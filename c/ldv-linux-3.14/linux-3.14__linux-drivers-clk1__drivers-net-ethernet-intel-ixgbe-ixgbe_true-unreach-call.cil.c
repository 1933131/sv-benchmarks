/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 7 ".tmp_ixgbe_main.c"
struct device;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/types.h"
typedef __u16 __le16;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/types.h"
typedef __u32 __be32;
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/types.h"
typedef __u64 __le64;
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 106 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.h"
struct ldv_thread;
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/thread.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 103 "/home/debian/klever/addons/aspectator-0efea3f/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.0/include/stdarg.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/export.h"
struct module;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 243 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 333
struct page;
#line 333 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 341
struct file;
#line 354
struct seq_file;
#line 387
struct thread_struct;
#line 389
struct mm_struct;
#line 390
struct task_struct;
#line 391
struct cpumask;
#line 392 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 327
struct arch_spinlock;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/rwlock.h"
struct __anonstruct____missing_field_name_17 {
   u32 read ;
   s32 write ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_16 {
   s64 lock ;
   struct __anonstruct____missing_field_name_17 __annonCompField8 ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_16 arch_rwlock_t;
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 212 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/printk.h"
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned int flags : 8 ;
};
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dynamic_debug.h"
struct net_device;
#line 376 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/printk.h"
struct file_operations;
#line 388
struct completion;
#line 416 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernel.h"
struct pid;
#line 449
enum system_states {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4
} ;
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/current.h"
struct lockdep_map;
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_18 __annonCompField9 ;
};
#line 306 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 663 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_23 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_22 {
   struct __anonstruct____missing_field_name_23 __annonCompField13 ;
   struct __anonstruct____missing_field_name_24 __annonCompField14 ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_22 __annonCompField15 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_25 __annonCompField16 ;
};
#line 346 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 377 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8U] ;
};
#line 381 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
#line 386 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 392 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
#line 401 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 456
struct kmem_cache;
#line 457
struct perf_event;
#line 458 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 2 ;
   unsigned int hardirqs_off : 1 ;
   unsigned int references : 11 ;
};
#line 537 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_29 __annonCompField18 ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_28 __annonCompField19 ;
};
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct timespec;
#line 75 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 80 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/jump_label.h"
struct jump_entry;
#line 54
struct static_key_mod;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
   struct jump_entry *entries ;
   struct static_key_mod *next ;
};
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 412 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 259 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_35 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 259 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_35 seqlock_t;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 223 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcupdate.h"
struct notifier_block;
#line 1039 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   unsigned long bitmap[4U] ;
   struct idr_layer *ary[256U] ;
   int count ;
   int layer ;
   struct callback_head callback_head ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   int cur ;
   spinlock_t lock ;
};
#line 197 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 213 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct dentry;
#line 88
struct iattr;
#line 89
struct vm_area_struct;
#line 90
struct super_block;
#line 91
struct file_system_type;
#line 92
struct kernfs_open_node;
#line 93
struct kernfs_iattrs;
#line 109
struct kernfs_root;
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kernfs_node;
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 66
struct kernfs_ops;
#line 66 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
union __anonunion_u_36 {
   struct completion *completion ;
   struct kernfs_node *removed_list ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
union __anonunion____missing_field_name_37 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   union __anonunion_u_36 u ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_37 __annonCompField21 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kernfs_dir_ops {
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   struct ida ino_ida ;
   struct kernfs_dir_ops *dir_ops ;
};
#line 137
struct vm_operations_struct;
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 376
struct sock;
#line 377
struct kobject;
#line 378
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 384 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/highuid.h"
struct user_namespace;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uidgid.h"
struct __anonstruct_kuid_t_38 {
   uid_t val ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_38 kuid_t;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uidgid.h"
struct __anonstruct_kgid_t_39 {
   gid_t val ;
};
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_39 kgid_t;
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/stat.h"
struct bin_attribute;
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 462 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 323 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 388
struct tvec_base;
#line 389 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 258 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timer.h"
struct hrtimer;
#line 259
enum hrtimer_restart;
#line 270
struct workqueue_struct;
#line 271
struct work_struct;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kobject.h"
struct kset;
#line 50
struct kobj_type;
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 112 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 144 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 219
struct klist_node;
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_40 {
   unsigned long bits[16U] ;
};
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_40 nodemask_t;
#line 522
struct path;
#line 523
struct inode;
#line 524 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 301
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 308
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 316
struct wakeup_source;
#line 527 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 534
struct dev_pm_qos;
#line 534 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool ignore_children : 1 ;
   bool early_init : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   bool syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int run_wake : 1 ;
   unsigned int runtime_auto : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   unsigned int memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 591 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 82 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[6U] ;
   unsigned long nr_free ;
};
#line 87
struct pglist_data;
#line 88 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct zone_padding {
   char x[0U] ;
};
#line 189 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2U] ;
   unsigned long recent_scanned[2U] ;
};
#line 202
struct zone;
#line 202 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5U] ;
   struct zone_reclaim_stat reclaim_stat ;
   struct zone *zone ;
};
#line 234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3U] ;
};
#line 247 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   s8 stat_threshold ;
   s8 vm_stat_diff[35U] ;
};
#line 257
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
#line 265 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct zone {
   unsigned long watermark[3U] ;
   unsigned long percpu_drift_mark ;
   unsigned long lowmem_reserve[4U] ;
   unsigned long dirty_balance_reserve ;
   int node ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   struct per_cpu_pageset *pageset ;
   spinlock_t lock ;
   bool compact_blockskip_flush ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn ;
   seqlock_t span_seqlock ;
   struct free_area free_area[11U] ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   struct zone_padding _pad1_ ;
   spinlock_t lru_lock ;
   struct lruvec lruvec ;
   unsigned long pages_scanned ;
   unsigned long flags ;
   atomic_long_t vm_stat[35U] ;
   unsigned int inactive_ratio ;
   struct zone_padding _pad2_ ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct pglist_data *zone_pgdat ;
   unsigned long zone_start_pfn ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   unsigned long managed_pages ;
   int nr_migrate_reserve_block ;
   char const   *name ;
};
#line 578 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct zonelist_cache {
   unsigned short z_to_n[4096U] ;
   unsigned long fullzones[64U] ;
   unsigned long last_full_zap ;
};
#line 665 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 678 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[4097U] ;
   struct zonelist_cache zlcache ;
};
#line 716 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4U] ;
   struct zonelist node_zonelists[2U] ;
   int nr_zones ;
   spinlock_t node_size_lock ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   nodemask_t reclaim_nodes ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
   enum zone_type classzone_idx ;
   spinlock_t numabalancing_migrate_lock ;
   unsigned long numabalancing_migrate_next_window ;
   unsigned long numabalancing_migrate_nr_pages ;
};
#line 776 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;
#line 799
struct rw_semaphore;
#line 800 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 891 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct ctl_table;
#line 172 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 133 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_105 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_105 mm_context_t;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/clocksource.h"
typedef u64 cycle_t;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/clocksource.h"
struct cyclecounter {
   cycle_t (*read)(struct cyclecounter  const  * ) ;
   cycle_t mask ;
   u32 mult ;
   u32 shift ;
};
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/clocksource.h"
struct timecounter {
   struct cyclecounter  const  *cc ;
   cycle_t cycle_last ;
   u64 nsec ;
};
#line 341
struct device_node;
#line 1276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mmzone.h"
struct llist_node;
#line 64 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 419 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/gfp.h"
struct dma_map_ops;
#line 419 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct iommu_ops;
#line 21
struct iommu_group;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct device_attribute;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195
struct of_device_id;
#line 195
struct acpi_device_id;
#line 195 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 637 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 646
struct acpi_device;
#line 647 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 653
struct dma_coherent_mem;
#line 653 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled : 1 ;
   bool offline : 1 ;
};
#line 795 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active : 1 ;
   bool autosleep_enabled : 1 ;
};
#line 91 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kdev_t.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cdev.h"
struct backing_dev_info;
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/miscdevice.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 269 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/plist.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 50
enum dev_pm_qos_req_type {
    DEV_PM_QOS_LATENCY = 1,
    DEV_PM_QOS_FLAGS = 2
} ;
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm_qos.h"
union __anonunion_data_133 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_133 data ;
   struct device *dev ;
};
#line 64
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 83 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 88 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints latency ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *latency_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 460 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rculist.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 54
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_135 {
   struct __anonstruct____missing_field_name_136 __annonCompField34 ;
   struct __anonstruct____missing_field_name_137 __annonCompField35 ;
};
#line 61
struct uprobe;
#line 61
struct return_instance;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_135 __annonCompField36 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
struct xol_area;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 129
struct address_space;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
struct __anonstruct____missing_field_name_144 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_143 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_144 __annonCompField39 ;
   int units ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
struct __anonstruct____missing_field_name_142 {
   union __anonunion____missing_field_name_143 __annonCompField40 ;
   atomic_t _count ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_141 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_142 __annonCompField41 ;
   unsigned int active ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
struct __anonstruct____missing_field_name_139 {
   union __anonunion____missing_field_name_140 __annonCompField38 ;
   union __anonunion____missing_field_name_141 __annonCompField42 ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 130
struct slab;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_146 __annonCompField44 ;
   struct list_head list ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_139 __annonCompField43 ;
   union __anonunion____missing_field_name_145 __annonCompField45 ;
   union __anonunion____missing_field_name_147 __annonCompField46 ;
   unsigned long debug_flags ;
};
#line 186 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 238
struct anon_vma;
#line 238
struct mempolicy;
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 310 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 329 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 342
struct kioctx_table;
#line 343
struct linux_binfmt;
#line 343
struct mmu_notifier_mm;
#line 343 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 71
struct file_ra_state;
#line 72
struct user_struct;
#line 73
struct writeback_control;
#line 185 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 210 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 2071 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 1156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 18
struct cred;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_151 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_151 sync_serial_settings;
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_152 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_152 te1_settings;
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_153 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_153 raw_hdlc_proto;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_154 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_154 fr_proto;
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_155 {
   unsigned int dlci ;
};
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_155 fr_proto_pvc;
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_156 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_156 fr_proto_pvc_info;
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_157 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_157 cisco_proto;
#line 95 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_158 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_158 ifs_ifsu ;
};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_159 {
   char ifrn_name[16U] ;
};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_160 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_159 ifr_ifrn ;
   union __anonunion_ifr_ifru_160 ifr_ifru ;
};
#line 233
struct hlist_bl_node;
#line 233 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_163 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rculist_bl.h"
union __anonunion____missing_field_name_162 {
   struct __anonstruct____missing_field_name_163 __annonCompField47 ;
};
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_162 __annonCompField48 ;
};
#line 49 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockref.h"
struct nameidata;
#line 50
struct vfsmount;
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockref.h"
struct __anonstruct____missing_field_name_165 {
   u32 hash ;
   u32 len ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockref.h"
union __anonunion____missing_field_name_164 {
   struct __anonstruct____missing_field_name_165 __annonCompField49 ;
   u64 hash_len ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_164 __annonCompField50 ;
   unsigned char const   *name ;
};
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dcache.h"
union __anonunion_d_u_166 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_166 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 469 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 381
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 388
struct pid_namespace;
#line 388 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/fs.h"
struct export_operations;
#line 58
struct kiocb;
#line 59
struct pipe_inode_info;
#line 60
struct poll_table_struct;
#line 61
struct kstatfs;
#line 62
struct swap_info_struct;
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/projid.h"
struct __anonstruct_kprojid_t_168 {
   projid_t val ;
};
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_168 kprojid_t;
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
union __anonunion____missing_field_name_169 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_169 __annonCompField51 ;
   enum quota_type type ;
};
#line 178 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
};
#line 333 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 379 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
union __anonunion_arg_171 {
   char *buf ;
   void *data ;
};
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_170 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_171 arg ;
   int error ;
};
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_170 read_descriptor_t;
#line 348 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 408 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 430
struct request_queue;
#line 431
struct hd_struct;
#line 431
struct gendisk;
#line 431 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 503
struct posix_acl;
#line 504
struct inode_operations;
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_172 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_173 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 504
struct file_lock;
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_174 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_172 __annonCompField52 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_173 __annonCompField53 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_174 __annonCompField54 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 740 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 748 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 771 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
union __anonunion_f_u_175 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 771 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_175 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 909
struct files_struct;
#line 909 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 910 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 915 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 928
struct net;
#line 933
struct nlm_lockowner;
#line 934 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_177 {
   struct list_head link ;
   int state ;
};
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_176 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_177 afs ;
};
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_176 fl_u ;
};
#line 1036 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1228 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1244
struct super_operations;
#line 1244
struct xattr_handler;
#line 1244
struct mtd_info;
#line 1244 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
#line 1474 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1512 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1517 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1600 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1814 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 4 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_178 {
   unsigned long sig[1U] ;
};
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_178 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_180 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_181 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_183 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_184 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_185 {
   long _band ;
   int _fd ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_186 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_179 {
   int _pad[28U] ;
   struct __anonstruct__kill_180 _kill ;
   struct __anonstruct__timer_181 _timer ;
   struct __anonstruct__rt_182 _rt ;
   struct __anonstruct__sigchld_183 _sigchld ;
   struct __anonstruct__sigfault_184 _sigfault ;
   struct __anonstruct__sigpoll_185 _sigpoll ;
   struct __anonstruct__sigsys_186 _sigsys ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_179 _sifields ;
};
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 251 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 265 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 463 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 835 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct __anonstruct____missing_field_name_190 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
union __anonunion____missing_field_name_189 {
   struct __anonstruct____missing_field_name_190 __annonCompField55 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_189 __annonCompField56 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 193
struct assoc_array_ptr;
#line 193 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sysctl.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_191 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_192 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
struct __anonstruct____missing_field_name_194 {
   struct key_type *type ;
   char *description ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_193 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_194 __annonCompField59 ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
union __anonunion_type_data_195 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
union __anonunion_payload_197 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_196 {
   union __anonunion_payload_197 payload ;
   struct assoc_array keys ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_191 __annonCompField57 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_192 __annonCompField58 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_193 __annonCompField60 ;
   union __anonunion_type_data_195 type_data ;
   union __anonunion____missing_field_name_196 __annonCompField61 ;
};
#line 345
struct audit_context;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct futex_pi_state;
#line 124
struct robust_list_head;
#line 125
struct bio_list;
#line 126
struct fs_struct;
#line 127
struct perf_event_context;
#line 128
struct blk_plug;
#line 180
struct cfs_rq;
#line 181
struct task_group;
#line 421 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 460 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 468 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 475 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 487 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 507 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 549
struct autogroup;
#line 550
struct tty_struct;
#line 550
struct taskstats;
#line 550
struct tty_audit_buf;
#line 550 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int is_child_subreaper : 1 ;
   unsigned int has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 730 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 774
struct reclaim_state;
#line 775 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 790 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1004
struct uts_namespace;
#line 1005 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1013 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1025 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1060 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1091
struct rt_rq;
#line 1091 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1107 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   struct hrtimer dl_timer ;
};
#line 1162
struct mem_cgroup;
#line 1162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1569 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int may_oom : 1 ;
};
#line 1576
struct sched_class;
#line 1576
struct css_set;
#line 1576
struct compat_robust_list_head;
#line 1576
struct numa_group;
#line 1576
struct ftrace_ret_stack;
#line 1576 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned int brk_randomized : 1 ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int no_new_privs : 1 ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   int numa_migrate_deferred ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 273 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 277 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/random.h"
enum ldv_21583 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/net.h"
typedef enum ldv_21583 socket_state;
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/net.h"
struct proto_ops;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
struct __anonstruct____missing_field_name_214 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
struct __anonstruct____missing_field_name_215 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
union __anonunion____missing_field_name_213 {
   struct __anonstruct____missing_field_name_214 __annonCompField63 ;
   struct __anonstruct____missing_field_name_215 __annonCompField64 ;
};
#line 497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion____missing_field_name_213 __annonCompField65 ;
};
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/checksum.h"
struct sk_buff;
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 136 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 172
struct skb_frag_struct;
#line 172 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 173 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct __anonstruct_page_217 {
   struct page *p ;
};
#line 173 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_217 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 206 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
   ktime_t syststamp ;
};
#line 275 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 354 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 355
struct sec_path;
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct __anonstruct____missing_field_name_219 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_218 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_219 __annonCompField67 ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_220 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_221 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   ktime_t tstamp ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion____missing_field_name_218 __annonCompField68 ;
   __u32 priority ;
   __u8 local_df : 1 ;
   __u8 cloned : 1 ;
   __u8 ip_summed : 2 ;
   __u8 nohdr : 1 ;
   __u8 nfctinfo : 3 ;
   __u8 pkt_type : 3 ;
   __u8 fclone : 2 ;
   __u8 ipvs_property : 1 ;
   __u8 peeked : 1 ;
   __u8 nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 rxhash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   __u8 ndisc_nodetype : 2 ;
   __u8 pfmemalloc : 1 ;
   __u8 ooo_okay : 1 ;
   __u8 l4_rxhash : 1 ;
   __u8 wifi_acked_valid : 1 ;
   __u8 wifi_acked : 1 ;
   __u8 no_fcs : 1 ;
   __u8 head_frag : 1 ;
   __u8 encapsulation : 1 ;
   union __anonunion____missing_field_name_220 __annonCompField69 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_221 __annonCompField70 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 578
struct dst_entry;
#line 646
struct rtable;
#line 2939 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 105 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 128 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 303 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 331 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 382 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 404 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 425 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 458 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 474 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 494 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 505 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 524 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 550 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 684 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 692 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 768 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh_indir)(struct net_device * , u32 * ) ;
   int (*set_rxfh_indir)(struct net_device * , u32 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 249
struct prot_inuse;
#line 250 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ethtool.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct u64_stats_sync {

};
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 83 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[97U] ;
};
#line 112 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118
struct proc_dir_entry;
#line 118 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics[1U] ;
   struct ipstats_mib *ip_statistics[1U] ;
   struct linux_mib *net_statistics[1U] ;
   struct udp_mib *udp_statistics[1U] ;
   struct udp_mib *udplite_statistics[1U] ;
   struct icmp_mib *icmp_statistics[1U] ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6[1U] ;
   struct udp_mib *udplite_stats_in6[1U] ;
   struct ipstats_mib *ipv6_statistics[1U] ;
   struct icmpv6_mib *icmpv6_statistics[1U] ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics[1U] ;
};
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 180 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 181
struct ipv4_devconf;
#line 182
struct fib_rules_ops;
#line 183
struct fib_table;
#line 184 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/ipv4.h"
struct inet_peer_base;
#line 22
struct xt_table;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports sysctl_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   kgid_t sysctl_ping_group_range[2U] ;
   atomic_t dev_addr_genid ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 90
struct neighbour;
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
};
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 34
struct rt6_info;
#line 34
struct rt6_statistics;
#line 34
struct fib6_table;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 85
struct sctp_mib;
#line 86 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/ipv6.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics[1U] ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 104 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/in.h"
union __anonunion_in6_u_224 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 104 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/in.h"
struct in6_addr {
   union __anonunion_in6_u_224 in6_u ;
};
#line 324 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netfilter.h"
struct nlattr;
#line 337
struct nf_logger;
#line 338 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 52 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 63
struct ip_conntrack_stat;
#line 63
struct nf_ct_event_notifier;
#line 63
struct nf_exp_event_notifier;
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 104
struct nft_af_info;
#line 105 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
#line 489 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   spinlock_t xfrm_policy_sk_bundle_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
};
#line 65
struct net_generic;
#line 66
struct netns_ipvs;
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 395 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 200 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/prio_heap.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/xattr.h"
struct simple_xattrs {
   struct list_head head ;
   spinlock_t lock ;
};
#line 98
struct percpu_ref;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 173
struct cgroupfs_root;
#line 174
struct cgroup_subsys;
#line 175
struct cgroup;
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   unsigned long flags ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cgroup.h"
struct cgroup_name {
   struct callback_head callback_head ;
   char name[] ;
};
#line 160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   int id ;
   int nr_css ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   u64 serial_nr ;
   struct cgroup_name *name ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroupfs_root *root ;
   struct list_head cset_links ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct cgroup_subsys_state dummy_css ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
   struct simple_xattrs xattrs ;
};
#line 252 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cgroup.h"
struct cgroupfs_root {
   struct super_block *sb ;
   unsigned long subsys_mask ;
   int hierarchy_id ;
   struct cgroup top_cgroup ;
   int number_of_cgroups ;
   struct list_head root_list ;
   unsigned long flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 342 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cgrp_links ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct callback_head callback_head ;
};
#line 392 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   int (*write_string)(struct cgroup_subsys_state * , struct cftype * , char const   * ) ;
   int (*trigger)(struct cgroup_subsys_state * , unsigned int  ) ;
};
#line 479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cgroup.h"
struct cftype_set {
   struct list_head node ;
   struct cftype *cfts ;
};
#line 546
struct cgroup_taskset;
#line 557 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int subsys_id ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   char const   *name ;
   struct cgroupfs_root *root ;
   struct list_head cftsets ;
   struct cftype *base_cftypes ;
   struct cftype_set base_cftset ;
   struct module *module ;
};
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/vtime.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/hardirq.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 103 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/security.h"
struct xfrm_policy;
#line 104
struct xfrm_state;
#line 124
struct request_sock;
#line 3157
struct mnt_namespace;
#line 3158
struct ipc_namespace;
#line 3159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 171 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 288
enum macvlan_mode {
    MACVLAN_MODE_PRIVATE = 1,
    MACVLAN_MODE_VEPA = 2,
    MACVLAN_MODE_BRIDGE = 4,
    MACVLAN_MODE_PASSTHRU = 8
} ;
#line 536 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 tx_rate ;
   __u32 spoofchk ;
   __u32 linkstate ;
};
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_link.h"
struct netpoll_info;
#line 28
struct phy_device;
#line 29
struct wireless_dev;
#line 64 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 116 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 196
struct neigh_parms;
#line 197 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 222 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 251 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 302 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 337
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
} ;
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 346
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 394 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 395 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 532
struct Qdisc;
#line 532 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 594 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 606 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 618 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 669 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 692 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 705 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 716 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 727 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 743 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 756 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * , gfp_t  ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_tx_rate)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
};
#line 1147
enum ldv_27941 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
} ;
#line 1156
enum ldv_27942 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
} ;
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct __anonstruct_adj_list_235 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_236 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1161
struct iw_handler_def;
#line 1161
struct iw_public_data;
#line 1161
struct forwarding_accel_ops;
#line 1161
struct vlan_info;
#line 1161
struct tipc_bearer;
#line 1161
struct in_device;
#line 1161
struct dn_dev;
#line 1161
struct inet6_dev;
#line 1161
struct cpu_rmap;
#line 1161
struct pcpu_lstats;
#line 1161
struct pcpu_sw_netstats;
#line 1161
struct pcpu_dstats;
#line 1161
struct pcpu_vstats;
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
union __anonunion____missing_field_name_237 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1161
struct garp_port;
#line 1161
struct mrp_port;
#line 1161
struct rtnl_link_ops;
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_235 adj_list ;
   struct __anonstruct_all_adj_list_236 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct forwarding_accel_ops  const  *fwd_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   enum ldv_27941 reg_state : 8 ;
   bool dismantle ;
   enum ldv_27942 rtnl_link_state : 16 ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion____missing_field_name_237 __annonCompField74 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 1722 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 2465
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 13 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/io.h"
struct hotplug_slot;
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/io.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
typedef int pci_power_t;
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 180 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 186
enum pcie_link_width {
    PCIE_LNK_WIDTH_RESRV = 0,
    PCIE_LNK_X1 = 1,
    PCIE_LNK_X2 = 2,
    PCIE_LNK_X4 = 4,
    PCIE_LNK_X8 = 8,
    PCIE_LNK_X12 = 12,
    PCIE_LNK_X16 = 16,
    PCIE_LNK_X32 = 32,
    PCIE_LNK_WIDTH_UNKNOWN = 255
} ;
#line 198
enum pci_bus_speed {
    PCI_SPEED_33MHz = 0,
    PCI_SPEED_66MHz = 1,
    PCI_SPEED_66MHz_PCIX = 2,
    PCI_SPEED_100MHz_PCIX = 3,
    PCI_SPEED_133MHz_PCIX = 4,
    PCI_SPEED_66MHz_PCIX_ECC = 5,
    PCI_SPEED_100MHz_PCIX_ECC = 6,
    PCI_SPEED_133MHz_PCIX_ECC = 7,
    PCI_SPEED_66MHz_PCIX_266 = 9,
    PCI_SPEED_100MHz_PCIX_266 = 10,
    PCI_SPEED_133MHz_PCIX_266 = 11,
    AGP_UNKNOWN = 12,
    AGP_1X = 13,
    AGP_2X = 14,
    AGP_4X = 15,
    AGP_8X = 16,
    PCI_SPEED_66MHz_PCIX_533 = 17,
    PCI_SPEED_100MHz_PCIX_533 = 18,
    PCI_SPEED_133MHz_PCIX_533 = 19,
    PCIE_SPEED_2_5GT = 20,
    PCIE_SPEED_5_0GT = 21,
    PCIE_SPEED_8_0GT = 22,
    PCI_SPEED_UNKNOWN = 255
} ;
#line 237
struct pcie_link_state;
#line 238
struct pci_vpd;
#line 239
struct pci_sriov;
#line 240
struct pci_ats;
#line 241
struct pci_driver;
#line 241 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
union __anonunion____missing_field_name_241 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 241 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_interrupt : 1 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int no_d3cold : 1 ;
   unsigned int d3cold_allowed : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_cfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   unsigned int broken_intx_masking : 1 ;
   unsigned int io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_241 __annonCompField75 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 429
struct pci_ops;
#line 429
struct msi_chip;
#line 429 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_chip *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 534 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 569 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 579 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 609 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dmapool.h"
struct dma_pool;
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elf.h"
struct kernel_param;
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_246 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion____missing_field_name_246 __annonCompField76 ;
};
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 463
struct tracepoint;
#line 464 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/moduleparam.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 92 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/tracepoint.h"
struct mod_arch_specific {

};
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 208
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 215 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 229
struct module_sect_attrs;
#line 229
struct module_notes_attrs;
#line 229
struct ftrace_event_call;
#line 229 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 618 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/interrupt.h"
struct iphdr {
   __u8 ihl : 4 ;
   __u8 version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 615 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/memcontrol.h"
struct res_counter {
   unsigned long long usage ;
   unsigned long long max_usage ;
   unsigned long long limit ;
   unsigned long long soft_limit ;
   unsigned long long failcnt ;
   spinlock_t lock ;
   struct res_counter *parent ;
};
#line 226 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/res_counter.h"
struct kioctx;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/aio.h"
typedef int kiocb_cancel_fn(struct kiocb * );
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/aio.h"
union __anonunion_ki_obj_247 {
   void *user ;
   struct task_struct *tsk ;
};
#line 31
struct eventfd_ctx;
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/aio.h"
struct kiocb {
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   kiocb_cancel_fn *ki_cancel ;
   void *private ;
   union __anonunion_ki_obj_247 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   size_t ki_nbytes ;
   struct list_head ki_list ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 100 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/aio.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/filter.h"
union __anonunion____missing_field_name_248 {
   struct sock_filter insns[0U] ;
   struct work_struct work ;
};
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   unsigned int len ;
   struct callback_head rcu ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct sock_filter  const  * ) ;
   union __anonunion____missing_field_name_248 __annonCompField77 ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 108 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy  const  *slave_policy ;
   int (*slave_validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*slave_changelink)(struct net_device * , struct net_device * , struct nlattr ** ,
                           struct nlattr ** ) ;
   size_t (*get_slave_size)(struct net_device  const  * , struct net_device  const  * ) ;
   int (*fill_slave_info)(struct sk_buff * , struct net_device  const  * , struct net_device  const  * ) ;
};
#line 167
struct neigh_table;
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/rtnetlink.h"
struct neigh_parms {
   struct net *net ;
   struct net_device *dev ;
   struct neigh_parms *next ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[12U] ;
   unsigned long data_state[1U] ;
};
#line 111 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 130
struct neigh_ops;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   struct net *net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 177 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 190 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/neighbour.h"
struct neigh_table {
   struct neigh_table *next ;
   int family ;
   int entry_size ;
   int key_len ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 462
struct dn_route;
#line 462 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/neighbour.h"
union __anonunion____missing_field_name_253 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 462 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion____missing_field_name_253 __annonCompField78 ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
struct __anonstruct_socket_lock_t_254 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_254 socket_lock_t;
#line 123
struct proto;
#line 129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
typedef __u32 __portpair;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
typedef __u64 __addrpair;
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
struct __anonstruct____missing_field_name_256 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_255 {
   __addrpair skc_addrpair ;
   struct __anonstruct____missing_field_name_256 __annonCompField79 ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_257 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
struct __anonstruct____missing_field_name_259 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_258 {
   __portpair skc_portpair ;
   struct __anonstruct____missing_field_name_259 __annonCompField82 ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_260 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_261 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
struct sock_common {
   union __anonunion____missing_field_name_255 __annonCompField80 ;
   union __anonunion____missing_field_name_257 __annonCompField81 ;
   union __anonunion____missing_field_name_258 __annonCompField83 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 4 ;
   int skc_bound_dev_if ;
   union __anonunion____missing_field_name_260 __annonCompField84 ;
   struct proto *skc_prot ;
   struct net *skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion____missing_field_name_261 __annonCompField85 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 216
struct cg_proto;
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
struct __anonstruct_sk_backlog_262 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_262 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int sk_shutdown : 2 ;
   unsigned int sk_no_check : 2 ;
   unsigned int sk_userlocks : 4 ;
   unsigned int sk_protocol : 8 ;
   unsigned int sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   unsigned short sk_ack_backlog ;
   unsigned short sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   void *sk_protinfo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * , int  ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 901
struct request_sock_ops;
#line 902
struct timewait_sock_ops;
#line 903
struct inet_hashinfo;
#line 904
struct raw_hashinfo;
#line 919
struct udp_table;
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
union __anonunion_h_263 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  , int  ,
                  int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*mtu_reduced)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock  const  * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_263 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 1044 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/sock.h"
struct cg_proto {
   struct res_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct sock * , struct request_sock * ) ;
};
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   u16 mss ;
   u8 num_retrans ;
   u8 cookie_ts : 1 ;
   u8 num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   unsigned long expires ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 secid ;
   u32 peer_secid ;
};
#line 372 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 219 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inet_timewait_sock.h"
struct tcphdr {
   __be16 source ;
   __be16 dest ;
   __be32 seq ;
   __be32 ack_seq ;
   __u16 res1 : 4 ;
   __u16 doff : 4 ;
   __u16 fin : 1 ;
   __u16 syn : 1 ;
   __u16 rst : 1 ;
   __u16 psh : 1 ;
   __u16 ack : 1 ;
   __u16 urg : 1 ;
   __u16 ece : 1 ;
   __u16 cwr : 1 ;
   __be16 window ;
   __sum16 check ;
   __be16 urg_ptr ;
};
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 priority : 4 ;
   __u8 version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 optimistic_dad ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   void *sysctl ;
};
#line 101 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 110 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   spinlock_t aca_lock ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
#line 154 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6[1U] ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 852 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/ipv6.h"
union __anonunion____missing_field_name_280 {
   __be32 a4 ;
   __be32 a6[4U] ;
};
#line 852 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion____missing_field_name_280 __annonCompField87 ;
};
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inetpeer.h"
union __anonunion____missing_field_name_281 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inetpeer.h"
struct __anonstruct____missing_field_name_283 {
   atomic_t rid ;
   atomic_t ip_id_count ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inetpeer.h"
union __anonunion____missing_field_name_282 {
   struct __anonstruct____missing_field_name_283 __annonCompField89 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[15U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion____missing_field_name_281 __annonCompField88 ;
   union __anonunion____missing_field_name_282 __annonCompField90 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   u32 flush_seq ;
   int total ;
};
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
};
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/if_vlan.h"
struct vlan_hdr {
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 80 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_vlan.h"
struct vlan_pcpu_stats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 rx_multicast ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
   u32 rx_errors ;
   u32 tx_dropped ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_macvlan.h"
struct macvlan_port;
#line 15
struct macvtap_queue;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_macvlan.h"
struct macvlan_dev {
   struct net_device *dev ;
   struct list_head list ;
   struct hlist_node hlist ;
   struct macvlan_port *port ;
   struct net_device *lowerdev ;
   void *fwd_priv ;
   struct vlan_pcpu_stats *pcpu_stats ;
   unsigned long mc_filter[4U] ;
   netdev_features_t set_features ;
   enum macvlan_mode mode ;
   u16 flags ;
   struct macvtap_queue *taps[16U] ;
   struct list_head queue_list ;
   int numvtaps ;
   int numqueues ;
   netdev_features_t tap_features ;
   int minor ;
};
#line 135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pps_kernel.h"
struct ptp_clock_time {
   __s64 sec ;
   __u32 nsec ;
   __u32 reserved ;
};
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ptp_clock.h"
struct ptp_extts_request {
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[2U] ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ptp_clock.h"
struct ptp_perout_request {
   struct ptp_clock_time start ;
   struct ptp_clock_time period ;
   unsigned int index ;
   unsigned int flags ;
   unsigned int rsv[4U] ;
};
#line 97
enum ldv_34995 {
    PTP_CLK_REQ_EXTTS = 0,
    PTP_CLK_REQ_PEROUT = 1,
    PTP_CLK_REQ_PPS = 2
} ;
#line 103 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ptp_clock.h"
union __anonunion____missing_field_name_288 {
   struct ptp_extts_request extts ;
   struct ptp_perout_request perout ;
};
#line 103 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ptp_clock.h"
struct ptp_clock_request {
   enum ldv_34995 type ;
   union __anonunion____missing_field_name_288 __annonCompField92 ;
};
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ptp_clock_kernel.h"
struct ptp_clock_info {
   struct module *owner ;
   char name[16U] ;
   s32 max_adj ;
   int n_alarm ;
   int n_ext_ts ;
   int n_per_out ;
   int pps ;
   int (*adjfreq)(struct ptp_clock_info * , s32  ) ;
   int (*adjtime)(struct ptp_clock_info * , s64  ) ;
   int (*gettime)(struct ptp_clock_info * , struct timespec * ) ;
   int (*settime)(struct ptp_clock_info * , struct timespec  const  * ) ;
   int (*enable)(struct ptp_clock_info * , struct ptp_clock_request * , int  ) ;
};
#line 93
struct ptp_clock;
#line 158 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ptp_clock_kernel.h"
struct mii_ioctl_data {
   __u16 phy_id ;
   __u16 reg_num ;
   __u16 val_in ;
   __u16 val_out ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mdio.h"
struct mdio_if_info {
   int prtad ;
   u32 mmds ;
   unsigned int mode_support ;
   struct net_device *dev ;
   int (*mdio_read)(struct net_device * , int  , int  , u16  ) ;
   int (*mdio_write)(struct net_device * , int  , int  , u16  , u16  ) ;
};
#line 175 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mdio.h"
struct ixgbe_thermal_diode_data {
   u8 location ;
   u8 temp ;
   u8 caution_thresh ;
   u8 max_op_thresh ;
};
#line 135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_thermal_sensor_data {
   struct ixgbe_thermal_diode_data sensor[3U] ;
};
#line 2300 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_read_291 {
   __le64 buffer_addr ;
   __le32 cmd_type_len ;
   __le32 olinfo_status ;
};
#line 2300 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_wb_292 {
   __le64 rsvd ;
   __le32 nxtseq_seed ;
   __le32 status ;
};
#line 2300 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_adv_tx_desc {
   struct __anonstruct_read_291 read ;
   struct __anonstruct_wb_292 wb ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_read_293 {
   __le64 pkt_addr ;
   __le64 hdr_addr ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_hs_rss_297 {
   __le16 pkt_info ;
   __le16 hdr_info ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_lo_dword_296 {
   __le32 data ;
   struct __anonstruct_hs_rss_297 hs_rss ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_csum_ip_299 {
   __le16 ip_id ;
   __le16 csum ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_hi_dword_298 {
   __le32 rss ;
   struct __anonstruct_csum_ip_299 csum_ip ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_lower_295 {
   union __anonunion_lo_dword_296 lo_dword ;
   union __anonunion_hi_dword_298 hi_dword ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_upper_300 {
   __le32 status_error ;
   __le16 length ;
   __le16 vlan ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_wb_294 {
   struct __anonstruct_lower_295 lower ;
   struct __anonstruct_upper_300 upper ;
};
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_adv_rx_desc {
   struct __anonstruct_read_293 read ;
   struct __anonstruct_wb_294 wb ;
};
#line 2411 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
typedef u32 ixgbe_autoneg_advertised;
#line 2413 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
typedef u32 ixgbe_link_speed;
#line 2438 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_formatted_301 {
   u8 vm_pool ;
   u8 flow_type ;
   __be16 vlan_id ;
   __be32 dst_ip[4U] ;
   __be32 src_ip[4U] ;
   __be16 src_port ;
   __be16 dst_port ;
   __be16 flex_bytes ;
   __be16 bkt_hash ;
};
#line 2438 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_atr_input {
   struct __anonstruct_formatted_301 formatted ;
   __be32 dword_stream[11U] ;
};
#line 2555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_formatted_302 {
   u8 vm_pool ;
   u8 flow_type ;
   __be16 vlan_id ;
};
#line 2555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct __anonstruct_port_303 {
   __be16 src ;
   __be16 dst ;
};
#line 2555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union ixgbe_atr_hash_dword {
   struct __anonstruct_formatted_302 formatted ;
   __be32 ip ;
   struct __anonstruct_port_303 port ;
   __be16 flex_bytes ;
   __be32 dword ;
};
#line 2571
enum ixgbe_eeprom_type {
    ixgbe_eeprom_uninitialized = 0,
    ixgbe_eeprom_spi = 1,
    ixgbe_flash = 2,
    ixgbe_eeprom_none = 3
} ;
#line 2578
enum ixgbe_mac_type {
    ixgbe_mac_unknown = 0,
    ixgbe_mac_82598EB = 1,
    ixgbe_mac_82599EB = 2,
    ixgbe_mac_X540 = 3,
    ixgbe_num_macs = 4
} ;
#line 2586
enum ixgbe_phy_type {
    ixgbe_phy_unknown = 0,
    ixgbe_phy_none = 1,
    ixgbe_phy_tn = 2,
    ixgbe_phy_aq = 3,
    ixgbe_phy_cu_unknown = 4,
    ixgbe_phy_qt = 5,
    ixgbe_phy_xaui = 6,
    ixgbe_phy_nl = 7,
    ixgbe_phy_sfp_passive_tyco = 8,
    ixgbe_phy_sfp_passive_unknown = 9,
    ixgbe_phy_sfp_active_unknown = 10,
    ixgbe_phy_sfp_avago = 11,
    ixgbe_phy_sfp_ftl = 12,
    ixgbe_phy_sfp_ftl_active = 13,
    ixgbe_phy_sfp_unknown = 14,
    ixgbe_phy_sfp_intel = 15,
    ixgbe_phy_qsfp_passive_unknown = 16,
    ixgbe_phy_qsfp_active_unknown = 17,
    ixgbe_phy_qsfp_intel = 18,
    ixgbe_phy_qsfp_unknown = 19,
    ixgbe_phy_sfp_unsupported = 20,
    ixgbe_phy_generic = 21
} ;
#line 2611
enum ixgbe_sfp_type {
    ixgbe_sfp_type_da_cu = 0,
    ixgbe_sfp_type_sr = 1,
    ixgbe_sfp_type_lr = 2,
    ixgbe_sfp_type_da_cu_core0 = 3,
    ixgbe_sfp_type_da_cu_core1 = 4,
    ixgbe_sfp_type_srlr_core0 = 5,
    ixgbe_sfp_type_srlr_core1 = 6,
    ixgbe_sfp_type_da_act_lmt_core0 = 7,
    ixgbe_sfp_type_da_act_lmt_core1 = 8,
    ixgbe_sfp_type_1g_cu_core0 = 9,
    ixgbe_sfp_type_1g_cu_core1 = 10,
    ixgbe_sfp_type_1g_sx_core0 = 11,
    ixgbe_sfp_type_1g_sx_core1 = 12,
    ixgbe_sfp_type_1g_lx_core0 = 13,
    ixgbe_sfp_type_1g_lx_core1 = 14,
    ixgbe_sfp_type_not_present = 65534,
    ixgbe_sfp_type_unknown = 65535
} ;
#line 2631
enum ixgbe_media_type {
    ixgbe_media_type_unknown = 0,
    ixgbe_media_type_fiber = 1,
    ixgbe_media_type_fiber_fixed = 2,
    ixgbe_media_type_fiber_qsfp = 3,
    ixgbe_media_type_fiber_lco = 4,
    ixgbe_media_type_copper = 5,
    ixgbe_media_type_backplane = 6,
    ixgbe_media_type_cx4 = 7,
    ixgbe_media_type_virtual = 8
} ;
#line 2643
enum ixgbe_fc_mode {
    ixgbe_fc_none = 0,
    ixgbe_fc_rx_pause = 1,
    ixgbe_fc_tx_pause = 2,
    ixgbe_fc_full = 3,
    ixgbe_fc_default = 4
} ;
#line 2651
enum ixgbe_smart_speed {
    ixgbe_smart_speed_auto = 0,
    ixgbe_smart_speed_on = 1,
    ixgbe_smart_speed_off = 2
} ;
#line 2657
enum ixgbe_bus_type {
    ixgbe_bus_type_unknown = 0,
    ixgbe_bus_type_pci = 1,
    ixgbe_bus_type_pcix = 2,
    ixgbe_bus_type_pci_express = 3,
    ixgbe_bus_type_reserved = 4
} ;
#line 2665
enum ixgbe_bus_speed {
    ixgbe_bus_speed_unknown = 0,
    ixgbe_bus_speed_33 = 33,
    ixgbe_bus_speed_66 = 66,
    ixgbe_bus_speed_100 = 100,
    ixgbe_bus_speed_120 = 120,
    ixgbe_bus_speed_133 = 133,
    ixgbe_bus_speed_2500 = 2500,
    ixgbe_bus_speed_5000 = 5000,
    ixgbe_bus_speed_8000 = 8000,
    ixgbe_bus_speed_reserved = 8001
} ;
#line 2678
enum ixgbe_bus_width {
    ixgbe_bus_width_unknown = 0,
    ixgbe_bus_width_pcie_x1 = 1,
    ixgbe_bus_width_pcie_x2 = 2,
    ixgbe_bus_width_pcie_x4 = 4,
    ixgbe_bus_width_pcie_x8 = 8,
    ixgbe_bus_width_32 = 32,
    ixgbe_bus_width_64 = 64,
    ixgbe_bus_width_reserved = 65
} ;
#line 2689 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_addr_filter_info {
   u32 num_mc_addrs ;
   u32 rar_used_count ;
   u32 mta_in_use ;
   u32 overflow_promisc ;
   bool uc_set_promisc ;
   bool user_set_promisc ;
};
#line 2717 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_bus_info {
   enum ixgbe_bus_speed speed ;
   enum ixgbe_bus_width width ;
   enum ixgbe_bus_type type ;
   u16 func ;
   u16 lan_id ;
};
#line 2727 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_fc_info {
   u32 high_water[8U] ;
   u32 low_water ;
   u16 pause_time ;
   bool send_xon ;
   bool strict_ieee ;
   bool disable_fc_autoneg ;
   bool fc_was_autonegged ;
   enum ixgbe_fc_mode current_mode ;
   enum ixgbe_fc_mode requested_mode ;
};
#line 2740 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hw_stats {
   u64 crcerrs ;
   u64 illerrc ;
   u64 errbc ;
   u64 mspdc ;
   u64 mpctotal ;
   u64 mpc[8U] ;
   u64 mlfc ;
   u64 mrfc ;
   u64 rlec ;
   u64 lxontxc ;
   u64 lxonrxc ;
   u64 lxofftxc ;
   u64 lxoffrxc ;
   u64 pxontxc[8U] ;
   u64 pxonrxc[8U] ;
   u64 pxofftxc[8U] ;
   u64 pxoffrxc[8U] ;
   u64 prc64 ;
   u64 prc127 ;
   u64 prc255 ;
   u64 prc511 ;
   u64 prc1023 ;
   u64 prc1522 ;
   u64 gprc ;
   u64 bprc ;
   u64 mprc ;
   u64 gptc ;
   u64 gorc ;
   u64 gotc ;
   u64 rnbc[8U] ;
   u64 ruc ;
   u64 rfc ;
   u64 roc ;
   u64 rjc ;
   u64 mngprc ;
   u64 mngpdc ;
   u64 mngptc ;
   u64 tor ;
   u64 tpr ;
   u64 tpt ;
   u64 ptc64 ;
   u64 ptc127 ;
   u64 ptc255 ;
   u64 ptc511 ;
   u64 ptc1023 ;
   u64 ptc1522 ;
   u64 mptc ;
   u64 bptc ;
   u64 xec ;
   u64 rqsmr[16U] ;
   u64 tqsmr[8U] ;
   u64 qprc[16U] ;
   u64 qptc[16U] ;
   u64 qbrc[16U] ;
   u64 qbtc[16U] ;
   u64 qprdc[16U] ;
   u64 pxon2offc[8U] ;
   u64 fdirustat_add ;
   u64 fdirustat_remove ;
   u64 fdirfstat_fadd ;
   u64 fdirfstat_fremove ;
   u64 fdirmatch ;
   u64 fdirmiss ;
   u64 fccrc ;
   u64 fcoerpdc ;
   u64 fcoeprc ;
   u64 fcoeptc ;
   u64 fcoedwrc ;
   u64 fcoedwtc ;
   u64 fcoe_noddp ;
   u64 fcoe_noddp_ext_buff ;
   u64 b2ospc ;
   u64 b2ogprc ;
   u64 o2bgptc ;
   u64 o2bspc ;
};
#line 2819
struct ixgbe_hw;
#line 2825 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_eeprom_operations {
   s32 (*init_params)(struct ixgbe_hw * ) ;
   s32 (*read)(struct ixgbe_hw * , u16  , u16 * ) ;
   s32 (*read_buffer)(struct ixgbe_hw * , u16  , u16  , u16 * ) ;
   s32 (*write)(struct ixgbe_hw * , u16  , u16  ) ;
   s32 (*write_buffer)(struct ixgbe_hw * , u16  , u16  , u16 * ) ;
   s32 (*validate_checksum)(struct ixgbe_hw * , u16 * ) ;
   s32 (*update_checksum)(struct ixgbe_hw * ) ;
   u16 (*calc_checksum)(struct ixgbe_hw * ) ;
};
#line 2838 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mac_operations {
   s32 (*init_hw)(struct ixgbe_hw * ) ;
   s32 (*reset_hw)(struct ixgbe_hw * ) ;
   s32 (*start_hw)(struct ixgbe_hw * ) ;
   s32 (*clear_hw_cntrs)(struct ixgbe_hw * ) ;
   enum ixgbe_media_type (*get_media_type)(struct ixgbe_hw * ) ;
   u32 (*get_supported_physical_layer)(struct ixgbe_hw * ) ;
   s32 (*get_mac_addr)(struct ixgbe_hw * , u8 * ) ;
   s32 (*get_san_mac_addr)(struct ixgbe_hw * , u8 * ) ;
   s32 (*get_device_caps)(struct ixgbe_hw * , u16 * ) ;
   s32 (*get_wwn_prefix)(struct ixgbe_hw * , u16 * , u16 * ) ;
   s32 (*stop_adapter)(struct ixgbe_hw * ) ;
   s32 (*get_bus_info)(struct ixgbe_hw * ) ;
   void (*set_lan_id)(struct ixgbe_hw * ) ;
   s32 (*read_analog_reg8)(struct ixgbe_hw * , u32  , u8 * ) ;
   s32 (*write_analog_reg8)(struct ixgbe_hw * , u32  , u8  ) ;
   s32 (*setup_sfp)(struct ixgbe_hw * ) ;
   s32 (*disable_rx_buff)(struct ixgbe_hw * ) ;
   s32 (*enable_rx_buff)(struct ixgbe_hw * ) ;
   s32 (*enable_rx_dma)(struct ixgbe_hw * , u32  ) ;
   s32 (*acquire_swfw_sync)(struct ixgbe_hw * , u16  ) ;
   void (*release_swfw_sync)(struct ixgbe_hw * , u16  ) ;
   void (*disable_tx_laser)(struct ixgbe_hw * ) ;
   void (*enable_tx_laser)(struct ixgbe_hw * ) ;
   void (*flap_tx_laser)(struct ixgbe_hw * ) ;
   void (*stop_link_on_d3)(struct ixgbe_hw * ) ;
   s32 (*setup_link)(struct ixgbe_hw * , ixgbe_link_speed  , bool  ) ;
   s32 (*check_link)(struct ixgbe_hw * , ixgbe_link_speed * , bool * , bool  ) ;
   s32 (*get_link_capabilities)(struct ixgbe_hw * , ixgbe_link_speed * , bool * ) ;
   void (*set_rxpba)(struct ixgbe_hw * , int  , u32  , int  ) ;
   s32 (*led_on)(struct ixgbe_hw * , u32  ) ;
   s32 (*led_off)(struct ixgbe_hw * , u32  ) ;
   s32 (*blink_led_start)(struct ixgbe_hw * , u32  ) ;
   s32 (*blink_led_stop)(struct ixgbe_hw * , u32  ) ;
   s32 (*set_rar)(struct ixgbe_hw * , u32  , u8 * , u32  , u32  ) ;
   s32 (*clear_rar)(struct ixgbe_hw * , u32  ) ;
   s32 (*set_vmdq)(struct ixgbe_hw * , u32  , u32  ) ;
   s32 (*set_vmdq_san_mac)(struct ixgbe_hw * , u32  ) ;
   s32 (*clear_vmdq)(struct ixgbe_hw * , u32  , u32  ) ;
   s32 (*init_rx_addrs)(struct ixgbe_hw * ) ;
   s32 (*update_mc_addr_list)(struct ixgbe_hw * , struct net_device * ) ;
   s32 (*enable_mc)(struct ixgbe_hw * ) ;
   s32 (*disable_mc)(struct ixgbe_hw * ) ;
   s32 (*clear_vfta)(struct ixgbe_hw * ) ;
   s32 (*set_vfta)(struct ixgbe_hw * , u32  , u32  , bool  ) ;
   s32 (*init_uta_tables)(struct ixgbe_hw * ) ;
   void (*set_mac_anti_spoofing)(struct ixgbe_hw * , bool  , int  ) ;
   void (*set_vlan_anti_spoofing)(struct ixgbe_hw * , bool  , int  ) ;
   s32 (*fc_enable)(struct ixgbe_hw * ) ;
   s32 (*set_fw_drv_ver)(struct ixgbe_hw * , u8  , u8  , u8  , u8  ) ;
   s32 (*get_thermal_sensor_data)(struct ixgbe_hw * ) ;
   s32 (*init_thermal_sensor_thresh)(struct ixgbe_hw * ) ;
   bool (*mng_fw_enabled)(struct ixgbe_hw * ) ;
};
#line 2906 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_phy_operations {
   s32 (*identify)(struct ixgbe_hw * ) ;
   s32 (*identify_sfp)(struct ixgbe_hw * ) ;
   s32 (*init)(struct ixgbe_hw * ) ;
   s32 (*reset)(struct ixgbe_hw * ) ;
   s32 (*read_reg)(struct ixgbe_hw * , u32  , u32  , u16 * ) ;
   s32 (*write_reg)(struct ixgbe_hw * , u32  , u32  , u16  ) ;
   s32 (*read_reg_mdi)(struct ixgbe_hw * , u32  , u32  , u16 * ) ;
   s32 (*write_reg_mdi)(struct ixgbe_hw * , u32  , u32  , u16  ) ;
   s32 (*setup_link)(struct ixgbe_hw * ) ;
   s32 (*setup_link_speed)(struct ixgbe_hw * , ixgbe_link_speed  , bool  ) ;
   s32 (*check_link)(struct ixgbe_hw * , ixgbe_link_speed * , bool * ) ;
   s32 (*get_firmware_version)(struct ixgbe_hw * , u16 * ) ;
   s32 (*read_i2c_byte)(struct ixgbe_hw * , u8  , u8  , u8 * ) ;
   s32 (*write_i2c_byte)(struct ixgbe_hw * , u8  , u8  , u8  ) ;
   s32 (*read_i2c_sff8472)(struct ixgbe_hw * , u8  , u8 * ) ;
   s32 (*read_i2c_eeprom)(struct ixgbe_hw * , u8  , u8 * ) ;
   s32 (*write_i2c_eeprom)(struct ixgbe_hw * , u8  , u8  ) ;
   s32 (*check_overtemp)(struct ixgbe_hw * ) ;
};
#line 2927 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_eeprom_info {
   struct ixgbe_eeprom_operations ops ;
   enum ixgbe_eeprom_type type ;
   u32 semaphore_delay ;
   u16 word_size ;
   u16 address_bits ;
   u16 word_page_size ;
};
#line 2936 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mac_info {
   struct ixgbe_mac_operations ops ;
   enum ixgbe_mac_type type ;
   u8 addr[6U] ;
   u8 perm_addr[6U] ;
   u8 san_addr[6U] ;
   u16 wwnn_prefix ;
   u16 wwpn_prefix ;
   u16 max_msix_vectors ;
   u32 mta_shadow[128U] ;
   s32 mc_filter_type ;
   u32 mcft_size ;
   u32 vft_size ;
   u32 num_rar_entries ;
   u32 rar_highwater ;
   u32 rx_pb_size ;
   u32 max_tx_queues ;
   u32 max_rx_queues ;
   u32 orig_autoc ;
   u32 cached_autoc ;
   u32 orig_autoc2 ;
   bool orig_link_settings_stored ;
   bool autotry_restart ;
   u8 flags ;
   u8 san_mac_rar_index ;
   struct ixgbe_thermal_sensor_data thermal_sensor_data ;
};
#line 2968 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_phy_info {
   struct ixgbe_phy_operations ops ;
   struct mdio_if_info mdio ;
   enum ixgbe_phy_type type ;
   u32 id ;
   enum ixgbe_sfp_type sfp_type ;
   bool sfp_setup_needed ;
   u32 revision ;
   enum ixgbe_media_type media_type ;
   bool reset_disable ;
   ixgbe_autoneg_advertised autoneg_advertised ;
   enum ixgbe_smart_speed smart_speed ;
   bool smart_speed_active ;
   bool multispeed_fiber ;
   bool reset_if_overtemp ;
   bool qsfp_shared_i2c_bus ;
};
#line 118 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
struct ixgbe_mbx_operations;
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
struct ixgbe_mbx_operations {
   s32 (*init_params)(struct ixgbe_hw * ) ;
   s32 (*read)(struct ixgbe_hw * , u32 * , u16  , u16  ) ;
   s32 (*write)(struct ixgbe_hw * , u32 * , u16  , u16  ) ;
   s32 (*read_posted)(struct ixgbe_hw * , u32 * , u16  , u16  ) ;
   s32 (*write_posted)(struct ixgbe_hw * , u32 * , u16  , u16  ) ;
   s32 (*check_for_msg)(struct ixgbe_hw * , u16  ) ;
   s32 (*check_for_ack)(struct ixgbe_hw * , u16  ) ;
   s32 (*check_for_rst)(struct ixgbe_hw * , u16  ) ;
};
#line 2999 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mbx_stats {
   u32 msgs_tx ;
   u32 msgs_rx ;
   u32 acks ;
   u32 reqs ;
   u32 rsts ;
};
#line 3008 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_mbx_info {
   struct ixgbe_mbx_operations ops ;
   struct ixgbe_mbx_stats stats ;
   u32 timeout ;
   u32 usec_delay ;
   u32 v2p_mailbox ;
   u16 size ;
};
#line 3017 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hw {
   u8 *hw_addr ;
   void *back ;
   struct ixgbe_mac_info mac ;
   struct ixgbe_addr_filter_info addr_ctrl ;
   struct ixgbe_fc_info fc ;
   struct ixgbe_phy_info phy ;
   struct ixgbe_eeprom_info eeprom ;
   struct ixgbe_bus_info bus ;
   struct ixgbe_mbx_info mbx ;
   u16 device_id ;
   u16 vendor_id ;
   u16 subsystem_device_id ;
   u16 subsystem_vendor_id ;
   u8 revision_id ;
   bool adapter_stopped ;
   bool force_full_reset ;
   bool allow_unsupported_sfp ;
   bool mng_fw_enabled ;
   bool wol_enabled ;
};
#line 3039 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_info {
   enum ixgbe_mac_type mac ;
   s32 (*get_invariants)(struct ixgbe_hw * ) ;
   struct ixgbe_mac_operations *mac_ops ;
   struct ixgbe_eeprom_operations *eeprom_ops ;
   struct ixgbe_phy_operations *phy_ops ;
   struct ixgbe_mbx_operations *mbx_ops ;
};
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
enum strict_prio_type {
    prio_none = 0,
    prio_group = 1,
    prio_link = 2
} ;
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct dcb_support {
   u32 capabilities ;
   u8 traffic_classes ;
   u8 pfc_traffic_classes ;
};
#line 97 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct tc_bw_alloc {
   u8 bwg_id ;
   u8 bwg_percent ;
   u8 link_percent ;
   u8 up_to_tc_bitmap ;
   u16 data_credits_refill ;
   u16 data_credits_max ;
   enum strict_prio_type prio_type ;
};
#line 109
enum dcb_pfc_type {
    pfc_disabled = 0,
    pfc_enabled_full = 1,
    pfc_enabled_tx = 2,
    pfc_enabled_rx = 3
} ;
#line 116 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct tc_configuration {
   struct tc_bw_alloc path[2U] ;
   enum dcb_pfc_type dcb_pfc ;
   u16 desc_credits_max ;
   u8 tc ;
};
#line 125 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct dcb_num_tcs {
   u8 pg_tcs ;
   u8 pfc_tcs ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct ixgbe_dcb_config {
   struct dcb_support support ;
   struct dcb_num_tcs num_tcs ;
   struct tc_configuration tc_config[8U] ;
   u8 bw_percentage[2U][8U] ;
   bool pfc_mode_enable ;
   u32 dcb_cfg_version ;
   u32 link_speed ;
};
#line 339 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/scsi/fc/fc_fs.h"
struct ixgbe_fcoe_ddp {
   int len ;
   u32 err ;
   unsigned int sgc ;
   struct scatterlist *sgl ;
   dma_addr_t udp ;
   u64 *udl ;
   struct dma_pool *pool ;
};
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h"
struct ixgbe_fcoe_ddp_pool {
   struct dma_pool *pool ;
   u64 noddp ;
   u64 noddp_ext_buff ;
};
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h"
struct ixgbe_fcoe {
   struct ixgbe_fcoe_ddp_pool *ddp_pool ;
   atomic_t refcnt ;
   spinlock_t lock ;
   struct ixgbe_fcoe_ddp ddp[512U] ;
   void *extra_ddp_buffer ;
   dma_addr_t extra_ddp_buffer_dma ;
   unsigned long mode ;
   u8 up ;
};
#line 143 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/busy_poll.h"
struct vf_data_storage {
   unsigned char vf_mac_addresses[6U] ;
   u16 vf_mc_hashes[30U] ;
   u16 num_vf_mc_hashes ;
   u16 default_vf_vlan_id ;
   u16 vlans_enabled ;
   bool clear_to_send ;
   bool pf_set_mac ;
   u16 pf_vlan ;
   u16 pf_qos ;
   u16 tx_rate ;
   u16 vlan_count ;
   u8 spoofchk_enabled ;
   unsigned int vf_api ;
};
#line 153 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct vf_macvlans {
   struct list_head l ;
   int vf ;
   int rar_entry ;
   bool free ;
   bool is_macvlan ;
   u8 vf_macvlan[6U] ;
};
#line 162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_tx_buffer {
   union ixgbe_adv_tx_desc *next_to_watch ;
   unsigned long time_stamp ;
   struct sk_buff *skb ;
   unsigned int bytecount ;
   unsigned short gso_segs ;
   __be16 protocol ;
   dma_addr_t dma ;
   __u32 len ;
   u32 tx_flags ;
};
#line 183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_rx_buffer {
   struct sk_buff *skb ;
   dma_addr_t dma ;
   struct page *page ;
   unsigned int page_offset ;
};
#line 190 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_queue_stats {
   u64 packets ;
   u64 bytes ;
   u64 yields ;
   u64 misses ;
   u64 cleaned ;
};
#line 199 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_tx_queue_stats {
   u64 restart_queue ;
   u64 tx_busy ;
   u64 tx_done_old ;
};
#line 206 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_rx_queue_stats {
   u64 rsc_count ;
   u64 rsc_flush ;
   u64 non_eop_descs ;
   u64 alloc_rx_page_failed ;
   u64 alloc_rx_buff_failed ;
   u64 csum_err ;
};
#line 225
struct ixgbe_adapter;
#line 225 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_fwd_adapter {
   unsigned long active_vlans[64U] ;
   struct net_device *netdev ;
   struct ixgbe_adapter *real_adapter ;
   unsigned int tx_base_queue ;
   unsigned int rx_base_queue ;
   int pool ;
};
#line 234
struct ixgbe_q_vector;
#line 234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion____missing_field_name_304 {
   struct ixgbe_tx_buffer *tx_buffer_info ;
   struct ixgbe_rx_buffer *rx_buffer_info ;
};
#line 234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct __anonstruct____missing_field_name_306 {
   u8 atr_sample_rate ;
   u8 atr_count ;
};
#line 234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion____missing_field_name_305 {
   u16 next_to_alloc ;
   struct __anonstruct____missing_field_name_306 __annonCompField95 ;
};
#line 234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion____missing_field_name_307 {
   struct ixgbe_tx_queue_stats tx_stats ;
   struct ixgbe_rx_queue_stats rx_stats ;
};
#line 234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring {
   struct ixgbe_ring *next ;
   struct ixgbe_q_vector *q_vector ;
   struct net_device *netdev ;
   struct device *dev ;
   struct ixgbe_fwd_adapter *l2_accel_priv ;
   void *desc ;
   union __anonunion____missing_field_name_304 __annonCompField94 ;
   unsigned long last_rx_timestamp ;
   unsigned long state ;
   u8 *tail ;
   dma_addr_t dma ;
   unsigned int size ;
   u16 count ;
   u8 queue_index ;
   u8 reg_idx ;
   u16 next_to_use ;
   u16 next_to_clean ;
   union __anonunion____missing_field_name_305 __annonCompField96 ;
   u8 dcb_tc ;
   struct ixgbe_queue_stats stats ;
   struct u64_stats_sync syncp ;
   union __anonunion____missing_field_name_307 __annonCompField97 ;
};
#line 300 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring_feature {
   u16 limit ;
   u16 indices ;
   u16 mask ;
   u16 offset ;
};
#line 350 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_ring_container {
   struct ixgbe_ring *ring ;
   unsigned int total_bytes ;
   unsigned int total_packets ;
   u16 work_limit ;
   u8 count ;
   u8 itr ;
};
#line 360 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_q_vector {
   struct ixgbe_adapter *adapter ;
   int cpu ;
   u16 v_idx ;
   u16 itr ;
   struct ixgbe_ring_container rx ;
   struct ixgbe_ring_container tx ;
   struct napi_struct napi ;
   cpumask_t affinity_mask ;
   int numa_node ;
   struct callback_head rcu ;
   char name[25U] ;
   unsigned int state ;
   spinlock_t lock ;
   struct ixgbe_ring ring[0U] ;
};
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct hwmon_attr {
   struct device_attribute dev_attr ;
   struct ixgbe_hw *hw ;
   struct ixgbe_thermal_diode_data *sensor ;
   char name[12U] ;
};
#line 555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct hwmon_buff {
   struct attribute_group group ;
   struct attribute_group  const  *groups[2U] ;
   struct attribute *attrs[13U] ;
   struct hwmon_attr hwmon_list[12U] ;
   unsigned int n_hwmon ;
};
#line 594 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_adapter {
   unsigned long active_vlans[64U] ;
   struct net_device *netdev ;
   struct pci_dev *pdev ;
   unsigned long state ;
   u32 flags ;
   u32 flags2 ;
   int num_tx_queues ;
   u16 tx_itr_setting ;
   u16 tx_work_limit ;
   int num_rx_queues ;
   u16 rx_itr_setting ;
   struct ixgbe_ring *tx_ring[64U] ;
   u64 restart_queue ;
   u64 lsc_int ;
   u32 tx_timeout_count ;
   struct ixgbe_ring *rx_ring[64U] ;
   int num_rx_pools ;
   int num_rx_queues_per_pool ;
   u64 hw_csum_rx_error ;
   u64 hw_rx_no_dma_resources ;
   u64 rsc_total_count ;
   u64 rsc_total_flush ;
   u64 non_eop_descs ;
   u32 alloc_rx_page_failed ;
   u32 alloc_rx_buff_failed ;
   struct ixgbe_q_vector *q_vector[64U] ;
   struct ieee_pfc *ixgbe_ieee_pfc ;
   struct ieee_ets *ixgbe_ieee_ets ;
   struct ixgbe_dcb_config dcb_cfg ;
   struct ixgbe_dcb_config temp_dcb_cfg ;
   u8 dcb_set_bitmap ;
   u8 dcbx_cap ;
   enum ixgbe_fc_mode last_lfc_mode ;
   int num_q_vectors ;
   int max_q_vectors ;
   struct ixgbe_ring_feature ring_feature[5U] ;
   struct msix_entry *msix_entries ;
   u32 test_icr ;
   struct ixgbe_ring test_tx_ring ;
   struct ixgbe_ring test_rx_ring ;
   struct ixgbe_hw hw ;
   u16 msg_enable ;
   struct ixgbe_hw_stats stats ;
   u64 tx_busy ;
   unsigned int tx_ring_count ;
   unsigned int rx_ring_count ;
   u32 link_speed ;
   bool link_up ;
   unsigned long link_check_timeout ;
   struct timer_list service_timer ;
   struct work_struct service_task ;
   struct hlist_head fdir_filter_list ;
   unsigned long fdir_overflow ;
   union ixgbe_atr_input fdir_mask ;
   int fdir_filter_count ;
   u32 fdir_pballoc ;
   u32 atr_sample_rate ;
   spinlock_t fdir_perfect_lock ;
   struct ixgbe_fcoe fcoe ;
   u8 *io_addr ;
   u32 wol ;
   u16 bd_number ;
   u16 eeprom_verh ;
   u16 eeprom_verl ;
   u16 eeprom_cap ;
   u32 interrupt_event ;
   u32 led_reg ;
   struct ptp_clock *ptp_clock ;
   struct ptp_clock_info ptp_caps ;
   struct work_struct ptp_tx_work ;
   struct sk_buff *ptp_tx_skb ;
   unsigned long ptp_tx_start ;
   unsigned long last_overflow_check ;
   unsigned long last_rx_ptp_check ;
   spinlock_t tmreg_lock ;
   struct cyclecounter cc ;
   struct timecounter tc ;
   u32 base_incval ;
   unsigned long active_vfs[1U] ;
   unsigned int num_vfs ;
   struct vf_data_storage *vfinfo ;
   int vf_rate_link_speed ;
   struct vf_macvlans vf_mvs ;
   struct vf_macvlans *mv_list ;
   u32 timer_event_accumulator ;
   u32 vferr_refcount ;
   struct kobject *info_kobj ;
   struct hwmon_buff *ixgbe_hwmon_buff ;
   struct dentry *ixgbe_dbg_adapter ;
   u8 default_up ;
   unsigned long fwd_bitmask ;
};
#line 797 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_fdir_filter {
   struct hlist_node fdir_node ;
   union ixgbe_atr_input filter ;
   u16 sw_idx ;
   u16 action ;
};
#line 814 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
union __anonunion____missing_field_name_308 {
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 814 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
struct ixgbe_cb {
   union __anonunion____missing_field_name_308 __annonCompField98 ;
   dma_addr_t dma ;
   u16 append_cnt ;
   bool page_released ;
};
#line 324 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct ixgbe_reg_info {
   u32 ofs ;
   char *name ;
};
#line 457 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct my_u0 {
   u64 a ;
   u64 b ;
};
#line 1466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion_hdr_310 {
   unsigned char *network ;
   struct ethhdr *eth ;
   struct vlan_hdr *vlan ;
   struct iphdr *ipv4 ;
   struct ipv6hdr *ipv6 ;
};
#line 6779 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
union __anonunion_hdr_312 {
   unsigned char *network ;
   struct iphdr *ipv4 ;
   struct ipv6hdr *ipv6 ;
};
#line 8578 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct ldv_struct_EMGentry_31 {
   int signal_pending ;
};
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_struct_dummy_resourceless_instance_14 {
   struct notifier_block *arg0 ;
   int signal_pending ;
};
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_struct_dummy_resourceless_instance_6 {
   struct net_device *arg0 ;
   int signal_pending ;
};
#line 57 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_struct_interrupt_instance_2 {
   int arg0 ;
   enum irqreturn (*arg1)(int  , void * ) ;
   enum irqreturn (*arg2)(int  , void * ) ;
   void *arg3 ;
   int signal_pending ;
};
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_struct_pci_instance_7 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_struct_timer_instance_15 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
#line 19655 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type;
#line 19667 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type___0;
#line 19688 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type___1;
#line 19700 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type___2;
#line 19739 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type___3;
#line 19751 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type___4;
#line 19772 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type___5;
#line 19784 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef struct net_device *ldv_func_ret_type___6;
#line 19796 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type___7;
#line 19835 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
typedef int ldv_func_ret_type___8;
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
union __anonunion_cmd_or_resp_248 {
   u8 cmd_resv ;
   u8 ret_status ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_hdr {
   u8 cmd ;
   u8 buf_len ;
   union __anonunion_cmd_or_resp_248 cmd_or_resp ;
   u8 checksum ;
};
#line 2289 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_hic_drv_info {
   struct ixgbe_hic_hdr hdr ;
   u8 port_num ;
   u8 ver_sub ;
   u8 ver_build ;
   u8 ver_min ;
   u8 ver_maj ;
   u8 pad ;
   u16 pad2 ;
};
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
struct ixgbe_stats {
   char stat_string[32U] ;
   int type ;
   int sizeof_stat ;
   int stat_offset ;
};
#line 1259 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
struct ixgbe_reg_test {
   u16 reg ;
   u8 array_len ;
   u8 test_type ;
   u32 mask ;
   u32 write ;
};
#line 52 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
struct ldv_struct_free_irq_18 {
   int arg0 ;
   int signal_pending ;
};
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 2345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h"
struct ixgbe_adv_tx_context_desc {
   __le32 vlan_macip_lens ;
   __le32 seqnum_seed ;
   __le32 type_tucmd_mlhl ;
   __le32 mss_l4len_idx ;
};
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 490 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_vlan.h"
struct hwtstamp_config {
   int flags ;
   int tx_type ;
   int rx_filter ;
};
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pps_kernel.h"
struct pps_event_time {
   struct timespec ts_real ;
};
#line 121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ptp_clock_kernel.h"
union __anonunion____missing_field_name_247 {
   u64 timestamp ;
   struct pps_event_time pps_times ;
};
#line 121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ptp_clock_kernel.h"
struct ptp_clock_event {
   int type ;
   int index ;
   union __anonunion____missing_field_name_247 __annonCompField77 ;
};
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/xen/features.h"
struct bio_vec;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/smp.h"
union __anonunion____missing_field_name_132 {
   struct list_head list ;
   struct llist_node llist ;
};
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/smp.h"
struct call_single_data {
   union __anonunion____missing_field_name_132 __annonCompField32 ;
   void (*func)(void * ) ;
   void *info ;
   u16 flags ;
};
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/percpu-rwsem.h"
struct bio_set;
#line 28
struct bio;
#line 29
struct bio_integrity_payload;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   struct bio_integrity_payload *bi_integrity ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 57 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/fs.h"
struct hd_geometry;
#line 1516 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
struct block_device_operations;
#line 163 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
struct fc_frame_header {
   __u8 fh_r_ctl ;
   __u8 fh_d_id[3U] ;
   __u8 fh_cs_ctl ;
   __u8 fh_s_id[3U] ;
   __u8 fh_type ;
   __u8 fh_f_ctl[3U] ;
   __u8 fh_seq_id ;
   __u8 fh_df_ctl ;
   __be16 fh_seq_cnt ;
   __be16 fh_ox_id ;
   __be16 fh_rx_id ;
   __be32 fh_parm_offset ;
};
#line 339 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/scsi/fc/fc_fs.h"
struct fcoe_hdr {
   __u8 fcoe_ver ;
   __u8 fcoe_resvd[12U] ;
   __u8 fcoe_sof ;
};
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/scsi/fc/fc_fcoe.h"
struct fcoe_crc_eof {
   __le32 fcoe_crc32 ;
   __u8 fcoe_eof ;
   __u8 fcoe_resvd[3U] ;
};
#line 80 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned int for_kupdate : 1 ;
   unsigned int for_background : 1 ;
   unsigned int tagged_writepages : 1 ;
   unsigned int for_reclaim : 1 ;
   unsigned int range_cyclic : 1 ;
   unsigned int for_sync : 1 ;
};
#line 88
struct bdi_writeback;
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned int nr ;
   unsigned long last_old_flush ;
   struct delayed_work dwork ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   spinlock_t list_lock ;
};
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[4U] ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mempool.h"
union __anonunion____missing_field_name_297 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mempool.h"
union __anonunion____missing_field_name_298 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_297 __annonCompField97 ;
   union __anonunion____missing_field_name_298 __annonCompField98 ;
   unsigned int flags ;
};
#line 92 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 269 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   void *bip_buf ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned int bip_owns_buf : 1 ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 600 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bsg.h"
struct elevator_queue;
#line 24
struct blk_trace;
#line 25
struct request;
#line 27
struct bsg_job;
#line 28
struct blkcg_gq;
#line 49 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 69
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_SPECIAL = 7,
    REQ_TYPE_ATA_TASKFILE = 8,
    REQ_TYPE_ATA_PC = 9
} ;
#line 81 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_299 {
   struct call_single_data csd ;
   struct work_struct mq_flush_work ;
};
#line 81
struct blk_mq_ctx;
#line 81 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_300 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 81 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct __anonstruct_elv_302 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 81 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct __anonstruct_flush_303 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 81 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_301 {
   struct __anonstruct_elv_302 elv ;
   struct __anonstruct_flush_303 flush ;
};
#line 81 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_299 __annonCompField99 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   struct hlist_node hash ;
   union __anonunion____missing_field_name_300 __annonCompField100 ;
   union __anonunion____missing_field_name_301 __annonCompField101 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   char *buffer ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/hashtable.h"
struct elevator_type;
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 80 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 101 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned int registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 223 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 224 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 225 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 226 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 227 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 235 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 237 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 239 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 240 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 241
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 248 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 254 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
};
#line 263 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 293
struct blk_mq_ops;
#line 293
struct blk_mq_hw_ctx;
#line 293
struct throtl_data;
#line 293 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned int flush_not_queueable : 1 ;
   unsigned int flush_queue_delayed : 1 ;
   unsigned int flush_pending_idx : 1 ;
   unsigned int flush_running_idx : 1 ;
   unsigned long flush_pending_since ;
   struct list_head flush_queue[2U] ;
   struct list_head flush_data_in_flight ;
   struct request *flush_rq ;
   spinlock_t mq_flush_lock ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_counter mq_usage_counter ;
   struct list_head all_q_node ;
};
#line 1019 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct blk_plug {
   unsigned long magic ;
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1393 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct blk_integrity_exchg {
   void *prot_buf ;
   void *data_buf ;
   sector_t sector ;
   unsigned int data_size ;
   unsigned short sector_size ;
   char const   *disk_name ;
};
#line 1425 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef void integrity_gen_fn(struct blk_integrity_exchg * );
#line 1426 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef int integrity_vrfy_fn(struct blk_integrity_exchg * );
#line 1427 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef void integrity_set_tag_fn(void * , void * , unsigned int  );
#line 1428 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
typedef void integrity_get_tag_fn(void * , void * , unsigned int  );
#line 1429 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct blk_integrity {
   integrity_gen_fn *generate_fn ;
   integrity_vrfy_fn *verify_fn ;
   integrity_set_tag_fn *set_tag_fn ;
   integrity_get_tag_fn *get_tag_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short sector_size ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1488 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kthread.h"
struct kthread_work;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   wait_queue_head_t done ;
   struct kthread_worker *worker ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};
#line 152
struct spi_message;
#line 153
struct spi_transfer;
#line 210 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   struct completion xfer_completion ;
   int (*prepare_transfer_hardware)(struct spi_master * ) ;
   int (*transfer_one_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_transfer_hardware)(struct spi_master * ) ;
   int (*prepare_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_message)(struct spi_master * , struct spi_message * ) ;
   void (*set_cs)(struct spi_device * , bool  ) ;
   int (*transfer_one)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   int *cs_gpios ;
};
#line 475 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spi/spi.h"
struct spi_transfer {
   void const   *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   unsigned int cs_change : 1 ;
   unsigned int tx_nbits : 3 ;
   unsigned int rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};
#line 595 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 8 "thread.c"
struct ldv_thread_set {
   int number ;
   struct ldv_thread **threads ;
};
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/thread.h"
struct ldv_thread {
   int identifier ;
   void (*function)(void * ) ;
};
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.h"
struct clk;
#line 1 "<compiler builtins>"
void __builtin_prefetch(void const   *  , ...) ;
#line 1
long __builtin_expect(long exp , long c ) ;
#line 4 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void *ldv_dev_get_drvdata(struct device  const  *dev ) ;
#line 5
int ldv_dev_set_drvdata(struct device *dev , void *data ) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/err.h"
void *ldv_err_ptr(long error ) ;
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/common.h"
extern void ldv_initialize(void) ;
#line 47
int ldv_post_init(int init_ret_val ) ;
#line 58
extern void ldv_pre_probe(void) ;
#line 67
int ldv_post_probe(int probe_ret_val ) ;
#line 75
int ldv_filter_err_code(int ret_val ) ;
#line 105
extern int ldv_pre_register_netdev(void) ;
#line 119
void ldv_check_final_state(void) ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/irq.h"
extern void ldv_switch_to_interrupt_context(void) ;
#line 42
extern void ldv_switch_to_process_context(void) ;
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/common.h"
void ldv_assume(int expression ) ;
#line 31
void ldv_stop(void) ;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.h"
void ldv_free(void *s ) ;
#line 34
void *ldv_xmalloc(size_t size ) ;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 608 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
__inline static int hlist_empty(struct hlist_head  const  *h ) 
{ 


  {
#line 610
  return ((unsigned long )h->first == (unsigned long )((struct hlist_node */* const  */)0));
}
}
#line 613 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
__inline static void __hlist_del(struct hlist_node *n ) 
{ 
  struct hlist_node *next ;
  struct hlist_node **pprev ;

  {
#line 615
  next = n->next;
#line 616
  pprev = n->pprev;
#line 617
  *pprev = next;
#line 618
  if ((unsigned long )next != (unsigned long )((struct hlist_node *)0)) {
#line 619
    next->pprev = pprev;
  } else {

  }
#line 620
  return;
}
}
#line 622 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
__inline static void hlist_del(struct hlist_node *n ) 
{ 


  {
  {
#line 624
  __hlist_del(n);
#line 625
  n->next = (struct hlist_node *)-2401263026317557504L;
#line 626
  n->pprev = (struct hlist_node **)-2401263026316508672L;
  }
#line 627
  return;
}
}
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/export.h"
extern struct module __this_module ;
#line 358 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 79
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 81
  return;
}
}
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 116
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 118
  return;
}
}
#line 206 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 208
  __asm__  volatile   ("":);
#line 208
  return (0);

#line 208
  return (1);
}
}
#line 310 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 312
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 320
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 325
  return (oldbit);
}
}
#line 398 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/bitops.h"
__inline static int ffs(int x ) 
{ 
  int r ;

  {
#line 412
  __asm__  ("bsfl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 425
  return (r + 1);
}
}
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/bitops/find.h"
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
#line 42
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
#line 53
extern unsigned long find_first_zero_bit(unsigned long const   * , unsigned long  ) ;
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 222 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bitops.h"
extern unsigned long find_last_bit(unsigned long const   * , unsigned long  ) ;
#line 132 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dynamic_debug.h"
extern int __dynamic_netdev_dbg(struct _ddebug * , struct net_device  const  * , char const   * 
                                , ...) ;
#line 387 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/printk.h"
extern void print_hex_dump(char const   * , char const   * , int  , int  , int  ,
                           void const   * , size_t  , bool  ) ;
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 391
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 457
extern enum system_states system_state ;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 88 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8192U] ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 62
extern char *strcpy(char * , char const   * ) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/string.h"
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
#line 113 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , int  ) ;
#line 276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ 
  int tmp___0 ;

  {
  {
#line 280
  tmp___0 = __bitmap_weight(src, nbits);
  }
#line 280
  return (tmp___0);
}
}
#line 66 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/bug.h"
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
#line 71
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 79
extern struct cpumask  const  * const  cpu_possible_mask ;
#line 80
extern struct cpumask  const  * const  cpu_online_mask ;
#line 105 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 108
  __ret_warn_once = cpu >= (unsigned int )nr_cpu_ids;
#line 108
  tmp___1 = __builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 108
  if (tmp___1 != 0L) {
    {
#line 108
    __ret_warn_on = ! __warned;
#line 108
    tmp = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 108
    if (tmp != 0L) {
      {
#line 108
      warn_slowpath_null("include/linux/cpumask.h", 108);
      }
    } else {

    }
    {
#line 108
    tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 108
    if (tmp___0 != 0L) {
#line 108
      __warned = 1;
    } else {

    }
  } else {

  }
  {
#line 108
  __builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 110
  return (cpu);
}
}
#line 170 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 173
  if (n != -1) {
    {
#line 174
    cpumask_check((unsigned int )n);
    }
  } else {

  }
  {
#line 175
  tmp = find_next_bit((unsigned long const   *)(& srcp->bits), (unsigned long )nr_cpu_ids,
                      (unsigned long )(n + 1));
  }
#line 175
  return ((unsigned int )tmp);
}
}
#line 459 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 461
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), nr_cpu_ids);
  }
#line 461
  return ((unsigned int )tmp);
}
}
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/paravirt.h"
extern int ( /* missing proto */  __builtin_unreachable)() ;
#line 802 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  {
#line 804
  __edi = __edi;
#line 804
  __esi = __esi;
#line 804
  __edx = __edx;
#line 804
  __ecx = __ecx;
#line 804
  __eax = __eax;
#line 804
  tmp = __builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  }
#line 804
  if (tmp != 0L) {
    {
#line 804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
#line 804
    __builtin_unreachable();
    }
  } else {

  }
#line 804
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 804
  __ret = __eax;
#line 804
  return (__ret);
}
}
#line 155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 811 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/processor.h"
__inline static void prefetchw(void const   *x ) 
{ 


  {
#line 813
  __asm__  volatile   ("661:\n\tprefetcht0 (%1)\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word (1*32+31)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\tprefetchw (%1)\n6641:\n\t.popsection": : "i" (0),
                       "r" (x));
#line 814
  return;
}
}
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 26
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 38
  v->counter = i;
#line 39
  return;
}
}
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
#line 91
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
#line 93
  return;
}
}
#line 279 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 333
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
#line 337
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
#line 536
extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
#line 8 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;

  {
  {
#line 22
  if (4UL == 1UL) {
#line 22
    goto case_1;
  } else {

  }
#line 22
  if (4UL == 2UL) {
#line 22
    goto case_2;
  } else {

  }
#line 22
  if (4UL == 4UL) {
#line 22
    goto case_4;
  } else {

  }
#line 22
  if (4UL == 8UL) {
#line 22
    goto case_8;
  } else {

  }
#line 22
  goto switch_default;
  case_1: /* CIL Label */ 
#line 22
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6324;
  case_2: /* CIL Label */ 
#line 22
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6324;
  case_4: /* CIL Label */ 
#line 22
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6324;
  case_8: /* CIL Label */ 
#line 22
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_6324;
  switch_default: /* CIL Label */ 
  {
#line 22
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_6324: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 73 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 75
  pao_ID__ = 0;
  {
#line 75
  if (4UL == 1UL) {
#line 75
    goto case_1;
  } else {

  }
#line 75
  if (4UL == 2UL) {
#line 75
    goto case_2;
  } else {

  }
#line 75
  if (4UL == 4UL) {
#line 75
    goto case_4;
  } else {

  }
#line 75
  if (4UL == 8UL) {
#line 75
    goto case_8;
  } else {

  }
#line 75
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 75
  if (pao_ID__ == 1) {
#line 75
    __asm__  ("incb %%gs:%P0": "+m" (__preempt_count));
  } else
#line 75
  if (pao_ID__ == -1) {
#line 75
    __asm__  ("decb %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 75
    __asm__  ("addb %1, %%gs:%P0": "+m" (__preempt_count): "qi" (val));
  }
#line 75
  goto ldv_6381;
  case_2: /* CIL Label */ ;
#line 75
  if (pao_ID__ == 1) {
#line 75
    __asm__  ("incw %%gs:%P0": "+m" (__preempt_count));
  } else
#line 75
  if (pao_ID__ == -1) {
#line 75
    __asm__  ("decw %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 75
    __asm__  ("addw %1, %%gs:%P0": "+m" (__preempt_count): "ri" (val));
  }
#line 75
  goto ldv_6381;
  case_4: /* CIL Label */ ;
#line 75
  if (pao_ID__ == 1) {
#line 75
    __asm__  ("incl %%gs:%P0": "+m" (__preempt_count));
  } else
#line 75
  if (pao_ID__ == -1) {
#line 75
    __asm__  ("decl %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 75
    __asm__  ("addl %1, %%gs:%P0": "+m" (__preempt_count): "ri" (val));
  }
#line 75
  goto ldv_6381;
  case_8: /* CIL Label */ ;
#line 75
  if (pao_ID__ == 1) {
#line 75
    __asm__  ("incq %%gs:%P0": "+m" (__preempt_count));
  } else
#line 75
  if (pao_ID__ == -1) {
#line 75
    __asm__  ("decq %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 75
    __asm__  ("addq %1, %%gs:%P0": "+m" (__preempt_count): "re" (val));
  }
#line 75
  goto ldv_6381;
  switch_default: /* CIL Label */ 
  {
#line 75
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_6381: ;
#line 77
  return;
}
}
#line 78 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 80
  pao_ID__ = 0;
  {
#line 80
  if (4UL == 1UL) {
#line 80
    goto case_1;
  } else {

  }
#line 80
  if (4UL == 2UL) {
#line 80
    goto case_2;
  } else {

  }
#line 80
  if (4UL == 4UL) {
#line 80
    goto case_4;
  } else {

  }
#line 80
  if (4UL == 8UL) {
#line 80
    goto case_8;
  } else {

  }
#line 80
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 80
  if (pao_ID__ == 1) {
#line 80
    __asm__  ("incb %%gs:%P0": "+m" (__preempt_count));
  } else
#line 80
  if (pao_ID__ == -1) {
#line 80
    __asm__  ("decb %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 80
    __asm__  ("addb %1, %%gs:%P0": "+m" (__preempt_count): "qi" (- val));
  }
#line 80
  goto ldv_6393;
  case_2: /* CIL Label */ ;
#line 80
  if (pao_ID__ == 1) {
#line 80
    __asm__  ("incw %%gs:%P0": "+m" (__preempt_count));
  } else
#line 80
  if (pao_ID__ == -1) {
#line 80
    __asm__  ("decw %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 80
    __asm__  ("addw %1, %%gs:%P0": "+m" (__preempt_count): "ri" (- val));
  }
#line 80
  goto ldv_6393;
  case_4: /* CIL Label */ ;
#line 80
  if (pao_ID__ == 1) {
#line 80
    __asm__  ("incl %%gs:%P0": "+m" (__preempt_count));
  } else
#line 80
  if (pao_ID__ == -1) {
#line 80
    __asm__  ("decl %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 80
    __asm__  ("addl %1, %%gs:%P0": "+m" (__preempt_count): "ri" (- val));
  }
#line 80
  goto ldv_6393;
  case_8: /* CIL Label */ ;
#line 80
  if (pao_ID__ == 1) {
#line 80
    __asm__  ("incq %%gs:%P0": "+m" (__preempt_count));
  } else
#line 80
  if (pao_ID__ == -1) {
#line 80
    __asm__  ("decq %%gs:%P0": "+m" (__preempt_count));
  } else {
#line 80
    __asm__  ("addq %1, %%gs:%P0": "+m" (__preempt_count): "re" (- val));
  }
#line 80
  goto ldv_6393;
  switch_default: /* CIL Label */ 
  {
#line 80
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_6393: ;
#line 82
  return;
}
}
#line 8 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bottom_half.h"
extern void __local_bh_disable_ip(unsigned long  , unsigned int  ) ;
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bottom_half.h"
__inline static void local_bh_disable(void) 
{ 


  {
  {
#line 19
  __local_bh_disable_ip((unsigned long )((void *)0), 512U);
  }
#line 21
  return;
}
}
#line 23
extern void __local_bh_enable_ip(unsigned long  , unsigned int  ) ;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/bottom_half.h"
__inline static void local_bh_enable(void) 
{ 


  {
  {
#line 32
  __local_bh_enable_ip((unsigned long )((void *)0), 512U);
  }
#line 34
  return;
}
}
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 28
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 40
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->__annonCompField19.rlock);
}
}
#line 301 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  {
#line 303
  _raw_spin_lock(& lock->__annonCompField19.rlock);
  }
#line 304
  return;
}
}
#line 306 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
  {
#line 308
  _raw_spin_lock_bh(& lock->__annonCompField19.rlock);
  }
#line 309
  return;
}
}
#line 341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  {
#line 343
  _raw_spin_unlock(& lock->__annonCompField19.rlock);
  }
#line 344
  return;
}
}
#line 346 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
  {
#line 348
  _raw_spin_unlock_bh(& lock->__annonCompField19.rlock);
  }
#line 349
  return;
}
}
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcupdate.h"
__inline static void __rcu_read_lock(void) 
{ 


  {
  {
#line 198
  __preempt_count_add(1);
#line 198
  __asm__  volatile   ("": : : "memory");
  }
#line 199
  return;
}
}
#line 201 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcupdate.h"
__inline static void __rcu_read_unlock(void) 
{ 


  {
  {
#line 203
  __asm__  volatile   ("": : : "memory");
#line 203
  __preempt_count_sub(1);
  }
#line 204
  return;
}
}
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcutree.h"
extern void rcu_barrier(void) ;
#line 93
extern bool rcu_is_watching(void) ;
#line 315 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcupdate.h"
__inline static void rcu_lock_acquire(struct lockdep_map *map ) 
{ 


  {
  {
#line 317
  lock_acquire(map, 0U, 0, 2, 1, (struct lockdep_map *)0, (unsigned long )((void *)0));
  }
#line 319
  return;
}
}
#line 320 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcupdate.h"
__inline static void rcu_lock_release(struct lockdep_map *map ) 
{ 


  {
  {
#line 322
  lock_release(map, 1, (unsigned long )((void *)0));
  }
#line 324
  return;
}
}
#line 325
extern struct lockdep_map rcu_lock_map ;
#line 329
extern int debug_lockdep_rcu_enabled(void) ;
#line 806 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcupdate.h"
__inline static void rcu_read_lock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 808
  __rcu_read_lock();
#line 810
  rcu_lock_acquire(& rcu_lock_map);
#line 811
  tmp = debug_lockdep_rcu_enabled();
  }
#line 811
  if (tmp != 0 && ! __warned) {
    {
#line 811
    tmp___0 = rcu_is_watching();
    }
#line 811
    if (tmp___0) {
#line 811
      tmp___1 = 0;
    } else {
#line 811
      tmp___1 = 1;
    }
#line 811
    if (tmp___1) {
      {
#line 811
      __warned = 1;
#line 811
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 812, "rcu_read_lock() used illegally while idle");
      }
    } else {

    }
  } else {

  }
#line 814
  return;
}
}
#line 830 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcupdate.h"
__inline static void rcu_read_unlock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 832
  tmp = debug_lockdep_rcu_enabled();
  }
#line 832
  if (tmp != 0 && ! __warned) {
    {
#line 832
    tmp___0 = rcu_is_watching();
    }
#line 832
    if (tmp___0) {
#line 832
      tmp___1 = 0;
    } else {
#line 832
      tmp___1 = 1;
    }
#line 832
    if (tmp___1) {
      {
#line 832
      __warned = 1;
#line 832
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 833, "rcu_read_unlock() used illegally while idle");
      }
    } else {

    }
  } else {

  }
  {
#line 834
  rcu_lock_release(& rcu_lock_map);
#line 836
  __rcu_read_unlock();
  }
#line 837
  return;
}
}
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 176
extern int mod_timer(struct timer_list * , unsigned long  ) ;
#line 179
static int ldv_mod_timer_17(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 183
static int ldv_mod_timer_20(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 245
extern int del_timer_sync(struct timer_list * ) ;
#line 248
static int ldv_del_timer_sync_18(struct timer_list *ldv_func_arg1 ) ;
#line 192 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/workqueue.h"
extern void __init_work(struct work_struct * , int  ) ;
#line 375
extern struct workqueue_struct *system_wq ;
#line 464
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 480
extern bool cancel_work_sync(struct work_struct * ) ;
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  {
#line 507
  tmp = queue_work_on(8192, wq, work);
  }
#line 507
  return (tmp);
}
}
#line 563 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/workqueue.h"
__inline static bool schedule_work(struct work_struct *work ) 
{ 
  bool tmp ;

  {
  {
#line 565
  tmp = queue_work(system_wq, work);
  }
#line 565
  return (tmp);
}
}
#line 84 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 86
  return ((char const   *)kobj->name);
}
}
#line 156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/memory_hotplug.h"
extern pg_data_t *node_data[] ;
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 55
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 55
  return (ret);
}
}
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 63
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 64
  return;
}
}
#line 174
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
#line 182 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/io.h"
__inline static void *ioremap(resource_size_t offset , unsigned long size ) 
{ 
  void *tmp ;

  {
  {
#line 184
  tmp = ioremap_nocache(offset, size);
  }
#line 184
  return (tmp);
}
}
#line 187
extern void iounmap(void volatile   * ) ;
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/vmalloc.h"
extern void *vzalloc(unsigned long  ) ;
#line 71
extern void *vzalloc_node(unsigned long  , int  ) ;
#line 79
extern void vfree(void const   * ) ;
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 174 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/percpu.h"
extern void __bad_size_call_parameter(void) ;
#line 185 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/topology.h"
extern int numa_node ;
#line 189 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/topology.h"
__inline static int numa_node_id(void) 
{ 
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 191
  __vpp_verify = (void const   *)0;
  {
#line 191
  if (4UL == 1UL) {
#line 191
    goto case_1;
  } else {

  }
#line 191
  if (4UL == 2UL) {
#line 191
    goto case_2___0;
  } else {

  }
#line 191
  if (4UL == 4UL) {
#line 191
    goto case_4___1;
  } else {

  }
#line 191
  if (4UL == 8UL) {
#line 191
    goto case_8___2;
  } else {

  }
#line 191
  goto switch_default___3;
  case_1: /* CIL Label */ ;
  {
#line 191
  if (4UL == 1UL) {
#line 191
    goto case_1___0;
  } else {

  }
#line 191
  if (4UL == 2UL) {
#line 191
    goto case_2;
  } else {

  }
#line 191
  if (4UL == 4UL) {
#line 191
    goto case_4;
  } else {

  }
#line 191
  if (4UL == 8UL) {
#line 191
    goto case_8;
  } else {

  }
#line 191
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 191
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (numa_node));
#line 191
  goto ldv_13769;
  case_2: /* CIL Label */ 
#line 191
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 191
  goto ldv_13769;
  case_4: /* CIL Label */ 
#line 191
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 191
  goto ldv_13769;
  case_8: /* CIL Label */ 
#line 191
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 191
  goto ldv_13769;
  switch_default: /* CIL Label */ 
  {
#line 191
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_13769: 
#line 191
  pscr_ret__ = pfo_ret__;
#line 191
  goto ldv_13775;
  case_2___0: /* CIL Label */ ;
  {
#line 191
  if (4UL == 1UL) {
#line 191
    goto case_1___1;
  } else {

  }
#line 191
  if (4UL == 2UL) {
#line 191
    goto case_2___1;
  } else {

  }
#line 191
  if (4UL == 4UL) {
#line 191
    goto case_4___0;
  } else {

  }
#line 191
  if (4UL == 8UL) {
#line 191
    goto case_8___0;
  } else {

  }
#line 191
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
#line 191
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (numa_node));
#line 191
  goto ldv_13779;
  case_2___1: /* CIL Label */ 
#line 191
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 191
  goto ldv_13779;
  case_4___0: /* CIL Label */ 
#line 191
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 191
  goto ldv_13779;
  case_8___0: /* CIL Label */ 
#line 191
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 191
  goto ldv_13779;
  switch_default___0: /* CIL Label */ 
  {
#line 191
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  ldv_13779: 
#line 191
  pscr_ret__ = pfo_ret_____0;
#line 191
  goto ldv_13775;
  case_4___1: /* CIL Label */ ;
  {
#line 191
  if (4UL == 1UL) {
#line 191
    goto case_1___2;
  } else {

  }
#line 191
  if (4UL == 2UL) {
#line 191
    goto case_2___2;
  } else {

  }
#line 191
  if (4UL == 4UL) {
#line 191
    goto case_4___2;
  } else {

  }
#line 191
  if (4UL == 8UL) {
#line 191
    goto case_8___1;
  } else {

  }
#line 191
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
#line 191
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (numa_node));
#line 191
  goto ldv_13788;
  case_2___2: /* CIL Label */ 
#line 191
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 191
  goto ldv_13788;
  case_4___2: /* CIL Label */ 
#line 191
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 191
  goto ldv_13788;
  case_8___1: /* CIL Label */ 
#line 191
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 191
  goto ldv_13788;
  switch_default___1: /* CIL Label */ 
  {
#line 191
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  ldv_13788: 
#line 191
  pscr_ret__ = pfo_ret_____1;
#line 191
  goto ldv_13775;
  case_8___2: /* CIL Label */ ;
  {
#line 191
  if (4UL == 1UL) {
#line 191
    goto case_1___3;
  } else {

  }
#line 191
  if (4UL == 2UL) {
#line 191
    goto case_2___3;
  } else {

  }
#line 191
  if (4UL == 4UL) {
#line 191
    goto case_4___3;
  } else {

  }
#line 191
  if (4UL == 8UL) {
#line 191
    goto case_8___3;
  } else {

  }
#line 191
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
#line 191
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (numa_node));
#line 191
  goto ldv_13797;
  case_2___3: /* CIL Label */ 
#line 191
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 191
  goto ldv_13797;
  case_4___3: /* CIL Label */ 
#line 191
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 191
  goto ldv_13797;
  case_8___3: /* CIL Label */ 
#line 191
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 191
  goto ldv_13797;
  switch_default___2: /* CIL Label */ 
  {
#line 191
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  ldv_13797: 
#line 191
  pscr_ret__ = pfo_ret_____2;
#line 191
  goto ldv_13775;
  switch_default___3: /* CIL Label */ 
  {
#line 191
  __bad_size_call_parameter();
  }
#line 191
  goto ldv_13775;
  switch_break: /* CIL Label */ ;
  }
  ldv_13775: ;
#line 191
  return (pscr_ret__);
}
}
#line 275 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags ) 
{ 
  long tmp ;

  {
  {
#line 277
  tmp = __builtin_expect((flags & 262144U) != 0U, 0L);
  }
#line 277
  if (tmp != 0L) {
#line 278
    return (1);
  } else {

  }
#line 280
  return (0);
}
}
#line 292 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ 
  int tmp ;

  {
  {
#line 294
  tmp = gfp_zonelist(flags);
  }
#line 294
  return ((struct zonelist *)(& (node_data[nid])->node_zonelists) + (unsigned long )tmp);
}
}
#line 305
extern struct page *__alloc_pages_nodemask(gfp_t  , unsigned int  , struct zonelist * ,
                                           nodemask_t * ) ;
#line 309 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ 
  struct page *tmp ;

  {
  {
#line 312
  tmp = __alloc_pages_nodemask(gfp_mask, order, zonelist, (nodemask_t *)0);
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ 
  struct zonelist *tmp ;
  struct page *tmp___0 ;

  {
#line 319
  if (nid < 0) {
    {
#line 320
    nid = numa_node_id();
    }
  } else {

  }
  {
#line 322
  tmp = node_zonelist(nid, gfp_mask);
#line 322
  tmp___0 = __alloc_pages(gfp_mask, order, tmp);
  }
#line 322
  return (tmp___0);
}
}
#line 370
extern void __free_pages(struct page * , unsigned int  ) ;
#line 285 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
extern int driver_for_each_device(struct device_driver * , struct device * , void * ,
                                  int (*)(struct device * , void * ) ) ;
#line 95 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm_wakeup.h"
extern int device_set_wakeup_enable(struct device * , bool  ) ;
#line 798 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 801
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 802
    return ((char const   *)dev->init_name);
  } else {

  }
  {
#line 804
  tmp = kobject_name(& dev->kobj);
  }
#line 804
  return (tmp);
}
}
#line 811 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
__inline static int dev_to_node(struct device *dev ) 
{ 


  {
#line 813
  return (dev->numa_node);
}
}
#line 815 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
__inline static void set_dev_node(struct device *dev , int node ) 
{ 


  {
#line 817
  dev->numa_node = node;
#line 818
  return;
}
}
#line 916
static void *ldv_dev_get_drvdata_6(struct device  const  *dev ) ;
#line 920
static void *ldv_dev_get_drvdata_8(struct device  const  *dev ) ;
#line 925
static int ldv_dev_set_drvdata_7(struct device *dev , void *data ) ;
#line 1029
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 1031
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1035
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 10 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 48
extern void usleep_range(unsigned long  , unsigned long  ) ;
#line 337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
  {
#line 337
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
  }
#line 337
  return (tmp);
}
}
#line 400 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm.h"
__inline static struct page *compound_head(struct page *page ) 
{ 
  struct page *head ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 402
  tmp___1 = PageTail((struct page  const  *)page);
#line 402
  tmp___2 = __builtin_expect(tmp___1 != 0, 0L);
  }
#line 402
  if (tmp___2 != 0L) {
    {
#line 403
    head = page->__annonCompField46.first_page;
#line 410
    __asm__  volatile   ("": : : "memory");
#line 411
    tmp = PageTail((struct page  const  *)page);
#line 411
    tmp___0 = __builtin_expect(tmp != 0, 1L);
    }
#line 411
    if (tmp___0 != 0L) {
#line 412
      return (head);
    } else {

    }
  } else {

  }
#line 414
  return (page);
}
}
#line 432 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm.h"
__inline static int page_count(struct page *page ) 
{ 
  struct page *tmp ;
  int tmp___0 ;

  {
  {
#line 434
  tmp = compound_head(page);
#line 434
  tmp___0 = atomic_read((atomic_t const   *)(& tmp->__annonCompField43.__annonCompField42.__annonCompField41._count));
  }
#line 434
  return (tmp___0);
}
}
#line 535
extern void put_page(struct page * ) ;
#line 724 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm.h"
__inline static int page_to_nid(struct page  const  *page ) 
{ 


  {
#line 726
  return ((int )(page->flags >> 54));
}
}
#line 888 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 890
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dynamic_queue_limits.h"
__inline static void dql_queued(struct dql *dql , unsigned int count ) 
{ 
  long tmp ;

  {
  {
#line 74
  tmp = __builtin_expect(count > 268435455U, 0L);
  }
#line 74
  if (tmp != 0L) {
    {
#line 74
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/dynamic_queue_limits.h"),
                         "i" (74), "i" (12UL));
#line 74
    __builtin_unreachable();
    }
  } else {

  }
#line 76
  dql->num_queued = dql->num_queued + count;
#line 77
  dql->last_obj_cnt = count;
#line 78
  return;
}
}
#line 81 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dynamic_queue_limits.h"
__inline static int dql_avail(struct dql  const  *dql ) 
{ 


  {
#line 83
  return ((int )((unsigned int )dql->adj_limit - (unsigned int )dql->num_queued));
}
}
#line 87
extern void dql_completed(struct dql * , unsigned int  ) ;
#line 90
extern void dql_reset(struct dql * ) ;
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 223 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/net.h"
extern int net_ratelimit(void) ;
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 302
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 560 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 562
  if (size != 0UL && n > 0xffffffffffffffffUL / size) {
#line 563
    return ((void *)0);
  } else {

  }
  {
#line 564
  tmp = __kmalloc(n * size, flags);
  }
#line 564
  return (tmp);
}
}
#line 573 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 575
  tmp = kmalloc_array(n, size, flags | 32768U);
  }
#line 575
  return (tmp);
}
}
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_fold(__wsum sum ) 
{ 


  {
#line 24
  __asm__  ("  addl %1,%0\n  adcl $0xffff,%0": "=r" (sum): "r" (sum << 16), "0" (sum & 4294901760U));
#line 29
  return ((__sum16 )(~ sum >> 16));
}
}
#line 87 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/checksum_64.h"
__inline static __wsum csum_tcpudp_nofold(__be32 saddr , __be32 daddr , unsigned short len ,
                                          unsigned short proto , __wsum sum ) 
{ 


  {
#line 90
  __asm__  ("  addl %1, %0\n  adcl %2, %0\n  adcl %3, %0\n  adcl $0, %0\n": "=r" (sum): "g" (daddr),
            "g" (saddr), "g" (((int )len + (int )proto) << 8), "0" (sum));
#line 97
  return (sum);
}
}
#line 112 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/checksum_64.h"
__inline static __sum16 csum_tcpudp_magic(__be32 saddr , __be32 daddr , unsigned short len ,
                                          unsigned short proto , __wsum sum ) 
{ 
  __wsum tmp ;
  __sum16 tmp___0 ;

  {
  {
#line 116
  tmp = csum_tcpudp_nofold(saddr, daddr, (int )len, (int )proto, sum);
#line 116
  tmp___0 = csum_fold(tmp);
  }
#line 116
  return (tmp___0);
}
}
#line 179
extern __sum16 csum_ipv6_magic(struct in6_addr  const  * , struct in6_addr  const  * ,
                               __u32  , unsigned short  , __wsum  ) ;
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 65
  return ((unsigned int )dma_direction <= 2U);
}
}
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 72
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL) && *(dev->dma_mask) != 0ULL);
}
}
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 67
extern void debug_dma_sync_single_range_for_cpu(struct device * , dma_addr_t  , unsigned long  ,
                                                size_t  , int  ) ;
#line 73
extern void debug_dma_sync_single_range_for_device(struct device * , dma_addr_t  ,
                                                   unsigned long  , size_t  , int  ) ;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
  {
#line 37
  tmp = __builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
  }
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 19
  if (tmp___1 != 0L) {
    {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
#line 19
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
  }
#line 26
  return (addr);
}
}
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 36
  if (tmp___1 != 0L) {
    {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
#line 36
    __builtin_unreachable();
    }
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
    {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
    }
  } else {

  }
  {
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
  }
#line 40
  return;
}
}
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 75
  tmp = get_dma_ops(dev);
#line 75
  ops = tmp;
#line 78
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 78
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 79
  tmp___1 = valid_dma_direction((int )dir);
#line 79
  tmp___2 = __builtin_expect(tmp___1 == 0, 0L);
  }
#line 79
  if (tmp___2 != 0L) {
    {
#line 79
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (79), "i" (12UL));
#line 79
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 80
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
#line 81
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
  }
#line 83
  return (addr);
}
}
#line 86 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 89
  tmp = get_dma_ops(dev);
#line 89
  ops = tmp;
#line 91
  tmp___0 = valid_dma_direction((int )dir);
#line 91
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 91
  if (tmp___1 != 0L) {
    {
#line 91
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
#line 91
    __builtin_unreachable();
    }
  } else {

  }
#line 92
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
    {
#line 93
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
    }
  } else {

  }
  {
#line 94
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
  }
#line 95
  return;
}
}
#line 121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_cpu(struct device *dev , dma_addr_t addr ,
                                                   unsigned long offset , size_t size ,
                                                   enum dma_data_direction dir ) 
{ 
  struct dma_map_ops  const  *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 127
  tmp = get_dma_ops(dev);
#line 127
  ops = (struct dma_map_ops  const  *)tmp;
#line 129
  tmp___0 = valid_dma_direction((int )dir);
#line 129
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 129
  if (tmp___1 != 0L) {
    {
#line 129
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (129), "i" (12UL));
#line 129
    __builtin_unreachable();
    }
  } else {

  }
#line 130
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*/* const  */)(struct device * ,
                                                                                         dma_addr_t  ,
                                                                                         size_t  ,
                                                                                         enum dma_data_direction  ))0)) {
    {
#line 131
    (*(ops->sync_single_for_cpu))(dev, addr + (unsigned long long )offset, size, dir);
    }
  } else {

  }
  {
#line 132
  debug_dma_sync_single_range_for_cpu(dev, addr, offset, size, (int )dir);
  }
#line 133
  return;
}
}
#line 135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_range_for_device(struct device *dev , dma_addr_t addr ,
                                                      unsigned long offset , size_t size ,
                                                      enum dma_data_direction dir ) 
{ 
  struct dma_map_ops  const  *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 141
  tmp = get_dma_ops(dev);
#line 141
  ops = (struct dma_map_ops  const  *)tmp;
#line 143
  tmp___0 = valid_dma_direction((int )dir);
#line 143
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 143
  if (tmp___1 != 0L) {
    {
#line 143
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (143), "i" (12UL));
#line 143
    __builtin_unreachable();
    }
  } else {

  }
#line 144
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*/* const  */)(struct device * ,
                                                                                            dma_addr_t  ,
                                                                                            size_t  ,
                                                                                            enum dma_data_direction  ))0)) {
    {
#line 145
    (*(ops->sync_single_for_device))(dev, addr + (unsigned long long )offset, size,
                                     dir);
    }
  } else {

  }
  {
#line 146
  debug_dma_sync_single_range_for_device(dev, addr, offset, size, (int )dir);
  }
#line 147
  return;
}
}
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
  }
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
    {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
    }
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 60
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 103 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
  }
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
  }
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
  {
#line 145
  tmp___0 = is_device_dma_capable(dev);
  }
#line 145
  if (tmp___0 == 0) {
#line 146
    return ((void *)0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return ((void *)0);
  } else {

  }
  {
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  }
#line 155
  return (memory);
}
}
#line 160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 166
  if (tmp___1 != 0L) {
    {
#line 166
    warn_slowpath_null("/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/dma-mapping.h",
                       166);
    }
  } else {

  }
  {
#line 166
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
    {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
    }
  } else {

  }
#line 174
  return;
}
}
#line 91 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 93
  tmp = dma_supported(dev, mask);
  }
#line 93
  if (tmp == 0) {
#line 94
    return (-5);
  } else {

  }
#line 95
  dev->coherent_dma_mask = mask;
#line 96
  return (0);
}
}
#line 106 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev , u64 mask ) 
{ 
  int rc ;
  int tmp ;

  {
  {
#line 108
  tmp = dma_set_mask(dev, mask);
#line 108
  rc = tmp;
  }
#line 109
  if (rc == 0) {
    {
#line 110
    dma_set_coherent_mask(dev, mask);
    }
  } else {

  }
#line 111
  return (rc);
}
}
#line 187 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const   *frag ) 
{ 


  {
#line 189
  return ((unsigned int )frag->size);
}
}
#line 202 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_frag_size_sub(skb_frag_t *frag , int delta ) 
{ 


  {
#line 204
  frag->size = frag->size - (__u32 )delta;
#line 205
  return;
}
}
#line 654
extern void consume_skb(struct sk_buff * ) ;
#line 689
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 697
extern int skb_pad(struct sk_buff * , int  ) ;
#line 798 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 800
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 907 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static struct sk_buff *skb_get(struct sk_buff *skb ) 
{ 


  {
  {
#line 909
  atomic_inc(& skb->users);
  }
#line 910
  return (skb);
}
}
#line 949 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff  const  *skb ) 
{ 
  int dataref ;
  unsigned char *tmp ;

  {
#line 953
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 0U) {
#line 954
    return (0);
  } else {

  }
  {
#line 956
  tmp = skb_end_pointer(skb);
#line 956
  dataref = atomic_read((atomic_t const   *)(& ((struct skb_shared_info *)tmp)->dataref));
#line 957
  dataref = (dataref & 65535) - (dataref >> 16);
  }
#line 958
  return (dataref != 1);
}
}
#line 1369 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1371
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 1374 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff  const  *skb ) 
{ 


  {
#line 1376
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
#line 1445
extern void skb_add_rx_frag(struct sk_buff * , int  , struct page * , int  , int  ,
                            unsigned int  ) ;
#line 1456 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static unsigned char *skb_tail_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 1458
  return ((unsigned char *)skb->head + (unsigned long )skb->tail);
}
}
#line 1461 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
#line 1463
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
#line 1464
  return;
}
}
#line 1466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb , int const   offset ) 
{ 


  {
  {
#line 1468
  skb_reset_tail_pointer(skb);
#line 1469
  skb->tail = skb->tail + (sk_buff_data_t )offset;
  }
#line 1470
  return;
}
}
#line 1495 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static unsigned char *__skb_put(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1497
  tmp___0 = skb_tail_pointer((struct sk_buff  const  *)skb);
#line 1497
  tmp = tmp___0;
#line 1498
  tmp___1 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 1498
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 1498
  if (tmp___2 != 0L) {
    {
#line 1498
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/skbuff.h"),
                         "i" (1498), "i" (12UL));
#line 1498
    __builtin_unreachable();
    }
  } else {

  }
#line 1499
  skb->tail = skb->tail + len;
#line 1500
  skb->len = skb->len + len;
#line 1501
  return (tmp);
}
}
#line 1669 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static unsigned char *skb_transport_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1671
  return ((unsigned char *)skb->head + (unsigned long )skb->transport_header);
}
}
#line 1686 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1688
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 1756 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static int skb_transport_offset(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 1758
  tmp = skb_transport_header(skb);
  }
#line 1758
  return ((int )((unsigned int )((long )tmp) - (unsigned int )((long )skb->data)));
}
}
#line 1761 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static u32 skb_network_header_len(struct sk_buff  const  *skb ) 
{ 


  {
#line 1763
  return ((u32 )((int )skb->transport_header - (int )skb->network_header));
}
}
#line 1771 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static int skb_network_offset(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 1773
  tmp = skb_network_header(skb);
  }
#line 1773
  return ((int )((unsigned int )((long )tmp) - (unsigned int )((long )skb->data)));
}
}
#line 1933
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 1969 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                            unsigned int length ,
                                                            gfp_t gfp ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  {
#line 1972
  tmp = __netdev_alloc_skb(dev, length, gfp);
#line 1972
  skb = tmp;
  }
#line 1976
  return (skb);
}
}
#line 1979 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                          unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
  {
#line 1982
  tmp = __netdev_alloc_skb_ip_align(dev, length, 32U);
  }
#line 1982
  return (tmp);
}
}
#line 1995 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static struct page *__skb_alloc_pages(gfp_t gfp_mask , struct sk_buff *skb ,
                                               unsigned int order ) 
{ 
  struct page *page ;

  {
#line 2001
  gfp_mask = gfp_mask | 256U;
#line 2003
  if ((gfp_mask & 65536U) == 0U) {
#line 2004
    gfp_mask = gfp_mask | 8192U;
  } else {

  }
  {
#line 2006
  page = alloc_pages_node(-1, gfp_mask, order);
  }
#line 2007
  if (((unsigned long )skb != (unsigned long )((struct sk_buff *)0) && (unsigned long )page != (unsigned long )((struct page *)0)) && (int )page->__annonCompField43.__annonCompField38.pfmemalloc) {
#line 2008
    skb->pfmemalloc = 1U;
  } else {

  }
#line 2010
  return (page);
}
}
#line 2046 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const   *frag ) 
{ 


  {
#line 2048
  return ((struct page *)frag->page.p);
}
}
#line 2104 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void *skb_frag_address(skb_frag_t const   *frag ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
  {
#line 2106
  tmp = skb_frag_page(frag);
#line 2106
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
  }
#line 2106
  return (tmp___0 + (unsigned long )frag->page_offset);
}
}
#line 2164 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev , skb_frag_t const   *frag ,
                                            size_t offset , size_t size , enum dma_data_direction dir ) 
{ 
  struct page *tmp ;
  dma_addr_t tmp___0 ;

  {
  {
#line 2169
  tmp = skb_frag_page(frag);
#line 2169
  tmp___0 = dma_map_page(dev, tmp, (size_t )frag->page_offset + offset, size, dir);
  }
#line 2169
  return (tmp___0);
}
}
#line 2445
extern int skb_copy_bits(struct sk_buff  const  * , int  , void * , int  ) ;
#line 2472 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void *skb_header_pointer(struct sk_buff  const  *skb , int offset ,
                                         int len , void *buffer ) 
{ 
  int hlen ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 2475
  tmp = skb_headlen(skb);
#line 2475
  hlen = (int )tmp;
  }
#line 2477
  if (hlen - offset >= len) {
#line 2478
    return ((void *)skb->data + (unsigned long )offset);
  } else {

  }
  {
#line 2480
  tmp___0 = skb_copy_bits(skb, offset, buffer, len);
  }
#line 2480
  if (tmp___0 < 0) {
#line 2481
    return ((void *)0);
  } else {

  }
#line 2483
  return (buffer);
}
}
#line 2518 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_copy_to_linear_data(struct sk_buff *skb , void const   *from ,
                                             unsigned int const   len ) 
{ 


  {
  {
#line 2522
  memcpy((void *)skb->data, from, (size_t )len);
  }
#line 2523
  return;
}
}
#line 2580
extern void skb_clone_tx_timestamp(struct sk_buff * ) ;
#line 2622
extern void skb_tstamp_tx(struct sk_buff * , struct skb_shared_hwtstamps * ) ;
#line 2625 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void sw_tx_timestamp(struct sk_buff *skb ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 2627
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
  }
#line 2627
  if (((int )((struct skb_shared_info *)tmp)->tx_flags & 2) != 0) {
    {
#line 2627
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
    }
#line 2627
    if (((int )((struct skb_shared_info *)tmp___0)->tx_flags & 4) == 0) {
      {
#line 2629
      skb_tstamp_tx(skb, (struct skb_shared_hwtstamps *)0);
      }
    } else {

    }
  } else {

  }
#line 2630
  return;
}
}
#line 2644 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_tx_timestamp(struct sk_buff *skb ) 
{ 


  {
  {
#line 2646
  skb_clone_tx_timestamp(skb);
#line 2647
  sw_tx_timestamp(skb);
  }
#line 2648
  return;
}
}
#line 2794 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb , u16 rx_queue ) 
{ 


  {
#line 2796
  skb->queue_mapping = (unsigned int )rx_queue + 1U;
#line 2797
  return;
}
}
#line 2799 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static u16 skb_get_rx_queue(struct sk_buff  const  *skb ) 
{ 


  {
#line 2801
  return ((unsigned int )((u16 )skb->queue_mapping) + 65535U);
}
}
#line 2804 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static bool skb_rx_queue_recorded(struct sk_buff  const  *skb ) 
{ 


  {
#line 2806
  return ((unsigned int )((unsigned short )skb->queue_mapping) != 0U);
}
}
#line 2854 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 2856
  tmp = skb_end_pointer(skb);
  }
#line 2856
  return ((unsigned int )((struct skb_shared_info *)tmp)->gso_size != 0U);
}
}
#line 2860 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static bool skb_is_gso_v6(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 2862
  tmp = skb_end_pointer(skb);
  }
#line 2862
  return (((int )((struct skb_shared_info *)tmp)->gso_type & 16) != 0);
}
}
#line 2896 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff  const  *skb ) 
{ 


  {
#line 2898
  return;
}
}
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/u64_stats_sync.h"
__inline static void u64_stats_update_begin(struct u64_stats_sync *syncp ) 
{ 


  {
#line 79
  return;
}
}
#line 122 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_bh(struct u64_stats_sync  const  *syncp ) 
{ 


  {
#line 130
  return (0U);
}
}
#line 134 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_bh(struct u64_stats_sync  const  *syncp ,
                                              unsigned int start ) 
{ 


  {
#line 143
  return (0);
}
}
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dcbnl.h"
extern u8 dcb_ieee_getapp_mask(struct net_device * , struct dcb_app * ) ;
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 397 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
extern void __napi_schedule(struct napi_struct * ) ;
#line 399 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n ) 
{ 
  int tmp ;

  {
  {
#line 401
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& n->state));
  }
#line 401
  return (tmp != 0);
}
}
#line 413 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 415
  tmp = napi_disable_pending(n);
  }
#line 415
  if (tmp) {
#line 415
    tmp___0 = 0;
  } else {
#line 415
    tmp___0 = 1;
  }
#line 415
  if (tmp___0) {
    {
#line 415
    tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
    }
#line 415
    if (tmp___1 == 0) {
#line 415
      tmp___2 = 1;
    } else {
#line 415
      tmp___2 = 0;
    }
  } else {
#line 415
    tmp___2 = 0;
  }
#line 415
  return ((bool )tmp___2);
}
}
#line 426 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n ) 
{ 
  bool tmp ;

  {
  {
#line 428
  tmp = napi_schedule_prep(n);
  }
#line 428
  if ((int )tmp) {
    {
#line 429
    __napi_schedule(n);
    }
  } else {

  }
#line 430
  return;
}
}
#line 449
extern void napi_complete(struct napi_struct * ) ;
#line 484 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void napi_disable(struct napi_struct *n ) 
{ 
  int tmp ;

  {
  {
#line 486
  __might_sleep("include/linux/netdevice.h", 486, 0);
#line 487
  set_bit(1L, (unsigned long volatile   *)(& n->state));
  }
#line 488
  goto ldv_37654;
  ldv_37653: 
  {
#line 489
  msleep(1U);
  }
  ldv_37654: 
  {
#line 488
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
  }
#line 488
  if (tmp != 0) {
#line 490
    goto ldv_37653;
  } else {

  }
  {
#line 490
  clear_bit(1L, (unsigned long volatile   *)(& n->state));
  }
#line 491
  return;
}
}
#line 500 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  {
#line 502
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& n->state));
#line 502
  tmp___0 = __builtin_expect(tmp == 0, 0L);
  }
#line 502
  if (tmp___0 != 0L) {
    {
#line 502
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (502), "i" (12UL));
#line 502
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 503
  __asm__  volatile   ("": : : "memory");
#line 504
  clear_bit(0L, (unsigned long volatile   *)(& n->state));
  }
#line 505
  return;
}
}
#line 1486 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static int netdev_get_prio_tc_map(struct net_device  const  *dev , u32 prio ) 
{ 


  {
#line 1488
  return ((int )dev->prio_tc_map[prio & 15U]);
}
}
#line 1492 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static int netdev_set_prio_tc_map(struct net_device *dev , u8 prio , u8 tc ) 
{ 


  {
#line 1494
  if ((int )tc >= (int )dev->num_tc) {
#line 1495
    return (-22);
  } else {

  }
#line 1497
  dev->prio_tc_map[(int )prio & 15] = (unsigned int )tc & 15U;
#line 1498
  return (0);
}
}
#line 1502 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netdev_reset_tc(struct net_device *dev ) 
{ 


  {
  {
#line 1504
  dev->num_tc = 0U;
#line 1505
  memset((void *)(& dev->tc_to_txq), 0, 64UL);
#line 1506
  memset((void *)(& dev->prio_tc_map), 0, 16UL);
  }
#line 1507
  return;
}
}
#line 1521 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static int netdev_set_num_tc(struct net_device *dev , u8 num_tc ) 
{ 


  {
#line 1523
  if ((unsigned int )num_tc > 16U) {
#line 1524
    return (-22);
  } else {

  }
#line 1526
  dev->num_tc = num_tc;
#line 1527
  return (0);
}
}
#line 1531 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static int netdev_get_num_tc(struct net_device *dev ) 
{ 


  {
#line 1533
  return ((int )dev->num_tc);
}
}
#line 1537 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1540
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 1603 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1605
  return ((void *)dev + 3200U);
}
}
#line 1877
extern void free_netdev(struct net_device * ) ;
#line 1880
static void ldv_free_netdev_23(struct net_device *ldv_func_arg1 ) ;
#line 1884
static void ldv_free_netdev_25(struct net_device *ldv_func_arg1 ) ;
#line 1896
extern int netpoll_trap(void) ;
#line 2058
extern void __netif_schedule(struct Qdisc * ) ;
#line 2060 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_schedule_queue(struct netdev_queue *txq ) 
{ 


  {
#line 2062
  if ((txq->state & 3UL) == 0UL) {
    {
#line 2063
    __netif_schedule(txq->qdisc);
    }
  } else {

  }
#line 2064
  return;
}
}
#line 2074 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
  {
#line 2076
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
  }
#line 2077
  return;
}
}
#line 2090 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2094
  i = 0U;
#line 2094
  goto ldv_38549;
  ldv_38548: 
  {
#line 2095
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2095
  txq = tmp;
#line 2096
  netif_tx_start_queue(txq);
#line 2094
  i = i + 1U;
  }
  ldv_38549: ;
#line 2094
  if (i < dev->num_tx_queues) {
#line 2096
    goto ldv_38548;
  } else {

  }

#line 2101
  return;
}
}
#line 2126 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 2128
  __ret_warn_on = (unsigned long )dev_queue == (unsigned long )((struct netdev_queue *)0);
#line 2128
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 2128
  if (tmp != 0L) {
    {
#line 2128
    warn_slowpath_null("include/linux/netdevice.h", 2128);
    }
  } else {

  }
  {
#line 2128
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 2128
  if (tmp___0 != 0L) {
    {
#line 2129
    printk("\016netif_stop_queue() cannot be called before register_netdev()\n");
    }
#line 2130
    return;
  } else {

  }
  {
#line 2132
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
  }
#line 2133
  return;
}
}
#line 2147 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_stop_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2151
  i = 0U;
#line 2151
  goto ldv_38579;
  ldv_38578: 
  {
#line 2152
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2152
  txq = tmp;
#line 2153
  netif_tx_stop_queue(txq);
#line 2151
  i = i + 1U;
  }
  ldv_38579: ;
#line 2151
  if (i < dev->num_tx_queues) {
#line 2153
    goto ldv_38578;
  } else {

  }

#line 2158
  return;
}
}
#line 2157 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
  {
#line 2159
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
  }
#line 2159
  return (tmp != 0);
}
}
#line 2183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netdev_tx_sent_queue(struct netdev_queue *dev_queue , unsigned int bytes ) 
{ 
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2187
  dql_queued(& dev_queue->dql, bytes);
#line 2189
  tmp = dql_avail((struct dql  const  *)(& dev_queue->dql));
#line 2189
  tmp___0 = __builtin_expect(tmp >= 0, 1L);
  }
#line 2189
  if (tmp___0 != 0L) {
#line 2190
    return;
  } else {

  }
  {
#line 2192
  set_bit(1L, (unsigned long volatile   *)(& dev_queue->state));
#line 2199
  __asm__  volatile   ("mfence": : : "memory");
#line 2202
  tmp___1 = dql_avail((struct dql  const  *)(& dev_queue->dql));
#line 2202
  tmp___2 = __builtin_expect(tmp___1 >= 0, 0L);
  }
#line 2202
  if (tmp___2 != 0L) {
    {
#line 2203
    clear_bit(1L, (unsigned long volatile   *)(& dev_queue->state));
    }
  } else {

  }
#line 2204
  return;
}
}
#line 2221 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netdev_tx_completed_queue(struct netdev_queue *dev_queue , unsigned int pkts ,
                                               unsigned int bytes ) 
{ 
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2225
  tmp = __builtin_expect(bytes == 0U, 0L);
  }
#line 2225
  if (tmp != 0L) {
#line 2226
    return;
  } else {

  }
  {
#line 2228
  dql_completed(& dev_queue->dql, bytes);
#line 2235
  __asm__  volatile   ("mfence": : : "memory");
#line 2237
  tmp___0 = dql_avail((struct dql  const  *)(& dev_queue->dql));
  }
#line 2237
  if (tmp___0 < 0) {
#line 2238
    return;
  } else {

  }
  {
#line 2240
  tmp___1 = test_and_set_bit(1L, (unsigned long volatile   *)(& dev_queue->state));
  }
#line 2240
  if (tmp___1 != 0) {
    {
#line 2241
    netif_schedule_queue(dev_queue);
    }
  } else {

  }
#line 2242
  return;
}
}
#line 2261 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netdev_tx_reset_queue(struct netdev_queue *q ) 
{ 


  {
  {
#line 2264
  clear_bit(1L, (unsigned long volatile   *)(& q->state));
#line 2265
  dql_reset(& q->dql);
  }
#line 2266
  return;
}
}
#line 2307 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
  {
#line 2309
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev->state));
  }
#line 2309
  return (tmp != 0);
}
}
#line 2326 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_start_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
  {
#line 2328
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2328
  txq = tmp;
#line 2330
  netif_tx_start_queue(txq);
  }
#line 2331
  return;
}
}
#line 2340 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;

  {
  {
#line 2342
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2342
  txq = tmp;
#line 2344
  tmp___0 = netpoll_trap();
  }
#line 2344
  if (tmp___0 != 0) {
#line 2345
    return;
  } else {

  }
  {
#line 2347
  netif_tx_stop_queue(txq);
  }
#line 2348
  return;
}
}
#line 2357 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
  {
#line 2360
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
#line 2360
  txq = tmp;
#line 2362
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
  }
#line 2362
  return (tmp___0);
}
}
#line 2378 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_wake_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2380
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2380
  txq = tmp;
#line 2382
  tmp___0 = netpoll_trap();
  }
#line 2382
  if (tmp___0 != 0) {
#line 2383
    return;
  } else {

  }
  {
#line 2385
  tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& txq->state));
  }
#line 2385
  if (tmp___1 != 0) {
    {
#line 2386
    __netif_schedule(txq->qdisc);
    }
  } else {

  }
#line 2387
  return;
}
}
#line 2390
extern int netif_set_xps_queue(struct net_device * , struct cpumask  const  * , u16  ) ;
#line 2422
extern int netif_set_real_num_tx_queues(struct net_device * , unsigned int  ) ;
#line 2425
extern int netif_set_real_num_rx_queues(struct net_device * , unsigned int  ) ;
#line 2472
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
#line 2503 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
  {
#line 2505
  __dev_kfree_skb_any(skb, 1);
  }
#line 2506
  return;
}
}
#line 2513
extern int netif_rx(struct sk_buff * ) ;
#line 2515
extern int netif_receive_skb(struct sk_buff * ) ;
#line 2516
extern gro_result_t napi_gro_receive(struct napi_struct * , struct sk_buff * ) ;
#line 2601 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
  {
#line 2603
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& dev->state));
  }
#line 2603
  return (tmp == 0);
}
}
#line 2610
extern void netif_carrier_on(struct net_device * ) ;
#line 2612
extern void netif_carrier_off(struct net_device * ) ;
#line 2680
extern void netif_device_detach(struct net_device * ) ;
#line 2682
extern void netif_device_attach(struct net_device * ) ;
#line 2722 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static u32 netif_msg_init(int debug_value , int default_msg_enable_bits ) 
{ 


  {
#line 2725
  if ((unsigned int )debug_value > 31U) {
#line 2726
    return ((u32 )default_msg_enable_bits);
  } else {

  }
#line 2727
  if (debug_value == 0) {
#line 2728
    return (0U);
  } else {

  }
#line 2730
  return ((u32 )((1 << debug_value) + -1));
}
}
#line 2733 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu ) 
{ 


  {
  {
#line 2735
  spin_lock(& txq->_xmit_lock);
#line 2736
  txq->xmit_lock_owner = cpu;
  }
#line 2737
  return;
}
}
#line 2753 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq ) 
{ 


  {
  {
#line 2755
  txq->xmit_lock_owner = -1;
#line 2756
  spin_unlock(& txq->_xmit_lock);
  }
#line 2757
  return;
}
}
#line 2840 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
  {
#line 2845
  local_bh_disable();
#line 2846
  __vpp_verify = (void const   *)0;
  }
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2___0;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4___1;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8___2;
  } else {

  }
#line 2846
  goto switch_default___3;
  case_1: /* CIL Label */ ;
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1___0;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8;
  } else {

  }
#line 2846
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 2846
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 2846
  goto ldv_39108;
  case_2: /* CIL Label */ 
#line 2846
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2846
  goto ldv_39108;
  case_4: /* CIL Label */ 
#line 2846
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2846
  goto ldv_39108;
  case_8: /* CIL Label */ 
#line 2846
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2846
  goto ldv_39108;
  switch_default: /* CIL Label */ 
  {
#line 2846
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_39108: 
#line 2846
  pscr_ret__ = pfo_ret__;
#line 2846
  goto ldv_39114;
  case_2___0: /* CIL Label */ ;
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1___1;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2___1;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4___0;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8___0;
  } else {

  }
#line 2846
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
#line 2846
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 2846
  goto ldv_39118;
  case_2___1: /* CIL Label */ 
#line 2846
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2846
  goto ldv_39118;
  case_4___0: /* CIL Label */ 
#line 2846
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2846
  goto ldv_39118;
  case_8___0: /* CIL Label */ 
#line 2846
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2846
  goto ldv_39118;
  switch_default___0: /* CIL Label */ 
  {
#line 2846
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  ldv_39118: 
#line 2846
  pscr_ret__ = pfo_ret_____0;
#line 2846
  goto ldv_39114;
  case_4___1: /* CIL Label */ ;
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1___2;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2___2;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4___2;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8___1;
  } else {

  }
#line 2846
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
#line 2846
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 2846
  goto ldv_39127;
  case_2___2: /* CIL Label */ 
#line 2846
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2846
  goto ldv_39127;
  case_4___2: /* CIL Label */ 
#line 2846
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2846
  goto ldv_39127;
  case_8___1: /* CIL Label */ 
#line 2846
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2846
  goto ldv_39127;
  switch_default___1: /* CIL Label */ 
  {
#line 2846
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  ldv_39127: 
#line 2846
  pscr_ret__ = pfo_ret_____1;
#line 2846
  goto ldv_39114;
  case_8___2: /* CIL Label */ ;
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1___3;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2___3;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4___3;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8___3;
  } else {

  }
#line 2846
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
#line 2846
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 2846
  goto ldv_39136;
  case_2___3: /* CIL Label */ 
#line 2846
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2846
  goto ldv_39136;
  case_4___3: /* CIL Label */ 
#line 2846
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2846
  goto ldv_39136;
  case_8___3: /* CIL Label */ 
#line 2846
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2846
  goto ldv_39136;
  switch_default___2: /* CIL Label */ 
  {
#line 2846
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  ldv_39136: 
#line 2846
  pscr_ret__ = pfo_ret_____2;
#line 2846
  goto ldv_39114;
  switch_default___3: /* CIL Label */ 
  {
#line 2846
  __bad_size_call_parameter();
  }
#line 2846
  goto ldv_39114;
  switch_break: /* CIL Label */ ;
  }
  ldv_39114: 
#line 2846
  cpu = pscr_ret__;
#line 2847
  i = 0U;
#line 2847
  goto ldv_39146;
  ldv_39145: 
  {
#line 2848
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2848
  txq = tmp;
#line 2850
  __netif_tx_lock(txq, cpu);
#line 2851
  netif_tx_stop_queue(txq);
#line 2852
  __netif_tx_unlock(txq);
#line 2847
  i = i + 1U;
  }
  ldv_39146: ;
#line 2847
  if (i < dev->num_tx_queues) {
#line 2849
    goto ldv_39145;
  } else {

  }
  {
#line 2854
  local_bh_enable();
  }
#line 2855
  return;
}
}
#line 2903
extern int register_netdev(struct net_device * ) ;
#line 2906
static int ldv_register_netdev_22(struct net_device *ldv_func_arg1 ) ;
#line 2908
extern void unregister_netdev(struct net_device * ) ;
#line 2911
static void ldv_unregister_netdev_19(struct net_device *ldv_func_arg1 ) ;
#line 2915
static void ldv_unregister_netdev_24(struct net_device *ldv_func_arg1 ) ;
#line 2926
extern int dev_addr_add(struct net_device * , unsigned char const   * , unsigned char  ) ;
#line 2928
extern int dev_addr_del(struct net_device * , unsigned char const   * , unsigned char  ) ;
#line 2935
extern int dev_uc_add_excl(struct net_device * , unsigned char const   * ) ;
#line 2946
extern int dev_mc_add_excl(struct net_device * , unsigned char const   * ) ;
#line 2976
extern struct net_device *netdev_all_upper_get_next_dev_rcu(struct net_device * ,
                                                            struct list_head ** ) ;
#line 3130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static void netif_set_gso_max_size(struct net_device *dev , unsigned int size ) 
{ 


  {
#line 3133
  dev->gso_max_size = size;
#line 3134
  return;
}
}
#line 3149 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static bool netif_is_macvlan(struct net_device *dev ) 
{ 


  {
#line 3151
  return ((dev->priv_flags & 2097152U) != 0U);
}
}
#line 3190
extern int netdev_crit(struct net_device  const  * , char const   *  , ...) ;
#line 3192
extern int netdev_err(struct net_device  const  * , char const   *  , ...) ;
#line 3194
extern int netdev_warn(struct net_device  const  * , char const   *  , ...) ;
#line 3198
extern int netdev_info(struct net_device  const  * , char const   *  , ...) ;
#line 383 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static int pci_channel_offline(struct pci_dev *pdev ) 
{ 


  {
#line 385
  return (pdev->error_state != 1U);
}
}
#line 775
extern void pci_dev_put(struct pci_dev * ) ;
#line 798
extern int pci_find_ext_capability(struct pci_dev * , int  ) ;
#line 804
extern struct pci_dev *pci_get_device(unsigned int  , unsigned int  , struct pci_dev * ) ;
#line 824
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 830
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 842 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
  {
#line 845
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
#line 845
  return (tmp);
}
}
#line 855 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
  {
#line 858
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
  }
#line 858
  return (tmp);
}
}
#line 861
extern int pcie_capability_read_word(struct pci_dev * , int  , u16 * ) ;
#line 904
extern int pci_enable_device_mem(struct pci_dev * ) ;
#line 919
extern void pci_disable_device(struct pci_dev * ) ;
#line 922
extern void pci_set_master(struct pci_dev * ) ;
#line 947
extern int pcie_get_minimum_link(struct pci_dev * , enum pci_bus_speed * , enum pcie_link_width * ) ;
#line 963
extern int pci_select_bars(struct pci_dev * , unsigned long  ) ;
#line 975
extern int pci_save_state(struct pci_dev * ) ;
#line 976
extern void pci_restore_state(struct pci_dev * ) ;
#line 987
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 993
extern int pci_wake_from_d3(struct pci_dev * , bool  ) ;
#line 994
extern int pci_prepare_to_sleep(struct pci_dev * ) ;
#line 1046
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
#line 1048
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
#line 1085
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1089
static int ldv___pci_register_driver_26(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                        char const   *ldv_func_arg3 ) ;
#line 1098
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1101
static void ldv_pci_unregister_driver_29(struct pci_driver *ldv_func_arg1 ) ;
#line 1167
extern void pci_disable_msix(struct pci_dev * ) ;
#line 1407 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  {
#line 1409
  tmp = ldv_dev_get_drvdata_6((struct device  const  *)(& pdev->dev));
  }
#line 1409
  return (tmp);
}
}
#line 1412 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
  {
#line 1414
  ldv_dev_set_drvdata_7(& pdev->dev, data);
  }
#line 1415
  return;
}
}
#line 1420 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
  {
#line 1422
  tmp = dev_name(& pdev->dev);
  }
#line 1422
  return (tmp);
}
}
#line 1603
extern int pci_sriov_set_totalvfs(struct pci_dev * , u16  ) ;
#line 1636 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static int pci_pcie_cap(struct pci_dev *dev ) 
{ 


  {
#line 1638
  return ((int )dev->pcie_cap);
}
}
#line 1647 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static bool pci_is_pcie(struct pci_dev *dev ) 
{ 
  int tmp ;

  {
  {
#line 1649
  tmp = pci_pcie_cap(dev);
  }
#line 1649
  return (tmp != 0);
}
}
#line 1656 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static u16 pcie_caps_reg(struct pci_dev  const  *dev ) 
{ 


  {
#line 1658
  return ((u16 )dev->pcie_flags_reg);
}
}
#line 1665 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static int pci_pcie_type(struct pci_dev  const  *dev ) 
{ 
  u16 tmp ;

  {
  {
#line 1667
  tmp = pcie_caps_reg(dev);
  }
#line 1667
  return (((int )tmp & 240) >> 4);
}
}
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
  }
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_9(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                void * ) ,
                                      unsigned long flags , char const   *name , void *dev ) ;
#line 141
__inline static int ldv_request_irq_10(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 145
__inline static int ldv_request_irq_12(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 149
__inline static int ldv_request_irq_13(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 158
extern void free_irq(unsigned int  , void * ) ;
#line 161
static void ldv_free_irq_11(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 165
static void ldv_free_irq_14(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 169
static void ldv_free_irq_15(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 173
static void ldv_free_irq_16(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 209
extern int irq_set_affinity_hint(unsigned int  , struct cpumask  const  * ) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 25
  tmp = skb_network_header(skb);
  }
#line 25
  return ((struct iphdr *)tmp);
}
}
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rtnetlink.h"
extern void rtnl_lock(void) ;
#line 22
extern void rtnl_unlock(void) ;
#line 77
extern int ndo_dflt_fdb_add(struct ndmsg * , struct nlattr ** , struct net_device * ,
                            unsigned char const   * , u16  ) ;
#line 87
extern int ndo_dflt_bridge_getlink(struct sk_buff * , u32  , u32  , struct net_device * ,
                                   u16  ) ;
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
extern struct nlattr *nla_find(struct nlattr  const  * , int  , int  ) ;
#line 289 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static void *nlmsg_data(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 291
  return ((void *)nlh + 16U);
}
}
#line 298 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static int nlmsg_len(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 300
  return ((int )((unsigned int )nlh->nlmsg_len - 16U));
}
}
#line 308 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static struct nlattr *nlmsg_attrdata(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
  {
#line 311
  tmp = nlmsg_data(nlh);
#line 311
  data = (unsigned char *)tmp;
  }
#line 312
  return ((struct nlattr *)(data + ((unsigned long )((unsigned int )hdrlen + 3U) & 4294967292UL)));
}
}
#line 320 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static int nlmsg_attrlen(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  int tmp ;

  {
  {
#line 322
  tmp = nlmsg_len(nlh);
  }
#line 322
  return ((int )((unsigned int )tmp - (((unsigned int )hdrlen + 3U) & 4294967292U)));
}
}
#line 384 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static struct nlattr *nlmsg_find_attr(struct nlmsghdr  const  *nlh , int hdrlen ,
                                               int attrtype ) 
{ 
  int tmp ;
  struct nlattr *tmp___0 ;
  struct nlattr *tmp___1 ;

  {
  {
#line 387
  tmp = nlmsg_attrlen(nlh, hdrlen);
#line 387
  tmp___0 = nlmsg_attrdata(nlh, hdrlen);
#line 387
  tmp___1 = nla_find((struct nlattr  const  *)tmp___0, tmp, attrtype);
  }
#line 387
  return (tmp___1);
}
}
#line 659 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static int nla_type(struct nlattr  const  *nla ) 
{ 


  {
#line 661
  return ((int )nla->nla_type & -49153);
}
}
#line 668 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static void *nla_data(struct nlattr  const  *nla ) 
{ 


  {
#line 670
  return ((void *)nla + 4U);
}
}
#line 677 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static int nla_len(struct nlattr  const  *nla ) 
{ 


  {
#line 679
  return ((int )nla->nla_len + -4);
}
}
#line 687 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static int nla_ok(struct nlattr  const  *nla , int remaining ) 
{ 


  {
#line 689
  return ((remaining > 3 && (unsigned int )((unsigned short )nla->nla_len) > 3U) && (int )nla->nla_len <= remaining);
}
}
#line 702 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr  const  *nla , int *remaining ) 
{ 
  int totlen ;

  {
#line 704
  totlen = ((int )nla->nla_len + 3) & -4;
#line 706
  *remaining = *remaining - totlen;
#line 707
  return ((struct nlattr *)nla + (unsigned long )totlen);
}
}
#line 983 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/netlink.h"
__inline static u16 nla_get_u16(struct nlattr  const  *nla ) 
{ 
  void *tmp ;

  {
  {
#line 985
  tmp = nla_data(nla);
  }
#line 985
  return (*((u16 *)tmp));
}
}
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/tcp.h"
__inline static struct tcphdr *tcp_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 30
  tmp = skb_transport_header(skb);
  }
#line 30
  return ((struct tcphdr *)tmp);
}
}
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/tcp.h"
__inline static unsigned int tcp_hdrlen(struct sk_buff  const  *skb ) 
{ 
  struct tcphdr *tmp ;

  {
  {
#line 35
  tmp = tcp_hdr(skb);
  }
#line 35
  return ((unsigned int )((int )tmp->doff * 4));
}
}
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 69
  tmp = skb_network_header(skb);
  }
#line 69
  return ((struct ipv6hdr *)tmp);
}
}
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 47
extern int eth_validate_addr(struct net_device * ) ;
#line 49
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 53
static struct net_device *ldv_alloc_etherdev_mqs_21(int ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                                    unsigned int ldv_func_arg3 ) ;
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
static u8 const   eth_reserved_addr_base[6U]  = {      1U,      128U,      194U,      0U, 
        0U,      0U};
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
__inline static bool is_link_local_ether_addr(u8 const   *addr ) 
{ 
  __be16 *a ;
  __be16 const   *b ;
  __be16 m ;

  {
#line 69
  a = (__be16 *)addr;
#line 70
  b = (__be16 const   *)(& eth_reserved_addr_base);
#line 71
  m = 61695U;
#line 74
  return ((((unsigned int )*((u32 const   *)addr) ^ (unsigned int )*((u32 const   *)b)) | ((unsigned int )((int )*(a + 2UL) ^ (int )((unsigned short )*(b + 2UL))) & 61695U)) == 0U);
}
}
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 92
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 107 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 109
  return (((int )*addr & 1) != 0);
}
}
#line 144 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
__inline static bool is_unicast_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 146
  tmp = is_multicast_ether_addr(addr);
  }
#line 146
  if ((int )tmp != 0) {
#line 146
    tmp___0 = 0;
  } else {
#line 146
    tmp___0 = 1;
  }
#line 146
  return ((bool )tmp___0);
}
}
#line 160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 164
  tmp = is_multicast_ether_addr(addr);
  }
#line 164
  if (tmp) {
#line 164
    tmp___0 = 0;
  } else {
#line 164
    tmp___0 = 1;
  }
#line 164
  if (tmp___0) {
    {
#line 164
    tmp___1 = is_zero_ether_addr(addr);
    }
#line 164
    if (tmp___1) {
#line 164
      tmp___2 = 0;
    } else {
#line 164
      tmp___2 = 1;
    }
#line 164
    if (tmp___2) {
#line 164
      tmp___3 = 1;
    } else {
#line 164
      tmp___3 = 0;
    }
  } else {
#line 164
    tmp___3 = 0;
  }
#line 164
  return ((bool )tmp___3);
}
}
#line 337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_vlan.h"
__inline static struct sk_buff *__vlan_hwaccel_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                       u16 vlan_tci ) 
{ 


  {
#line 341
  skb->vlan_proto = vlan_proto;
#line 342
  skb->vlan_tci = (__u16 )((unsigned int )vlan_tci | 4096U);
#line 343
  return (skb);
}
}
#line 427 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_vlan.h"
__inline static __be16 vlan_get_protocol(struct sk_buff  const  *skb ) 
{ 
  __be16 protocol ;
  __be16 proto ;
  __be16 *protop ;
  void *tmp ;
  long tmp___0 ;

  {
#line 429
  protocol = 0U;
#line 431
  if (((int )skb->vlan_tci & 4096) != 0 || (unsigned int )((unsigned short )skb->protocol) != 129U) {
#line 433
    protocol = skb->protocol;
  } else {
    {
#line 436
    tmp = skb_header_pointer(skb, 16, 2, (void *)(& proto));
#line 436
    protop = (__be16 *)tmp;
#line 439
    tmp___0 = __builtin_expect((unsigned long )protop != (unsigned long )((__be16 *)0U),
                               1L);
    }
#line 439
    if (tmp___0 != 0L) {
#line 440
      protocol = *protop;
    } else {

    }
  }
#line 443
  return (protocol);
}
}
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 39
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 40
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mii.h"
__inline static struct mii_ioctl_data *if_mii(struct ifreq *rq ) 
{ 


  {
#line 47
  return ((struct mii_ioctl_data *)(& rq->ifr_ifru));
}
}
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mdio.h"
extern int mdio_mii_ioctl(struct mdio_if_info  const  * , struct mii_ioctl_data * ,
                          int  ) ;
#line 115 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw ) ;
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw , u8 *pba_num , u32 pba_num_size ) ;
#line 43
enum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status ) ;
#line 44
enum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status ) ;
#line 52
s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw ) ;
#line 62
s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw , u16 offset , u16 *data ) ;
#line 83
bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw ) ;
#line 129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static bool ixgbe_removed(void *addr ) 
{ 
  long tmp ;

  {
  {
#line 131
  tmp = __builtin_expect((unsigned long )addr == (unsigned long )((void *)0), 0L);
  }
#line 131
  return (tmp != 0L);
}
}
#line 134
void ixgbe_check_remove(struct ixgbe_hw *hw , u32 reg ) ;
#line 136 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg(struct ixgbe_hw *hw , u32 reg , u32 value ) 
{ 
  u8 *reg_addr ;
  bool tmp ;

  {
  {
#line 138
  reg_addr = *((u8 * volatile  *)(& hw->hw_addr));
#line 140
  tmp = ixgbe_removed((void *)reg_addr);
  }
#line 140
  if ((int )tmp) {
#line 141
    return;
  } else {

  }
  {
#line 142
  writel(value, (void volatile   *)reg_addr + (unsigned long )reg);
  }
#line 143
  return;
}
}
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static u32 ixgbe_read_reg(struct ixgbe_hw *hw , u32 reg ) 
{ 
  u8 *reg_addr ;
  u32 value ;
  bool tmp ;
  long tmp___0 ;

  {
  {
#line 167
  reg_addr = *((u8 * volatile  *)(& hw->hw_addr));
#line 170
  tmp = ixgbe_removed((void *)reg_addr);
  }
#line 170
  if ((int )tmp) {
#line 171
    return (4294967295U);
  } else {

  }
  {
#line 172
  value = readl((void const volatile   *)reg_addr + (unsigned long )reg);
#line 173
  tmp___0 = __builtin_expect(value == 4294967295U, 0L);
  }
#line 173
  if (tmp___0 != 0L) {
    {
#line 174
    ixgbe_check_remove(hw, reg);
    }
  } else {

  }
#line 175
  return (value);
}
}
#line 149 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *cfg , int direction , u8 up___0 ) ;
#line 152
s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw , struct ixgbe_dcb_config *dcb_config ,
                                   int max_frame , u8 direction ) ;
#line 156
s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw , struct ieee_ets *ets , int max_frame ) ;
#line 159
s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw , u8 pfc_en , u8 *prio_tc ) ;
#line 160
s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw , struct ixgbe_dcb_config *dcb_config ) ;
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dca.h"
extern void dca_register_notify(struct notifier_block * ) ;
#line 32
static void ldv_dca_register_notify_27(struct notifier_block *ldv_func_arg1 ) ;
#line 34
extern void dca_unregister_notify(struct notifier_block * ) ;
#line 37
static void ldv_dca_unregister_notify_28(struct notifier_block *ldv_func_arg1 ) ;
#line 76
extern int dca_add_requester(struct device * ) ;
#line 77
extern int dca_remove_requester(struct device * ) ;
#line 79
extern u8 dca3_get_tag(struct device * , int  ) ;
#line 121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/busy_poll.h"
__inline static void skb_mark_napi_id(struct sk_buff *skb , struct napi_struct *napi ) 
{ 


  {
#line 124
  skb->__annonCompField69.napi_id = napi->napi_id;
#line 125
  return;
}
}
#line 332 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static unsigned int ixgbe_rx_bufsz(struct ixgbe_ring *ring ) 
{ 
  int tmp ;

  {
  {
#line 335
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& ring->state));
  }
#line 335
  if (tmp != 0) {
#line 336
    return (4096U);
  } else {

  }
#line 339
  return (2048U);
}
}
#line 342 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static unsigned int ixgbe_rx_pg_order(struct ixgbe_ring *ring ) 
{ 
  int tmp ;

  {
  {
#line 345
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& ring->state));
  }
#line 345
  if (tmp != 0) {
#line 346
    return (1U);
  } else {

  }
#line 348
  return (0U);
}
}
#line 408 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static void ixgbe_qv_init_lock(struct ixgbe_q_vector *q_vector ) 
{ 
  struct lock_class_key __key ;

  {
  {
#line 411
  spinlock_check(& q_vector->lock);
#line 411
  __raw_spin_lock_init(& q_vector->lock.__annonCompField19.rlock, "&(&q_vector->lock)->rlock",
                       & __key);
#line 412
  q_vector->state = 0U;
  }
#line 413
  return;
}
}
#line 416 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_lock_napi(struct ixgbe_q_vector *q_vector ) 
{ 
  int rc ;
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 418
  rc = 1;
#line 419
  spin_lock_bh(& q_vector->lock);
  }
#line 420
  if ((q_vector->state & 7U) != 0U) {
    {
#line 421
    __ret_warn_on = (int )q_vector->state & 1;
#line 421
    tmp = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 421
    if (tmp != 0L) {
      {
#line 421
      warn_slowpath_null("drivers/net/ethernet/intel/ixgbe/ixgbe.h", 421);
      }
    } else {

    }
    {
#line 421
    __builtin_expect(__ret_warn_on != 0, 0L);
#line 422
    q_vector->state = q_vector->state | 8U;
#line 423
    rc = 0;
#line 425
    (q_vector->tx.ring)->stats.yields = (q_vector->tx.ring)->stats.yields + 1ULL;
    }
  } else {
#line 429
    q_vector->state = 1U;
  }
  {
#line 431
  spin_unlock_bh(& q_vector->lock);
  }
#line 432
  return (rc != 0);
}
}
#line 436 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_unlock_napi(struct ixgbe_q_vector *q_vector ) 
{ 
  int rc ;
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 438
  rc = 0;
#line 439
  spin_lock_bh(& q_vector->lock);
#line 440
  __ret_warn_on = (q_vector->state & 10U) != 0U;
#line 440
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 440
  if (tmp != 0L) {
    {
#line 440
    warn_slowpath_null("drivers/net/ethernet/intel/ixgbe/ixgbe.h", 441);
    }
  } else {

  }
  {
#line 440
  __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 443
  if ((q_vector->state & 16U) != 0U) {
#line 444
    rc = 1;
  } else {

  }
  {
#line 446
  q_vector->state = q_vector->state & 4U;
#line 447
  spin_unlock_bh(& q_vector->lock);
  }
#line 448
  return (rc != 0);
}
}
#line 452 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_lock_poll(struct ixgbe_q_vector *q_vector ) 
{ 
  int rc ;

  {
  {
#line 454
  rc = 1;
#line 455
  spin_lock_bh(& q_vector->lock);
  }
#line 456
  if ((q_vector->state & 7U) != 0U) {
#line 457
    q_vector->state = q_vector->state | 16U;
#line 458
    rc = 0;
#line 460
    (q_vector->rx.ring)->stats.yields = (q_vector->rx.ring)->stats.yields + 1ULL;
  } else {
#line 464
    q_vector->state = q_vector->state | 2U;
  }
  {
#line 466
  spin_unlock_bh(& q_vector->lock);
  }
#line 467
  return (rc != 0);
}
}
#line 471 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_unlock_poll(struct ixgbe_q_vector *q_vector ) 
{ 
  int rc ;
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 473
  rc = 0;
#line 474
  spin_lock_bh(& q_vector->lock);
#line 475
  __ret_warn_on = (int )q_vector->state & 1;
#line 475
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 475
  if (tmp != 0L) {
    {
#line 475
    warn_slowpath_null("drivers/net/ethernet/intel/ixgbe/ixgbe.h", 475);
    }
  } else {

  }
  {
#line 475
  __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 477
  if ((q_vector->state & 16U) != 0U) {
#line 478
    rc = 1;
  } else {

  }
  {
#line 480
  q_vector->state = q_vector->state & 4U;
#line 481
  spin_unlock_bh(& q_vector->lock);
  }
#line 482
  return (rc != 0);
}
}
#line 486 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_busy_polling(struct ixgbe_q_vector *q_vector ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 488
  __ret_warn_on = (q_vector->state & 3U) == 0U;
#line 488
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 488
  if (tmp != 0L) {
    {
#line 488
    warn_slowpath_null("drivers/net/ethernet/intel/ixgbe/ixgbe.h", 488);
    }
  } else {

  }
  {
#line 488
  __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 489
  return ((q_vector->state & 18U) != 0U);
}
}
#line 493 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static bool ixgbe_qv_disable(struct ixgbe_q_vector *q_vector ) 
{ 
  int rc ;

  {
  {
#line 495
  rc = 1;
#line 496
  spin_lock_bh(& q_vector->lock);
  }
#line 497
  if ((q_vector->state & 3U) != 0U) {
#line 498
    rc = 0;
  } else {

  }
  {
#line 499
  q_vector->state = q_vector->state | 4U;
#line 500
  spin_unlock_bh(& q_vector->lock);
  }
#line 502
  return (rc != 0);
}
}
#line 576 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static __le32 ixgbe_test_staterr(union ixgbe_adv_rx_desc *rx_desc , u32 const   stat_err_bits ) 
{ 


  {
#line 579
  return (rx_desc->wb.upper.status_error & (__le32 )stat_err_bits);
}
}
#line 582 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static u16 ixgbe_desc_unused(struct ixgbe_ring *ring ) 
{ 
  u16 ntc ;
  u16 ntu ;

  {
#line 584
  ntc = ring->next_to_clean;
#line 585
  ntu = ring->next_to_use;
#line 587
  return (((((int )ntc <= (int )ntu ? ring->count : 0U) + (unsigned int )ntc) - (unsigned int )ntu) + 65535U);
}
}
#line 590 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static void ixgbe_write_tail(struct ixgbe_ring *ring , u32 value ) 
{ 


  {
  {
#line 592
  writel(value, (void volatile   *)ring->tail);
  }
#line 593
  return;
}
}
#line 832
struct ixgbe_info ixgbe_82598_info ;
#line 833
struct ixgbe_info ixgbe_82599_info ;
#line 834
struct ixgbe_info ixgbe_X540_info ;
#line 836
struct dcbnl_rtnl_ops  const  dcbnl_ops ;
#line 839
char ixgbe_driver_name[6U] ;
#line 840
char const   ixgbe_driver_version[9U] ;
#line 842
char ixgbe_default_device_descr[39U] ;
#line 845
void ixgbe_up(struct ixgbe_adapter *adapter ) ;
#line 846
void ixgbe_down(struct ixgbe_adapter *adapter ) ;
#line 847
void ixgbe_reinit_locked(struct ixgbe_adapter *adapter ) ;
#line 848
void ixgbe_reset(struct ixgbe_adapter *adapter ) ;
#line 849
void ixgbe_set_ethtool_ops(struct net_device *netdev ) ;
#line 850
int ixgbe_setup_rx_resources(struct ixgbe_ring *rx_ring ) ;
#line 851
int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring ) ;
#line 852
void ixgbe_free_rx_resources(struct ixgbe_ring *rx_ring ) ;
#line 853
void ixgbe_free_tx_resources(struct ixgbe_ring *tx_ring ) ;
#line 854
void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) ;
#line 855
void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) ;
#line 856
void ixgbe_disable_rx_queue(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) ;
#line 857
void ixgbe_update_stats(struct ixgbe_adapter *adapter ) ;
#line 858
int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter ) ;
#line 859
int ixgbe_wol_supported(struct ixgbe_adapter *adapter , u16 device_id , u16 subdevice_id ) ;
#line 861
void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter ) ;
#line 862
netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb , struct ixgbe_adapter *adapter ,
                                  struct ixgbe_ring *tx_ring ) ;
#line 864
void ixgbe_unmap_and_free_tx_resource(struct ixgbe_ring *ring , struct ixgbe_tx_buffer *tx_buffer ) ;
#line 866
void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring , u16 cleaned_count ) ;
#line 867
void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector ) ;
#line 868
int ixgbe_poll(struct napi_struct *napi , int budget ) ;
#line 870
s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw ) ;
#line 871
s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw , u32 fdirctrl ) ;
#line 872
s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw , u32 fdirctrl ) ;
#line 873
s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_hash_dword input ,
                                          union ixgbe_atr_hash_dword common , u8 queue ) ;
#line 877
s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input_mask ) ;
#line 879
s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input ,
                                          u16 soft_id , u8 queue ) ;
#line 888
void ixgbe_set_rx_mode(struct net_device *netdev ) ;
#line 890
void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter ) ;
#line 892
int ixgbe_setup_tc(struct net_device *dev , u8 tc ) ;
#line 893
void ixgbe_tx_ctxtdesc(struct ixgbe_ring *tx_ring , u32 vlan_macip_lens , u32 fcoe_sof_eof ,
                       u32 type_tucmd , u32 mss_l4len_idx ) ;
#line 894
void ixgbe_do_reset(struct net_device *netdev ) ;
#line 896
void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter ) ;
#line 897
int ixgbe_sysfs_init(struct ixgbe_adapter *adapter ) ;
#line 900
void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter ) ;
#line 901
int ixgbe_fso(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first , u8 *hdr_len ) ;
#line 903
int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter , union ixgbe_adv_rx_desc *rx_desc ,
                   struct sk_buff *skb ) ;
#line 905
int ixgbe_fcoe_ddp_get(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                       unsigned int sgc ) ;
#line 907
int ixgbe_fcoe_ddp_target(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                          unsigned int sgc ) ;
#line 909
int ixgbe_fcoe_ddp_put(struct net_device *netdev , u16 xid ) ;
#line 910
int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter ) ;
#line 911
void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter ) ;
#line 912
int ixgbe_fcoe_enable(struct net_device *netdev ) ;
#line 913
int ixgbe_fcoe_disable(struct net_device *netdev ) ;
#line 918
int ixgbe_fcoe_get_wwn(struct net_device *netdev , u64 *wwn , int type ) ;
#line 919
int ixgbe_fcoe_get_hbainfo(struct net_device *netdev , struct netdev_fcoe_hbainfo *info ) ;
#line 921
u8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter ) ;
#line 924
void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter ) ;
#line 925
void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter ) ;
#line 926
void ixgbe_dbg_init(void) ;
#line 927
void ixgbe_dbg_exit(void) ;
#line 934 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static struct netdev_queue *txring_txq(struct ixgbe_ring  const  *ring ) 
{ 
  struct netdev_queue *tmp ;

  {
  {
#line 936
  tmp = netdev_get_tx_queue((struct net_device  const  *)ring->netdev, (unsigned int )ring->queue_index);
  }
#line 936
  return (tmp);
}
}
#line 939
void ixgbe_ptp_init(struct ixgbe_adapter *adapter ) ;
#line 940
void ixgbe_ptp_stop(struct ixgbe_adapter *adapter ) ;
#line 941
void ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter ) ;
#line 942
void ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter ) ;
#line 943
void __ixgbe_ptp_rx_hwtstamp(struct ixgbe_q_vector *q_vector , struct sk_buff *skb ) ;
#line 945 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
__inline static void ixgbe_ptp_rx_hwtstamp(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ,
                                           struct sk_buff *skb ) 
{ 
  __le32 tmp ;
  long tmp___0 ;

  {
  {
#line 949
  tmp = ixgbe_test_staterr(rx_desc, 65536U);
#line 949
  tmp___0 = __builtin_expect(tmp == 0U, 0L);
  }
#line 949
  if (tmp___0 != 0L) {
#line 950
    return;
  } else {

  }
  {
#line 952
  __ixgbe_ptp_rx_hwtstamp(rx_ring->q_vector, skb);
#line 958
  rx_ring->last_rx_timestamp = jiffies;
  }
#line 959
  return;
}
}
#line 961
int ixgbe_ptp_hwtstamp_ioctl(struct ixgbe_adapter *adapter , struct ifreq *ifr , int cmd ) ;
#line 963
void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter ) ;
#line 964
void ixgbe_ptp_reset(struct ixgbe_adapter *adapter ) ;
#line 965
void ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter , u32 eicr ) ;
#line 967
void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter ) ;
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter ) ;
#line 37
void ixgbe_msg_task(struct ixgbe_adapter *adapter ) ;
#line 38
int ixgbe_vf_configuration(struct pci_dev *pdev , unsigned int event_mask ) ;
#line 39
void ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter ) ;
#line 40
void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter ) ;
#line 41
int ixgbe_ndo_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) ;
#line 42
int ixgbe_ndo_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) ;
#line 44
int ixgbe_ndo_set_vf_bw(struct net_device *netdev , int vf , int tx_rate ) ;
#line 45
int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev , int vf , bool setting ) ;
#line 46
int ixgbe_ndo_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *ivi ) ;
#line 48
void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter ) ;
#line 49
int ixgbe_disable_sriov(struct ixgbe_adapter *adapter ) ;
#line 51
void ixgbe_enable_sriov(struct ixgbe_adapter *adapter ) ;
#line 53
int ixgbe_pci_sriov_configure(struct pci_dev *dev , int num_vfs ) ;
#line 57 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_driver_name[6U]  = {      'i',      'x',      'g',      'b', 
        'e',      '\000'};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static char const   ixgbe_driver_string[47U]  = 
#line 58
  {      'I',      'n',      't',      'e', 
        'l',      '(',      'R',      ')', 
        ' ',      '1',      '0',      ' ', 
        'G',      'i',      'g',      'a', 
        'b',      'i',      't',      ' ', 
        'P',      'C',      'I',      ' ', 
        'E',      'x',      'p',      'r', 
        'e',      's',      's',      ' ', 
        'N',      'e',      't',      'w', 
        'o',      'r',      'k',      ' ', 
        'D',      'r',      'i',      'v', 
        'e',      'r',      '\000'};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char ixgbe_default_device_descr[39U]  = 
#line 61
  {      'I',      'n',      't',      'e', 
        'l',      '(',      'R',      ')', 
        ' ',      '1',      '0',      ' ', 
        'G',      'i',      'g',      'a', 
        'b',      'i',      't',      ' ', 
        'N',      'e',      't',      'w', 
        'o',      'r',      'k',      ' ', 
        'C',      'o',      'n',      'n', 
        'e',      'c',      't',      'i', 
        'o',      'n',      '\000'};
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
char const   ixgbe_driver_version[9U]  = 
#line 68
  {      '3',      '.',      '1',      '9', 
        '.',      '1',      '-',      'k', 
        '\000'};
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static char const   ixgbe_copyright[43U]  = 
#line 69
  {      'C',      'o',      'p',      'y', 
        'r',      'i',      'g',      'h', 
        't',      ' ',      '(',      'c', 
        ')',      ' ',      '1',      '9', 
        '9',      '9',      '-',      '2', 
        '0',      '1',      '3',      ' ', 
        'I',      'n',      't',      'e', 
        'l',      ' ',      'C',      'o', 
        'r',      'p',      'o',      'r', 
        'a',      't',      'i',      'o', 
        'n',      '.',      '\000'};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct ixgbe_info  const  *ixgbe_info_tbl[3U]  = {      (struct ixgbe_info  const  *)(& ixgbe_82598_info),      (struct ixgbe_info  const  *)(& ixgbe_82599_info),      (struct ixgbe_info  const  *)(& ixgbe_X540_info)};
#line 86 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_device_id  const  ixgbe_pci_tbl[31U]  = 
#line 86
  {      {32902U, 4278U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4294U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4295U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4296U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 5387U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4317U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4332U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4337U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4321U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4340U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4315U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 5384U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {32902U, 4343U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 4348U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5399U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 4347U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5383U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5396U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 4345U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5418U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5417U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5404U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 4344U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5416U, 4294967295U, 4294967295U, 0U, 0U, 2UL}, 
        {32902U, 5453U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5455U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5464U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5463U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5450U, 4294967295U, 4294967295U, 0U, 0U, 1UL}, 
        {32902U, 5472U, 4294967295U, 4294967295U, 0U, 0U, 2UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 123
static int ixgbe_notify_dca(struct notifier_block *nb , unsigned long event , void *p ) ;
#line 125 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct notifier_block dca_notifier  =    {& ixgbe_notify_dca, (struct notifier_block *)0, 0};
#line 133 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static unsigned int max_vfs  ;
#line 139 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static unsigned int allow_unsupported_sfp  ;
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int debug  =    -1;
#line 154 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_read_pci_cfg_word_parent(struct ixgbe_adapter *adapter , u32 reg ,
                                          u16 *value ) 
{ 
  struct pci_dev *parent_dev ;
  struct pci_bus *parent_bus ;
  bool tmp ;
  int tmp___0 ;

  {
#line 160
  parent_bus = ((adapter->pdev)->bus)->parent;
#line 161
  if ((unsigned long )parent_bus == (unsigned long )((struct pci_bus *)0)) {
#line 162
    return (-1);
  } else {

  }
#line 164
  parent_dev = parent_bus->self;
#line 165
  if ((unsigned long )parent_dev == (unsigned long )((struct pci_dev *)0)) {
#line 166
    return (-1);
  } else {

  }
  {
#line 168
  tmp = pci_is_pcie(parent_dev);
  }
#line 168
  if (tmp) {
#line 168
    tmp___0 = 0;
  } else {
#line 168
    tmp___0 = 1;
  }
#line 168
  if (tmp___0) {
#line 169
    return (-1);
  } else {

  }
  {
#line 171
  pcie_capability_read_word(parent_dev, (int )reg, value);
  }
#line 172
  return (0);
}
}
#line 175 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static s32 ixgbe_get_parent_bus_info(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u16 link_status ;
  int err ;

  {
  {
#line 177
  hw = & adapter->hw;
#line 178
  link_status = 0U;
#line 181
  hw->bus.type = 3;
#line 186
  err = ixgbe_read_pci_cfg_word_parent(adapter, 18U, & link_status);
  }
#line 189
  if (err != 0) {
#line 190
    return (err);
  } else {

  }
  {
#line 192
  hw->bus.width = ixgbe_convert_bus_width((int )link_status);
#line 193
  hw->bus.speed = ixgbe_convert_bus_speed((int )link_status);
  }
#line 195
  return (0);
}
}
#line 207 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_pcie_from_parent(struct ixgbe_hw *hw ) 
{ 


  {
  {
#line 210
  if ((int )hw->device_id == 5450) {
#line 210
    goto case_5450;
  } else {

  }
#line 211
  if ((int )hw->device_id == 5464) {
#line 211
    goto case_5464;
  } else {

  }
#line 213
  goto switch_default;
  case_5450: /* CIL Label */ ;
  case_5464: /* CIL Label */ ;
#line 212
  return (1);
  switch_default: /* CIL Label */ ;
#line 214
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 218 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_minimum_link(struct ixgbe_adapter *adapter , int expected_gts ) 
{ 
  int max_gts ;
  enum pci_bus_speed speed ;
  enum pcie_link_width width ;
  struct pci_dev *pdev ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 221
  max_gts = 0;
#line 222
  speed = 255;
#line 223
  width = 255;
#line 228
  tmp = ixgbe_pcie_from_parent(& adapter->hw);
  }
#line 228
  if ((int )tmp) {
#line 229
    pdev = (((adapter->pdev)->bus)->parent)->self;
  } else {
#line 231
    pdev = adapter->pdev;
  }
  {
#line 233
  tmp___0 = pcie_get_minimum_link(pdev, & speed, & width);
  }
#line 233
  if ((tmp___0 != 0 || (unsigned int )speed == 255U) || (unsigned int )width == 255U) {
    {
#line 235
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unable to determine PCI Express bandwidth.\n");
    }
#line 236
    return;
  } else {

  }
  {
#line 240
  if ((unsigned int )speed == 20U) {
#line 240
    goto case_20;
  } else {

  }
#line 244
  if ((unsigned int )speed == 21U) {
#line 244
    goto case_21;
  } else {

  }
#line 248
  if ((unsigned int )speed == 22U) {
#line 248
    goto case_22;
  } else {

  }
#line 252
  goto switch_default;
  case_20: /* CIL Label */ 
#line 242
  max_gts = (int )((unsigned int )width * 2U);
#line 243
  goto ldv_53486;
  case_21: /* CIL Label */ 
#line 246
  max_gts = (int )((unsigned int )width * 4U);
#line 247
  goto ldv_53486;
  case_22: /* CIL Label */ 
#line 250
  max_gts = (int )((unsigned int )width * 8U);
#line 251
  goto ldv_53486;
  switch_default: /* CIL Label */ 
  {
#line 253
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unable to determine PCI Express bandwidth.\n");
  }
#line 254
  return;
  switch_break: /* CIL Label */ ;
  }
  ldv_53486: 
  {
#line 257
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "PCI Express bandwidth of %dGT/s available\n",
            max_gts);
#line 259
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "(Speed:%s, Width: x%d, Encoding Loss:%s)\n",
            (unsigned int )speed != 22U ? ((unsigned int )speed != 21U ? ((unsigned int )speed == 20U ? (char *)"2.5GT/s" : (char *)"Unknown") : (char *)"5.0GT/s") : (char *)"8.0GT/s",
            (unsigned int )width, (unsigned int )speed != 20U ? ((unsigned int )speed != 21U ? ((unsigned int )speed == 22U ? (char *)"<2%" : (char *)"Unknown") : (char *)"20%") : (char *)"20%");
  }
#line 270
  if (max_gts < expected_gts) {
    {
#line 271
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "This is not sufficient for optimal performance of this card.\n");
#line 272
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "For optimal performance, at least %dGT/s of bandwidth is required.\n",
             expected_gts);
#line 274
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "A slot with more lanes and/or higher speed is suggested.\n");
    }
  } else {

  }
#line 276
  return;
}
}
#line 278 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_event_schedule(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 280
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 280
  if (tmp == 0) {
    {
#line 280
    tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 280
    if (tmp___0 == 0) {
      {
#line 280
      tmp___1 = test_and_set_bit(4L, (unsigned long volatile   *)(& adapter->state));
      }
#line 280
      if (tmp___1 == 0) {
        {
#line 283
        schedule_work(& adapter->service_task);
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 284
  return;
}
}
#line 286 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_remove_adapter(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;

  {
#line 288
  adapter = (struct ixgbe_adapter *)hw->back;
#line 290
  if ((unsigned long )hw->hw_addr == (unsigned long )((u8 *)0U)) {
#line 291
    return;
  } else {

  }
  {
#line 292
  hw->hw_addr = (u8 *)0U;
#line 293
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter removed\n");
#line 294
  ixgbe_service_event_schedule(adapter);
  }
#line 295
  return;
}
}
#line 297 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_check_remove(struct ixgbe_hw *hw , u32 reg ) 
{ 
  u32 value ;

  {
#line 307
  if (reg == 8U) {
    {
#line 308
    ixgbe_remove_adapter(hw);
    }
#line 309
    return;
  } else {

  }
  {
#line 311
  value = ixgbe_read_reg(hw, 8U);
  }
#line 312
  if (value == 4294967295U) {
    {
#line 313
    ixgbe_remove_adapter(hw);
    }
  } else {

  }
#line 314
  return;
}
}
#line 316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_event_complete(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  {
#line 318
  tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& adapter->state));
#line 318
  tmp___0 = __builtin_expect(tmp == 0, 0L);
  }
#line 318
  if (tmp___0 != 0L) {
    {
#line 318
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"),
                         "i" (318), "i" (12UL));
#line 318
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 321
  __asm__  volatile   ("": : : "memory");
#line 322
  clear_bit(4L, (unsigned long volatile   *)(& adapter->state));
  }
#line 323
  return;
}
}
#line 330 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct ixgbe_reg_info  const  ixgbe_reg_info_tbl[19U]  = 
#line 330
  {      {0U, (char *)"CTRL"}, 
        {8U, (char *)"STATUS"}, 
        {24U, (char *)"CTRL_EXT"}, 
        {2048U, (char *)"EICR"}, 
        {8448U, (char *)"SRRCTL"}, 
        {8704U, (char *)"DRXCTL"}, 
        {4104U, (char *)"RDLEN"}, 
        {4112U, (char *)"RDH"}, 
        {4120U, (char *)"RDT"}, 
        {4136U, (char *)"RXDCTL"}, 
        {4096U, (char *)"RDBAL"}, 
        {4100U, (char *)"RDBAH"}, 
        {24576U, (char *)"TDBAL"}, 
        {24580U, (char *)"TDBAH"}, 
        {24584U, (char *)"TDLEN"}, 
        {24592U, (char *)"TDH"}, 
        {24600U, (char *)"TDT"}, 
        {24616U, (char *)"TXDCTL"}};
#line 366 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_regdump(struct ixgbe_hw *hw , struct ixgbe_reg_info *reginfo ) 
{ 
  int i ;
  int j ;
  char rname[16U] ;
  u32 regs[64U] ;
  u32 tmp ;

  {
#line 368
  i = 0;
#line 368
  j = 0;
  {
#line 373
  if (reginfo->ofs == 8448U) {
#line 373
    goto case_8448;
  } else {

  }
#line 377
  if (reginfo->ofs == 8704U) {
#line 377
    goto case_8704;
  } else {

  }
#line 381
  if (reginfo->ofs == 4104U) {
#line 381
    goto case_4104;
  } else {

  }
#line 385
  if (reginfo->ofs == 4112U) {
#line 385
    goto case_4112;
  } else {

  }
#line 389
  if (reginfo->ofs == 4120U) {
#line 389
    goto case_4120;
  } else {

  }
#line 393
  if (reginfo->ofs == 4136U) {
#line 393
    goto case_4136;
  } else {

  }
#line 397
  if (reginfo->ofs == 4096U) {
#line 397
    goto case_4096;
  } else {

  }
#line 401
  if (reginfo->ofs == 4100U) {
#line 401
    goto case_4100;
  } else {

  }
#line 405
  if (reginfo->ofs == 24576U) {
#line 405
    goto case_24576;
  } else {

  }
#line 409
  if (reginfo->ofs == 24580U) {
#line 409
    goto case_24580;
  } else {

  }
#line 413
  if (reginfo->ofs == 24584U) {
#line 413
    goto case_24584;
  } else {

  }
#line 417
  if (reginfo->ofs == 24592U) {
#line 417
    goto case_24592;
  } else {

  }
#line 421
  if (reginfo->ofs == 24600U) {
#line 421
    goto case_24600;
  } else {

  }
#line 425
  if (reginfo->ofs == 24616U) {
#line 425
    goto case_24616;
  } else {

  }
#line 429
  goto switch_default;
  case_8448: /* CIL Label */ 
#line 374
  i = 0;
#line 374
  goto ldv_53519;
  ldv_53518: 
  {
#line 375
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 15 ? (i + 2112) * 4 : (i <= 63 ? i * 64 + 4116 : (i + -64) * 64 + 53268)));
#line 374
  i = i + 1;
  }
  ldv_53519: ;
#line 374
  if (i <= 63) {
#line 376
    goto ldv_53518;
  } else {

  }

#line 376
  goto ldv_53521;
  case_8704: /* CIL Label */ 
#line 378
  i = 0;
#line 378
  goto ldv_53524;
  ldv_53523: 
  {
#line 379
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 15 ? (i + 2176) * 4 : (i <= 63 ? i * 64 + 4108 : (i + -64) * 64 + 53260)));
#line 378
  i = i + 1;
  }
  ldv_53524: ;
#line 378
  if (i <= 63) {
#line 380
    goto ldv_53523;
  } else {

  }

#line 380
  goto ldv_53521;
  case_4104: /* CIL Label */ 
#line 382
  i = 0;
#line 382
  goto ldv_53528;
  ldv_53527: 
  {
#line 383
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4104 : (i + -64) * 64 + 53256));
#line 382
  i = i + 1;
  }
  ldv_53528: ;
#line 382
  if (i <= 63) {
#line 384
    goto ldv_53527;
  } else {

  }

#line 384
  goto ldv_53521;
  case_4112: /* CIL Label */ 
#line 386
  i = 0;
#line 386
  goto ldv_53532;
  ldv_53531: 
  {
#line 387
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4112 : (i + -64) * 64 + 53264));
#line 386
  i = i + 1;
  }
  ldv_53532: ;
#line 386
  if (i <= 63) {
#line 388
    goto ldv_53531;
  } else {

  }

#line 388
  goto ldv_53521;
  case_4120: /* CIL Label */ 
#line 390
  i = 0;
#line 390
  goto ldv_53536;
  ldv_53535: 
  {
#line 391
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4120 : (i + -64) * 64 + 53272));
#line 390
  i = i + 1;
  }
  ldv_53536: ;
#line 390
  if (i <= 63) {
#line 392
    goto ldv_53535;
  } else {

  }

#line 392
  goto ldv_53521;
  case_4136: /* CIL Label */ 
#line 394
  i = 0;
#line 394
  goto ldv_53540;
  ldv_53539: 
  {
#line 395
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4136 : (i + -64) * 64 + 53288));
#line 394
  i = i + 1;
  }
  ldv_53540: ;
#line 394
  if (i <= 63) {
#line 396
    goto ldv_53539;
  } else {

  }

#line 396
  goto ldv_53521;
  case_4096: /* CIL Label */ 
#line 398
  i = 0;
#line 398
  goto ldv_53544;
  ldv_53543: 
  {
#line 399
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? (i + 64) * 64 : (i + 768) * 64));
#line 398
  i = i + 1;
  }
  ldv_53544: ;
#line 398
  if (i <= 63) {
#line 400
    goto ldv_53543;
  } else {

  }

#line 400
  goto ldv_53521;
  case_4100: /* CIL Label */ 
#line 402
  i = 0;
#line 402
  goto ldv_53548;
  ldv_53547: 
  {
#line 403
  regs[i] = ixgbe_read_reg(hw, (u32 )(i <= 63 ? i * 64 + 4100 : (i + -64) * 64 + 53252));
#line 402
  i = i + 1;
  }
  ldv_53548: ;
#line 402
  if (i <= 63) {
#line 404
    goto ldv_53547;
  } else {

  }

#line 404
  goto ldv_53521;
  case_24576: /* CIL Label */ 
#line 406
  i = 0;
#line 406
  goto ldv_53552;
  ldv_53551: 
  {
#line 407
  regs[i] = ixgbe_read_reg(hw, (u32 )((i + 384) * 64));
#line 406
  i = i + 1;
  }
  ldv_53552: ;
#line 406
  if (i <= 63) {
#line 408
    goto ldv_53551;
  } else {

  }

#line 408
  goto ldv_53521;
  case_24580: /* CIL Label */ 
#line 410
  i = 0;
#line 410
  goto ldv_53556;
  ldv_53555: 
  {
#line 411
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24580));
#line 410
  i = i + 1;
  }
  ldv_53556: ;
#line 410
  if (i <= 63) {
#line 412
    goto ldv_53555;
  } else {

  }

#line 412
  goto ldv_53521;
  case_24584: /* CIL Label */ 
#line 414
  i = 0;
#line 414
  goto ldv_53560;
  ldv_53559: 
  {
#line 415
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24584));
#line 414
  i = i + 1;
  }
  ldv_53560: ;
#line 414
  if (i <= 63) {
#line 416
    goto ldv_53559;
  } else {

  }

#line 416
  goto ldv_53521;
  case_24592: /* CIL Label */ 
#line 418
  i = 0;
#line 418
  goto ldv_53564;
  ldv_53563: 
  {
#line 419
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24592));
#line 418
  i = i + 1;
  }
  ldv_53564: ;
#line 418
  if (i <= 63) {
#line 420
    goto ldv_53563;
  } else {

  }

#line 420
  goto ldv_53521;
  case_24600: /* CIL Label */ 
#line 422
  i = 0;
#line 422
  goto ldv_53568;
  ldv_53567: 
  {
#line 423
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24600));
#line 422
  i = i + 1;
  }
  ldv_53568: ;
#line 422
  if (i <= 63) {
#line 424
    goto ldv_53567;
  } else {

  }

#line 424
  goto ldv_53521;
  case_24616: /* CIL Label */ 
#line 426
  i = 0;
#line 426
  goto ldv_53572;
  ldv_53571: 
  {
#line 427
  regs[i] = ixgbe_read_reg(hw, (u32 )(i * 64 + 24616));
#line 426
  i = i + 1;
  }
  ldv_53572: ;
#line 426
  if (i <= 63) {
#line 428
    goto ldv_53571;
  } else {

  }

#line 428
  goto ldv_53521;
  switch_default: /* CIL Label */ 
  {
#line 430
  tmp = ixgbe_read_reg(hw, reginfo->ofs);
#line 430
  printk("\016ixgbe: %-15s %08x\n", reginfo->name, tmp);
  }
#line 432
  return;
  switch_break: /* CIL Label */ ;
  }
  ldv_53521: 
#line 435
  i = 0;
#line 435
  goto ldv_53579;
  ldv_53578: 
  {
#line 436
  snprintf((char *)(& rname), 16UL, "%s[%d-%d]", reginfo->name, i * 8, i * 8 + 7);
#line 437
  printk("\vixgbe: %-15s", (char *)(& rname));
#line 438
  j = 0;
  }
#line 438
  goto ldv_53576;
  ldv_53575: 
  {
#line 439
  printk(" %08x", regs[i * 8 + j]);
#line 438
  j = j + 1;
  }
  ldv_53576: ;
#line 438
  if (j <= 7) {
#line 440
    goto ldv_53575;
  } else {

  }
  {
#line 440
  printk("\n");
#line 435
  i = i + 1;
  }
  ldv_53579: ;
#line 435
  if (i <= 7) {
#line 437
    goto ldv_53578;
  } else {

  }

#line 442
  return;
}
}
#line 448 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_dump(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  struct ixgbe_reg_info *reginfo ;
  int n ;
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_tx_buffer *tx_buffer ;
  union ixgbe_adv_tx_desc *tx_desc ;
  struct my_u0 *u0 ;
  struct ixgbe_ring *rx_ring ;
  union ixgbe_adv_rx_desc *rx_desc ;
  struct ixgbe_rx_buffer *rx_buffer_info ;
  u32 staterr ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;

  {
#line 450
  netdev = adapter->netdev;
#line 451
  hw = & adapter->hw;
#line 453
  n = 0;
#line 462
  i = 0;
#line 464
  if (((int )adapter->msg_enable & 8192) == 0) {
#line 465
    return;
  } else {

  }
#line 468
  if ((unsigned long )netdev != (unsigned long )((struct net_device *)0)) {
    {
#line 469
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Net device Info\n");
#line 470
    printk("\016ixgbe: Device Name     state            trans_start      last_rx\n");
#line 472
    printk("\016ixgbe: %-15s %016lX %016lX %016lX\n", (char *)(& netdev->name), netdev->state,
           netdev->trans_start, netdev->last_rx);
    }
  } else {

  }
  {
#line 480
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Register Dump\n");
#line 481
  printk("\016ixgbe:  Register Name   Value\n");
#line 482
  reginfo = (struct ixgbe_reg_info *)(& ixgbe_reg_info_tbl);
  }
#line 482
  goto ldv_53601;
  ldv_53600: 
  {
#line 484
  ixgbe_regdump(hw, reginfo);
#line 483
  reginfo = reginfo + 1;
  }
  ldv_53601: ;
#line 482
  if ((unsigned long )reginfo->name != (unsigned long )((char *)0)) {
#line 485
    goto ldv_53600;
  } else {

  }

#line 488
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 489
    goto exit;
  } else {
    {
#line 488
    tmp = netif_running((struct net_device  const  *)netdev);
    }
#line 488
    if (tmp) {
#line 488
      tmp___0 = 0;
    } else {
#line 488
      tmp___0 = 1;
    }
#line 488
    if (tmp___0) {
#line 489
      goto exit;
    } else {

    }
  }
  {
#line 491
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "TX Rings Summary\n");
#line 492
  printk("\016ixgbe:  %s     %s              %s        %s\n", (char *)"Queue [NTU] [NTC] [bi(ntc)->dma  ]",
         (char *)"leng", (char *)"ntw", (char *)"timestamp");
#line 495
  n = 0;
  }
#line 495
  goto ldv_53605;
  ldv_53604: 
  {
#line 496
  tx_ring = adapter->tx_ring[n];
#line 497
  tx_buffer = tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )tx_ring->next_to_clean;
#line 498
  printk("\016ixgbe:  %5d %5X %5X %016llX %08X %p %016llX\n", n, (int )tx_ring->next_to_use,
         (int )tx_ring->next_to_clean, tx_buffer->dma, tx_buffer->len, tx_buffer->next_to_watch,
         (unsigned long long )tx_buffer->time_stamp);
#line 495
  n = n + 1;
  }
  ldv_53605: ;
#line 495
  if (n < adapter->num_tx_queues) {
#line 497
    goto ldv_53604;
  } else {

  }

#line 507
  if (((int )adapter->msg_enable & 1024) == 0) {
#line 508
    goto rx_ring_summary;
  } else {

  }
  {
#line 510
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "TX Rings Dump\n");
#line 547
  n = 0;
  }
#line 547
  goto ldv_53612;
  ldv_53611: 
  {
#line 548
  tx_ring = adapter->tx_ring[n];
#line 549
  printk("\016ixgbe: ------------------------------------\n");
#line 550
  printk("\016ixgbe: TX QUEUE INDEX = %d\n", (int )tx_ring->queue_index);
#line 551
  printk("\016ixgbe: ------------------------------------\n");
#line 552
  printk("\016ixgbe: %s%s    %s              %s        %s          %s\n", (char *)"T [desc]     [address 63:0  ] ",
         (char *)"[PlPOIdStDDt Ln] [bi->dma       ] ", (char *)"leng", (char *)"ntw",
         (char *)"timestamp", (char *)"bi->skb");
#line 557
  i = 0;
  }
#line 557
  goto ldv_53609;
  ldv_53608: 
#line 558
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long )i;
#line 559
  tx_buffer = tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )i;
#line 560
  u0 = (struct my_u0 *)tx_desc;
#line 561
  if (tx_buffer->len != 0U) {
    {
#line 562
    printk("\016ixgbe: T [0x%03X]    %016llX %016llX %016llX %08X %p %016llX %p",
           i, u0->a, u0->b, tx_buffer->dma, tx_buffer->len, tx_buffer->next_to_watch,
           (unsigned long long )tx_buffer->time_stamp, tx_buffer->skb);
    }
#line 571
    if (i == (int )tx_ring->next_to_use && i == (int )tx_ring->next_to_clean) {
      {
#line 573
      printk(" NTC/U\n");
      }
    } else
#line 574
    if (i == (int )tx_ring->next_to_use) {
      {
#line 575
      printk(" NTU\n");
      }
    } else
#line 576
    if (i == (int )tx_ring->next_to_clean) {
      {
#line 577
      printk(" NTC\n");
      }
    } else {
      {
#line 579
      printk("\n");
      }
    }
#line 581
    if (((int )adapter->msg_enable & 4096) != 0 && (unsigned long )tx_buffer->skb != (unsigned long )((struct sk_buff *)0)) {
      {
#line 583
      print_hex_dump("\016", "", 1, 16, 1, (void const   *)(tx_buffer->skb)->data,
                     (size_t )tx_buffer->len, 1);
      }
    } else {

    }
  } else {

  }
#line 557
  i = i + 1;
  ldv_53609: ;
#line 557
  if ((unsigned long )tx_ring->desc != (unsigned long )((void *)0) && i < (int )tx_ring->count) {
#line 559
    goto ldv_53608;
  } else {

  }
#line 547
  n = n + 1;
  ldv_53612: ;
#line 547
  if (n < adapter->num_tx_queues) {
#line 549
    goto ldv_53611;
  } else {

  }

  rx_ring_summary: 
  {
#line 594
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "RX Rings Summary\n");
#line 595
  printk("\016ixgbe: Queue [NTU] [NTC]\n");
#line 596
  n = 0;
  }
#line 596
  goto ldv_53615;
  ldv_53614: 
  {
#line 597
  rx_ring = adapter->rx_ring[n];
#line 598
  printk("\016ixgbe: %5d %5X %5X\n", n, (int )rx_ring->next_to_use, (int )rx_ring->next_to_clean);
#line 596
  n = n + 1;
  }
  ldv_53615: ;
#line 596
  if (n < adapter->num_rx_queues) {
#line 598
    goto ldv_53614;
  } else {

  }

#line 603
  if (((int )adapter->msg_enable & 2048) == 0) {
#line 604
    goto exit;
  } else {

  }
  {
#line 606
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "RX Rings Dump\n");
#line 653
  n = 0;
  }
#line 653
  goto ldv_53621;
  ldv_53620: 
  {
#line 654
  rx_ring = adapter->rx_ring[n];
#line 655
  printk("\016ixgbe: ------------------------------------\n");
#line 656
  printk("\016ixgbe: RX QUEUE INDEX = %d\n", (int )rx_ring->queue_index);
#line 657
  printk("\016ixgbe: ------------------------------------\n");
#line 658
  printk("\016ixgbe: %s%s%s", (char *)"R  [desc]      [ PktBuf     A0] ", (char *)"[  HeadBuf   DD] [bi->dma       ] [bi->skb       ] ",
         (char *)"<-- Adv Rx Read format\n");
#line 662
  printk("\016ixgbe: %s%s%s", (char *)"RWB[desc]      [PcsmIpSHl PtRs] ", (char *)"[vl er S cks ln] ---------------- [bi->skb       ] ",
         (char *)"<-- Adv Rx Write-Back format\n");
#line 667
  i = 0;
  }
#line 667
  goto ldv_53618;
  ldv_53617: 
#line 668
  rx_buffer_info = rx_ring->__annonCompField94.rx_buffer_info + (unsigned long )i;
#line 669
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )i;
#line 670
  u0 = (struct my_u0 *)rx_desc;
#line 671
  staterr = rx_desc->wb.upper.status_error;
#line 672
  if ((int )staterr & 1) {
    {
#line 674
    printk("\016ixgbe: RWB[0x%03X]     %016llX %016llX ---------------- %p", i, u0->a,
           u0->b, rx_buffer_info->skb);
    }
  } else {
    {
#line 680
    printk("\016ixgbe: R  [0x%03X]     %016llX %016llX %016llX %p", i, u0->a, u0->b,
           rx_buffer_info->dma, rx_buffer_info->skb);
    }
#line 687
    if (((int )adapter->msg_enable & 4096) != 0 && rx_buffer_info->dma != 0ULL) {
      {
#line 689
      tmp___1 = ixgbe_rx_bufsz(rx_ring);
#line 689
      tmp___2 = lowmem_page_address((struct page  const  *)rx_buffer_info->page);
#line 689
      print_hex_dump("\016", "", 1, 16, 1, (void const   *)tmp___2 + (unsigned long )rx_buffer_info->page_offset,
                     (size_t )tmp___1, 1);
      }
    } else {

    }
  }
#line 697
  if (i == (int )rx_ring->next_to_use) {
    {
#line 698
    printk(" NTU\n");
    }
  } else
#line 699
  if (i == (int )rx_ring->next_to_clean) {
    {
#line 700
    printk(" NTC\n");
    }
  } else {
    {
#line 702
    printk("\n");
    }
  }
#line 667
  i = i + 1;
  ldv_53618: ;
#line 667
  if (i < (int )rx_ring->count) {
#line 669
    goto ldv_53617;
  } else {

  }
#line 653
  n = n + 1;
  ldv_53621: ;
#line 653
  if (n < adapter->num_rx_queues) {
#line 655
    goto ldv_53620;
  } else {

  }

  exit: ;
#line 708
  return;
}
}
#line 711 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_release_hw_control(struct ixgbe_adapter *adapter ) 
{ 
  u32 ctrl_ext ;

  {
  {
#line 716
  ctrl_ext = ixgbe_read_reg(& adapter->hw, 24U);
#line 717
  ixgbe_write_reg(& adapter->hw, 24U, ctrl_ext & 4026531839U);
  }
#line 718
  return;
}
}
#line 721 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_get_hw_control(struct ixgbe_adapter *adapter ) 
{ 
  u32 ctrl_ext ;

  {
  {
#line 726
  ctrl_ext = ixgbe_read_reg(& adapter->hw, 24U);
#line 727
  ixgbe_write_reg(& adapter->hw, 24U, ctrl_ext | 268435456U);
  }
#line 728
  return;
}
}
#line 739 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_ivar(struct ixgbe_adapter *adapter , s8 direction , u8 queue ,
                           u8 msix_vector ) 
{ 
  u32 ivar ;
  u32 index ;
  struct ixgbe_hw *hw ;

  {
#line 743
  hw = & adapter->hw;
  {
#line 745
  if ((unsigned int )hw->mac.type == 1U) {
#line 745
    goto case_1;
  } else {

  }
#line 755
  if ((unsigned int )hw->mac.type == 2U) {
#line 755
    goto case_2;
  } else {

  }
#line 756
  if ((unsigned int )hw->mac.type == 3U) {
#line 756
    goto case_3;
  } else {

  }
#line 776
  goto switch_default;
  case_1: /* CIL Label */ 
#line 746
  msix_vector = (u8 )((unsigned int )msix_vector | 128U);
#line 747
  if ((int )direction == -1) {
#line 748
    direction = 0;
  } else {

  }
  {
#line 749
  index = (u32 )(((int )direction * 64 + (int )queue) >> 2) & 31U;
#line 750
  ivar = ixgbe_read_reg(hw, (index + 576U) * 4U);
#line 751
  ivar = ivar & (u32 )(~ (255 << ((int )queue & 3) * 8));
#line 752
  ivar = ivar | (u32 )((int )msix_vector << ((int )queue & 3) * 8);
#line 753
  ixgbe_write_reg(hw, (index + 576U) * 4U, ivar);
  }
#line 754
  goto ldv_53641;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
#line 757
  if ((int )direction == -1) {
    {
#line 759
    msix_vector = (u8 )((unsigned int )msix_vector | 128U);
#line 760
    index = (u32 )(((int )queue & 1) * 8);
#line 761
    ivar = ixgbe_read_reg(& adapter->hw, 2560U);
#line 762
    ivar = ivar & (u32 )(~ (255 << (int )index));
#line 763
    ivar = ivar | (u32 )((int )msix_vector << (int )index);
#line 764
    ixgbe_write_reg(& adapter->hw, 2560U, ivar);
    }
#line 765
    goto ldv_53641;
  } else {
    {
#line 768
    msix_vector = (u8 )((unsigned int )msix_vector | 128U);
#line 769
    index = (u32 )((((int )queue & 1) * 2 + (int )direction) * 8);
#line 770
    ivar = ixgbe_read_reg(hw, (u32 )((((int )queue >> 1) + 576) * 4));
#line 771
    ivar = ivar & (u32 )(~ (255 << (int )index));
#line 772
    ivar = ivar | (u32 )((int )msix_vector << (int )index);
#line 773
    ixgbe_write_reg(hw, (u32 )((((int )queue >> 1) + 576) * 4), ivar);
    }
#line 774
    goto ldv_53641;
  }
  switch_default: /* CIL Label */ ;
#line 777
  goto ldv_53641;
  switch_break: /* CIL Label */ ;
  }
  ldv_53641: ;
#line 780
  return;
}
}
#line 781 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_rearm_queues(struct ixgbe_adapter *adapter , u64 qmask ) 
{ 
  u32 mask ;

  {
  {
#line 787
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 787
    goto case_1;
  } else {

  }
#line 791
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 791
    goto case_2;
  } else {

  }
#line 792
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 792
    goto case_3;
  } else {

  }
#line 798
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 788
  mask = (u32 )qmask & 65535U;
#line 789
  ixgbe_write_reg(& adapter->hw, 2056U, mask);
  }
#line 790
  goto ldv_53651;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 793
  mask = (u32 )qmask;
#line 794
  ixgbe_write_reg(& adapter->hw, 2704U, mask);
#line 795
  mask = (u32 )(qmask >> 32);
#line 796
  ixgbe_write_reg(& adapter->hw, 2708U, mask);
  }
#line 797
  goto ldv_53651;
  switch_default: /* CIL Label */ ;
#line 799
  goto ldv_53651;
  switch_break: /* CIL Label */ ;
  }
  ldv_53651: ;
#line 802
  return;
}
}
#line 803 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_unmap_and_free_tx_resource(struct ixgbe_ring *ring , struct ixgbe_tx_buffer *tx_buffer ) 
{ 


  {
#line 806
  if ((unsigned long )tx_buffer->skb != (unsigned long )((struct sk_buff *)0)) {
    {
#line 807
    dev_kfree_skb_any(tx_buffer->skb);
    }
#line 808
    if (tx_buffer->len != 0U) {
      {
#line 809
      dma_unmap_single_attrs(ring->dev, tx_buffer->dma, (size_t )tx_buffer->len, 1,
                             (struct dma_attrs *)0);
      }
    } else {

    }
  } else
#line 813
  if (tx_buffer->len != 0U) {
    {
#line 814
    dma_unmap_page(ring->dev, tx_buffer->dma, (size_t )tx_buffer->len, 1);
    }
  } else {

  }
#line 819
  tx_buffer->next_to_watch = (union ixgbe_adv_tx_desc *)0;
#line 820
  tx_buffer->skb = (struct sk_buff *)0;
#line 821
  tx_buffer->len = 0U;
#line 822
  return;
}
}
#line 825 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_xoff_rx_lfc(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct ixgbe_hw_stats *hwstats ;
  int i ;
  u32 data ;

  {
#line 827
  hw = & adapter->hw;
#line 828
  hwstats = & adapter->stats;
#line 832
  if ((unsigned int )hw->fc.current_mode != 3U && (unsigned int )hw->fc.current_mode != 1U) {
#line 834
    return;
  } else {

  }
  {
#line 837
  if ((unsigned int )hw->mac.type == 1U) {
#line 837
    goto case_1;
  } else {

  }
#line 840
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 838
  data = ixgbe_read_reg(hw, 53096U);
  }
#line 839
  goto ldv_53667;
  switch_default: /* CIL Label */ 
  {
#line 841
  data = ixgbe_read_reg(hw, 16808U);
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_53667: 
#line 843
  hwstats->lxoffrxc = hwstats->lxoffrxc + (u64 )data;
#line 846
  if (data == 0U) {
#line 847
    return;
  } else {

  }
#line 849
  i = 0;
#line 849
  goto ldv_53670;
  ldv_53669: 
  {
#line 850
  clear_bit(3L, (unsigned long volatile   *)(& (adapter->tx_ring[i])->state));
#line 849
  i = i + 1;
  }
  ldv_53670: ;
#line 849
  if (i < adapter->num_tx_queues) {
#line 851
    goto ldv_53669;
  } else {

  }

#line 856
  return;
}
}
#line 854 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_xoff_received(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct ixgbe_hw_stats *hwstats ;
  u32 xoff[8U] ;
  unsigned int tmp ;
  u8 tc ;
  int i ;
  bool pfc_en ;
  u32 pxoffrxc ;
  int tmp___0 ;
  struct ixgbe_ring *tx_ring ;

  {
#line 856
  hw = & adapter->hw;
#line 857
  hwstats = & adapter->stats;
#line 858
  xoff[0] = 0U;
#line 858
  tmp = 1U;
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (tmp >= 8U) {
#line 858
      goto while_break;
    } else {

    }
#line 858
    xoff[tmp] = 0U;
#line 858
    tmp = tmp + 1U;
  }
  while_break: /* CIL Label */ ;
  }
#line 861
  pfc_en = adapter->dcb_cfg.pfc_mode_enable;
#line 863
  if ((unsigned long )adapter->ixgbe_ieee_pfc != (unsigned long )((struct ieee_pfc *)0)) {
#line 864
    pfc_en = ((int )pfc_en | ((unsigned int )(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0;
  } else {

  }
#line 866
  if ((adapter->flags & 4096U) == 0U || ! pfc_en) {
    {
#line 867
    ixgbe_update_xoff_rx_lfc(adapter);
    }
#line 868
    return;
  } else {

  }
#line 872
  i = 0;
#line 872
  goto ldv_53686;
  ldv_53685: ;
  {
#line 876
  if ((unsigned int )hw->mac.type == 1U) {
#line 876
    goto case_1;
  } else {

  }
#line 879
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 877
  pxoffrxc = ixgbe_read_reg(hw, (u32 )((i + 13256) * 4));
  }
#line 878
  goto ldv_53683;
  switch_default: /* CIL Label */ 
  {
#line 880
  pxoffrxc = ixgbe_read_reg(hw, (u32 )((i + 4184) * 4));
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_53683: 
  {
#line 882
  hwstats->pxoffrxc[i] = hwstats->pxoffrxc[i] + (u64 )pxoffrxc;
#line 884
  tmp___0 = netdev_get_prio_tc_map((struct net_device  const  *)adapter->netdev, (u32 )i);
#line 884
  tc = (u8 )tmp___0;
#line 885
  xoff[(int )tc] = xoff[(int )tc] + pxoffrxc;
#line 872
  i = i + 1;
  }
  ldv_53686: ;
#line 872
  if (i < ((adapter->flags & 4096U) != 0U ? 8 : 1)) {
#line 874
    goto ldv_53685;
  } else {

  }
#line 889
  i = 0;
#line 889
  goto ldv_53690;
  ldv_53689: 
#line 890
  tx_ring = adapter->tx_ring[i];
#line 892
  tc = tx_ring->dcb_tc;
#line 893
  if (xoff[(int )tc] != 0U) {
    {
#line 894
    clear_bit(3L, (unsigned long volatile   *)(& tx_ring->state));
    }
  } else {

  }
#line 889
  i = i + 1;
  ldv_53690: ;
#line 889
  if (i < adapter->num_tx_queues) {
#line 891
    goto ldv_53689;
  } else {

  }

#line 896
  return;
}
}
#line 898 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u64 ixgbe_get_tx_completed(struct ixgbe_ring *ring ) 
{ 


  {
#line 900
  return (ring->stats.packets);
}
}
#line 903 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u64 ixgbe_get_tx_pending(struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  u32 head ;
  u32 tail ;
  void *tmp ;

  {
#line 909
  if ((unsigned long )ring->l2_accel_priv != (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 910
    adapter = (ring->l2_accel_priv)->real_adapter;
  } else {
    {
#line 912
    tmp = netdev_priv((struct net_device  const  *)ring->netdev);
#line 912
    adapter = (struct ixgbe_adapter *)tmp;
    }
  }
  {
#line 914
  hw = & adapter->hw;
#line 915
  head = ixgbe_read_reg(hw, (u32 )((int )ring->reg_idx * 64 + 24592));
#line 916
  tail = ixgbe_read_reg(hw, (u32 )((int )ring->reg_idx * 64 + 24600));
  }
#line 918
  if (head != tail) {
#line 919
    return ((u64 )(head < tail ? tail - head : (tail + (u32 )ring->count) - head));
  } else {

  }
#line 922
  return (0ULL);
}
}
#line 925 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring ) 
{ 
  u32 tx_done ;
  u64 tmp ;
  u32 tx_done_old ;
  u32 tx_pending ;
  u64 tmp___0 ;
  bool ret ;
  int tmp___1 ;

  {
  {
#line 927
  tmp = ixgbe_get_tx_completed(tx_ring);
#line 927
  tx_done = (u32 )tmp;
#line 928
  tx_done_old = (u32 )tx_ring->__annonCompField97.tx_stats.tx_done_old;
#line 929
  tmp___0 = ixgbe_get_tx_pending(tx_ring);
#line 929
  tx_pending = (u32 )tmp___0;
#line 930
  ret = 0;
#line 932
  clear_bit(2L, (unsigned long volatile   *)(& tx_ring->state));
  }
#line 946
  if (tx_done_old == tx_done && tx_pending != 0U) {
    {
#line 948
    tmp___1 = test_and_set_bit(3L, (unsigned long volatile   *)(& tx_ring->state));
#line 948
    ret = tmp___1 != 0;
    }
  } else {
    {
#line 952
    tx_ring->__annonCompField97.tx_stats.tx_done_old = (u64 )tx_done;
#line 954
    clear_bit(3L, (unsigned long volatile   *)(& tx_ring->state));
    }
  }
#line 957
  return (ret);
}
}
#line 964 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_timeout_reset(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;

  {
  {
#line 968
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 968
  if (tmp == 0) {
#line 969
    adapter->flags2 = adapter->flags2 | 64U;
#line 970
    if ((int )adapter->msg_enable & 1) {
      {
#line 970
      netdev_warn((struct net_device  const  *)adapter->netdev, "initiating reset due to tx timeout\n");
      }
    } else {

    }
    {
#line 971
    ixgbe_service_event_schedule(adapter);
    }
  } else {

  }
#line 973
  return;
}
}
#line 980 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector , struct ixgbe_ring *tx_ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_tx_buffer *tx_buffer ;
  union ixgbe_adv_tx_desc *tx_desc ;
  unsigned int total_bytes ;
  unsigned int total_packets ;
  unsigned int budget ;
  unsigned int i ;
  int tmp ;
  union ixgbe_adv_tx_desc *eop_desc ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct ixgbe_hw *hw ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  struct netdev_queue *tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  bool tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  u16 tmp___14 ;
  long tmp___15 ;

  {
  {
#line 983
  adapter = q_vector->adapter;
#line 986
  total_bytes = 0U;
#line 986
  total_packets = 0U;
#line 987
  budget = (unsigned int )q_vector->tx.work_limit;
#line 988
  i = (unsigned int )tx_ring->next_to_clean;
#line 990
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 990
  if (tmp != 0) {
#line 991
    return (1);
  } else {

  }
#line 993
  tx_buffer = tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )i;
#line 994
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long )i;
#line 995
  i = i - (unsigned int )tx_ring->count;
  ldv_53728: 
#line 998
  eop_desc = tx_buffer->next_to_watch;
#line 1001
  if ((unsigned long )eop_desc == (unsigned long )((union ixgbe_adv_tx_desc *)0)) {
#line 1002
    goto ldv_53724;
  } else {

  }
#line 1008
  if ((eop_desc->wb.status & 1U) == 0U) {
#line 1009
    goto ldv_53724;
  } else {

  }
  {
#line 1012
  tx_buffer->next_to_watch = (union ixgbe_adv_tx_desc *)0;
#line 1015
  total_bytes = total_bytes + tx_buffer->bytecount;
#line 1016
  total_packets = total_packets + (unsigned int )tx_buffer->gso_segs;
#line 1019
  dev_kfree_skb_any(tx_buffer->skb);
#line 1022
  dma_unmap_single_attrs(tx_ring->dev, tx_buffer->dma, (size_t )tx_buffer->len, 1,
                         (struct dma_attrs *)0);
#line 1028
  tx_buffer->skb = (struct sk_buff *)0;
#line 1029
  tx_buffer->len = 0U;
  }
#line 1032
  goto ldv_53726;
  ldv_53725: 
  {
#line 1033
  tx_buffer = tx_buffer + 1;
#line 1034
  tx_desc = tx_desc + 1;
#line 1035
  i = i + 1U;
#line 1036
  tmp___0 = __builtin_expect(i == 0U, 0L);
  }
#line 1036
  if (tmp___0 != 0L) {
#line 1037
    i = i - (unsigned int )tx_ring->count;
#line 1038
    tx_buffer = tx_ring->__annonCompField94.tx_buffer_info;
#line 1039
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
  } else {

  }
#line 1043
  if (tx_buffer->len != 0U) {
    {
#line 1044
    dma_unmap_page(tx_ring->dev, tx_buffer->dma, (size_t )tx_buffer->len, 1);
#line 1048
    tx_buffer->len = 0U;
    }
  } else {

  }
  ldv_53726: ;
#line 1032
  if ((unsigned long )tx_desc != (unsigned long )eop_desc) {
#line 1034
    goto ldv_53725;
  } else {

  }
  {
#line 1053
  tx_buffer = tx_buffer + 1;
#line 1054
  tx_desc = tx_desc + 1;
#line 1055
  i = i + 1U;
#line 1056
  tmp___1 = __builtin_expect(i == 0U, 0L);
  }
#line 1056
  if (tmp___1 != 0L) {
#line 1057
    i = i - (unsigned int )tx_ring->count;
#line 1058
    tx_buffer = tx_ring->__annonCompField94.tx_buffer_info;
#line 1059
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
  } else {

  }
  {
#line 1063
  __builtin_prefetch((void const   *)tx_desc);
#line 1066
  budget = budget - 1U;
#line 1067
  tmp___2 = __builtin_expect(budget != 0U, 1L);
  }
#line 1067
  if (tmp___2 != 0L) {
#line 1069
    goto ldv_53728;
  } else {

  }
  ldv_53724: 
  {
#line 1069
  i = i + (unsigned int )tx_ring->count;
#line 1070
  tx_ring->next_to_clean = (u16 )i;
#line 1071
  u64_stats_update_begin(& tx_ring->syncp);
#line 1072
  tx_ring->stats.bytes = tx_ring->stats.bytes + (u64 )total_bytes;
#line 1073
  tx_ring->stats.packets = tx_ring->stats.packets + (u64 )total_packets;
#line 1074
  u64_stats_update_begin(& tx_ring->syncp);
#line 1075
  q_vector->tx.total_bytes = q_vector->tx.total_bytes + total_bytes;
#line 1076
  q_vector->tx.total_packets = q_vector->tx.total_packets + total_packets;
#line 1078
  tmp___5 = constant_test_bit(2L, (unsigned long const volatile   *)(& tx_ring->state));
  }
#line 1078
  if (tmp___5 != 0) {
    {
#line 1078
    tmp___6 = ixgbe_check_tx_hang(tx_ring);
    }
#line 1078
    if ((int )tmp___6) {
#line 1080
      hw = & adapter->hw;
#line 1081
      if ((int )adapter->msg_enable & 1) {
        {
#line 1093
        tmp___3 = ixgbe_read_reg(hw, (u32 )((int )tx_ring->reg_idx * 64 + 24600));
#line 1093
        tmp___4 = ixgbe_read_reg(hw, (u32 )((int )tx_ring->reg_idx * 64 + 24592));
#line 1093
        netdev_err((struct net_device  const  *)adapter->netdev, "Detected Tx Unit Hang\n  Tx Queue             <%d>\n  TDH, TDT             <%x>, <%x>\n  next_to_use          <%x>\n  next_to_clean        <%x>\ntx_buffer_info[next_to_clean]\n  time_stamp           <%lx>\n  jiffies              <%lx>\n",
                   (int )tx_ring->queue_index, tmp___4, tmp___3, (int )tx_ring->next_to_use,
                   i, (tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )i)->time_stamp,
                   jiffies);
        }
      } else {

      }
      {
#line 1095
      netif_stop_subqueue(tx_ring->netdev, (int )tx_ring->queue_index);
      }
#line 1097
      if (((int )adapter->msg_enable & 2) != 0) {
        {
#line 1099
        netdev_info((struct net_device  const  *)adapter->netdev, "tx hang %d detected on queue %d, resetting adapter\n",
                    adapter->tx_timeout_count + 1U, (int )tx_ring->queue_index);
        }
      } else {

      }
      {
#line 1102
      ixgbe_tx_timeout_reset(adapter);
      }
#line 1105
      return (1);
    } else {

    }
  } else {

  }
  {
#line 1108
  tmp___7 = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 1108
  netdev_tx_completed_queue(tmp___7, total_packets, total_bytes);
#line 1112
  tmp___10 = __builtin_expect(total_packets != 0U, 0L);
  }
#line 1112
  if (tmp___10 != 0L) {
    {
#line 1112
    tmp___11 = netif_carrier_ok((struct net_device  const  *)tx_ring->netdev);
#line 1112
    tmp___12 = __builtin_expect((long )tmp___11, 0L);
    }
#line 1112
    if (tmp___12 != 0L) {
#line 1112
      tmp___13 = 1;
    } else {
#line 1112
      tmp___13 = 0;
    }
  } else {
#line 1112
    tmp___13 = 0;
  }
#line 1112
  if (tmp___13 != 0) {
    {
#line 1112
    tmp___14 = ixgbe_desc_unused(tx_ring);
#line 1112
    tmp___15 = __builtin_expect((unsigned int )tmp___14 > 41U, 0L);
    }
#line 1112
    if (tmp___15 != 0L) {
      {
#line 1117
      __asm__  volatile   ("mfence": : : "memory");
#line 1118
      tmp___8 = __netif_subqueue_stopped((struct net_device  const  *)tx_ring->netdev,
                                         (int )tx_ring->queue_index);
      }
#line 1118
      if ((int )tmp___8) {
        {
#line 1118
        tmp___9 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
        }
#line 1118
        if (tmp___9 == 0) {
          {
#line 1121
          netif_wake_subqueue(tx_ring->netdev, (int )tx_ring->queue_index);
#line 1123
          tx_ring->__annonCompField97.tx_stats.restart_queue = tx_ring->__annonCompField97.tx_stats.restart_queue + 1ULL;
          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 1127
  return (budget != 0U);
}
}
#line 1131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_tx_dca(struct ixgbe_adapter *adapter , struct ixgbe_ring *tx_ring ,
                                int cpu ) 
{ 
  struct ixgbe_hw *hw ;
  u32 txctrl ;
  u8 tmp ;
  u16 reg_offset ;

  {
  {
#line 1135
  hw = & adapter->hw;
#line 1136
  tmp = dca3_get_tag(tx_ring->dev, cpu);
#line 1136
  txctrl = (u32 )tmp;
  }
  {
#line 1140
  if ((unsigned int )hw->mac.type == 1U) {
#line 1140
    goto case_1;
  } else {

  }
#line 1143
  if ((unsigned int )hw->mac.type == 2U) {
#line 1143
    goto case_2;
  } else {

  }
#line 1144
  if ((unsigned int )hw->mac.type == 3U) {
#line 1144
    goto case_3;
  } else {

  }
#line 1148
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1141
  reg_offset = (unsigned int )((u16 )((int )tx_ring->reg_idx + 7296)) * 4U;
#line 1142
  goto ldv_53739;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 1145
  reg_offset = (unsigned int )((u16 )tx_ring->reg_idx) * 64U + 24588U;
#line 1146
  txctrl = txctrl << 24;
#line 1147
  goto ldv_53739;
  switch_default: /* CIL Label */ ;
#line 1150
  return;
  switch_break: /* CIL Label */ ;
  }
  ldv_53739: 
  {
#line 1158
  txctrl = txctrl | 8736U;
#line 1162
  ixgbe_write_reg(hw, (u32 )reg_offset, txctrl);
  }
#line 1163
  return;
}
}
#line 1165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_rx_dca(struct ixgbe_adapter *adapter , struct ixgbe_ring *rx_ring ,
                                int cpu ) 
{ 
  struct ixgbe_hw *hw ;
  u32 rxctrl ;
  u8 tmp ;
  u8 reg_idx ;

  {
  {
#line 1169
  hw = & adapter->hw;
#line 1170
  tmp = dca3_get_tag(rx_ring->dev, cpu);
#line 1170
  rxctrl = (u32 )tmp;
#line 1171
  reg_idx = rx_ring->reg_idx;
  }
  {
#line 1175
  if ((unsigned int )hw->mac.type == 2U) {
#line 1175
    goto case_2;
  } else {

  }
#line 1176
  if ((unsigned int )hw->mac.type == 3U) {
#line 1176
    goto case_3;
  } else {

  }
#line 1179
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 1177
  rxctrl = rxctrl << 24;
#line 1178
  goto ldv_53753;
  switch_default: /* CIL Label */ ;
#line 1180
  goto ldv_53753;
  switch_break: /* CIL Label */ ;
  }
  ldv_53753: 
  {
#line 1188
  rxctrl = rxctrl | 544U;
#line 1191
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2176) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4108 : ((int )reg_idx + -64) * 64 + 53260)),
                  rxctrl);
  }
#line 1192
  return;
}
}
#line 1194 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_dca(struct ixgbe_q_vector *q_vector ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_ring *ring ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 1196
  adapter = q_vector->adapter;
#line 1198
  __preempt_count_add(1);
#line 1198
  __asm__  volatile   ("": : : "memory");
#line 1198
  __vpp_verify = (void const   *)0;
  }
  {
#line 1198
  if (4UL == 1UL) {
#line 1198
    goto case_1;
  } else {

  }
#line 1198
  if (4UL == 2UL) {
#line 1198
    goto case_2___0;
  } else {

  }
#line 1198
  if (4UL == 4UL) {
#line 1198
    goto case_4___1;
  } else {

  }
#line 1198
  if (4UL == 8UL) {
#line 1198
    goto case_8___2;
  } else {

  }
#line 1198
  goto switch_default___3;
  case_1: /* CIL Label */ ;
  {
#line 1198
  if (4UL == 1UL) {
#line 1198
    goto case_1___0;
  } else {

  }
#line 1198
  if (4UL == 2UL) {
#line 1198
    goto case_2;
  } else {

  }
#line 1198
  if (4UL == 4UL) {
#line 1198
    goto case_4;
  } else {

  }
#line 1198
  if (4UL == 8UL) {
#line 1198
    goto case_8;
  } else {

  }
#line 1198
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 1198
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1198
  goto ldv_53766;
  case_2: /* CIL Label */ 
#line 1198
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1198
  goto ldv_53766;
  case_4: /* CIL Label */ 
#line 1198
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1198
  goto ldv_53766;
  case_8: /* CIL Label */ 
#line 1198
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1198
  goto ldv_53766;
  switch_default: /* CIL Label */ 
  {
#line 1198
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_53766: 
#line 1198
  pscr_ret__ = pfo_ret__;
#line 1198
  goto ldv_53772;
  case_2___0: /* CIL Label */ ;
  {
#line 1198
  if (4UL == 1UL) {
#line 1198
    goto case_1___1;
  } else {

  }
#line 1198
  if (4UL == 2UL) {
#line 1198
    goto case_2___1;
  } else {

  }
#line 1198
  if (4UL == 4UL) {
#line 1198
    goto case_4___0;
  } else {

  }
#line 1198
  if (4UL == 8UL) {
#line 1198
    goto case_8___0;
  } else {

  }
#line 1198
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
#line 1198
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1198
  goto ldv_53776;
  case_2___1: /* CIL Label */ 
#line 1198
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1198
  goto ldv_53776;
  case_4___0: /* CIL Label */ 
#line 1198
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1198
  goto ldv_53776;
  case_8___0: /* CIL Label */ 
#line 1198
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1198
  goto ldv_53776;
  switch_default___0: /* CIL Label */ 
  {
#line 1198
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  ldv_53776: 
#line 1198
  pscr_ret__ = pfo_ret_____0;
#line 1198
  goto ldv_53772;
  case_4___1: /* CIL Label */ ;
  {
#line 1198
  if (4UL == 1UL) {
#line 1198
    goto case_1___2;
  } else {

  }
#line 1198
  if (4UL == 2UL) {
#line 1198
    goto case_2___2;
  } else {

  }
#line 1198
  if (4UL == 4UL) {
#line 1198
    goto case_4___2;
  } else {

  }
#line 1198
  if (4UL == 8UL) {
#line 1198
    goto case_8___1;
  } else {

  }
#line 1198
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
#line 1198
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1198
  goto ldv_53785;
  case_2___2: /* CIL Label */ 
#line 1198
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1198
  goto ldv_53785;
  case_4___2: /* CIL Label */ 
#line 1198
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1198
  goto ldv_53785;
  case_8___1: /* CIL Label */ 
#line 1198
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1198
  goto ldv_53785;
  switch_default___1: /* CIL Label */ 
  {
#line 1198
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  ldv_53785: 
#line 1198
  pscr_ret__ = pfo_ret_____1;
#line 1198
  goto ldv_53772;
  case_8___2: /* CIL Label */ ;
  {
#line 1198
  if (4UL == 1UL) {
#line 1198
    goto case_1___3;
  } else {

  }
#line 1198
  if (4UL == 2UL) {
#line 1198
    goto case_2___3;
  } else {

  }
#line 1198
  if (4UL == 4UL) {
#line 1198
    goto case_4___3;
  } else {

  }
#line 1198
  if (4UL == 8UL) {
#line 1198
    goto case_8___3;
  } else {

  }
#line 1198
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
#line 1198
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1198
  goto ldv_53794;
  case_2___3: /* CIL Label */ 
#line 1198
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1198
  goto ldv_53794;
  case_4___3: /* CIL Label */ 
#line 1198
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1198
  goto ldv_53794;
  case_8___3: /* CIL Label */ 
#line 1198
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1198
  goto ldv_53794;
  switch_default___2: /* CIL Label */ 
  {
#line 1198
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  ldv_53794: 
#line 1198
  pscr_ret__ = pfo_ret_____2;
#line 1198
  goto ldv_53772;
  switch_default___3: /* CIL Label */ 
  {
#line 1198
  __bad_size_call_parameter();
  }
#line 1198
  goto ldv_53772;
  switch_break: /* CIL Label */ ;
  }
  ldv_53772: 
#line 1198
  cpu = pscr_ret__;
#line 1200
  if (q_vector->cpu == cpu) {
#line 1201
    goto out_no_update;
  } else {

  }
#line 1203
  ring = q_vector->tx.ring;
#line 1203
  goto ldv_53805;
  ldv_53804: 
  {
#line 1204
  ixgbe_update_tx_dca(adapter, ring, cpu);
#line 1203
  ring = ring->next;
  }
  ldv_53805: ;
#line 1203
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 1205
    goto ldv_53804;
  } else {

  }
#line 1206
  ring = q_vector->rx.ring;
#line 1206
  goto ldv_53808;
  ldv_53807: 
  {
#line 1207
  ixgbe_update_rx_dca(adapter, ring, cpu);
#line 1206
  ring = ring->next;
  }
  ldv_53808: ;
#line 1206
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 1208
    goto ldv_53807;
  } else {

  }
#line 1209
  q_vector->cpu = cpu;
  out_no_update: 
  {
#line 1211
  __asm__  volatile   ("": : : "memory");
#line 1211
  __preempt_count_sub(1);
  }
#line 1212
  return;
}
}
#line 1214 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_dca(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 1218
  if ((adapter->flags & 256U) == 0U) {
#line 1219
    return;
  } else {

  }
  {
#line 1222
  ixgbe_write_reg(& adapter->hw, 69748U, 2U);
#line 1224
  i = 0;
  }
#line 1224
  goto ldv_53815;
  ldv_53814: 
  {
#line 1225
  (adapter->q_vector[i])->cpu = -1;
#line 1226
  ixgbe_update_dca(adapter->q_vector[i]);
#line 1224
  i = i + 1;
  }
  ldv_53815: ;
#line 1224
  if (i < adapter->num_q_vectors) {
#line 1226
    goto ldv_53814;
  } else {

  }

#line 1231
  return;
}
}
#line 1230 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_notify_dca(struct device *dev , void *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  unsigned long event ;
  int tmp___0 ;

  {
  {
#line 1232
  tmp = ldv_dev_get_drvdata_8((struct device  const  *)dev);
#line 1232
  adapter = (struct ixgbe_adapter *)tmp;
#line 1233
  event = *((unsigned long *)data);
  }
#line 1235
  if ((adapter->flags & 512U) == 0U) {
#line 1236
    return (0);
  } else {

  }
  {
#line 1239
  if (event == 1UL) {
#line 1239
    goto case_1;
  } else {

  }
#line 1249
  if (event == 2UL) {
#line 1249
    goto case_2;
  } else {

  }
#line 1238
  goto switch_break;
  case_1: /* CIL Label */ ;
#line 1241
  if ((adapter->flags & 256U) != 0U) {
#line 1242
    goto ldv_53824;
  } else {

  }
  {
#line 1243
  tmp___0 = dca_add_requester(dev);
  }
#line 1243
  if (tmp___0 == 0) {
    {
#line 1244
    adapter->flags = adapter->flags | 256U;
#line 1245
    ixgbe_setup_dca(adapter);
    }
#line 1246
    goto ldv_53824;
  } else {

  }
  case_2: /* CIL Label */ ;
#line 1250
  if ((adapter->flags & 256U) != 0U) {
    {
#line 1251
    dca_remove_requester(dev);
#line 1252
    adapter->flags = adapter->flags & 4294967039U;
#line 1253
    ixgbe_write_reg(& adapter->hw, 69748U, 1U);
    }
  } else {

  }
#line 1255
  goto ldv_53824;
  switch_break: /* CIL Label */ ;
  }
  ldv_53824: ;
#line 1258
  return (0);
}
}
#line 1262 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_rx_hash(struct ixgbe_ring *ring , union ixgbe_adv_rx_desc *rx_desc ,
                                   struct sk_buff *skb ) 
{ 


  {
#line 1266
  if (((ring->netdev)->features & 2147483648ULL) != 0ULL) {
#line 1267
    skb->rxhash = rx_desc->wb.lower.hi_dword.rss;
  } else {

  }
#line 1268
  return;
}
}
#line 1278 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_rx_is_fcoe(struct ixgbe_ring *ring , union ixgbe_adv_rx_desc *rx_desc ) 
{ 
  __le16 pkt_info ;
  int tmp ;

  {
  {
#line 1281
  pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;
#line 1283
  tmp = constant_test_bit(6L, (unsigned long const volatile   *)(& ring->state));
  }
#line 1283
  return ((bool )(tmp != 0 && ((int )pkt_info & 112) == 32));
}
}
#line 1296 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_rx_checksum(struct ixgbe_ring *ring , union ixgbe_adv_rx_desc *rx_desc ,
                                       struct sk_buff *skb ) 
{ 
  __le32 tmp ;
  __le32 tmp___0 ;
  __le32 tmp___1 ;
  __le16 pkt_info ;
  int tmp___2 ;
  __le32 tmp___3 ;

  {
  {
#line 1300
  skb_checksum_none_assert((struct sk_buff  const  *)skb);
  }
#line 1303
  if (((ring->netdev)->features & 4294967296ULL) == 0ULL) {
#line 1304
    return;
  } else {

  }
  {
#line 1307
  tmp = ixgbe_test_staterr(rx_desc, 64U);
  }
#line 1307
  if (tmp != 0U) {
    {
#line 1307
    tmp___0 = ixgbe_test_staterr(rx_desc, 2147483648U);
    }
#line 1307
    if (tmp___0 != 0U) {
#line 1309
      ring->__annonCompField97.rx_stats.csum_err = ring->__annonCompField97.rx_stats.csum_err + 1ULL;
#line 1310
      return;
    } else {

    }
  } else {

  }
  {
#line 1313
  tmp___1 = ixgbe_test_staterr(rx_desc, 32U);
  }
#line 1313
  if (tmp___1 == 0U) {
#line 1314
    return;
  } else {

  }
  {
#line 1316
  tmp___3 = ixgbe_test_staterr(rx_desc, 1073741824U);
  }
#line 1316
  if (tmp___3 != 0U) {
#line 1317
    pkt_info = rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;
#line 1323
    if (((int )pkt_info & 512) != 0) {
      {
#line 1323
      tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& ring->state));
      }
#line 1323
      if (tmp___2 != 0) {
#line 1325
        return;
      } else {

      }
    } else {

    }
#line 1327
    ring->__annonCompField97.rx_stats.csum_err = ring->__annonCompField97.rx_stats.csum_err + 1ULL;
#line 1328
    return;
  } else {

  }
#line 1332
  skb->ip_summed = 1U;
#line 1333
  return;
}
}
#line 1335 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_release_rx_desc(struct ixgbe_ring *rx_ring , u32 val ) 
{ 


  {
  {
#line 1337
  rx_ring->next_to_use = (u16 )val;
#line 1340
  rx_ring->__annonCompField96.next_to_alloc = (u16 )val;
#line 1347
  __asm__  volatile   ("sfence": : : "memory");
#line 1348
  ixgbe_write_tail(rx_ring, val);
  }
#line 1349
  return;
}
}
#line 1351 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_alloc_mapped_page(struct ixgbe_ring *rx_ring , struct ixgbe_rx_buffer *bi ) 
{ 
  struct page *page ;
  dma_addr_t dma ;
  long tmp ;
  unsigned int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1354
  page = bi->page;
#line 1355
  dma = bi->dma;
#line 1358
  tmp = __builtin_expect(dma != 0ULL, 1L);
  }
#line 1358
  if (tmp != 0L) {
#line 1359
    return (1);
  } else {

  }
  {
#line 1362
  tmp___2 = __builtin_expect((unsigned long )page == (unsigned long )((struct page *)0),
                             1L);
  }
#line 1362
  if (tmp___2 != 0L) {
    {
#line 1363
    tmp___0 = ixgbe_rx_pg_order(rx_ring);
#line 1363
    page = __skb_alloc_pages(16672U, bi->skb, tmp___0);
#line 1365
    tmp___1 = __builtin_expect((unsigned long )page == (unsigned long )((struct page *)0),
                               0L);
    }
#line 1365
    if (tmp___1 != 0L) {
#line 1366
      rx_ring->__annonCompField97.rx_stats.alloc_rx_page_failed = rx_ring->__annonCompField97.rx_stats.alloc_rx_page_failed + 1ULL;
#line 1367
      return (0);
    } else {

    }
#line 1369
    bi->page = page;
  } else {

  }
  {
#line 1373
  tmp___3 = ixgbe_rx_pg_order(rx_ring);
#line 1373
  dma = dma_map_page(rx_ring->dev, page, 0UL, 4096UL << (int )tmp___3, 2);
#line 1380
  tmp___5 = dma_mapping_error(rx_ring->dev, dma);
  }
#line 1380
  if (tmp___5 != 0) {
    {
#line 1381
    tmp___4 = ixgbe_rx_pg_order(rx_ring);
#line 1381
    __free_pages(page, tmp___4);
#line 1382
    bi->page = (struct page *)0;
#line 1384
    rx_ring->__annonCompField97.rx_stats.alloc_rx_page_failed = rx_ring->__annonCompField97.rx_stats.alloc_rx_page_failed + 1ULL;
    }
#line 1385
    return (0);
  } else {

  }
#line 1388
  bi->dma = dma;
#line 1389
  bi->page_offset = 0U;
#line 1391
  return (1);
}
}
#line 1399 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring , u16 cleaned_count ) 
{ 
  union ixgbe_adv_rx_desc *rx_desc ;
  struct ixgbe_rx_buffer *bi ;
  u16 i ;
  bool tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 1403
  i = rx_ring->next_to_use;
#line 1406
  if ((unsigned int )cleaned_count == 0U) {
#line 1407
    return;
  } else {

  }
#line 1409
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )i;
#line 1410
  bi = rx_ring->__annonCompField94.rx_buffer_info + (unsigned long )i;
#line 1411
  i = (int )i - (int )rx_ring->count;
  ldv_53860: 
  {
#line 1414
  tmp = ixgbe_alloc_mapped_page(rx_ring, bi);
  }
#line 1414
  if (tmp) {
#line 1414
    tmp___0 = 0;
  } else {
#line 1414
    tmp___0 = 1;
  }
#line 1414
  if (tmp___0) {
#line 1415
    goto ldv_53859;
  } else {

  }
  {
#line 1421
  rx_desc->read.pkt_addr = bi->dma + (dma_addr_t )bi->page_offset;
#line 1423
  rx_desc = rx_desc + 1;
#line 1424
  bi = bi + 1;
#line 1425
  i = (u16 )((int )i + 1);
#line 1426
  tmp___1 = __builtin_expect((unsigned int )i == 0U, 0L);
  }
#line 1426
  if (tmp___1 != 0L) {
#line 1427
    rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc;
#line 1428
    bi = rx_ring->__annonCompField94.rx_buffer_info;
#line 1429
    i = (int )i - (int )rx_ring->count;
  } else {

  }
#line 1433
  rx_desc->read.hdr_addr = 0ULL;
#line 1435
  cleaned_count = (u16 )((int )cleaned_count - 1);
#line 1436
  if ((unsigned int )cleaned_count != 0U) {
#line 1438
    goto ldv_53860;
  } else {

  }
  ldv_53859: 
#line 1438
  i = (int )i + (int )rx_ring->count;
#line 1440
  if ((int )rx_ring->next_to_use != (int )i) {
    {
#line 1441
    ixgbe_release_rx_desc(rx_ring, (u32 )i);
    }
  } else {

  }
#line 1442
  return;
}
}
#line 1455 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static unsigned int ixgbe_get_headlen(unsigned char *data , unsigned int max_len ) 
{ 
  union __anonunion_hdr_310 hdr ;
  __be16 protocol ;
  u8 nexthdr ;
  u8 hlen ;

  {
#line 1468
  nexthdr = 0U;
#line 1472
  if (max_len <= 13U) {
#line 1473
    return (max_len);
  } else {

  }
#line 1476
  hdr.network = data;
#line 1479
  protocol = (hdr.eth)->h_proto;
#line 1480
  hdr.network = hdr.network + 14UL;
#line 1483
  if ((unsigned int )protocol == 129U) {
#line 1484
    if ((long )hdr.network - (long )data > (long )(max_len - 4U)) {
#line 1485
      return (max_len);
    } else {

    }
#line 1487
    protocol = (hdr.vlan)->h_vlan_encapsulated_proto;
#line 1488
    hdr.network = hdr.network + 4UL;
  } else {

  }
#line 1492
  if ((unsigned int )protocol == 8U) {
#line 1493
    if ((unsigned long )((long )hdr.network - (long )data) > (unsigned long )max_len - 20UL) {
#line 1494
      return (max_len);
    } else {

    }
#line 1497
    hlen = ((unsigned int )*(hdr.network) & 15U) << 2U;
#line 1500
    if ((unsigned int )hlen <= 19U) {
#line 1501
      return ((unsigned int )((long )hdr.network) - (unsigned int )((long )data));
    } else {

    }
#line 1504
    if (((int )(hdr.ipv4)->frag_off & 65311) == 0) {
#line 1505
      nexthdr = (hdr.ipv4)->protocol;
    } else {

    }
  } else
#line 1506
  if ((unsigned int )protocol == 56710U) {
#line 1507
    if ((unsigned long )((long )hdr.network - (long )data) > (unsigned long )max_len - 40UL) {
#line 1508
      return (max_len);
    } else {

    }
#line 1511
    nexthdr = (hdr.ipv6)->nexthdr;
#line 1512
    hlen = 40U;
  } else
#line 1514
  if ((unsigned int )protocol == 1673U) {
#line 1515
    if ((long )hdr.network - (long )data > (long )(max_len - 38U)) {
#line 1516
      return (max_len);
    } else {

    }
#line 1517
    hlen = 38U;
  } else {
#line 1520
    return ((unsigned int )((long )hdr.network) - (unsigned int )((long )data));
  }
#line 1524
  hdr.network = hdr.network + (unsigned long )hlen;
#line 1527
  if ((unsigned int )nexthdr == 6U) {
#line 1528
    if ((unsigned long )((long )hdr.network - (long )data) > (unsigned long )max_len - 20UL) {
#line 1529
      return (max_len);
    } else {

    }
#line 1532
    hlen = (u8 )(((int )*(hdr.network + 12UL) & 240) >> 2);
#line 1535
    if ((unsigned int )hlen <= 19U) {
#line 1536
      return ((unsigned int )((long )hdr.network) - (unsigned int )((long )data));
    } else {

    }
#line 1538
    hdr.network = hdr.network + (unsigned long )hlen;
  } else
#line 1539
  if ((unsigned int )nexthdr == 17U) {
#line 1540
    if ((unsigned long )((long )hdr.network - (long )data) > (unsigned long )max_len - 8UL) {
#line 1541
      return (max_len);
    } else {

    }
#line 1543
    hdr.network = hdr.network + 8UL;
  } else {

  }
#line 1552
  if ((long )hdr.network - (long )data < (long )max_len) {
#line 1553
    return ((unsigned int )((long )hdr.network) - (unsigned int )((long )data));
  } else {
#line 1555
    return (max_len);
  }
}
}
#line 1558 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_rsc_gso_size(struct ixgbe_ring *ring , struct sk_buff *skb ) 
{ 
  u16 hdr_len ;
  unsigned int tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
  {
#line 1561
  tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 1561
  hdr_len = (u16 )tmp;
#line 1564
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1564
  ((struct skb_shared_info *)tmp___0)->gso_size = (unsigned short )((((skb->len - (unsigned int )hdr_len) + (unsigned int )((struct ixgbe_cb *)(& skb->cb))->append_cnt) - 1U) / (unsigned int )((struct ixgbe_cb *)(& skb->cb))->append_cnt);
#line 1566
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1566
  ((struct skb_shared_info *)tmp___1)->gso_type = 1U;
  }
#line 1567
  return;
}
}
#line 1569 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_rsc_stats(struct ixgbe_ring *rx_ring , struct sk_buff *skb ) 
{ 


  {
#line 1573
  if ((unsigned int )((struct ixgbe_cb *)(& skb->cb))->append_cnt == 0U) {
#line 1574
    return;
  } else {

  }
  {
#line 1576
  rx_ring->__annonCompField97.rx_stats.rsc_count = rx_ring->__annonCompField97.rx_stats.rsc_count + (u64 )((struct ixgbe_cb *)(& skb->cb))->append_cnt;
#line 1577
  rx_ring->__annonCompField97.rx_stats.rsc_flush = rx_ring->__annonCompField97.rx_stats.rsc_flush + 1ULL;
#line 1579
  ixgbe_set_rsc_gso_size(rx_ring, skb);
#line 1582
  ((struct ixgbe_cb *)(& skb->cb))->append_cnt = 0U;
  }
#line 1583
  return;
}
}
#line 1595 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_process_skb_fields(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ,
                                     struct sk_buff *skb ) 
{ 
  struct net_device *dev ;
  u16 vid ;
  __le32 tmp ;

  {
  {
#line 1599
  dev = rx_ring->netdev;
#line 1601
  ixgbe_update_rsc_stats(rx_ring, skb);
#line 1603
  ixgbe_rx_hash(rx_ring, rx_desc, skb);
#line 1605
  ixgbe_rx_checksum(rx_ring, rx_desc, skb);
#line 1607
  ixgbe_ptp_rx_hwtstamp(rx_ring, rx_desc, skb);
  }
#line 1609
  if ((dev->features & 256ULL) != 0ULL) {
    {
#line 1609
    tmp = ixgbe_test_staterr(rx_desc, 8U);
    }
#line 1609
    if (tmp != 0U) {
      {
#line 1611
      vid = rx_desc->wb.upper.vlan;
#line 1612
      __vlan_hwaccel_put_tag(skb, 129, (int )vid);
      }
    } else {

    }
  } else {

  }
  {
#line 1615
  skb_record_rx_queue(skb, (int )rx_ring->queue_index);
#line 1617
  skb->protocol = eth_type_trans(skb, dev);
  }
#line 1618
  return;
}
}
#line 1620 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_rx_skb(struct ixgbe_q_vector *q_vector , struct sk_buff *skb ) 
{ 
  struct ixgbe_adapter *adapter ;
  bool tmp ;

  {
  {
#line 1623
  adapter = q_vector->adapter;
#line 1625
  tmp = ixgbe_qv_busy_polling(q_vector);
  }
#line 1625
  if ((int )tmp) {
    {
#line 1626
    netif_receive_skb(skb);
    }
  } else
#line 1627
  if ((adapter->flags & 128U) == 0U) {
    {
#line 1628
    napi_gro_receive(& q_vector->napi, skb);
    }
  } else {
    {
#line 1630
    netif_rx(skb);
    }
  }
#line 1631
  return;
}
}
#line 1644 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_is_non_eop(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ,
                             struct sk_buff *skb ) 
{ 
  u32 ntc ;
  __le32 rsc_enabled ;
  u32 rsc_cnt ;
  long tmp ;
  int tmp___0 ;
  __le32 tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1648
  ntc = (u32 )((int )rx_ring->next_to_clean + 1);
#line 1651
  ntc = ntc < (u32 )rx_ring->count ? ntc : 0U;
#line 1652
  rx_ring->next_to_clean = (u16 )ntc;
#line 1654
  __builtin_prefetch((void const   *)rx_ring->desc + (unsigned long )ntc);
#line 1657
  tmp___0 = constant_test_bit(4L, (unsigned long const volatile   *)(& rx_ring->state));
  }
#line 1657
  if (tmp___0 != 0) {
    {
#line 1658
    rsc_enabled = rx_desc->wb.lower.lo_dword.data & 1966080U;
#line 1661
    tmp = __builtin_expect(rsc_enabled != 0U, 0L);
    }
#line 1661
    if (tmp != 0L) {
#line 1662
      rsc_cnt = rsc_enabled;
#line 1664
      rsc_cnt = rsc_cnt >> 17;
#line 1665
      ((struct ixgbe_cb *)(& skb->cb))->append_cnt = (unsigned int )((int )((struct ixgbe_cb *)(& skb->cb))->append_cnt + (int )((u16 )rsc_cnt)) - 1U;
#line 1668
      ntc = rx_desc->wb.upper.status_error;
#line 1669
      ntc = ntc & 1048560U;
#line 1670
      ntc = ntc >> 4;
    } else {

    }
  } else {

  }
  {
#line 1675
  tmp___1 = ixgbe_test_staterr(rx_desc, 2U);
#line 1675
  tmp___2 = __builtin_expect(tmp___1 != 0U, 1L);
  }
#line 1675
  if (tmp___2 != 0L) {
#line 1676
    return (0);
  } else {

  }
#line 1679
  (rx_ring->__annonCompField94.rx_buffer_info + (unsigned long )ntc)->skb = skb;
#line 1680
  rx_ring->__annonCompField97.rx_stats.non_eop_descs = rx_ring->__annonCompField97.rx_stats.non_eop_descs + 1ULL;
#line 1682
  return (1);
}
}
#line 1697 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_pull_tail(struct ixgbe_ring *rx_ring , struct sk_buff *skb ) 
{ 
  struct skb_frag_struct *frag ;
  unsigned char *tmp ;
  unsigned char *va ;
  unsigned int pull_len ;
  void *tmp___0 ;

  {
  {
#line 1700
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1700
  frag = (struct skb_frag_struct *)(& ((struct skb_shared_info *)tmp)->frags);
#line 1709
  tmp___0 = skb_frag_address((skb_frag_t const   *)frag);
#line 1709
  va = (unsigned char *)tmp___0;
#line 1715
  pull_len = ixgbe_get_headlen(va, 256U);
#line 1718
  skb_copy_to_linear_data(skb, (void const   *)va, (pull_len + 7U) & 4294967288U);
#line 1721
  skb_frag_size_sub(frag, (int )pull_len);
#line 1722
  frag->page_offset = frag->page_offset + pull_len;
#line 1723
  skb->data_len = skb->data_len - pull_len;
#line 1724
  skb->tail = skb->tail + pull_len;
  }
#line 1725
  return;
}
}
#line 1737 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring , struct sk_buff *skb ) 
{ 
  unsigned int tmp ;
  struct skb_frag_struct *frag ;
  unsigned char *tmp___0 ;
  unsigned int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1741
  tmp___2 = __builtin_expect((long )((struct ixgbe_cb *)(& skb->cb))->page_released,
                             0L);
  }
#line 1741
  if (tmp___2 != 0L) {
    {
#line 1742
    tmp = ixgbe_rx_pg_order(rx_ring);
#line 1742
    dma_unmap_page(rx_ring->dev, ((struct ixgbe_cb *)(& skb->cb))->dma, 4096UL << (int )tmp,
                   2);
#line 1744
    ((struct ixgbe_cb *)(& skb->cb))->page_released = 0;
    }
  } else {
    {
#line 1746
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1746
    frag = (struct skb_frag_struct *)(& ((struct skb_shared_info *)tmp___0)->frags);
#line 1748
    tmp___1 = ixgbe_rx_bufsz(rx_ring);
#line 1748
    dma_sync_single_range_for_cpu(rx_ring->dev, ((struct ixgbe_cb *)(& skb->cb))->dma,
                                  (unsigned long )frag->page_offset, (size_t )tmp___1,
                                  2);
    }
  }
#line 1754
  ((struct ixgbe_cb *)(& skb->cb))->dma = 0ULL;
#line 1755
  return;
}
}
#line 1775 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_cleanup_headers(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ,
                                  struct sk_buff *skb ) 
{ 
  struct net_device *netdev ;
  __le32 tmp ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int pad_len ;
  int tmp___4 ;
  long tmp___5 ;

  {
  {
#line 1779
  netdev = rx_ring->netdev;
#line 1782
  tmp = ixgbe_test_staterr(rx_desc, 989855744U);
#line 1782
  tmp___0 = __builtin_expect(tmp != 0U, 0L);
  }
#line 1782
  if (tmp___0 != 0L) {
    {
#line 1782
    tmp___1 = __builtin_expect((netdev->features & 68719476736ULL) == 0ULL, 0L);
    }
#line 1782
    if (tmp___1 != 0L) {
      {
#line 1785
      dev_kfree_skb_any(skb);
      }
#line 1786
      return (1);
    } else {

    }
  } else {

  }
  {
#line 1790
  tmp___2 = skb_is_nonlinear((struct sk_buff  const  *)skb);
  }
#line 1790
  if ((int )tmp___2) {
    {
#line 1791
    ixgbe_pull_tail(rx_ring, skb);
    }
  } else {

  }
  {
#line 1795
  tmp___3 = ixgbe_rx_is_fcoe(rx_ring, rx_desc);
  }
#line 1795
  if ((int )tmp___3) {
#line 1796
    return (0);
  } else {

  }
  {
#line 1800
  tmp___5 = __builtin_expect(skb->len <= 59U, 0L);
  }
#line 1800
  if (tmp___5 != 0L) {
    {
#line 1801
    pad_len = (int )(60U - skb->len);
#line 1803
    tmp___4 = skb_pad(skb, pad_len);
    }
#line 1803
    if (tmp___4 != 0) {
#line 1804
      return (1);
    } else {

    }
    {
#line 1805
    __skb_put(skb, (unsigned int )pad_len);
    }
  } else {

  }
#line 1808
  return (0);
}
}
#line 1818 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reuse_rx_page(struct ixgbe_ring *rx_ring , struct ixgbe_rx_buffer *old_buff ) 
{ 
  struct ixgbe_rx_buffer *new_buff ;
  u16 nta ;
  unsigned int tmp ;

  {
  {
#line 1822
  nta = rx_ring->__annonCompField96.next_to_alloc;
#line 1824
  new_buff = rx_ring->__annonCompField94.rx_buffer_info + (unsigned long )nta;
#line 1827
  nta = (u16 )((int )nta + 1);
#line 1828
  rx_ring->__annonCompField96.next_to_alloc = (int )nta < (int )rx_ring->count ? nta : 0U;
#line 1831
  new_buff->page = old_buff->page;
#line 1832
  new_buff->dma = old_buff->dma;
#line 1833
  new_buff->page_offset = old_buff->page_offset;
#line 1836
  tmp = ixgbe_rx_bufsz(rx_ring);
#line 1836
  dma_sync_single_range_for_device(rx_ring->dev, new_buff->dma, (unsigned long )new_buff->page_offset,
                                   (size_t )tmp, 2);
  }
#line 1839
  return;
}
}
#line 1857 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static bool ixgbe_add_rx_frag(struct ixgbe_ring *rx_ring , struct ixgbe_rx_buffer *rx_buffer ,
                              union ixgbe_adv_rx_desc *rx_desc , struct sk_buff *skb ) 
{ 
  struct page *page ;
  unsigned int size ;
  unsigned int truesize ;
  unsigned int tmp ;
  unsigned char *va ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;

  {
  {
#line 1862
  page = rx_buffer->page;
#line 1863
  size = (unsigned int )rx_desc->wb.upper.length;
#line 1865
  tmp = ixgbe_rx_bufsz(rx_ring);
#line 1865
  truesize = tmp;
  }
#line 1872
  if (size <= 256U) {
    {
#line 1872
    tmp___5 = skb_is_nonlinear((struct sk_buff  const  *)skb);
    }
#line 1872
    if (tmp___5) {
#line 1872
      tmp___6 = 0;
    } else {
#line 1872
      tmp___6 = 1;
    }
#line 1872
    if (tmp___6) {
      {
#line 1873
      tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 1873
      va = (unsigned char *)tmp___0 + (unsigned long )rx_buffer->page_offset;
#line 1875
      tmp___1 = __skb_put(skb, size);
#line 1875
      memcpy((void *)tmp___1, (void const   *)va, (size_t )(size + 7U) & 4294967288UL);
#line 1878
      tmp___2 = page_to_nid((struct page  const  *)page);
#line 1878
      tmp___3 = numa_node_id();
#line 1878
      tmp___4 = __builtin_expect(tmp___2 == tmp___3, 1L);
      }
#line 1878
      if (tmp___4 != 0L) {
#line 1879
        return (1);
      } else {

      }
      {
#line 1882
      put_page(page);
      }
#line 1883
      return (0);
    } else {

    }
  } else {

  }
  {
#line 1886
  tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1886
  skb_add_rx_frag(skb, (int )((struct skb_shared_info *)tmp___7)->nr_frags, page,
                  (int )rx_buffer->page_offset, (int )size, truesize);
#line 1890
  tmp___8 = page_to_nid((struct page  const  *)page);
#line 1890
  tmp___9 = numa_node_id();
#line 1890
  tmp___10 = __builtin_expect(tmp___8 != tmp___9, 0L);
  }
#line 1890
  if (tmp___10 != 0L) {
#line 1891
    return (0);
  } else {

  }
  {
#line 1895
  tmp___11 = page_count(page);
#line 1895
  tmp___12 = __builtin_expect(tmp___11 != 1, 0L);
  }
#line 1895
  if (tmp___12 != 0L) {
#line 1896
    return (0);
  } else {

  }
  {
#line 1899
  rx_buffer->page_offset = rx_buffer->page_offset ^ truesize;
#line 1906
  atomic_set(& page->__annonCompField43.__annonCompField42.__annonCompField41._count,
             2);
  }
#line 1918
  return (1);
}
}
#line 1921 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct sk_buff *ixgbe_fetch_rx_buffer(struct ixgbe_ring *rx_ring , union ixgbe_adv_rx_desc *rx_desc ) 
{ 
  struct ixgbe_rx_buffer *rx_buffer ;
  struct sk_buff *skb ;
  struct page *page ;
  void *page_addr ;
  void *tmp ;
  long tmp___0 ;
  __le32 tmp___1 ;
  long tmp___2 ;
  __le32 tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned int tmp___6 ;
  bool tmp___7 ;

  {
  {
#line 1928
  rx_buffer = rx_ring->__annonCompField94.rx_buffer_info + (unsigned long )rx_ring->next_to_clean;
#line 1929
  page = rx_buffer->page;
#line 1930
  prefetchw((void const   *)page);
#line 1932
  skb = rx_buffer->skb;
#line 1934
  tmp___5 = __builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                             1L);
  }
#line 1934
  if (tmp___5 != 0L) {
    {
#line 1935
    tmp = lowmem_page_address((struct page  const  *)page);
#line 1935
    page_addr = tmp + (unsigned long )rx_buffer->page_offset;
#line 1939
    __builtin_prefetch((void const   *)page_addr);
#line 1941
    __builtin_prefetch((void const   *)page_addr + 64U);
#line 1945
    skb = netdev_alloc_skb_ip_align(rx_ring->netdev, 256U);
#line 1947
    tmp___0 = __builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
    }
#line 1947
    if (tmp___0 != 0L) {
#line 1948
      rx_ring->__annonCompField97.rx_stats.alloc_rx_buff_failed = rx_ring->__annonCompField97.rx_stats.alloc_rx_buff_failed + 1ULL;
#line 1949
      return ((struct sk_buff *)0);
    } else {

    }
    {
#line 1957
    prefetchw((void const   *)skb->data);
#line 1965
    tmp___1 = ixgbe_test_staterr(rx_desc, 2U);
#line 1965
    tmp___2 = __builtin_expect(tmp___1 != 0U, 1L);
    }
#line 1965
    if (tmp___2 != 0L) {
#line 1966
      goto dma_sync;
    } else {

    }
#line 1968
    ((struct ixgbe_cb *)(& skb->cb))->dma = rx_buffer->dma;
  } else {
    {
#line 1970
    tmp___3 = ixgbe_test_staterr(rx_desc, 2U);
    }
#line 1970
    if (tmp___3 != 0U) {
      {
#line 1971
      ixgbe_dma_sync_frag(rx_ring, skb);
      }
    } else {

    }
    dma_sync: 
    {
#line 1975
    tmp___4 = ixgbe_rx_bufsz(rx_ring);
#line 1975
    dma_sync_single_range_for_cpu(rx_ring->dev, rx_buffer->dma, (unsigned long )rx_buffer->page_offset,
                                  (size_t )tmp___4, 2);
    }
  }
  {
#line 1983
  tmp___7 = ixgbe_add_rx_frag(rx_ring, rx_buffer, rx_desc, skb);
  }
#line 1983
  if ((int )tmp___7) {
    {
#line 1985
    ixgbe_reuse_rx_page(rx_ring, rx_buffer);
    }
  } else
#line 1986
  if (((struct ixgbe_cb *)(& skb->cb))->dma == rx_buffer->dma) {
#line 1988
    ((struct ixgbe_cb *)(& skb->cb))->page_released = 1;
  } else {
    {
#line 1991
    tmp___6 = ixgbe_rx_pg_order(rx_ring);
#line 1991
    dma_unmap_page(rx_ring->dev, rx_buffer->dma, 4096UL << (int )tmp___6, 2);
    }
  }
#line 1997
  rx_buffer->skb = (struct sk_buff *)0;
#line 1998
  rx_buffer->dma = 0ULL;
#line 1999
  rx_buffer->page = (struct page *)0;
#line 2001
  return (skb);
}
}
#line 2017 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector , struct ixgbe_ring *rx_ring ,
                              int const   budget ) 
{ 
  unsigned int total_rx_bytes ;
  unsigned int total_rx_packets ;
  struct ixgbe_adapter *adapter ;
  int ddp_bytes ;
  unsigned int mss ;
  u16 cleaned_count ;
  u16 tmp ;
  union ixgbe_adv_rx_desc *rx_desc ;
  struct sk_buff *skb ;
  __le32 tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  long tmp___4 ;

  {
  {
#line 2021
  total_rx_bytes = 0U;
#line 2021
  total_rx_packets = 0U;
#line 2023
  adapter = q_vector->adapter;
#line 2025
  mss = 0U;
#line 2027
  tmp = ixgbe_desc_unused(rx_ring);
#line 2027
  cleaned_count = tmp;
  }
  ldv_53963: ;
#line 2034
  if ((unsigned int )cleaned_count > 15U) {
    {
#line 2035
    ixgbe_alloc_rx_buffers(rx_ring, (int )cleaned_count);
#line 2036
    cleaned_count = 0U;
    }
  } else {

  }
  {
#line 2039
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )rx_ring->next_to_clean;
#line 2041
  tmp___0 = ixgbe_test_staterr(rx_desc, 1U);
  }
#line 2041
  if (tmp___0 == 0U) {
#line 2042
    goto ldv_53961;
  } else {

  }
  {
#line 2049
  __asm__  volatile   ("lfence": : : "memory");
#line 2052
  skb = ixgbe_fetch_rx_buffer(rx_ring, rx_desc);
  }
#line 2055
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 2056
    goto ldv_53961;
  } else {

  }
  {
#line 2058
  cleaned_count = (u16 )((int )cleaned_count + 1);
#line 2061
  tmp___1 = ixgbe_is_non_eop(rx_ring, rx_desc, skb);
  }
#line 2061
  if ((int )tmp___1) {
#line 2062
    goto ldv_53962;
  } else {

  }
  {
#line 2065
  tmp___2 = ixgbe_cleanup_headers(rx_ring, rx_desc, skb);
  }
#line 2065
  if ((int )tmp___2) {
#line 2066
    goto ldv_53962;
  } else {

  }
  {
#line 2069
  total_rx_bytes = total_rx_bytes + skb->len;
#line 2072
  ixgbe_process_skb_fields(rx_ring, rx_desc, skb);
#line 2076
  tmp___3 = ixgbe_rx_is_fcoe(rx_ring, rx_desc);
  }
#line 2076
  if ((int )tmp___3) {
    {
#line 2077
    ddp_bytes = ixgbe_fcoe_ddp(adapter, rx_desc, skb);
    }
#line 2079
    if (ddp_bytes > 0) {
#line 2080
      if (mss == 0U) {
#line 2081
        mss = (rx_ring->netdev)->mtu - 46U;
#line 2085
        if (mss > 512U) {
#line 2086
          mss = mss & 4294966784U;
        } else {

        }
      } else {

      }
#line 2088
      total_rx_bytes = total_rx_bytes + (unsigned int )ddp_bytes;
#line 2089
      total_rx_packets = total_rx_packets + (((unsigned int )ddp_bytes + mss) - 1U) / mss;
    } else {

    }
#line 2092
    if (ddp_bytes == 0) {
      {
#line 2093
      dev_kfree_skb_any(skb);
      }
#line 2094
      goto ldv_53962;
    } else {

    }
  } else {

  }
  {
#line 2099
  skb_mark_napi_id(skb, & q_vector->napi);
#line 2100
  ixgbe_rx_skb(q_vector, skb);
#line 2103
  total_rx_packets = total_rx_packets + 1U;
  }
  ldv_53962: 
  {
#line 2104
  tmp___4 = __builtin_expect(total_rx_packets < (unsigned int )budget, 1L);
  }
#line 2104
  if (tmp___4 != 0L) {
#line 2106
    goto ldv_53963;
  } else {

  }
  ldv_53961: 
  {
#line 2106
  u64_stats_update_begin(& rx_ring->syncp);
#line 2107
  rx_ring->stats.packets = rx_ring->stats.packets + (u64 )total_rx_packets;
#line 2108
  rx_ring->stats.bytes = rx_ring->stats.bytes + (u64 )total_rx_bytes;
#line 2109
  u64_stats_update_begin(& rx_ring->syncp);
#line 2110
  q_vector->rx.total_packets = q_vector->rx.total_packets + total_rx_packets;
#line 2111
  q_vector->rx.total_bytes = q_vector->rx.total_bytes + total_rx_bytes;
  }
#line 2113
  if ((unsigned int )cleaned_count != 0U) {
    {
#line 2114
    ixgbe_alloc_rx_buffers(rx_ring, (int )cleaned_count);
    }
  } else {

  }
#line 2116
  return ((int )total_rx_packets);
}
}
#line 2121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_low_latency_recv(struct napi_struct *napi ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  struct napi_struct  const  *__mptr ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_ring *ring ;
  int found ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2124
  __mptr = (struct napi_struct  const  *)napi;
#line 2124
  q_vector = (struct ixgbe_q_vector *)__mptr + 0xffffffffffffffc0UL;
#line 2125
  adapter = q_vector->adapter;
#line 2127
  found = 0;
#line 2129
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 2129
  if (tmp != 0) {
#line 2130
    return (-1);
  } else {

  }
  {
#line 2132
  tmp___0 = ixgbe_qv_lock_poll(q_vector);
  }
#line 2132
  if (tmp___0) {
#line 2132
    tmp___1 = 0;
  } else {
#line 2132
    tmp___1 = 1;
  }
#line 2132
  if (tmp___1) {
#line 2133
    return (-2);
  } else {

  }
#line 2135
  ring = q_vector->rx.ring;
#line 2135
  goto ldv_53975;
  ldv_53974: 
  {
#line 2136
  found = ixgbe_clean_rx_irq(q_vector, ring, 4);
  }
#line 2138
  if (found != 0) {
#line 2139
    ring->stats.cleaned = ring->stats.cleaned + (u64 )found;
  } else {
#line 2141
    ring->stats.misses = ring->stats.misses + 1ULL;
  }
#line 2143
  if (found != 0) {
#line 2144
    goto ldv_53973;
  } else {

  }
#line 2135
  ring = ring->next;
  ldv_53975: ;
#line 2135
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2137
    goto ldv_53974;
  } else {

  }
  ldv_53973: 
  {
#line 2147
  ixgbe_qv_unlock_poll(q_vector);
  }
#line 2149
  return (found);
}
}
#line 2160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_msix(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  int v_idx ;
  u32 mask ;
  u32 eitrsel ;
  struct ixgbe_ring *ring ;

  {
#line 2167
  if (adapter->num_vfs > 32U) {
    {
#line 2168
    eitrsel = (u32 )((1 << (int )(adapter->num_vfs - 32U)) + -1);
#line 2169
    ixgbe_write_reg(& adapter->hw, 2196U, eitrsel);
    }
  } else {

  }
#line 2176
  v_idx = 0;
#line 2176
  goto ldv_53991;
  ldv_53990: 
#line 2178
  q_vector = adapter->q_vector[v_idx];
#line 2180
  ring = q_vector->rx.ring;
#line 2180
  goto ldv_53985;
  ldv_53984: 
  {
#line 2181
  ixgbe_set_ivar(adapter, 0, (int )ring->reg_idx, (int )((u8 )v_idx));
#line 2180
  ring = ring->next;
  }
  ldv_53985: ;
#line 2180
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2182
    goto ldv_53984;
  } else {

  }
#line 2183
  ring = q_vector->tx.ring;
#line 2183
  goto ldv_53988;
  ldv_53987: 
  {
#line 2184
  ixgbe_set_ivar(adapter, 1, (int )ring->reg_idx, (int )((u8 )v_idx));
#line 2183
  ring = ring->next;
  }
  ldv_53988: ;
#line 2183
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2185
    goto ldv_53987;
  } else {

  }
  {
#line 2186
  ixgbe_write_eitr(q_vector);
#line 2176
  v_idx = v_idx + 1;
  }
  ldv_53991: ;
#line 2176
  if (v_idx < adapter->num_q_vectors) {
#line 2178
    goto ldv_53990;
  } else {

  }

  {
#line 2190
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 2190
    goto case_1;
  } else {

  }
#line 2194
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 2194
    goto case_2;
  } else {

  }
#line 2195
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 2195
    goto case_3;
  } else {

  }
#line 2198
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2191
  ixgbe_set_ivar(adapter, -1, 97, (int )((u8 )v_idx));
  }
#line 2193
  goto ldv_53994;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 2196
  ixgbe_set_ivar(adapter, -1, 1, (int )((u8 )v_idx));
  }
#line 2197
  goto ldv_53994;
  switch_default: /* CIL Label */ ;
#line 2199
  goto ldv_53994;
  switch_break: /* CIL Label */ ;
  }
  ldv_53994: 
  {
#line 2201
  ixgbe_write_reg(& adapter->hw, (u32 )(v_idx <= 23 ? (v_idx + 520) * 4 : (v_idx + 18600) * 4),
                  1950U);
#line 2204
  mask = 3222339583U;
#line 2205
  mask = mask & 2145910783U;
#line 2209
  ixgbe_write_reg(& adapter->hw, 2064U, mask);
  }
#line 2210
  return;
}
}
#line 2234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector , struct ixgbe_ring_container *ring_container ) 
{ 
  int bytes ;
  int packets ;
  u32 timepassed_us ;
  u64 bytes_perint ;
  u8 itr_setting ;

  {
#line 2237
  bytes = (int )ring_container->total_bytes;
#line 2238
  packets = (int )ring_container->total_packets;
#line 2241
  itr_setting = ring_container->itr;
#line 2243
  if (packets == 0) {
#line 2244
    return;
  } else {

  }
#line 2252
  timepassed_us = (u32 )((int )q_vector->itr >> 2);
#line 2253
  if (timepassed_us == 0U) {
#line 2254
    return;
  } else {

  }
#line 2256
  bytes_perint = (u64 )((u32 )bytes / timepassed_us);
  {
#line 2259
  if ((int )itr_setting == 0) {
#line 2259
    goto case_0;
  } else {

  }
#line 2263
  if ((int )itr_setting == 1) {
#line 2263
    goto case_1;
  } else {

  }
#line 2269
  if ((int )itr_setting == 2) {
#line 2269
    goto case_2;
  } else {

  }
#line 2258
  goto switch_break;
  case_0: /* CIL Label */ ;
#line 2260
  if (bytes_perint > 10ULL) {
#line 2261
    itr_setting = 1U;
  } else {

  }
#line 2262
  goto ldv_54013;
  case_1: /* CIL Label */ ;
#line 2264
  if (bytes_perint > 20ULL) {
#line 2265
    itr_setting = 2U;
  } else
#line 2266
  if (bytes_perint <= 10ULL) {
#line 2267
    itr_setting = 0U;
  } else {

  }
#line 2268
  goto ldv_54013;
  case_2: /* CIL Label */ ;
#line 2270
  if (bytes_perint <= 20ULL) {
#line 2271
    itr_setting = 1U;
  } else {

  }
#line 2272
  goto ldv_54013;
  switch_break: /* CIL Label */ ;
  }
  ldv_54013: 
#line 2276
  ring_container->total_bytes = 0U;
#line 2277
  ring_container->total_packets = 0U;
#line 2280
  ring_container->itr = itr_setting;
#line 2281
  return;
}
}
#line 2291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  int v_idx ;
  u32 itr_reg ;

  {
#line 2293
  adapter = q_vector->adapter;
#line 2294
  hw = & adapter->hw;
#line 2295
  v_idx = (int )q_vector->v_idx;
#line 2296
  itr_reg = (u32 )q_vector->itr & 4088U;
  {
#line 2299
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 2299
    goto case_1;
  } else {

  }
#line 2303
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 2303
    goto case_2;
  } else {

  }
#line 2304
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 2304
    goto case_3;
  } else {

  }
#line 2311
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2301
  itr_reg = itr_reg | (itr_reg << 16);
#line 2302
  goto ldv_54024;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 2309
  itr_reg = itr_reg | 2147483648U;
#line 2310
  goto ldv_54024;
  switch_default: /* CIL Label */ ;
#line 2312
  goto ldv_54024;
  switch_break: /* CIL Label */ ;
  }
  ldv_54024: 
  {
#line 2314
  ixgbe_write_reg(hw, (u32 )(v_idx <= 23 ? (v_idx + 520) * 4 : (v_idx + 18600) * 4),
                  itr_reg);
  }
#line 2315
  return;
}
}
#line 2317 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_itr(struct ixgbe_q_vector *q_vector ) 
{ 
  u32 new_itr ;
  u8 current_itr ;
  u8 _max1 ;
  u8 _max2 ;

  {
  {
#line 2319
  new_itr = (u32 )q_vector->itr;
#line 2322
  ixgbe_update_itr(q_vector, & q_vector->tx);
#line 2323
  ixgbe_update_itr(q_vector, & q_vector->rx);
#line 2325
  _max1 = q_vector->rx.itr;
#line 2325
  _max2 = q_vector->tx.itr;
#line 2325
  current_itr = (u8 )((int )_max1 > (int )_max2 ? _max1 : _max2);
  }
  {
#line 2329
  if ((int )current_itr == 0) {
#line 2329
    goto case_0;
  } else {

  }
#line 2332
  if ((int )current_itr == 1) {
#line 2332
    goto case_1;
  } else {

  }
#line 2335
  if ((int )current_itr == 2) {
#line 2335
    goto case_2;
  } else {

  }
#line 2338
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2330
  new_itr = 40U;
#line 2331
  goto ldv_54037;
  case_1: /* CIL Label */ 
#line 2333
  new_itr = 200U;
#line 2334
  goto ldv_54037;
  case_2: /* CIL Label */ 
#line 2336
  new_itr = 500U;
#line 2337
  goto ldv_54037;
  switch_default: /* CIL Label */ ;
#line 2339
  goto ldv_54037;
  switch_break: /* CIL Label */ ;
  }
  ldv_54037: ;
#line 2342
  if (new_itr != (u32 )q_vector->itr) {
    {
#line 2344
    new_itr = ((new_itr * (u32 )q_vector->itr) * 10U) / (new_itr * 9U + (u32 )q_vector->itr);
#line 2348
    q_vector->itr = (u16 )new_itr;
#line 2350
    ixgbe_write_eitr(q_vector);
    }
  } else {

  }
#line 2352
  return;
}
}
#line 2358 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_overtemp_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 eicr ;
  int tmp ;
  u32 speed ;
  bool link_up ;
  s32 tmp___0 ;

  {
  {
#line 2360
  hw = & adapter->hw;
#line 2361
  eicr = adapter->interrupt_event;
#line 2363
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 2363
  if (tmp != 0) {
#line 2364
    return;
  } else {

  }
#line 2366
  if (*((unsigned int *)adapter + 135UL) == 0U) {
#line 2368
    return;
  } else {

  }
#line 2370
  adapter->flags2 = adapter->flags2 & 4294967287U;
  {
#line 2373
  if ((int )hw->device_id == 5404) {
#line 2373
    goto case_5404;
  } else {

  }
#line 2400
  goto switch_default;
  case_5404: /* CIL Label */ ;
#line 2381
  if ((eicr & 17825792U) == 0U) {
#line 2383
    return;
  } else {

  }
#line 2385
  if ((eicr & 1048576U) == 0U && (unsigned long )hw->mac.ops.check_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                                     ixgbe_link_speed * ,
                                                                                                     bool * ,
                                                                                                     bool  ))0)) {
    {
#line 2387
    link_up = 0;
#line 2389
    (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
    }
#line 2391
    if ((int )link_up) {
#line 2392
      return;
    } else {

    }
  } else {

  }
  {
#line 2396
  tmp___0 = (*(hw->phy.ops.check_overtemp))(hw);
  }
#line 2396
  if (tmp___0 != -26) {
#line 2397
    return;
  } else {

  }
#line 2399
  goto ldv_54049;
  switch_default: /* CIL Label */ ;
#line 2401
  if ((eicr & 16777216U) == 0U) {
#line 2402
    return;
  } else {

  }
#line 2403
  goto ldv_54049;
  switch_break: /* CIL Label */ ;
  }
  ldv_54049: ;
#line 2405
  if ((int )adapter->msg_enable & 1) {
    {
#line 2408
    netdev_crit((struct net_device  const  *)adapter->netdev, "Network adapter has been stopped because it has over heated. Restart the computer. If the problem persists, power off the system and replace the adapter\n");
    }
  } else {

  }
#line 2410
  adapter->interrupt_event = 0U;
#line 2411
  return;
}
}
#line 2413 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_fan_failure(struct ixgbe_adapter *adapter , u32 eicr ) 
{ 
  struct ixgbe_hw *hw ;

  {
#line 2415
  hw = & adapter->hw;
#line 2417
  if ((adapter->flags & 32768U) != 0U && (eicr & 33554432U) != 0U) {
#line 2419
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 2419
      netdev_crit((struct net_device  const  *)adapter->netdev, "Fan has stopped, replace the adapter\n");
      }
    } else {

    }
    {
#line 2421
    ixgbe_write_reg(hw, 2048U, 33554432U);
    }
  } else {

  }
#line 2423
  return;
}
}
#line 2425 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_overtemp_event(struct ixgbe_adapter *adapter , u32 eicr ) 
{ 
  int tmp ;

  {
#line 2427
  if ((adapter->flags2 & 4U) == 0U) {
#line 2428
    return;
  } else {

  }
  {
#line 2431
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 2431
    goto case_2;
  } else {

  }
#line 2444
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 2444
    goto case_3;
  } else {

  }
#line 2448
  goto switch_default;
  case_2: /* CIL Label */ ;
#line 2436
  if ((eicr & 17825792U) != 0U) {
    {
#line 2436
    tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 2436
    if (tmp == 0) {
      {
#line 2438
      adapter->interrupt_event = eicr;
#line 2439
      adapter->flags2 = adapter->flags2 | 8U;
#line 2440
      ixgbe_service_event_schedule(adapter);
      }
#line 2441
      return;
    } else {

    }
  } else {

  }
#line 2443
  return;
  case_3: /* CIL Label */ ;
#line 2445
  if ((eicr & 8388608U) == 0U) {
#line 2446
    return;
  } else {

  }
#line 2447
  goto ldv_54062;
  switch_default: /* CIL Label */ ;
#line 2449
  return;
  switch_break: /* CIL Label */ ;
  }
  ldv_54062: ;
#line 2452
  if ((int )adapter->msg_enable & 1) {
    {
#line 2455
    netdev_crit((struct net_device  const  *)adapter->netdev, "Network adapter has been stopped because it has over heated. Restart the computer. If the problem persists, power off the system and replace the adapter\n");
    }
  } else {

  }
#line 2456
  return;
}
}
#line 2458 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_sfp_event(struct ixgbe_adapter *adapter , u32 eicr ) 
{ 
  struct ixgbe_hw *hw ;
  int tmp ;
  int tmp___0 ;

  {
#line 2460
  hw = & adapter->hw;
#line 2462
  if ((eicr & 67108864U) != 0U) {
    {
#line 2464
    ixgbe_write_reg(hw, 2048U, 67108864U);
#line 2465
    tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 2465
    if (tmp == 0) {
      {
#line 2466
      adapter->flags2 = adapter->flags2 | 32U;
#line 2467
      ixgbe_service_event_schedule(adapter);
      }
    } else {

    }
  } else {

  }
#line 2471
  if ((eicr & 33554432U) != 0U) {
    {
#line 2473
    ixgbe_write_reg(hw, 2048U, 33554432U);
#line 2474
    tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 2474
    if (tmp___0 == 0) {
      {
#line 2475
      adapter->flags = adapter->flags | 131072U;
#line 2476
      ixgbe_service_event_schedule(adapter);
      }
    } else {

    }
  } else {

  }
#line 2479
  return;
}
}
#line 2481 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_lsc(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int tmp ;

  {
  {
#line 2483
  hw = & adapter->hw;
#line 2485
  adapter->lsc_int = adapter->lsc_int + 1ULL;
#line 2486
  adapter->flags = adapter->flags | 65536U;
#line 2487
  adapter->link_check_timeout = jiffies;
#line 2488
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 2488
  if (tmp == 0) {
    {
#line 2489
    ixgbe_write_reg(hw, 2184U, 1048576U);
#line 2490
    ixgbe_read_reg(hw, 8U);
#line 2491
    ixgbe_service_event_schedule(adapter);
    }
  } else {

  }
#line 2493
  return;
}
}
#line 2495 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_enable_queues(struct ixgbe_adapter *adapter , u64 qmask ) 
{ 
  u32 mask ;
  struct ixgbe_hw *hw ;

  {
#line 2499
  hw = & adapter->hw;
  {
#line 2502
  if ((unsigned int )hw->mac.type == 1U) {
#line 2502
    goto case_1;
  } else {

  }
#line 2506
  if ((unsigned int )hw->mac.type == 2U) {
#line 2506
    goto case_2;
  } else {

  }
#line 2507
  if ((unsigned int )hw->mac.type == 3U) {
#line 2507
    goto case_3;
  } else {

  }
#line 2515
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2503
  mask = (u32 )qmask & 65535U;
#line 2504
  ixgbe_write_reg(hw, 2176U, mask);
  }
#line 2505
  goto ldv_54080;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 2508
  mask = (u32 )qmask;
#line 2509
  if (mask != 0U) {
    {
#line 2510
    ixgbe_write_reg(hw, 2720U, mask);
    }
  } else {

  }
#line 2511
  mask = (u32 )(qmask >> 32);
#line 2512
  if (mask != 0U) {
    {
#line 2513
    ixgbe_write_reg(hw, 2724U, mask);
    }
  } else {

  }
#line 2514
  goto ldv_54080;
  switch_default: /* CIL Label */ ;
#line 2516
  goto ldv_54080;
  switch_break: /* CIL Label */ ;
  }
  ldv_54080: ;
#line 2520
  return;
}
}
#line 2521 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_disable_queues(struct ixgbe_adapter *adapter , u64 qmask ) 
{ 
  u32 mask ;
  struct ixgbe_hw *hw ;

  {
#line 2525
  hw = & adapter->hw;
  {
#line 2528
  if ((unsigned int )hw->mac.type == 1U) {
#line 2528
    goto case_1;
  } else {

  }
#line 2532
  if ((unsigned int )hw->mac.type == 2U) {
#line 2532
    goto case_2;
  } else {

  }
#line 2533
  if ((unsigned int )hw->mac.type == 3U) {
#line 2533
    goto case_3;
  } else {

  }
#line 2541
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2529
  mask = (u32 )qmask & 65535U;
#line 2530
  ixgbe_write_reg(hw, 2184U, mask);
  }
#line 2531
  goto ldv_54091;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 2534
  mask = (u32 )qmask;
#line 2535
  if (mask != 0U) {
    {
#line 2536
    ixgbe_write_reg(hw, 2736U, mask);
    }
  } else {

  }
#line 2537
  mask = (u32 )(qmask >> 32);
#line 2538
  if (mask != 0U) {
    {
#line 2539
    ixgbe_write_reg(hw, 2740U, mask);
    }
  } else {

  }
#line 2540
  goto ldv_54091;
  switch_default: /* CIL Label */ ;
#line 2542
  goto ldv_54091;
  switch_break: /* CIL Label */ ;
  }
  ldv_54091: ;
#line 2546
  return;
}
}
#line 2551 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_enable(struct ixgbe_adapter *adapter , bool queues ,
                                      bool flush ) 
{ 
  u32 mask ;

  {
#line 2554
  mask = 3222274048U;
#line 2557
  if ((adapter->flags & 65536U) != 0U) {
#line 2558
    mask = mask & 4293918719U;
  } else {

  }
#line 2560
  if ((adapter->flags2 & 4U) != 0U) {
    {
#line 2562
    if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 2562
      goto case_2;
    } else {

    }
#line 2565
    if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 2565
      goto case_3;
    } else {

    }
#line 2568
    goto switch_default;
    case_2: /* CIL Label */ 
#line 2563
    mask = mask | 16777216U;
#line 2564
    goto ldv_54102;
    case_3: /* CIL Label */ 
#line 2566
    mask = mask | 8388608U;
#line 2567
    goto ldv_54102;
    switch_default: /* CIL Label */ ;
#line 2569
    goto ldv_54102;
    switch_break: /* CIL Label */ ;
    }
    ldv_54102: ;
  } else {

  }
#line 2571
  if ((adapter->flags & 32768U) != 0U) {
#line 2572
    mask = mask | 33554432U;
  } else {

  }
  {
#line 2574
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 2574
    goto case_2___0;
  } else {

  }
#line 2577
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 2577
    goto case_3___0;
  } else {

  }
#line 2581
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 2575
  mask = mask | 33554432U;
#line 2576
  mask = mask | 67108864U;
  case_3___0: /* CIL Label */ 
#line 2578
  mask = mask | 268435456U;
#line 2579
  mask = mask | 524288U;
#line 2580
  goto ldv_54107;
  switch_default___0: /* CIL Label */ ;
#line 2582
  goto ldv_54107;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_54107: ;
#line 2585
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 2586
    mask = mask | 16777216U;
  } else {

  }
#line 2588
  if (*((unsigned long *)adapter + 67UL) == 262144UL) {
#line 2590
    mask = mask | 65536U;
  } else {

  }
  {
#line 2592
  ixgbe_write_reg(& adapter->hw, 2176U, mask);
  }
#line 2593
  if ((int )queues) {
    {
#line 2594
    ixgbe_irq_enable_queues(adapter, 0xffffffffffffffffULL);
    }
  } else {

  }
#line 2595
  if ((int )flush) {
    {
#line 2596
    ixgbe_read_reg(& adapter->hw, 8U);
    }
  } else {

  }
#line 2597
  return;
}
}
#line 2599 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_msix_other(int irq , void *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  u32 eicr ;
  int reinit_count ;
  int i ;
  struct ixgbe_ring *ring ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2601
  adapter = (struct ixgbe_adapter *)data;
#line 2602
  hw = & adapter->hw;
#line 2611
  eicr = ixgbe_read_reg(hw, 2056U);
#line 2620
  eicr = eicr & 4294901760U;
#line 2622
  ixgbe_write_reg(hw, 2048U, eicr);
  }
#line 2624
  if ((eicr & 1048576U) != 0U) {
    {
#line 2625
    ixgbe_check_lsc(adapter);
    }
  } else {

  }
#line 2627
  if ((eicr & 524288U) != 0U) {
    {
#line 2628
    ixgbe_msg_task(adapter);
    }
  } else {

  }
  {
#line 2631
  if ((unsigned int )hw->mac.type == 2U) {
#line 2631
    goto case_2;
  } else {

  }
#line 2632
  if ((unsigned int )hw->mac.type == 3U) {
#line 2632
    goto case_3;
  } else {

  }
#line 2656
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
#line 2633
  if ((eicr & 268435456U) != 0U) {
#line 2634
    if (((int )adapter->msg_enable & 4) != 0) {
      {
#line 2635
      netdev_info((struct net_device  const  *)adapter->netdev, "Received unrecoverable ECC Err, please reboot\n");
      }
    } else {

    }
  } else {

  }
#line 2637
  if ((eicr & 65536U) != 0U) {
#line 2638
    reinit_count = 0;
#line 2640
    i = 0;
#line 2640
    goto ldv_54122;
    ldv_54121: 
    {
#line 2641
    ring = adapter->tx_ring[i];
#line 2642
    tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& ring->state));
    }
#line 2642
    if (tmp != 0) {
#line 2644
      reinit_count = reinit_count + 1;
    } else {

    }
#line 2640
    i = i + 1;
    ldv_54122: ;
#line 2640
    if (i < adapter->num_tx_queues) {
#line 2642
      goto ldv_54121;
    } else {

    }

#line 2646
    if (reinit_count != 0) {
      {
#line 2648
      ixgbe_write_reg(hw, 2184U, 65536U);
#line 2649
      adapter->flags2 = adapter->flags2 | 128U;
#line 2650
      ixgbe_service_event_schedule(adapter);
      }
    } else {

    }
  } else {

  }
  {
#line 2653
  ixgbe_check_sfp_event(adapter, eicr);
#line 2654
  ixgbe_check_overtemp_event(adapter, eicr);
  }
#line 2655
  goto ldv_54124;
  switch_default: /* CIL Label */ ;
#line 2657
  goto ldv_54124;
  switch_break: /* CIL Label */ ;
  }
  ldv_54124: 
  {
#line 2660
  ixgbe_check_fan_failure(adapter, eicr);
#line 2662
  tmp___0 = __builtin_expect((eicr & 16777216U) != 0U, 0L);
  }
#line 2662
  if (tmp___0 != 0L) {
    {
#line 2663
    ixgbe_ptp_check_pps_event(adapter, eicr);
    }
  } else {

  }
  {
#line 2666
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 2666
  if (tmp___1 == 0) {
    {
#line 2667
    ixgbe_irq_enable(adapter, 0, 0);
    }
  } else {

  }
#line 2669
  return (1);
}
}
#line 2672 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_msix_clean_rings(int irq , void *data ) 
{ 
  struct ixgbe_q_vector *q_vector ;

  {
#line 2674
  q_vector = (struct ixgbe_q_vector *)data;
#line 2678
  if ((unsigned long )q_vector->rx.ring != (unsigned long )((struct ixgbe_ring *)0) || (unsigned long )q_vector->tx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
    {
#line 2679
    napi_schedule(& q_vector->napi);
    }
  } else {

  }
#line 2681
  return (1);
}
}
#line 2691 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_poll(struct napi_struct *napi , int budget ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  struct napi_struct  const  *__mptr ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_ring *ring ;
  int per_ring_budget ;
  bool clean_complete ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int _max1 ;
  int _max2 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2694
  __mptr = (struct napi_struct  const  *)napi;
#line 2694
  q_vector = (struct ixgbe_q_vector *)__mptr + 0xffffffffffffffc0UL;
#line 2695
  adapter = q_vector->adapter;
#line 2698
  clean_complete = 1;
#line 2701
  if ((adapter->flags & 256U) != 0U) {
    {
#line 2702
    ixgbe_update_dca(q_vector);
    }
  } else {

  }
#line 2705
  ring = q_vector->tx.ring;
#line 2705
  goto ldv_54143;
  ldv_54142: 
  {
#line 2706
  tmp = ixgbe_clean_tx_irq(q_vector, ring);
#line 2706
  clean_complete = ((int )clean_complete & (int )tmp) != 0;
#line 2705
  ring = ring->next;
  }
  ldv_54143: ;
#line 2705
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2707
    goto ldv_54142;
  } else {

  }
  {
#line 2708
  tmp___0 = ixgbe_qv_lock_napi(q_vector);
  }
#line 2708
  if (tmp___0) {
#line 2708
    tmp___1 = 0;
  } else {
#line 2708
    tmp___1 = 1;
  }
#line 2708
  if (tmp___1) {
#line 2709
    return (budget);
  } else {

  }
#line 2713
  if ((unsigned int )q_vector->rx.count > 1U) {
#line 2714
    _max1 = budget / (int )q_vector->rx.count;
#line 2714
    _max2 = 1;
#line 2714
    per_ring_budget = _max1 > _max2 ? _max1 : _max2;
  } else {
#line 2716
    per_ring_budget = budget;
  }
#line 2718
  ring = q_vector->rx.ring;
#line 2718
  goto ldv_54149;
  ldv_54148: 
  {
#line 2719
  tmp___2 = ixgbe_clean_rx_irq(q_vector, ring, per_ring_budget);
#line 2719
  clean_complete = ((int )clean_complete & (tmp___2 < per_ring_budget)) != 0;
#line 2718
  ring = ring->next;
  }
  ldv_54149: ;
#line 2718
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 2720
    goto ldv_54148;
  } else {

  }
  {
#line 2722
  ixgbe_qv_unlock_napi(q_vector);
  }
#line 2724
  if (! clean_complete) {
#line 2725
    return (budget);
  } else {

  }
  {
#line 2728
  napi_complete(napi);
  }
#line 2729
  if ((int )adapter->rx_itr_setting & 1) {
    {
#line 2730
    ixgbe_set_itr(q_vector);
    }
  } else {

  }
  {
#line 2731
  tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 2731
  if (tmp___3 == 0) {
    {
#line 2732
    ixgbe_irq_enable_queues(adapter, 1ULL << (int )q_vector->v_idx);
    }
  } else {

  }
#line 2734
  return (0);
}
}
#line 2744 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_request_msix_irqs(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int vector ;
  int err ;
  int ri ;
  int ti ;
  struct ixgbe_q_vector *q_vector ;
  struct msix_entry *entry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2746
  netdev = adapter->netdev;
#line 2748
  ri = 0;
#line 2748
  ti = 0;
#line 2750
  vector = 0;
#line 2750
  goto ldv_54164;
  ldv_54163: 
#line 2751
  q_vector = adapter->q_vector[vector];
#line 2752
  entry = adapter->msix_entries + (unsigned long )vector;
#line 2754
  if ((unsigned long )q_vector->tx.ring != (unsigned long )((struct ixgbe_ring *)0) && (unsigned long )q_vector->rx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
    {
#line 2755
    tmp = ri;
#line 2755
    ri = ri + 1;
#line 2755
    snprintf((char *)(& q_vector->name), 24UL, "%s-%s-%d", (char *)(& netdev->name),
             (char *)"TxRx", tmp);
#line 2757
    ti = ti + 1;
    }
  } else
#line 2758
  if ((unsigned long )q_vector->rx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
    {
#line 2759
    tmp___0 = ri;
#line 2759
    ri = ri + 1;
#line 2759
    snprintf((char *)(& q_vector->name), 24UL, "%s-%s-%d", (char *)(& netdev->name),
             (char *)"rx", tmp___0);
    }
  } else
#line 2761
  if ((unsigned long )q_vector->tx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
    {
#line 2762
    tmp___1 = ti;
#line 2762
    ti = ti + 1;
#line 2762
    snprintf((char *)(& q_vector->name), 24UL, "%s-%s-%d", (char *)(& netdev->name),
             (char *)"tx", tmp___1);
    }
  } else {
#line 2766
    goto ldv_54161;
  }
  {
#line 2768
  err = ldv_request_irq_9(entry->vector, & ixgbe_msix_clean_rings, 0UL, (char const   *)(& q_vector->name),
                          (void *)q_vector);
  }
#line 2770
  if (err != 0) {
#line 2771
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 2772
      netdev_err((struct net_device  const  *)adapter->netdev, "request_irq failed for MSIX interrupt Error: %d\n",
                 err);
      }
    } else {

    }
#line 2773
    goto free_queue_irqs;
  } else {

  }
#line 2776
  if ((adapter->flags & 262144U) != 0U) {
    {
#line 2778
    irq_set_affinity_hint(entry->vector, (struct cpumask  const  *)(& q_vector->affinity_mask));
    }
  } else {

  }
  ldv_54161: 
#line 2750
  vector = vector + 1;
  ldv_54164: ;
#line 2750
  if (vector < adapter->num_q_vectors) {
#line 2752
    goto ldv_54163;
  } else {

  }
  {
#line 2783
  err = ldv_request_irq_10((adapter->msix_entries + (unsigned long )vector)->vector,
                           & ixgbe_msix_other, 0UL, (char const   *)(& netdev->name),
                           (void *)adapter);
  }
#line 2785
  if (err != 0) {
#line 2786
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 2786
      netdev_err((struct net_device  const  *)adapter->netdev, "request_irq for msix_other failed: %d\n",
                 err);
      }
    } else {

    }
#line 2787
    goto free_queue_irqs;
  } else {

  }
#line 2790
  return (0);
  free_queue_irqs: ;
#line 2793
  goto ldv_54167;
  ldv_54166: 
  {
#line 2794
  vector = vector - 1;
#line 2795
  irq_set_affinity_hint((adapter->msix_entries + (unsigned long )vector)->vector,
                        (struct cpumask  const  *)0);
#line 2797
  ldv_free_irq_11((adapter->msix_entries + (unsigned long )vector)->vector, (void *)adapter->q_vector[vector]);
  }
  ldv_54167: ;
#line 2793
  if (vector != 0) {
#line 2795
    goto ldv_54166;
  } else {

  }
  {
#line 2800
  adapter->flags = adapter->flags & 4294967287U;
#line 2801
  pci_disable_msix(adapter->pdev);
#line 2802
  kfree((void const   *)adapter->msix_entries);
#line 2803
  adapter->msix_entries = (struct msix_entry *)0;
  }
#line 2804
  return (err);
}
}
#line 2812 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static irqreturn_t ixgbe_intr(int irq , void *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  struct ixgbe_q_vector *q_vector ;
  u32 eicr ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2814
  adapter = (struct ixgbe_adapter *)data;
#line 2815
  hw = & adapter->hw;
#line 2816
  q_vector = adapter->q_vector[0];
#line 2823
  ixgbe_write_reg(hw, 2184U, 4294967295U);
#line 2827
  eicr = ixgbe_read_reg(hw, 2048U);
  }
#line 2828
  if (eicr == 0U) {
    {
#line 2836
    tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 2836
    if (tmp == 0) {
      {
#line 2837
      ixgbe_irq_enable(adapter, 1, 1);
      }
    } else {

    }
#line 2838
    return (0);
  } else {

  }
#line 2841
  if ((eicr & 1048576U) != 0U) {
    {
#line 2842
    ixgbe_check_lsc(adapter);
    }
  } else {

  }
  {
#line 2845
  if ((unsigned int )hw->mac.type == 2U) {
#line 2845
    goto case_2;
  } else {

  }
#line 2848
  if ((unsigned int )hw->mac.type == 3U) {
#line 2848
    goto case_3;
  } else {

  }
#line 2854
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 2846
  ixgbe_check_sfp_event(adapter, eicr);
  }
  case_3: /* CIL Label */ ;
#line 2849
  if ((eicr & 268435456U) != 0U) {
#line 2850
    if (((int )adapter->msg_enable & 4) != 0) {
      {
#line 2851
      netdev_info((struct net_device  const  *)adapter->netdev, "Received unrecoverable ECC err, please reboot\n");
      }
    } else {

    }
  } else {

  }
  {
#line 2852
  ixgbe_check_overtemp_event(adapter, eicr);
  }
#line 2853
  goto ldv_54179;
  switch_default: /* CIL Label */ ;
#line 2855
  goto ldv_54179;
  switch_break: /* CIL Label */ ;
  }
  ldv_54179: 
  {
#line 2858
  ixgbe_check_fan_failure(adapter, eicr);
#line 2859
  tmp___0 = __builtin_expect((eicr & 16777216U) != 0U, 0L);
  }
#line 2859
  if (tmp___0 != 0L) {
    {
#line 2860
    ixgbe_ptp_check_pps_event(adapter, eicr);
    }
  } else {

  }
  {
#line 2863
  napi_schedule(& q_vector->napi);
#line 2869
  tmp___1 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 2869
  if (tmp___1 == 0) {
    {
#line 2870
    ixgbe_irq_enable(adapter, 0, 0);
    }
  } else {

  }
#line 2872
  return (1);
}
}
#line 2882 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_request_irq(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int err ;

  {
#line 2884
  netdev = adapter->netdev;
#line 2887
  if ((adapter->flags & 8U) != 0U) {
    {
#line 2888
    err = ixgbe_request_msix_irqs(adapter);
    }
  } else
#line 2889
  if ((adapter->flags & 2U) != 0U) {
    {
#line 2890
    err = ldv_request_irq_12((adapter->pdev)->irq, & ixgbe_intr, 0UL, (char const   *)(& netdev->name),
                             (void *)adapter);
    }
  } else {
    {
#line 2893
    err = ldv_request_irq_13((adapter->pdev)->irq, & ixgbe_intr, 128UL, (char const   *)(& netdev->name),
                             (void *)adapter);
    }
  }
#line 2896
  if (err != 0) {
#line 2897
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 2897
      netdev_err((struct net_device  const  *)adapter->netdev, "request_irq failed, Error %d\n",
                 err);
      }
    } else {

    }
  } else {

  }
#line 2899
  return (err);
}
}
#line 2902 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_irq(struct ixgbe_adapter *adapter ) 
{ 
  int vector ;
  struct ixgbe_q_vector *q_vector ;
  struct msix_entry *entry ;
  int tmp ;

  {
#line 2906
  if ((adapter->flags & 8U) == 0U) {
    {
#line 2907
    ldv_free_irq_14((adapter->pdev)->irq, (void *)adapter);
    }
#line 2908
    return;
  } else {

  }
#line 2911
  vector = 0;
#line 2911
  goto ldv_54194;
  ldv_54193: 
#line 2912
  q_vector = adapter->q_vector[vector];
#line 2913
  entry = adapter->msix_entries + (unsigned long )vector;
#line 2916
  if ((unsigned long )q_vector->rx.ring == (unsigned long )((struct ixgbe_ring *)0) && (unsigned long )q_vector->tx.ring == (unsigned long )((struct ixgbe_ring *)0)) {
#line 2917
    goto ldv_54192;
  } else {

  }
  {
#line 2920
  irq_set_affinity_hint(entry->vector, (struct cpumask  const  *)0);
#line 2922
  ldv_free_irq_15(entry->vector, (void *)q_vector);
  }
  ldv_54192: 
#line 2911
  vector = vector + 1;
  ldv_54194: ;
#line 2911
  if (vector < adapter->num_q_vectors) {
#line 2913
    goto ldv_54193;
  } else {

  }
  {
#line 2925
  tmp = vector;
#line 2925
  vector = vector + 1;
#line 2925
  ldv_free_irq_16((adapter->msix_entries + (unsigned long )tmp)->vector, (void *)adapter);
  }
#line 2926
  return;
}
}
#line 2932 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static void ixgbe_irq_disable(struct ixgbe_adapter *adapter ) 
{ 
  int vector ;
  int tmp ;

  {
  {
#line 2935
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 2935
    goto case_1;
  } else {

  }
#line 2938
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 2938
    goto case_2;
  } else {

  }
#line 2939
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 2939
    goto case_3;
  } else {

  }
#line 2944
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2936
  ixgbe_write_reg(& adapter->hw, 2184U, 4294967295U);
  }
#line 2937
  goto ldv_54200;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 2940
  ixgbe_write_reg(& adapter->hw, 2184U, 4294901760U);
#line 2941
  ixgbe_write_reg(& adapter->hw, 2736U, 4294967295U);
#line 2942
  ixgbe_write_reg(& adapter->hw, 2740U, 4294967295U);
  }
#line 2943
  goto ldv_54200;
  switch_default: /* CIL Label */ ;
#line 2945
  goto ldv_54200;
  switch_break: /* CIL Label */ ;
  }
  ldv_54200: 
  {
#line 2947
  ixgbe_read_reg(& adapter->hw, 8U);
  }
#line 2948
  if ((adapter->flags & 8U) != 0U) {
#line 2951
    vector = 0;
#line 2951
    goto ldv_54206;
    ldv_54205: 
    {
#line 2952
    synchronize_irq((adapter->msix_entries + (unsigned long )vector)->vector);
#line 2951
    vector = vector + 1;
    }
    ldv_54206: ;
#line 2951
    if (vector < adapter->num_q_vectors) {
#line 2953
      goto ldv_54205;
    } else {

    }
    {
#line 2954
    tmp = vector;
#line 2954
    vector = vector + 1;
#line 2954
    synchronize_irq((adapter->msix_entries + (unsigned long )tmp)->vector);
    }
  } else {
    {
#line 2956
    synchronize_irq((adapter->pdev)->irq);
    }
  }
#line 2957
  return;
}
}
#line 2964 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_msi_and_legacy(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_q_vector *q_vector ;

  {
  {
#line 2966
  q_vector = adapter->q_vector[0];
#line 2968
  ixgbe_write_eitr(q_vector);
#line 2970
  ixgbe_set_ivar(adapter, 0, 0, 0);
#line 2971
  ixgbe_set_ivar(adapter, 1, 0, 0);
  }
#line 2973
  if (((int )adapter->msg_enable & 8192) != 0) {
    {
#line 2973
    netdev_info((struct net_device  const  *)adapter->netdev, "Legacy interrupt IVAR setup done\n");
    }
  } else {

  }
#line 2974
  return;
}
}
#line 2983 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u64 tdba ;
  int wait_loop ;
  u32 txdctl ;
  u8 reg_idx ;
  struct ixgbe_q_vector *q_vector ;
  int tmp ;
  u32 tmp___0 ;

  {
  {
#line 2986
  hw = & adapter->hw;
#line 2987
  tdba = ring->dma;
#line 2988
  wait_loop = 10;
#line 2989
  txdctl = 33554432U;
#line 2990
  reg_idx = ring->reg_idx;
#line 2993
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24616), 0U);
#line 2994
  ixgbe_read_reg(hw, 8U);
#line 2996
  ixgbe_write_reg(hw, (u32 )(((int )reg_idx + 384) * 64), (u32 )tdba);
#line 2998
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24580), (u32 )(tdba >> 32));
#line 2999
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24584), (u32 )ring->count * 16U);
#line 3001
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24592), 0U);
#line 3002
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24600), 0U);
#line 3003
  ring->tail = adapter->io_addr + (unsigned long )((int )reg_idx * 64 + 24600);
  }
#line 3016
  if ((unsigned long )ring->q_vector == (unsigned long )((struct ixgbe_q_vector *)0) || (unsigned int )(ring->q_vector)->itr <= 39U) {
#line 3020
    txdctl = txdctl | 65536U;
  } else {
#line 3022
    txdctl = txdctl | 524288U;
  }
#line 3028
  txdctl = txdctl | 288U;
#line 3032
  if ((adapter->flags & 262144U) != 0U) {
    {
#line 3033
    ring->__annonCompField96.__annonCompField95.atr_sample_rate = (u8 )adapter->atr_sample_rate;
#line 3034
    ring->__annonCompField96.__annonCompField95.atr_count = 0U;
#line 3035
    set_bit(0L, (unsigned long volatile   *)(& ring->state));
    }
  } else {
#line 3037
    ring->__annonCompField96.__annonCompField95.atr_sample_rate = 0U;
  }
  {
#line 3041
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)(& ring->state));
  }
#line 3041
  if (tmp == 0) {
#line 3042
    q_vector = ring->q_vector;
#line 3044
    if ((unsigned long )q_vector != (unsigned long )((struct ixgbe_q_vector *)0)) {
      {
#line 3045
      netif_set_xps_queue(ring->netdev, (struct cpumask  const  *)(& q_vector->affinity_mask),
                          (int )ring->queue_index);
      }
    } else {

    }
  } else {

  }
  {
#line 3050
  clear_bit(3L, (unsigned long volatile   *)(& ring->state));
#line 3053
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24616), txdctl);
  }
#line 3056
  if ((unsigned int )hw->mac.type == 1U) {
    {
#line 3056
    tmp___0 = ixgbe_read_reg(hw, 17060U);
    }
#line 3056
    if ((tmp___0 & 1073741824U) == 0U) {
#line 3058
      return;
    } else {

    }
  } else {

  }
  ldv_54222: 
  {
#line 3062
  usleep_range(1000UL, 2000UL);
#line 3063
  txdctl = ixgbe_read_reg(hw, (u32 )((int )reg_idx * 64 + 24616));
#line 3064
  wait_loop = wait_loop - 1;
  }
#line 3064
  if (wait_loop != 0 && (txdctl & 33554432U) == 0U) {
#line 3066
    goto ldv_54222;
  } else {

  }

#line 3065
  if (wait_loop == 0) {
#line 3066
    if ((int )adapter->msg_enable & 1) {
      {
#line 3066
      netdev_err((struct net_device  const  *)adapter->netdev, "Could not enable Tx Queue %d\n",
                 (int )reg_idx);
      }
    } else {

    }
  } else {

  }
#line 3067
  return;
}
}
#line 3069 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 rttdcs ;
  u32 mtqc ;
  u8 tcs ;
  int tmp ;
  u32 sectx ;
  u32 tmp___0 ;

  {
  {
#line 3071
  hw = & adapter->hw;
#line 3073
  tmp = netdev_get_num_tc(adapter->netdev);
#line 3073
  tcs = (u8 )tmp;
  }
#line 3075
  if ((unsigned int )hw->mac.type == 1U) {
#line 3076
    return;
  } else {

  }
  {
#line 3079
  rttdcs = ixgbe_read_reg(hw, 18688U);
#line 3080
  rttdcs = rttdcs | 64U;
#line 3081
  ixgbe_write_reg(hw, 18688U, rttdcs);
  }
#line 3084
  if ((adapter->flags & 8388608U) != 0U) {
#line 3085
    mtqc = 2U;
#line 3086
    if ((unsigned int )tcs > 4U) {
#line 3087
      mtqc = mtqc | 13U;
    } else
#line 3088
    if ((unsigned int )tcs > 1U) {
#line 3089
      mtqc = mtqc | 9U;
    } else
#line 3090
    if ((unsigned int )adapter->ring_feature[2].indices == 4U) {
#line 3091
      mtqc = mtqc | 8U;
    } else {
#line 3093
      mtqc = mtqc | 4U;
    }
  } else
#line 3095
  if ((unsigned int )tcs > 4U) {
#line 3096
    mtqc = 13U;
  } else
#line 3097
  if ((unsigned int )tcs > 1U) {
#line 3098
    mtqc = 9U;
  } else {
#line 3100
    mtqc = 0U;
  }
  {
#line 3103
  ixgbe_write_reg(hw, 33056U, mtqc);
  }
#line 3106
  if ((unsigned int )tcs != 0U) {
    {
#line 3107
    tmp___0 = ixgbe_read_reg(hw, 34832U);
#line 3107
    sectx = tmp___0;
#line 3108
    sectx = sectx | 7936U;
#line 3109
    ixgbe_write_reg(hw, 34832U, sectx);
    }
  } else {

  }
  {
#line 3113
  rttdcs = rttdcs & 4294967231U;
#line 3114
  ixgbe_write_reg(hw, 18688U, rttdcs);
  }
#line 3115
  return;
}
}
#line 3123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_tx(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 dmatxctl ;
  u32 i ;

  {
  {
#line 3125
  hw = & adapter->hw;
#line 3129
  ixgbe_setup_mtqc(adapter);
  }
#line 3131
  if ((unsigned int )hw->mac.type != 1U) {
    {
#line 3133
    dmatxctl = ixgbe_read_reg(hw, 19072U);
#line 3134
    dmatxctl = dmatxctl | 1U;
#line 3135
    ixgbe_write_reg(hw, 19072U, dmatxctl);
    }
  } else {

  }
#line 3139
  i = 0U;
#line 3139
  goto ldv_54239;
  ldv_54238: 
  {
#line 3140
  ixgbe_configure_tx_ring(adapter, adapter->tx_ring[i]);
#line 3139
  i = i + 1U;
  }
  ldv_54239: ;
#line 3139
  if (i < (u32 )adapter->num_tx_queues) {
#line 3141
    goto ldv_54238;
  } else {

  }

#line 3146
  return;
}
}
#line 3143 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_enable_rx_drop(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u8 reg_idx ;
  u32 srrctl ;
  u32 tmp ;

  {
  {
#line 3146
  hw = & adapter->hw;
#line 3147
  reg_idx = ring->reg_idx;
#line 3148
  tmp = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)));
#line 3148
  srrctl = tmp;
#line 3150
  srrctl = srrctl | 268435456U;
#line 3152
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)),
                  srrctl);
  }
#line 3153
  return;
}
}
#line 3155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_disable_rx_drop(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u8 reg_idx ;
  u32 srrctl ;
  u32 tmp ;

  {
  {
#line 3158
  hw = & adapter->hw;
#line 3159
  reg_idx = ring->reg_idx;
#line 3160
  tmp = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)));
#line 3160
  srrctl = tmp;
#line 3162
  srrctl = srrctl & 4026531839U;
#line 3164
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)),
                  srrctl);
  }
#line 3165
  return;
}
}
#line 3168 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  bool pfc_en ;

  {
#line 3174
  pfc_en = adapter->dcb_cfg.pfc_mode_enable;
#line 3176
  if ((unsigned long )adapter->ixgbe_ieee_pfc != (unsigned long )((struct ieee_pfc *)0)) {
#line 3177
    pfc_en = ((int )pfc_en | ((unsigned int )(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0;
  } else {

  }
#line 3188
  if (adapter->num_vfs != 0U || ((adapter->num_rx_queues > 1 && ((unsigned int )adapter->hw.fc.current_mode & 2U) == 0U) && ! pfc_en)) {
#line 3190
    i = 0;
#line 3190
    goto ldv_54261;
    ldv_54260: 
    {
#line 3191
    ixgbe_enable_rx_drop(adapter, adapter->rx_ring[i]);
#line 3190
    i = i + 1;
    }
    ldv_54261: ;
#line 3190
    if (i < adapter->num_rx_queues) {
#line 3192
      goto ldv_54260;
    } else {

    }

  } else {
#line 3193
    i = 0;
#line 3193
    goto ldv_54264;
    ldv_54263: 
    {
#line 3194
    ixgbe_disable_rx_drop(adapter, adapter->rx_ring[i]);
#line 3193
    i = i + 1;
    }
    ldv_54264: ;
#line 3193
    if (i < adapter->num_rx_queues) {
#line 3195
      goto ldv_54263;
    } else {

    }

  }
#line 3201
  return;
}
}
#line 3200 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_srrctl(struct ixgbe_adapter *adapter , struct ixgbe_ring *rx_ring ) 
{ 
  struct ixgbe_hw *hw ;
  u32 srrctl ;
  u8 reg_idx ;
  u16 mask ;
  unsigned int tmp ;

  {
#line 3203
  hw = & adapter->hw;
#line 3205
  reg_idx = rx_ring->reg_idx;
#line 3207
  if ((unsigned int )hw->mac.type == 1U) {
#line 3208
    mask = adapter->ring_feature[2].mask;
#line 3214
    reg_idx = (int )reg_idx & (int )((u8 )mask);
  } else {

  }
  {
#line 3218
  srrctl = 1024U;
#line 3221
  tmp = ixgbe_rx_bufsz(rx_ring);
#line 3221
  srrctl = srrctl | (tmp >> 10);
#line 3224
  srrctl = srrctl | 33554432U;
#line 3226
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 15U ? ((int )reg_idx + 2112) * 4 : ((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4116 : ((int )reg_idx + -64) * 64 + 53268)),
                  srrctl);
  }
#line 3227
  return;
}
}
#line 3229 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 seed[10U] ;
  u32 mrqc ;
  u32 reta ;
  u32 rxcsum ;
  int i ;
  int j ;
  u16 rss_i ;
  u8 tcs ;
  int tmp ;

  {
#line 3231
  hw = & adapter->hw;
#line 3232
  seed[0] = 3801208637U;
#line 3232
  seed[1] = 403041388U;
#line 3232
  seed[2] = 714388237U;
#line 3232
  seed[3] = 2773429228U;
#line 3232
  seed[4] = 3930697596U;
#line 3232
  seed[5] = 3793005885U;
#line 3232
  seed[6] = 3092622014U;
#line 3232
  seed[7] = 1782474730U;
#line 3232
  seed[8] = 339102999U;
#line 3232
  seed[9] = 1005395981U;
#line 3235
  mrqc = 0U;
#line 3235
  reta = 0U;
#line 3238
  rss_i = adapter->ring_feature[2].indices;
#line 3245
  if ((adapter->flags & 8388608U) != 0U && (unsigned int )rss_i <= 1U) {
#line 3246
    rss_i = 2U;
  } else {

  }
#line 3249
  i = 0;
#line 3249
  goto ldv_54286;
  ldv_54285: 
  {
#line 3250
  ixgbe_write_reg(hw, (u32 )((i + 5920) * 4), seed[i]);
#line 3249
  i = i + 1;
  }
  ldv_54286: ;
#line 3249
  if (i <= 9) {
#line 3251
    goto ldv_54285;
  } else {

  }
#line 3253
  i = 0;
#line 3253
  j = 0;
#line 3253
  goto ldv_54289;
  ldv_54288: ;
#line 3254
  if (j == (int )rss_i) {
#line 3255
    j = 0;
  } else {

  }
#line 3258
  reta = (reta << 8) | (u32 )(j * 17);
#line 3259
  if ((i & 3) == 3) {
    {
#line 3260
    ixgbe_write_reg(hw, (u32 )(((i >> 2) + 5888) * 4), reta);
    }
  } else {

  }
#line 3253
  i = i + 1;
#line 3253
  j = j + 1;
  ldv_54289: ;
#line 3253
  if (i <= 127) {
#line 3255
    goto ldv_54288;
  } else {

  }
  {
#line 3264
  rxcsum = ixgbe_read_reg(hw, 20480U);
#line 3265
  rxcsum = rxcsum | 8192U;
#line 3266
  ixgbe_write_reg(hw, 20480U, rxcsum);
  }
#line 3268
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 3269
    if ((unsigned int )adapter->ring_feature[2].mask != 0U) {
#line 3270
      mrqc = 1U;
    } else {

    }
  } else {
    {
#line 3272
    tmp = netdev_get_num_tc(adapter->netdev);
#line 3272
    tcs = (u8 )tmp;
    }
#line 3274
    if ((adapter->flags & 8388608U) != 0U) {
#line 3275
      if ((unsigned int )tcs > 4U) {
#line 3276
        mrqc = 12U;
      } else
#line 3277
      if ((unsigned int )tcs > 1U) {
#line 3278
        mrqc = 13U;
      } else
#line 3279
      if ((unsigned int )adapter->ring_feature[2].indices == 4U) {
#line 3280
        mrqc = 10U;
      } else {
#line 3282
        mrqc = 11U;
      }
    } else
#line 3284
    if ((unsigned int )tcs > 4U) {
#line 3285
      mrqc = 4U;
    } else
#line 3286
    if ((unsigned int )tcs > 1U) {
#line 3287
      mrqc = 5U;
    } else {
#line 3289
      mrqc = 1U;
    }
  }
#line 3294
  mrqc = mrqc | 3342336U;
#line 3299
  if ((adapter->flags2 & 256U) != 0U) {
#line 3300
    mrqc = mrqc | 4194304U;
  } else {

  }
#line 3301
  if ((adapter->flags2 & 512U) != 0U) {
#line 3302
    mrqc = mrqc | 8388608U;
  } else {

  }
  {
#line 3304
  ixgbe_write_reg(hw, 22552U, mrqc);
  }
#line 3305
  return;
}
}
#line 3312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_rscctl(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u32 rscctrl ;
  u8 reg_idx ;
  int tmp ;

  {
  {
#line 3315
  hw = & adapter->hw;
#line 3317
  reg_idx = ring->reg_idx;
#line 3319
  tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& ring->state));
  }
#line 3319
  if (tmp == 0) {
#line 3320
    return;
  } else {

  }
  {
#line 3322
  rscctrl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4140 : ((int )reg_idx + -64) * 64 + 53292));
#line 3323
  rscctrl = rscctrl | 1U;
#line 3329
  rscctrl = rscctrl | 12U;
#line 3330
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4140 : ((int )reg_idx + -64) * 64 + 53292),
                  rscctrl);
  }
#line 3331
  return;
}
}
#line 3334 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_rx_desc_queue_enable(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  int wait_loop ;
  u32 rxdctl ;
  u8 reg_idx ;
  bool tmp ;
  u32 tmp___0 ;

  {
  {
#line 3337
  hw = & adapter->hw;
#line 3338
  wait_loop = 10;
#line 3340
  reg_idx = ring->reg_idx;
#line 3342
  tmp = ixgbe_removed((void *)hw->hw_addr);
  }
#line 3342
  if ((int )tmp) {
#line 3343
    return;
  } else {

  }
#line 3345
  if ((unsigned int )hw->mac.type == 1U) {
    {
#line 3345
    tmp___0 = ixgbe_read_reg(hw, 17060U);
    }
#line 3345
    if ((tmp___0 & 1073741824U) == 0U) {
#line 3347
      return;
    } else {

    }
  } else {

  }
  ldv_54307: 
  {
#line 3350
  usleep_range(1000UL, 2000UL);
#line 3351
  rxdctl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288));
#line 3352
  wait_loop = wait_loop - 1;
  }
#line 3352
  if (wait_loop != 0 && (rxdctl & 33554432U) == 0U) {
#line 3354
    goto ldv_54307;
  } else {

  }

#line 3354
  if (wait_loop == 0) {
#line 3355
    if ((int )adapter->msg_enable & 1) {
      {
#line 3356
      netdev_err((struct net_device  const  *)adapter->netdev, "RXDCTL.ENABLE on Rx queue %d not set within the polling period\n",
                 (int )reg_idx);
      }
    } else {

    }
  } else {

  }
#line 3357
  return;
}
}
#line 3360 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_disable_rx_queue(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  int wait_loop ;
  u32 rxdctl ;
  u8 reg_idx ;
  bool tmp ;
  u32 tmp___0 ;

  {
  {
#line 3363
  hw = & adapter->hw;
#line 3364
  wait_loop = 10;
#line 3366
  reg_idx = ring->reg_idx;
#line 3368
  tmp = ixgbe_removed((void *)hw->hw_addr);
  }
#line 3368
  if ((int )tmp) {
#line 3369
    return;
  } else {

  }
  {
#line 3370
  rxdctl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288));
#line 3371
  rxdctl = rxdctl & 4261412863U;
#line 3374
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288),
                  rxdctl);
  }
#line 3376
  if ((unsigned int )hw->mac.type == 1U) {
    {
#line 3376
    tmp___0 = ixgbe_read_reg(hw, 17060U);
    }
#line 3376
    if ((tmp___0 & 1073741824U) == 0U) {
#line 3378
      return;
    } else {

    }
  } else {

  }
  ldv_54317: 
  {
#line 3382
  __const_udelay(42950UL);
#line 3383
  rxdctl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288));
#line 3384
  wait_loop = wait_loop - 1;
  }
#line 3384
  if (wait_loop != 0 && (rxdctl & 33554432U) != 0U) {
#line 3386
    goto ldv_54317;
  } else {

  }

#line 3386
  if (wait_loop == 0) {
#line 3387
    if ((int )adapter->msg_enable & 1) {
      {
#line 3388
      netdev_err((struct net_device  const  *)adapter->netdev, "RXDCTL.ENABLE on Rx queue %d not cleared within the polling period\n",
                 (int )reg_idx);
      }
    } else {

    }
  } else {

  }
#line 3389
  return;
}
}
#line 3392 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter , struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_hw *hw ;
  u64 rdba ;
  u32 rxdctl ;
  u8 reg_idx ;
  u16 tmp ;

  {
  {
#line 3395
  hw = & adapter->hw;
#line 3396
  rdba = ring->dma;
#line 3398
  reg_idx = ring->reg_idx;
#line 3401
  rxdctl = ixgbe_read_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288));
#line 3402
  ixgbe_disable_rx_queue(adapter, ring);
#line 3404
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? ((int )reg_idx + 64) * 64 : ((int )reg_idx + 768) * 64),
                  (u32 )rdba);
#line 3405
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4100 : ((int )reg_idx + -64) * 64 + 53252),
                  (u32 )(rdba >> 32));
#line 3406
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4104 : ((int )reg_idx + -64) * 64 + 53256),
                  (u32 )ring->count * 16U);
#line 3408
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4112 : ((int )reg_idx + -64) * 64 + 53264),
                  0U);
#line 3409
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4120 : ((int )reg_idx + -64) * 64 + 53272),
                  0U);
#line 3410
  ring->tail = adapter->io_addr + (unsigned long )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4120 : ((int )reg_idx + -64) * 64 + 53272);
#line 3412
  ixgbe_configure_srrctl(adapter, ring);
#line 3413
  ixgbe_configure_rscctl(adapter, ring);
  }
#line 3415
  if ((unsigned int )hw->mac.type == 1U) {
#line 3423
    rxdctl = rxdctl & 4290772992U;
#line 3424
    rxdctl = rxdctl | 525344U;
  } else {

  }
  {
#line 3428
  rxdctl = rxdctl | 33554432U;
#line 3429
  ixgbe_write_reg(hw, (u32 )((unsigned int )reg_idx <= 63U ? (int )reg_idx * 64 + 4136 : ((int )reg_idx + -64) * 64 + 53288),
                  rxdctl);
#line 3431
  ixgbe_rx_desc_queue_enable(adapter, ring);
#line 3432
  tmp = ixgbe_desc_unused(ring);
#line 3432
  ixgbe_alloc_rx_buffers(ring, (int )tmp);
  }
#line 3433
  return;
}
}
#line 3435 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_psrtype(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int rss_i ;
  u16 pool ;
  u32 psrtype ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 3437
  hw = & adapter->hw;
#line 3438
  rss_i = (int )adapter->ring_feature[2].indices;
#line 3442
  psrtype = 4912U;
#line 3448
  if ((unsigned int )hw->mac.type == 1U) {
#line 3449
    return;
  } else {

  }
#line 3451
  if (rss_i > 3) {
#line 3452
    psrtype = psrtype | 1073741824U;
  } else
#line 3453
  if (rss_i > 1) {
#line 3454
    psrtype = psrtype | 536870912U;
  } else {

  }
  {
#line 3456
  tmp = find_first_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL);
#line 3456
  pool = (u16 )tmp;
  }
#line 3456
  goto ldv_54335;
  ldv_54334: 
  {
#line 3457
  ixgbe_write_reg(hw, (u32 )((int )pool + (int )adapter->ring_feature[1].offset <= 15 ? (((int )pool + (int )adapter->ring_feature[1].offset) + 5408) * 4 : (((int )pool + (int )adapter->ring_feature[1].offset) + 14976) * 4),
                  psrtype);
#line 3456
  tmp___0 = find_next_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL,
                          (unsigned long )((int )pool + 1));
#line 3456
  pool = (u16 )tmp___0;
  }
  ldv_54335: ;
#line 3456
  if ((unsigned int )pool <= 31U) {
#line 3458
    goto ldv_54334;
  } else {

  }

#line 3463
  return;
}
}
#line 3460 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_virtualization(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 reg_offset ;
  u32 vf_shift ;
  u32 gcr_ext ;
  u32 vmdctl ;
  int i ;

  {
#line 3462
  hw = & adapter->hw;
#line 3467
  if ((adapter->flags & 8388608U) == 0U) {
#line 3468
    return;
  } else {

  }
  {
#line 3470
  vmdctl = ixgbe_read_reg(hw, 20912U);
#line 3471
  vmdctl = vmdctl | 1U;
#line 3472
  vmdctl = vmdctl & 4294959231U;
#line 3473
  vmdctl = vmdctl | (u32 )((int )adapter->ring_feature[1].offset << 7);
#line 3474
  vmdctl = vmdctl | 1073741824U;
#line 3475
  ixgbe_write_reg(hw, 20912U, vmdctl);
#line 3477
  vf_shift = (u32 )adapter->ring_feature[1].offset & 31U;
#line 3478
  reg_offset = (int )adapter->ring_feature[1].offset > 31;
#line 3481
  ixgbe_write_reg(hw, (reg_offset + 5240U) * 4U, (u32 )(-1 << (int )vf_shift));
#line 3482
  ixgbe_write_reg(hw, ((reg_offset ^ 1U) + 5240U) * 4U, reg_offset - 1U);
#line 3483
  ixgbe_write_reg(hw, (reg_offset + 8260U) * 4U, (u32 )(-1 << (int )vf_shift));
#line 3484
  ixgbe_write_reg(hw, ((reg_offset ^ 1U) + 8260U) * 4U, reg_offset - 1U);
  }
#line 3485
  if ((adapter->flags2 & 2048U) != 0U) {
    {
#line 3486
    ixgbe_write_reg(hw, 33312U, 1U);
    }
  } else {

  }
  {
#line 3489
  (*(hw->mac.ops.set_vmdq))(hw, 0U, (u32 )adapter->ring_feature[1].offset);
  }
  {
#line 3496
  if ((int )adapter->ring_feature[1].mask == 120) {
#line 3496
    goto case_120;
  } else {

  }
#line 3499
  if ((int )adapter->ring_feature[1].mask == 124) {
#line 3499
    goto case_124;
  } else {

  }
#line 3502
  goto switch_default;
  case_120: /* CIL Label */ 
#line 3497
  gcr_ext = 1U;
#line 3498
  goto ldv_54347;
  case_124: /* CIL Label */ 
#line 3500
  gcr_ext = 2U;
#line 3501
  goto ldv_54347;
  switch_default: /* CIL Label */ 
#line 3503
  gcr_ext = 3U;
#line 3504
  goto ldv_54347;
  switch_break: /* CIL Label */ ;
  }
  ldv_54347: 
  {
#line 3507
  ixgbe_write_reg(hw, 69712U, gcr_ext);
#line 3511
  (*(hw->mac.ops.set_mac_anti_spoofing))(hw, adapter->num_vfs != 0U, (int )adapter->num_vfs);
#line 3514
  i = 0;
  }
#line 3514
  goto ldv_54351;
  ldv_54350: ;
#line 3515
  if ((unsigned int )(adapter->vfinfo + (unsigned long )i)->spoofchk_enabled == 0U) {
    {
#line 3516
    ixgbe_ndo_set_vf_spoofchk(adapter->netdev, i, 0);
    }
  } else {

  }
#line 3514
  i = i + 1;
  ldv_54351: ;
#line 3514
  if ((unsigned int )i < adapter->num_vfs) {
#line 3516
    goto ldv_54350;
  } else {

  }

#line 3521
  return;
}
}
#line 3520 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_rx_buffer_len(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct net_device *netdev ;
  int max_frame ;
  struct ixgbe_ring *rx_ring ;
  int i ;
  u32 mhadd ;
  u32 hlreg0 ;

  {
#line 3522
  hw = & adapter->hw;
#line 3523
  netdev = adapter->netdev;
#line 3524
  max_frame = (int )(netdev->mtu + 18U);
#line 3531
  if ((adapter->flags & 2097152U) != 0U && max_frame <= 3071) {
#line 3533
    max_frame = 3072;
  } else {

  }
#line 3538
  if (max_frame <= 1517) {
#line 3539
    max_frame = 1518;
  } else {

  }
  {
#line 3541
  mhadd = ixgbe_read_reg(hw, 17000U);
  }
#line 3542
  if ((u32 )max_frame != mhadd >> 16) {
    {
#line 3543
    mhadd = mhadd & 65535U;
#line 3544
    mhadd = mhadd | (u32 )(max_frame << 16);
#line 3546
    ixgbe_write_reg(hw, 17000U, mhadd);
    }
  } else {

  }
  {
#line 3549
  hlreg0 = ixgbe_read_reg(hw, 16960U);
#line 3551
  hlreg0 = hlreg0 | 4U;
#line 3552
  ixgbe_write_reg(hw, 16960U, hlreg0);
#line 3558
  i = 0;
  }
#line 3558
  goto ldv_54364;
  ldv_54363: 
#line 3559
  rx_ring = adapter->rx_ring[i];
#line 3560
  if ((adapter->flags2 & 2U) != 0U) {
    {
#line 3561
    set_bit(4L, (unsigned long volatile   *)(& rx_ring->state));
    }
  } else {
    {
#line 3563
    clear_bit(4L, (unsigned long volatile   *)(& rx_ring->state));
    }
  }
#line 3558
  i = i + 1;
  ldv_54364: ;
#line 3558
  if (i < adapter->num_rx_queues) {
#line 3560
    goto ldv_54363;
  } else {

  }

#line 3565
  return;
}
}
#line 3567 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_rdrxctl(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 rdrxctl ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  {
#line 3569
  hw = & adapter->hw;
#line 3570
  tmp = ixgbe_read_reg(hw, 12032U);
#line 3570
  rdrxctl = tmp;
  }
  {
#line 3573
  if ((unsigned int )hw->mac.type == 1U) {
#line 3573
    goto case_1;
  } else {

  }
#line 3586
  if ((unsigned int )hw->mac.type == 2U) {
#line 3586
    goto case_2;
  } else {

  }
#line 3587
  if ((unsigned int )hw->mac.type == 3U) {
#line 3587
    goto case_3;
  } else {

  }
#line 3596
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3584
  rdrxctl = rdrxctl | 32U;
#line 3585
  goto ldv_54372;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 3589
  tmp___0 = ixgbe_read_reg(hw, 12328U);
#line 3589
  ixgbe_write_reg(hw, 12328U, tmp___0 | 128U);
#line 3591
  rdrxctl = rdrxctl & 4290904063U;
#line 3593
  rdrxctl = rdrxctl | 100663296U;
#line 3594
  rdrxctl = rdrxctl | 2U;
  }
#line 3595
  goto ldv_54372;
  switch_default: /* CIL Label */ ;
#line 3598
  return;
  switch_break: /* CIL Label */ ;
  }
  ldv_54372: 
  {
#line 3601
  ixgbe_write_reg(hw, 12032U, rdrxctl);
  }
#line 3602
  return;
}
}
#line 3610 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_rx(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;
  u32 rxctrl ;
  u32 rfctl ;

  {
  {
#line 3612
  hw = & adapter->hw;
#line 3617
  rxctrl = ixgbe_read_reg(hw, 12288U);
#line 3618
  ixgbe_write_reg(hw, 12288U, rxctrl & 4294967294U);
#line 3620
  ixgbe_setup_psrtype(adapter);
#line 3621
  ixgbe_setup_rdrxctl(adapter);
#line 3624
  rfctl = ixgbe_read_reg(hw, 20488U);
#line 3625
  rfctl = rfctl & 4294967263U;
  }
#line 3626
  if ((adapter->flags2 & 2U) == 0U) {
#line 3627
    rfctl = rfctl | 32U;
  } else {

  }
  {
#line 3628
  ixgbe_write_reg(hw, 20488U, rfctl);
#line 3631
  ixgbe_setup_mrqc(adapter);
#line 3634
  ixgbe_set_rx_buffer_len(adapter);
#line 3640
  i = 0;
  }
#line 3640
  goto ldv_54384;
  ldv_54383: 
  {
#line 3641
  ixgbe_configure_rx_ring(adapter, adapter->rx_ring[i]);
#line 3640
  i = i + 1;
  }
  ldv_54384: ;
#line 3640
  if (i < adapter->num_rx_queues) {
#line 3642
    goto ldv_54383;
  } else {

  }

#line 3644
  if ((unsigned int )hw->mac.type == 1U) {
#line 3645
    rxctrl = rxctrl | 2U;
  } else {

  }
  {
#line 3648
  rxctrl = rxctrl | 1U;
#line 3649
  (*(hw->mac.ops.enable_rx_dma))(hw, rxctrl);
  }
#line 3650
  return;
}
}
#line 3652 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_vlan_rx_add_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;

  {
  {
#line 3655
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3655
  adapter = (struct ixgbe_adapter *)tmp;
#line 3656
  hw = & adapter->hw;
#line 3659
  (*(hw->mac.ops.set_vfta))(& adapter->hw, (u32 )vid, (u32 )adapter->ring_feature[1].offset,
                            1);
#line 3660
  set_bit((long )vid, (unsigned long volatile   *)(& adapter->active_vlans));
  }
#line 3662
  return (0);
}
}
#line 3665 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_vlan_rx_kill_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;

  {
  {
#line 3668
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3668
  adapter = (struct ixgbe_adapter *)tmp;
#line 3669
  hw = & adapter->hw;
#line 3672
  (*(hw->mac.ops.set_vfta))(& adapter->hw, (u32 )vid, (u32 )adapter->ring_feature[1].offset,
                            0);
#line 3673
  clear_bit((long )vid, (unsigned long volatile   *)(& adapter->active_vlans));
  }
#line 3675
  return (0);
}
}
#line 3682 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_filter_disable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vlnctrl ;

  {
  {
#line 3684
  hw = & adapter->hw;
#line 3687
  vlnctrl = ixgbe_read_reg(hw, 20616U);
#line 3688
  vlnctrl = vlnctrl & 2684354559U;
#line 3689
  ixgbe_write_reg(hw, 20616U, vlnctrl);
  }
#line 3690
  return;
}
}
#line 3696 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_filter_enable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vlnctrl ;

  {
  {
#line 3698
  hw = & adapter->hw;
#line 3701
  vlnctrl = ixgbe_read_reg(hw, 20616U);
#line 3702
  vlnctrl = vlnctrl | 1073741824U;
#line 3703
  vlnctrl = vlnctrl & 3758096383U;
#line 3704
  ixgbe_write_reg(hw, 20616U, vlnctrl);
  }
#line 3705
  return;
}
}
#line 3711 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_strip_disable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vlnctrl ;
  int i ;
  int j ;
  struct ixgbe_ring *ring ;

  {
#line 3713
  hw = & adapter->hw;
  {
#line 3718
  if ((unsigned int )hw->mac.type == 1U) {
#line 3718
    goto case_1;
  } else {

  }
#line 3723
  if ((unsigned int )hw->mac.type == 2U) {
#line 3723
    goto case_2;
  } else {

  }
#line 3724
  if ((unsigned int )hw->mac.type == 3U) {
#line 3724
    goto case_3;
  } else {

  }
#line 3736
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 3719
  vlnctrl = ixgbe_read_reg(hw, 20616U);
#line 3720
  vlnctrl = vlnctrl & 2147483647U;
#line 3721
  ixgbe_write_reg(hw, 20616U, vlnctrl);
  }
#line 3722
  goto ldv_54418;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 3725
  i = 0;
#line 3725
  goto ldv_54424;
  ldv_54423: 
#line 3726
  ring = adapter->rx_ring[i];
#line 3728
  if ((unsigned long )ring->l2_accel_priv != (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 3729
    goto ldv_54422;
  } else {

  }
  {
#line 3730
  j = (int )ring->reg_idx;
#line 3731
  vlnctrl = ixgbe_read_reg(hw, (u32 )(j <= 63 ? j * 64 + 4136 : (j + -64) * 64 + 53288));
#line 3732
  vlnctrl = vlnctrl & 3221225471U;
#line 3733
  ixgbe_write_reg(hw, (u32 )(j <= 63 ? j * 64 + 4136 : (j + -64) * 64 + 53288), vlnctrl);
  }
  ldv_54422: 
#line 3725
  i = i + 1;
  ldv_54424: ;
#line 3725
  if (i < adapter->num_rx_queues) {
#line 3727
    goto ldv_54423;
  } else {

  }

#line 3735
  goto ldv_54418;
  switch_default: /* CIL Label */ ;
#line 3737
  goto ldv_54418;
  switch_break: /* CIL Label */ ;
  }
  ldv_54418: ;
#line 3740
  return;
}
}
#line 3745 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_vlan_strip_enable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vlnctrl ;
  int i ;
  int j ;
  struct ixgbe_ring *ring ;

  {
#line 3747
  hw = & adapter->hw;
  {
#line 3752
  if ((unsigned int )hw->mac.type == 1U) {
#line 3752
    goto case_1;
  } else {

  }
#line 3757
  if ((unsigned int )hw->mac.type == 2U) {
#line 3757
    goto case_2;
  } else {

  }
#line 3758
  if ((unsigned int )hw->mac.type == 3U) {
#line 3758
    goto case_3;
  } else {

  }
#line 3770
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 3753
  vlnctrl = ixgbe_read_reg(hw, 20616U);
#line 3754
  vlnctrl = vlnctrl | 2147483648U;
#line 3755
  ixgbe_write_reg(hw, 20616U, vlnctrl);
  }
#line 3756
  goto ldv_54435;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 3759
  i = 0;
#line 3759
  goto ldv_54441;
  ldv_54440: 
#line 3760
  ring = adapter->rx_ring[i];
#line 3762
  if ((unsigned long )ring->l2_accel_priv != (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 3763
    goto ldv_54439;
  } else {

  }
  {
#line 3764
  j = (int )ring->reg_idx;
#line 3765
  vlnctrl = ixgbe_read_reg(hw, (u32 )(j <= 63 ? j * 64 + 4136 : (j + -64) * 64 + 53288));
#line 3766
  vlnctrl = vlnctrl | 1073741824U;
#line 3767
  ixgbe_write_reg(hw, (u32 )(j <= 63 ? j * 64 + 4136 : (j + -64) * 64 + 53288), vlnctrl);
  }
  ldv_54439: 
#line 3759
  i = i + 1;
  ldv_54441: ;
#line 3759
  if (i < adapter->num_rx_queues) {
#line 3761
    goto ldv_54440;
  } else {

  }

#line 3769
  goto ldv_54435;
  switch_default: /* CIL Label */ ;
#line 3771
  goto ldv_54435;
  switch_break: /* CIL Label */ ;
  }
  ldv_54435: ;
#line 3774
  return;
}
}
#line 3775 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_restore_vlan(struct ixgbe_adapter *adapter ) 
{ 
  u16 vid ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 3779
  ixgbe_vlan_rx_add_vid(adapter->netdev, 129, 0);
#line 3781
  tmp = find_first_bit((unsigned long const   *)(& adapter->active_vlans), 4096UL);
#line 3781
  vid = (u16 )tmp;
  }
#line 3781
  goto ldv_54449;
  ldv_54448: 
  {
#line 3782
  ixgbe_vlan_rx_add_vid(adapter->netdev, 129, (int )vid);
#line 3781
  tmp___0 = find_next_bit((unsigned long const   *)(& adapter->active_vlans), 4096UL,
                          (unsigned long )((int )vid + 1));
#line 3781
  vid = (u16 )tmp___0;
  }
  ldv_54449: ;
#line 3781
  if ((unsigned int )vid <= 4095U) {
#line 3783
    goto ldv_54448;
  } else {

  }

#line 3788
  return;
}
}
#line 3794 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_write_uc_addr_list(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  unsigned int rar_entries ;
  int count ;
  struct netdev_hw_addr *ha ;
  struct list_head  const  *__mptr ;
  unsigned int tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 3796
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3796
  adapter = (struct ixgbe_adapter *)tmp;
#line 3797
  hw = & adapter->hw;
#line 3798
  rar_entries = hw->mac.num_rar_entries - 1U;
#line 3799
  count = 0;
  }
#line 3802
  if ((adapter->flags & 8388608U) != 0U) {
#line 3803
    rar_entries = 14U;
  } else {

  }
#line 3806
  if ((unsigned int )netdev->uc.count > rar_entries) {
#line 3807
    return (-12);
  } else {

  }
#line 3809
  if (netdev->uc.count != 0) {
#line 3812
    if ((unsigned long )hw->mac.ops.set_rar == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                         u32  , u8 * ,
                                                                         u32  , u32  ))0)) {
#line 3813
      return (-12);
    } else {

    }
#line 3815
    __mptr = (struct list_head  const  *)netdev->uc.list.next;
#line 3815
    ha = (struct netdev_hw_addr *)__mptr;
#line 3815
    goto ldv_54465;
    ldv_54464: ;
#line 3816
    if (rar_entries == 0U) {
#line 3817
      goto ldv_54463;
    } else {

    }
    {
#line 3818
    tmp___0 = rar_entries;
#line 3818
    rar_entries = rar_entries - 1U;
#line 3818
    (*(hw->mac.ops.set_rar))(hw, tmp___0, (u8 *)(& ha->addr), (u32 )adapter->ring_feature[1].offset,
                             2147483648U);
#line 3820
    count = count + 1;
#line 3815
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 3815
    ha = (struct netdev_hw_addr *)__mptr___0;
    }
    ldv_54465: ;
#line 3815
    if ((unsigned long )(& ha->list) != (unsigned long )(& netdev->uc.list)) {
#line 3817
      goto ldv_54464;
    } else {

    }
    ldv_54463: ;
  } else {

  }
#line 3824
  goto ldv_54467;
  ldv_54466: 
  {
#line 3825
  (*(hw->mac.ops.clear_rar))(hw, rar_entries);
#line 3824
  rar_entries = rar_entries - 1U;
  }
  ldv_54467: ;
#line 3824
  if (rar_entries != 0U) {
#line 3826
    goto ldv_54466;
  } else {

  }

#line 3827
  return (count);
}
}
#line 3839 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_set_rx_mode(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u32 fctrl ;
  u32 vmolr ;
  int count ;
  u32 tmp___0 ;

  {
  {
#line 3841
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3841
  adapter = (struct ixgbe_adapter *)tmp;
#line 3842
  hw = & adapter->hw;
#line 3843
  vmolr = 150994944U;
#line 3848
  fctrl = ixgbe_read_reg(hw, 20608U);
#line 3851
  fctrl = fctrl & 4294967293U;
#line 3852
  fctrl = fctrl | 1024U;
#line 3853
  fctrl = fctrl | 8192U;
#line 3854
  fctrl = fctrl | 4096U;
#line 3857
  fctrl = fctrl & 4294966527U;
  }
#line 3859
  if ((netdev->flags & 256U) != 0U) {
#line 3860
    hw->addr_ctrl.user_set_promisc = 1;
#line 3861
    fctrl = fctrl | 768U;
#line 3862
    vmolr = vmolr | 335544320U;
#line 3867
    if ((adapter->flags & 8404992U) == 0U) {
      {
#line 3869
      ixgbe_vlan_filter_disable(adapter);
      }
    } else {
      {
#line 3871
      ixgbe_vlan_filter_enable(adapter);
      }
    }
  } else {
#line 3873
    if ((netdev->flags & 512U) != 0U) {
#line 3874
      fctrl = fctrl | 256U;
#line 3875
      vmolr = vmolr | 268435456U;
    } else {

    }
    {
#line 3877
    ixgbe_vlan_filter_enable(adapter);
#line 3878
    hw->addr_ctrl.user_set_promisc = 0;
    }
  }
  {
#line 3886
  count = ixgbe_write_uc_addr_list(netdev);
  }
#line 3887
  if (count < 0) {
#line 3888
    fctrl = fctrl | 512U;
#line 3889
    vmolr = vmolr | 67108864U;
  } else {

  }
  {
#line 3896
  (*(hw->mac.ops.update_mc_addr_list))(hw, netdev);
#line 3897
  vmolr = vmolr | 33554432U;
  }
#line 3899
  if (adapter->num_vfs != 0U) {
    {
#line 3900
    ixgbe_restore_vf_multicasts(adapter);
    }
  } else {

  }
#line 3902
  if ((unsigned int )hw->mac.type != 1U) {
    {
#line 3903
    tmp___0 = ixgbe_read_reg(hw, (u32 )(((int )adapter->ring_feature[1].offset + 15360) * 4));
#line 3903
    vmolr = vmolr | (tmp___0 & 3925868543U);
#line 3906
    ixgbe_write_reg(hw, (u32 )(((int )adapter->ring_feature[1].offset + 15360) * 4),
                    vmolr);
    }
  } else {

  }
#line 3910
  if (((adapter->netdev)->features & 68719476736ULL) != 0ULL) {
#line 3913
    fctrl = fctrl | 5122U;
#line 3917
    fctrl = fctrl & 4294959103U;
  } else {

  }
  {
#line 3921
  ixgbe_write_reg(hw, 20608U, fctrl);
  }
#line 3923
  if ((netdev->features & 256ULL) != 0ULL) {
    {
#line 3924
    ixgbe_vlan_strip_enable(adapter);
    }
  } else {
    {
#line 3926
    ixgbe_vlan_strip_disable(adapter);
    }
  }
#line 3927
  return;
}
}
#line 3929 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_napi_enable_all(struct ixgbe_adapter *adapter ) 
{ 
  int q_idx ;

  {
#line 3933
  q_idx = 0;
#line 3933
  goto ldv_54482;
  ldv_54481: 
  {
#line 3934
  ixgbe_qv_init_lock(adapter->q_vector[q_idx]);
#line 3935
  napi_enable(& (adapter->q_vector[q_idx])->napi);
#line 3933
  q_idx = q_idx + 1;
  }
  ldv_54482: ;
#line 3933
  if (q_idx < adapter->num_q_vectors) {
#line 3935
    goto ldv_54481;
  } else {

  }

#line 3940
  return;
}
}
#line 3939 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_napi_disable_all(struct ixgbe_adapter *adapter ) 
{ 
  int q_idx ;
  bool tmp ;
  int tmp___0 ;

  {
#line 3943
  q_idx = 0;
#line 3943
  goto ldv_54492;
  ldv_54491: 
  {
#line 3944
  napi_disable(& (adapter->q_vector[q_idx])->napi);
  }
#line 3945
  goto ldv_54489;
  ldv_54488: 
  {
#line 3946
  printk("\016ixgbe: QV %d locked\n", q_idx);
#line 3947
  usleep_range(1000UL, 20000UL);
  }
  ldv_54489: 
  {
#line 3945
  tmp = ixgbe_qv_disable(adapter->q_vector[q_idx]);
  }
#line 3945
  if (tmp) {
#line 3945
    tmp___0 = 0;
  } else {
#line 3945
    tmp___0 = 1;
  }
#line 3945
  if (tmp___0) {
#line 3947
    goto ldv_54488;
  } else {

  }
#line 3943
  q_idx = q_idx + 1;
  ldv_54492: ;
#line 3943
  if (q_idx < adapter->num_q_vectors) {
#line 3945
    goto ldv_54491;
  } else {

  }

#line 3950
  return;
}
}
#line 3961 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_dcb(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int max_frame ;
  int _max1 ;
  int _max2 ;
  u32 msb ;
  u16 rss_i ;

  {
#line 3963
  hw = & adapter->hw;
#line 3964
  max_frame = (int )((adapter->netdev)->mtu + 18U);
#line 3966
  if ((adapter->flags & 4096U) == 0U) {
#line 3967
    if ((unsigned int )hw->mac.type == 1U) {
      {
#line 3968
      netif_set_gso_max_size(adapter->netdev, 65536U);
      }
    } else {

    }
#line 3969
    return;
  } else {

  }
#line 3972
  if ((unsigned int )hw->mac.type == 1U) {
    {
#line 3973
    netif_set_gso_max_size(adapter->netdev, 32768U);
    }
  } else {

  }
#line 3976
  if (((adapter->netdev)->features & 536870912ULL) != 0ULL) {
#line 3977
    _max1 = max_frame;
#line 3977
    _max2 = 3072;
#line 3977
    max_frame = _max1 > _max2 ? _max1 : _max2;
  } else {

  }
#line 3981
  if (((int )adapter->dcbx_cap & 4) != 0) {
    {
#line 3982
    ixgbe_dcb_calculate_tc_credits(hw, & adapter->dcb_cfg, max_frame, 0);
#line 3984
    ixgbe_dcb_calculate_tc_credits(hw, & adapter->dcb_cfg, max_frame, 1);
#line 3986
    ixgbe_dcb_hw_config(hw, & adapter->dcb_cfg);
    }
  } else
#line 3987
  if ((unsigned long )adapter->ixgbe_ieee_ets != (unsigned long )((struct ieee_ets *)0) && (unsigned long )adapter->ixgbe_ieee_pfc != (unsigned long )((struct ieee_pfc *)0)) {
    {
#line 3988
    ixgbe_dcb_hw_ets(& adapter->hw, adapter->ixgbe_ieee_ets, max_frame);
#line 3991
    ixgbe_dcb_hw_pfc_config(& adapter->hw, (int )(adapter->ixgbe_ieee_pfc)->pfc_en,
                            (u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc));
    }
  } else {

  }
#line 3997
  if ((unsigned int )hw->mac.type != 1U) {
#line 3998
    msb = 0U;
#line 3999
    rss_i = (unsigned int )adapter->ring_feature[2].indices + 65535U;
#line 4001
    goto ldv_54505;
    ldv_54504: 
#line 4002
    msb = msb + 1U;
#line 4003
    rss_i = (u16 )((int )rss_i >> 1);
    ldv_54505: ;
#line 4001
    if ((unsigned int )rss_i != 0U) {
#line 4003
      goto ldv_54504;
    } else {

    }
    {
#line 4007
    ixgbe_write_reg(hw, 60528U, msb * 286331153U);
    }
  } else {

  }
#line 4009
  return;
}
}
#line 4021 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_hpbthresh(struct ixgbe_adapter *adapter , int pb ) 
{ 
  struct ixgbe_hw *hw ;
  struct net_device *dev ;
  int link ;
  int tc ;
  int kb ;
  int marker ;
  u32 dv_id ;
  u32 rx_pba ;
  u8 tmp ;
  u32 tmp___0 ;

  {
#line 4023
  hw = & adapter->hw;
#line 4024
  dev = adapter->netdev;
#line 4029
  link = (int )(dev->mtu + 38U);
#line 4029
  tc = link;
#line 4033
  if ((dev->features & 536870912ULL) != 0ULL && tc <= 3071) {
    {
#line 4033
    tmp = ixgbe_fcoe_get_tc(adapter);
    }
#line 4033
    if (pb == (int )tmp) {
#line 4036
      tc = 3072;
    } else {

    }
  } else {

  }
  {
#line 4041
  if ((unsigned int )hw->mac.type == 3U) {
#line 4041
    goto case_3;
  } else {

  }
#line 4044
  goto switch_default;
  case_3: /* CIL Label */ 
#line 4042
  dv_id = (u32 )(((link * 288 + 3373344) / 25 + 1) + tc * 16);
#line 4043
  goto ldv_54520;
  switch_default: /* CIL Label */ 
#line 4045
  dv_id = (u32 )(((link * 288 + 2009376) / 25 + 1) + tc * 16);
#line 4046
  goto ldv_54520;
  switch_break: /* CIL Label */ ;
  }
  ldv_54520: ;
#line 4050
  if ((adapter->flags & 8388608U) != 0U) {
#line 4051
    dv_id = dv_id + (u32 )(tc * 8);
  } else {

  }
  {
#line 4054
  kb = (int )((dv_id + 8191U) / 8192U);
#line 4055
  tmp___0 = ixgbe_read_reg(hw, (u32 )((pb + 3840) * 4));
#line 4055
  rx_pba = tmp___0 >> 10;
#line 4057
  marker = (int )(rx_pba - (u32 )kb);
  }
#line 4063
  if (marker < 0) {
#line 4064
    if ((int )adapter->msg_enable & 1) {
      {
#line 4066
      netdev_warn((struct net_device  const  *)adapter->netdev, "Packet Buffer(%i) can not provide enoughheadroom to support flow control.Decrease MTU or number of traffic classes\n",
                  pb);
      }
    } else {

    }
#line 4067
    marker = tc + 1;
  } else {

  }
#line 4070
  return (marker);
}
}
#line 4079 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_lpbthresh(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct net_device *dev ;
  int tc ;
  u32 dv_id ;

  {
#line 4081
  hw = & adapter->hw;
#line 4082
  dev = adapter->netdev;
#line 4087
  tc = (int )(dev->mtu + 18U);
  {
#line 4091
  if ((unsigned int )hw->mac.type == 3U) {
#line 4091
    goto case_3;
  } else {

  }
#line 4094
  goto switch_default;
  case_3: /* CIL Label */ 
#line 4092
  dv_id = (u32 )((tc + 900) * 16 + 1);
#line 4093
  goto ldv_54530;
  switch_default: /* CIL Label */ 
#line 4095
  dv_id = (u32 )((tc + 900) * 32 + 2);
#line 4096
  goto ldv_54530;
  switch_break: /* CIL Label */ ;
  }
  ldv_54530: ;
#line 4100
  return ((int )((dv_id + 8191U) / 8192U));
}
}
#line 4106 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_pbthresh_setup(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int num_tc ;
  int tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4108
  hw = & adapter->hw;
#line 4109
  tmp = netdev_get_num_tc(adapter->netdev);
#line 4109
  num_tc = tmp;
  }
#line 4112
  if (num_tc == 0) {
#line 4113
    num_tc = 1;
  } else {

  }
  {
#line 4115
  tmp___0 = ixgbe_lpbthresh(adapter);
#line 4115
  hw->fc.low_water = (u32 )tmp___0;
#line 4117
  i = 0;
  }
#line 4117
  goto ldv_54539;
  ldv_54538: 
  {
#line 4118
  tmp___1 = ixgbe_hpbthresh(adapter, i);
#line 4118
  hw->fc.high_water[i] = (u32 )tmp___1;
  }
#line 4121
  if (hw->fc.low_water > hw->fc.high_water[i]) {
#line 4122
    hw->fc.low_water = 0U;
  } else {

  }
#line 4117
  i = i + 1;
  ldv_54539: ;
#line 4117
  if (i < num_tc) {
#line 4119
    goto ldv_54538;
  } else {

  }

#line 4124
  return;
}
}
#line 4126 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_pb(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int hdrm ;
  u8 tc ;
  int tmp ;

  {
  {
#line 4128
  hw = & adapter->hw;
#line 4130
  tmp = netdev_get_num_tc(adapter->netdev);
#line 4130
  tc = (u8 )tmp;
  }
#line 4132
  if (*((unsigned int *)adapter + 134UL) != 0U) {
#line 4134
    hdrm = 32 << (int )adapter->fdir_pballoc;
  } else {
#line 4136
    hdrm = 0;
  }
  {
#line 4138
  (*(hw->mac.ops.set_rxpba))(hw, (int )tc, (u32 )hdrm, 0);
#line 4139
  ixgbe_pbthresh_setup(adapter);
  }
#line 4140
  return;
}
}
#line 4142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_filter_restore(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *filter ;
  int tmp ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp___0 ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___1 ;

  {
  {
#line 4144
  hw = & adapter->hw;
#line 4148
  spin_lock(& adapter->fdir_perfect_lock);
#line 4150
  tmp = hlist_empty((struct hlist_head  const  *)(& adapter->fdir_filter_list));
  }
#line 4150
  if (tmp == 0) {
    {
#line 4151
    ixgbe_fdir_set_input_mask_82599(hw, & adapter->fdir_mask);
    }
  } else {

  }
#line 4153
  ____ptr = adapter->fdir_filter_list.first;
#line 4153
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 4153
    __mptr = (struct hlist_node  const  *)____ptr;
#line 4153
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 4153
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 4153
  filter = tmp___0;
#line 4153
  goto ldv_54563;
  ldv_54562: 
  {
#line 4155
  ixgbe_fdir_write_perfect_filter_82599(hw, & filter->filter, (int )filter->sw_idx,
                                        (unsigned int )filter->action != 127U ? (int )(adapter->rx_ring[(int )filter->action])->reg_idx : 127);
#line 4153
  ____ptr___0 = node2;
  }
#line 4153
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 4153
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 4153
    tmp___1 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 4153
    tmp___1 = (struct ixgbe_fdir_filter *)0;
  }
#line 4153
  filter = tmp___1;
  ldv_54563: ;
#line 4153
  if ((unsigned long )filter != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 4153
    node2 = filter->fdir_node.next;
#line 4155
    goto ldv_54562;
  } else {

  }
  {
#line 4163
  spin_unlock(& adapter->fdir_perfect_lock);
  }
#line 4164
  return;
}
}
#line 4166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_macvlan_set_rx_mode(struct net_device *dev , unsigned int pool ,
                                      struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vmolr ;

  {
  {
#line 4169
  hw = & adapter->hw;
#line 4173
  vmolr = ixgbe_read_reg(hw, (pool + 15360U) * 4U);
#line 4174
  vmolr = vmolr | 184549376U;
#line 4177
  vmolr = vmolr & 4026531839U;
  }
#line 4179
  if ((dev->flags & 512U) != 0U) {
#line 4180
    vmolr = vmolr | 268435456U;
  } else {
    {
#line 4182
    vmolr = vmolr | 33554432U;
#line 4183
    (*(hw->mac.ops.update_mc_addr_list))(hw, dev);
    }
  }
  {
#line 4185
  ixgbe_write_uc_addr_list(adapter->netdev);
#line 4186
  ixgbe_write_reg(hw, (pool + 15360U) * 4U, vmolr);
  }
#line 4187
  return;
}
}
#line 4189 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_add_mac_filter(struct ixgbe_adapter *adapter , u8 *addr , u16 pool ) 
{ 
  struct ixgbe_hw *hw ;
  unsigned int entry ;

  {
  {
#line 4192
  hw = & adapter->hw;
#line 4195
  entry = hw->mac.num_rar_entries - (u32 )pool;
#line 4196
  (*(hw->mac.ops.set_rar))(hw, entry, addr, (u32 )((int )pool + (int )adapter->ring_feature[1].offset),
                           2147483648U);
  }
#line 4197
  return;
}
}
#line 4199 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fwd_psrtype(struct ixgbe_fwd_adapter *vadapter ) 
{ 
  struct ixgbe_adapter *adapter ;
  int rss_i ;
  struct ixgbe_hw *hw ;
  u16 pool ;
  u32 psrtype ;

  {
#line 4201
  adapter = vadapter->real_adapter;
#line 4202
  rss_i = adapter->num_rx_queues_per_pool;
#line 4203
  hw = & adapter->hw;
#line 4204
  pool = (u16 )vadapter->pool;
#line 4205
  psrtype = 4912U;
#line 4211
  if ((unsigned int )hw->mac.type == 1U) {
#line 4212
    return;
  } else {

  }
#line 4214
  if (rss_i > 3) {
#line 4215
    psrtype = psrtype | 1073741824U;
  } else
#line 4216
  if (rss_i > 1) {
#line 4217
    psrtype = psrtype | 536870912U;
  } else {

  }
  {
#line 4219
  ixgbe_write_reg(hw, (u32 )((int )pool + (int )adapter->ring_feature[1].offset <= 15 ? (((int )pool + (int )adapter->ring_feature[1].offset) + 5408) * 4 : (((int )pool + (int )adapter->ring_feature[1].offset) + 14976) * 4),
                  psrtype);
  }
#line 4220
  return;
}
}
#line 4226 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_rx_ring(struct ixgbe_ring *rx_ring ) 
{ 
  struct device *dev ;
  unsigned long size ;
  u16 i ;
  struct ixgbe_rx_buffer *rx_buffer ;
  struct sk_buff *skb ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 4228
  dev = rx_ring->dev;
#line 4233
  if ((unsigned long )rx_ring->__annonCompField94.rx_buffer_info == (unsigned long )((struct ixgbe_rx_buffer *)0)) {
#line 4234
    return;
  } else {

  }
#line 4237
  i = 0U;
#line 4237
  goto ldv_54596;
  ldv_54595: 
#line 4240
  rx_buffer = rx_ring->__annonCompField94.rx_buffer_info + (unsigned long )i;
#line 4241
  if ((unsigned long )rx_buffer->skb != (unsigned long )((struct sk_buff *)0)) {
#line 4242
    skb = rx_buffer->skb;
#line 4243
    if ((int )((struct ixgbe_cb *)(& skb->cb))->page_released) {
      {
#line 4244
      tmp = ixgbe_rx_bufsz(rx_ring);
#line 4244
      dma_unmap_page(dev, ((struct ixgbe_cb *)(& skb->cb))->dma, (size_t )tmp, 2);
#line 4248
      ((struct ixgbe_cb *)(& skb->cb))->page_released = 0;
      }
    } else {

    }
    {
#line 4250
    consume_skb(skb);
    }
  } else {

  }
#line 4252
  rx_buffer->skb = (struct sk_buff *)0;
#line 4253
  if (rx_buffer->dma != 0ULL) {
    {
#line 4254
    tmp___0 = ixgbe_rx_pg_order(rx_ring);
#line 4254
    dma_unmap_page(dev, rx_buffer->dma, 4096UL << (int )tmp___0, 2);
    }
  } else {

  }
#line 4257
  rx_buffer->dma = 0ULL;
#line 4258
  if ((unsigned long )rx_buffer->page != (unsigned long )((struct page *)0)) {
    {
#line 4259
    tmp___1 = ixgbe_rx_pg_order(rx_ring);
#line 4259
    __free_pages(rx_buffer->page, tmp___1);
    }
  } else {

  }
#line 4261
  rx_buffer->page = (struct page *)0;
#line 4237
  i = (u16 )((int )i + 1);
  ldv_54596: ;
#line 4237
  if ((int )i < (int )rx_ring->count) {
#line 4239
    goto ldv_54595;
  } else {

  }
  {
#line 4264
  size = (unsigned long )rx_ring->count * 32UL;
#line 4265
  memset((void *)rx_ring->__annonCompField94.rx_buffer_info, 0, size);
#line 4268
  memset(rx_ring->desc, 0, (size_t )rx_ring->size);
#line 4270
  rx_ring->__annonCompField96.next_to_alloc = 0U;
#line 4271
  rx_ring->next_to_clean = 0U;
#line 4272
  rx_ring->next_to_use = 0U;
  }
#line 4273
  return;
}
}
#line 4275 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_disable_fwd_ring(struct ixgbe_fwd_adapter *vadapter , struct ixgbe_ring *rx_ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  int index ;

  {
  {
#line 4278
  adapter = vadapter->real_adapter;
#line 4279
  index = (int )((unsigned int )rx_ring->queue_index + vadapter->rx_base_queue);
#line 4282
  ixgbe_disable_rx_queue(adapter, rx_ring);
#line 4283
  usleep_range(10000UL, 20000UL);
#line 4284
  ixgbe_irq_disable_queues(adapter, 1ULL << index);
#line 4285
  ixgbe_clean_rx_ring(rx_ring);
#line 4286
  rx_ring->l2_accel_priv = (struct ixgbe_fwd_adapter *)0;
  }
#line 4287
  return;
}
}
#line 4289 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_fwd_ring_down(struct net_device *vdev , struct ixgbe_fwd_adapter *accel ) 
{ 
  struct ixgbe_adapter *adapter ;
  unsigned int rxbase ;
  unsigned int txbase ;
  int i ;

  {
  {
#line 4292
  adapter = accel->real_adapter;
#line 4293
  rxbase = accel->rx_base_queue;
#line 4294
  txbase = accel->tx_base_queue;
#line 4297
  netif_tx_stop_all_queues(vdev);
#line 4299
  i = 0;
  }
#line 4299
  goto ldv_54613;
  ldv_54612: 
  {
#line 4300
  ixgbe_disable_fwd_ring(accel, adapter->rx_ring[rxbase + (unsigned int )i]);
#line 4301
  (adapter->rx_ring[rxbase + (unsigned int )i])->netdev = adapter->netdev;
#line 4299
  i = i + 1;
  }
  ldv_54613: ;
#line 4299
  if (i < adapter->num_rx_queues_per_pool) {
#line 4301
    goto ldv_54612;
  } else {

  }
#line 4304
  i = 0;
#line 4304
  goto ldv_54616;
  ldv_54615: 
#line 4305
  (adapter->tx_ring[txbase + (unsigned int )i])->l2_accel_priv = (struct ixgbe_fwd_adapter *)0;
#line 4306
  (adapter->tx_ring[txbase + (unsigned int )i])->netdev = adapter->netdev;
#line 4304
  i = i + 1;
  ldv_54616: ;
#line 4304
  if (i < adapter->num_rx_queues_per_pool) {
#line 4306
    goto ldv_54615;
  } else {

  }

#line 4310
  return (0);
}
}
#line 4313 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_fwd_ring_up(struct net_device *vdev , struct ixgbe_fwd_adapter *accel ) 
{ 
  struct ixgbe_adapter *adapter ;
  unsigned int rxbase ;
  unsigned int txbase ;
  unsigned int queues ;
  int i ;
  int baseq ;
  int err ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  bool tmp___2 ;

  {
  {
#line 4316
  adapter = accel->real_adapter;
#line 4318
  err = 0;
#line 4320
  tmp___0 = variable_test_bit((long )accel->pool, (unsigned long const volatile   *)(& adapter->fwd_bitmask));
  }
#line 4320
  if (tmp___0 == 0) {
#line 4321
    return (0);
  } else {

  }
  {
#line 4323
  baseq = accel->pool * adapter->num_rx_queues_per_pool;
#line 4324
  descriptor.modname = "ixgbe";
#line 4324
  descriptor.function = "ixgbe_fwd_ring_up";
#line 4324
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_main.c";
#line 4324
  descriptor.format = "pool %i:%i queues %i:%i VSI bitmask %lx\n";
#line 4324
  descriptor.lineno = 4327U;
#line 4324
  descriptor.flags = 0U;
#line 4324
  tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 4324
  if (tmp___1 != 0L) {
    {
#line 4324
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)vdev, "pool %i:%i queues %i:%i VSI bitmask %lx\n",
                         accel->pool, adapter->num_rx_pools, baseq, baseq + adapter->num_rx_queues_per_pool,
                         adapter->fwd_bitmask);
    }
  } else {

  }
#line 4329
  accel->netdev = vdev;
#line 4330
  rxbase = (unsigned int )baseq;
#line 4330
  accel->rx_base_queue = rxbase;
#line 4331
  txbase = (unsigned int )baseq;
#line 4331
  accel->tx_base_queue = txbase;
#line 4333
  i = 0;
#line 4333
  goto ldv_54632;
  ldv_54631: 
  {
#line 4334
  ixgbe_disable_fwd_ring(accel, adapter->rx_ring[rxbase + (unsigned int )i]);
#line 4333
  i = i + 1;
  }
  ldv_54632: ;
#line 4333
  if (i < adapter->num_rx_queues_per_pool) {
#line 4335
    goto ldv_54631;
  } else {

  }
#line 4336
  i = 0;
#line 4336
  goto ldv_54635;
  ldv_54634: 
  {
#line 4337
  (adapter->rx_ring[rxbase + (unsigned int )i])->netdev = vdev;
#line 4338
  (adapter->rx_ring[rxbase + (unsigned int )i])->l2_accel_priv = accel;
#line 4339
  ixgbe_configure_rx_ring(adapter, adapter->rx_ring[rxbase + (unsigned int )i]);
#line 4336
  i = i + 1;
  }
  ldv_54635: ;
#line 4336
  if (i < adapter->num_rx_queues_per_pool) {
#line 4338
    goto ldv_54634;
  } else {

  }
#line 4342
  i = 0;
#line 4342
  goto ldv_54638;
  ldv_54637: 
#line 4343
  (adapter->tx_ring[txbase + (unsigned int )i])->netdev = vdev;
#line 4344
  (adapter->tx_ring[txbase + (unsigned int )i])->l2_accel_priv = accel;
#line 4342
  i = i + 1;
  ldv_54638: ;
#line 4342
  if (i < adapter->num_rx_queues_per_pool) {
#line 4344
    goto ldv_54637;
  } else {

  }
  {
#line 4347
  __min1 = (unsigned int )adapter->num_rx_queues_per_pool;
#line 4347
  __min2 = vdev->num_tx_queues;
#line 4347
  queues = __min1 < __min2 ? __min1 : __min2;
#line 4349
  err = netif_set_real_num_tx_queues(vdev, queues);
  }
#line 4350
  if (err != 0) {
#line 4351
    goto fwd_queue_err;
  } else {

  }
  {
#line 4353
  err = netif_set_real_num_rx_queues(vdev, queues);
  }
#line 4354
  if (err != 0) {
#line 4355
    goto fwd_queue_err;
  } else {

  }
  {
#line 4357
  tmp___2 = is_valid_ether_addr((u8 const   *)vdev->dev_addr);
  }
#line 4357
  if ((int )tmp___2) {
    {
#line 4358
    ixgbe_add_mac_filter(adapter, vdev->dev_addr, (int )((u16 )accel->pool));
    }
  } else {

  }
  {
#line 4360
  ixgbe_fwd_psrtype(accel);
#line 4361
  ixgbe_macvlan_set_rx_mode(vdev, (unsigned int )accel->pool, adapter);
  }
#line 4362
  return (err);
  fwd_queue_err: 
  {
#line 4364
  ixgbe_fwd_ring_down(vdev, accel);
  }
#line 4365
  return (err);
}
}
#line 4368 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure_dfwd(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *upper ;
  struct list_head *iter ;
  int err ;
  struct macvlan_dev *dfwd ;
  void *tmp ;
  struct ixgbe_fwd_adapter *vadapter ;
  bool tmp___0 ;

  {
  {
#line 4374
  iter = & (adapter->netdev)->all_adj_list.upper;
#line 4374
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  }
#line 4374
  goto ldv_54654;
  ldv_54653: 
  {
#line 4375
  tmp___0 = netif_is_macvlan(upper);
  }
#line 4375
  if ((int )tmp___0) {
    {
#line 4376
    tmp = netdev_priv((struct net_device  const  *)upper);
#line 4376
    dfwd = (struct macvlan_dev *)tmp;
#line 4377
    vadapter = (struct ixgbe_fwd_adapter *)dfwd->fwd_priv;
    }
#line 4379
    if ((unsigned long )dfwd->fwd_priv != (unsigned long )((void *)0)) {
      {
#line 4380
      err = ixgbe_fwd_ring_up(upper, vadapter);
      }
#line 4381
      if (err != 0) {
#line 4382
        goto ldv_54652;
      } else {

      }
    } else {

    }
  } else {

  }
  ldv_54652: 
  {
#line 4374
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  }
  ldv_54654: ;
#line 4374
  if ((unsigned long )upper != (unsigned long )((struct net_device *)0)) {
#line 4376
    goto ldv_54653;
  } else {

  }

#line 4381
  return;
}
}
#line 4388 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_configure(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;

  {
  {
#line 4390
  hw = & adapter->hw;
#line 4392
  ixgbe_configure_pb(adapter);
#line 4394
  ixgbe_configure_dcb(adapter);
#line 4400
  ixgbe_configure_virtualization(adapter);
#line 4402
  ixgbe_set_rx_mode(adapter->netdev);
#line 4403
  ixgbe_restore_vlan(adapter);
  }
  {
#line 4406
  if ((unsigned int )hw->mac.type == 2U) {
#line 4406
    goto case_2;
  } else {

  }
#line 4407
  if ((unsigned int )hw->mac.type == 3U) {
#line 4407
    goto case_3;
  } else {

  }
#line 4410
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 4408
  (*(hw->mac.ops.disable_rx_buff))(hw);
  }
#line 4409
  goto ldv_54662;
  switch_default: /* CIL Label */ ;
#line 4411
  goto ldv_54662;
  switch_break: /* CIL Label */ ;
  }
  ldv_54662: ;
#line 4414
  if ((adapter->flags & 262144U) != 0U) {
    {
#line 4415
    ixgbe_init_fdir_signature_82599(& adapter->hw, adapter->fdir_pballoc);
    }
  } else
#line 4417
  if ((adapter->flags & 524288U) != 0U) {
    {
#line 4418
    ixgbe_init_fdir_perfect_82599(& adapter->hw, adapter->fdir_pballoc);
#line 4420
    ixgbe_fdir_filter_restore(adapter);
    }
  } else {

  }
  {
#line 4424
  if ((unsigned int )hw->mac.type == 2U) {
#line 4424
    goto case_2___0;
  } else {

  }
#line 4425
  if ((unsigned int )hw->mac.type == 3U) {
#line 4425
    goto case_3___0;
  } else {

  }
#line 4428
  goto switch_default___0;
  case_2___0: /* CIL Label */ ;
  case_3___0: /* CIL Label */ 
  {
#line 4426
  (*(hw->mac.ops.enable_rx_buff))(hw);
  }
#line 4427
  goto ldv_54666;
  switch_default___0: /* CIL Label */ ;
#line 4429
  goto ldv_54666;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_54666: 
  {
#line 4434
  ixgbe_configure_fcoe(adapter);
#line 4437
  ixgbe_configure_tx(adapter);
#line 4438
  ixgbe_configure_rx(adapter);
#line 4439
  ixgbe_configure_dfwd(adapter);
  }
#line 4440
  return;
}
}
#line 4442 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static bool ixgbe_is_sfp(struct ixgbe_hw *hw ) 
{ 


  {
  {
#line 4445
  if ((unsigned int )hw->phy.type == 11U) {
#line 4445
    goto case_11;
  } else {

  }
#line 4446
  if ((unsigned int )hw->phy.type == 12U) {
#line 4446
    goto case_12;
  } else {

  }
#line 4447
  if ((unsigned int )hw->phy.type == 15U) {
#line 4447
    goto case_15;
  } else {

  }
#line 4448
  if ((unsigned int )hw->phy.type == 14U) {
#line 4448
    goto case_14;
  } else {

  }
#line 4449
  if ((unsigned int )hw->phy.type == 8U) {
#line 4449
    goto case_8;
  } else {

  }
#line 4450
  if ((unsigned int )hw->phy.type == 9U) {
#line 4450
    goto case_9;
  } else {

  }
#line 4451
  if ((unsigned int )hw->phy.type == 10U) {
#line 4451
    goto case_10;
  } else {

  }
#line 4452
  if ((unsigned int )hw->phy.type == 13U) {
#line 4452
    goto case_13;
  } else {

  }
#line 4453
  if ((unsigned int )hw->phy.type == 16U) {
#line 4453
    goto case_16;
  } else {

  }
#line 4454
  if ((unsigned int )hw->phy.type == 17U) {
#line 4454
    goto case_17;
  } else {

  }
#line 4455
  if ((unsigned int )hw->phy.type == 18U) {
#line 4455
    goto case_18;
  } else {

  }
#line 4456
  if ((unsigned int )hw->phy.type == 19U) {
#line 4456
    goto case_19;
  } else {

  }
#line 4458
  if ((unsigned int )hw->phy.type == 7U) {
#line 4458
    goto case_7;
  } else {

  }
#line 4461
  goto switch_default;
  case_11: /* CIL Label */ ;
  case_12: /* CIL Label */ ;
  case_15: /* CIL Label */ ;
  case_14: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_13: /* CIL Label */ ;
  case_16: /* CIL Label */ ;
  case_17: /* CIL Label */ ;
  case_18: /* CIL Label */ ;
  case_19: /* CIL Label */ ;
#line 4457
  return (1);
  case_7: /* CIL Label */ ;
#line 4459
  if ((unsigned int )hw->mac.type == 1U) {
#line 4460
    return (1);
  } else {

  }
  switch_default: /* CIL Label */ ;
#line 4462
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 4470 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_link_config(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 4478
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 4479
    adapter->flags2 = adapter->flags2 | 16U;
  } else {

  }
#line 4481
  adapter->flags2 = adapter->flags2 | 32U;
#line 4482
  return;
}
}
#line 4490 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_non_sfp_link_config(struct ixgbe_hw *hw ) 
{ 
  u32 speed ;
  bool autoneg ;
  bool link_up ;
  u32 ret ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 4493
  link_up = 0;
#line 4494
  ret = 4294967288U;
#line 4496
  if ((unsigned long )hw->mac.ops.check_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          ixgbe_link_speed * ,
                                                                          bool * ,
                                                                          bool  ))0)) {
    {
#line 4497
    tmp = (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
#line 4497
    ret = (u32 )tmp;
    }
  } else {

  }
#line 4499
  if (ret != 0U) {
#line 4500
    goto link_cfg_out;
  } else {

  }
#line 4502
  speed = hw->phy.autoneg_advertised;
#line 4503
  if (speed == 0U && (unsigned long )hw->mac.ops.get_link_capabilities != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                                    ixgbe_link_speed * ,
                                                                                                    bool * ))0)) {
    {
#line 4504
    tmp___0 = (*(hw->mac.ops.get_link_capabilities))(hw, & speed, & autoneg);
#line 4504
    ret = (u32 )tmp___0;
    }
  } else {

  }
#line 4506
  if (ret != 0U) {
#line 4507
    goto link_cfg_out;
  } else {

  }
#line 4509
  if ((unsigned long )hw->mac.ops.setup_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          ixgbe_link_speed  ,
                                                                          bool  ))0)) {
    {
#line 4510
    tmp___1 = (*(hw->mac.ops.setup_link))(hw, speed, (int )link_up);
#line 4510
    ret = (u32 )tmp___1;
    }
  } else {

  }
  link_cfg_out: ;
#line 4512
  return ((int )ret);
}
}
#line 4515 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_setup_gpie(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 gpie ;

  {
#line 4517
  hw = & adapter->hw;
#line 4518
  gpie = 0U;
#line 4520
  if ((adapter->flags & 8U) != 0U) {
#line 4521
    gpie = 2147483696U;
#line 4523
    gpie = gpie | 1073741824U;
    {
#line 4529
    if ((unsigned int )hw->mac.type == 1U) {
#line 4529
      goto case_1;
    } else {

    }
#line 4532
    if ((unsigned int )hw->mac.type == 2U) {
#line 4532
      goto case_2;
    } else {

    }
#line 4533
    if ((unsigned int )hw->mac.type == 3U) {
#line 4533
      goto case_3;
    } else {

    }
#line 4534
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 4530
    ixgbe_write_reg(hw, 2192U, 65535U);
    }
#line 4531
    goto ldv_54702;
    case_2: /* CIL Label */ ;
    case_3: /* CIL Label */ ;
    switch_default: /* CIL Label */ 
    {
#line 4535
    ixgbe_write_reg(hw, 2768U, 4294967295U);
#line 4536
    ixgbe_write_reg(hw, 2772U, 4294967295U);
    }
#line 4537
    goto ldv_54702;
    switch_break: /* CIL Label */ ;
    }
    ldv_54702: ;
  } else {
    {
#line 4542
    ixgbe_write_reg(hw, 2192U, 65535U);
    }
  }
#line 4548
  if ((adapter->flags & 8388608U) != 0U) {
#line 4549
    gpie = gpie & 4294918143U;
    {
#line 4552
    if ((int )adapter->ring_feature[1].mask == 120) {
#line 4552
      goto case_120;
    } else {

    }
#line 4555
    if ((int )adapter->ring_feature[1].mask == 124) {
#line 4555
      goto case_124;
    } else {

    }
#line 4558
    goto switch_default___0;
    case_120: /* CIL Label */ 
#line 4553
    gpie = gpie | 16384U;
#line 4554
    goto ldv_54707;
    case_124: /* CIL Label */ 
#line 4556
    gpie = gpie | 32768U;
#line 4557
    goto ldv_54707;
    switch_default___0: /* CIL Label */ 
#line 4559
    gpie = gpie | 49152U;
#line 4560
    goto ldv_54707;
    switch_break___0: /* CIL Label */ ;
    }
    ldv_54707: ;
  } else {

  }
#line 4565
  if ((adapter->flags2 & 4U) != 0U) {
    {
#line 4567
    if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 4567
      goto case_2___0;
    } else {

    }
#line 4570
    if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 4570
      goto case_3___0;
    } else {

    }
#line 4573
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 4568
    gpie = gpie | 1U;
#line 4569
    goto ldv_54711;
    case_3___0: /* CIL Label */ 
#line 4571
    gpie = gpie | 8388608U;
#line 4572
    goto ldv_54711;
    switch_default___1: /* CIL Label */ ;
#line 4574
    goto ldv_54711;
    switch_break___1: /* CIL Label */ ;
    }
    ldv_54711: ;
  } else {

  }
#line 4579
  if ((adapter->flags & 32768U) != 0U) {
#line 4580
    gpie = gpie | 2U;
  } else {

  }
#line 4582
  if ((unsigned int )hw->mac.type == 2U) {
#line 4583
    gpie = gpie | 2U;
#line 4584
    gpie = gpie | 4U;
  } else {

  }
  {
#line 4587
  ixgbe_write_reg(hw, 2200U, gpie);
  }
#line 4588
  return;
}
}
#line 4590 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_up_complete(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct net_device *upper ;
  struct list_head *iter ;
  int err ;
  u32 ctrl_ext ;
  bool tmp ;
  u32 esdp ;
  u32 tmp___0 ;
  struct macvlan_dev *vlan ;
  void *tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 4592
  hw = & adapter->hw;
#line 4598
  ixgbe_get_hw_control(adapter);
#line 4599
  ixgbe_setup_gpie(adapter);
  }
#line 4601
  if ((adapter->flags & 8U) != 0U) {
    {
#line 4602
    ixgbe_configure_msix(adapter);
    }
  } else {
    {
#line 4604
    ixgbe_configure_msi_and_legacy(adapter);
    }
  }
#line 4607
  if ((unsigned long )hw->mac.ops.enable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
    {
#line 4608
    (*(hw->mac.ops.enable_tx_laser))(hw);
    }
  } else {

  }
  {
#line 4610
  __asm__  volatile   ("": : : "memory");
#line 4611
  clear_bit(2L, (unsigned long volatile   *)(& adapter->state));
#line 4612
  ixgbe_napi_enable_all(adapter);
#line 4614
  tmp = ixgbe_is_sfp(hw);
  }
#line 4614
  if ((int )tmp) {
    {
#line 4615
    ixgbe_sfp_link_config(adapter);
    }
  } else {
    {
#line 4617
    err = ixgbe_non_sfp_link_config(hw);
    }
#line 4618
    if (err != 0) {
#line 4619
      if (((int )adapter->msg_enable & 2) != 0) {
        {
#line 4619
        netdev_err((struct net_device  const  *)adapter->netdev, "link_config FAILED %d\n",
                   err);
        }
      } else {

      }
    } else {

    }
  }
  {
#line 4623
  ixgbe_read_reg(hw, 2048U);
#line 4624
  ixgbe_irq_enable(adapter, 1, 1);
  }
#line 4630
  if ((adapter->flags & 32768U) != 0U) {
    {
#line 4631
    tmp___0 = ixgbe_read_reg(hw, 32U);
#line 4631
    esdp = tmp___0;
    }
#line 4632
    if ((esdp & 2U) != 0U) {
#line 4633
      if ((int )adapter->msg_enable & 1) {
        {
#line 4633
        netdev_crit((struct net_device  const  *)adapter->netdev, "Fan has stopped, replace the adapter\n");
        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 4637
  netif_tx_start_all_queues(adapter->netdev);
#line 4640
  iter = & (adapter->netdev)->all_adj_list.upper;
#line 4640
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  }
#line 4640
  goto ldv_54725;
  ldv_54724: 
  {
#line 4641
  tmp___2 = netif_is_macvlan(upper);
  }
#line 4641
  if ((int )tmp___2) {
    {
#line 4642
    tmp___1 = netdev_priv((struct net_device  const  *)upper);
#line 4642
    vlan = (struct macvlan_dev *)tmp___1;
    }
#line 4644
    if ((unsigned long )vlan->fwd_priv != (unsigned long )((void *)0)) {
      {
#line 4645
      netif_tx_start_all_queues(upper);
      }
    } else {

    }
  } else {

  }
  {
#line 4640
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  }
  ldv_54725: ;
#line 4640
  if ((unsigned long )upper != (unsigned long )((struct net_device *)0)) {
#line 4642
    goto ldv_54724;
  } else {

  }
  {
#line 4651
  adapter->flags = adapter->flags | 65536U;
#line 4652
  adapter->link_check_timeout = jiffies;
#line 4653
  ldv_mod_timer_17(& adapter->service_timer, jiffies);
#line 4656
  ctrl_ext = ixgbe_read_reg(hw, 24U);
#line 4657
  ctrl_ext = ctrl_ext | 16384U;
#line 4658
  ixgbe_write_reg(hw, 24U, ctrl_ext);
  }
#line 4659
  return;
}
}
#line 4661 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_reinit_locked(struct ixgbe_adapter *adapter ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4663
  tmp = preempt_count();
#line 4663
  __ret_warn_on = ((unsigned long )tmp & 2096896UL) != 0UL;
#line 4663
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 4663
  if (tmp___0 != 0L) {
    {
#line 4663
    warn_slowpath_null("drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", 4663);
    }
  } else {

  }
  {
#line 4663
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 4665
  (adapter->netdev)->trans_start = jiffies;
  }
#line 4667
  goto ldv_54733;
  ldv_54732: 
  {
#line 4668
  usleep_range(1000UL, 2000UL);
  }
  ldv_54733: 
  {
#line 4667
  tmp___1 = test_and_set_bit(1L, (unsigned long volatile   *)(& adapter->state));
  }
#line 4667
  if (tmp___1 != 0) {
#line 4669
    goto ldv_54732;
  } else {

  }
  {
#line 4669
  ixgbe_down(adapter);
  }
#line 4676
  if ((adapter->flags & 8388608U) != 0U) {
    {
#line 4677
    msleep(2000U);
    }
  } else {

  }
  {
#line 4678
  ixgbe_up(adapter);
#line 4679
  clear_bit(1L, (unsigned long volatile   *)(& adapter->state));
  }
#line 4680
  return;
}
}
#line 4682 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_up(struct ixgbe_adapter *adapter ) 
{ 


  {
  {
#line 4685
  ixgbe_configure(adapter);
#line 4687
  ixgbe_up_complete(adapter);
  }
#line 4688
  return;
}
}
#line 4690 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_reset(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int err ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4692
  hw = & adapter->hw;
#line 4695
  tmp = ixgbe_removed((void *)hw->hw_addr);
  }
#line 4695
  if ((int )tmp) {
#line 4696
    return;
  } else {

  }
#line 4698
  goto ldv_54744;
  ldv_54743: 
  {
#line 4699
  usleep_range(1000UL, 2000UL);
  }
  ldv_54744: 
  {
#line 4698
  tmp___0 = test_and_set_bit(5L, (unsigned long volatile   *)(& adapter->state));
  }
#line 4698
  if (tmp___0 != 0) {
#line 4700
    goto ldv_54743;
  } else {

  }
  {
#line 4702
  adapter->flags2 = adapter->flags2 & 4294967247U;
#line 4704
  adapter->flags = adapter->flags & 4294836223U;
#line 4706
  err = (*(hw->mac.ops.init_hw))(hw);
  }
  {
#line 4708
  if (err == 0) {
#line 4708
    goto case_0;
  } else {

  }
#line 4709
  if (err == -20) {
#line 4709
    goto case_neg_20;
  } else {

  }
#line 4710
  if (err == -19) {
#line 4710
    goto case_neg_19;
  } else {

  }
#line 4712
  if (err == -12) {
#line 4712
    goto case_neg_12;
  } else {

  }
#line 4715
  if (err == -24) {
#line 4715
    goto case_neg_24;
  } else {

  }
#line 4724
  goto switch_default;
  case_0: /* CIL Label */ ;
  case_neg_20: /* CIL Label */ ;
  case_neg_19: /* CIL Label */ ;
#line 4711
  goto ldv_54749;
  case_neg_12: /* CIL Label */ 
  {
#line 4713
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "master disable timed out\n");
  }
#line 4714
  goto ldv_54749;
  case_neg_24: /* CIL Label */ 
  {
#line 4717
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "This device is a pre-production adapter/LOM. Please be aware there may be issues associated with your hardware.  If you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\n");
  }
#line 4723
  goto ldv_54749;
  switch_default: /* CIL Label */ 
  {
#line 4725
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Hardware Error: %d\n",
          err);
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_54749: 
  {
#line 4728
  clear_bit(5L, (unsigned long volatile   *)(& adapter->state));
#line 4731
  (*(hw->mac.ops.set_rar))(hw, 0U, (u8 *)(& hw->mac.addr), (u32 )adapter->ring_feature[1].offset,
                           2147483648U);
  }
#line 4734
  if ((unsigned int )hw->mac.san_mac_rar_index != 0U) {
    {
#line 4735
    (*(hw->mac.ops.set_vmdq_san_mac))(hw, (u32 )adapter->ring_feature[1].offset);
    }
  } else {

  }
  {
#line 4737
  tmp___1 = constant_test_bit(6L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 4737
  if (tmp___1 != 0) {
    {
#line 4738
    ixgbe_ptp_reset(adapter);
    }
  } else {

  }
#line 4739
  return;
}
}
#line 4745 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_tx_ring(struct ixgbe_ring *tx_ring ) 
{ 
  struct ixgbe_tx_buffer *tx_buffer_info ;
  unsigned long size ;
  u16 i ;
  struct netdev_queue *tmp ;

  {
#line 4752
  if ((unsigned long )tx_ring->__annonCompField94.tx_buffer_info == (unsigned long )((struct ixgbe_tx_buffer *)0)) {
#line 4753
    return;
  } else {

  }
#line 4756
  i = 0U;
#line 4756
  goto ldv_54760;
  ldv_54759: 
  {
#line 4757
  tx_buffer_info = tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )i;
#line 4758
  ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer_info);
#line 4756
  i = (u16 )((int )i + 1);
  }
  ldv_54760: ;
#line 4756
  if ((int )i < (int )tx_ring->count) {
#line 4758
    goto ldv_54759;
  } else {

  }
  {
#line 4761
  tmp = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 4761
  netdev_tx_reset_queue(tmp);
#line 4763
  size = (unsigned long )tx_ring->count * 48UL;
#line 4764
  memset((void *)tx_ring->__annonCompField94.tx_buffer_info, 0, size);
#line 4767
  memset(tx_ring->desc, 0, (size_t )tx_ring->size);
#line 4769
  tx_ring->next_to_use = 0U;
#line 4770
  tx_ring->next_to_clean = 0U;
  }
#line 4771
  return;
}
}
#line 4777 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_all_rx_rings(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 4781
  i = 0;
#line 4781
  goto ldv_54767;
  ldv_54766: 
  {
#line 4782
  ixgbe_clean_rx_ring(adapter->rx_ring[i]);
#line 4781
  i = i + 1;
  }
  ldv_54767: ;
#line 4781
  if (i < adapter->num_rx_queues) {
#line 4783
    goto ldv_54766;
  } else {

  }

#line 4788
  return;
}
}
#line 4789 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_clean_all_tx_rings(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 4793
  i = 0;
#line 4793
  goto ldv_54774;
  ldv_54773: 
  {
#line 4794
  ixgbe_clean_tx_ring(adapter->tx_ring[i]);
#line 4793
  i = i + 1;
  }
  ldv_54774: ;
#line 4793
  if (i < adapter->num_tx_queues) {
#line 4795
    goto ldv_54773;
  } else {

  }

#line 4800
  return;
}
}
#line 4797 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_filter_exit(struct ixgbe_adapter *adapter ) 
{ 
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *filter ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___0 ;

  {
  {
#line 4802
  spin_lock(& adapter->fdir_perfect_lock);
#line 4804
  ____ptr = adapter->fdir_filter_list.first;
  }
#line 4804
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 4804
    __mptr = (struct hlist_node  const  *)____ptr;
#line 4804
    tmp = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 4804
    tmp = (struct ixgbe_fdir_filter *)0;
  }
#line 4804
  filter = tmp;
#line 4804
  goto ldv_54791;
  ldv_54790: 
  {
#line 4806
  hlist_del(& filter->fdir_node);
#line 4807
  kfree((void const   *)filter);
#line 4804
  ____ptr___0 = node2;
  }
#line 4804
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 4804
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 4804
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 4804
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 4804
  filter = tmp___0;
  ldv_54791: ;
#line 4804
  if ((unsigned long )filter != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 4804
    node2 = filter->fdir_node.next;
#line 4806
    goto ldv_54790;
  } else {

  }
  {
#line 4809
  adapter->fdir_filter_count = 0;
#line 4811
  spin_unlock(& adapter->fdir_perfect_lock);
  }
#line 4812
  return;
}
}
#line 4814 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_down(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  struct net_device *upper ;
  struct list_head *iter ;
  u32 rxctrl ;
  int i ;
  int tmp ;
  struct macvlan_dev *vlan ;
  void *tmp___0 ;
  bool tmp___1 ;
  u8 reg_idx ;
  u32 tmp___2 ;
  int tmp___3 ;

  {
  {
#line 4816
  netdev = adapter->netdev;
#line 4817
  hw = & adapter->hw;
#line 4824
  tmp = test_and_set_bit(2L, (unsigned long volatile   *)(& adapter->state));
  }
#line 4824
  if (tmp != 0) {
#line 4825
    return;
  } else {

  }
  {
#line 4828
  rxctrl = ixgbe_read_reg(hw, 12288U);
#line 4829
  ixgbe_write_reg(hw, 12288U, rxctrl & 4294967294U);
#line 4832
  i = 0;
  }
#line 4832
  goto ldv_54803;
  ldv_54802: 
  {
#line 4834
  ixgbe_disable_rx_queue(adapter, adapter->rx_ring[i]);
#line 4832
  i = i + 1;
  }
  ldv_54803: ;
#line 4832
  if (i < adapter->num_rx_queues) {
#line 4834
    goto ldv_54802;
  } else {

  }
  {
#line 4836
  usleep_range(10000UL, 20000UL);
#line 4838
  netif_tx_stop_all_queues(netdev);
#line 4841
  netif_carrier_off(netdev);
#line 4842
  netif_tx_disable(netdev);
#line 4845
  iter = & (adapter->netdev)->all_adj_list.upper;
#line 4845
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  }
#line 4845
  goto ldv_54807;
  ldv_54806: 
  {
#line 4846
  tmp___1 = netif_is_macvlan(upper);
  }
#line 4846
  if ((int )tmp___1) {
    {
#line 4847
    tmp___0 = netdev_priv((struct net_device  const  *)upper);
#line 4847
    vlan = (struct macvlan_dev *)tmp___0;
    }
#line 4849
    if ((unsigned long )vlan->fwd_priv != (unsigned long )((void *)0)) {
      {
#line 4850
      netif_tx_stop_all_queues(upper);
#line 4851
      netif_carrier_off(upper);
#line 4852
      netif_tx_disable(upper);
      }
    } else {

    }
  } else {

  }
  {
#line 4845
  upper = netdev_all_upper_get_next_dev_rcu(adapter->netdev, & iter);
  }
  ldv_54807: ;
#line 4845
  if ((unsigned long )upper != (unsigned long )((struct net_device *)0)) {
#line 4847
    goto ldv_54806;
  } else {

  }
  {
#line 4857
  ixgbe_irq_disable(adapter);
#line 4859
  ixgbe_napi_disable_all(adapter);
#line 4861
  adapter->flags2 = adapter->flags2 & 4294967103U;
#line 4863
  adapter->flags = adapter->flags & 4294901759U;
#line 4865
  ldv_del_timer_sync_18(& adapter->service_timer);
  }
#line 4867
  if (adapter->num_vfs != 0U) {
    {
#line 4869
    ixgbe_write_reg(& adapter->hw, 2196U, 0U);
#line 4872
    i = 0;
    }
#line 4872
    goto ldv_54810;
    ldv_54809: 
#line 4873
    (adapter->vfinfo + (unsigned long )i)->clear_to_send = 0;
#line 4872
    i = i + 1;
    ldv_54810: ;
#line 4872
    if ((unsigned int )i < adapter->num_vfs) {
#line 4874
      goto ldv_54809;
    } else {

    }
    {
#line 4876
    ixgbe_ping_all_vfs(adapter);
#line 4879
    ixgbe_disable_tx_rx(adapter);
    }
  } else {

  }
#line 4883
  i = 0;
#line 4883
  goto ldv_54814;
  ldv_54813: 
  {
#line 4884
  reg_idx = (adapter->tx_ring[i])->reg_idx;
#line 4885
  ixgbe_write_reg(hw, (u32 )((int )reg_idx * 64 + 24616), 67108864U);
#line 4883
  i = i + 1;
  }
  ldv_54814: ;
#line 4883
  if (i < adapter->num_tx_queues) {
#line 4885
    goto ldv_54813;
  } else {

  }

  {
#line 4890
  if ((unsigned int )hw->mac.type == 2U) {
#line 4890
    goto case_2;
  } else {

  }
#line 4891
  if ((unsigned int )hw->mac.type == 3U) {
#line 4891
    goto case_3;
  } else {

  }
#line 4896
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 4892
  tmp___2 = ixgbe_read_reg(hw, 19072U);
#line 4892
  ixgbe_write_reg(hw, 19072U, tmp___2 & 4294967294U);
  }
#line 4895
  goto ldv_54818;
  switch_default: /* CIL Label */ ;
#line 4897
  goto ldv_54818;
  switch_break: /* CIL Label */ ;
  }
  ldv_54818: 
  {
#line 4900
  tmp___3 = pci_channel_offline(adapter->pdev);
  }
#line 4900
  if (tmp___3 == 0) {
    {
#line 4901
    ixgbe_reset(adapter);
    }
  } else {

  }
#line 4904
  if ((unsigned long )hw->mac.ops.disable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
    {
#line 4905
    (*(hw->mac.ops.disable_tx_laser))(hw);
    }
  } else {

  }
  {
#line 4907
  ixgbe_clean_all_tx_rings(adapter);
#line 4908
  ixgbe_clean_all_rx_rings(adapter);
#line 4912
  ixgbe_setup_dca(adapter);
  }
#line 4913
  return;
}
}
#line 4920 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_timeout(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 4922
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4922
  adapter = (struct ixgbe_adapter *)tmp;
#line 4925
  ixgbe_tx_timeout_reset(adapter);
  }
#line 4926
  return;
}
}
#line 4936 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_sw_init(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct pci_dev *pdev ;
  unsigned int rss ;
  unsigned int fdir ;
  u32 fwsm ;
  int j ;
  struct tc_configuration *tc ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp ;
  int __min1___0 ;
  int __min2___0 ;
  unsigned int tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  s32 tmp___1 ;

  {
  {
#line 4938
  hw = & adapter->hw;
#line 4939
  pdev = adapter->pdev;
#line 4949
  hw->vendor_id = pdev->vendor;
#line 4950
  hw->device_id = pdev->device;
#line 4951
  hw->revision_id = pdev->revision;
#line 4952
  hw->subsystem_vendor_id = pdev->subsystem_vendor;
#line 4953
  hw->subsystem_device_id = pdev->subsystem_device;
#line 4956
  __min1 = 16;
#line 4956
  tmp = cpumask_weight(cpu_online_mask);
#line 4956
  __min2 = (int )tmp;
#line 4956
  rss = (unsigned int )(__min1 < __min2 ? __min1 : __min2);
#line 4957
  adapter->ring_feature[2].limit = (u16 )rss;
#line 4958
  adapter->flags2 = adapter->flags2 | 1U;
#line 4959
  adapter->flags2 = adapter->flags2 | 2U;
#line 4960
  adapter->max_q_vectors = 64;
#line 4961
  adapter->atr_sample_rate = 20U;
#line 4962
  __min1___0 = 63;
#line 4962
  tmp___0 = cpumask_weight(cpu_online_mask);
#line 4962
  __min2___0 = (int )tmp___0;
#line 4962
  fdir = (unsigned int )(__min1___0 < __min2___0 ? __min1___0 : __min2___0);
#line 4963
  adapter->ring_feature[3].limit = (u16 )fdir;
#line 4964
  adapter->fdir_pballoc = 1U;
#line 4966
  adapter->flags = adapter->flags | 512U;
#line 4969
  adapter->flags = adapter->flags | 1048576U;
#line 4970
  adapter->flags = adapter->flags & 4292870143U;
#line 4973
  adapter->fcoe.up = 3U;
  }
  {
#line 4979
  if ((unsigned int )hw->mac.type == 1U) {
#line 4979
    goto case_1;
  } else {

  }
#line 4998
  if ((unsigned int )hw->mac.type == 2U) {
#line 4998
    goto case_2;
  } else {

  }
#line 5002
  if ((unsigned int )hw->mac.type == 3U) {
#line 5002
    goto case_3;
  } else {

  }
#line 5007
  goto switch_default;
  case_1: /* CIL Label */ 
#line 4980
  adapter->flags2 = adapter->flags2 & 4294967294U;
#line 4981
  adapter->flags2 = adapter->flags2 & 4294967293U;
#line 4983
  if ((unsigned int )hw->device_id == 4296U) {
#line 4984
    adapter->flags = adapter->flags | 32768U;
  } else {

  }
#line 4986
  adapter->max_q_vectors = 16;
#line 4987
  adapter->ring_feature[3].limit = 0U;
#line 4988
  adapter->atr_sample_rate = 0U;
#line 4989
  adapter->fdir_pballoc = 0U;
#line 4991
  adapter->flags = adapter->flags & 4293918719U;
#line 4992
  adapter->flags = adapter->flags & 4292870143U;
#line 4994
  adapter->fcoe.up = 0U;
#line 4997
  goto ldv_54841;
  case_2: /* CIL Label */ ;
#line 4999
  if ((unsigned int )hw->device_id == 5404U) {
#line 5000
    adapter->flags2 = adapter->flags2 | 4U;
  } else {

  }
#line 5001
  goto ldv_54841;
  case_3: /* CIL Label */ 
  {
#line 5003
  fwsm = ixgbe_read_reg(hw, 65864U);
  }
#line 5004
  if ((int )fwsm & 1) {
#line 5005
    adapter->flags2 = adapter->flags2 | 4U;
  } else {

  }
#line 5006
  goto ldv_54841;
  switch_default: /* CIL Label */ ;
#line 5008
  goto ldv_54841;
  switch_break: /* CIL Label */ ;
  }
  ldv_54841: 
  {
#line 5013
  spinlock_check(& adapter->fcoe.lock);
#line 5013
  __raw_spin_lock_init(& adapter->fcoe.lock.__annonCompField19.rlock, "&(&adapter->fcoe.lock)->rlock",
                       & __key);
#line 5017
  spinlock_check(& adapter->fdir_perfect_lock);
#line 5017
  __raw_spin_lock_init(& adapter->fdir_perfect_lock.__annonCompField19.rlock, "&(&adapter->fdir_perfect_lock)->rlock",
                       & __key___0);
  }
  {
#line 5021
  if ((unsigned int )hw->mac.type == 3U) {
#line 5021
    goto case_3___0;
  } else {

  }
#line 5025
  goto switch_default___0;
  case_3___0: /* CIL Label */ 
#line 5022
  adapter->dcb_cfg.num_tcs.pg_tcs = 4U;
#line 5023
  adapter->dcb_cfg.num_tcs.pfc_tcs = 4U;
#line 5024
  goto ldv_54848;
  switch_default___0: /* CIL Label */ 
#line 5026
  adapter->dcb_cfg.num_tcs.pg_tcs = 8U;
#line 5027
  adapter->dcb_cfg.num_tcs.pfc_tcs = 8U;
#line 5028
  goto ldv_54848;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_54848: 
#line 5032
  j = 0;
#line 5032
  goto ldv_54851;
  ldv_54850: 
#line 5033
  tc = (struct tc_configuration *)(& adapter->dcb_cfg.tc_config) + (unsigned long )j;
#line 5034
  tc->path[0].bwg_id = 0U;
#line 5035
  tc->path[0].bwg_percent = ((unsigned int )((u8 )j) & 1U) + 12U;
#line 5036
  tc->path[1].bwg_id = 0U;
#line 5037
  tc->path[1].bwg_percent = ((unsigned int )((u8 )j) & 1U) + 12U;
#line 5038
  tc->dcb_pfc = 0;
#line 5032
  j = j + 1;
  ldv_54851: ;
#line 5032
  if (j <= 7) {
#line 5034
    goto ldv_54850;
  } else {

  }
  {
#line 5042
  tc = (struct tc_configuration *)(& adapter->dcb_cfg.tc_config);
#line 5043
  tc->path[0].up_to_tc_bitmap = 255U;
#line 5044
  tc->path[1].up_to_tc_bitmap = 255U;
#line 5046
  adapter->dcb_cfg.bw_percentage[0][0] = 100U;
#line 5047
  adapter->dcb_cfg.bw_percentage[1][0] = 100U;
#line 5048
  adapter->dcb_cfg.pfc_mode_enable = 0;
#line 5049
  adapter->dcb_set_bitmap = 0U;
#line 5050
  adapter->dcbx_cap = 5U;
#line 5051
  memcpy((void *)(& adapter->temp_dcb_cfg), (void const   *)(& adapter->dcb_cfg),
         296UL);
#line 5057
  hw->fc.requested_mode = 3;
#line 5058
  hw->fc.current_mode = 3;
#line 5059
  ixgbe_pbthresh_setup(adapter);
#line 5060
  hw->fc.pause_time = 65535U;
#line 5061
  hw->fc.send_xon = 1;
#line 5062
  hw->fc.disable_fc_autoneg = ixgbe_device_supports_autoneg_fc(hw);
  }
#line 5065
  if (max_vfs != 0U) {
    {
#line 5066
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Enabling SR-IOV VFs using the max_vfs module parameter is deprecated - please use the pci sysfs interface instead.\n");
    }
  } else {

  }
#line 5069
  if ((unsigned int )hw->mac.type != 1U) {
#line 5070
    if (max_vfs > 63U) {
      {
#line 5071
      adapter->num_vfs = 0U;
#line 5072
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "max_vfs parameter out of range. Not assigning any SR-IOV VFs\n");
      }
    } else {
#line 5074
      adapter->num_vfs = max_vfs;
    }
  } else {

  }
  {
#line 5080
  adapter->rx_itr_setting = 1U;
#line 5081
  adapter->tx_itr_setting = 1U;
#line 5084
  adapter->tx_ring_count = 512U;
#line 5085
  adapter->rx_ring_count = 512U;
#line 5088
  adapter->tx_work_limit = 256U;
#line 5091
  tmp___1 = ixgbe_init_eeprom_params_generic(hw);
  }
#line 5091
  if (tmp___1 != 0) {
    {
#line 5092
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEPROM initialization failed\n");
    }
#line 5093
    return (-5);
  } else {

  }
  {
#line 5097
  set_bit(0L, (unsigned long volatile   *)(& adapter->fwd_bitmask));
#line 5098
  set_bit(2L, (unsigned long volatile   *)(& adapter->state));
  }
#line 5100
  return (0);
}
}
#line 5109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring ) 
{ 
  struct device *dev ;
  int orig_node ;
  int tmp ;
  int numa_node___0 ;
  int size ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 5111
  dev = tx_ring->dev;
#line 5112
  tmp = dev_to_node(dev);
#line 5112
  orig_node = tmp;
#line 5113
  numa_node___0 = -1;
#line 5116
  size = (int )((unsigned int )tx_ring->count * 48U);
  }
#line 5118
  if ((unsigned long )tx_ring->q_vector != (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 5119
    numa_node___0 = (tx_ring->q_vector)->numa_node;
  } else {

  }
  {
#line 5121
  tmp___0 = vzalloc_node((unsigned long )size, numa_node___0);
#line 5121
  tx_ring->__annonCompField94.tx_buffer_info = (struct ixgbe_tx_buffer *)tmp___0;
  }
#line 5122
  if ((unsigned long )tx_ring->__annonCompField94.tx_buffer_info == (unsigned long )((struct ixgbe_tx_buffer *)0)) {
    {
#line 5123
    tmp___1 = vzalloc((unsigned long )size);
#line 5123
    tx_ring->__annonCompField94.tx_buffer_info = (struct ixgbe_tx_buffer *)tmp___1;
    }
  } else {

  }
#line 5124
  if ((unsigned long )tx_ring->__annonCompField94.tx_buffer_info == (unsigned long )((struct ixgbe_tx_buffer *)0)) {
#line 5125
    goto err;
  } else {

  }
  {
#line 5130
  tx_ring->size = (unsigned int )tx_ring->count * 16U;
#line 5131
  tx_ring->size = (tx_ring->size + 4095U) & 4294963200U;
#line 5133
  set_dev_node(dev, numa_node___0);
#line 5134
  tx_ring->desc = dma_alloc_attrs(dev, (size_t )tx_ring->size, & tx_ring->dma, 208U,
                                  (struct dma_attrs *)0);
#line 5138
  set_dev_node(dev, orig_node);
  }
#line 5139
  if ((unsigned long )tx_ring->desc == (unsigned long )((void *)0)) {
    {
#line 5140
    tx_ring->desc = dma_alloc_attrs(dev, (size_t )tx_ring->size, & tx_ring->dma, 208U,
                                    (struct dma_attrs *)0);
    }
  } else {

  }
#line 5142
  if ((unsigned long )tx_ring->desc == (unsigned long )((void *)0)) {
#line 5143
    goto err;
  } else {

  }
#line 5145
  tx_ring->next_to_use = 0U;
#line 5146
  tx_ring->next_to_clean = 0U;
#line 5147
  return (0);
  err: 
  {
#line 5150
  vfree((void const   *)tx_ring->__annonCompField94.tx_buffer_info);
#line 5151
  tx_ring->__annonCompField94.tx_buffer_info = (struct ixgbe_tx_buffer *)0;
#line 5152
  dev_err((struct device  const  *)dev, "Unable to allocate memory for the Tx descriptor ring\n");
  }
#line 5153
  return (-12);
}
}
#line 5166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_all_tx_resources(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  int err ;
  int tmp ;

  {
#line 5168
  err = 0;
#line 5170
  i = 0;
#line 5170
  goto ldv_54869;
  ldv_54868: 
  {
#line 5171
  err = ixgbe_setup_tx_resources(adapter->tx_ring[i]);
  }
#line 5172
  if (err == 0) {
#line 5173
    goto ldv_54866;
  } else {

  }
#line 5175
  if (((int )adapter->msg_enable & 2) != 0) {
    {
#line 5175
    netdev_err((struct net_device  const  *)adapter->netdev, "Allocation for Tx Queue %u failed\n",
               i);
    }
  } else {

  }
#line 5176
  goto err_setup_tx;
  ldv_54866: 
#line 5170
  i = i + 1;
  ldv_54869: ;
#line 5170
  if (i < adapter->num_tx_queues) {
#line 5172
    goto ldv_54868;
  } else {

  }

#line 5179
  return (0);
  err_setup_tx: ;
#line 5182
  goto ldv_54872;
  ldv_54871: 
  {
#line 5183
  ixgbe_free_tx_resources(adapter->tx_ring[i]);
  }
  ldv_54872: 
#line 5182
  tmp = i;
#line 5182
  i = i - 1;
#line 5182
  if (tmp != 0) {
#line 5184
    goto ldv_54871;
  } else {

  }

#line 5184
  return (err);
}
}
#line 5193 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_rx_resources(struct ixgbe_ring *rx_ring ) 
{ 
  struct device *dev ;
  int orig_node ;
  int tmp ;
  int numa_node___0 ;
  int size ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 5195
  dev = rx_ring->dev;
#line 5196
  tmp = dev_to_node(dev);
#line 5196
  orig_node = tmp;
#line 5197
  numa_node___0 = -1;
#line 5200
  size = (int )((unsigned int )rx_ring->count * 32U);
  }
#line 5202
  if ((unsigned long )rx_ring->q_vector != (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 5203
    numa_node___0 = (rx_ring->q_vector)->numa_node;
  } else {

  }
  {
#line 5205
  tmp___0 = vzalloc_node((unsigned long )size, numa_node___0);
#line 5205
  rx_ring->__annonCompField94.rx_buffer_info = (struct ixgbe_rx_buffer *)tmp___0;
  }
#line 5206
  if ((unsigned long )rx_ring->__annonCompField94.rx_buffer_info == (unsigned long )((struct ixgbe_rx_buffer *)0)) {
    {
#line 5207
    tmp___1 = vzalloc((unsigned long )size);
#line 5207
    rx_ring->__annonCompField94.rx_buffer_info = (struct ixgbe_rx_buffer *)tmp___1;
    }
  } else {

  }
#line 5208
  if ((unsigned long )rx_ring->__annonCompField94.rx_buffer_info == (unsigned long )((struct ixgbe_rx_buffer *)0)) {
#line 5209
    goto err;
  } else {

  }
  {
#line 5214
  rx_ring->size = (unsigned int )rx_ring->count * 16U;
#line 5215
  rx_ring->size = (rx_ring->size + 4095U) & 4294963200U;
#line 5217
  set_dev_node(dev, numa_node___0);
#line 5218
  rx_ring->desc = dma_alloc_attrs(dev, (size_t )rx_ring->size, & rx_ring->dma, 208U,
                                  (struct dma_attrs *)0);
#line 5222
  set_dev_node(dev, orig_node);
  }
#line 5223
  if ((unsigned long )rx_ring->desc == (unsigned long )((void *)0)) {
    {
#line 5224
    rx_ring->desc = dma_alloc_attrs(dev, (size_t )rx_ring->size, & rx_ring->dma, 208U,
                                    (struct dma_attrs *)0);
    }
  } else {

  }
#line 5226
  if ((unsigned long )rx_ring->desc == (unsigned long )((void *)0)) {
#line 5227
    goto err;
  } else {

  }
#line 5229
  rx_ring->next_to_clean = 0U;
#line 5230
  rx_ring->next_to_use = 0U;
#line 5232
  return (0);
  err: 
  {
#line 5234
  vfree((void const   *)rx_ring->__annonCompField94.rx_buffer_info);
#line 5235
  rx_ring->__annonCompField94.rx_buffer_info = (struct ixgbe_rx_buffer *)0;
#line 5236
  dev_err((struct device  const  *)dev, "Unable to allocate memory for the Rx descriptor ring\n");
  }
#line 5237
  return (-12);
}
}
#line 5250 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_setup_all_rx_resources(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  int err ;
  int tmp ;

  {
#line 5252
  err = 0;
#line 5254
  i = 0;
#line 5254
  goto ldv_54890;
  ldv_54889: 
  {
#line 5255
  err = ixgbe_setup_rx_resources(adapter->rx_ring[i]);
  }
#line 5256
  if (err == 0) {
#line 5257
    goto ldv_54887;
  } else {

  }
#line 5259
  if (((int )adapter->msg_enable & 2) != 0) {
    {
#line 5259
    netdev_err((struct net_device  const  *)adapter->netdev, "Allocation for Rx Queue %u failed\n",
               i);
    }
  } else {

  }
#line 5260
  goto err_setup_rx;
  ldv_54887: 
#line 5254
  i = i + 1;
  ldv_54890: ;
#line 5254
  if (i < adapter->num_rx_queues) {
#line 5256
    goto ldv_54889;
  } else {

  }
  {
#line 5264
  err = ixgbe_setup_fcoe_ddp_resources(adapter);
  }
#line 5265
  if (err == 0) {
#line 5267
    return (0);
  } else {

  }
  err_setup_rx: ;
#line 5270
  goto ldv_54893;
  ldv_54892: 
  {
#line 5271
  ixgbe_free_rx_resources(adapter->rx_ring[i]);
  }
  ldv_54893: 
#line 5270
  tmp = i;
#line 5270
  i = i - 1;
#line 5270
  if (tmp != 0) {
#line 5272
    goto ldv_54892;
  } else {

  }

#line 5272
  return (err);
}
}
#line 5281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_free_tx_resources(struct ixgbe_ring *tx_ring ) 
{ 


  {
  {
#line 5283
  ixgbe_clean_tx_ring(tx_ring);
#line 5285
  vfree((void const   *)tx_ring->__annonCompField94.tx_buffer_info);
#line 5286
  tx_ring->__annonCompField94.tx_buffer_info = (struct ixgbe_tx_buffer *)0;
  }
#line 5289
  if ((unsigned long )tx_ring->desc == (unsigned long )((void *)0)) {
#line 5290
    return;
  } else {

  }
  {
#line 5292
  dma_free_attrs(tx_ring->dev, (size_t )tx_ring->size, tx_ring->desc, tx_ring->dma,
                 (struct dma_attrs *)0);
#line 5295
  tx_ring->desc = (void *)0;
  }
#line 5296
  return;
}
}
#line 5304 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_all_tx_resources(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 5308
  i = 0;
#line 5308
  goto ldv_54903;
  ldv_54902: ;
#line 5309
  if ((unsigned long )(adapter->tx_ring[i])->desc != (unsigned long )((void *)0)) {
    {
#line 5310
    ixgbe_free_tx_resources(adapter->tx_ring[i]);
    }
  } else {

  }
#line 5308
  i = i + 1;
  ldv_54903: ;
#line 5308
  if (i < adapter->num_tx_queues) {
#line 5310
    goto ldv_54902;
  } else {

  }

#line 5315
  return;
}
}
#line 5319 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_free_rx_resources(struct ixgbe_ring *rx_ring ) 
{ 


  {
  {
#line 5321
  ixgbe_clean_rx_ring(rx_ring);
#line 5323
  vfree((void const   *)rx_ring->__annonCompField94.rx_buffer_info);
#line 5324
  rx_ring->__annonCompField94.rx_buffer_info = (struct ixgbe_rx_buffer *)0;
  }
#line 5327
  if ((unsigned long )rx_ring->desc == (unsigned long )((void *)0)) {
#line 5328
    return;
  } else {

  }
  {
#line 5330
  dma_free_attrs(rx_ring->dev, (size_t )rx_ring->size, rx_ring->desc, rx_ring->dma,
                 (struct dma_attrs *)0);
#line 5333
  rx_ring->desc = (void *)0;
  }
#line 5334
  return;
}
}
#line 5342 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_free_all_rx_resources(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
  {
#line 5347
  ixgbe_free_fcoe_ddp_resources(adapter);
#line 5350
  i = 0;
  }
#line 5350
  goto ldv_54913;
  ldv_54912: ;
#line 5351
  if ((unsigned long )(adapter->rx_ring[i])->desc != (unsigned long )((void *)0)) {
    {
#line 5352
    ixgbe_free_rx_resources(adapter->rx_ring[i]);
    }
  } else {

  }
#line 5350
  i = i + 1;
  ldv_54913: ;
#line 5350
  if (i < adapter->num_rx_queues) {
#line 5352
    goto ldv_54912;
  } else {

  }

#line 5357
  return;
}
}
#line 5362 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_change_mtu(struct net_device *netdev , int new_mtu ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int max_frame ;
  bool tmp___0 ;

  {
  {
#line 5364
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5364
  adapter = (struct ixgbe_adapter *)tmp;
#line 5365
  max_frame = new_mtu + 18;
  }
#line 5368
  if (new_mtu <= 67 || max_frame > 9728) {
#line 5369
    return (-22);
  } else {

  }
#line 5376
  if ((adapter->flags & 8388608U) != 0U && ((unsigned int )adapter->hw.mac.type == 2U && max_frame > 1518)) {
#line 5379
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 5379
      netdev_warn((struct net_device  const  *)adapter->netdev, "Setting MTU > 1500 will disable legacy VFs\n");
      }
    } else {

    }
  } else {

  }
#line 5381
  if (((int )adapter->msg_enable & 2) != 0) {
    {
#line 5381
    netdev_info((struct net_device  const  *)adapter->netdev, "changing MTU from %d to %d\n",
                netdev->mtu, new_mtu);
    }
  } else {

  }
  {
#line 5384
  netdev->mtu = (unsigned int )new_mtu;
#line 5386
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 5386
  if ((int )tmp___0) {
    {
#line 5387
    ixgbe_reinit_locked(adapter);
    }
  } else {

  }
#line 5389
  return (0);
}
}
#line 5404 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_open(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  int queues ;
  int tmp___0 ;

  {
  {
#line 5406
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5406
  adapter = (struct ixgbe_adapter *)tmp;
#line 5410
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 5410
  if (tmp___0 != 0) {
#line 5411
    return (-16);
  } else {

  }
  {
#line 5413
  netif_carrier_off(netdev);
#line 5416
  err = ixgbe_setup_all_tx_resources(adapter);
  }
#line 5417
  if (err != 0) {
#line 5418
    goto err_setup_tx;
  } else {

  }
  {
#line 5421
  err = ixgbe_setup_all_rx_resources(adapter);
  }
#line 5422
  if (err != 0) {
#line 5423
    goto err_setup_rx;
  } else {

  }
  {
#line 5425
  ixgbe_configure(adapter);
#line 5427
  err = ixgbe_request_irq(adapter);
  }
#line 5428
  if (err != 0) {
#line 5429
    goto err_req_irq;
  } else {

  }
#line 5432
  if (adapter->num_rx_pools > 1) {
#line 5433
    queues = adapter->num_rx_queues_per_pool;
  } else {
#line 5435
    queues = adapter->num_tx_queues;
  }
  {
#line 5437
  err = netif_set_real_num_tx_queues(netdev, (unsigned int )queues);
  }
#line 5438
  if (err != 0) {
#line 5439
    goto err_set_queues;
  } else {

  }
#line 5441
  if (adapter->num_rx_pools > 1 && adapter->num_rx_queues > 4) {
#line 5443
    queues = 4;
  } else {
#line 5445
    queues = adapter->num_rx_queues;
  }
  {
#line 5446
  err = netif_set_real_num_rx_queues(netdev, (unsigned int )queues);
  }
#line 5447
  if (err != 0) {
#line 5448
    goto err_set_queues;
  } else {

  }
  {
#line 5450
  ixgbe_ptp_init(adapter);
#line 5452
  ixgbe_up_complete(adapter);
  }
#line 5454
  return (0);
  err_set_queues: 
  {
#line 5457
  ixgbe_free_irq(adapter);
  }
  err_req_irq: 
  {
#line 5459
  ixgbe_free_all_rx_resources(adapter);
  }
  err_setup_rx: 
  {
#line 5461
  ixgbe_free_all_tx_resources(adapter);
  }
  err_setup_tx: 
  {
#line 5463
  ixgbe_reset(adapter);
  }
#line 5465
  return (err);
}
}
#line 5479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_close(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 5481
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 5481
  adapter = (struct ixgbe_adapter *)tmp;
#line 5483
  ixgbe_ptp_stop(adapter);
#line 5485
  ixgbe_down(adapter);
#line 5486
  ixgbe_free_irq(adapter);
#line 5488
  ixgbe_fdir_filter_exit(adapter);
#line 5490
  ixgbe_free_all_tx_resources(adapter);
#line 5491
  ixgbe_free_all_rx_resources(adapter);
#line 5493
  ixgbe_release_hw_control(adapter);
  }
#line 5495
  return (0);
}
}
#line 5499 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_resume(struct pci_dev *pdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  u32 err ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 5501
  tmp = pci_get_drvdata(pdev);
#line 5501
  adapter = (struct ixgbe_adapter *)tmp;
#line 5502
  netdev = adapter->netdev;
#line 5505
  pci_set_power_state(pdev, 0);
#line 5506
  pci_restore_state(pdev);
#line 5511
  pci_save_state(pdev);
#line 5513
  tmp___0 = pci_enable_device_mem(pdev);
#line 5513
  err = (u32 )tmp___0;
  }
#line 5514
  if (err != 0U) {
    {
#line 5515
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Cannot enable PCI device from suspend\n");
    }
#line 5516
    return ((int )err);
  } else {

  }
  {
#line 5518
  pci_set_master(pdev);
#line 5520
  pci_wake_from_d3(pdev, 0);
#line 5522
  ixgbe_reset(adapter);
#line 5524
  ixgbe_write_reg(& adapter->hw, 22544U, 4294967295U);
#line 5526
  rtnl_lock();
#line 5527
  tmp___1 = ixgbe_init_interrupt_scheme(adapter);
#line 5527
  err = (u32 )tmp___1;
  }
#line 5528
  if (err == 0U) {
    {
#line 5528
    tmp___3 = netif_running((struct net_device  const  *)netdev);
    }
#line 5528
    if ((int )tmp___3) {
      {
#line 5529
      tmp___2 = ixgbe_open(netdev);
#line 5529
      err = (u32 )tmp___2;
      }
    } else {

    }
  } else {

  }
  {
#line 5531
  rtnl_unlock();
  }
#line 5533
  if (err != 0U) {
#line 5534
    return ((int )err);
  } else {

  }
  {
#line 5536
  netif_device_attach(netdev);
  }
#line 5538
  return (0);
}
}
#line 5542 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_shutdown(struct pci_dev *pdev , bool *enable_wake ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  u32 ctrl ;
  u32 fctrl ;
  u32 wufc ;
  int retval ;
  bool tmp___0 ;

  {
  {
#line 5544
  tmp = pci_get_drvdata(pdev);
#line 5544
  adapter = (struct ixgbe_adapter *)tmp;
#line 5545
  netdev = adapter->netdev;
#line 5546
  hw = & adapter->hw;
#line 5548
  wufc = adapter->wol;
#line 5550
  retval = 0;
#line 5553
  netif_device_detach(netdev);
#line 5555
  rtnl_lock();
#line 5556
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 5556
  if ((int )tmp___0) {
    {
#line 5557
    ixgbe_down(adapter);
#line 5558
    ixgbe_free_irq(adapter);
#line 5559
    ixgbe_free_all_tx_resources(adapter);
#line 5560
    ixgbe_free_all_rx_resources(adapter);
    }
  } else {

  }
  {
#line 5562
  rtnl_unlock();
#line 5564
  ixgbe_clear_interrupt_scheme(adapter);
#line 5567
  retval = pci_save_state(pdev);
  }
#line 5568
  if (retval != 0) {
#line 5569
    return (retval);
  } else {

  }
#line 5572
  if ((unsigned long )hw->mac.ops.stop_link_on_d3 != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
    {
#line 5573
    (*(hw->mac.ops.stop_link_on_d3))(hw);
    }
  } else {

  }
#line 5575
  if (wufc != 0U) {
    {
#line 5576
    ixgbe_set_rx_mode(netdev);
    }
#line 5579
    if ((unsigned long )hw->mac.ops.enable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
      {
#line 5580
      (*(hw->mac.ops.enable_tx_laser))(hw);
      }
    } else {

    }
#line 5583
    if ((wufc & 8U) != 0U) {
      {
#line 5584
      fctrl = ixgbe_read_reg(hw, 20608U);
#line 5585
      fctrl = fctrl | 256U;
#line 5586
      ixgbe_write_reg(hw, 20608U, fctrl);
      }
    } else {

    }
    {
#line 5589
    ctrl = ixgbe_read_reg(hw, 0U);
#line 5590
    ctrl = ctrl | 4U;
#line 5591
    ixgbe_write_reg(hw, 0U, ctrl);
#line 5593
    ixgbe_write_reg(hw, 22536U, wufc);
    }
  } else {
    {
#line 5595
    ixgbe_write_reg(hw, 22528U, 0U);
#line 5596
    ixgbe_write_reg(hw, 22536U, 0U);
    }
  }
  {
#line 5600
  if ((unsigned int )hw->mac.type == 1U) {
#line 5600
    goto case_1;
  } else {

  }
#line 5603
  if ((unsigned int )hw->mac.type == 2U) {
#line 5603
    goto case_2;
  } else {

  }
#line 5604
  if ((unsigned int )hw->mac.type == 3U) {
#line 5604
    goto case_3;
  } else {

  }
#line 5607
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 5601
  pci_wake_from_d3(pdev, 0);
  }
#line 5602
  goto ldv_54953;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 5605
  pci_wake_from_d3(pdev, wufc != 0U);
  }
#line 5606
  goto ldv_54953;
  switch_default: /* CIL Label */ ;
#line 5608
  goto ldv_54953;
  switch_break: /* CIL Label */ ;
  }
  ldv_54953: 
  {
#line 5611
  *enable_wake = wufc != 0U;
#line 5613
  ixgbe_release_hw_control(adapter);
#line 5615
  pci_disable_device(pdev);
  }
#line 5617
  return (0);
}
}
#line 5621 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ 
  int retval ;
  bool wake ;

  {
  {
#line 5626
  retval = __ixgbe_shutdown(pdev, & wake);
  }
#line 5627
  if (retval != 0) {
#line 5628
    return (retval);
  } else {

  }
#line 5630
  if ((int )wake) {
    {
#line 5631
    pci_prepare_to_sleep(pdev);
    }
  } else {
    {
#line 5633
    pci_wake_from_d3(pdev, 0);
#line 5634
    pci_set_power_state(pdev, 3);
    }
  }
#line 5637
  return (0);
}
}
#line 5641 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_shutdown(struct pci_dev *pdev ) 
{ 
  bool wake ;

  {
  {
#line 5645
  __ixgbe_shutdown(pdev, & wake);
  }
#line 5647
  if ((unsigned int )system_state == 3U) {
    {
#line 5648
    pci_wake_from_d3(pdev, (int )wake);
#line 5649
    pci_set_power_state(pdev, 3);
    }
  } else {

  }
#line 5651
  return;
}
}
#line 5657 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_update_stats(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  struct ixgbe_hw_stats *hwstats ;
  u64 total_mpc ;
  u32 i ;
  u32 missed_rx ;
  u32 mpc ;
  u32 bprc ;
  u32 lxon ;
  u32 lxoff ;
  u32 xon_off_tot ;
  u64 non_eop_descs ;
  u64 restart_queue ;
  u64 tx_busy ;
  u64 alloc_rx_page_failed ;
  u64 alloc_rx_buff_failed ;
  u64 bytes ;
  u64 packets ;
  u64 hw_csum_rx_error ;
  int tmp ;
  int tmp___0 ;
  u64 rsc_count ;
  u64 rsc_flush ;
  struct ixgbe_ring *rx_ring ;
  struct ixgbe_ring *tx_ring ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;
  u32 tmp___28 ;
  u32 tmp___29 ;
  u32 tmp___30 ;
  u32 tmp___31 ;
  u32 tmp___32 ;
  u32 tmp___33 ;
  u32 tmp___34 ;
  struct ixgbe_fcoe *fcoe ;
  struct ixgbe_fcoe_ddp_pool *ddp_pool ;
  unsigned int cpu ;
  u64 noddp ;
  u64 noddp_ext_buff ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  u32 tmp___35 ;
  u32 tmp___36 ;
  u32 tmp___37 ;
  u32 tmp___38 ;
  u32 tmp___39 ;
  u32 tmp___40 ;
  u32 tmp___41 ;
  u32 tmp___42 ;
  u32 tmp___43 ;
  u32 tmp___44 ;
  u32 tmp___45 ;
  u32 tmp___46 ;
  u32 tmp___47 ;
  u32 tmp___48 ;
  u32 tmp___49 ;
  u32 tmp___50 ;
  u32 tmp___51 ;
  u32 tmp___52 ;
  u32 tmp___53 ;
  u32 tmp___54 ;
  u32 tmp___55 ;
  u32 tmp___56 ;

  {
  {
#line 5659
  netdev = adapter->netdev;
#line 5660
  hw = & adapter->hw;
#line 5661
  hwstats = & adapter->stats;
#line 5662
  total_mpc = 0ULL;
#line 5663
  missed_rx = 0U;
#line 5664
  non_eop_descs = 0ULL;
#line 5664
  restart_queue = 0ULL;
#line 5664
  tx_busy = 0ULL;
#line 5665
  alloc_rx_page_failed = 0ULL;
#line 5665
  alloc_rx_buff_failed = 0ULL;
#line 5666
  bytes = 0ULL;
#line 5666
  packets = 0ULL;
#line 5666
  hw_csum_rx_error = 0ULL;
#line 5668
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 5668
  if (tmp != 0) {
#line 5670
    return;
  } else {
    {
#line 5668
    tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 5668
    if (tmp___0 != 0) {
#line 5670
      return;
    } else {

    }
  }
#line 5672
  if ((adapter->flags2 & 2U) != 0U) {
#line 5673
    rsc_count = 0ULL;
#line 5674
    rsc_flush = 0ULL;
#line 5675
    i = 0U;
#line 5675
    goto ldv_54992;
    ldv_54991: 
#line 5676
    rsc_count = rsc_count + (adapter->rx_ring[i])->__annonCompField97.rx_stats.rsc_count;
#line 5677
    rsc_flush = rsc_flush + (adapter->rx_ring[i])->__annonCompField97.rx_stats.rsc_flush;
#line 5675
    i = i + 1U;
    ldv_54992: ;
#line 5675
    if (i < (u32 )adapter->num_rx_queues) {
#line 5677
      goto ldv_54991;
    } else {

    }
#line 5679
    adapter->rsc_total_count = rsc_count;
#line 5680
    adapter->rsc_total_flush = rsc_flush;
  } else {

  }
#line 5683
  i = 0U;
#line 5683
  goto ldv_54996;
  ldv_54995: 
#line 5684
  rx_ring = adapter->rx_ring[i];
#line 5685
  non_eop_descs = non_eop_descs + rx_ring->__annonCompField97.rx_stats.non_eop_descs;
#line 5686
  alloc_rx_page_failed = alloc_rx_page_failed + rx_ring->__annonCompField97.rx_stats.alloc_rx_page_failed;
#line 5687
  alloc_rx_buff_failed = alloc_rx_buff_failed + rx_ring->__annonCompField97.rx_stats.alloc_rx_buff_failed;
#line 5688
  hw_csum_rx_error = hw_csum_rx_error + rx_ring->__annonCompField97.rx_stats.csum_err;
#line 5689
  bytes = bytes + rx_ring->stats.bytes;
#line 5690
  packets = packets + rx_ring->stats.packets;
#line 5683
  i = i + 1U;
  ldv_54996: ;
#line 5683
  if (i < (u32 )adapter->num_rx_queues) {
#line 5685
    goto ldv_54995;
  } else {

  }
#line 5692
  adapter->non_eop_descs = non_eop_descs;
#line 5693
  adapter->alloc_rx_page_failed = (u32 )alloc_rx_page_failed;
#line 5694
  adapter->alloc_rx_buff_failed = (u32 )alloc_rx_buff_failed;
#line 5695
  adapter->hw_csum_rx_error = hw_csum_rx_error;
#line 5696
  netdev->stats.rx_bytes = (unsigned long )bytes;
#line 5697
  netdev->stats.rx_packets = (unsigned long )packets;
#line 5699
  bytes = 0ULL;
#line 5700
  packets = 0ULL;
#line 5702
  i = 0U;
#line 5702
  goto ldv_55000;
  ldv_54999: 
#line 5703
  tx_ring = adapter->tx_ring[i];
#line 5704
  restart_queue = restart_queue + tx_ring->__annonCompField97.tx_stats.restart_queue;
#line 5705
  tx_busy = tx_busy + tx_ring->__annonCompField97.tx_stats.tx_busy;
#line 5706
  bytes = bytes + tx_ring->stats.bytes;
#line 5707
  packets = packets + tx_ring->stats.packets;
#line 5702
  i = i + 1U;
  ldv_55000: ;
#line 5702
  if (i < (u32 )adapter->num_tx_queues) {
#line 5704
    goto ldv_54999;
  } else {

  }
  {
#line 5709
  adapter->restart_queue = restart_queue;
#line 5710
  adapter->tx_busy = tx_busy;
#line 5711
  netdev->stats.tx_bytes = (unsigned long )bytes;
#line 5712
  netdev->stats.tx_packets = (unsigned long )packets;
#line 5714
  tmp___1 = ixgbe_read_reg(hw, 16384U);
#line 5714
  hwstats->crcerrs = hwstats->crcerrs + (u64 )tmp___1;
#line 5717
  i = 0U;
  }
#line 5717
  goto ldv_55008;
  ldv_55007: 
  {
#line 5719
  mpc = ixgbe_read_reg(hw, (i + 4072U) * 4U);
#line 5720
  missed_rx = missed_rx + mpc;
#line 5721
  hwstats->mpc[i] = hwstats->mpc[i] + (u64 )mpc;
#line 5722
  total_mpc = total_mpc + hwstats->mpc[i];
#line 5723
  tmp___2 = ixgbe_read_reg(hw, (i + 4032U) * 4U);
#line 5723
  hwstats->pxontxc[i] = hwstats->pxontxc[i] + (u64 )tmp___2;
#line 5724
  tmp___3 = ixgbe_read_reg(hw, (i + 4040U) * 4U);
#line 5724
  hwstats->pxofftxc[i] = hwstats->pxofftxc[i] + (u64 )tmp___3;
  }
  {
#line 5726
  if ((unsigned int )hw->mac.type == 1U) {
#line 5726
    goto case_1;
  } else {

  }
#line 5733
  if ((unsigned int )hw->mac.type == 2U) {
#line 5733
    goto case_2;
  } else {

  }
#line 5734
  if ((unsigned int )hw->mac.type == 3U) {
#line 5734
    goto case_3;
  } else {

  }
#line 5738
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 5727
  tmp___4 = ixgbe_read_reg(hw, (i + 4080U) * 4U);
#line 5727
  hwstats->rnbc[i] = hwstats->rnbc[i] + (u64 )tmp___4;
#line 5728
  tmp___5 = ixgbe_read_reg(hw, i * 64U + 24628U);
#line 5728
  hwstats->qbtc[i] = hwstats->qbtc[i] + (u64 )tmp___5;
#line 5729
  tmp___6 = ixgbe_read_reg(hw, i * 64U + 4148U);
#line 5729
  hwstats->qbrc[i] = hwstats->qbrc[i] + (u64 )tmp___6;
#line 5730
  tmp___7 = ixgbe_read_reg(hw, (i + 13248U) * 4U);
#line 5730
  hwstats->pxonrxc[i] = hwstats->pxonrxc[i] + (u64 )tmp___7;
  }
#line 5732
  goto ldv_55003;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 5735
  tmp___8 = ixgbe_read_reg(hw, (i + 4176U) * 4U);
#line 5735
  hwstats->pxonrxc[i] = hwstats->pxonrxc[i] + (u64 )tmp___8;
  }
#line 5737
  goto ldv_55003;
  switch_default: /* CIL Label */ ;
#line 5739
  goto ldv_55003;
  switch_break: /* CIL Label */ ;
  }
  ldv_55003: 
#line 5717
  i = i + 1U;
  ldv_55008: ;
#line 5717
  if (i <= 7U) {
#line 5719
    goto ldv_55007;
  } else {

  }
#line 5744
  i = 0U;
#line 5744
  goto ldv_55011;
  ldv_55010: 
  {
#line 5745
  tmp___9 = ixgbe_read_reg(hw, i * 64U + 24624U);
#line 5745
  hwstats->qptc[i] = hwstats->qptc[i] + (u64 )tmp___9;
#line 5746
  tmp___10 = ixgbe_read_reg(hw, i * 64U + 4144U);
#line 5746
  hwstats->qprc[i] = hwstats->qprc[i] + (u64 )tmp___10;
  }
#line 5747
  if ((unsigned int )hw->mac.type - 2U <= 1U) {
    {
#line 5749
    tmp___11 = ixgbe_read_reg(hw, (i + 4320U) * 8U);
#line 5749
    hwstats->qbtc[i] = hwstats->qbtc[i] + (u64 )tmp___11;
#line 5750
    ixgbe_read_reg(hw, i * 8U + 34564U);
#line 5751
    tmp___12 = ixgbe_read_reg(hw, i * 64U + 4148U);
#line 5751
    hwstats->qbrc[i] = hwstats->qbrc[i] + (u64 )tmp___12;
#line 5752
    ixgbe_read_reg(hw, i * 64U + 4152U);
    }
  } else {

  }
#line 5744
  i = i + 1U;
  ldv_55011: ;
#line 5744
  if (i <= 15U) {
#line 5746
    goto ldv_55010;
  } else {

  }
  {
#line 5756
  tmp___13 = ixgbe_read_reg(hw, 16500U);
#line 5756
  hwstats->gprc = hwstats->gprc + (u64 )tmp___13;
#line 5758
  hwstats->gprc = hwstats->gprc - (u64 )missed_rx;
#line 5760
  ixgbe_update_xoff_received(adapter);
  }
  {
#line 5764
  if ((unsigned int )hw->mac.type == 1U) {
#line 5764
    goto case_1___0;
  } else {

  }
#line 5770
  if ((unsigned int )hw->mac.type == 3U) {
#line 5770
    goto case_3___0;
  } else {

  }
#line 5776
  if ((unsigned int )hw->mac.type == 2U) {
#line 5776
    goto case_2___0;
  } else {

  }
#line 5812
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 5765
  tmp___14 = ixgbe_read_reg(hw, 53088U);
#line 5765
  hwstats->lxonrxc = hwstats->lxonrxc + (u64 )tmp___14;
#line 5766
  tmp___15 = ixgbe_read_reg(hw, 16524U);
#line 5766
  hwstats->gorc = hwstats->gorc + (u64 )tmp___15;
#line 5767
  tmp___16 = ixgbe_read_reg(hw, 16532U);
#line 5767
  hwstats->gotc = hwstats->gotc + (u64 )tmp___16;
#line 5768
  tmp___17 = ixgbe_read_reg(hw, 16580U);
#line 5768
  hwstats->tor = hwstats->tor + (u64 )tmp___17;
  }
#line 5769
  goto ldv_55014;
  case_3___0: /* CIL Label */ 
  {
#line 5772
  tmp___18 = ixgbe_read_reg(hw, 16836U);
#line 5772
  hwstats->o2bgptc = hwstats->o2bgptc + (u64 )tmp___18;
#line 5773
  tmp___19 = ixgbe_read_reg(hw, 34736U);
#line 5773
  hwstats->o2bspc = hwstats->o2bspc + (u64 )tmp___19;
#line 5774
  tmp___20 = ixgbe_read_reg(hw, 16832U);
#line 5774
  hwstats->b2ospc = hwstats->b2ospc + (u64 )tmp___20;
#line 5775
  tmp___21 = ixgbe_read_reg(hw, 12176U);
#line 5775
  hwstats->b2ogprc = hwstats->b2ogprc + (u64 )tmp___21;
  }
  case_2___0: /* CIL Label */ 
#line 5777
  i = 0U;
#line 5777
  goto ldv_55018;
  ldv_55017: 
  {
#line 5778
  tmp___22 = ixgbe_read_reg(hw, i * 64U + 5168U);
#line 5778
  adapter->hw_rx_no_dma_resources = adapter->hw_rx_no_dma_resources + (u64 )tmp___22;
#line 5777
  i = i + 1U;
  }
  ldv_55018: ;
#line 5777
  if (i <= 15U) {
#line 5779
    goto ldv_55017;
  } else {

  }
  {
#line 5780
  tmp___23 = ixgbe_read_reg(hw, 16520U);
#line 5780
  hwstats->gorc = hwstats->gorc + (u64 )tmp___23;
#line 5781
  ixgbe_read_reg(hw, 16524U);
#line 5782
  tmp___24 = ixgbe_read_reg(hw, 16528U);
#line 5782
  hwstats->gotc = hwstats->gotc + (u64 )tmp___24;
#line 5783
  ixgbe_read_reg(hw, 16532U);
#line 5784
  tmp___25 = ixgbe_read_reg(hw, 16576U);
#line 5784
  hwstats->tor = hwstats->tor + (u64 )tmp___25;
#line 5785
  ixgbe_read_reg(hw, 16580U);
#line 5786
  tmp___26 = ixgbe_read_reg(hw, 16804U);
#line 5786
  hwstats->lxonrxc = hwstats->lxonrxc + (u64 )tmp___26;
#line 5787
  tmp___27 = ixgbe_read_reg(hw, 61016U);
#line 5787
  hwstats->fdirmatch = hwstats->fdirmatch + (u64 )tmp___27;
#line 5788
  tmp___28 = ixgbe_read_reg(hw, 61020U);
#line 5788
  hwstats->fdirmiss = hwstats->fdirmiss + (u64 )tmp___28;
#line 5790
  tmp___29 = ixgbe_read_reg(hw, 20760U);
#line 5790
  hwstats->fccrc = hwstats->fccrc + (u64 )tmp___29;
#line 5791
  tmp___30 = ixgbe_read_reg(hw, 9244U);
#line 5791
  hwstats->fcoerpdc = hwstats->fcoerpdc + (u64 )tmp___30;
#line 5792
  tmp___31 = ixgbe_read_reg(hw, 9256U);
#line 5792
  hwstats->fcoeprc = hwstats->fcoeprc + (u64 )tmp___31;
#line 5793
  tmp___32 = ixgbe_read_reg(hw, 34692U);
#line 5793
  hwstats->fcoeptc = hwstats->fcoeptc + (u64 )tmp___32;
#line 5794
  tmp___33 = ixgbe_read_reg(hw, 9260U);
#line 5794
  hwstats->fcoedwrc = hwstats->fcoedwrc + (u64 )tmp___33;
#line 5795
  tmp___34 = ixgbe_read_reg(hw, 34696U);
#line 5795
  hwstats->fcoedwtc = hwstats->fcoedwtc + (u64 )tmp___34;
  }
#line 5797
  if ((unsigned long )adapter->fcoe.ddp_pool != (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 5798
    fcoe = & adapter->fcoe;
#line 5801
    noddp = 0ULL;
#line 5801
    noddp_ext_buff = 0ULL;
#line 5802
    cpu = 4294967295U;
#line 5802
    goto ldv_55030;
    ldv_55029: 
#line 5803
    __vpp_verify = (void const   *)0;
#line 5803
    __asm__  ("": "=r" (__ptr): "0" (fcoe->ddp_pool));
#line 5803
    ddp_pool = (struct ixgbe_fcoe_ddp_pool *)(__ptr + __per_cpu_offset[cpu]);
#line 5804
    noddp = noddp + ddp_pool->noddp;
#line 5805
    noddp_ext_buff = noddp_ext_buff + ddp_pool->noddp_ext_buff;
    ldv_55030: 
    {
#line 5802
    cpu = cpumask_next((int )cpu, cpu_possible_mask);
    }
#line 5802
    if (cpu < (unsigned int )nr_cpu_ids) {
#line 5804
      goto ldv_55029;
    } else {

    }
#line 5807
    hwstats->fcoe_noddp = noddp;
#line 5808
    hwstats->fcoe_noddp_ext_buff = noddp_ext_buff;
  } else {

  }
#line 5811
  goto ldv_55014;
  switch_default___0: /* CIL Label */ ;
#line 5813
  goto ldv_55014;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_55014: 
  {
#line 5815
  bprc = ixgbe_read_reg(hw, 16504U);
#line 5816
  hwstats->bprc = hwstats->bprc + (u64 )bprc;
#line 5817
  tmp___35 = ixgbe_read_reg(hw, 16508U);
#line 5817
  hwstats->mprc = hwstats->mprc + (u64 )tmp___35;
  }
#line 5818
  if ((unsigned int )hw->mac.type == 1U) {
#line 5819
    hwstats->mprc = hwstats->mprc - (u64 )bprc;
  } else {

  }
  {
#line 5820
  tmp___36 = ixgbe_read_reg(hw, 16556U);
#line 5820
  hwstats->roc = hwstats->roc + (u64 )tmp___36;
#line 5821
  tmp___37 = ixgbe_read_reg(hw, 16476U);
#line 5821
  hwstats->prc64 = hwstats->prc64 + (u64 )tmp___37;
#line 5822
  tmp___38 = ixgbe_read_reg(hw, 16480U);
#line 5822
  hwstats->prc127 = hwstats->prc127 + (u64 )tmp___38;
#line 5823
  tmp___39 = ixgbe_read_reg(hw, 16484U);
#line 5823
  hwstats->prc255 = hwstats->prc255 + (u64 )tmp___39;
#line 5824
  tmp___40 = ixgbe_read_reg(hw, 16488U);
#line 5824
  hwstats->prc511 = hwstats->prc511 + (u64 )tmp___40;
#line 5825
  tmp___41 = ixgbe_read_reg(hw, 16492U);
#line 5825
  hwstats->prc1023 = hwstats->prc1023 + (u64 )tmp___41;
#line 5826
  tmp___42 = ixgbe_read_reg(hw, 16496U);
#line 5826
  hwstats->prc1522 = hwstats->prc1522 + (u64 )tmp___42;
#line 5827
  tmp___43 = ixgbe_read_reg(hw, 16448U);
#line 5827
  hwstats->rlec = hwstats->rlec + (u64 )tmp___43;
#line 5828
  lxon = ixgbe_read_reg(hw, 16224U);
#line 5829
  hwstats->lxontxc = hwstats->lxontxc + (u64 )lxon;
#line 5830
  lxoff = ixgbe_read_reg(hw, 16232U);
#line 5831
  hwstats->lxofftxc = hwstats->lxofftxc + (u64 )lxoff;
#line 5832
  tmp___44 = ixgbe_read_reg(hw, 16512U);
#line 5832
  hwstats->gptc = hwstats->gptc + (u64 )tmp___44;
#line 5833
  tmp___45 = ixgbe_read_reg(hw, 16624U);
#line 5833
  hwstats->mptc = hwstats->mptc + (u64 )tmp___45;
#line 5837
  xon_off_tot = lxon + lxoff;
#line 5838
  hwstats->gptc = hwstats->gptc - (u64 )xon_off_tot;
#line 5839
  hwstats->mptc = hwstats->mptc - (u64 )xon_off_tot;
#line 5840
  hwstats->gotc = hwstats->gotc - (u64 )(xon_off_tot * 64U);
#line 5841
  tmp___46 = ixgbe_read_reg(hw, 16548U);
#line 5841
  hwstats->ruc = hwstats->ruc + (u64 )tmp___46;
#line 5842
  tmp___47 = ixgbe_read_reg(hw, 16552U);
#line 5842
  hwstats->rfc = hwstats->rfc + (u64 )tmp___47;
#line 5843
  tmp___48 = ixgbe_read_reg(hw, 16560U);
#line 5843
  hwstats->rjc = hwstats->rjc + (u64 )tmp___48;
#line 5844
  tmp___49 = ixgbe_read_reg(hw, 16592U);
#line 5844
  hwstats->tpr = hwstats->tpr + (u64 )tmp___49;
#line 5845
  tmp___50 = ixgbe_read_reg(hw, 16600U);
#line 5845
  hwstats->ptc64 = hwstats->ptc64 + (u64 )tmp___50;
#line 5846
  hwstats->ptc64 = hwstats->ptc64 - (u64 )xon_off_tot;
#line 5847
  tmp___51 = ixgbe_read_reg(hw, 16604U);
#line 5847
  hwstats->ptc127 = hwstats->ptc127 + (u64 )tmp___51;
#line 5848
  tmp___52 = ixgbe_read_reg(hw, 16608U);
#line 5848
  hwstats->ptc255 = hwstats->ptc255 + (u64 )tmp___52;
#line 5849
  tmp___53 = ixgbe_read_reg(hw, 16612U);
#line 5849
  hwstats->ptc511 = hwstats->ptc511 + (u64 )tmp___53;
#line 5850
  tmp___54 = ixgbe_read_reg(hw, 16616U);
#line 5850
  hwstats->ptc1023 = hwstats->ptc1023 + (u64 )tmp___54;
#line 5851
  tmp___55 = ixgbe_read_reg(hw, 16620U);
#line 5851
  hwstats->ptc1522 = hwstats->ptc1522 + (u64 )tmp___55;
#line 5852
  tmp___56 = ixgbe_read_reg(hw, 16628U);
#line 5852
  hwstats->bptc = hwstats->bptc + (u64 )tmp___56;
#line 5855
  netdev->stats.multicast = (unsigned long )hwstats->mprc;
#line 5858
  netdev->stats.rx_errors = (unsigned long )(hwstats->crcerrs + hwstats->rlec);
#line 5859
  netdev->stats.rx_dropped = 0UL;
#line 5860
  netdev->stats.rx_length_errors = (unsigned long )hwstats->rlec;
#line 5861
  netdev->stats.rx_crc_errors = (unsigned long )hwstats->crcerrs;
#line 5862
  netdev->stats.rx_missed_errors = (unsigned long )total_mpc;
  }
#line 5863
  return;
}
}
#line 5869 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fdir_reinit_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int i ;
  int tmp ;
  s32 tmp___0 ;

  {
#line 5871
  hw = & adapter->hw;
#line 5874
  if ((adapter->flags2 & 128U) == 0U) {
#line 5875
    return;
  } else {

  }
  {
#line 5877
  adapter->flags2 = adapter->flags2 & 4294967167U;
#line 5880
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 5880
  if (tmp != 0) {
#line 5881
    return;
  } else {

  }
#line 5884
  if ((adapter->flags & 262144U) == 0U) {
#line 5885
    return;
  } else {

  }
  {
#line 5887
  adapter->fdir_overflow = adapter->fdir_overflow + 1UL;
#line 5889
  tmp___0 = ixgbe_reinit_fdir_tables_82599(hw);
  }
#line 5889
  if (tmp___0 == 0) {
#line 5890
    i = 0;
#line 5890
    goto ldv_55039;
    ldv_55038: 
    {
#line 5891
    set_bit(0L, (unsigned long volatile   *)(& (adapter->tx_ring[i])->state));
#line 5890
    i = i + 1;
    }
    ldv_55039: ;
#line 5890
    if (i < adapter->num_tx_queues) {
#line 5892
      goto ldv_55038;
    } else {

    }
    {
#line 5894
    ixgbe_write_reg(hw, 2176U, 65536U);
    }
  } else
#line 5896
  if (((int )adapter->msg_enable & 2) != 0) {
    {
#line 5897
    netdev_err((struct net_device  const  *)adapter->netdev, "failed to finish FDIR re-initialization, ignored adding FDIR ATR filters\n");
    }
  } else {

  }
#line 5898
  return;
}
}
#line 5910 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_hang_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u64 eics ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  struct ixgbe_q_vector *qv ;

  {
  {
#line 5912
  hw = & adapter->hw;
#line 5913
  eics = 0ULL;
#line 5917
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 5917
  if (tmp != 0) {
#line 5920
    return;
  } else {
    {
#line 5917
    tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 5917
    if (tmp___0 != 0) {
#line 5920
      return;
    } else {
      {
#line 5917
      tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
      }
#line 5917
      if (tmp___1 != 0) {
#line 5920
        return;
      } else {

      }
    }
  }
  {
#line 5923
  tmp___2 = netif_carrier_ok((struct net_device  const  *)adapter->netdev);
  }
#line 5923
  if ((int )tmp___2) {
#line 5924
    i = 0;
#line 5924
    goto ldv_55048;
    ldv_55047: 
    {
#line 5925
    set_bit(2L, (unsigned long volatile   *)(& (adapter->tx_ring[i])->state));
#line 5924
    i = i + 1;
    }
    ldv_55048: ;
#line 5924
    if (i < adapter->num_tx_queues) {
#line 5926
      goto ldv_55047;
    } else {

    }

  } else {

  }
#line 5928
  if ((adapter->flags & 8U) == 0U) {
    {
#line 5934
    ixgbe_write_reg(hw, 2056U, 3221225472U);
    }
  } else {
#line 5938
    i = 0;
#line 5938
    goto ldv_55052;
    ldv_55051: 
#line 5939
    qv = adapter->q_vector[i];
#line 5940
    if ((unsigned long )qv->rx.ring != (unsigned long )((struct ixgbe_ring *)0) || (unsigned long )qv->tx.ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 5941
      eics = eics | (1ULL << i);
    } else {

    }
#line 5938
    i = i + 1;
    ldv_55052: ;
#line 5938
    if (i < adapter->num_q_vectors) {
#line 5940
      goto ldv_55051;
    } else {

    }

  }
  {
#line 5946
  ixgbe_irq_rearm_queues(adapter, eics);
  }
#line 5947
  return;
}
}
#line 5955 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_update_link(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 link_speed ;
  bool link_up ;
  bool pfc_en ;

  {
#line 5957
  hw = & adapter->hw;
#line 5958
  link_speed = adapter->link_speed;
#line 5959
  link_up = adapter->link_up;
#line 5960
  pfc_en = adapter->dcb_cfg.pfc_mode_enable;
#line 5962
  if ((adapter->flags & 65536U) == 0U) {
#line 5963
    return;
  } else {

  }
#line 5965
  if ((unsigned long )hw->mac.ops.check_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          ixgbe_link_speed * ,
                                                                          bool * ,
                                                                          bool  ))0)) {
    {
#line 5966
    (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
    }
  } else {
#line 5969
    link_speed = 128U;
#line 5970
    link_up = 1;
  }
#line 5973
  if ((unsigned long )adapter->ixgbe_ieee_pfc != (unsigned long )((struct ieee_pfc *)0)) {
#line 5974
    pfc_en = ((int )pfc_en | ((unsigned int )(adapter->ixgbe_ieee_pfc)->pfc_en != 0U)) != 0;
  } else {

  }
#line 5976
  if ((int )link_up && ((adapter->flags & 4096U) == 0U || ! pfc_en)) {
    {
#line 5977
    (*(hw->mac.ops.fc_enable))(hw);
#line 5978
    ixgbe_set_rx_drop_en(adapter);
    }
  } else {

  }
#line 5982
  if ((int )link_up || (long )((adapter->link_check_timeout - (unsigned long )jiffies) + 1000UL) < 0L) {
    {
#line 5984
    adapter->flags = adapter->flags & 4294901759U;
#line 5985
    ixgbe_write_reg(hw, 2176U, 1048576U);
#line 5986
    ixgbe_read_reg(hw, 8U);
    }
  } else {

  }
#line 5989
  adapter->link_up = link_up;
#line 5990
  adapter->link_speed = link_speed;
#line 5991
  return;
}
}
#line 5993 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_update_default_up(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct dcb_app app ;
  u8 up___0 ;
  int tmp ;

  {
#line 5996
  netdev = adapter->netdev;
#line 5997
  app.selector = 1U;
#line 5997
  app.priority = (unsigned char)0;
#line 5997
  app.protocol = 0U;
#line 6001
  up___0 = 0U;
#line 6003
  if (((int )adapter->dcbx_cap & 8) != 0) {
    {
#line 6004
    up___0 = dcb_ieee_getapp_mask(netdev, & app);
    }
  } else {

  }
#line 6006
  if ((unsigned int )up___0 > 1U) {
    {
#line 6006
    tmp = ffs((int )up___0);
#line 6006
    adapter->default_up = (unsigned int )((u8 )tmp) + 255U;
    }
  } else {
#line 6006
    adapter->default_up = 0U;
  }
#line 6007
  return;
}
}
#line 6015 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_link_is_up(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  u32 link_speed ;
  bool flow_rx ;
  bool flow_tx ;
  bool tmp ;
  u32 frctl ;
  u32 tmp___0 ;
  u32 rmcs ;
  u32 tmp___1 ;
  u32 mflcn ;
  u32 tmp___2 ;
  u32 fccfg ;
  u32 tmp___3 ;
  int tmp___4 ;

  {
  {
#line 6017
  netdev = adapter->netdev;
#line 6018
  hw = & adapter->hw;
#line 6019
  link_speed = adapter->link_speed;
#line 6023
  tmp = netif_carrier_ok((struct net_device  const  *)netdev);
  }
#line 6023
  if ((int )tmp) {
#line 6024
    return;
  } else {

  }
#line 6026
  adapter->flags2 = adapter->flags2 & 4294967279U;
  {
#line 6029
  if ((unsigned int )hw->mac.type == 1U) {
#line 6029
    goto case_1;
  } else {

  }
#line 6036
  if ((unsigned int )hw->mac.type == 3U) {
#line 6036
    goto case_3;
  } else {

  }
#line 6037
  if ((unsigned int )hw->mac.type == 2U) {
#line 6037
    goto case_2;
  } else {

  }
#line 6044
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 6030
  tmp___0 = ixgbe_read_reg(hw, 20608U);
#line 6030
  frctl = tmp___0;
#line 6031
  tmp___1 = ixgbe_read_reg(hw, 15616U);
#line 6031
  rmcs = tmp___1;
#line 6032
  flow_rx = (frctl & 32768U) != 0U;
#line 6033
  flow_tx = (rmcs & 8U) != 0U;
  }
#line 6035
  goto ldv_55084;
  case_3: /* CIL Label */ ;
  case_2: /* CIL Label */ 
  {
#line 6038
  tmp___2 = ixgbe_read_reg(hw, 17044U);
#line 6038
  mflcn = tmp___2;
#line 6039
  tmp___3 = ixgbe_read_reg(hw, 15616U);
#line 6039
  fccfg = tmp___3;
#line 6040
  flow_rx = (mflcn & 8U) != 0U;
#line 6041
  flow_tx = (fccfg & 8U) != 0U;
  }
#line 6043
  goto ldv_55084;
  switch_default: /* CIL Label */ 
#line 6045
  flow_tx = 0;
#line 6046
  flow_rx = 0;
#line 6047
  goto ldv_55084;
  switch_break: /* CIL Label */ ;
  }
  ldv_55084: 
  {
#line 6050
  adapter->last_rx_ptp_check = jiffies;
#line 6052
  tmp___4 = constant_test_bit(6L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 6052
  if (tmp___4 != 0) {
    {
#line 6053
    ixgbe_ptp_start_cyclecounter(adapter);
    }
  } else {

  }
#line 6055
  if ((int )adapter->msg_enable & 1) {
    {
#line 6065
    netdev_info((struct net_device  const  *)adapter->netdev, "NIC Link is Up %s, Flow Control: %s\n",
                link_speed != 128U ? (link_speed != 32U ? (link_speed == 8U ? (char *)"100 Mbps" : (char *)"unknown speed") : (char *)"1 Gbps") : (char *)"10 Gbps",
                ! flow_rx || ! flow_tx ? ((int )flow_rx ? (char *)"RX" : ((int )flow_tx ? (char *)"TX" : (char *)"None")) : (char *)"RX/TX");
    }
  } else {

  }
  {
#line 6067
  netif_carrier_on(netdev);
#line 6068
  ixgbe_check_vf_rate_limit(adapter);
#line 6071
  ixgbe_update_default_up(adapter);
#line 6074
  ixgbe_ping_all_vfs(adapter);
  }
#line 6075
  return;
}
}
#line 6082 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_link_is_down(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_hw *hw ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  {
#line 6084
  netdev = adapter->netdev;
#line 6085
  hw = & adapter->hw;
#line 6087
  adapter->link_up = 0;
#line 6088
  adapter->link_speed = 0U;
#line 6091
  tmp = netif_carrier_ok((struct net_device  const  *)netdev);
  }
#line 6091
  if (tmp) {
#line 6091
    tmp___0 = 0;
  } else {
#line 6091
    tmp___0 = 1;
  }
#line 6091
  if (tmp___0) {
#line 6092
    return;
  } else {

  }
  {
#line 6095
  tmp___1 = ixgbe_is_sfp(hw);
  }
#line 6095
  if ((int )tmp___1 && (unsigned int )hw->mac.type == 1U) {
#line 6096
    adapter->flags2 = adapter->flags2 | 16U;
  } else {

  }
  {
#line 6098
  tmp___2 = constant_test_bit(6L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 6098
  if (tmp___2 != 0) {
    {
#line 6099
    ixgbe_ptp_start_cyclecounter(adapter);
    }
  } else {

  }
#line 6101
  if ((int )adapter->msg_enable & 1) {
    {
#line 6101
    netdev_info((struct net_device  const  *)adapter->netdev, "NIC Link is Down\n");
    }
  } else {

  }
  {
#line 6102
  netif_carrier_off(netdev);
#line 6105
  ixgbe_ping_all_vfs(adapter);
  }
#line 6106
  return;
}
}
#line 6112 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_flush_tx(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  int some_tx_pending ;
  struct ixgbe_ring *tx_ring ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 6115
  some_tx_pending = 0;
#line 6117
  tmp = netif_carrier_ok((struct net_device  const  *)adapter->netdev);
  }
#line 6117
  if (tmp) {
#line 6117
    tmp___0 = 0;
  } else {
#line 6117
    tmp___0 = 1;
  }
#line 6117
  if (tmp___0) {
#line 6118
    i = 0;
#line 6118
    goto ldv_55103;
    ldv_55102: 
#line 6119
    tx_ring = adapter->tx_ring[i];
#line 6120
    if ((int )tx_ring->next_to_use != (int )tx_ring->next_to_clean) {
#line 6121
      some_tx_pending = 1;
#line 6122
      goto ldv_55101;
    } else {

    }
#line 6118
    i = i + 1;
    ldv_55103: ;
#line 6118
    if (i < adapter->num_tx_queues) {
#line 6120
      goto ldv_55102;
    } else {

    }
    ldv_55101: ;
#line 6126
    if (some_tx_pending != 0) {
#line 6132
      if ((int )adapter->msg_enable & 1) {
        {
#line 6132
        netdev_warn((struct net_device  const  *)adapter->netdev, "initiating reset to clear Tx work after link loss\n");
        }
      } else {

      }
#line 6133
      adapter->flags2 = adapter->flags2 | 64U;
    } else {

    }
  } else {

  }
#line 6136
  return;
}
}
#line 6138 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_spoof_check(struct ixgbe_adapter *adapter ) 
{ 
  u32 ssvpc ;

  {
#line 6143
  if ((unsigned int )adapter->hw.mac.type == 1U || adapter->num_vfs == 0U) {
#line 6145
    return;
  } else {

  }
  {
#line 6147
  ssvpc = ixgbe_read_reg(& adapter->hw, 34688U);
  }
#line 6153
  if (ssvpc == 0U) {
#line 6154
    return;
  } else {

  }
#line 6156
  if ((int )adapter->msg_enable & 1) {
    {
#line 6156
    netdev_warn((struct net_device  const  *)adapter->netdev, "%u Spoofed packets detected\n",
                ssvpc);
    }
  } else {

  }
#line 6157
  return;
}
}
#line 6163 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_watchdog_subtask(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 6166
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 6166
  if (tmp != 0) {
#line 6169
    return;
  } else {
    {
#line 6166
    tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 6166
    if (tmp___0 != 0) {
#line 6169
      return;
    } else {
      {
#line 6166
      tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
      }
#line 6166
      if (tmp___1 != 0) {
#line 6169
        return;
      } else {

      }
    }
  }
  {
#line 6171
  ixgbe_watchdog_update_link(adapter);
  }
#line 6173
  if ((int )adapter->link_up) {
    {
#line 6174
    ixgbe_watchdog_link_is_up(adapter);
    }
  } else {
    {
#line 6176
    ixgbe_watchdog_link_is_down(adapter);
    }
  }
  {
#line 6178
  ixgbe_spoof_check(adapter);
#line 6179
  ixgbe_update_stats(adapter);
#line 6181
  ixgbe_watchdog_flush_tx(adapter);
  }
#line 6182
  return;
}
}
#line 6188 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_detection_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  s32 err ;
  int tmp ;

  {
#line 6190
  hw = & adapter->hw;
#line 6194
  if (*((unsigned int *)adapter + 135UL) == 0U) {
#line 6196
    return;
  } else {

  }
  {
#line 6199
  tmp = test_and_set_bit(5L, (unsigned long volatile   *)(& adapter->state));
  }
#line 6199
  if (tmp != 0) {
#line 6200
    return;
  } else {

  }
  {
#line 6202
  err = (*(hw->phy.ops.identify_sfp))(hw);
  }
#line 6203
  if (err == -19) {
#line 6204
    goto sfp_out;
  } else {

  }
#line 6206
  if (err == -20) {
#line 6209
    adapter->flags2 = adapter->flags2 | 32U;
  } else {

  }
#line 6213
  if (err != 0) {
#line 6214
    goto sfp_out;
  } else {

  }
#line 6217
  if ((adapter->flags2 & 32U) == 0U) {
#line 6218
    goto sfp_out;
  } else {

  }
#line 6220
  adapter->flags2 = adapter->flags2 & 4294967263U;
#line 6227
  if ((unsigned int )hw->mac.type == 1U) {
    {
#line 6228
    err = (*(hw->phy.ops.reset))(hw);
    }
  } else {
    {
#line 6230
    err = (*(hw->mac.ops.setup_sfp))(hw);
    }
  }
#line 6232
  if (err == -19) {
#line 6233
    goto sfp_out;
  } else {

  }
#line 6235
  adapter->flags = adapter->flags | 131072U;
#line 6236
  if (((int )adapter->msg_enable & 2) != 0) {
    {
#line 6236
    netdev_info((struct net_device  const  *)adapter->netdev, "detected SFP+: %d\n",
                (unsigned int )hw->phy.sfp_type);
    }
  } else {

  }
  sfp_out: 
  {
#line 6239
  clear_bit(5L, (unsigned long volatile   *)(& adapter->state));
  }
#line 6241
  if (err == -19 && (unsigned int )(adapter->netdev)->reg_state == 1U) {
    {
#line 6243
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "failed to initialize because an unsupported SFP+ module type was detected.\n");
#line 6245
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Reload the driver after installing a supported module.\n");
#line 6247
    ldv_unregister_netdev_19(adapter->netdev);
    }
  } else {

  }
#line 6249
  return;
}
}
#line 6255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_sfp_link_config_subtask(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 speed ;
  bool autoneg ;
  int tmp ;

  {
#line 6257
  hw = & adapter->hw;
#line 6259
  autoneg = 0;
#line 6261
  if ((adapter->flags & 131072U) == 0U) {
#line 6262
    return;
  } else {

  }
  {
#line 6265
  tmp = test_and_set_bit(5L, (unsigned long volatile   *)(& adapter->state));
  }
#line 6265
  if (tmp != 0) {
#line 6266
    return;
  } else {

  }
#line 6268
  adapter->flags = adapter->flags & 4294836223U;
#line 6270
  speed = hw->phy.autoneg_advertised;
#line 6271
  if (speed == 0U && (unsigned long )hw->mac.ops.get_link_capabilities != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                                    ixgbe_link_speed * ,
                                                                                                    bool * ))0)) {
    {
#line 6272
    (*(hw->mac.ops.get_link_capabilities))(hw, & speed, & autoneg);
    }
#line 6275
    if (! autoneg) {
#line 6276
      if ((speed & 128U) != 0U) {
#line 6277
        speed = 128U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 6281
  if ((unsigned long )hw->mac.ops.setup_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          ixgbe_link_speed  ,
                                                                          bool  ))0)) {
    {
#line 6282
    (*(hw->mac.ops.setup_link))(hw, speed, 1);
    }
  } else {

  }
  {
#line 6284
  adapter->flags = adapter->flags | 65536U;
#line 6285
  adapter->link_check_timeout = jiffies;
#line 6286
  clear_bit(5L, (unsigned long volatile   *)(& adapter->state));
  }
#line 6287
  return;
}
}
#line 6290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_check_for_bad_vf(struct ixgbe_adapter *adapter ) 
{ 
  int vf ;
  struct ixgbe_hw *hw ;
  struct net_device *netdev ;
  u32 gpc ;
  u32 ciaa ;
  u32 ciad ;

  {
  {
#line 6293
  hw = & adapter->hw;
#line 6294
  netdev = adapter->netdev;
#line 6298
  gpc = ixgbe_read_reg(hw, 34720U);
  }
#line 6299
  if (gpc != 0U) {
#line 6300
    return;
  } else {

  }
#line 6308
  vf = 0;
#line 6308
  goto ldv_55133;
  ldv_55132: 
  {
#line 6309
  ciaa = (unsigned int )(vf << 16) | 2147483648U;
#line 6311
  ciaa = ciaa | 4U;
#line 6312
  ixgbe_write_reg(hw, 69768U, ciaa);
#line 6313
  ciad = ixgbe_read_reg(hw, 69772U);
#line 6314
  ciaa = ciaa & 2147483647U;
#line 6316
  ixgbe_write_reg(hw, 69768U, ciaa);
#line 6318
  ciad = ciad >> 16;
  }
#line 6319
  if ((ciad & 8192U) != 0U) {
    {
#line 6320
    netdev_err((struct net_device  const  *)netdev, "VF %d Hung DMA\n", vf);
#line 6322
    ciaa = (unsigned int )(vf << 16) | 2147483648U;
#line 6323
    ciaa = ciaa | 168U;
#line 6324
    ixgbe_write_reg(hw, 69768U, ciaa);
#line 6325
    ciad = 32768U;
#line 6326
    ixgbe_write_reg(hw, 69772U, ciad);
#line 6327
    ciaa = ciaa & 2147483647U;
#line 6328
    ixgbe_write_reg(hw, 69768U, ciaa);
    }
  } else {

  }
#line 6308
  vf = vf + 1;
  ldv_55133: ;
#line 6308
  if ((unsigned int )vf < adapter->num_vfs) {
#line 6310
    goto ldv_55132;
  } else {

  }

#line 6315
  return;
}
}
#line 6338 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_timer(unsigned long data ) 
{ 
  struct ixgbe_adapter *adapter ;
  unsigned long next_event_offset ;
  bool ready ;

  {
#line 6340
  adapter = (struct ixgbe_adapter *)data;
#line 6342
  ready = 1;
#line 6345
  if ((adapter->flags & 65536U) != 0U) {
#line 6346
    next_event_offset = 25UL;
  } else {
#line 6348
    next_event_offset = 500UL;
  }
#line 6355
  if (adapter->num_vfs == 0U || (adapter->flags & 65536U) != 0U) {
#line 6357
    goto normal_timer_service;
  } else {

  }
  {
#line 6360
  ixgbe_check_for_bad_vf(adapter);
#line 6361
  next_event_offset = 5UL;
#line 6362
  adapter->timer_event_accumulator = adapter->timer_event_accumulator + 1U;
  }
#line 6364
  if (adapter->timer_event_accumulator > 99U) {
#line 6365
    adapter->timer_event_accumulator = 0U;
  } else {
#line 6367
    ready = 0;
  }
  normal_timer_service: 
  {
#line 6372
  ldv_mod_timer_20(& adapter->service_timer, next_event_offset + (unsigned long )jiffies);
  }
#line 6374
  if ((int )ready) {
    {
#line 6375
    ixgbe_service_event_schedule(adapter);
    }
  } else {

  }
#line 6376
  return;
}
}
#line 6378 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_reset_subtask(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6380
  if ((adapter->flags2 & 64U) == 0U) {
#line 6381
    return;
  } else {

  }
  {
#line 6383
  adapter->flags2 = adapter->flags2 & 4294967231U;
#line 6386
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 6386
  if (tmp != 0) {
#line 6389
    return;
  } else {
    {
#line 6386
    tmp___0 = constant_test_bit(3L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 6386
    if (tmp___0 != 0) {
#line 6389
      return;
    } else {
      {
#line 6386
      tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
      }
#line 6386
      if (tmp___1 != 0) {
#line 6389
        return;
      } else {

      }
    }
  }
  {
#line 6391
  ixgbe_dump(adapter);
#line 6392
  netdev_err((struct net_device  const  *)adapter->netdev, "Reset adapter\n");
#line 6393
  adapter->tx_timeout_count = adapter->tx_timeout_count + 1U;
#line 6395
  rtnl_lock();
#line 6396
  ixgbe_reinit_locked(adapter);
#line 6397
  rtnl_unlock();
  }
#line 6398
  return;
}
}
#line 6404 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_service_task(struct work_struct *work ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 6406
  __mptr = (struct work_struct  const  *)work;
#line 6406
  adapter = (struct ixgbe_adapter *)__mptr + 0xffffffffffff6268UL;
#line 6409
  tmp___0 = ixgbe_removed((void *)adapter->hw.hw_addr);
  }
#line 6409
  if ((int )tmp___0) {
    {
#line 6410
    tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 6410
    if (tmp == 0) {
      {
#line 6411
      rtnl_lock();
#line 6412
      ixgbe_down(adapter);
#line 6413
      rtnl_unlock();
      }
    } else {

    }
    {
#line 6415
    ixgbe_service_event_complete(adapter);
    }
#line 6416
    return;
  } else {

  }
  {
#line 6418
  ixgbe_reset_subtask(adapter);
#line 6419
  ixgbe_sfp_detection_subtask(adapter);
#line 6420
  ixgbe_sfp_link_config_subtask(adapter);
#line 6421
  ixgbe_check_overtemp_subtask(adapter);
#line 6422
  ixgbe_watchdog_subtask(adapter);
#line 6423
  ixgbe_fdir_reinit_subtask(adapter);
#line 6424
  ixgbe_check_hang_subtask(adapter);
#line 6426
  tmp___1 = constant_test_bit(6L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 6426
  if (tmp___1 != 0) {
    {
#line 6427
    ixgbe_ptp_overflow_check(adapter);
#line 6428
    ixgbe_ptp_rx_hang(adapter);
    }
  } else {

  }
  {
#line 6431
  ixgbe_service_event_complete(adapter);
  }
#line 6432
  return;
}
}
#line 6434 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_tso(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first ,
                     u8 *hdr_len ) 
{ 
  struct sk_buff *skb ;
  u32 vlan_macip_lens ;
  u32 type_tucmd ;
  u32 mss_l4len_idx ;
  u32 l4len ;
  bool tmp ;
  int tmp___0 ;
  int err ;
  int tmp___1 ;
  int tmp___2 ;
  struct iphdr *iph ;
  struct iphdr *tmp___3 ;
  struct tcphdr *tmp___4 ;
  __sum16 tmp___5 ;
  struct ipv6hdr *tmp___6 ;
  struct tcphdr *tmp___7 ;
  struct ipv6hdr *tmp___8 ;
  struct ipv6hdr *tmp___9 ;
  __sum16 tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;

  {
#line 6438
  skb = first->skb;
#line 6442
  if ((unsigned int )*((unsigned char *)skb + 124UL) != 12U) {
#line 6443
    return (0);
  } else {

  }
  {
#line 6445
  tmp = skb_is_gso((struct sk_buff  const  *)skb);
  }
#line 6445
  if (tmp) {
#line 6445
    tmp___0 = 0;
  } else {
#line 6445
    tmp___0 = 1;
  }
#line 6445
  if (tmp___0) {
#line 6446
    return (0);
  } else {

  }
  {
#line 6448
  tmp___2 = skb_header_cloned((struct sk_buff  const  *)skb);
  }
#line 6448
  if (tmp___2 != 0) {
    {
#line 6449
    tmp___1 = pskb_expand_head(skb, 0, 0, 32U);
#line 6449
    err = tmp___1;
    }
#line 6450
    if (err != 0) {
#line 6451
      return (err);
    } else {

    }
  } else {

  }
#line 6455
  type_tucmd = 2048U;
#line 6457
  if ((unsigned int )first->protocol == 8U) {
    {
#line 6458
    tmp___3 = ip_hdr((struct sk_buff  const  *)skb);
#line 6458
    iph = tmp___3;
#line 6459
    iph->tot_len = 0U;
#line 6460
    iph->check = 0U;
#line 6461
    tmp___4 = tcp_hdr((struct sk_buff  const  *)skb);
#line 6461
    tmp___5 = csum_tcpudp_magic(iph->saddr, iph->daddr, 0, 6, 0U);
#line 6461
    tmp___4->check = ~ ((int )tmp___5);
#line 6465
    type_tucmd = type_tucmd | 1024U;
#line 6466
    first->tx_flags = first->tx_flags | 50U;
    }
  } else {
    {
#line 6469
    tmp___11 = skb_is_gso_v6((struct sk_buff  const  *)skb);
    }
#line 6469
    if ((int )tmp___11) {
      {
#line 6470
      tmp___6 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 6470
      tmp___6->payload_len = 0U;
#line 6471
      tmp___7 = tcp_hdr((struct sk_buff  const  *)skb);
#line 6471
      tmp___8 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 6471
      tmp___9 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 6471
      tmp___10 = csum_ipv6_magic((struct in6_addr  const  *)(& tmp___9->saddr), (struct in6_addr  const  *)(& tmp___8->daddr),
                                 0U, 6, 0U);
#line 6471
      tmp___7->check = ~ ((int )tmp___10);
#line 6475
      first->tx_flags = first->tx_flags | 34U;
      }
    } else {

    }
  }
  {
#line 6480
  l4len = tcp_hdrlen((struct sk_buff  const  *)skb);
#line 6481
  tmp___12 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 6481
  *hdr_len = (int )((u8 )tmp___12) + (int )((u8 )l4len);
#line 6484
  tmp___13 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6484
  first->gso_segs = ((struct skb_shared_info *)tmp___13)->gso_segs;
#line 6485
  first->bytecount = first->bytecount + (unsigned int )(((int )first->gso_segs + -1) * (int )*hdr_len);
#line 6488
  mss_l4len_idx = l4len << 8;
#line 6489
  tmp___14 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6489
  mss_l4len_idx = mss_l4len_idx | (u32 )((int )((struct skb_shared_info *)tmp___14)->gso_size << 16);
#line 6492
  vlan_macip_lens = skb_network_header_len((struct sk_buff  const  *)skb);
#line 6493
  tmp___15 = skb_network_offset((struct sk_buff  const  *)skb);
#line 6493
  vlan_macip_lens = vlan_macip_lens | (u32 )(tmp___15 << 9);
#line 6494
  vlan_macip_lens = vlan_macip_lens | (first->tx_flags & 4294901760U);
#line 6496
  ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0U, type_tucmd, mss_l4len_idx);
  }
#line 6499
  return (1);
}
}
#line 6502 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_csum(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first ) 
{ 
  struct sk_buff *skb ;
  u32 vlan_macip_lens ;
  u32 mss_l4len_idx ;
  u32 type_tucmd ;
  u8 l4_hdr ;
  u32 tmp ;
  struct iphdr *tmp___0 ;
  u32 tmp___1 ;
  struct ipv6hdr *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
#line 6505
  skb = first->skb;
#line 6506
  vlan_macip_lens = 0U;
#line 6507
  mss_l4len_idx = 0U;
#line 6508
  type_tucmd = 0U;
#line 6510
  if ((unsigned int )*((unsigned char *)skb + 124UL) != 12U) {
#line 6511
    if (*((unsigned int *)first + 11UL) == 0U) {
#line 6513
      return;
    } else {

    }
  } else {
#line 6515
    l4_hdr = 0U;
    {
#line 6517
    if ((int )first->protocol == 8) {
#line 6517
      goto case_8;
    } else {

    }
#line 6522
    if ((int )first->protocol == 56710) {
#line 6522
      goto case_56710;
    } else {

    }
#line 6526
    goto switch_default;
    case_8: /* CIL Label */ 
    {
#line 6518
    tmp = skb_network_header_len((struct sk_buff  const  *)skb);
#line 6518
    vlan_macip_lens = vlan_macip_lens | tmp;
#line 6519
    type_tucmd = type_tucmd | 1024U;
#line 6520
    tmp___0 = ip_hdr((struct sk_buff  const  *)skb);
#line 6520
    l4_hdr = tmp___0->protocol;
    }
#line 6521
    goto ldv_55173;
    case_56710: /* CIL Label */ 
    {
#line 6523
    tmp___1 = skb_network_header_len((struct sk_buff  const  *)skb);
#line 6523
    vlan_macip_lens = vlan_macip_lens | tmp___1;
#line 6524
    tmp___2 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 6524
    l4_hdr = tmp___2->nexthdr;
    }
#line 6525
    goto ldv_55173;
    switch_default: /* CIL Label */ 
    {
#line 6527
    tmp___3 = net_ratelimit();
#line 6527
    tmp___4 = __builtin_expect(tmp___3 != 0, 0L);
    }
#line 6527
    if (tmp___4 != 0L) {
      {
#line 6528
      dev_warn((struct device  const  *)tx_ring->dev, "partial checksum but proto=%x!\n",
               (int )first->protocol);
      }
    } else {

    }
#line 6532
    goto ldv_55173;
    switch_break: /* CIL Label */ ;
    }
    ldv_55173: ;
    {
#line 6536
    if ((int )l4_hdr == 6) {
#line 6536
      goto case_6;
    } else {

    }
#line 6541
    if ((int )l4_hdr == 132) {
#line 6541
      goto case_132;
    } else {

    }
#line 6546
    if ((int )l4_hdr == 17) {
#line 6546
      goto case_17;
    } else {

    }
#line 6550
    goto switch_default___0;
    case_6: /* CIL Label */ 
    {
#line 6537
    type_tucmd = type_tucmd | 2048U;
#line 6538
    tmp___5 = tcp_hdrlen((struct sk_buff  const  *)skb);
#line 6538
    mss_l4len_idx = tmp___5 << 8;
    }
#line 6540
    goto ldv_55177;
    case_132: /* CIL Label */ 
#line 6542
    type_tucmd = type_tucmd | 4096U;
#line 6543
    mss_l4len_idx = 3072U;
#line 6545
    goto ldv_55177;
    case_17: /* CIL Label */ 
#line 6547
    mss_l4len_idx = 2048U;
#line 6549
    goto ldv_55177;
    switch_default___0: /* CIL Label */ 
    {
#line 6551
    tmp___6 = net_ratelimit();
#line 6551
    tmp___7 = __builtin_expect(tmp___6 != 0, 0L);
    }
#line 6551
    if (tmp___7 != 0L) {
      {
#line 6552
      dev_warn((struct device  const  *)tx_ring->dev, "partial checksum but l4 proto=%x!\n",
               (int )l4_hdr);
      }
    } else {

    }
#line 6556
    goto ldv_55177;
    switch_break___0: /* CIL Label */ ;
    }
    ldv_55177: 
#line 6560
    first->tx_flags = first->tx_flags | 32U;
  }
  {
#line 6564
  tmp___8 = skb_network_offset((struct sk_buff  const  *)skb);
#line 6564
  vlan_macip_lens = vlan_macip_lens | (u32 )(tmp___8 << 9);
#line 6565
  vlan_macip_lens = vlan_macip_lens | (first->tx_flags & 4294901760U);
#line 6567
  ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0U, type_tucmd, mss_l4len_idx);
  }
#line 6568
  return;
}
}
#line 6576 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u32 ixgbe_tx_cmd_type(struct sk_buff *skb , u32 tx_flags ) 
{ 
  u32 cmd_type ;

  {
#line 6579
  cmd_type = 573571072U;
#line 6584
  cmd_type = cmd_type | (tx_flags & 1U) * 1073741824U;
#line 6588
  cmd_type = cmd_type | (tx_flags & 2U) * 1073741824U;
#line 6592
  cmd_type = cmd_type | (tx_flags & 4U) * 131072U;
#line 6596
  cmd_type = cmd_type ^ (unsigned int )skb->no_fcs * 33554432U;
#line 6598
  return (cmd_type);
}
}
#line 6601 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_olinfo_status(union ixgbe_adv_tx_desc *tx_desc , u32 tx_flags ,
                                   unsigned int paylen ) 
{ 
  u32 olinfo_status ;

  {
#line 6604
  olinfo_status = paylen << 14;
#line 6607
  olinfo_status = olinfo_status | (tx_flags & 32U) * 16U;
#line 6612
  olinfo_status = olinfo_status | (tx_flags & 16U) * 16U;
#line 6620
  olinfo_status = olinfo_status | (tx_flags & 8U) * 16U;
#line 6624
  tx_desc->read.olinfo_status = olinfo_status;
#line 6625
  return;
}
}
#line 6630 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_tx_map(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first ,
                         u8 const   hdr_len ) 
{ 
  struct sk_buff *skb ;
  struct ixgbe_tx_buffer *tx_buffer ;
  union ixgbe_adv_tx_desc *tx_desc ;
  struct skb_frag_struct *frag ;
  dma_addr_t dma ;
  unsigned int data_len ;
  unsigned int size ;
  u32 tx_flags ;
  u32 cmd_type ;
  u32 tmp ;
  u16 i ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  unsigned int tmp___4 ;
  struct netdev_queue *tmp___5 ;

  {
  {
#line 6634
  skb = first->skb;
#line 6640
  tx_flags = first->tx_flags;
#line 6641
  tmp = ixgbe_tx_cmd_type(skb, tx_flags);
#line 6641
  cmd_type = tmp;
#line 6642
  i = tx_ring->next_to_use;
#line 6644
  tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc + (unsigned long )i;
#line 6646
  ixgbe_tx_olinfo_status(tx_desc, tx_flags, skb->len - (unsigned int )hdr_len);
#line 6648
  size = skb_headlen((struct sk_buff  const  *)skb);
#line 6649
  data_len = skb->data_len;
  }
#line 6652
  if ((tx_flags & 128U) != 0U) {
#line 6653
    if (data_len <= 7U) {
#line 6654
      size = (size + data_len) - 8U;
#line 6655
      data_len = 0U;
    } else {
#line 6657
      data_len = data_len - 8U;
    }
  } else {

  }
  {
#line 6662
  dma = dma_map_single_attrs(tx_ring->dev, (void *)skb->data, (size_t )size, 1, (struct dma_attrs *)0);
#line 6664
  tx_buffer = first;
#line 6666
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6666
  frag = (struct skb_frag_struct *)(& ((struct skb_shared_info *)tmp___0)->frags);
  }
  ldv_55215: 
  {
#line 6667
  tmp___1 = dma_mapping_error(tx_ring->dev, dma);
  }
#line 6667
  if (tmp___1 != 0) {
#line 6668
    goto dma_error;
  } else {

  }
#line 6671
  tx_buffer->len = size;
#line 6672
  tx_buffer->dma = dma;
#line 6674
  tx_desc->read.buffer_addr = dma;
#line 6676
  goto ldv_55209;
  ldv_55208: 
#line 6677
  tx_desc->read.cmd_type_len = cmd_type ^ 16384U;
#line 6680
  i = (u16 )((int )i + 1);
#line 6681
  tx_desc = tx_desc + 1;
#line 6682
  if ((int )i == (int )tx_ring->count) {
#line 6683
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
#line 6684
    i = 0U;
  } else {

  }
#line 6686
  tx_desc->read.olinfo_status = 0U;
#line 6688
  dma = dma + 16384ULL;
#line 6689
  size = size - 16384U;
#line 6691
  tx_desc->read.buffer_addr = dma;
  ldv_55209: 
  {
#line 6676
  tmp___2 = __builtin_expect(size > 16384U, 0L);
  }
#line 6676
  if (tmp___2 != 0L) {
#line 6678
    goto ldv_55208;
  } else {

  }
  {
#line 6694
  tmp___3 = __builtin_expect(data_len == 0U, 1L);
  }
#line 6694
  if (tmp___3 != 0L) {
#line 6695
    goto ldv_55211;
  } else {

  }
#line 6697
  tx_desc->read.cmd_type_len = cmd_type ^ size;
#line 6699
  i = (u16 )((int )i + 1);
#line 6700
  tx_desc = tx_desc + 1;
#line 6701
  if ((int )i == (int )tx_ring->count) {
#line 6702
    tx_desc = (union ixgbe_adv_tx_desc *)tx_ring->desc;
#line 6703
    i = 0U;
  } else {

  }
  {
#line 6705
  tx_desc->read.olinfo_status = 0U;
#line 6708
  __min1 = data_len;
#line 6708
  tmp___4 = skb_frag_size((skb_frag_t const   *)frag);
#line 6708
  __min2 = tmp___4;
#line 6708
  size = __min1 < __min2 ? __min1 : __min2;
#line 6712
  data_len = data_len - size;
#line 6714
  dma = skb_frag_dma_map(tx_ring->dev, (skb_frag_t const   *)frag, 0UL, (size_t )size,
                         1);
#line 6717
  tx_buffer = tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )i;
#line 6666
  frag = frag + 1;
  }
#line 6718
  goto ldv_55215;
  ldv_55211: 
  {
#line 6721
  cmd_type = (cmd_type | size) | 150994944U;
#line 6722
  tx_desc->read.cmd_type_len = cmd_type;
#line 6724
  tmp___5 = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 6724
  netdev_tx_sent_queue(tmp___5, first->bytecount);
#line 6727
  first->time_stamp = jiffies;
#line 6737
  __asm__  volatile   ("sfence": : : "memory");
#line 6740
  first->next_to_watch = tx_desc;
#line 6742
  i = (u16 )((int )i + 1);
  }
#line 6743
  if ((int )i == (int )tx_ring->count) {
#line 6744
    i = 0U;
  } else {

  }
  {
#line 6746
  tx_ring->next_to_use = i;
#line 6749
  ixgbe_write_tail(tx_ring, (u32 )i);
  }
#line 6751
  return;
  dma_error: 
  {
#line 6753
  dev_err((struct device  const  *)tx_ring->dev, "TX DMA map failed\n");
  }
  ldv_55217: 
  {
#line 6757
  tx_buffer = tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )i;
#line 6758
  ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer);
  }
#line 6759
  if ((unsigned long )tx_buffer == (unsigned long )first) {
#line 6760
    goto ldv_55216;
  } else {

  }
#line 6761
  if ((unsigned int )i == 0U) {
#line 6762
    i = tx_ring->count;
  } else {

  }
#line 6763
  i = (u16 )((int )i - 1);
#line 6764
  goto ldv_55217;
  ldv_55216: 
#line 6766
  tx_ring->next_to_use = i;
#line 6767
  return;
}
}
#line 6769 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_atr(struct ixgbe_ring *ring , struct ixgbe_tx_buffer *first ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  union ixgbe_atr_hash_dword input ;
  union ixgbe_atr_hash_dword common ;
  union __anonunion_hdr_312 hdr ;
  struct tcphdr *th ;
  __be16 vlan_id ;
  __u16 tmp ;

  {
#line 6772
  q_vector = ring->q_vector;
#line 6773
  input.dword = 0U;
#line 6774
  common.dword = 0U;
#line 6784
  if ((unsigned long )q_vector == (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 6785
    return;
  } else {

  }
#line 6788
  if ((unsigned int )ring->__annonCompField96.__annonCompField95.atr_sample_rate == 0U) {
#line 6789
    return;
  } else {

  }
  {
#line 6791
  ring->__annonCompField96.__annonCompField95.atr_count = (u8 )((int )ring->__annonCompField96.__annonCompField95.atr_count + 1);
#line 6794
  hdr.network = skb_network_header((struct sk_buff  const  *)first->skb);
  }
#line 6797
  if (((unsigned int )first->protocol != 56710U || (unsigned int )(hdr.ipv6)->nexthdr != 6U) && ((unsigned int )first->protocol != 8U || (unsigned int )(hdr.ipv4)->protocol != 6U)) {
#line 6801
    return;
  } else {

  }
  {
#line 6803
  th = tcp_hdr((struct sk_buff  const  *)first->skb);
  }
#line 6806
  if ((unsigned long )th == (unsigned long )((struct tcphdr *)0) || (unsigned int )*((unsigned char *)th + 13UL) != 0U) {
#line 6807
    return;
  } else {

  }
#line 6810
  if ((unsigned int )*((unsigned char *)th + 13UL) == 0U && (int )ring->__annonCompField96.__annonCompField95.atr_count < (int )ring->__annonCompField96.__annonCompField95.atr_sample_rate) {
#line 6811
    return;
  } else {

  }
  {
#line 6814
  ring->__annonCompField96.__annonCompField95.atr_count = 0U;
#line 6816
  tmp = __fswab16((int )((__u16 )(first->tx_flags >> 16)));
#line 6816
  vlan_id = tmp;
#line 6825
  input.formatted.vlan_id = vlan_id;
  }
#line 6831
  if ((first->tx_flags & 65U) != 0U) {
#line 6832
    common.port.src = (__be16 )((unsigned int )((int )common.port.src ^ (int )th->dest) ^ 129U);
  } else {
#line 6834
    common.port.src = (__be16 )((int )common.port.src ^ ((int )th->dest ^ (int )first->protocol));
  }
#line 6835
  common.port.dst = (__be16 )((int )common.port.dst ^ (int )th->source);
#line 6837
  if ((unsigned int )first->protocol == 8U) {
#line 6838
    input.formatted.flow_type = 2U;
#line 6839
    common.ip = common.ip ^ ((hdr.ipv4)->saddr ^ (hdr.ipv4)->daddr);
  } else {
#line 6841
    input.formatted.flow_type = 6U;
#line 6842
    common.ip = common.ip ^ ((((((((hdr.ipv6)->saddr.in6_u.u6_addr32[0] ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[1]) ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[2]) ^ (hdr.ipv6)->saddr.in6_u.u6_addr32[3]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[0]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[1]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[2]) ^ (hdr.ipv6)->daddr.in6_u.u6_addr32[3]);
  }
  {
#line 6853
  ixgbe_fdir_add_signature_filter_82599(& (q_vector->adapter)->hw, input, common,
                                        (int )ring->queue_index);
  }
#line 6855
  return;
}
}
#line 6857 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int __ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring , u16 size ) 
{ 
  u16 tmp ;
  long tmp___0 ;

  {
  {
#line 6859
  netif_stop_subqueue(tx_ring->netdev, (int )tx_ring->queue_index);
#line 6863
  __asm__  volatile   ("mfence": : : "memory");
#line 6867
  tmp = ixgbe_desc_unused(tx_ring);
#line 6867
  tmp___0 = __builtin_expect((int )tmp < (int )size, 1L);
  }
#line 6867
  if (tmp___0 != 0L) {
#line 6868
    return (-16);
  } else {

  }
  {
#line 6871
  netif_start_subqueue(tx_ring->netdev, (int )tx_ring->queue_index);
#line 6872
  tx_ring->__annonCompField97.tx_stats.restart_queue = tx_ring->__annonCompField97.tx_stats.restart_queue + 1ULL;
  }
#line 6873
  return (0);
}
}
#line 6876 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static int ixgbe_maybe_stop_tx(struct ixgbe_ring *tx_ring , u16 size ) 
{ 
  u16 tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 6878
  tmp = ixgbe_desc_unused(tx_ring);
#line 6878
  tmp___0 = __builtin_expect((int )tmp >= (int )size, 1L);
  }
#line 6878
  if (tmp___0 != 0L) {
#line 6879
    return (0);
  } else {

  }
  {
#line 6880
  tmp___1 = __ixgbe_maybe_stop_tx(tx_ring, (int )size);
  }
#line 6880
  return (tmp___1);
}
}
#line 6883 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static u16 ixgbe_select_queue(struct net_device *dev , struct sk_buff *skb , void *accel_priv ,
                              u16 (*fallback)(struct net_device * , struct sk_buff * ) ) 
{ 
  struct ixgbe_fwd_adapter *fwd_adapter ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_ring_feature *f ;
  int txq ;
  __be16 tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___3 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  bool tmp___4 ;

  {
#line 6886
  fwd_adapter = (struct ixgbe_fwd_adapter *)accel_priv;
#line 6893
  if ((unsigned long )fwd_adapter != (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
#line 6894
    return ((int )skb->queue_mapping + (int )((u16 )fwd_adapter->tx_base_queue));
  } else {

  }
  {
#line 6902
  tmp = vlan_get_protocol((struct sk_buff  const  *)skb);
  }
  {
#line 6903
  if ((int )tmp == 1673) {
#line 6903
    goto case_1673;
  } else {

  }
#line 6904
  if ((int )tmp == 5257) {
#line 6904
    goto case_5257;
  } else {

  }
#line 6909
  goto switch_default;
  case_1673: /* CIL Label */ ;
  case_5257: /* CIL Label */ 
  {
#line 6905
  tmp___0 = netdev_priv((struct net_device  const  *)dev);
#line 6905
  adapter = (struct ixgbe_adapter *)tmp___0;
  }
#line 6907
  if ((adapter->flags & 2097152U) != 0U) {
#line 6908
    goto ldv_55252;
  } else {

  }
  switch_default: /* CIL Label */ 
  {
#line 6910
  tmp___1 = (*fallback)(dev, skb);
  }
#line 6910
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
  ldv_55252: 
  {
#line 6913
  f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 6916
  tmp___4 = skb_rx_queue_recorded((struct sk_buff  const  *)skb);
  }
#line 6916
  if ((int )tmp___4) {
    {
#line 6915
    tmp___3 = skb_get_rx_queue((struct sk_buff  const  *)skb);
#line 6916
    txq = (int )tmp___3;
    }
  } else {
#line 6916
    __vpp_verify = (void const   *)0;
    {
#line 6916
    if (4UL == 1UL) {
#line 6916
      goto case_1;
    } else {

    }
#line 6916
    if (4UL == 2UL) {
#line 6916
      goto case_2___0;
    } else {

    }
#line 6916
    if (4UL == 4UL) {
#line 6916
      goto case_4___1;
    } else {

    }
#line 6916
    if (4UL == 8UL) {
#line 6916
      goto case_8___2;
    } else {

    }
#line 6916
    goto switch_default___4;
    case_1: /* CIL Label */ ;
    {
#line 6916
    if (4UL == 1UL) {
#line 6916
      goto case_1___0;
    } else {

    }
#line 6916
    if (4UL == 2UL) {
#line 6916
      goto case_2;
    } else {

    }
#line 6916
    if (4UL == 4UL) {
#line 6916
      goto case_4;
    } else {

    }
#line 6916
    if (4UL == 8UL) {
#line 6916
      goto case_8;
    } else {

    }
#line 6916
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 6916
    __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 6916
    goto ldv_55259;
    case_2: /* CIL Label */ 
#line 6916
    __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 6916
    goto ldv_55259;
    case_4: /* CIL Label */ 
#line 6916
    __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 6916
    goto ldv_55259;
    case_8: /* CIL Label */ 
#line 6916
    __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 6916
    goto ldv_55259;
    switch_default___0: /* CIL Label */ 
    {
#line 6916
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_55259: 
#line 6916
    pscr_ret__ = pfo_ret__;
#line 6916
    goto ldv_55265;
    case_2___0: /* CIL Label */ ;
    {
#line 6916
    if (4UL == 1UL) {
#line 6916
      goto case_1___1;
    } else {

    }
#line 6916
    if (4UL == 2UL) {
#line 6916
      goto case_2___1;
    } else {

    }
#line 6916
    if (4UL == 4UL) {
#line 6916
      goto case_4___0;
    } else {

    }
#line 6916
    if (4UL == 8UL) {
#line 6916
      goto case_8___0;
    } else {

    }
#line 6916
    goto switch_default___1;
    case_1___1: /* CIL Label */ 
#line 6916
    __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 6916
    goto ldv_55269;
    case_2___1: /* CIL Label */ 
#line 6916
    __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 6916
    goto ldv_55269;
    case_4___0: /* CIL Label */ 
#line 6916
    __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 6916
    goto ldv_55269;
    case_8___0: /* CIL Label */ 
#line 6916
    __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 6916
    goto ldv_55269;
    switch_default___1: /* CIL Label */ 
    {
#line 6916
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_55269: 
#line 6916
    pscr_ret__ = pfo_ret_____0;
#line 6916
    goto ldv_55265;
    case_4___1: /* CIL Label */ ;
    {
#line 6916
    if (4UL == 1UL) {
#line 6916
      goto case_1___2;
    } else {

    }
#line 6916
    if (4UL == 2UL) {
#line 6916
      goto case_2___2;
    } else {

    }
#line 6916
    if (4UL == 4UL) {
#line 6916
      goto case_4___2;
    } else {

    }
#line 6916
    if (4UL == 8UL) {
#line 6916
      goto case_8___1;
    } else {

    }
#line 6916
    goto switch_default___2;
    case_1___2: /* CIL Label */ 
#line 6916
    __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 6916
    goto ldv_55278;
    case_2___2: /* CIL Label */ 
#line 6916
    __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 6916
    goto ldv_55278;
    case_4___2: /* CIL Label */ 
#line 6916
    __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 6916
    goto ldv_55278;
    case_8___1: /* CIL Label */ 
#line 6916
    __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 6916
    goto ldv_55278;
    switch_default___2: /* CIL Label */ 
    {
#line 6916
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_55278: 
#line 6916
    pscr_ret__ = pfo_ret_____1;
#line 6916
    goto ldv_55265;
    case_8___2: /* CIL Label */ ;
    {
#line 6916
    if (4UL == 1UL) {
#line 6916
      goto case_1___3;
    } else {

    }
#line 6916
    if (4UL == 2UL) {
#line 6916
      goto case_2___3;
    } else {

    }
#line 6916
    if (4UL == 4UL) {
#line 6916
      goto case_4___3;
    } else {

    }
#line 6916
    if (4UL == 8UL) {
#line 6916
      goto case_8___3;
    } else {

    }
#line 6916
    goto switch_default___3;
    case_1___3: /* CIL Label */ 
#line 6916
    __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 6916
    goto ldv_55287;
    case_2___3: /* CIL Label */ 
#line 6916
    __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 6916
    goto ldv_55287;
    case_4___3: /* CIL Label */ 
#line 6916
    __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 6916
    goto ldv_55287;
    case_8___3: /* CIL Label */ 
#line 6916
    __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 6916
    goto ldv_55287;
    switch_default___3: /* CIL Label */ 
    {
#line 6916
    __bad_percpu_size();
    }
    switch_break___4: /* CIL Label */ ;
    }
    ldv_55287: 
#line 6916
    pscr_ret__ = pfo_ret_____2;
#line 6916
    goto ldv_55265;
    switch_default___4: /* CIL Label */ 
    {
#line 6916
    __bad_size_call_parameter();
    }
#line 6916
    goto ldv_55265;
    switch_break___0: /* CIL Label */ ;
    }
    ldv_55265: 
#line 6916
    txq = pscr_ret__;
  }
#line 6918
  goto ldv_55296;
  ldv_55295: 
#line 6919
  txq = txq - (int )f->indices;
  ldv_55296: ;
#line 6918
  if (txq >= (int )f->indices) {
#line 6920
    goto ldv_55295;
  } else {

  }

#line 6921
  return ((int )((u16 )txq) + (int )f->offset);
}
}
#line 6927 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb , struct ixgbe_adapter *adapter ,
                                  struct ixgbe_ring *tx_ring ) 
{ 
  struct ixgbe_tx_buffer *first ;
  int tso ;
  u32 tx_flags ;
  unsigned short f ;
  u16 count ;
  unsigned int tmp ;
  __be16 protocol ;
  u8 hdr_len ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  struct vlan_hdr *vhdr ;
  struct vlan_hdr _vhdr ;
  void *tmp___3 ;
  __u16 tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  long tmp___8 ;
  struct vlan_ethhdr *vhdr___0 ;
  int tmp___9 ;
  int tmp___10 ;
  __u16 tmp___11 ;
  int tmp___12 ;

  {
  {
#line 6933
  tx_flags = 0U;
#line 6935
  tmp = skb_headlen((struct sk_buff  const  *)skb);
#line 6935
  count = (u16 )((tmp + 16383U) / 16384U);
#line 6936
  protocol = skb->protocol;
#line 6937
  hdr_len = 0U;
#line 6946
  f = 0U;
  }
#line 6946
  goto ldv_55311;
  ldv_55310: 
  {
#line 6947
  tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6947
  count = (int )count + (int )((u16 )((((struct skb_shared_info *)tmp___0)->frags[(int )f].size + 16383U) / 16384U));
#line 6946
  f = (unsigned short )((int )f + 1);
  }
  ldv_55311: 
  {
#line 6946
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
  }
#line 6946
  if ((int )f < (int )((unsigned short )((struct skb_shared_info *)tmp___1)->nr_frags)) {
#line 6948
    goto ldv_55310;
  } else {

  }
  {
#line 6949
  tmp___2 = ixgbe_maybe_stop_tx(tx_ring, (int )((unsigned int )count + 3U));
  }
#line 6949
  if (tmp___2 != 0) {
#line 6950
    tx_ring->__annonCompField97.tx_stats.tx_busy = tx_ring->__annonCompField97.tx_stats.tx_busy + 1ULL;
#line 6951
    return (16);
  } else {

  }
#line 6955
  first = tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )tx_ring->next_to_use;
#line 6956
  first->skb = skb;
#line 6957
  first->bytecount = skb->len;
#line 6958
  first->gso_segs = 1U;
#line 6961
  if (((int )skb->vlan_tci & 4096) != 0) {
#line 6962
    tx_flags = tx_flags | (u32 )(((int )skb->vlan_tci & -4097) << 16);
#line 6963
    tx_flags = tx_flags | 1U;
  } else
#line 6965
  if ((unsigned int )protocol == 129U) {
    {
#line 6967
    tmp___3 = skb_header_pointer((struct sk_buff  const  *)skb, 14, 4, (void *)(& _vhdr));
#line 6967
    vhdr = (struct vlan_hdr *)tmp___3;
    }
#line 6968
    if ((unsigned long )vhdr == (unsigned long )((struct vlan_hdr *)0)) {
#line 6969
      goto out_drop;
    } else {

    }
    {
#line 6971
    protocol = vhdr->h_vlan_encapsulated_proto;
#line 6972
    tmp___4 = __fswab16((int )vhdr->h_vlan_TCI);
#line 6972
    tx_flags = tx_flags | (u32 )((int )tmp___4 << 16);
#line 6974
    tx_flags = tx_flags | 64U;
    }
  } else {

  }
  {
#line 6977
  skb_tx_timestamp(skb);
#line 6979
  tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6979
  tmp___8 = __builtin_expect((long )((struct skb_shared_info *)tmp___7)->tx_flags & 1L,
                             0L);
  }
#line 6979
  if (tmp___8 != 0L) {
    {
#line 6980
    tmp___5 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6980
    tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 6980
    ((struct skb_shared_info *)tmp___5)->tx_flags = (__u8 )((unsigned int )((struct skb_shared_info *)tmp___6)->tx_flags | 4U);
#line 6981
    tx_flags = tx_flags | 4U;
#line 6984
    adapter->ptp_tx_skb = skb_get(skb);
#line 6985
    adapter->ptp_tx_start = jiffies;
#line 6986
    schedule_work(& adapter->ptp_tx_work);
    }
  } else {

  }
#line 6994
  if ((adapter->flags & 8388608U) != 0U) {
#line 6995
    tx_flags = tx_flags | 8U;
  } else {

  }
#line 6999
  if ((adapter->flags & 4096U) != 0U && ((tx_flags & 65U) != 0U || skb->priority != 7U)) {
#line 7002
    tx_flags = tx_flags & 536870911U;
#line 7003
    tx_flags = tx_flags | (skb->priority << 29);
#line 7005
    if ((tx_flags & 64U) != 0U) {
      {
#line 7007
      tmp___9 = skb_header_cloned((struct sk_buff  const  *)skb);
      }
#line 7007
      if (tmp___9 != 0) {
        {
#line 7007
        tmp___10 = pskb_expand_head(skb, 0, 0, 32U);
        }
#line 7007
        if (tmp___10 != 0) {
#line 7009
          goto out_drop;
        } else {

        }
      } else {

      }
      {
#line 7010
      vhdr___0 = (struct vlan_ethhdr *)skb->data;
#line 7011
      tmp___11 = __fswab16((int )((__u16 )(tx_flags >> 16)));
#line 7011
      vhdr___0->h_vlan_TCI = tmp___11;
      }
    } else {
#line 7014
      tx_flags = tx_flags | 1U;
    }
  } else {

  }
#line 7019
  first->tx_flags = tx_flags;
#line 7020
  first->protocol = protocol;
#line 7024
  if ((unsigned int )protocol == 1673U && ((tx_ring->netdev)->features & 136314880ULL) != 0ULL) {
    {
#line 7026
    tso = ixgbe_fso(tx_ring, first, & hdr_len);
    }
#line 7027
    if (tso < 0) {
#line 7028
      goto out_drop;
    } else {

    }
#line 7030
    goto xmit_fcoe;
  } else {

  }
  {
#line 7034
  tso = ixgbe_tso(tx_ring, first, & hdr_len);
  }
#line 7035
  if (tso < 0) {
#line 7036
    goto out_drop;
  } else
#line 7037
  if (tso == 0) {
    {
#line 7038
    ixgbe_tx_csum(tx_ring, first);
    }
  } else {

  }
  {
#line 7041
  tmp___12 = constant_test_bit(0L, (unsigned long const volatile   *)(& tx_ring->state));
  }
#line 7041
  if (tmp___12 != 0) {
    {
#line 7042
    ixgbe_atr(tx_ring, first);
    }
  } else {

  }
  xmit_fcoe: 
  {
#line 7047
  ixgbe_tx_map(tx_ring, first, (int )hdr_len);
#line 7049
  ixgbe_maybe_stop_tx(tx_ring, 21);
  }
#line 7051
  return (0);
  out_drop: 
  {
#line 7054
  dev_kfree_skb_any(first->skb);
#line 7055
  first->skb = (struct sk_buff *)0;
  }
#line 7057
  return (0);
}
}
#line 7060 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_tx_t __ixgbe_xmit_frame(struct sk_buff *skb , struct net_device *netdev ,
                                      struct ixgbe_ring *ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_ring *tx_ring ;
  int tmp___0 ;
  long tmp___1 ;
  netdev_tx_t tmp___2 ;

  {
  {
#line 7064
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7064
  adapter = (struct ixgbe_adapter *)tmp;
#line 7071
  tmp___1 = __builtin_expect(skb->len <= 16U, 0L);
  }
#line 7071
  if (tmp___1 != 0L) {
    {
#line 7072
    tmp___0 = skb_pad(skb, (int )(17U - skb->len));
    }
#line 7072
    if (tmp___0 != 0) {
#line 7073
      return (0);
    } else {

    }
    {
#line 7074
    skb->len = 17U;
#line 7075
    skb_set_tail_pointer(skb, 17);
    }
  } else {

  }
  {
#line 7078
  tx_ring = (unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0) ? ring : adapter->tx_ring[(int )skb->queue_mapping];
#line 7080
  tmp___2 = ixgbe_xmit_frame_ring(skb, adapter, tx_ring);
  }
#line 7080
  return (tmp___2);
}
}
#line 7083 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_tx_t ixgbe_xmit_frame(struct sk_buff *skb , struct net_device *netdev ) 
{ 
  netdev_tx_t tmp ;

  {
  {
#line 7086
  tmp = __ixgbe_xmit_frame(skb, netdev, (struct ixgbe_ring *)0);
  }
#line 7086
  return (tmp);
}
}
#line 7096 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_set_mac(struct net_device *netdev , void *p ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  struct sockaddr *addr ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 7098
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7098
  adapter = (struct ixgbe_adapter *)tmp;
#line 7099
  hw = & adapter->hw;
#line 7100
  addr = (struct sockaddr *)p;
#line 7102
  tmp___0 = is_valid_ether_addr((u8 const   *)(& addr->sa_data));
  }
#line 7102
  if (tmp___0) {
#line 7102
    tmp___1 = 0;
  } else {
#line 7102
    tmp___1 = 1;
  }
#line 7102
  if (tmp___1) {
#line 7103
    return (-99);
  } else {

  }
  {
#line 7105
  memcpy((void *)netdev->dev_addr, (void const   *)(& addr->sa_data), (size_t )netdev->addr_len);
#line 7106
  memcpy((void *)(& hw->mac.addr), (void const   *)(& addr->sa_data), (size_t )netdev->addr_len);
#line 7108
  (*(hw->mac.ops.set_rar))(hw, 0U, (u8 *)(& hw->mac.addr), (u32 )adapter->ring_feature[1].offset,
                           2147483648U);
  }
#line 7110
  return (0);
}
}
#line 7114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_mdio_read(struct net_device *netdev , int prtad , int devad , u16 addr ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u16 value ;
  int rc ;

  {
  {
#line 7116
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7116
  adapter = (struct ixgbe_adapter *)tmp;
#line 7117
  hw = & adapter->hw;
  }
#line 7121
  if (prtad != hw->phy.mdio.prtad) {
#line 7122
    return (-22);
  } else {

  }
  {
#line 7123
  rc = (*(hw->phy.ops.read_reg))(hw, (u32 )addr, (u32 )devad, & value);
  }
#line 7124
  if (rc == 0) {
#line 7125
    rc = (int )value;
  } else {

  }
#line 7126
  return (rc);
}
}
#line 7129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_mdio_write(struct net_device *netdev , int prtad , int devad , u16 addr ,
                            u16 value ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  s32 tmp___0 ;

  {
  {
#line 7132
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7132
  adapter = (struct ixgbe_adapter *)tmp;
#line 7133
  hw = & adapter->hw;
  }
#line 7135
  if (prtad != hw->phy.mdio.prtad) {
#line 7136
    return (-22);
  } else {

  }
  {
#line 7137
  tmp___0 = (*(hw->phy.ops.write_reg))(hw, (u32 )addr, (u32 )devad, (int )value);
  }
#line 7137
  return (tmp___0);
}
}
#line 7140 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ioctl(struct net_device *netdev , struct ifreq *req , int cmd ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  struct mii_ioctl_data *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 7142
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7142
  adapter = (struct ixgbe_adapter *)tmp;
  }
  {
#line 7145
  if (cmd == 35248) {
#line 7145
    goto case_35248;
  } else {

  }
#line 7147
  goto switch_default;
  case_35248: /* CIL Label */ 
  {
#line 7146
  tmp___0 = ixgbe_ptp_hwtstamp_ioctl(adapter, req, cmd);
  }
#line 7146
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
#line 7148
  tmp___1 = if_mii(req);
#line 7148
  tmp___2 = mdio_mii_ioctl((struct mdio_if_info  const  *)(& adapter->hw.phy.mdio),
                           tmp___1, cmd);
  }
#line 7148
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 7159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_add_sanmac_netdev(struct net_device *dev ) 
{ 
  int err ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  bool tmp___0 ;

  {
  {
#line 7161
  err = 0;
#line 7162
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7162
  adapter = (struct ixgbe_adapter *)tmp;
#line 7163
  hw = & adapter->hw;
#line 7165
  tmp___0 = is_valid_ether_addr((u8 const   *)(& hw->mac.san_addr));
  }
#line 7165
  if ((int )tmp___0) {
    {
#line 7166
    rtnl_lock();
#line 7167
    err = dev_addr_add(dev, (unsigned char const   *)(& hw->mac.san_addr), 2);
#line 7168
    rtnl_unlock();
#line 7171
    (*(hw->mac.ops.set_vmdq_san_mac))(hw, (u32 )adapter->ring_feature[1].offset);
    }
  } else {

  }
#line 7173
  return (err);
}
}
#line 7183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_del_sanmac_netdev(struct net_device *dev ) 
{ 
  int err ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_mac_info *mac ;
  bool tmp___0 ;

  {
  {
#line 7185
  err = 0;
#line 7186
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7186
  adapter = (struct ixgbe_adapter *)tmp;
#line 7187
  mac = & adapter->hw.mac;
#line 7189
  tmp___0 = is_valid_ether_addr((u8 const   *)(& mac->san_addr));
  }
#line 7189
  if ((int )tmp___0) {
    {
#line 7190
    rtnl_lock();
#line 7191
    err = dev_addr_del(dev, (unsigned char const   *)(& mac->san_addr), 2);
#line 7192
    rtnl_unlock();
    }
  } else {

  }
#line 7194
  return (err);
}
}
#line 7203 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_netpoll(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 7205
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7205
  adapter = (struct ixgbe_adapter *)tmp;
#line 7209
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 7209
  if (tmp___0 != 0) {
#line 7210
    return;
  } else {

  }
#line 7212
  adapter->flags = adapter->flags | 128U;
#line 7213
  if ((adapter->flags & 8U) != 0U) {
#line 7214
    i = 0;
#line 7214
    goto ldv_55381;
    ldv_55380: 
    {
#line 7215
    ixgbe_msix_clean_rings(0, (void *)adapter->q_vector[i]);
#line 7214
    i = i + 1;
    }
    ldv_55381: ;
#line 7214
    if (i < adapter->num_q_vectors) {
#line 7216
      goto ldv_55380;
    } else {

    }

  } else {
    {
#line 7217
    ixgbe_intr((int )(adapter->pdev)->irq, (void *)netdev);
    }
  }
#line 7219
  adapter->flags = adapter->flags & 4294967167U;
#line 7220
  return;
}
}
#line 7223 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct rtnl_link_stats64 *ixgbe_get_stats64(struct net_device *netdev , struct rtnl_link_stats64 *stats ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int i ;
  struct ixgbe_ring *ring ;
  u64 bytes ;
  u64 packets ;
  unsigned int start ;
  bool tmp___0 ;
  struct ixgbe_ring *ring___0 ;
  u64 bytes___0 ;
  u64 packets___0 ;
  unsigned int start___0 ;
  bool tmp___1 ;

  {
  {
#line 7226
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7226
  adapter = (struct ixgbe_adapter *)tmp;
#line 7229
  rcu_read_lock();
#line 7230
  i = 0;
  }
#line 7230
  goto ldv_55396;
  ldv_55395: 
#line 7231
  ring = *((struct ixgbe_ring * volatile  *)(& adapter->rx_ring) + (unsigned long )i);
#line 7235
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
    ldv_55393: 
    {
#line 7237
    start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& ring->syncp));
#line 7238
    packets = ring->stats.packets;
#line 7239
    bytes = ring->stats.bytes;
#line 7240
    tmp___0 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& ring->syncp),
                                       start);
    }
#line 7240
    if ((int )tmp___0) {
#line 7242
      goto ldv_55393;
    } else {

    }
#line 7241
    stats->rx_packets = stats->rx_packets + packets;
#line 7242
    stats->rx_bytes = stats->rx_bytes + bytes;
  } else {

  }
#line 7230
  i = i + 1;
  ldv_55396: ;
#line 7230
  if (i < adapter->num_rx_queues) {
#line 7232
    goto ldv_55395;
  } else {

  }
#line 7246
  i = 0;
#line 7246
  goto ldv_55405;
  ldv_55404: 
#line 7247
  ring___0 = *((struct ixgbe_ring * volatile  *)(& adapter->tx_ring) + (unsigned long )i);
#line 7251
  if ((unsigned long )ring___0 != (unsigned long )((struct ixgbe_ring *)0)) {
    ldv_55402: 
    {
#line 7253
    start___0 = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& ring___0->syncp));
#line 7254
    packets___0 = ring___0->stats.packets;
#line 7255
    bytes___0 = ring___0->stats.bytes;
#line 7256
    tmp___1 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& ring___0->syncp),
                                       start___0);
    }
#line 7256
    if ((int )tmp___1) {
#line 7258
      goto ldv_55402;
    } else {

    }
#line 7257
    stats->tx_packets = stats->tx_packets + packets___0;
#line 7258
    stats->tx_bytes = stats->tx_bytes + bytes___0;
  } else {

  }
#line 7246
  i = i + 1;
  ldv_55405: ;
#line 7246
  if (i < adapter->num_tx_queues) {
#line 7248
    goto ldv_55404;
  } else {

  }
  {
#line 7261
  rcu_read_unlock();
#line 7263
  stats->multicast = (__u64 )netdev->stats.multicast;
#line 7264
  stats->rx_errors = (__u64 )netdev->stats.rx_errors;
#line 7265
  stats->rx_length_errors = (__u64 )netdev->stats.rx_length_errors;
#line 7266
  stats->rx_crc_errors = (__u64 )netdev->stats.rx_crc_errors;
#line 7267
  stats->rx_missed_errors = (__u64 )netdev->stats.rx_missed_errors;
  }
#line 7268
  return (stats);
}
}
#line 7280 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_validate_rtr(struct ixgbe_adapter *adapter , u8 tc ) 
{ 
  struct ixgbe_hw *hw ;
  u32 reg ;
  u32 rsave ;
  int i ;
  u8 up2tc ;

  {
#line 7282
  hw = & adapter->hw;
#line 7289
  if ((unsigned int )hw->mac.type == 1U) {
#line 7290
    return;
  } else {

  }
  {
#line 7292
  reg = ixgbe_read_reg(hw, 12320U);
#line 7293
  rsave = reg;
#line 7295
  i = 0;
  }
#line 7295
  goto ldv_55417;
  ldv_55416: 
#line 7296
  up2tc = (u8 )(reg >> i * 3);
#line 7299
  if ((int )up2tc > (int )tc) {
#line 7300
    reg = reg & 4294967239U;
  } else {

  }
#line 7295
  i = i + 1;
  ldv_55417: ;
#line 7295
  if (i <= 7) {
#line 7297
    goto ldv_55416;
  } else {

  }

#line 7303
  if (reg != rsave) {
    {
#line 7304
    ixgbe_write_reg(hw, 12320U, reg);
    }
  } else {

  }
#line 7306
  return;
}
}
#line 7315 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_set_prio_tc_map(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *dev ;
  struct ixgbe_dcb_config *dcb_cfg ;
  struct ieee_ets *ets ;
  u8 prio ;
  u8 tc ;

  {
#line 7317
  dev = adapter->netdev;
#line 7318
  dcb_cfg = & adapter->dcb_cfg;
#line 7319
  ets = adapter->ixgbe_ieee_ets;
#line 7322
  prio = 0U;
#line 7322
  goto ldv_55428;
  ldv_55427: 
#line 7323
  tc = 0U;
#line 7325
  if (((int )adapter->dcbx_cap & 4) != 0) {
    {
#line 7326
    tc = ixgbe_dcb_get_tc_from_up(dcb_cfg, 0, (int )prio);
    }
  } else
#line 7327
  if ((unsigned long )ets != (unsigned long )((struct ieee_ets *)0)) {
#line 7328
    tc = ets->prio_tc[(int )prio];
  } else {

  }
  {
#line 7330
  netdev_set_prio_tc_map(dev, (int )prio, (int )tc);
#line 7322
  prio = (u8 )((int )prio + 1);
  }
  ldv_55428: ;
#line 7322
  if ((unsigned int )prio <= 7U) {
#line 7324
    goto ldv_55427;
  } else {

  }

#line 7329
  return;
}
}
#line 7341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_setup_tc(struct net_device *dev , u8 tc ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  bool pools ;
  unsigned long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 7343
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7343
  adapter = (struct ixgbe_adapter *)tmp;
#line 7344
  hw = & adapter->hw;
  }
#line 7348
  if ((int )tc > (int )adapter->dcb_cfg.num_tcs.pg_tcs || ((unsigned int )hw->mac.type == 1U && (unsigned int )tc <= 7U)) {
#line 7351
    return (-22);
  } else {

  }
  {
#line 7353
  tmp___0 = find_first_zero_bit((unsigned long const   *)(& adapter->fwd_bitmask),
                                32UL);
#line 7353
  pools = tmp___0 > 1UL;
  }
#line 7354
  if (((unsigned int )tc != 0U && (int )pools) && adapter->num_rx_pools > 8) {
#line 7355
    return (-16);
  } else {

  }
  {
#line 7361
  tmp___1 = netif_running((struct net_device  const  *)dev);
  }
#line 7361
  if ((int )tmp___1) {
    {
#line 7362
    ixgbe_close(dev);
    }
  } else {

  }
  {
#line 7363
  ixgbe_clear_interrupt_scheme(adapter);
  }
#line 7366
  if ((unsigned int )tc != 0U) {
    {
#line 7367
    netdev_set_num_tc(dev, (int )tc);
#line 7368
    ixgbe_set_prio_tc_map(adapter);
#line 7370
    adapter->flags = adapter->flags | 4096U;
    }
#line 7372
    if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 7373
      adapter->last_lfc_mode = adapter->hw.fc.requested_mode;
#line 7374
      adapter->hw.fc.requested_mode = 0;
    } else {

    }
  } else {
    {
#line 7377
    netdev_reset_tc(dev);
    }
#line 7379
    if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 7380
      adapter->hw.fc.requested_mode = adapter->last_lfc_mode;
    } else {

    }
#line 7382
    adapter->flags = adapter->flags & 4294963199U;
#line 7384
    adapter->temp_dcb_cfg.pfc_mode_enable = 0;
#line 7385
    adapter->dcb_cfg.pfc_mode_enable = 0;
  }
  {
#line 7388
  ixgbe_validate_rtr(adapter, (int )tc);
#line 7391
  ixgbe_init_interrupt_scheme(adapter);
#line 7393
  tmp___3 = netif_running((struct net_device  const  *)dev);
  }
#line 7393
  if ((int )tmp___3) {
    {
#line 7394
    tmp___2 = ixgbe_open(dev);
    }
#line 7394
    return (tmp___2);
  } else {

  }
#line 7396
  return (0);
}
}
#line 7400 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int tmp ;

  {
  {
#line 7402
  netdev = adapter->netdev;
#line 7404
  rtnl_lock();
#line 7405
  tmp = netdev_get_num_tc(netdev);
#line 7405
  ixgbe_setup_tc(netdev, (int )((u8 )tmp));
#line 7406
  rtnl_unlock();
  }
#line 7407
  return;
}
}
#line 7410 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
void ixgbe_do_reset(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
  {
#line 7412
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7412
  adapter = (struct ixgbe_adapter *)tmp;
#line 7414
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 7414
  if ((int )tmp___0) {
    {
#line 7415
    ixgbe_reinit_locked(adapter);
    }
  } else {
    {
#line 7417
    ixgbe_reset(adapter);
    }
  }
#line 7418
  return;
}
}
#line 7420 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static netdev_features_t ixgbe_fix_features(struct net_device *netdev , netdev_features_t features ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 7423
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7423
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 7426
  if ((features & 4294967296ULL) == 0ULL) {
#line 7427
    features = features & 0xffffffffffff7fffULL;
  } else {

  }
#line 7430
  if ((adapter->flags2 & 1U) == 0U) {
#line 7431
    features = features & 0xffffffffffff7fffULL;
  } else {

  }
#line 7433
  return (features);
}
}
#line 7436 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_set_features(struct net_device *netdev , netdev_features_t features ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  netdev_features_t changed ;
  bool need_reset ;
  int tmp___0 ;

  {
  {
#line 7439
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 7439
  adapter = (struct ixgbe_adapter *)tmp;
#line 7440
  changed = netdev->features ^ features;
#line 7441
  need_reset = 0;
  }
#line 7444
  if ((features & 32768ULL) == 0ULL) {
#line 7445
    if ((adapter->flags2 & 2U) != 0U) {
#line 7446
      need_reset = 1;
    } else {

    }
#line 7447
    adapter->flags2 = adapter->flags2 & 4294967293U;
  } else
#line 7448
  if (*((unsigned int *)adapter + 135UL) == 1U) {
#line 7450
    if ((unsigned int )adapter->rx_itr_setting == 1U || (unsigned int )adapter->rx_itr_setting > 24U) {
#line 7452
      adapter->flags2 = adapter->flags2 | 2U;
#line 7453
      need_reset = 1;
    } else
#line 7454
    if (((changed ^ features) & 32768ULL) != 0ULL) {
#line 7455
      if (((int )adapter->msg_enable & 2) != 0) {
        {
#line 7456
        netdev_info((struct net_device  const  *)adapter->netdev, "rx-usecs set too low, disabling RSC\n");
        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 7465
  if ((features & 1073741824ULL) == 1073741824ULL) {
#line 7465
    goto case_1073741824;
  } else {

  }
#line 7473
  goto switch_default;
  case_1073741824: /* CIL Label */ ;
#line 7467
  if ((adapter->flags & 524288U) == 0U) {
#line 7468
    need_reset = 1;
  } else {

  }
#line 7470
  adapter->flags = adapter->flags & 4294705151U;
#line 7471
  adapter->flags = adapter->flags | 524288U;
#line 7472
  goto ldv_55458;
  switch_default: /* CIL Label */ ;
#line 7475
  if ((adapter->flags & 524288U) != 0U) {
#line 7476
    need_reset = 1;
  } else {

  }
#line 7478
  adapter->flags = adapter->flags & 4294443007U;
#line 7481
  if ((adapter->flags & 8388608U) != 0U) {
#line 7482
    goto ldv_55458;
  } else {

  }
  {
#line 7485
  tmp___0 = netdev_get_num_tc(netdev);
  }
#line 7485
  if (tmp___0 > 1) {
#line 7486
    goto ldv_55458;
  } else {

  }
#line 7489
  if ((unsigned int )adapter->ring_feature[2].limit <= 1U) {
#line 7490
    goto ldv_55458;
  } else {

  }
#line 7493
  if (adapter->atr_sample_rate == 0U) {
#line 7494
    goto ldv_55458;
  } else {

  }
#line 7496
  adapter->flags = adapter->flags | 262144U;
#line 7497
  goto ldv_55458;
  switch_break: /* CIL Label */ ;
  }
  ldv_55458: ;
#line 7500
  if ((features & 256ULL) != 0ULL) {
    {
#line 7501
    ixgbe_vlan_strip_enable(adapter);
    }
  } else {
    {
#line 7503
    ixgbe_vlan_strip_disable(adapter);
    }
  }
#line 7505
  if ((changed & 68719476736ULL) != 0ULL) {
#line 7506
    need_reset = 1;
  } else {

  }
#line 7508
  netdev->features = features;
#line 7509
  if ((int )need_reset) {
    {
#line 7510
    ixgbe_do_reset(netdev);
    }
  } else {

  }
#line 7512
  return (0);
}
}
#line 7515 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_fdb_add(struct ndmsg *ndm , struct nlattr **tb , struct net_device *dev ,
                             unsigned char const   *addr , u16 flags ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  int tmp___0 ;
  u32 rar_uc_entries ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 7520
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7520
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 7523
  if ((adapter->flags & 8388608U) == 0U) {
    {
#line 7524
    tmp___0 = ndo_dflt_fdb_add(ndm, tb, dev, addr, (int )flags);
    }
#line 7524
    return (tmp___0);
  } else {

  }
#line 7529
  if ((unsigned int )ndm->ndm_state != 0U && ((int )ndm->ndm_state & 128) == 0) {
    {
#line 7530
    printk("\016ixgbe: %s: FDB only supports static addresses\n", (char *)(& ixgbe_driver_name));
    }
#line 7532
    return (-22);
  } else {

  }
  {
#line 7535
  tmp___2 = is_unicast_ether_addr(addr);
  }
#line 7535
  if ((int )tmp___2) {
#line 7535
    goto _L;
  } else {
    {
#line 7535
    tmp___3 = is_link_local_ether_addr(addr);
    }
#line 7535
    if ((int )tmp___3) {
      _L: /* CIL Label */ 
#line 7536
      rar_uc_entries = 15U;
#line 7538
      if ((u32 )dev->uc.count < rar_uc_entries) {
        {
#line 7539
        err = dev_uc_add_excl(dev, addr);
        }
      } else {
#line 7541
        err = -12;
      }
    } else {
      {
#line 7542
      tmp___1 = is_multicast_ether_addr(addr);
      }
#line 7542
      if ((int )tmp___1) {
        {
#line 7543
        err = dev_mc_add_excl(dev, addr);
        }
      } else {
#line 7545
        err = -22;
      }
    }
  }
#line 7549
  if (err == -17 && ((int )flags & 512) == 0) {
#line 7550
    err = 0;
  } else {

  }
#line 7552
  return (err);
}
}
#line 7555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_bridge_setlink(struct net_device *dev , struct nlmsghdr *nlh ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct nlattr *attr ;
  struct nlattr *br_spec ;
  int rem ;
  void *tmp___0 ;
  __u16 mode ;
  u32 reg ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 7558
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7558
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 7562
  if ((adapter->flags & 8388608U) == 0U) {
#line 7563
    return (-95);
  } else {

  }
  {
#line 7565
  br_spec = nlmsg_find_attr((struct nlmsghdr  const  *)nlh, 16, 26);
#line 7567
  tmp___0 = nla_data((struct nlattr  const  *)br_spec);
#line 7567
  attr = (struct nlattr *)tmp___0;
#line 7567
  rem = nla_len((struct nlattr  const  *)br_spec);
  }
#line 7567
  goto ldv_55482;
  ldv_55481: 
  {
#line 7569
  reg = 0U;
#line 7571
  tmp___1 = nla_type((struct nlattr  const  *)attr);
  }
#line 7571
  if (tmp___1 != 1) {
#line 7572
    goto ldv_55480;
  } else {

  }
  {
#line 7574
  mode = nla_get_u16((struct nlattr  const  *)attr);
  }
#line 7575
  if ((unsigned int )mode == 1U) {
#line 7576
    reg = 0U;
#line 7577
    adapter->flags2 = adapter->flags2 & 4294965247U;
  } else
#line 7578
  if ((unsigned int )mode == 0U) {
#line 7579
    reg = 1U;
#line 7580
    adapter->flags2 = adapter->flags2 | 2048U;
  } else {
#line 7582
    return (-22);
  }
  {
#line 7584
  ixgbe_write_reg(& adapter->hw, 33312U, reg);
  }
#line 7586
  if ((int )adapter->msg_enable & 1) {
    {
#line 7587
    netdev_info((struct net_device  const  *)adapter->netdev, "enabling bridge mode: %s\n",
                (unsigned int )mode == 1U ? (char *)"VEPA" : (char *)"VEB");
    }
  } else {

  }
  ldv_55480: 
  {
#line 7567
  attr = nla_next((struct nlattr  const  *)attr, & rem);
  }
  ldv_55482: 
  {
#line 7567
  tmp___2 = nla_ok((struct nlattr  const  *)attr, rem);
  }
#line 7567
  if (tmp___2 != 0) {
#line 7569
    goto ldv_55481;
  } else {

  }

#line 7590
  return (0);
}
}
#line 7593 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_ndo_bridge_getlink(struct sk_buff *skb , u32 pid , u32 seq , struct net_device *dev ,
                                    u32 filter_mask ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  u16 mode ;
  int tmp___0 ;

  {
  {
#line 7597
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 7597
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 7600
  if ((adapter->flags & 8388608U) == 0U) {
#line 7601
    return (0);
  } else {

  }
#line 7603
  if ((adapter->flags2 & 2048U) != 0U) {
#line 7604
    mode = 0U;
  } else {
#line 7606
    mode = 1U;
  }
  {
#line 7608
  tmp___0 = ndo_dflt_bridge_getlink(skb, pid, seq, dev, (int )mode);
  }
#line 7608
  return (tmp___0);
}
}
#line 7611 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void *ixgbe_fwd_add(struct net_device *pdev , struct net_device *vdev ) 
{ 
  struct ixgbe_fwd_adapter *fwd_adapter ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  unsigned int limit ;
  int pool ;
  int err ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 7613
  fwd_adapter = (struct ixgbe_fwd_adapter *)0;
#line 7614
  tmp = netdev_priv((struct net_device  const  *)pdev);
#line 7614
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 7619
  if (vdev->num_rx_queues != vdev->num_tx_queues) {
    {
#line 7620
    netdev_info((struct net_device  const  *)pdev, "%s: Only supports a single queue count for TX and RX\n",
                (char *)(& vdev->name));
#line 7622
    tmp___0 = ERR_PTR(-22L);
    }
#line 7622
    return (tmp___0);
  } else {

  }
#line 7626
  if (vdev->num_tx_queues > 4U || vdev->num_tx_queues == 3U) {
    {
#line 7628
    netdev_info((struct net_device  const  *)pdev, "%s: Supports RX/TX Queue counts 1,2, and 4\n",
                (char *)(& pdev->name));
#line 7631
    tmp___1 = ERR_PTR(-22L);
    }
#line 7631
    return (tmp___1);
  } else {

  }
#line 7634
  if (((adapter->flags & 4096U) != 0U && adapter->num_rx_pools > 7) || adapter->num_rx_pools > 31) {
    {
#line 7637
    tmp___2 = ERR_PTR(-16L);
    }
#line 7637
    return (tmp___2);
  } else {

  }
  {
#line 7639
  tmp___3 = kcalloc(1UL, 544UL, 208U);
#line 7639
  fwd_adapter = (struct ixgbe_fwd_adapter *)tmp___3;
  }
#line 7640
  if ((unsigned long )fwd_adapter == (unsigned long )((struct ixgbe_fwd_adapter *)0)) {
    {
#line 7641
    tmp___4 = ERR_PTR(-12L);
    }
#line 7641
    return (tmp___4);
  } else {

  }
  {
#line 7643
  tmp___5 = find_first_zero_bit((unsigned long const   *)(& adapter->fwd_bitmask),
                                32UL);
#line 7643
  pool = (int )tmp___5;
#line 7644
  adapter->num_rx_pools = adapter->num_rx_pools + 1;
#line 7645
  set_bit((long )pool, (unsigned long volatile   *)(& adapter->fwd_bitmask));
#line 7646
  tmp___6 = find_last_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL);
#line 7646
  limit = (unsigned int )tmp___6;
#line 7649
  adapter->flags = adapter->flags | 8404992U;
#line 7650
  adapter->ring_feature[1].limit = (unsigned int )((u16 )limit) + 1U;
#line 7651
  adapter->ring_feature[2].limit = (u16 )vdev->num_tx_queues;
#line 7654
  tmp___7 = netdev_get_num_tc(pdev);
#line 7654
  err = ixgbe_setup_tc(pdev, (int )((u8 )tmp___7));
  }
#line 7655
  if (err != 0) {
#line 7656
    goto fwd_add_err;
  } else {

  }
  {
#line 7657
  fwd_adapter->pool = pool;
#line 7658
  fwd_adapter->real_adapter = adapter;
#line 7659
  err = ixgbe_fwd_ring_up(vdev, fwd_adapter);
  }
#line 7660
  if (err != 0) {
#line 7661
    goto fwd_add_err;
  } else {

  }
  {
#line 7662
  netif_tx_start_all_queues(vdev);
  }
#line 7663
  return ((void *)fwd_adapter);
  fwd_add_err: 
  {
#line 7666
  netdev_info((struct net_device  const  *)pdev, "%s: dfwd hardware acceleration failed\n",
              (char *)(& vdev->name));
#line 7668
  clear_bit((long )pool, (unsigned long volatile   *)(& adapter->fwd_bitmask));
#line 7669
  adapter->num_rx_pools = adapter->num_rx_pools - 1;
#line 7670
  kfree((void const   *)fwd_adapter);
#line 7671
  tmp___8 = ERR_PTR((long )err);
  }
#line 7671
  return (tmp___8);
}
}
#line 7674 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_fwd_del(struct net_device *pdev , void *priv ) 
{ 
  struct ixgbe_fwd_adapter *fwd_adapter ;
  struct ixgbe_adapter *adapter ;
  unsigned int limit ;
  unsigned long tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  {
#line 7676
  fwd_adapter = (struct ixgbe_fwd_adapter *)priv;
#line 7677
  adapter = fwd_adapter->real_adapter;
#line 7680
  clear_bit((long )fwd_adapter->pool, (unsigned long volatile   *)(& adapter->fwd_bitmask));
#line 7681
  adapter->num_rx_pools = adapter->num_rx_pools - 1;
#line 7683
  tmp = find_last_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL);
#line 7683
  limit = (unsigned int )tmp;
#line 7684
  adapter->ring_feature[1].limit = (unsigned int )((u16 )limit) + 1U;
#line 7685
  ixgbe_fwd_ring_down(fwd_adapter->netdev, fwd_adapter);
#line 7686
  tmp___0 = netdev_get_num_tc(pdev);
#line 7686
  ixgbe_setup_tc(pdev, (int )((u8 )tmp___0));
#line 7687
  descriptor.modname = "ixgbe";
#line 7687
  descriptor.function = "ixgbe_fwd_del";
#line 7687
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_main.c";
#line 7687
  descriptor.format = "pool %i:%i queues %i:%i VSI bitmask %lx\n";
#line 7687
  descriptor.lineno = 7691U;
#line 7687
  descriptor.flags = 0U;
#line 7687
  tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 7687
  if (tmp___1 != 0L) {
    {
#line 7687
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)pdev, "pool %i:%i queues %i:%i VSI bitmask %lx\n",
                         fwd_adapter->pool, adapter->num_rx_pools, fwd_adapter->rx_base_queue,
                         fwd_adapter->rx_base_queue + (unsigned int )adapter->num_rx_queues_per_pool,
                         adapter->fwd_bitmask);
    }
  } else {

  }
  {
#line 7692
  kfree((void const   *)fwd_adapter);
  }
#line 7693
  return;
}
}
#line 7695 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct net_device_ops  const  ixgbe_netdev_ops  = 
#line 7695
     {0, 0, & ixgbe_open, & ixgbe_close, & ixgbe_xmit_frame, & ixgbe_select_queue, 0,
    & ixgbe_set_rx_mode, & ixgbe_set_mac, & eth_validate_addr, & ixgbe_ioctl, 0, & ixgbe_change_mtu,
    0, & ixgbe_tx_timeout, & ixgbe_get_stats64, 0, & ixgbe_vlan_rx_add_vid, & ixgbe_vlan_rx_kill_vid,
    & ixgbe_netpoll, 0, 0, & ixgbe_low_latency_recv, & ixgbe_ndo_set_vf_mac, & ixgbe_ndo_set_vf_vlan,
    & ixgbe_ndo_set_vf_bw, & ixgbe_ndo_set_vf_spoofchk, & ixgbe_ndo_get_vf_config,
    0, 0, 0, & ixgbe_setup_tc, & ixgbe_fcoe_enable, & ixgbe_fcoe_disable, & ixgbe_fcoe_ddp_get,
    & ixgbe_fcoe_ddp_put, & ixgbe_fcoe_ddp_target, & ixgbe_fcoe_get_hbainfo, & ixgbe_fcoe_get_wwn,
    0, 0, 0, & ixgbe_fix_features, & ixgbe_set_features, 0, 0, & ixgbe_ndo_fdb_add,
    0, 0, & ixgbe_ndo_bridge_setlink, & ixgbe_ndo_bridge_getlink, 0, 0, 0, 0, 0, & ixgbe_fwd_add,
    & ixgbe_fwd_del, 0};
#line 7750 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
__inline static int ixgbe_enumerate_functions(struct ixgbe_adapter *adapter ) 
{ 
  struct list_head *entry ;
  int physfns ;
  struct pci_dev *pdev ;
  struct list_head  const  *__mptr ;
  bool tmp ;

  {
  {
#line 7753
  physfns = 0;
#line 7759
  tmp = ixgbe_pcie_from_parent(& adapter->hw);
  }
#line 7759
  if ((int )tmp) {
#line 7760
    physfns = 4;
  } else {
#line 7762
    entry = (adapter->pdev)->bus_list.next;
#line 7762
    goto ldv_55522;
    ldv_55521: 
#line 7764
    __mptr = (struct list_head  const  *)entry;
#line 7764
    pdev = (struct pci_dev *)__mptr;
#line 7766
    if ((unsigned int )*((unsigned char *)pdev + 2499UL) == 0U) {
#line 7767
      physfns = physfns + 1;
    } else {

    }
#line 7762
    entry = entry->next;
    ldv_55522: ;
#line 7762
    if ((unsigned long )entry != (unsigned long )(& (adapter->pdev)->bus_list)) {
#line 7764
      goto ldv_55521;
    } else {

    }

  }
#line 7771
  return (physfns);
}
}
#line 7784 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
int ixgbe_wol_supported(struct ixgbe_adapter *adapter , u16 device_id , u16 subdevice_id ) 
{ 
  struct ixgbe_hw *hw ;
  u16 wol_cap ;
  int is_wol_supported ;

  {
#line 7787
  hw = & adapter->hw;
#line 7788
  wol_cap = (unsigned int )adapter->eeprom_cap & 12U;
#line 7789
  is_wol_supported = 0;
  {
#line 7792
  if ((int )device_id == 4347) {
#line 7792
    goto case_4347;
  } else {

  }
#line 7808
  if ((int )device_id == 5463) {
#line 7808
    goto case_5463;
  } else {

  }
#line 7816
  if ((int )device_id == 4344) {
#line 7816
    goto case_4344;
  } else {

  }
#line 7821
  if ((int )device_id == 4343) {
#line 7821
    goto case_4343;
  } else {

  }
#line 7824
  if ((int )device_id == 5416) {
#line 7824
    goto case_5416;
  } else {

  }
#line 7825
  if ((int )device_id == 5472) {
#line 7825
    goto case_5472;
  } else {

  }
#line 7791
  goto switch_break;
  case_4347: /* CIL Label */ ;
  {
#line 7795
  if ((int )subdevice_id == 6096) {
#line 7795
    goto case_6096;
  } else {

  }
#line 7799
  if ((int )subdevice_id == 8475) {
#line 7799
    goto case_8475;
  } else {

  }
#line 7800
  if ((int )subdevice_id == 4521) {
#line 7800
    goto case_4521;
  } else {

  }
#line 7801
  if ((int )subdevice_id == 8050) {
#line 7801
    goto case_8050;
  } else {

  }
#line 7802
  if ((int )subdevice_id == 1136) {
#line 7802
    goto case_1136;
  } else {

  }
#line 7803
  if ((int )subdevice_id == 35190) {
#line 7803
    goto case_35190;
  } else {

  }
#line 7794
  goto switch_break___0;
  case_6096: /* CIL Label */ ;
#line 7797
  if ((unsigned int )hw->bus.func != 0U) {
#line 7798
    goto ldv_55534;
  } else {

  }
  case_8475: /* CIL Label */ ;
  case_4521: /* CIL Label */ ;
  case_8050: /* CIL Label */ ;
  case_1136: /* CIL Label */ ;
  case_35190: /* CIL Label */ 
#line 7804
  is_wol_supported = 1;
#line 7805
  goto ldv_55534;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_55534: ;
#line 7807
  goto ldv_55540;
  case_5463: /* CIL Label */ ;
  {
#line 7811
  if ((int )subdevice_id == 1) {
#line 7811
    goto case_1;
  } else {

  }
#line 7810
  goto switch_break___1;
  case_1: /* CIL Label */ 
#line 7812
  is_wol_supported = 1;
#line 7813
  goto ldv_55543;
  switch_break___1: /* CIL Label */ ;
  }
  ldv_55543: ;
#line 7815
  goto ldv_55540;
  case_4344: /* CIL Label */ ;
#line 7818
  if ((unsigned int )subdevice_id != 12U) {
#line 7819
    is_wol_supported = 1;
  } else {

  }
#line 7820
  goto ldv_55540;
  case_4343: /* CIL Label */ 
#line 7822
  is_wol_supported = 1;
#line 7823
  goto ldv_55540;
  case_5416: /* CIL Label */ ;
  case_5472: /* CIL Label */ ;
#line 7827
  if ((unsigned int )wol_cap == 4U || ((unsigned int )wol_cap == 8U && (unsigned int )hw->bus.func == 0U)) {
#line 7830
    is_wol_supported = 1;
  } else {

  }
#line 7832
  goto ldv_55540;
  switch_break: /* CIL Label */ ;
  }
  ldv_55540: ;
#line 7835
  return (is_wol_supported);
}
}
#line 7849 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_probe(struct pci_dev *pdev , struct pci_device_id  const  *ent ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  struct ixgbe_info  const  *ii ;
  int cards_found ;
  int i ;
  int err ;
  int pci_using_dac ;
  int expected_gts ;
  unsigned int indices ;
  u8 part_str[11U] ;
  u16 device_caps ;
  u32 eec ;
  int __ret_warn_on ;
  char const   *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  u32 tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  u32 esdp ;
  u32 tmp___7 ;
  unsigned int fcoe_l ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___8 ;
  s32 tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  int tmp___12 ;
  bool tmp___13 ;
  int _min1 ;
  int tmp___14 ;
  int _min2 ;
  int tmp___15 ;
  bool tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 7852
  adapter = (struct ixgbe_adapter *)0;
#line 7854
  ii = ixgbe_info_tbl[ent->driver_data];
#line 7857
  indices = 64U;
#line 7867
  if ((unsigned int )*((unsigned char *)pdev + 2499UL) != 0U) {
    {
#line 7868
    __ret_warn_on = 1;
#line 7868
    tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 7868
    if (tmp___0 != 0L) {
      {
#line 7868
      tmp = pci_name((struct pci_dev  const  *)pdev);
#line 7868
      warn_slowpath_fmt("drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", 7869, "\v%s (%hx:%hx) should not be a VF!\n",
                        tmp, (int )pdev->vendor, (int )pdev->device);
      }
    } else {

    }
    {
#line 7868
    __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 7870
    return (-22);
  } else {

  }
  {
#line 7873
  err = pci_enable_device_mem(pdev);
  }
#line 7874
  if (err != 0) {
#line 7875
    return (err);
  } else {

  }
  {
#line 7877
  tmp___1 = dma_set_mask_and_coherent(& pdev->dev, 0xffffffffffffffffULL);
  }
#line 7877
  if (tmp___1 == 0) {
#line 7878
    pci_using_dac = 1;
  } else {
    {
#line 7880
    err = dma_set_mask_and_coherent(& pdev->dev, 4294967295ULL);
    }
#line 7881
    if (err != 0) {
      {
#line 7882
      dev_err((struct device  const  *)(& pdev->dev), "No usable DMA configuration, aborting\n");
      }
#line 7884
      goto err_dma;
    } else {

    }
#line 7886
    pci_using_dac = 0;
  }
  {
#line 7889
  tmp___2 = pci_select_bars(pdev, 512UL);
#line 7889
  err = pci_request_selected_regions(pdev, tmp___2, (char const   *)(& ixgbe_driver_name));
  }
#line 7891
  if (err != 0) {
    {
#line 7892
    dev_err((struct device  const  *)(& pdev->dev), "pci_request_selected_regions failed 0x%x\n",
            err);
    }
#line 7894
    goto err_pci_reg;
  } else {

  }
  {
#line 7897
  pci_enable_pcie_error_reporting(pdev);
#line 7899
  pci_set_master(pdev);
#line 7900
  pci_save_state(pdev);
  }
#line 7902
  if ((unsigned int )ii->mac == 1U) {
#line 7905
    indices = 32U;
  } else {

  }
  {
#line 7911
  netdev = ldv_alloc_etherdev_mqs_21(69632, indices, indices);
  }
#line 7912
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 7913
    err = -12;
#line 7914
    goto err_alloc_etherdev;
  } else {

  }
  {
#line 7917
  netdev->dev.parent = & pdev->dev;
#line 7919
  tmp___3 = netdev_priv((struct net_device  const  *)netdev);
#line 7919
  adapter = (struct ixgbe_adapter *)tmp___3;
#line 7920
  pci_set_drvdata(pdev, (void *)adapter);
#line 7922
  adapter->netdev = netdev;
#line 7923
  adapter->pdev = pdev;
#line 7924
  hw = & adapter->hw;
#line 7925
  hw->back = (void *)adapter;
#line 7926
  tmp___4 = netif_msg_init(debug, 7);
#line 7926
  adapter->msg_enable = (u16 )tmp___4;
#line 7928
  tmp___5 = ioremap(pdev->resource[0].start, pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start ? (unsigned long )((pdev->resource[0].end - pdev->resource[0].start) + 1ULL) : 0UL);
#line 7928
  hw->hw_addr = (u8 *)tmp___5;
#line 7930
  adapter->io_addr = hw->hw_addr;
  }
#line 7931
  if ((unsigned long )hw->hw_addr == (unsigned long )((u8 *)0U)) {
#line 7932
    err = -5;
#line 7933
    goto err_ioremap;
  } else {

  }
  {
#line 7936
  netdev->netdev_ops = & ixgbe_netdev_ops;
#line 7937
  ixgbe_set_ethtool_ops(netdev);
#line 7938
  netdev->watchdog_timeo = 1250;
#line 7939
  tmp___6 = pci_name((struct pci_dev  const  *)pdev);
#line 7939
  strncpy((char *)(& netdev->name), tmp___6, 15UL);
#line 7941
  adapter->bd_number = (u16 )cards_found;
#line 7944
  memcpy((void *)(& hw->mac.ops), (void const   *)ii->mac_ops, 416UL);
#line 7945
  hw->mac.type = ii->mac;
#line 7948
  memcpy((void *)(& hw->eeprom.ops), (void const   *)ii->eeprom_ops, 64UL);
#line 7949
  eec = ixgbe_read_reg(hw, 65552U);
  }
#line 7951
  if ((eec & 256U) == 0U) {
#line 7952
    hw->eeprom.ops.read = & ixgbe_read_eeprom_bit_bang_generic;
  } else {

  }
  {
#line 7955
  memcpy((void *)(& hw->phy.ops), (void const   *)ii->phy_ops, 144UL);
#line 7956
  hw->phy.sfp_type = 65535;
#line 7958
  hw->phy.mdio.prtad = -1;
#line 7959
  hw->phy.mdio.mmds = 0U;
#line 7960
  hw->phy.mdio.mode_support = 6U;
#line 7961
  hw->phy.mdio.dev = netdev;
#line 7962
  hw->phy.mdio.mdio_read = & ixgbe_mdio_read;
#line 7963
  hw->phy.mdio.mdio_write = & ixgbe_mdio_write;
#line 7965
  (*(ii->get_invariants))(hw);
#line 7968
  err = ixgbe_sw_init(adapter);
  }
#line 7969
  if (err != 0) {
#line 7970
    goto err_sw_init;
  } else {

  }
#line 7973
  if ((unsigned long )hw->mac.ops.mng_fw_enabled != (unsigned long )((bool (*)(struct ixgbe_hw * ))0)) {
    {
#line 7974
    hw->mng_fw_enabled = (*(hw->mac.ops.mng_fw_enabled))(hw);
    }
  } else {

  }
  {
#line 7978
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 7978
    goto case_2;
  } else {

  }
#line 7979
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 7979
    goto case_3;
  } else {

  }
#line 7982
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 7980
  ixgbe_write_reg(& adapter->hw, 22544U, 4294967295U);
  }
#line 7981
  goto ldv_55574;
  switch_default: /* CIL Label */ ;
#line 7983
  goto ldv_55574;
  switch_break: /* CIL Label */ ;
  }
  ldv_55574: ;
#line 7990
  if ((adapter->flags & 32768U) != 0U) {
    {
#line 7991
    tmp___7 = ixgbe_read_reg(hw, 32U);
#line 7991
    esdp = tmp___7;
    }
#line 7992
    if ((esdp & 2U) != 0U) {
#line 7993
      if (((int )adapter->msg_enable & 2) != 0) {
        {
#line 7993
        netdev_crit((struct net_device  const  *)adapter->netdev, "Fan has stopped, replace the adapter\n");
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 7996
  if (allow_unsupported_sfp != 0U) {
#line 7997
    hw->allow_unsupported_sfp = allow_unsupported_sfp != 0U;
  } else {

  }
  {
#line 8000
  hw->phy.reset_if_overtemp = 1;
#line 8001
  err = (*(hw->mac.ops.reset_hw))(hw);
#line 8002
  hw->phy.reset_if_overtemp = 0;
  }
#line 8003
  if (err == -20 && (unsigned int )hw->mac.type == 1U) {
#line 8005
    err = 0;
  } else
#line 8006
  if (err == -19) {
    {
#line 8007
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "failed to load because an unsupported SFP+ or QSFP module type was detected.\n");
#line 8008
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Reload the driver after installing a supported module.\n");
    }
#line 8009
    goto err_sw_init;
  } else
#line 8010
  if (err != 0) {
    {
#line 8011
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "HW Init failed: %d\n",
            err);
    }
#line 8012
    goto err_sw_init;
  } else {

  }
#line 8017
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 8018
    goto skip_sriov;
  } else {

  }
  {
#line 8020
  ixgbe_init_mbx_params_pf(hw);
#line 8021
  memcpy((void *)(& hw->mbx.ops), (void const   *)ii->mbx_ops, 64UL);
#line 8022
  pci_sriov_set_totalvfs(pdev, 63);
#line 8023
  ixgbe_enable_sriov(adapter);
  }
  skip_sriov: 
#line 8027
  netdev->features = 6443565971ULL;
#line 8038
  netdev->hw_features = netdev->features | 1099511627776ULL;
  {
#line 8041
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 8041
    goto case_2___0;
  } else {

  }
#line 8042
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 8042
    goto case_3___0;
  } else {

  }
#line 8047
  goto switch_default___0;
  case_2___0: /* CIL Label */ ;
  case_3___0: /* CIL Label */ 
#line 8043
  netdev->features = netdev->features | 268435456ULL;
#line 8044
  netdev->hw_features = netdev->hw_features | 1342177280ULL;
#line 8046
  goto ldv_55580;
  switch_default___0: /* CIL Label */ ;
#line 8048
  goto ldv_55580;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_55580: 
#line 8051
  netdev->hw_features = netdev->hw_features | 68719476736ULL;
#line 8053
  netdev->vlan_features = netdev->vlan_features | 65536ULL;
#line 8054
  netdev->vlan_features = netdev->vlan_features | 1048576ULL;
#line 8055
  netdev->vlan_features = netdev->vlan_features | 2ULL;
#line 8056
  netdev->vlan_features = netdev->vlan_features | 16ULL;
#line 8057
  netdev->vlan_features = netdev->vlan_features | 1ULL;
#line 8059
  netdev->priv_flags = netdev->priv_flags | 131072U;
#line 8060
  netdev->priv_flags = netdev->priv_flags | 524288U;
#line 8063
  netdev->dcbnl_ops = & dcbnl_ops;
#line 8067
  if ((adapter->flags & 1048576U) != 0U) {
#line 8070
    if ((unsigned long )hw->mac.ops.get_device_caps != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                 u16 * ))0)) {
      {
#line 8071
      (*(hw->mac.ops.get_device_caps))(hw, & device_caps);
      }
#line 8072
      if (((int )device_caps & 2) != 0) {
#line 8073
        adapter->flags = adapter->flags & 4293918719U;
      } else {

      }
    } else {

    }
    {
#line 8077
    __min1 = 8;
#line 8077
    tmp___8 = cpumask_weight(cpu_online_mask);
#line 8077
    __min2 = (int )tmp___8;
#line 8077
    fcoe_l = (unsigned int )(__min1 < __min2 ? __min1 : __min2);
#line 8078
    adapter->ring_feature[4].limit = (u16 )fcoe_l;
#line 8080
    netdev->features = netdev->features | 136314880ULL;
#line 8083
    netdev->vlan_features = netdev->vlan_features | 673185792ULL;
    }
  } else {

  }
#line 8088
  if (pci_using_dac != 0) {
#line 8089
    netdev->features = netdev->features | 32ULL;
#line 8090
    netdev->vlan_features = netdev->vlan_features | 32ULL;
  } else {

  }
#line 8093
  if ((int )adapter->flags2 & 1) {
#line 8094
    netdev->hw_features = netdev->hw_features | 32768ULL;
  } else {

  }
#line 8095
  if ((adapter->flags2 & 2U) != 0U) {
#line 8096
    netdev->features = netdev->features | 32768ULL;
  } else {

  }
  {
#line 8099
  tmp___9 = (*(hw->eeprom.ops.validate_checksum))(hw, (u16 *)0U);
  }
#line 8099
  if (tmp___9 < 0) {
    {
#line 8100
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "The EEPROM Checksum Is Not Valid\n");
#line 8101
    err = -5;
    }
#line 8102
    goto err_sw_init;
  } else {

  }
  {
#line 8105
  memcpy((void *)netdev->dev_addr, (void const   *)(& hw->mac.perm_addr), (size_t )netdev->addr_len);
#line 8107
  tmp___10 = is_valid_ether_addr((u8 const   *)netdev->dev_addr);
  }
#line 8107
  if (tmp___10) {
#line 8107
    tmp___11 = 0;
  } else {
#line 8107
    tmp___11 = 1;
  }
#line 8107
  if (tmp___11) {
    {
#line 8108
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "invalid MAC address\n");
#line 8109
    err = -5;
    }
#line 8110
    goto err_sw_init;
  } else {

  }
  {
#line 8113
  init_timer_key(& adapter->service_timer, 0U, "((&adapter->service_timer))", & __key);
#line 8113
  adapter->service_timer.function = & ixgbe_service_timer;
#line 8113
  adapter->service_timer.data = (unsigned long )adapter;
#line 8116
  __init_work(& adapter->service_task, 0);
#line 8116
  __constr_expr_0.counter = 137438953408L;
#line 8116
  adapter->service_task.data = __constr_expr_0;
#line 8116
  lockdep_init_map(& adapter->service_task.lockdep_map, "(&adapter->service_task)",
                   & __key___0, 0);
#line 8116
  INIT_LIST_HEAD(& adapter->service_task.entry);
#line 8116
  adapter->service_task.func = & ixgbe_service_task;
#line 8117
  clear_bit(4L, (unsigned long volatile   *)(& adapter->state));
#line 8119
  err = ixgbe_init_interrupt_scheme(adapter);
  }
#line 8120
  if (err != 0) {
#line 8121
    goto err_sw_init;
  } else {

  }
  {
#line 8124
  adapter->wol = 0U;
#line 8125
  (*(hw->eeprom.ops.read))(hw, 44, & adapter->eeprom_cap);
#line 8126
  tmp___12 = ixgbe_wol_supported(adapter, (int )pdev->device, (int )pdev->subsystem_device);
#line 8126
  hw->wol_enabled = tmp___12 != 0;
  }
#line 8128
  if ((int )hw->wol_enabled) {
#line 8129
    adapter->wol = 2U;
  } else {

  }
  {
#line 8131
  device_set_wakeup_enable(& (adapter->pdev)->dev, adapter->wol != 0U);
#line 8134
  (*(hw->eeprom.ops.read))(hw, 46, & adapter->eeprom_verh);
#line 8135
  (*(hw->eeprom.ops.read))(hw, 45, & adapter->eeprom_verl);
#line 8138
  (*(hw->mac.ops.get_bus_info))(hw);
#line 8139
  tmp___13 = ixgbe_pcie_from_parent(hw);
  }
#line 8139
  if ((int )tmp___13) {
    {
#line 8140
    ixgbe_get_parent_bus_info(adapter);
    }
  } else {

  }
  {
#line 8148
  if ((unsigned int )hw->mac.type == 1U) {
#line 8148
    goto case_1;
  } else {

  }
#line 8151
  goto switch_default___1;
  case_1: /* CIL Label */ 
  {
#line 8149
  tmp___14 = ixgbe_enumerate_functions(adapter);
#line 8149
  _min1 = tmp___14 * 10;
#line 8149
  _min2 = 16;
#line 8149
  expected_gts = _min1 < _min2 ? _min1 : _min2;
  }
#line 8150
  goto ldv_55593;
  switch_default___1: /* CIL Label */ 
  {
#line 8152
  tmp___15 = ixgbe_enumerate_functions(adapter);
#line 8152
  expected_gts = tmp___15 * 10;
  }
#line 8153
  goto ldv_55593;
  switch_break___1: /* CIL Label */ ;
  }
  ldv_55593: 
  {
#line 8155
  ixgbe_check_minimum_link(adapter, expected_gts);
#line 8157
  err = ixgbe_read_pba_string_generic(hw, (u8 *)(& part_str), 11U);
  }
#line 8158
  if (err != 0) {
    {
#line 8159
    strncpy((char *)(& part_str), "Unknown", 11UL);
    }
  } else {

  }
  {
#line 8160
  tmp___16 = ixgbe_is_sfp(hw);
  }
#line 8160
  if ((int )tmp___16 && (unsigned int )hw->phy.sfp_type != 65534U) {
    {
#line 8161
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MAC: %d, PHY: %d, SFP+: %d, PBA No: %s\n",
              (unsigned int )hw->mac.type, (unsigned int )hw->phy.type, (unsigned int )hw->phy.sfp_type,
              (u8 *)(& part_str));
    }
  } else {
    {
#line 8165
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MAC: %d, PHY: %d, PBA No: %s\n",
              (unsigned int )hw->mac.type, (unsigned int )hw->phy.type, (u8 *)(& part_str));
    }
  }
  {
#line 8168
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "%pM\n", netdev->dev_addr);
#line 8171
  err = (*(hw->mac.ops.start_hw))(hw);
  }
#line 8172
  if (err == -24) {
    {
#line 8174
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "This device is a pre-production adapter/LOM. Please be aware there may be issues associated with your hardware.  If you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\n");
    }
  } else {

  }
  {
#line 8181
  strcpy((char *)(& netdev->name), "eth%d");
#line 8182
  err = ldv_register_netdev_22(netdev);
  }
#line 8183
  if (err != 0) {
#line 8184
    goto err_register;
  } else {

  }
#line 8187
  if ((unsigned long )hw->mac.ops.disable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
    {
#line 8188
    (*(hw->mac.ops.disable_tx_laser))(hw);
    }
  } else {

  }
  {
#line 8191
  netif_carrier_off(netdev);
#line 8194
  tmp___17 = dca_add_requester(& pdev->dev);
  }
#line 8194
  if (tmp___17 == 0) {
    {
#line 8195
    adapter->flags = adapter->flags | 256U;
#line 8196
    ixgbe_setup_dca(adapter);
    }
  } else {

  }
#line 8199
  if ((adapter->flags & 8388608U) != 0U) {
#line 8200
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 8200
      netdev_info((struct net_device  const  *)adapter->netdev, "IOV is enabled with %d VFs\n",
                  adapter->num_vfs);
      }
    } else {

    }
#line 8201
    i = 0;
#line 8201
    goto ldv_55597;
    ldv_55596: 
    {
#line 8202
    ixgbe_vf_configuration(pdev, (unsigned int )(i | 268435456));
#line 8201
    i = i + 1;
    }
    ldv_55597: ;
#line 8201
    if ((unsigned int )i < adapter->num_vfs) {
#line 8203
      goto ldv_55596;
    } else {

    }

  } else {

  }
#line 8208
  if ((unsigned long )hw->mac.ops.set_fw_drv_ver != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                              u8  ,
                                                                              u8  ,
                                                                              u8  ,
                                                                              u8  ))0)) {
    {
#line 8209
    (*(hw->mac.ops.set_fw_drv_ver))(hw, 255, 255, 255, 255);
    }
  } else {

  }
  {
#line 8213
  ixgbe_add_sanmac_netdev(netdev);
#line 8215
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "%s\n", (char *)(& ixgbe_default_device_descr));
#line 8216
  cards_found = cards_found + 1;
#line 8219
  tmp___18 = ixgbe_sysfs_init(adapter);
  }
#line 8219
  if (tmp___18 != 0) {
#line 8220
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 8220
      netdev_err((struct net_device  const  *)adapter->netdev, "failed to allocate sysfs resources\n");
      }
    } else {

    }
  } else {

  }
  {
#line 8223
  ixgbe_dbg_adapter_init(adapter);
  }
#line 8226
  if ((int )hw->mng_fw_enabled && (unsigned long )hw->mac.ops.setup_link != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                                      ixgbe_link_speed  ,
                                                                                                      bool  ))0)) {
    {
#line 8227
    (*(hw->mac.ops.setup_link))(hw, 160U, 1);
    }
  } else {

  }
#line 8231
  return (0);
  err_register: 
  {
#line 8234
  ixgbe_release_hw_control(adapter);
#line 8235
  ixgbe_clear_interrupt_scheme(adapter);
  }
  err_sw_init: 
  {
#line 8237
  ixgbe_disable_sriov(adapter);
#line 8238
  adapter->flags2 = adapter->flags2 & 4294967279U;
#line 8239
  iounmap((void volatile   *)adapter->io_addr);
  }
  err_ioremap: 
  {
#line 8241
  ldv_free_netdev_23(netdev);
  }
  err_alloc_etherdev: 
  {
#line 8243
  tmp___19 = pci_select_bars(pdev, 512UL);
#line 8243
  pci_release_selected_regions(pdev, tmp___19);
  }
  err_pci_reg: ;
  err_dma: 
  {
#line 8247
  pci_disable_device(pdev);
  }
#line 8248
  return (err);
}
}
#line 8260 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_remove(struct pci_dev *pdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  int tmp___0 ;

  {
  {
#line 8262
  tmp = pci_get_drvdata(pdev);
#line 8262
  adapter = (struct ixgbe_adapter *)tmp;
#line 8263
  netdev = adapter->netdev;
#line 8265
  ixgbe_dbg_adapter_exit(adapter);
#line 8267
  set_bit(3L, (unsigned long volatile   *)(& adapter->state));
#line 8268
  cancel_work_sync(& adapter->service_task);
  }
#line 8272
  if ((adapter->flags & 256U) != 0U) {
    {
#line 8273
    adapter->flags = adapter->flags & 4294967039U;
#line 8274
    dca_remove_requester(& pdev->dev);
#line 8275
    ixgbe_write_reg(& adapter->hw, 69748U, 1U);
    }
  } else {

  }
  {
#line 8280
  ixgbe_sysfs_exit(adapter);
#line 8284
  ixgbe_del_sanmac_netdev(netdev);
  }
#line 8286
  if ((unsigned int )netdev->reg_state == 1U) {
    {
#line 8287
    ldv_unregister_netdev_24(netdev);
    }
  } else {

  }
#line 8294
  if (max_vfs != 0U) {
    {
#line 8295
    ixgbe_disable_sriov(adapter);
    }
  } else {

  }
  {
#line 8297
  ixgbe_clear_interrupt_scheme(adapter);
#line 8299
  ixgbe_release_hw_control(adapter);
#line 8302
  kfree((void const   *)adapter->ixgbe_ieee_pfc);
#line 8303
  kfree((void const   *)adapter->ixgbe_ieee_ets);
#line 8306
  iounmap((void volatile   *)adapter->io_addr);
#line 8307
  tmp___0 = pci_select_bars(pdev, 512UL);
#line 8307
  pci_release_selected_regions(pdev, tmp___0);
#line 8310
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "complete\n");
#line 8312
  ldv_free_netdev_25(netdev);
#line 8314
  pci_disable_pcie_error_reporting(pdev);
#line 8316
  pci_disable_device(pdev);
  }
#line 8317
  return;
}
}
#line 8327 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static pci_ers_result_t ixgbe_io_error_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  struct pci_dev *bdev ;
  struct pci_dev *vfdev ;
  u32 dw0 ;
  u32 dw1 ;
  u32 dw2 ;
  u32 dw3 ;
  int vf ;
  int pos ;
  u16 req_id ;
  u16 pf_func ;
  int tmp___0 ;
  unsigned int device_id ;
  bool tmp___1 ;

  {
  {
#line 8330
  tmp = pci_get_drvdata(pdev);
#line 8330
  adapter = (struct ixgbe_adapter *)tmp;
#line 8331
  netdev = adapter->netdev;
  }
#line 8339
  if ((unsigned int )adapter->hw.mac.type == 1U || adapter->num_vfs == 0U) {
#line 8341
    goto skip_bad_vf_detection;
  } else {

  }
#line 8343
  bdev = (pdev->bus)->self;
#line 8344
  goto ldv_55622;
  ldv_55621: 
#line 8345
  bdev = (bdev->bus)->self;
  ldv_55622: ;
#line 8344
  if ((unsigned long )bdev != (unsigned long )((struct pci_dev *)0)) {
    {
#line 8344
    tmp___0 = pci_pcie_type((struct pci_dev  const  *)bdev);
    }
#line 8344
    if (tmp___0 != 4) {
#line 8346
      goto ldv_55621;
    } else {
#line 8349
      goto ldv_55623;
    }
  } else {

  }
  ldv_55623: ;
#line 8347
  if ((unsigned long )bdev == (unsigned long )((struct pci_dev *)0)) {
#line 8348
    goto skip_bad_vf_detection;
  } else {

  }
  {
#line 8350
  pos = pci_find_ext_capability(bdev, 1);
  }
#line 8351
  if (pos == 0) {
#line 8352
    goto skip_bad_vf_detection;
  } else {

  }
  {
#line 8354
  pci_read_config_dword((struct pci_dev  const  *)bdev, pos + 28, & dw0);
#line 8355
  pci_read_config_dword((struct pci_dev  const  *)bdev, pos + 32, & dw1);
#line 8356
  pci_read_config_dword((struct pci_dev  const  *)bdev, pos + 36, & dw2);
#line 8357
  pci_read_config_dword((struct pci_dev  const  *)bdev, pos + 40, & dw3);
#line 8359
  req_id = (u16 )(dw1 >> 16);
  }
#line 8361
  if (((int )req_id & 128) == 0) {
#line 8362
    goto skip_bad_vf_detection;
  } else {

  }
#line 8364
  pf_func = (unsigned int )req_id & 1U;
#line 8365
  if ((((unsigned int )pf_func ^ pdev->devfn) & 1U) == 0U) {
    {
#line 8368
    vf = ((int )req_id & 127) >> 1;
#line 8369
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "VF %d has caused a PCIe error\n",
            vf);
#line 8370
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "TLP: dw0: %8.8x\tdw1: %8.8x\tdw2: %8.8x\tdw3: %8.8x\n",
            dw0, dw1, dw2, dw3);
    }
    {
#line 8374
    if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 8374
      goto case_2;
    } else {

    }
#line 8377
    if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 8377
      goto case_3;
    } else {

    }
#line 8380
    goto switch_default;
    case_2: /* CIL Label */ 
#line 8375
    device_id = 4333U;
#line 8376
    goto ldv_55626;
    case_3: /* CIL Label */ 
#line 8378
    device_id = 5397U;
#line 8379
    goto ldv_55626;
    switch_default: /* CIL Label */ 
#line 8381
    device_id = 0U;
#line 8382
    goto ldv_55626;
    switch_break: /* CIL Label */ ;
    }
    ldv_55626: 
    {
#line 8386
    vfdev = pci_get_device(32902U, device_id, (struct pci_dev *)0);
    }
#line 8387
    goto ldv_55631;
    ldv_55630: ;
#line 8388
    if (vfdev->devfn == ((unsigned int )req_id & 255U)) {
#line 8389
      goto ldv_55629;
    } else {

    }
    {
#line 8390
    vfdev = pci_get_device(32902U, device_id, vfdev);
    }
    ldv_55631: ;
#line 8387
    if ((unsigned long )vfdev != (unsigned long )((struct pci_dev *)0)) {
#line 8389
      goto ldv_55630;
    } else {

    }
    ldv_55629: ;
#line 8398
    if ((unsigned long )vfdev != (unsigned long )((struct pci_dev *)0)) {
      {
#line 8399
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Issuing VFLR to VF %d\n",
              vf);
#line 8400
      pci_write_config_dword((struct pci_dev  const  *)vfdev, 168, 32768U);
#line 8402
      pci_dev_put(vfdev);
      }
    } else {

    }
    {
#line 8405
    pci_cleanup_aer_uncorrect_error_status(pdev);
    }
  } else {

  }
#line 8414
  adapter->vferr_refcount = adapter->vferr_refcount + 1U;
#line 8416
  return (5U);
  skip_bad_vf_detection: 
  {
#line 8420
  netif_device_detach(netdev);
  }
#line 8422
  if (state == 3U) {
#line 8423
    return (4U);
  } else {

  }
  {
#line 8425
  tmp___1 = netif_running((struct net_device  const  *)netdev);
  }
#line 8425
  if ((int )tmp___1) {
    {
#line 8426
    ixgbe_down(adapter);
    }
  } else {

  }
  {
#line 8427
  pci_disable_device(pdev);
  }
#line 8430
  return (3U);
}
}
#line 8439 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static pci_ers_result_t ixgbe_io_slot_reset(struct pci_dev *pdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  pci_ers_result_t result ;
  int err ;
  int tmp___0 ;

  {
  {
#line 8441
  tmp = pci_get_drvdata(pdev);
#line 8441
  adapter = (struct ixgbe_adapter *)tmp;
#line 8445
  tmp___0 = pci_enable_device_mem(pdev);
  }
#line 8445
  if (tmp___0 != 0) {
#line 8446
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 8446
      netdev_err((struct net_device  const  *)adapter->netdev, "Cannot re-enable PCI device after reset.\n");
      }
    } else {

    }
#line 8447
    result = 4U;
  } else {
    {
#line 8449
    pci_set_master(pdev);
#line 8450
    pci_restore_state(pdev);
#line 8451
    pci_save_state(pdev);
#line 8453
    pci_wake_from_d3(pdev, 0);
#line 8455
    ixgbe_reset(adapter);
#line 8456
    ixgbe_write_reg(& adapter->hw, 22544U, 4294967295U);
#line 8457
    result = 5U;
    }
  }
  {
#line 8460
  err = pci_cleanup_aer_uncorrect_error_status(pdev);
  }
#line 8461
  if (err != 0) {
    {
#line 8462
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "pci_cleanup_aer_uncorrect_error_status failed 0x%0x\n",
            err);
    }
  } else {

  }
#line 8467
  return (result);
}
}
#line 8477 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_io_resume(struct pci_dev *pdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;

  {
  {
#line 8479
  tmp = pci_get_drvdata(pdev);
#line 8479
  adapter = (struct ixgbe_adapter *)tmp;
#line 8480
  netdev = adapter->netdev;
  }
#line 8483
  if (adapter->vferr_refcount != 0U) {
#line 8484
    if ((int )adapter->msg_enable & 1) {
      {
#line 8484
      netdev_info((struct net_device  const  *)adapter->netdev, "Resuming after VF err\n");
      }
    } else {

    }
#line 8485
    adapter->vferr_refcount = adapter->vferr_refcount - 1U;
#line 8486
    return;
  } else {

  }
  {
#line 8490
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 8490
  if ((int )tmp___0) {
    {
#line 8491
    ixgbe_up(adapter);
    }
  } else {

  }
  {
#line 8493
  netif_device_attach(netdev);
  }
#line 8494
  return;
}
}
#line 8496 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_error_handlers  const  ixgbe_err_handler  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& ixgbe_io_error_detected),
    0, 0, & ixgbe_io_slot_reset, & ixgbe_io_resume};
#line 8502 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static struct pci_driver ixgbe_driver  = 
#line 8502
     {{0, 0}, (char const   *)(& ixgbe_driver_name), (struct pci_device_id  const  *)(& ixgbe_pci_tbl),
    & ixgbe_probe, & ixgbe_remove, & ixgbe_suspend, 0, 0, & ixgbe_resume, & ixgbe_shutdown,
    & ixgbe_pci_sriov_configure, & ixgbe_err_handler, {0, 0, 0, 0, (_Bool)0, 0, 0,
                                                       0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0U}},
                                                                                    0U,
                                                                                    0U,
                                                                                    0,
                                                                                    {0,
                                                                                     {0,
                                                                                      0},
                                                                                     0,
                                                                                     0,
                                                                                     0UL}}}},
                                                                                 {0,
                                                                                  0}}};
#line 8522 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_init_module(void) 
{ 
  int ret ;

  {
  {
#line 8525
  printk("\016ixgbe: %s - version %s\n", (char const   *)(& ixgbe_driver_string),
         (char const   *)(& ixgbe_driver_version));
#line 8526
  printk("\016ixgbe: %s\n", (char const   *)(& ixgbe_copyright));
#line 8528
  ixgbe_dbg_init();
#line 8530
  ret = ldv___pci_register_driver_26(& ixgbe_driver, & __this_module, "ixgbe");
  }
#line 8531
  if (ret != 0) {
    {
#line 8532
    ixgbe_dbg_exit();
    }
#line 8533
    return (ret);
  } else {

  }
  {
#line 8537
  ldv_dca_register_notify_27(& dca_notifier);
  }
#line 8540
  return (0);
}
}
#line 8551 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static void ixgbe_exit_module(void) 
{ 


  {
  {
#line 8554
  ldv_dca_unregister_notify_28(& dca_notifier);
#line 8556
  ldv_pci_unregister_driver_29(& ixgbe_driver);
#line 8558
  ixgbe_dbg_exit();
#line 8560
  rcu_barrier();
  }
#line 8561
  return;
}
}
#line 8564 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c"
static int ixgbe_notify_dca(struct notifier_block *nb , unsigned long event , void *p ) 
{ 
  int ret_val ;

  {
  {
#line 8569
  ret_val = driver_for_each_device(& ixgbe_driver.driver, (struct device *)0, (void *)(& event),
                                   & __ixgbe_notify_dca);
  }
#line 8572
  return (ret_val != 0 ? 32770 : 0);
}
}
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_EMGentry_exit_ixgbe_exit_module_31_2(void (*arg0)(void) ) ;
#line 78
int ldv_EMGentry_init_ixgbe_init_module_31_11(int (*arg0)(void) ) ;
#line 79
int ldv___pci_register_driver(int arg0 , struct pci_driver *arg1 , struct module *arg2 ,
                              char *arg3 ) ;
#line 80
struct net_device *ldv_alloc_etherdev_mqs(struct net_device *arg0 , int arg1 , unsigned int arg2 ,
                                          unsigned int arg3 ) ;
#line 81
void ldv_dca_register_notify(void *arg0 , struct notifier_block *arg1 ) ;
#line 82
void ldv_dca_unregister_notify(void *arg0 , struct notifier_block *arg1 ) ;
#line 83
extern int ldv_del_timer_sync(int  , struct timer_list * ) ;
#line 84
void ldv_dispatch_deregister_26_1(struct net_device *arg0 ) ;
#line 85
void ldv_dispatch_deregister_27_1(struct pci_driver *arg0 ) ;
#line 86
void ldv_dispatch_deregister_29_1(struct notifier_block *arg0 ) ;
#line 87
void ldv_dispatch_deregister_dummy_resourceless_instance_15_31_4(void) ;
#line 88
void ldv_dispatch_deregister_file_operations_instance_9_31_5(void) ;
#line 90
void ldv_dispatch_instance_register_20_2(struct timer_list *arg0 ) ;
#line 92
void ldv_dispatch_irq_register_22_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 93
void ldv_dispatch_irq_register_23_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 94
void ldv_dispatch_irq_register_24_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 96
void ldv_dispatch_register_21_4(struct net_device *arg0 ) ;
#line 97
void ldv_dispatch_register_28_2(struct pci_driver *arg0 ) ;
#line 98
void ldv_dispatch_register_30_1(struct notifier_block *arg0 ) ;
#line 99
void ldv_dispatch_register_dummy_resourceless_instance_15_31_6(void) ;
#line 100
void ldv_dispatch_register_file_operations_instance_9_31_7(void) ;
#line 101
void ldv_dummy_resourceless_instance_callback_10_101(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 102
void ldv_dummy_resourceless_instance_callback_10_104(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) ;
#line 103
void ldv_dummy_resourceless_instance_callback_10_107(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) ;
#line 104
void ldv_dummy_resourceless_instance_callback_10_110(void (*arg0)(struct ixgbe_hw * ,
                                                                  unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 105
void ldv_dummy_resourceless_instance_callback_10_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 106
void ldv_dummy_resourceless_instance_callback_10_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 107
void ldv_dummy_resourceless_instance_callback_10_115(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ,
                                                     unsigned char arg5 ) ;
#line 108
void ldv_dummy_resourceless_instance_callback_10_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 109
void ldv_dummy_resourceless_instance_callback_10_119(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) ;
#line 110
void ldv_dummy_resourceless_instance_callback_10_12(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 111
void ldv_dummy_resourceless_instance_callback_10_122(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char *arg3 , unsigned int arg4 ,
                                                     unsigned int arg5 ) ;
#line 112
void ldv_dummy_resourceless_instance_callback_10_125(void (*arg0)(struct ixgbe_hw * ,
                                                                  int  , unsigned int  ,
                                                                  int  ) , struct ixgbe_hw *arg1 ,
                                                     int arg2 , unsigned int arg3 ,
                                                     int arg4 ) ;
#line 113
void ldv_dummy_resourceless_instance_callback_10_128(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 _Bool  ) , struct ixgbe_hw *arg1 ,
                                                     unsigned int arg2 , unsigned int arg3 ,
                                                     _Bool arg4 ) ;
#line 114
void ldv_dummy_resourceless_instance_callback_10_131(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) ;
#line 115
void ldv_dummy_resourceless_instance_callback_10_134(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 ) ;
#line 116
void ldv_dummy_resourceless_instance_callback_10_137(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 117
void ldv_dummy_resourceless_instance_callback_10_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 118
void ldv_dummy_resourceless_instance_callback_10_141(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , _Bool  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     _Bool arg3 ) ;
#line 119
void ldv_dummy_resourceless_instance_callback_10_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 120
void ldv_dummy_resourceless_instance_callback_10_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 121
void ldv_dummy_resourceless_instance_callback_10_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 122
void ldv_dummy_resourceless_instance_callback_10_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 123
void ldv_dummy_resourceless_instance_callback_10_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 124
void ldv_dummy_resourceless_instance_callback_10_149(int (*arg0)(struct ixgbe_hw * ,
                                                                 struct net_device * ) ,
                                                     struct ixgbe_hw *arg1 , struct net_device *arg2 ) ;
#line 125
void ldv_dummy_resourceless_instance_callback_10_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 126
void ldv_dummy_resourceless_instance_callback_10_150(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 127
void ldv_dummy_resourceless_instance_callback_10_153(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 128
void ldv_dummy_resourceless_instance_callback_10_156(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char arg3 ) ;
#line 129
void ldv_dummy_resourceless_instance_callback_10_159(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                     unsigned short arg3 , unsigned short *arg4 ) ;
#line 130
void ldv_dummy_resourceless_instance_callback_10_16(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 131
void ldv_dummy_resourceless_instance_callback_10_162(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ) ;
#line 132
void ldv_dummy_resourceless_instance_callback_10_165(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 ) ;
#line 133
void ldv_dummy_resourceless_instance_callback_10_168(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 134
void ldv_dummy_resourceless_instance_callback_10_171(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) ;
#line 135
void ldv_dummy_resourceless_instance_callback_10_174(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) ;
#line 136
void ldv_dummy_resourceless_instance_callback_10_19(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 137
void ldv_dummy_resourceless_instance_callback_10_22(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 138
void ldv_dummy_resourceless_instance_callback_10_25(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int *arg2 , _Bool *arg3 ,
                                                    _Bool arg4 ) ;
#line 139
void ldv_dummy_resourceless_instance_callback_10_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 140
void ldv_dummy_resourceless_instance_callback_10_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 141
void ldv_dummy_resourceless_instance_callback_10_3(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 142
void ldv_dummy_resourceless_instance_callback_10_30(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 143
void ldv_dummy_resourceless_instance_callback_10_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 144
void ldv_dummy_resourceless_instance_callback_10_34(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) ;
#line 145
void ldv_dummy_resourceless_instance_callback_10_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 146
void ldv_dummy_resourceless_instance_callback_10_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 147
void ldv_dummy_resourceless_instance_callback_10_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 148
void ldv_dummy_resourceless_instance_callback_10_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 149
void ldv_dummy_resourceless_instance_callback_10_41(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 150
void ldv_dummy_resourceless_instance_callback_10_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 151
void ldv_dummy_resourceless_instance_callback_10_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 152
void ldv_dummy_resourceless_instance_callback_10_46(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 153
void ldv_dummy_resourceless_instance_callback_10_49(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 154
void ldv_dummy_resourceless_instance_callback_10_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 155
void ldv_dummy_resourceless_instance_callback_10_53(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    _Bool *arg3 ) ;
#line 156
void ldv_dummy_resourceless_instance_callback_10_56(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 157
void ldv_dummy_resourceless_instance_callback_10_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 158
void ldv_dummy_resourceless_instance_callback_10_60(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 159
void ldv_dummy_resourceless_instance_callback_10_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 160
void ldv_dummy_resourceless_instance_callback_10_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 161
void ldv_dummy_resourceless_instance_callback_10_65(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                    unsigned short *arg3 ) ;
#line 162
void ldv_dummy_resourceless_instance_callback_10_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 163
void ldv_dummy_resourceless_instance_callback_10_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 164
void ldv_dummy_resourceless_instance_callback_10_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 165
void ldv_dummy_resourceless_instance_callback_10_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 166
void ldv_dummy_resourceless_instance_callback_10_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 167
void ldv_dummy_resourceless_instance_callback_10_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 168
void ldv_dummy_resourceless_instance_callback_10_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 169
void ldv_dummy_resourceless_instance_callback_10_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 170
void ldv_dummy_resourceless_instance_callback_10_76(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 171
void ldv_dummy_resourceless_instance_callback_10_79(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 172
void ldv_dummy_resourceless_instance_callback_10_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 173
void ldv_dummy_resourceless_instance_callback_10_83(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 174
void ldv_dummy_resourceless_instance_callback_10_86(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 ) ;
#line 175
void ldv_dummy_resourceless_instance_callback_10_89(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) ;
#line 176
void ldv_dummy_resourceless_instance_callback_10_9(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 177
void ldv_dummy_resourceless_instance_callback_10_92(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char *arg4 ) ;
#line 178
void ldv_dummy_resourceless_instance_callback_10_95(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) ;
#line 179
void ldv_dummy_resourceless_instance_callback_10_98(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) ;
#line 180
void ldv_dummy_resourceless_instance_callback_11_101(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 181
void ldv_dummy_resourceless_instance_callback_11_104(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) ;
#line 182
void ldv_dummy_resourceless_instance_callback_11_107(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) ;
#line 183
void ldv_dummy_resourceless_instance_callback_11_110(void (*arg0)(struct ixgbe_hw * ,
                                                                  unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 184
void ldv_dummy_resourceless_instance_callback_11_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 185
void ldv_dummy_resourceless_instance_callback_11_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 186
void ldv_dummy_resourceless_instance_callback_11_115(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ,
                                                     unsigned char arg5 ) ;
#line 187
void ldv_dummy_resourceless_instance_callback_11_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 188
void ldv_dummy_resourceless_instance_callback_11_119(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) ;
#line 189
void ldv_dummy_resourceless_instance_callback_11_12(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 190
void ldv_dummy_resourceless_instance_callback_11_122(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char *arg3 , unsigned int arg4 ,
                                                     unsigned int arg5 ) ;
#line 191
void ldv_dummy_resourceless_instance_callback_11_125(void (*arg0)(struct ixgbe_hw * ,
                                                                  int  , unsigned int  ,
                                                                  int  ) , struct ixgbe_hw *arg1 ,
                                                     int arg2 , unsigned int arg3 ,
                                                     int arg4 ) ;
#line 192
void ldv_dummy_resourceless_instance_callback_11_128(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 _Bool  ) , struct ixgbe_hw *arg1 ,
                                                     unsigned int arg2 , unsigned int arg3 ,
                                                     _Bool arg4 ) ;
#line 193
void ldv_dummy_resourceless_instance_callback_11_131(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) ;
#line 194
void ldv_dummy_resourceless_instance_callback_11_134(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 ) ;
#line 195
void ldv_dummy_resourceless_instance_callback_11_137(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 196
void ldv_dummy_resourceless_instance_callback_11_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 197
void ldv_dummy_resourceless_instance_callback_11_141(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , _Bool  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     _Bool arg3 ) ;
#line 198
void ldv_dummy_resourceless_instance_callback_11_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 199
void ldv_dummy_resourceless_instance_callback_11_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 200
void ldv_dummy_resourceless_instance_callback_11_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 201
void ldv_dummy_resourceless_instance_callback_11_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 202
void ldv_dummy_resourceless_instance_callback_11_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 203
void ldv_dummy_resourceless_instance_callback_11_149(int (*arg0)(struct ixgbe_hw * ,
                                                                 struct net_device * ) ,
                                                     struct ixgbe_hw *arg1 , struct net_device *arg2 ) ;
#line 204
void ldv_dummy_resourceless_instance_callback_11_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 205
void ldv_dummy_resourceless_instance_callback_11_150(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 206
void ldv_dummy_resourceless_instance_callback_11_153(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 207
void ldv_dummy_resourceless_instance_callback_11_156(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char arg3 ) ;
#line 208
void ldv_dummy_resourceless_instance_callback_11_159(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                     unsigned short arg3 , unsigned short *arg4 ) ;
#line 209
void ldv_dummy_resourceless_instance_callback_11_16(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 210
void ldv_dummy_resourceless_instance_callback_11_162(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ) ;
#line 211
void ldv_dummy_resourceless_instance_callback_11_165(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 ) ;
#line 212
void ldv_dummy_resourceless_instance_callback_11_168(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 213
void ldv_dummy_resourceless_instance_callback_11_171(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) ;
#line 214
void ldv_dummy_resourceless_instance_callback_11_174(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) ;
#line 215
void ldv_dummy_resourceless_instance_callback_11_19(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 216
void ldv_dummy_resourceless_instance_callback_11_22(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 217
void ldv_dummy_resourceless_instance_callback_11_25(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int *arg2 , _Bool *arg3 ,
                                                    _Bool arg4 ) ;
#line 218
void ldv_dummy_resourceless_instance_callback_11_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 219
void ldv_dummy_resourceless_instance_callback_11_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 220
void ldv_dummy_resourceless_instance_callback_11_3(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 221
void ldv_dummy_resourceless_instance_callback_11_30(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 222
void ldv_dummy_resourceless_instance_callback_11_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 223
void ldv_dummy_resourceless_instance_callback_11_34(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) ;
#line 224
void ldv_dummy_resourceless_instance_callback_11_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 225
void ldv_dummy_resourceless_instance_callback_11_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 226
void ldv_dummy_resourceless_instance_callback_11_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 227
void ldv_dummy_resourceless_instance_callback_11_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 228
void ldv_dummy_resourceless_instance_callback_11_41(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 229
void ldv_dummy_resourceless_instance_callback_11_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 230
void ldv_dummy_resourceless_instance_callback_11_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 231
void ldv_dummy_resourceless_instance_callback_11_46(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 232
void ldv_dummy_resourceless_instance_callback_11_49(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 233
void ldv_dummy_resourceless_instance_callback_11_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 234
void ldv_dummy_resourceless_instance_callback_11_53(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    _Bool *arg3 ) ;
#line 235
void ldv_dummy_resourceless_instance_callback_11_56(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 236
void ldv_dummy_resourceless_instance_callback_11_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 237
void ldv_dummy_resourceless_instance_callback_11_60(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 238
void ldv_dummy_resourceless_instance_callback_11_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 239
void ldv_dummy_resourceless_instance_callback_11_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 240
void ldv_dummy_resourceless_instance_callback_11_65(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                    unsigned short *arg3 ) ;
#line 241
void ldv_dummy_resourceless_instance_callback_11_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 242
void ldv_dummy_resourceless_instance_callback_11_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 243
void ldv_dummy_resourceless_instance_callback_11_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 244
void ldv_dummy_resourceless_instance_callback_11_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 245
void ldv_dummy_resourceless_instance_callback_11_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 246
void ldv_dummy_resourceless_instance_callback_11_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 247
void ldv_dummy_resourceless_instance_callback_11_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 248
void ldv_dummy_resourceless_instance_callback_11_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 249
void ldv_dummy_resourceless_instance_callback_11_76(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 250
void ldv_dummy_resourceless_instance_callback_11_79(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 251
void ldv_dummy_resourceless_instance_callback_11_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 252
void ldv_dummy_resourceless_instance_callback_11_83(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 253
void ldv_dummy_resourceless_instance_callback_11_86(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 ) ;
#line 254
void ldv_dummy_resourceless_instance_callback_11_89(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) ;
#line 255
void ldv_dummy_resourceless_instance_callback_11_9(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 256
void ldv_dummy_resourceless_instance_callback_11_92(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char *arg4 ) ;
#line 257
void ldv_dummy_resourceless_instance_callback_11_95(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) ;
#line 258
void ldv_dummy_resourceless_instance_callback_11_98(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) ;
#line 259
void ldv_dummy_resourceless_instance_callback_12_101(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 260
void ldv_dummy_resourceless_instance_callback_12_104(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) ;
#line 261
void ldv_dummy_resourceless_instance_callback_12_107(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) ;
#line 262
void ldv_dummy_resourceless_instance_callback_12_110(void (*arg0)(struct ixgbe_hw * ,
                                                                  unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 263
void ldv_dummy_resourceless_instance_callback_12_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 264
void ldv_dummy_resourceless_instance_callback_12_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 265
void ldv_dummy_resourceless_instance_callback_12_115(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ,
                                                     unsigned char arg5 ) ;
#line 266
void ldv_dummy_resourceless_instance_callback_12_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 267
void ldv_dummy_resourceless_instance_callback_12_119(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) ;
#line 268
void ldv_dummy_resourceless_instance_callback_12_12(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 269
void ldv_dummy_resourceless_instance_callback_12_122(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char *arg3 , unsigned int arg4 ,
                                                     unsigned int arg5 ) ;
#line 270
void ldv_dummy_resourceless_instance_callback_12_125(void (*arg0)(struct ixgbe_hw * ,
                                                                  int  , unsigned int  ,
                                                                  int  ) , struct ixgbe_hw *arg1 ,
                                                     int arg2 , unsigned int arg3 ,
                                                     int arg4 ) ;
#line 271
void ldv_dummy_resourceless_instance_callback_12_128(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 _Bool  ) , struct ixgbe_hw *arg1 ,
                                                     unsigned int arg2 , unsigned int arg3 ,
                                                     _Bool arg4 ) ;
#line 272
void ldv_dummy_resourceless_instance_callback_12_131(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) ;
#line 273
void ldv_dummy_resourceless_instance_callback_12_134(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 ) ;
#line 274
void ldv_dummy_resourceless_instance_callback_12_137(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 275
void ldv_dummy_resourceless_instance_callback_12_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 276
void ldv_dummy_resourceless_instance_callback_12_141(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , _Bool  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     _Bool arg3 ) ;
#line 277
void ldv_dummy_resourceless_instance_callback_12_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 278
void ldv_dummy_resourceless_instance_callback_12_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 279
void ldv_dummy_resourceless_instance_callback_12_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 280
void ldv_dummy_resourceless_instance_callback_12_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 281
void ldv_dummy_resourceless_instance_callback_12_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 282
void ldv_dummy_resourceless_instance_callback_12_149(int (*arg0)(struct ixgbe_hw * ,
                                                                 struct net_device * ) ,
                                                     struct ixgbe_hw *arg1 , struct net_device *arg2 ) ;
#line 283
void ldv_dummy_resourceless_instance_callback_12_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 284
void ldv_dummy_resourceless_instance_callback_12_150(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 285
void ldv_dummy_resourceless_instance_callback_12_153(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 286
void ldv_dummy_resourceless_instance_callback_12_156(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char arg3 ) ;
#line 287
void ldv_dummy_resourceless_instance_callback_12_159(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                     unsigned short arg3 , unsigned short *arg4 ) ;
#line 288
void ldv_dummy_resourceless_instance_callback_12_16(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 289
void ldv_dummy_resourceless_instance_callback_12_162(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ) ;
#line 290
void ldv_dummy_resourceless_instance_callback_12_165(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 ) ;
#line 291
void ldv_dummy_resourceless_instance_callback_12_168(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 292
void ldv_dummy_resourceless_instance_callback_12_171(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) ;
#line 293
void ldv_dummy_resourceless_instance_callback_12_174(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) ;
#line 294
void ldv_dummy_resourceless_instance_callback_12_19(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 295
void ldv_dummy_resourceless_instance_callback_12_22(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 296
void ldv_dummy_resourceless_instance_callback_12_25(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int *arg2 , _Bool *arg3 ,
                                                    _Bool arg4 ) ;
#line 297
void ldv_dummy_resourceless_instance_callback_12_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 298
void ldv_dummy_resourceless_instance_callback_12_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 299
void ldv_dummy_resourceless_instance_callback_12_3(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 300
void ldv_dummy_resourceless_instance_callback_12_30(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 301
void ldv_dummy_resourceless_instance_callback_12_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 302
void ldv_dummy_resourceless_instance_callback_12_34(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) ;
#line 303
void ldv_dummy_resourceless_instance_callback_12_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 304
void ldv_dummy_resourceless_instance_callback_12_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 305
void ldv_dummy_resourceless_instance_callback_12_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 306
void ldv_dummy_resourceless_instance_callback_12_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 307
void ldv_dummy_resourceless_instance_callback_12_41(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 308
void ldv_dummy_resourceless_instance_callback_12_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 309
void ldv_dummy_resourceless_instance_callback_12_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 310
void ldv_dummy_resourceless_instance_callback_12_46(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 311
void ldv_dummy_resourceless_instance_callback_12_49(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 312
void ldv_dummy_resourceless_instance_callback_12_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 313
void ldv_dummy_resourceless_instance_callback_12_53(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    _Bool *arg3 ) ;
#line 314
void ldv_dummy_resourceless_instance_callback_12_56(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 315
void ldv_dummy_resourceless_instance_callback_12_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 316
void ldv_dummy_resourceless_instance_callback_12_60(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 317
void ldv_dummy_resourceless_instance_callback_12_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 318
void ldv_dummy_resourceless_instance_callback_12_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 319
void ldv_dummy_resourceless_instance_callback_12_65(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                    unsigned short *arg3 ) ;
#line 320
void ldv_dummy_resourceless_instance_callback_12_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 321
void ldv_dummy_resourceless_instance_callback_12_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 322
void ldv_dummy_resourceless_instance_callback_12_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 323
void ldv_dummy_resourceless_instance_callback_12_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 324
void ldv_dummy_resourceless_instance_callback_12_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 325
void ldv_dummy_resourceless_instance_callback_12_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 326
void ldv_dummy_resourceless_instance_callback_12_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 327
void ldv_dummy_resourceless_instance_callback_12_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 328
void ldv_dummy_resourceless_instance_callback_12_76(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 329
void ldv_dummy_resourceless_instance_callback_12_79(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 330
void ldv_dummy_resourceless_instance_callback_12_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 331
void ldv_dummy_resourceless_instance_callback_12_83(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 332
void ldv_dummy_resourceless_instance_callback_12_86(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 ) ;
#line 333
void ldv_dummy_resourceless_instance_callback_12_89(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) ;
#line 334
void ldv_dummy_resourceless_instance_callback_12_9(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 335
void ldv_dummy_resourceless_instance_callback_12_92(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char *arg4 ) ;
#line 336
void ldv_dummy_resourceless_instance_callback_12_95(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) ;
#line 337
void ldv_dummy_resourceless_instance_callback_12_98(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) ;
#line 338
void ldv_dummy_resourceless_instance_callback_13_101(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 339
void ldv_dummy_resourceless_instance_callback_13_104(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) ;
#line 340
void ldv_dummy_resourceless_instance_callback_13_107(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) ;
#line 341
void ldv_dummy_resourceless_instance_callback_13_110(void (*arg0)(struct ixgbe_hw * ,
                                                                  unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 342
void ldv_dummy_resourceless_instance_callback_13_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 343
void ldv_dummy_resourceless_instance_callback_13_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 344
void ldv_dummy_resourceless_instance_callback_13_115(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ,
                                                     unsigned char arg5 ) ;
#line 345
void ldv_dummy_resourceless_instance_callback_13_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 346
void ldv_dummy_resourceless_instance_callback_13_119(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) ;
#line 347
void ldv_dummy_resourceless_instance_callback_13_12(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 348
void ldv_dummy_resourceless_instance_callback_13_122(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char *arg3 , unsigned int arg4 ,
                                                     unsigned int arg5 ) ;
#line 349
void ldv_dummy_resourceless_instance_callback_13_125(void (*arg0)(struct ixgbe_hw * ,
                                                                  int  , unsigned int  ,
                                                                  int  ) , struct ixgbe_hw *arg1 ,
                                                     int arg2 , unsigned int arg3 ,
                                                     int arg4 ) ;
#line 350
void ldv_dummy_resourceless_instance_callback_13_128(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 _Bool  ) , struct ixgbe_hw *arg1 ,
                                                     unsigned int arg2 , unsigned int arg3 ,
                                                     _Bool arg4 ) ;
#line 351
void ldv_dummy_resourceless_instance_callback_13_131(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) ;
#line 352
void ldv_dummy_resourceless_instance_callback_13_134(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 ) ;
#line 353
void ldv_dummy_resourceless_instance_callback_13_137(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 354
void ldv_dummy_resourceless_instance_callback_13_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 355
void ldv_dummy_resourceless_instance_callback_13_141(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , _Bool  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     _Bool arg3 ) ;
#line 356
void ldv_dummy_resourceless_instance_callback_13_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 357
void ldv_dummy_resourceless_instance_callback_13_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 358
void ldv_dummy_resourceless_instance_callback_13_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 359
void ldv_dummy_resourceless_instance_callback_13_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 360
void ldv_dummy_resourceless_instance_callback_13_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) ;
#line 361
void ldv_dummy_resourceless_instance_callback_13_149(int (*arg0)(struct ixgbe_hw * ,
                                                                 struct net_device * ) ,
                                                     struct ixgbe_hw *arg1 , struct net_device *arg2 ) ;
#line 362
void ldv_dummy_resourceless_instance_callback_13_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 363
void ldv_dummy_resourceless_instance_callback_13_150(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 364
void ldv_dummy_resourceless_instance_callback_13_153(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 365
void ldv_dummy_resourceless_instance_callback_13_156(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char arg3 ) ;
#line 366
void ldv_dummy_resourceless_instance_callback_13_159(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                     unsigned short arg3 , unsigned short *arg4 ) ;
#line 367
void ldv_dummy_resourceless_instance_callback_13_16(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 368
void ldv_dummy_resourceless_instance_callback_13_162(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ) ;
#line 369
void ldv_dummy_resourceless_instance_callback_13_165(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 ) ;
#line 370
void ldv_dummy_resourceless_instance_callback_13_168(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) ;
#line 371
void ldv_dummy_resourceless_instance_callback_13_171(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) ;
#line 372
void ldv_dummy_resourceless_instance_callback_13_174(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) ;
#line 373
void ldv_dummy_resourceless_instance_callback_13_19(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 374
void ldv_dummy_resourceless_instance_callback_13_22(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 375
void ldv_dummy_resourceless_instance_callback_13_25(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int *arg2 , _Bool *arg3 ,
                                                    _Bool arg4 ) ;
#line 376
void ldv_dummy_resourceless_instance_callback_13_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 377
void ldv_dummy_resourceless_instance_callback_13_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 378
void ldv_dummy_resourceless_instance_callback_13_3(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 379
void ldv_dummy_resourceless_instance_callback_13_30(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 380
void ldv_dummy_resourceless_instance_callback_13_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 381
void ldv_dummy_resourceless_instance_callback_13_34(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) ;
#line 382
void ldv_dummy_resourceless_instance_callback_13_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 383
void ldv_dummy_resourceless_instance_callback_13_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 384
void ldv_dummy_resourceless_instance_callback_13_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 385
void ldv_dummy_resourceless_instance_callback_13_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 386
void ldv_dummy_resourceless_instance_callback_13_41(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 387
void ldv_dummy_resourceless_instance_callback_13_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 388
void ldv_dummy_resourceless_instance_callback_13_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 389
void ldv_dummy_resourceless_instance_callback_13_46(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 390
void ldv_dummy_resourceless_instance_callback_13_49(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 391
void ldv_dummy_resourceless_instance_callback_13_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 392
void ldv_dummy_resourceless_instance_callback_13_53(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    _Bool *arg3 ) ;
#line 393
void ldv_dummy_resourceless_instance_callback_13_56(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 394
void ldv_dummy_resourceless_instance_callback_13_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 395
void ldv_dummy_resourceless_instance_callback_13_60(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 396
void ldv_dummy_resourceless_instance_callback_13_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 397
void ldv_dummy_resourceless_instance_callback_13_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 398
void ldv_dummy_resourceless_instance_callback_13_65(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                    unsigned short *arg3 ) ;
#line 399
void ldv_dummy_resourceless_instance_callback_13_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 400
void ldv_dummy_resourceless_instance_callback_13_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 401
void ldv_dummy_resourceless_instance_callback_13_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 402
void ldv_dummy_resourceless_instance_callback_13_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 403
void ldv_dummy_resourceless_instance_callback_13_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 404
void ldv_dummy_resourceless_instance_callback_13_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 405
void ldv_dummy_resourceless_instance_callback_13_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 406
void ldv_dummy_resourceless_instance_callback_13_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 407
void ldv_dummy_resourceless_instance_callback_13_76(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 408
void ldv_dummy_resourceless_instance_callback_13_79(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 409
void ldv_dummy_resourceless_instance_callback_13_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 410
void ldv_dummy_resourceless_instance_callback_13_83(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 411
void ldv_dummy_resourceless_instance_callback_13_86(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 ) ;
#line 412
void ldv_dummy_resourceless_instance_callback_13_89(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) ;
#line 413
void ldv_dummy_resourceless_instance_callback_13_9(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 414
void ldv_dummy_resourceless_instance_callback_13_92(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char *arg4 ) ;
#line 415
void ldv_dummy_resourceless_instance_callback_13_95(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) ;
#line 416
void ldv_dummy_resourceless_instance_callback_13_98(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) ;
#line 417
void ldv_dummy_resourceless_instance_callback_14_3(int (*arg0)(struct notifier_block * ,
                                                               unsigned long  , void * ) ,
                                                   struct notifier_block *arg1 , unsigned long arg2 ,
                                                   void *arg3 ) ;
#line 418
void ldv_dummy_resourceless_instance_callback_6_100(int (*arg0)(struct net_device * ,
                                                                struct netdev_fcoe_hbainfo * ) ,
                                                    struct net_device *arg1 , struct netdev_fcoe_hbainfo *arg2 ) ;
#line 419
void ldv_dummy_resourceless_instance_callback_6_101(int (*arg0)(struct net_device * ,
                                                                unsigned long long * ,
                                                                int  ) , struct net_device *arg1 ,
                                                    unsigned long long *arg2 , int arg3 ) ;
#line 420
void ldv_dummy_resourceless_instance_callback_6_104(int (*arg0)(struct ndmsg * , struct nlattr ** ,
                                                                struct net_device * ,
                                                                unsigned char * ,
                                                                unsigned short  ) ,
                                                    struct ndmsg *arg1 , struct nlattr **arg2 ,
                                                    struct net_device *arg3 , unsigned char *arg4 ,
                                                    unsigned short arg5 ) ;
#line 421
void ldv_dummy_resourceless_instance_callback_6_107(unsigned long long (*arg0)(struct net_device * ,
                                                                               unsigned long long  ) ,
                                                    struct net_device *arg1 , unsigned long long arg2 ) ;
#line 422
void ldv_dummy_resourceless_instance_callback_6_110(struct rtnl_link_stats64 *(*arg0)(struct net_device * ,
                                                                                      struct rtnl_link_stats64 * ) ,
                                                    struct net_device *arg1 , struct rtnl_link_stats64 *arg2 ) ;
#line 423
void ldv_dummy_resourceless_instance_callback_6_111(int (*arg0)(struct net_device * ,
                                                                int  , struct ifla_vf_info * ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    struct ifla_vf_info *arg3 ) ;
#line 424
void ldv_dummy_resourceless_instance_callback_6_114(void (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) ;
#line 425
void ldv_dummy_resourceless_instance_callback_6_115(unsigned short (*arg0)(struct net_device * ,
                                                                           struct sk_buff * ,
                                                                           void * ,
                                                                           unsigned short (*)(struct net_device * ,
                                                                                              struct sk_buff * ) ) ,
                                                    struct net_device *arg1 , struct sk_buff *arg2 ,
                                                    void *arg3 , unsigned short (*arg4)(struct net_device * ,
                                                                                        struct sk_buff * ) ) ;
#line 426
void ldv_dummy_resourceless_instance_callback_6_118(int (*arg0)(struct net_device * ,
                                                                unsigned long long  ) ,
                                                    struct net_device *arg1 , unsigned long long arg2 ) ;
#line 427
void ldv_dummy_resourceless_instance_callback_6_12(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 428
void ldv_dummy_resourceless_instance_callback_6_121(int (*arg0)(struct net_device * ,
                                                                void * ) , struct net_device *arg1 ,
                                                    void *arg2 ) ;
#line 429
void ldv_dummy_resourceless_instance_callback_6_122(void (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) ;
#line 430
void ldv_dummy_resourceless_instance_callback_6_123(int (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char *arg3 ) ;
#line 431
void ldv_dummy_resourceless_instance_callback_6_126(int (*arg0)(struct net_device * ,
                                                                int  , _Bool  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    _Bool arg3 ) ;
#line 432
void ldv_dummy_resourceless_instance_callback_6_129(int (*arg0)(struct net_device * ,
                                                                int  , int  ) , struct net_device *arg1 ,
                                                    int arg2 , int arg3 ) ;
#line 433
void ldv_dummy_resourceless_instance_callback_6_13(void (*arg0)(struct net_device * ,
                                                                struct ethtool_stats * ,
                                                                unsigned long long * ) ,
                                                   struct net_device *arg1 , struct ethtool_stats *arg2 ,
                                                   unsigned long long *arg3 ) ;
#line 434
void ldv_dummy_resourceless_instance_callback_6_132(int (*arg0)(struct net_device * ,
                                                                int  , unsigned short  ,
                                                                unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned short arg3 , unsigned char arg4 ) ;
#line 435
void ldv_dummy_resourceless_instance_callback_6_135(int (*arg0)(struct net_device * ,
                                                                unsigned char  ) ,
                                                    struct net_device *arg1 , unsigned char arg2 ) ;
#line 436
void ldv_dummy_resourceless_instance_callback_6_138(enum netdev_tx (*arg0)(struct sk_buff * ,
                                                                           struct net_device * ) ,
                                                    struct sk_buff *arg1 , struct net_device *arg2 ) ;
#line 437
void ldv_dummy_resourceless_instance_callback_6_139(void (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) ;
#line 438
void ldv_dummy_resourceless_instance_callback_6_140(int (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) ;
#line 439
void ldv_dummy_resourceless_instance_callback_6_141(int (*arg0)(struct net_device * ,
                                                                unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct net_device *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 ) ;
#line 440
void ldv_dummy_resourceless_instance_callback_6_144(int (*arg0)(struct net_device * ,
                                                                unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct net_device *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 ) ;
#line 441
void ldv_dummy_resourceless_instance_callback_6_147(int (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) ;
#line 442
void ldv_dummy_resourceless_instance_callback_6_148(void (*arg0)(struct net_device * ,
                                                                 struct ethtool_test * ,
                                                                 unsigned long long * ) ,
                                                    struct net_device *arg1 , struct ethtool_test *arg2 ,
                                                    unsigned long long *arg3 ) ;
#line 443
void ldv_dummy_resourceless_instance_callback_6_151(int (*arg0)(struct net_device * ,
                                                                struct ethtool_channels * ) ,
                                                    struct net_device *arg1 , struct ethtool_channels *arg2 ) ;
#line 444
void ldv_dummy_resourceless_instance_callback_6_152(int (*arg0)(struct net_device * ,
                                                                struct ethtool_coalesce * ) ,
                                                    struct net_device *arg1 , struct ethtool_coalesce *arg2 ) ;
#line 445
void ldv_dummy_resourceless_instance_callback_6_153(int (*arg0)(struct net_device * ,
                                                                struct ethtool_eeprom * ,
                                                                unsigned char * ) ,
                                                    struct net_device *arg1 , struct ethtool_eeprom *arg2 ,
                                                    unsigned char *arg3 ) ;
#line 446
void ldv_dummy_resourceless_instance_callback_6_156(void (*arg0)(struct net_device * ,
                                                                 unsigned int  ) ,
                                                    struct net_device *arg1 , unsigned int arg2 ) ;
#line 447
void ldv_dummy_resourceless_instance_callback_6_159(int (*arg0)(struct net_device * ,
                                                                struct ethtool_pauseparam * ) ,
                                                    struct net_device *arg1 , struct ethtool_pauseparam *arg2 ) ;
#line 448
void ldv_dummy_resourceless_instance_callback_6_16(unsigned int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 449
void ldv_dummy_resourceless_instance_callback_6_160(int (*arg0)(struct net_device * ,
                                                                enum ethtool_phys_id_state  ) ,
                                                    struct net_device *arg1 , enum ethtool_phys_id_state arg2 ) ;
#line 450
void ldv_dummy_resourceless_instance_callback_6_161(int (*arg0)(struct net_device * ,
                                                                struct ethtool_ringparam * ) ,
                                                    struct net_device *arg1 , struct ethtool_ringparam *arg2 ) ;
#line 451
void ldv_dummy_resourceless_instance_callback_6_162(int (*arg0)(struct net_device * ,
                                                                struct ethtool_rxnfc * ) ,
                                                    struct net_device *arg1 , struct ethtool_rxnfc *arg2 ) ;
#line 452
void ldv_dummy_resourceless_instance_callback_6_163(int (*arg0)(struct net_device * ,
                                                                struct ethtool_cmd * ) ,
                                                    struct net_device *arg1 , struct ethtool_cmd *arg2 ) ;
#line 453
void ldv_dummy_resourceless_instance_callback_6_164(int (*arg0)(struct net_device * ,
                                                                struct ethtool_wolinfo * ) ,
                                                    struct net_device *arg1 , struct ethtool_wolinfo *arg2 ) ;
#line 454
void ldv_dummy_resourceless_instance_callback_6_165(unsigned char (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) ;
#line 455
void ldv_dummy_resourceless_instance_callback_6_166(unsigned char (*arg0)(struct net_device * ,
                                                                          unsigned char  ) ,
                                                    struct net_device *arg1 , unsigned char arg2 ) ;
#line 456
void ldv_dummy_resourceless_instance_callback_6_169(int (*arg0)(struct net_device * ,
                                                                int  , unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 ) ;
#line 457
void ldv_dummy_resourceless_instance_callback_6_17(int (*arg0)(struct net_device * ,
                                                               struct ethtool_eeprom * ,
                                                               unsigned char * ) ,
                                                   struct net_device *arg1 , struct ethtool_eeprom *arg2 ,
                                                   unsigned char *arg3 ) ;
#line 458
void ldv_dummy_resourceless_instance_callback_6_172(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 ) ;
#line 459
void ldv_dummy_resourceless_instance_callback_6_175(void (*arg0)(struct net_device * ,
                                                                 unsigned char  ) ,
                                                    struct net_device *arg1 , unsigned char arg2 ) ;
#line 460
void ldv_dummy_resourceless_instance_callback_6_178(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 ) ;
#line 461
void ldv_dummy_resourceless_instance_callback_6_181(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 ) ;
#line 462
void ldv_dummy_resourceless_instance_callback_6_184(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ,
                                                    unsigned char arg5 , unsigned char arg6 ) ;
#line 463
void ldv_dummy_resourceless_instance_callback_6_187(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ,
                                                    unsigned char arg5 , unsigned char arg6 ) ;
#line 464
void ldv_dummy_resourceless_instance_callback_6_190(unsigned char (*arg0)(struct net_device * ,
                                                                          unsigned char  ) ,
                                                    struct net_device *arg1 , unsigned char arg2 ) ;
#line 465
void ldv_dummy_resourceless_instance_callback_6_20(int (*arg0)(struct net_device * ,
                                                               struct ethtool_modinfo * ) ,
                                                   struct net_device *arg1 , struct ethtool_modinfo *arg2 ) ;
#line 466
void ldv_dummy_resourceless_instance_callback_6_21(unsigned int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 467
void ldv_dummy_resourceless_instance_callback_6_22(void (*arg0)(struct net_device * ,
                                                                struct ethtool_pauseparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_pauseparam *arg2 ) ;
#line 468
void ldv_dummy_resourceless_instance_callback_6_23(void (*arg0)(struct net_device * ,
                                                                struct ethtool_regs * ,
                                                                void * ) , struct net_device *arg1 ,
                                                   struct ethtool_regs *arg2 , void *arg3 ) ;
#line 469
void ldv_dummy_resourceless_instance_callback_6_24(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 470
void ldv_dummy_resourceless_instance_callback_6_25(void (*arg0)(struct net_device * ,
                                                                struct ethtool_ringparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_ringparam *arg2 ) ;
#line 471
void ldv_dummy_resourceless_instance_callback_6_26(int (*arg0)(struct net_device * ,
                                                               struct ethtool_rxnfc * ,
                                                               unsigned int * ) ,
                                                   struct net_device *arg1 , struct ethtool_rxnfc *arg2 ,
                                                   unsigned int *arg3 ) ;
#line 472
void ldv_dummy_resourceless_instance_callback_6_29(int (*arg0)(struct net_device * ,
                                                               struct ethtool_cmd * ) ,
                                                   struct net_device *arg1 , struct ethtool_cmd *arg2 ) ;
#line 473
void ldv_dummy_resourceless_instance_callback_6_3(void (*arg0)(struct net_device * ,
                                                               struct ethtool_channels * ) ,
                                                  struct net_device *arg1 , struct ethtool_channels *arg2 ) ;
#line 474
void ldv_dummy_resourceless_instance_callback_6_30(int (*arg0)(struct net_device * ,
                                                               int  ) , struct net_device *arg1 ,
                                                   int arg2 ) ;
#line 475
void ldv_dummy_resourceless_instance_callback_6_33(void (*arg0)(struct net_device * ,
                                                                unsigned int  , unsigned char * ) ,
                                                   struct net_device *arg1 , unsigned int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 476
void ldv_dummy_resourceless_instance_callback_6_36(int (*arg0)(struct net_device * ,
                                                               struct ethtool_ts_info * ) ,
                                                   struct net_device *arg1 , struct ethtool_ts_info *arg2 ) ;
#line 477
void ldv_dummy_resourceless_instance_callback_6_37(void (*arg0)(struct net_device * ,
                                                                struct ethtool_wolinfo * ) ,
                                                   struct net_device *arg1 , struct ethtool_wolinfo *arg2 ) ;
#line 478
void ldv_dummy_resourceless_instance_callback_6_38(unsigned char (*arg0)(struct net_device * ,
                                                                         unsigned char  ,
                                                                         unsigned short  ) ,
                                                   struct net_device *arg1 , unsigned char arg2 ,
                                                   unsigned short arg3 ) ;
#line 479
void ldv_dummy_resourceless_instance_callback_6_41(unsigned char (*arg0)(struct net_device * ,
                                                                         int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 480
void ldv_dummy_resourceless_instance_callback_6_44(unsigned char (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 481
void ldv_dummy_resourceless_instance_callback_6_45(int (*arg0)(struct net_device * ,
                                                               int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 482
void ldv_dummy_resourceless_instance_callback_6_48(void (*arg0)(struct net_device * ,
                                                                unsigned char * ) ,
                                                   struct net_device *arg1 , unsigned char *arg2 ) ;
#line 483
void ldv_dummy_resourceless_instance_callback_6_51(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 484
void ldv_dummy_resourceless_instance_callback_6_54(unsigned char (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 485
void ldv_dummy_resourceless_instance_callback_6_55(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 486
void ldv_dummy_resourceless_instance_callback_6_58(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 487
void ldv_dummy_resourceless_instance_callback_6_61(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ,
                                                                unsigned char * ,
                                                                unsigned char * ,
                                                                unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 , unsigned char *arg4 ,
                                                   unsigned char *arg5 , unsigned char *arg6 ) ;
#line 488
void ldv_dummy_resourceless_instance_callback_6_64(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ,
                                                                unsigned char * ,
                                                                unsigned char * ,
                                                                unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 , unsigned char *arg4 ,
                                                   unsigned char *arg5 , unsigned char *arg6 ) ;
#line 489
void ldv_dummy_resourceless_instance_callback_6_67(unsigned char (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 490
void ldv_dummy_resourceless_instance_callback_6_68(int (*arg0)(struct net_device * ,
                                                               struct dcb_app * ) ,
                                                   struct net_device *arg1 , struct dcb_app *arg2 ) ;
#line 491
void ldv_dummy_resourceless_instance_callback_6_69(int (*arg0)(struct net_device * ,
                                                               struct ieee_ets * ) ,
                                                   struct net_device *arg1 , struct ieee_ets *arg2 ) ;
#line 492
void ldv_dummy_resourceless_instance_callback_6_7(int (*arg0)(struct net_device * ,
                                                              struct ethtool_coalesce * ) ,
                                                  struct net_device *arg1 , struct ethtool_coalesce *arg2 ) ;
#line 493
void ldv_dummy_resourceless_instance_callback_6_70(int (*arg0)(struct net_device * ,
                                                               struct ieee_pfc * ) ,
                                                   struct net_device *arg1 , struct ieee_pfc *arg2 ) ;
#line 494
void ldv_dummy_resourceless_instance_callback_6_71(int (*arg0)(struct net_device * ,
                                                               struct dcb_app * ) ,
                                                   struct net_device *arg1 , struct dcb_app *arg2 ) ;
#line 495
void ldv_dummy_resourceless_instance_callback_6_72(int (*arg0)(struct net_device * ,
                                                               struct ieee_ets * ) ,
                                                   struct net_device *arg1 , struct ieee_ets *arg2 ) ;
#line 496
void ldv_dummy_resourceless_instance_callback_6_73(int (*arg0)(struct net_device * ,
                                                               struct ieee_pfc * ) ,
                                                   struct net_device *arg1 , struct ieee_pfc *arg2 ) ;
#line 497
void ldv_dummy_resourceless_instance_callback_6_74(int (*arg0)(struct sk_buff * ,
                                                               unsigned int  , unsigned int  ,
                                                               struct net_device * ,
                                                               unsigned int  ) , struct sk_buff *arg1 ,
                                                   unsigned int arg2 , unsigned int arg3 ,
                                                   struct net_device *arg4 , unsigned int arg5 ) ;
#line 498
void ldv_dummy_resourceless_instance_callback_6_77(int (*arg0)(struct net_device * ,
                                                               struct nlmsghdr * ) ,
                                                   struct net_device *arg1 , struct nlmsghdr *arg2 ) ;
#line 499
void ldv_dummy_resourceless_instance_callback_6_78(int (*arg0)(struct napi_struct * ) ,
                                                   struct napi_struct *arg1 ) ;
#line 500
void ldv_dummy_resourceless_instance_callback_6_79(int (*arg0)(struct net_device * ,
                                                               int  ) , struct net_device *arg1 ,
                                                   int arg2 ) ;
#line 501
void ldv_dummy_resourceless_instance_callback_6_8(void (*arg0)(struct net_device * ,
                                                               struct ethtool_drvinfo * ) ,
                                                  struct net_device *arg1 , struct ethtool_drvinfo *arg2 ) ;
#line 502
void ldv_dummy_resourceless_instance_callback_6_82(void *(*arg0)(struct net_device * ,
                                                                 struct net_device * ) ,
                                                   struct net_device *arg1 , struct net_device *arg2 ) ;
#line 503
void ldv_dummy_resourceless_instance_callback_6_85(void (*arg0)(struct net_device * ,
                                                                void * ) , struct net_device *arg1 ,
                                                   void *arg2 ) ;
#line 504
void ldv_dummy_resourceless_instance_callback_6_86(int (*arg0)(struct net_device * ,
                                                               struct ifreq * , int  ) ,
                                                   struct net_device *arg1 , struct ifreq *arg2 ,
                                                   int arg3 ) ;
#line 505
void ldv_dummy_resourceless_instance_callback_6_89(int (*arg0)(struct net_device * ,
                                                               unsigned short  ) ,
                                                   struct net_device *arg1 , unsigned short arg2 ) ;
#line 506
void ldv_dummy_resourceless_instance_callback_6_9(int (*arg0)(struct net_device * ,
                                                              struct ethtool_eeprom * ,
                                                              unsigned char * ) ,
                                                  struct net_device *arg1 , struct ethtool_eeprom *arg2 ,
                                                  unsigned char *arg3 ) ;
#line 507
void ldv_dummy_resourceless_instance_callback_6_92(int (*arg0)(struct net_device * ,
                                                               unsigned short  , struct scatterlist * ,
                                                               unsigned int  ) , struct net_device *arg1 ,
                                                   unsigned short arg2 , struct scatterlist *arg3 ,
                                                   unsigned int arg4 ) ;
#line 508
void ldv_dummy_resourceless_instance_callback_6_95(int (*arg0)(struct net_device * ,
                                                               unsigned short  , struct scatterlist * ,
                                                               unsigned int  ) , struct net_device *arg1 ,
                                                   unsigned short arg2 , struct scatterlist *arg3 ,
                                                   unsigned int arg4 ) ;
#line 509
void ldv_dummy_resourceless_instance_callback_6_98(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 510
void ldv_dummy_resourceless_instance_callback_6_99(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 511
void ldv_dummy_resourceless_instance_callback_8_101(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 512
void ldv_dummy_resourceless_instance_callback_8_104(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short *arg4 ) ;
#line 513
void ldv_dummy_resourceless_instance_callback_8_107(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short *arg4 ) ;
#line 514
void ldv_dummy_resourceless_instance_callback_8_110(void (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 515
void ldv_dummy_resourceless_instance_callback_8_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 516
void ldv_dummy_resourceless_instance_callback_8_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 517
void ldv_dummy_resourceless_instance_callback_8_115(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ,
                                                    unsigned char arg5 ) ;
#line 518
void ldv_dummy_resourceless_instance_callback_8_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 519
void ldv_dummy_resourceless_instance_callback_8_119(void (*arg0)(struct ixgbe_hw * ,
                                                                 _Bool  , int  ) ,
                                                    struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                    int arg3 ) ;
#line 520
void ldv_dummy_resourceless_instance_callback_8_12(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 521
void ldv_dummy_resourceless_instance_callback_8_122(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 , unsigned int arg4 ,
                                                    unsigned int arg5 ) ;
#line 522
void ldv_dummy_resourceless_instance_callback_8_125(void (*arg0)(struct ixgbe_hw * ,
                                                                 int  , unsigned int  ,
                                                                 int  ) , struct ixgbe_hw *arg1 ,
                                                    int arg2 , unsigned int arg3 ,
                                                    int arg4 ) ;
#line 523
void ldv_dummy_resourceless_instance_callback_8_128(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int arg2 , unsigned int arg3 ,
                                                    _Bool arg4 ) ;
#line 524
void ldv_dummy_resourceless_instance_callback_8_131(void (*arg0)(struct ixgbe_hw * ,
                                                                 _Bool  , int  ) ,
                                                    struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                    int arg3 ) ;
#line 525
void ldv_dummy_resourceless_instance_callback_8_134(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) ;
#line 526
void ldv_dummy_resourceless_instance_callback_8_137(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 527
void ldv_dummy_resourceless_instance_callback_8_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 528
void ldv_dummy_resourceless_instance_callback_8_141(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , _Bool  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    _Bool arg3 ) ;
#line 529
void ldv_dummy_resourceless_instance_callback_8_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 530
void ldv_dummy_resourceless_instance_callback_8_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 531
void ldv_dummy_resourceless_instance_callback_8_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 532
void ldv_dummy_resourceless_instance_callback_8_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 533
void ldv_dummy_resourceless_instance_callback_8_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 534
void ldv_dummy_resourceless_instance_callback_8_149(int (*arg0)(struct ixgbe_hw * ,
                                                                struct net_device * ) ,
                                                    struct ixgbe_hw *arg1 , struct net_device *arg2 ) ;
#line 535
void ldv_dummy_resourceless_instance_callback_8_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 536
void ldv_dummy_resourceless_instance_callback_8_150(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 537
void ldv_dummy_resourceless_instance_callback_8_153(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 538
void ldv_dummy_resourceless_instance_callback_8_156(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char arg3 ) ;
#line 539
void ldv_dummy_resourceless_instance_callback_8_159(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) ;
#line 540
void ldv_dummy_resourceless_instance_callback_8_16(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 541
void ldv_dummy_resourceless_instance_callback_8_162(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ) ;
#line 542
void ldv_dummy_resourceless_instance_callback_8_165(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 ) ;
#line 543
void ldv_dummy_resourceless_instance_callback_8_168(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 544
void ldv_dummy_resourceless_instance_callback_8_171(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short arg4 ) ;
#line 545
void ldv_dummy_resourceless_instance_callback_8_174(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short arg4 ) ;
#line 546
void ldv_dummy_resourceless_instance_callback_8_19(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 547
void ldv_dummy_resourceless_instance_callback_8_22(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 548
void ldv_dummy_resourceless_instance_callback_8_25(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , _Bool * ,
                                                               _Bool  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int *arg2 , _Bool *arg3 ,
                                                   _Bool arg4 ) ;
#line 549
void ldv_dummy_resourceless_instance_callback_8_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 550
void ldv_dummy_resourceless_instance_callback_8_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 551
void ldv_dummy_resourceless_instance_callback_8_3(int (*arg0)(struct ixgbe_hw * ,
                                                              unsigned short  ) ,
                                                  struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 552
void ldv_dummy_resourceless_instance_callback_8_30(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 553
void ldv_dummy_resourceless_instance_callback_8_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 554
void ldv_dummy_resourceless_instance_callback_8_34(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  , unsigned int  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                   unsigned int arg3 ) ;
#line 555
void ldv_dummy_resourceless_instance_callback_8_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 556
void ldv_dummy_resourceless_instance_callback_8_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 557
void ldv_dummy_resourceless_instance_callback_8_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 558
void ldv_dummy_resourceless_instance_callback_8_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 559
void ldv_dummy_resourceless_instance_callback_8_41(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 560
void ldv_dummy_resourceless_instance_callback_8_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 561
void ldv_dummy_resourceless_instance_callback_8_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 562
void ldv_dummy_resourceless_instance_callback_8_46(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 563
void ldv_dummy_resourceless_instance_callback_8_49(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 564
void ldv_dummy_resourceless_instance_callback_8_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 565
void ldv_dummy_resourceless_instance_callback_8_53(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , _Bool * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                   _Bool *arg3 ) ;
#line 566
void ldv_dummy_resourceless_instance_callback_8_56(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 567
void ldv_dummy_resourceless_instance_callback_8_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 568
void ldv_dummy_resourceless_instance_callback_8_60(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 569
void ldv_dummy_resourceless_instance_callback_8_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 570
void ldv_dummy_resourceless_instance_callback_8_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 571
void ldv_dummy_resourceless_instance_callback_8_65(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                   unsigned short *arg3 ) ;
#line 572
void ldv_dummy_resourceless_instance_callback_8_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 573
void ldv_dummy_resourceless_instance_callback_8_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 574
void ldv_dummy_resourceless_instance_callback_8_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 575
void ldv_dummy_resourceless_instance_callback_8_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 576
void ldv_dummy_resourceless_instance_callback_8_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 577
void ldv_dummy_resourceless_instance_callback_8_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 578
void ldv_dummy_resourceless_instance_callback_8_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 579
void ldv_dummy_resourceless_instance_callback_8_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 580
void ldv_dummy_resourceless_instance_callback_8_76(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 581
void ldv_dummy_resourceless_instance_callback_8_79(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 582
void ldv_dummy_resourceless_instance_callback_8_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 583
void ldv_dummy_resourceless_instance_callback_8_83(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , unsigned short  ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                   unsigned short arg3 , unsigned short arg4 ) ;
#line 584
void ldv_dummy_resourceless_instance_callback_8_86(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 585
void ldv_dummy_resourceless_instance_callback_8_89(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  , unsigned short  ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 , unsigned short *arg4 ) ;
#line 586
void ldv_dummy_resourceless_instance_callback_8_9(int (*arg0)(struct ixgbe_hw * ,
                                                              unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                  unsigned int arg2 ) ;
#line 587
void ldv_dummy_resourceless_instance_callback_8_92(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char  ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char arg3 , unsigned char *arg4 ) ;
#line 588
void ldv_dummy_resourceless_instance_callback_8_95(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char *arg3 ) ;
#line 589
void ldv_dummy_resourceless_instance_callback_8_98(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char *arg3 ) ;
#line 590
void ldv_dummy_resourceless_instance_callback_9_101(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 591
void ldv_dummy_resourceless_instance_callback_9_104(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short *arg4 ) ;
#line 592
void ldv_dummy_resourceless_instance_callback_9_107(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short *arg4 ) ;
#line 593
void ldv_dummy_resourceless_instance_callback_9_110(void (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 594
void ldv_dummy_resourceless_instance_callback_9_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 595
void ldv_dummy_resourceless_instance_callback_9_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 596
void ldv_dummy_resourceless_instance_callback_9_115(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ,
                                                    unsigned char arg5 ) ;
#line 597
void ldv_dummy_resourceless_instance_callback_9_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 598
void ldv_dummy_resourceless_instance_callback_9_119(void (*arg0)(struct ixgbe_hw * ,
                                                                 _Bool  , int  ) ,
                                                    struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                    int arg3 ) ;
#line 599
void ldv_dummy_resourceless_instance_callback_9_12(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 600
void ldv_dummy_resourceless_instance_callback_9_122(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 , unsigned int arg4 ,
                                                    unsigned int arg5 ) ;
#line 601
void ldv_dummy_resourceless_instance_callback_9_125(void (*arg0)(struct ixgbe_hw * ,
                                                                 int  , unsigned int  ,
                                                                 int  ) , struct ixgbe_hw *arg1 ,
                                                    int arg2 , unsigned int arg3 ,
                                                    int arg4 ) ;
#line 602
void ldv_dummy_resourceless_instance_callback_9_128(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int arg2 , unsigned int arg3 ,
                                                    _Bool arg4 ) ;
#line 603
void ldv_dummy_resourceless_instance_callback_9_131(void (*arg0)(struct ixgbe_hw * ,
                                                                 _Bool  , int  ) ,
                                                    struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                    int arg3 ) ;
#line 604
void ldv_dummy_resourceless_instance_callback_9_134(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) ;
#line 605
void ldv_dummy_resourceless_instance_callback_9_137(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) ;
#line 606
void ldv_dummy_resourceless_instance_callback_9_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 607
void ldv_dummy_resourceless_instance_callback_9_141(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , _Bool  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    _Bool arg3 ) ;
#line 608
void ldv_dummy_resourceless_instance_callback_9_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 609
void ldv_dummy_resourceless_instance_callback_9_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 610
void ldv_dummy_resourceless_instance_callback_9_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 611
void ldv_dummy_resourceless_instance_callback_9_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 612
void ldv_dummy_resourceless_instance_callback_9_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) ;
#line 613
void ldv_dummy_resourceless_instance_callback_9_149(int (*arg0)(struct ixgbe_hw * ,
                                                                struct net_device * ) ,
                                                    struct ixgbe_hw *arg1 , struct net_device *arg2 ) ;
#line 614
void ldv_dummy_resourceless_instance_callback_9_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 615
void ldv_dummy_resourceless_instance_callback_9_150(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 616
void ldv_dummy_resourceless_instance_callback_9_153(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 617
void ldv_dummy_resourceless_instance_callback_9_156(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char arg3 ) ;
#line 618
void ldv_dummy_resourceless_instance_callback_9_159(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) ;
#line 619
void ldv_dummy_resourceless_instance_callback_9_16(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 620
void ldv_dummy_resourceless_instance_callback_9_162(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ) ;
#line 621
void ldv_dummy_resourceless_instance_callback_9_165(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 ) ;
#line 622
void ldv_dummy_resourceless_instance_callback_9_168(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) ;
#line 623
void ldv_dummy_resourceless_instance_callback_9_171(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short arg4 ) ;
#line 624
void ldv_dummy_resourceless_instance_callback_9_174(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short arg4 ) ;
#line 625
void ldv_dummy_resourceless_instance_callback_9_19(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 626
void ldv_dummy_resourceless_instance_callback_9_22(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 627
void ldv_dummy_resourceless_instance_callback_9_25(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , _Bool * ,
                                                               _Bool  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int *arg2 , _Bool *arg3 ,
                                                   _Bool arg4 ) ;
#line 628
void ldv_dummy_resourceless_instance_callback_9_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 629
void ldv_dummy_resourceless_instance_callback_9_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 630
void ldv_dummy_resourceless_instance_callback_9_3(int (*arg0)(struct ixgbe_hw * ,
                                                              unsigned short  ) ,
                                                  struct ixgbe_hw *arg1 , unsigned short arg2 ) ;
#line 631
void ldv_dummy_resourceless_instance_callback_9_30(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 632
void ldv_dummy_resourceless_instance_callback_9_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 633
void ldv_dummy_resourceless_instance_callback_9_34(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  , unsigned int  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                   unsigned int arg3 ) ;
#line 634
void ldv_dummy_resourceless_instance_callback_9_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 635
void ldv_dummy_resourceless_instance_callback_9_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 636
void ldv_dummy_resourceless_instance_callback_9_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 637
void ldv_dummy_resourceless_instance_callback_9_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 638
void ldv_dummy_resourceless_instance_callback_9_41(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 639
void ldv_dummy_resourceless_instance_callback_9_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 640
void ldv_dummy_resourceless_instance_callback_9_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 641
void ldv_dummy_resourceless_instance_callback_9_46(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 642
void ldv_dummy_resourceless_instance_callback_9_49(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ) ;
#line 643
void ldv_dummy_resourceless_instance_callback_9_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 644
void ldv_dummy_resourceless_instance_callback_9_53(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , _Bool * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                   _Bool *arg3 ) ;
#line 645
void ldv_dummy_resourceless_instance_callback_9_56(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 646
void ldv_dummy_resourceless_instance_callback_9_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 647
void ldv_dummy_resourceless_instance_callback_9_60(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char *arg2 ) ;
#line 648
void ldv_dummy_resourceless_instance_callback_9_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 649
void ldv_dummy_resourceless_instance_callback_9_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 650
void ldv_dummy_resourceless_instance_callback_9_65(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                   unsigned short *arg3 ) ;
#line 651
void ldv_dummy_resourceless_instance_callback_9_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 652
void ldv_dummy_resourceless_instance_callback_9_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 653
void ldv_dummy_resourceless_instance_callback_9_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 654
void ldv_dummy_resourceless_instance_callback_9_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 655
void ldv_dummy_resourceless_instance_callback_9_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 656
void ldv_dummy_resourceless_instance_callback_9_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 657
void ldv_dummy_resourceless_instance_callback_9_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 658
void ldv_dummy_resourceless_instance_callback_9_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 659
void ldv_dummy_resourceless_instance_callback_9_76(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 660
void ldv_dummy_resourceless_instance_callback_9_79(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) ;
#line 661
void ldv_dummy_resourceless_instance_callback_9_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) ;
#line 662
void ldv_dummy_resourceless_instance_callback_9_83(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , unsigned short  ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                   unsigned short arg3 , unsigned short arg4 ) ;
#line 663
void ldv_dummy_resourceless_instance_callback_9_86(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 664
void ldv_dummy_resourceless_instance_callback_9_89(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  , unsigned short  ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 , unsigned short *arg4 ) ;
#line 665
void ldv_dummy_resourceless_instance_callback_9_9(int (*arg0)(struct ixgbe_hw * ,
                                                              unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                  unsigned int arg2 ) ;
#line 666
void ldv_dummy_resourceless_instance_callback_9_92(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char  ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char arg3 , unsigned char *arg4 ) ;
#line 667
void ldv_dummy_resourceless_instance_callback_9_95(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char *arg3 ) ;
#line 668
void ldv_dummy_resourceless_instance_callback_9_98(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char *arg3 ) ;
#line 669
void ldv_entry_EMGentry_31(void *arg0 ) ;
#line 670
void main(void) ;
#line 671
void ldv_file_operations_file_operations_instance_0(void *arg0 ) ;
#line 672
void ldv_file_operations_file_operations_instance_1(void *arg0 ) ;
#line 673
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) ;
#line 674
void ldv_free_netdev(void *arg0 , struct net_device *arg1 ) ;
#line 675
enum irqreturn ldv_interrupt_instance_handler_2_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 676
enum irqreturn ldv_interrupt_instance_handler_3_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 677
enum irqreturn ldv_interrupt_instance_handler_4_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 678
void ldv_interrupt_instance_thread_2_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 679
void ldv_interrupt_instance_thread_3_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 680
void ldv_interrupt_instance_thread_4_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 681
void ldv_interrupt_instance_thread_5_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 682
void ldv_interrupt_interrupt_instance_2(void *arg0 ) ;
#line 683
void ldv_interrupt_interrupt_instance_3(void *arg0 ) ;
#line 684
void ldv_interrupt_interrupt_instance_4(void *arg0 ) ;
#line 685
void ldv_interrupt_interrupt_instance_5(void *arg0 ) ;
#line 686
int ldv_mod_timer(int arg0 , struct timer_list *arg1 , unsigned long arg2 ) ;
#line 687
void ldv_net_dummy_resourceless_instance_6(void *arg0 ) ;
#line 688
void ldv_pci_instance_callback_7_10(unsigned int (*arg0)(struct pci_dev * , enum pci_channel_state  ) ,
                                    struct pci_dev *arg1 , enum pci_channel_state arg2 ) ;
#line 689
void ldv_pci_instance_callback_7_23(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 690
void ldv_pci_instance_callback_7_24(unsigned int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 691
void ldv_pci_instance_callback_7_25(int (*arg0)(struct pci_dev * , int  ) , struct pci_dev *arg1 ,
                                    int arg2 ) ;
#line 692
int ldv_pci_instance_probe_7_17(int (*arg0)(struct pci_dev * , struct pci_device_id * ) ,
                                struct pci_dev *arg1 , struct pci_device_id *arg2 ) ;
#line 693
void ldv_pci_instance_release_7_2(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 694
void ldv_pci_instance_resume_7_5(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 695
void ldv_pci_instance_resume_early_7_6(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 696
void ldv_pci_instance_shutdown_7_3(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 697
int ldv_pci_instance_suspend_7_8(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                 struct pci_dev *arg1 , struct pm_message arg2 ) ;
#line 698
int ldv_pci_instance_suspend_late_7_7(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                      struct pci_dev *arg1 , struct pm_message arg2 ) ;
#line 699
void ldv_pci_pci_instance_7(void *arg0 ) ;
#line 700
void ldv_pci_unregister_driver(void *arg0 , struct pci_driver *arg1 ) ;
#line 701
int ldv_register_netdev(int arg0 , struct net_device *arg1 ) ;
#line 702
int ldv_register_netdev_open_21_6(int (*arg0)(struct net_device * ) , struct net_device *arg1 ) ;
#line 703
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) ;
#line 704
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_10(void *arg0 ) ;
#line 705
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_11(void *arg0 ) ;
#line 706
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_12(void *arg0 ) ;
#line 707
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_13(void *arg0 ) ;
#line 708
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_8(void *arg0 ) ;
#line 709
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_9(void *arg0 ) ;
#line 710
void ldv_struct_notifier_block_dummy_resourceless_instance_14(void *arg0 ) ;
#line 711
void ldv_timer_instance_callback_15_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) ;
#line 712
void ldv_timer_timer_instance_15(void *arg0 ) ;
#line 713
void ldv_unregister_netdev(void *arg0 , struct net_device *arg1 ) ;
#line 714
void ldv_unregister_netdev_stop_26_2(int (*arg0)(struct net_device * ) , struct net_device *arg1 ) ;
#line 717 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_10  ;
#line 718 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_11  ;
#line 719 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_12  ;
#line 720 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_13  ;
#line 721 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_14  ;
#line 722 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_15  ;
#line 723 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_2  ;
#line 724 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_3  ;
#line 725 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_31  ;
#line 726 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_4  ;
#line 727 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_6  ;
#line 728 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_7  ;
#line 729 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_8  ;
#line 730 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct ldv_thread ldv_thread_9  ;
#line 736 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_EMGentry_exit_ixgbe_exit_module_31_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 737
  ixgbe_exit_module();
  }
#line 738
  return;
}
}
#line 741 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv_EMGentry_init_ixgbe_init_module_31_11(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 742
  tmp = ixgbe_init_module();
  }
#line 742
  return (tmp);
}
}
#line 746 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv___pci_register_driver(int arg0 , struct pci_driver *arg1 , struct module *arg2 ,
                              char *arg3 ) 
{ 
  struct pci_driver *ldv_28_pci_driver_pci_driver ;
  int tmp ;

  {
  {
#line 753
  tmp = ldv_undef_int();
  }
#line 753
  if (tmp != 0) {
    {
#line 755
    ldv_assume(arg0 == 0);
#line 756
    ldv_28_pci_driver_pci_driver = arg1;
#line 760
    ldv_dispatch_register_28_2(ldv_28_pci_driver_pci_driver);
    }
#line 764
    return (arg0);
  } else {
    {
#line 768
    ldv_assume(arg0 != 0);
    }
#line 772
    return (arg0);
  }
#line 775
  return (arg0);
}
}
#line 780 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
struct net_device *ldv_alloc_etherdev_mqs(struct net_device *arg0 , int arg1 , unsigned int arg2 ,
                                          unsigned int arg3 ) 
{ 
  struct net_device *ldv_16_netdev_net_device ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 787
  tmp___0 = ldv_undef_int();
  }
#line 787
  if (tmp___0 != 0) {
    {
#line 789
    tmp = ldv_xmalloc(3200UL);
#line 789
    ldv_16_netdev_net_device = (struct net_device *)tmp;
    }
#line 793
    return (ldv_16_netdev_net_device);
#line 797
    return (arg0);
  } else {
#line 801
    return ((struct net_device *)0);
#line 805
    return (arg0);
  }
#line 808
  return (arg0);
}
}
#line 813 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dca_register_notify(void *arg0 , struct notifier_block *arg1 ) 
{ 
  struct notifier_block *ldv_30_struct_notifier_block_struct_notifier_block ;

  {
  {
#line 819
  ldv_30_struct_notifier_block_struct_notifier_block = arg1;
#line 823
  ldv_dispatch_register_30_1(ldv_30_struct_notifier_block_struct_notifier_block);
  }
#line 827
  return;
#line 829
  return;
}
}
#line 834 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dca_unregister_notify(void *arg0 , struct notifier_block *arg1 ) 
{ 
  struct notifier_block *ldv_29_struct_notifier_block_struct_notifier_block ;

  {
  {
#line 840
  ldv_29_struct_notifier_block_struct_notifier_block = arg1;
#line 844
  ldv_dispatch_deregister_29_1(ldv_29_struct_notifier_block_struct_notifier_block);
  }
#line 848
  return;
#line 850
  return;
}
}
#line 855 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_deregister_26_1(struct net_device *arg0 ) 
{ 


  {
#line 859
  return;
}
}
#line 863 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_deregister_27_1(struct pci_driver *arg0 ) 
{ 


  {
#line 867
  return;
}
}
#line 871 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_deregister_29_1(struct notifier_block *arg0 ) 
{ 


  {
#line 875
  return;
}
}
#line 879 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_15_31_4(void) 
{ 


  {
#line 893
  return;
}
}
#line 897 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_deregister_file_operations_instance_9_31_5(void) 
{ 


  {
#line 903
  return;
}
}
#line 907 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_instance_register_20_2(struct timer_list *arg0 ) 
{ 
  struct ldv_struct_timer_instance_15 *cf_arg_15 ;
  void *tmp ;

  {
  {
#line 910
  tmp = ldv_xmalloc(16UL);
#line 910
  cf_arg_15 = (struct ldv_struct_timer_instance_15 *)tmp;
#line 911
  cf_arg_15->arg0 = arg0;
#line 912
  ldv_timer_timer_instance_15((void *)cf_arg_15);
  }
#line 913
  return;
}
}
#line 917 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_irq_register_22_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_2 *cf_arg_2 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_3 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_4 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_5 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 923
  tmp = ldv_undef_int();
  }
  {
#line 924
  if (tmp == 0) {
#line 924
    goto case_0;
  } else {

  }
#line 933
  if (tmp == 1) {
#line 933
    goto case_1;
  } else {

  }
#line 942
  if (tmp == 2) {
#line 942
    goto case_2;
  } else {

  }
#line 951
  if (tmp == 3) {
#line 951
    goto case_3;
  } else {

  }
#line 960
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 925
  tmp___0 = ldv_xmalloc(40UL);
#line 925
  cf_arg_2 = (struct ldv_struct_interrupt_instance_2 *)tmp___0;
#line 926
  cf_arg_2->arg0 = arg0;
#line 927
  cf_arg_2->arg1 = arg1;
#line 928
  cf_arg_2->arg2 = arg2;
#line 929
  cf_arg_2->arg3 = arg3;
#line 930
  ldv_interrupt_interrupt_instance_2((void *)cf_arg_2);
  }
#line 931
  goto ldv_59737;
  case_1: /* CIL Label */ 
  {
#line 934
  tmp___1 = ldv_xmalloc(40UL);
#line 934
  cf_arg_3 = (struct ldv_struct_interrupt_instance_2 *)tmp___1;
#line 935
  cf_arg_3->arg0 = arg0;
#line 936
  cf_arg_3->arg1 = arg1;
#line 937
  cf_arg_3->arg2 = arg2;
#line 938
  cf_arg_3->arg3 = arg3;
#line 939
  ldv_interrupt_interrupt_instance_3((void *)cf_arg_3);
  }
#line 940
  goto ldv_59737;
  case_2: /* CIL Label */ 
  {
#line 943
  tmp___2 = ldv_xmalloc(40UL);
#line 943
  cf_arg_4 = (struct ldv_struct_interrupt_instance_2 *)tmp___2;
#line 944
  cf_arg_4->arg0 = arg0;
#line 945
  cf_arg_4->arg1 = arg1;
#line 946
  cf_arg_4->arg2 = arg2;
#line 947
  cf_arg_4->arg3 = arg3;
#line 948
  ldv_interrupt_interrupt_instance_4((void *)cf_arg_4);
  }
#line 949
  goto ldv_59737;
  case_3: /* CIL Label */ 
  {
#line 952
  tmp___3 = ldv_xmalloc(40UL);
#line 952
  cf_arg_5 = (struct ldv_struct_interrupt_instance_2 *)tmp___3;
#line 953
  cf_arg_5->arg0 = arg0;
#line 954
  cf_arg_5->arg1 = arg1;
#line 955
  cf_arg_5->arg2 = arg2;
#line 956
  cf_arg_5->arg3 = arg3;
#line 957
  ldv_interrupt_interrupt_instance_5((void *)cf_arg_5);
  }
#line 958
  goto ldv_59737;
  switch_default: /* CIL Label */ 
  {
#line 960
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_59737: ;
#line 962
  return;
}
}
#line 966 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_irq_register_23_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_2 *cf_arg_2 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_3 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_4 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_5 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 972
  tmp = ldv_undef_int();
  }
  {
#line 973
  if (tmp == 0) {
#line 973
    goto case_0;
  } else {

  }
#line 982
  if (tmp == 1) {
#line 982
    goto case_1;
  } else {

  }
#line 991
  if (tmp == 2) {
#line 991
    goto case_2;
  } else {

  }
#line 1000
  if (tmp == 3) {
#line 1000
    goto case_3;
  } else {

  }
#line 1009
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 974
  tmp___0 = ldv_xmalloc(40UL);
#line 974
  cf_arg_2 = (struct ldv_struct_interrupt_instance_2 *)tmp___0;
#line 975
  cf_arg_2->arg0 = arg0;
#line 976
  cf_arg_2->arg1 = arg1;
#line 977
  cf_arg_2->arg2 = arg2;
#line 978
  cf_arg_2->arg3 = arg3;
#line 979
  ldv_interrupt_interrupt_instance_2((void *)cf_arg_2);
  }
#line 980
  goto ldv_59758;
  case_1: /* CIL Label */ 
  {
#line 983
  tmp___1 = ldv_xmalloc(40UL);
#line 983
  cf_arg_3 = (struct ldv_struct_interrupt_instance_2 *)tmp___1;
#line 984
  cf_arg_3->arg0 = arg0;
#line 985
  cf_arg_3->arg1 = arg1;
#line 986
  cf_arg_3->arg2 = arg2;
#line 987
  cf_arg_3->arg3 = arg3;
#line 988
  ldv_interrupt_interrupt_instance_3((void *)cf_arg_3);
  }
#line 989
  goto ldv_59758;
  case_2: /* CIL Label */ 
  {
#line 992
  tmp___2 = ldv_xmalloc(40UL);
#line 992
  cf_arg_4 = (struct ldv_struct_interrupt_instance_2 *)tmp___2;
#line 993
  cf_arg_4->arg0 = arg0;
#line 994
  cf_arg_4->arg1 = arg1;
#line 995
  cf_arg_4->arg2 = arg2;
#line 996
  cf_arg_4->arg3 = arg3;
#line 997
  ldv_interrupt_interrupt_instance_4((void *)cf_arg_4);
  }
#line 998
  goto ldv_59758;
  case_3: /* CIL Label */ 
  {
#line 1001
  tmp___3 = ldv_xmalloc(40UL);
#line 1001
  cf_arg_5 = (struct ldv_struct_interrupt_instance_2 *)tmp___3;
#line 1002
  cf_arg_5->arg0 = arg0;
#line 1003
  cf_arg_5->arg1 = arg1;
#line 1004
  cf_arg_5->arg2 = arg2;
#line 1005
  cf_arg_5->arg3 = arg3;
#line 1006
  ldv_interrupt_interrupt_instance_5((void *)cf_arg_5);
  }
#line 1007
  goto ldv_59758;
  switch_default: /* CIL Label */ 
  {
#line 1009
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_59758: ;
#line 1011
  return;
}
}
#line 1015 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_irq_register_24_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_2 *cf_arg_2 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_3 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_4 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_5 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1021
  tmp = ldv_undef_int();
  }
  {
#line 1022
  if (tmp == 0) {
#line 1022
    goto case_0;
  } else {

  }
#line 1031
  if (tmp == 1) {
#line 1031
    goto case_1;
  } else {

  }
#line 1040
  if (tmp == 2) {
#line 1040
    goto case_2;
  } else {

  }
#line 1049
  if (tmp == 3) {
#line 1049
    goto case_3;
  } else {

  }
#line 1058
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1023
  tmp___0 = ldv_xmalloc(40UL);
#line 1023
  cf_arg_2 = (struct ldv_struct_interrupt_instance_2 *)tmp___0;
#line 1024
  cf_arg_2->arg0 = arg0;
#line 1025
  cf_arg_2->arg1 = arg1;
#line 1026
  cf_arg_2->arg2 = arg2;
#line 1027
  cf_arg_2->arg3 = arg3;
#line 1028
  ldv_interrupt_interrupt_instance_2((void *)cf_arg_2);
  }
#line 1029
  goto ldv_59779;
  case_1: /* CIL Label */ 
  {
#line 1032
  tmp___1 = ldv_xmalloc(40UL);
#line 1032
  cf_arg_3 = (struct ldv_struct_interrupt_instance_2 *)tmp___1;
#line 1033
  cf_arg_3->arg0 = arg0;
#line 1034
  cf_arg_3->arg1 = arg1;
#line 1035
  cf_arg_3->arg2 = arg2;
#line 1036
  cf_arg_3->arg3 = arg3;
#line 1037
  ldv_interrupt_interrupt_instance_3((void *)cf_arg_3);
  }
#line 1038
  goto ldv_59779;
  case_2: /* CIL Label */ 
  {
#line 1041
  tmp___2 = ldv_xmalloc(40UL);
#line 1041
  cf_arg_4 = (struct ldv_struct_interrupt_instance_2 *)tmp___2;
#line 1042
  cf_arg_4->arg0 = arg0;
#line 1043
  cf_arg_4->arg1 = arg1;
#line 1044
  cf_arg_4->arg2 = arg2;
#line 1045
  cf_arg_4->arg3 = arg3;
#line 1046
  ldv_interrupt_interrupt_instance_4((void *)cf_arg_4);
  }
#line 1047
  goto ldv_59779;
  case_3: /* CIL Label */ 
  {
#line 1050
  tmp___3 = ldv_xmalloc(40UL);
#line 1050
  cf_arg_5 = (struct ldv_struct_interrupt_instance_2 *)tmp___3;
#line 1051
  cf_arg_5->arg0 = arg0;
#line 1052
  cf_arg_5->arg1 = arg1;
#line 1053
  cf_arg_5->arg2 = arg2;
#line 1054
  cf_arg_5->arg3 = arg3;
#line 1055
  ldv_interrupt_interrupt_instance_5((void *)cf_arg_5);
  }
#line 1056
  goto ldv_59779;
  switch_default: /* CIL Label */ 
  {
#line 1058
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_59779: ;
#line 1060
  return;
}
}
#line 1064 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_register_21_4(struct net_device *arg0 ) 
{ 
  struct ldv_struct_dummy_resourceless_instance_6 *cf_arg_6 ;
  void *tmp ;

  {
  {
#line 1067
  tmp = ldv_xmalloc(16UL);
#line 1067
  cf_arg_6 = (struct ldv_struct_dummy_resourceless_instance_6 *)tmp;
#line 1068
  cf_arg_6->arg0 = arg0;
#line 1069
  ldv_net_dummy_resourceless_instance_6((void *)cf_arg_6);
  }
#line 1070
  return;
}
}
#line 1074 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_register_28_2(struct pci_driver *arg0 ) 
{ 
  struct ldv_struct_pci_instance_7 *cf_arg_7 ;
  void *tmp ;

  {
  {
#line 1077
  tmp = ldv_xmalloc(16UL);
#line 1077
  cf_arg_7 = (struct ldv_struct_pci_instance_7 *)tmp;
#line 1078
  cf_arg_7->arg0 = arg0;
#line 1079
  ldv_pci_pci_instance_7((void *)cf_arg_7);
  }
#line 1080
  return;
}
}
#line 1084 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_register_30_1(struct notifier_block *arg0 ) 
{ 
  struct ldv_struct_dummy_resourceless_instance_14 *cf_arg_14 ;
  void *tmp ;

  {
  {
#line 1087
  tmp = ldv_xmalloc(16UL);
#line 1087
  cf_arg_14 = (struct ldv_struct_dummy_resourceless_instance_14 *)tmp;
#line 1088
  cf_arg_14->arg0 = arg0;
#line 1089
  ldv_struct_notifier_block_dummy_resourceless_instance_14((void *)cf_arg_14);
  }
#line 1090
  return;
}
}
#line 1094 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_15_31_6(void) 
{ 
  struct ldv_struct_EMGentry_31 *cf_arg_8 ;
  struct ldv_struct_EMGentry_31 *cf_arg_9 ;
  struct ldv_struct_EMGentry_31 *cf_arg_10 ;
  struct ldv_struct_EMGentry_31 *cf_arg_11 ;
  struct ldv_struct_EMGentry_31 *cf_arg_12 ;
  struct ldv_struct_EMGentry_31 *cf_arg_13 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 1102
  tmp = ldv_xmalloc(4UL);
#line 1102
  cf_arg_8 = (struct ldv_struct_EMGentry_31 *)tmp;
#line 1103
  ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_8((void *)cf_arg_8);
#line 1104
  tmp___0 = ldv_xmalloc(4UL);
#line 1104
  cf_arg_9 = (struct ldv_struct_EMGentry_31 *)tmp___0;
#line 1105
  ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_9((void *)cf_arg_9);
#line 1106
  tmp___1 = ldv_xmalloc(4UL);
#line 1106
  cf_arg_10 = (struct ldv_struct_EMGentry_31 *)tmp___1;
#line 1107
  ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_10((void *)cf_arg_10);
#line 1108
  tmp___2 = ldv_xmalloc(4UL);
#line 1108
  cf_arg_11 = (struct ldv_struct_EMGentry_31 *)tmp___2;
#line 1109
  ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_11((void *)cf_arg_11);
#line 1110
  tmp___3 = ldv_xmalloc(4UL);
#line 1110
  cf_arg_12 = (struct ldv_struct_EMGentry_31 *)tmp___3;
#line 1111
  ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_12((void *)cf_arg_12);
#line 1112
  tmp___4 = ldv_xmalloc(4UL);
#line 1112
  cf_arg_13 = (struct ldv_struct_EMGentry_31 *)tmp___4;
#line 1113
  ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_13((void *)cf_arg_13);
  }
#line 1114
  return;
}
}
#line 1118 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dispatch_register_file_operations_instance_9_31_7(void) 
{ 
  struct ldv_struct_EMGentry_31 *cf_arg_0 ;
  struct ldv_struct_EMGentry_31 *cf_arg_1 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1122
  tmp = ldv_xmalloc(4UL);
#line 1122
  cf_arg_0 = (struct ldv_struct_EMGentry_31 *)tmp;
#line 1123
  ldv_file_operations_file_operations_instance_0((void *)cf_arg_0);
#line 1124
  tmp___0 = ldv_xmalloc(4UL);
#line 1124
  cf_arg_1 = (struct ldv_struct_EMGentry_31 *)tmp___0;
#line 1125
  ldv_file_operations_file_operations_instance_1((void *)cf_arg_1);
  }
#line 1126
  return;
}
}
#line 1130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_14_3(int (*arg0)(struct notifier_block * ,
                                                               unsigned long  , void * ) ,
                                                   struct notifier_block *arg1 , unsigned long arg2 ,
                                                   void *arg3 ) 
{ 


  {
  {
#line 1131
  ixgbe_notify_dca(arg1, arg2, arg3);
  }
#line 1132
  return;
}
}
#line 1135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_100(int (*arg0)(struct net_device * ,
                                                                struct netdev_fcoe_hbainfo * ) ,
                                                    struct net_device *arg1 , struct netdev_fcoe_hbainfo *arg2 ) 
{ 


  {
  {
#line 1136
  ixgbe_fcoe_get_hbainfo(arg1, arg2);
  }
#line 1137
  return;
}
}
#line 1140 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_101(int (*arg0)(struct net_device * ,
                                                                unsigned long long * ,
                                                                int  ) , struct net_device *arg1 ,
                                                    unsigned long long *arg2 , int arg3 ) 
{ 


  {
  {
#line 1141
  ixgbe_fcoe_get_wwn(arg1, arg2, arg3);
  }
#line 1142
  return;
}
}
#line 1145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_104(int (*arg0)(struct ndmsg * , struct nlattr ** ,
                                                                struct net_device * ,
                                                                unsigned char * ,
                                                                unsigned short  ) ,
                                                    struct ndmsg *arg1 , struct nlattr **arg2 ,
                                                    struct net_device *arg3 , unsigned char *arg4 ,
                                                    unsigned short arg5 ) 
{ 


  {
  {
#line 1146
  ixgbe_ndo_fdb_add(arg1, arg2, arg3, (unsigned char const   *)arg4, (int )arg5);
  }
#line 1147
  return;
}
}
#line 1150 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_107(unsigned long long (*arg0)(struct net_device * ,
                                                                               unsigned long long  ) ,
                                                    struct net_device *arg1 , unsigned long long arg2 ) 
{ 


  {
  {
#line 1151
  ixgbe_fix_features(arg1, arg2);
  }
#line 1152
  return;
}
}
#line 1155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_110(struct rtnl_link_stats64 *(*arg0)(struct net_device * ,
                                                                                      struct rtnl_link_stats64 * ) ,
                                                    struct net_device *arg1 , struct rtnl_link_stats64 *arg2 ) 
{ 


  {
  {
#line 1156
  ixgbe_get_stats64(arg1, arg2);
  }
#line 1157
  return;
}
}
#line 1160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_111(int (*arg0)(struct net_device * ,
                                                                int  , struct ifla_vf_info * ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    struct ifla_vf_info *arg3 ) 
{ 


  {
  {
#line 1161
  ixgbe_ndo_get_vf_config(arg1, arg2, arg3);
  }
#line 1162
  return;
}
}
#line 1165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_114(void (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) 
{ 


  {
  {
#line 1166
  ixgbe_netpoll(arg1);
  }
#line 1167
  return;
}
}
#line 1170 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_115(unsigned short (*arg0)(struct net_device * ,
                                                                           struct sk_buff * ,
                                                                           void * ,
                                                                           unsigned short (*)(struct net_device * ,
                                                                                              struct sk_buff * ) ) ,
                                                    struct net_device *arg1 , struct sk_buff *arg2 ,
                                                    void *arg3 , unsigned short (*arg4)(struct net_device * ,
                                                                                        struct sk_buff * ) ) 
{ 


  {
  {
#line 1171
  ixgbe_select_queue(arg1, arg2, arg3, arg4);
  }
#line 1172
  return;
}
}
#line 1175 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_118(int (*arg0)(struct net_device * ,
                                                                unsigned long long  ) ,
                                                    struct net_device *arg1 , unsigned long long arg2 ) 
{ 


  {
  {
#line 1176
  ixgbe_set_features(arg1, arg2);
  }
#line 1177
  return;
}
}
#line 1180 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_121(int (*arg0)(struct net_device * ,
                                                                void * ) , struct net_device *arg1 ,
                                                    void *arg2 ) 
{ 


  {
  {
#line 1181
  ixgbe_set_mac(arg1, arg2);
  }
#line 1182
  return;
}
}
#line 1185 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_122(void (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) 
{ 


  {
  {
#line 1186
  ixgbe_set_rx_mode(arg1);
  }
#line 1187
  return;
}
}
#line 1190 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_123(int (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 1191
  ixgbe_ndo_set_vf_mac(arg1, arg2, arg3);
  }
#line 1192
  return;
}
}
#line 1195 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_126(int (*arg0)(struct net_device * ,
                                                                int  , _Bool  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    _Bool arg3 ) 
{ 


  {
  {
#line 1196
  ixgbe_ndo_set_vf_spoofchk(arg1, arg2, (int )arg3);
  }
#line 1197
  return;
}
}
#line 1200 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_129(int (*arg0)(struct net_device * ,
                                                                int  , int  ) , struct net_device *arg1 ,
                                                    int arg2 , int arg3 ) 
{ 


  {
  {
#line 1201
  ixgbe_ndo_set_vf_bw(arg1, arg2, arg3);
  }
#line 1202
  return;
}
}
#line 1205 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_132(int (*arg0)(struct net_device * ,
                                                                int  , unsigned short  ,
                                                                unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned short arg3 , unsigned char arg4 ) 
{ 


  {
  {
#line 1206
  ixgbe_ndo_set_vf_vlan(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 1207
  return;
}
}
#line 1210 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_135(int (*arg0)(struct net_device * ,
                                                                unsigned char  ) ,
                                                    struct net_device *arg1 , unsigned char arg2 ) 
{ 


  {
  {
#line 1211
  ixgbe_setup_tc(arg1, (int )arg2);
  }
#line 1212
  return;
}
}
#line 1215 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_138(enum netdev_tx (*arg0)(struct sk_buff * ,
                                                                           struct net_device * ) ,
                                                    struct sk_buff *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 1216
  ixgbe_xmit_frame(arg1, arg2);
  }
#line 1217
  return;
}
}
#line 1220 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_139(void (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) 
{ 


  {
  {
#line 1221
  ixgbe_tx_timeout(arg1);
  }
#line 1222
  return;
}
}
#line 1225 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_140(int (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) 
{ 


  {
  {
#line 1226
  eth_validate_addr(arg1);
  }
#line 1227
  return;
}
}
#line 1230 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_141(int (*arg0)(struct net_device * ,
                                                                unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct net_device *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 ) 
{ 


  {
  {
#line 1231
  ixgbe_vlan_rx_add_vid(arg1, (int )arg2, (int )arg3);
  }
#line 1232
  return;
}
}
#line 1235 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_144(int (*arg0)(struct net_device * ,
                                                                unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct net_device *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 ) 
{ 


  {
  {
#line 1236
  ixgbe_vlan_rx_kill_vid(arg1, (int )arg2, (int )arg3);
  }
#line 1237
  return;
}
}
#line 1240 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_74(int (*arg0)(struct sk_buff * ,
                                                               unsigned int  , unsigned int  ,
                                                               struct net_device * ,
                                                               unsigned int  ) , struct sk_buff *arg1 ,
                                                   unsigned int arg2 , unsigned int arg3 ,
                                                   struct net_device *arg4 , unsigned int arg5 ) 
{ 


  {
  {
#line 1241
  ixgbe_ndo_bridge_getlink(arg1, arg2, arg3, arg4, arg5);
  }
#line 1242
  return;
}
}
#line 1245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_77(int (*arg0)(struct net_device * ,
                                                               struct nlmsghdr * ) ,
                                                   struct net_device *arg1 , struct nlmsghdr *arg2 ) 
{ 


  {
  {
#line 1246
  ixgbe_ndo_bridge_setlink(arg1, arg2);
  }
#line 1247
  return;
}
}
#line 1250 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_78(int (*arg0)(struct napi_struct * ) ,
                                                   struct napi_struct *arg1 ) 
{ 


  {
  {
#line 1251
  ixgbe_low_latency_recv(arg1);
  }
#line 1252
  return;
}
}
#line 1255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_79(int (*arg0)(struct net_device * ,
                                                               int  ) , struct net_device *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 1256
  ixgbe_change_mtu(arg1, arg2);
  }
#line 1257
  return;
}
}
#line 1260 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_82(void *(*arg0)(struct net_device * ,
                                                                 struct net_device * ) ,
                                                   struct net_device *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 1261
  ixgbe_fwd_add(arg1, arg2);
  }
#line 1262
  return;
}
}
#line 1265 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_85(void (*arg0)(struct net_device * ,
                                                                void * ) , struct net_device *arg1 ,
                                                   void *arg2 ) 
{ 


  {
  {
#line 1266
  ixgbe_fwd_del(arg1, arg2);
  }
#line 1267
  return;
}
}
#line 1270 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_86(int (*arg0)(struct net_device * ,
                                                               struct ifreq * , int  ) ,
                                                   struct net_device *arg1 , struct ifreq *arg2 ,
                                                   int arg3 ) 
{ 


  {
  {
#line 1271
  ixgbe_ioctl(arg1, arg2, arg3);
  }
#line 1272
  return;
}
}
#line 1275 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_89(int (*arg0)(struct net_device * ,
                                                               unsigned short  ) ,
                                                   struct net_device *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 1276
  ixgbe_fcoe_ddp_put(arg1, (int )arg2);
  }
#line 1277
  return;
}
}
#line 1280 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_92(int (*arg0)(struct net_device * ,
                                                               unsigned short  , struct scatterlist * ,
                                                               unsigned int  ) , struct net_device *arg1 ,
                                                   unsigned short arg2 , struct scatterlist *arg3 ,
                                                   unsigned int arg4 ) 
{ 


  {
  {
#line 1281
  ixgbe_fcoe_ddp_get(arg1, (int )arg2, arg3, arg4);
  }
#line 1282
  return;
}
}
#line 1285 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_95(int (*arg0)(struct net_device * ,
                                                               unsigned short  , struct scatterlist * ,
                                                               unsigned int  ) , struct net_device *arg1 ,
                                                   unsigned short arg2 , struct scatterlist *arg3 ,
                                                   unsigned int arg4 ) 
{ 


  {
  {
#line 1286
  ixgbe_fcoe_ddp_target(arg1, (int )arg2, arg3, arg4);
  }
#line 1287
  return;
}
}
#line 1290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_98(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 1291
  ixgbe_fcoe_disable(arg1);
  }
#line 1292
  return;
}
}
#line 1295 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_99(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 1296
  ixgbe_fcoe_enable(arg1);
  }
#line 1297
  return;
}
}
#line 1300 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_entry_EMGentry_31(void *arg0 ) 
{ 
  void (*ldv_31_exit_ixgbe_exit_module_default)(void) ;
  int (*ldv_31_init_ixgbe_init_module_default)(void) ;
  int ldv_31_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1309
  ldv_31_ret_default = ldv_EMGentry_init_ixgbe_init_module_31_11(ldv_31_init_ixgbe_init_module_default);
#line 1311
  ldv_31_ret_default = ldv_post_init(ldv_31_ret_default);
#line 1314
  tmp___0 = ldv_undef_int();
  }
#line 1314
  if (tmp___0 != 0) {
    {
#line 1316
    ldv_assume(ldv_31_ret_default != 0);
#line 1320
    ldv_check_final_state();
#line 1321
    ldv_stop();
    }
#line 1325
    return;
  } else {
    {
#line 1329
    ldv_assume(ldv_31_ret_default == 0);
#line 1332
    tmp = ldv_undef_int();
    }
#line 1332
    if (tmp != 0) {
      {
#line 1334
      ldv_dispatch_register_file_operations_instance_9_31_7();
#line 1338
      ldv_dispatch_register_dummy_resourceless_instance_15_31_6();
#line 1342
      ldv_dispatch_deregister_file_operations_instance_9_31_5();
#line 1346
      ldv_dispatch_deregister_dummy_resourceless_instance_15_31_4();
      }
    } else {

    }
    {
#line 1357
    ldv_EMGentry_exit_ixgbe_exit_module_31_2(ldv_31_exit_ixgbe_exit_module_default);
#line 1361
    ldv_check_final_state();
#line 1362
    ldv_stop();
    }
#line 1366
    return;
  }
#line 1369
  return;
}
}
#line 1374 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void main(void) 
{ 


  {
  {
#line 1375
  ldv_initialize();
#line 1376
  ldv_entry_EMGentry_31((void *)0);
  }
#line 1377
  return;
}
}
#line 1381 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_free_netdev(void *arg0 , struct net_device *arg1 ) 
{ 
  struct net_device *ldv_19_netdev_net_device ;

  {
  {
#line 1387
  ldv_19_netdev_net_device = arg1;
#line 1388
  ldv_free((void *)ldv_19_netdev_net_device);
  }
#line 1392
  return;
#line 1394
  return;
}
}
#line 1399 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
enum irqreturn ldv_interrupt_instance_handler_2_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 1400
  tmp = ixgbe_intr(arg1, arg2);
  }
#line 1400
  return (tmp);
}
}
#line 1404 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
enum irqreturn ldv_interrupt_instance_handler_3_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 1405
  tmp = ixgbe_msix_clean_rings(arg1, arg2);
  }
#line 1405
  return (tmp);
}
}
#line 1409 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
enum irqreturn ldv_interrupt_instance_handler_4_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 1410
  tmp = ixgbe_msix_other(arg1, arg2);
  }
#line 1410
  return (tmp);
}
}
#line 1414 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_interrupt_instance_thread_2_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 1415
  (*arg0)(arg1, arg2);
  }
#line 1416
  return;
}
}
#line 1419 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_interrupt_instance_thread_3_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 1420
  (*arg0)(arg1, arg2);
  }
#line 1421
  return;
}
}
#line 1424 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_interrupt_instance_thread_4_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 1425
  (*arg0)(arg1, arg2);
  }
#line 1426
  return;
}
}
#line 1429 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_interrupt_instance_thread_5_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 1430
  (*arg0)(arg1, arg2);
  }
#line 1431
  return;
}
}
#line 1434 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_interrupt_interrupt_instance_2(void *arg0 ) 
{ 
  enum irqreturn (*ldv_2_callback_handler)(int  , void * ) ;
  void *ldv_2_data_data ;
  int ldv_2_line_line ;
  enum irqreturn ldv_2_ret_val_default ;
  enum irqreturn (*ldv_2_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_2 *data ;
  int tmp ;

  {
#line 1443
  data = (struct ldv_struct_interrupt_instance_2 *)arg0;
#line 1448
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_2 *)0)) {
    {
#line 1449
    ldv_2_line_line = data->arg0;
#line 1450
    ldv_2_callback_handler = data->arg1;
#line 1451
    ldv_2_thread_thread = data->arg2;
#line 1452
    ldv_2_data_data = data->arg3;
#line 1453
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1459
  ldv_switch_to_interrupt_context();
#line 1461
  ldv_2_ret_val_default = ldv_interrupt_instance_handler_2_5(ldv_2_callback_handler,
                                                             ldv_2_line_line, ldv_2_data_data);
#line 1463
  ldv_switch_to_process_context();
#line 1466
  tmp = ldv_undef_int();
  }
#line 1466
  if (tmp != 0) {
    {
#line 1468
    ldv_assume((unsigned int )ldv_2_ret_val_default == 2U);
    }
#line 1472
    if ((unsigned long )ldv_2_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                    void * ))0)) {
      {
#line 1474
      ldv_interrupt_instance_thread_2_3(ldv_2_thread_thread, ldv_2_line_line, ldv_2_data_data);
      }
    } else {

    }
  } else {
    {
#line 1481
    ldv_assume((unsigned int )ldv_2_ret_val_default != 2U);
    }
  }
#line 1490
  return;
#line 1492
  return;
}
}
#line 1497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_interrupt_interrupt_instance_3(void *arg0 ) 
{ 
  enum irqreturn (*ldv_3_callback_handler)(int  , void * ) ;
  void *ldv_3_data_data ;
  int ldv_3_line_line ;
  enum irqreturn ldv_3_ret_val_default ;
  enum irqreturn (*ldv_3_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_2 *data ;
  int tmp ;

  {
#line 1506
  data = (struct ldv_struct_interrupt_instance_2 *)arg0;
#line 1511
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_2 *)0)) {
    {
#line 1512
    ldv_3_line_line = data->arg0;
#line 1513
    ldv_3_callback_handler = data->arg1;
#line 1514
    ldv_3_thread_thread = data->arg2;
#line 1515
    ldv_3_data_data = data->arg3;
#line 1516
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1522
  ldv_switch_to_interrupt_context();
#line 1524
  ldv_3_ret_val_default = ldv_interrupt_instance_handler_3_5(ldv_3_callback_handler,
                                                             ldv_3_line_line, ldv_3_data_data);
#line 1526
  ldv_switch_to_process_context();
#line 1529
  tmp = ldv_undef_int();
  }
#line 1529
  if (tmp != 0) {
    {
#line 1531
    ldv_assume((unsigned int )ldv_3_ret_val_default == 2U);
    }
#line 1535
    if ((unsigned long )ldv_3_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                    void * ))0)) {
      {
#line 1537
      ldv_interrupt_instance_thread_3_3(ldv_3_thread_thread, ldv_3_line_line, ldv_3_data_data);
      }
    } else {

    }
  } else {
    {
#line 1544
    ldv_assume((unsigned int )ldv_3_ret_val_default != 2U);
    }
  }
#line 1553
  return;
#line 1555
  return;
}
}
#line 1560 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_interrupt_interrupt_instance_4(void *arg0 ) 
{ 
  enum irqreturn (*ldv_4_callback_handler)(int  , void * ) ;
  void *ldv_4_data_data ;
  int ldv_4_line_line ;
  enum irqreturn ldv_4_ret_val_default ;
  enum irqreturn (*ldv_4_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_2 *data ;
  int tmp ;

  {
#line 1569
  data = (struct ldv_struct_interrupt_instance_2 *)arg0;
#line 1574
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_2 *)0)) {
    {
#line 1575
    ldv_4_line_line = data->arg0;
#line 1576
    ldv_4_callback_handler = data->arg1;
#line 1577
    ldv_4_thread_thread = data->arg2;
#line 1578
    ldv_4_data_data = data->arg3;
#line 1579
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1585
  ldv_switch_to_interrupt_context();
#line 1587
  ldv_4_ret_val_default = ldv_interrupt_instance_handler_4_5(ldv_4_callback_handler,
                                                             ldv_4_line_line, ldv_4_data_data);
#line 1589
  ldv_switch_to_process_context();
#line 1592
  tmp = ldv_undef_int();
  }
#line 1592
  if (tmp != 0) {
    {
#line 1594
    ldv_assume((unsigned int )ldv_4_ret_val_default == 2U);
    }
#line 1598
    if ((unsigned long )ldv_4_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                    void * ))0)) {
      {
#line 1600
      ldv_interrupt_instance_thread_4_3(ldv_4_thread_thread, ldv_4_line_line, ldv_4_data_data);
      }
    } else {

    }
  } else {
    {
#line 1607
    ldv_assume((unsigned int )ldv_4_ret_val_default != 2U);
    }
  }
#line 1616
  return;
#line 1618
  return;
}
}
#line 1623 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv_mod_timer(int arg0 , struct timer_list *arg1 , unsigned long arg2 ) 
{ 
  struct timer_list *ldv_20_timer_list_timer_list ;
  int tmp ;

  {
  {
#line 1630
  tmp = ldv_undef_int();
  }
#line 1630
  if (tmp != 0) {
    {
#line 1632
    ldv_assume(arg0 == 0);
#line 1633
    ldv_20_timer_list_timer_list = arg1;
#line 1637
    ldv_dispatch_instance_register_20_2(ldv_20_timer_list_timer_list);
    }
#line 1641
    return (arg0);
  } else {
    {
#line 1645
    ldv_assume(arg0 != 0);
    }
#line 1649
    return (arg0);
  }
#line 1652
  return (arg0);
}
}
#line 1657 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_net_dummy_resourceless_instance_6(void *arg0 ) 
{ 
  void (*ldv_6_callback_get_channels)(struct net_device * , struct ethtool_channels * ) ;
  int (*ldv_6_callback_get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
  void (*ldv_6_callback_get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
  int (*ldv_6_callback_get_eeprom)(struct net_device * , struct ethtool_eeprom * ,
                                   unsigned char * ) ;
  int (*ldv_6_callback_get_eeprom_len)(struct net_device * ) ;
  void (*ldv_6_callback_get_ethtool_stats)(struct net_device * , struct ethtool_stats * ,
                                           unsigned long long * ) ;
  unsigned int (*ldv_6_callback_get_link)(struct net_device * ) ;
  int (*ldv_6_callback_get_module_eeprom)(struct net_device * , struct ethtool_eeprom * ,
                                          unsigned char * ) ;
  int (*ldv_6_callback_get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
  unsigned int (*ldv_6_callback_get_msglevel)(struct net_device * ) ;
  void (*ldv_6_callback_get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
  void (*ldv_6_callback_get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
  int (*ldv_6_callback_get_regs_len)(struct net_device * ) ;
  void (*ldv_6_callback_get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
  int (*ldv_6_callback_get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , unsigned int * ) ;
  int (*ldv_6_callback_get_settings)(struct net_device * , struct ethtool_cmd * ) ;
  int (*ldv_6_callback_get_sset_count)(struct net_device * , int  ) ;
  void (*ldv_6_callback_get_strings)(struct net_device * , unsigned int  , unsigned char * ) ;
  int (*ldv_6_callback_get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
  void (*ldv_6_callback_get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
  unsigned char (*ldv_6_callback_getapp)(struct net_device * , unsigned char  , unsigned short  ) ;
  unsigned char (*ldv_6_callback_getcap)(struct net_device * , int  , unsigned char * ) ;
  unsigned char (*ldv_6_callback_getdcbx)(struct net_device * ) ;
  int (*ldv_6_callback_getnumtcs)(struct net_device * , int  , unsigned char * ) ;
  void (*ldv_6_callback_getpermhwaddr)(struct net_device * , unsigned char * ) ;
  void (*ldv_6_callback_getpfccfg)(struct net_device * , int  , unsigned char * ) ;
  unsigned char (*ldv_6_callback_getpfcstate)(struct net_device * ) ;
  void (*ldv_6_callback_getpgbwgcfgrx)(struct net_device * , int  , unsigned char * ) ;
  void (*ldv_6_callback_getpgbwgcfgtx)(struct net_device * , int  , unsigned char * ) ;
  void (*ldv_6_callback_getpgtccfgrx)(struct net_device * , int  , unsigned char * ,
                                      unsigned char * , unsigned char * , unsigned char * ) ;
  void (*ldv_6_callback_getpgtccfgtx)(struct net_device * , int  , unsigned char * ,
                                      unsigned char * , unsigned char * , unsigned char * ) ;
  unsigned char (*ldv_6_callback_getstate)(struct net_device * ) ;
  int (*ldv_6_callback_ieee_delapp)(struct net_device * , struct dcb_app * ) ;
  int (*ldv_6_callback_ieee_getets)(struct net_device * , struct ieee_ets * ) ;
  int (*ldv_6_callback_ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
  int (*ldv_6_callback_ieee_setapp)(struct net_device * , struct dcb_app * ) ;
  int (*ldv_6_callback_ieee_setets)(struct net_device * , struct ieee_ets * ) ;
  int (*ldv_6_callback_ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
  int (*ldv_6_callback_ndo_bridge_getlink)(struct sk_buff * , unsigned int  , unsigned int  ,
                                           struct net_device * , unsigned int  ) ;
  int (*ldv_6_callback_ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
  int (*ldv_6_callback_ndo_busy_poll)(struct napi_struct * ) ;
  int (*ldv_6_callback_ndo_change_mtu)(struct net_device * , int  ) ;
  void *(*ldv_6_callback_ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
  void (*ldv_6_callback_ndo_dfwd_del_station)(struct net_device * , void * ) ;
  int (*ldv_6_callback_ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
  int (*ldv_6_callback_ndo_fcoe_ddp_done)(struct net_device * , unsigned short  ) ;
  int (*ldv_6_callback_ndo_fcoe_ddp_setup)(struct net_device * , unsigned short  ,
                                           struct scatterlist * , unsigned int  ) ;
  int (*ldv_6_callback_ndo_fcoe_ddp_target)(struct net_device * , unsigned short  ,
                                            struct scatterlist * , unsigned int  ) ;
  int (*ldv_6_callback_ndo_fcoe_disable)(struct net_device * ) ;
  int (*ldv_6_callback_ndo_fcoe_enable)(struct net_device * ) ;
  int (*ldv_6_callback_ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
  int (*ldv_6_callback_ndo_fcoe_get_wwn)(struct net_device * , unsigned long long * ,
                                         int  ) ;
  int (*ldv_6_callback_ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * ,
                                    unsigned char * , unsigned short  ) ;
  unsigned long long (*ldv_6_callback_ndo_fix_features)(struct net_device * , unsigned long long  ) ;
  struct rtnl_link_stats64 *(*ldv_6_callback_ndo_get_stats64)(struct net_device * ,
                                                              struct rtnl_link_stats64 * ) ;
  int (*ldv_6_callback_ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
  void (*ldv_6_callback_ndo_poll_controller)(struct net_device * ) ;
  unsigned short (*ldv_6_callback_ndo_select_queue)(struct net_device * , struct sk_buff * ,
                                                    void * , unsigned short (*)(struct net_device * ,
                                                                                struct sk_buff * ) ) ;
  int (*ldv_6_callback_ndo_set_features)(struct net_device * , unsigned long long  ) ;
  int (*ldv_6_callback_ndo_set_mac_address)(struct net_device * , void * ) ;
  void (*ldv_6_callback_ndo_set_rx_mode)(struct net_device * ) ;
  int (*ldv_6_callback_ndo_set_vf_mac)(struct net_device * , int  , unsigned char * ) ;
  int (*ldv_6_callback_ndo_set_vf_spoofchk)(struct net_device * , int  , _Bool  ) ;
  int (*ldv_6_callback_ndo_set_vf_tx_rate)(struct net_device * , int  , int  ) ;
  int (*ldv_6_callback_ndo_set_vf_vlan)(struct net_device * , int  , unsigned short  ,
                                        unsigned char  ) ;
  int (*ldv_6_callback_ndo_setup_tc)(struct net_device * , unsigned char  ) ;
  enum netdev_tx (*ldv_6_callback_ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
  void (*ldv_6_callback_ndo_tx_timeout)(struct net_device * ) ;
  int (*ldv_6_callback_ndo_validate_addr)(struct net_device * ) ;
  int (*ldv_6_callback_ndo_vlan_rx_add_vid)(struct net_device * , unsigned short  ,
                                            unsigned short  ) ;
  int (*ldv_6_callback_ndo_vlan_rx_kill_vid)(struct net_device * , unsigned short  ,
                                             unsigned short  ) ;
  int (*ldv_6_callback_nway_reset)(struct net_device * ) ;
  void (*ldv_6_callback_self_test)(struct net_device * , struct ethtool_test * , unsigned long long * ) ;
  int (*ldv_6_callback_set_channels)(struct net_device * , struct ethtool_channels * ) ;
  int (*ldv_6_callback_set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
  int (*ldv_6_callback_set_eeprom)(struct net_device * , struct ethtool_eeprom * ,
                                   unsigned char * ) ;
  void (*ldv_6_callback_set_msglevel)(struct net_device * , unsigned int  ) ;
  int (*ldv_6_callback_set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
  int (*ldv_6_callback_set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
  int (*ldv_6_callback_set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
  int (*ldv_6_callback_set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
  int (*ldv_6_callback_set_settings)(struct net_device * , struct ethtool_cmd * ) ;
  int (*ldv_6_callback_set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
  unsigned char (*ldv_6_callback_setall)(struct net_device * ) ;
  unsigned char (*ldv_6_callback_setdcbx)(struct net_device * , unsigned char  ) ;
  int (*ldv_6_callback_setnumtcs)(struct net_device * , int  , unsigned char  ) ;
  void (*ldv_6_callback_setpfccfg)(struct net_device * , int  , unsigned char  ) ;
  void (*ldv_6_callback_setpfcstate)(struct net_device * , unsigned char  ) ;
  void (*ldv_6_callback_setpgbwgcfgrx)(struct net_device * , int  , unsigned char  ) ;
  void (*ldv_6_callback_setpgbwgcfgtx)(struct net_device * , int  , unsigned char  ) ;
  void (*ldv_6_callback_setpgtccfgrx)(struct net_device * , int  , unsigned char  ,
                                      unsigned char  , unsigned char  , unsigned char  ) ;
  void (*ldv_6_callback_setpgtccfgtx)(struct net_device * , int  , unsigned char  ,
                                      unsigned char  , unsigned char  , unsigned char  ) ;
  unsigned char (*ldv_6_callback_setstate)(struct net_device * , unsigned char  ) ;
  enum ethtool_phys_id_state ldv_6_container_enum_ethtool_phys_id_state ;
  unsigned short (*ldv_6_container_func_2_ptr)(struct net_device * , struct sk_buff * ) ;
  struct net_device *ldv_6_container_net_device ;
  struct dcb_app *ldv_6_container_struct_dcb_app_ptr ;
  struct ethtool_channels *ldv_6_container_struct_ethtool_channels_ptr ;
  struct ethtool_cmd *ldv_6_container_struct_ethtool_cmd_ptr ;
  struct ethtool_coalesce *ldv_6_container_struct_ethtool_coalesce_ptr ;
  struct ethtool_drvinfo *ldv_6_container_struct_ethtool_drvinfo_ptr ;
  struct ethtool_eeprom *ldv_6_container_struct_ethtool_eeprom_ptr ;
  struct ethtool_modinfo *ldv_6_container_struct_ethtool_modinfo_ptr ;
  struct ethtool_pauseparam *ldv_6_container_struct_ethtool_pauseparam_ptr ;
  struct ethtool_regs *ldv_6_container_struct_ethtool_regs_ptr ;
  struct ethtool_ringparam *ldv_6_container_struct_ethtool_ringparam_ptr ;
  struct ethtool_rxnfc *ldv_6_container_struct_ethtool_rxnfc_ptr ;
  struct ethtool_stats *ldv_6_container_struct_ethtool_stats_ptr ;
  struct ethtool_test *ldv_6_container_struct_ethtool_test_ptr ;
  struct ethtool_ts_info *ldv_6_container_struct_ethtool_ts_info_ptr ;
  struct ethtool_wolinfo *ldv_6_container_struct_ethtool_wolinfo_ptr ;
  struct ieee_ets *ldv_6_container_struct_ieee_ets_ptr ;
  struct ieee_pfc *ldv_6_container_struct_ieee_pfc_ptr ;
  struct ifla_vf_info *ldv_6_container_struct_ifla_vf_info_ptr ;
  struct ifreq *ldv_6_container_struct_ifreq_ptr ;
  struct napi_struct *ldv_6_container_struct_napi_struct_ptr ;
  struct ndmsg *ldv_6_container_struct_ndmsg_ptr ;
  struct netdev_fcoe_hbainfo *ldv_6_container_struct_netdev_fcoe_hbainfo_ptr ;
  struct nlattr **ldv_6_container_struct_nlattr_ptr_ptr ;
  struct nlmsghdr *ldv_6_container_struct_nlmsghdr_ptr ;
  struct rtnl_link_stats64 *ldv_6_container_struct_rtnl_link_stats64_ptr ;
  struct scatterlist *ldv_6_container_struct_scatterlist_ptr ;
  struct sk_buff *ldv_6_container_struct_sk_buff_ptr ;
  unsigned long long *ldv_6_ldv_param_101_1_default ;
  int ldv_6_ldv_param_101_2_default ;
  unsigned char *ldv_6_ldv_param_104_3_default ;
  unsigned short ldv_6_ldv_param_104_4_default ;
  unsigned long long ldv_6_ldv_param_107_1_default ;
  int ldv_6_ldv_param_111_1_default ;
  unsigned short (*ldv_6_ldv_param_115_3_default)(struct net_device * , struct sk_buff * ) ;
  unsigned long long ldv_6_ldv_param_118_1_default ;
  int ldv_6_ldv_param_123_1_default ;
  unsigned char *ldv_6_ldv_param_123_2_default ;
  int ldv_6_ldv_param_126_1_default ;
  _Bool ldv_6_ldv_param_126_2_default ;
  int ldv_6_ldv_param_129_1_default ;
  int ldv_6_ldv_param_129_2_default ;
  int ldv_6_ldv_param_132_1_default ;
  unsigned short ldv_6_ldv_param_132_2_default ;
  unsigned char ldv_6_ldv_param_132_3_default ;
  unsigned char ldv_6_ldv_param_135_1_default ;
  unsigned long long *ldv_6_ldv_param_13_2_default ;
  unsigned short ldv_6_ldv_param_141_1_default ;
  unsigned short ldv_6_ldv_param_141_2_default ;
  unsigned short ldv_6_ldv_param_144_1_default ;
  unsigned short ldv_6_ldv_param_144_2_default ;
  unsigned long long *ldv_6_ldv_param_148_2_default ;
  unsigned char *ldv_6_ldv_param_153_2_default ;
  unsigned int ldv_6_ldv_param_156_1_default ;
  unsigned char ldv_6_ldv_param_166_1_default ;
  int ldv_6_ldv_param_169_1_default ;
  unsigned char ldv_6_ldv_param_169_2_default ;
  int ldv_6_ldv_param_172_1_default ;
  unsigned char ldv_6_ldv_param_172_2_default ;
  unsigned char ldv_6_ldv_param_175_1_default ;
  int ldv_6_ldv_param_178_1_default ;
  unsigned char ldv_6_ldv_param_178_2_default ;
  unsigned char *ldv_6_ldv_param_17_2_default ;
  int ldv_6_ldv_param_181_1_default ;
  unsigned char ldv_6_ldv_param_181_2_default ;
  int ldv_6_ldv_param_184_1_default ;
  unsigned char ldv_6_ldv_param_184_2_default ;
  unsigned char ldv_6_ldv_param_184_3_default ;
  unsigned char ldv_6_ldv_param_184_4_default ;
  unsigned char ldv_6_ldv_param_184_5_default ;
  int ldv_6_ldv_param_187_1_default ;
  unsigned char ldv_6_ldv_param_187_2_default ;
  unsigned char ldv_6_ldv_param_187_3_default ;
  unsigned char ldv_6_ldv_param_187_4_default ;
  unsigned char ldv_6_ldv_param_187_5_default ;
  unsigned char ldv_6_ldv_param_190_1_default ;
  unsigned int *ldv_6_ldv_param_26_2_default ;
  int ldv_6_ldv_param_30_1_default ;
  unsigned int ldv_6_ldv_param_33_1_default ;
  unsigned char *ldv_6_ldv_param_33_2_default ;
  unsigned char ldv_6_ldv_param_38_1_default ;
  unsigned short ldv_6_ldv_param_38_2_default ;
  int ldv_6_ldv_param_41_1_default ;
  unsigned char *ldv_6_ldv_param_41_2_default ;
  int ldv_6_ldv_param_45_1_default ;
  unsigned char *ldv_6_ldv_param_45_2_default ;
  unsigned char *ldv_6_ldv_param_48_1_default ;
  int ldv_6_ldv_param_51_1_default ;
  unsigned char *ldv_6_ldv_param_51_2_default ;
  int ldv_6_ldv_param_55_1_default ;
  unsigned char *ldv_6_ldv_param_55_2_default ;
  int ldv_6_ldv_param_58_1_default ;
  unsigned char *ldv_6_ldv_param_58_2_default ;
  int ldv_6_ldv_param_61_1_default ;
  unsigned char *ldv_6_ldv_param_61_2_default ;
  unsigned char *ldv_6_ldv_param_61_3_default ;
  unsigned char *ldv_6_ldv_param_61_4_default ;
  unsigned char *ldv_6_ldv_param_61_5_default ;
  int ldv_6_ldv_param_64_1_default ;
  unsigned char *ldv_6_ldv_param_64_2_default ;
  unsigned char *ldv_6_ldv_param_64_3_default ;
  unsigned char *ldv_6_ldv_param_64_4_default ;
  unsigned char *ldv_6_ldv_param_64_5_default ;
  unsigned int ldv_6_ldv_param_74_1_default ;
  unsigned int ldv_6_ldv_param_74_2_default ;
  unsigned int ldv_6_ldv_param_74_4_default ;
  int ldv_6_ldv_param_79_1_default ;
  struct net_device *ldv_6_ldv_param_82_1_default ;
  int ldv_6_ldv_param_86_2_default ;
  unsigned short ldv_6_ldv_param_89_1_default ;
  unsigned short ldv_6_ldv_param_92_1_default ;
  unsigned int ldv_6_ldv_param_92_3_default ;
  unsigned short ldv_6_ldv_param_95_1_default ;
  unsigned int ldv_6_ldv_param_95_3_default ;
  unsigned char *ldv_6_ldv_param_9_2_default ;
  struct ldv_struct_dummy_resourceless_instance_6 *data ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;

  {
#line 1871
  data = (struct ldv_struct_dummy_resourceless_instance_6 *)arg0;
#line 1876
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_dummy_resourceless_instance_6 *)0)) {
    {
#line 1877
    ldv_6_container_net_device = data->arg0;
#line 1878
    ldv_free((void *)data);
    }
  } else {

  }
#line 1886
  goto ldv_call_6;
#line 1888
  return;
  ldv_call_6: 
  {
#line 1894
  tmp = ldv_undef_int();
  }
  {
#line 1895
  if (tmp == 1) {
#line 1895
    goto case_1;
  } else {

  }
#line 1914
  if (tmp == 2) {
#line 1914
    goto case_2;
  } else {

  }
#line 1935
  if (tmp == 3) {
#line 1935
    goto case_3;
  } else {

  }
#line 1958
  if (tmp == 4) {
#line 1958
    goto case_4;
  } else {

  }
#line 1983
  if (tmp == 5) {
#line 1983
    goto case_5;
  } else {

  }
#line 2010
  if (tmp == 6) {
#line 2010
    goto case_6;
  } else {

  }
#line 2039
  if (tmp == 7) {
#line 2039
    goto case_7;
  } else {

  }
#line 2070
  if (tmp == 8) {
#line 2070
    goto case_8;
  } else {

  }
#line 2103
  if (tmp == 9) {
#line 2103
    goto case_9;
  } else {

  }
#line 2138
  if (tmp == 10) {
#line 2138
    goto case_10;
  } else {

  }
#line 2169
  if (tmp == 11) {
#line 2169
    goto case_11;
  } else {

  }
#line 2202
  if (tmp == 12) {
#line 2202
    goto case_12;
  } else {

  }
#line 2237
  if (tmp == 13) {
#line 2237
    goto case_13;
  } else {

  }
#line 2274
  if (tmp == 14) {
#line 2274
    goto case_14;
  } else {

  }
#line 2313
  if (tmp == 15) {
#line 2313
    goto case_15;
  } else {

  }
#line 2354
  if (tmp == 16) {
#line 2354
    goto case_16;
  } else {

  }
#line 2397
  if (tmp == 17) {
#line 2397
    goto case_17;
  } else {

  }
#line 2448
  if (tmp == 18) {
#line 2448
    goto case_18;
  } else {

  }
#line 2503
  if (tmp == 19) {
#line 2503
    goto case_19;
  } else {

  }
#line 2552
  if (tmp == 20) {
#line 2552
    goto case_20;
  } else {

  }
#line 2603
  if (tmp == 21) {
#line 2603
    goto case_21;
  } else {

  }
#line 2664
  if (tmp == 22) {
#line 2664
    goto case_22;
  } else {

  }
#line 2719
  if (tmp == 23) {
#line 2719
    goto case_23;
  } else {

  }
#line 2782
  if (tmp == 24) {
#line 2782
    goto case_24;
  } else {

  }
#line 2847
  if (tmp == 25) {
#line 2847
    goto case_25;
  } else {

  }
#line 2908
  if (tmp == 26) {
#line 2908
    goto case_26;
  } else {

  }
#line 2971
  if (tmp == 27) {
#line 2971
    goto case_27;
  } else {

  }
#line 3036
  if (tmp == 28) {
#line 3036
    goto case_28;
  } else {

  }
#line 3109
  if (tmp == 29) {
#line 3109
    goto case_29;
  } else {

  }
#line 3184
  if (tmp == 30) {
#line 3184
    goto case_30;
  } else {

  }
#line 3261
  if (tmp == 31) {
#line 3261
    goto case_31;
  } else {

  }
#line 3340
  if (tmp == 32) {
#line 3340
    goto case_32;
  } else {

  }
#line 3423
  if (tmp == 33) {
#line 3423
    goto case_33;
  } else {

  }
#line 3500
  if (tmp == 34) {
#line 3500
    goto case_34;
  } else {

  }
#line 3579
  if (tmp == 35) {
#line 3579
    goto case_35;
  } else {

  }
#line 3666
  if (tmp == 36) {
#line 3666
    goto case_36;
  } else {

  }
#line 3757
  if (tmp == 37) {
#line 3757
    goto case_37;
  } else {

  }
#line 3842
  if (tmp == 38) {
#line 3842
    goto case_38;
  } else {

  }
#line 3935
  if (tmp == 39) {
#line 3935
    goto case_39;
  } else {

  }
#line 4024
  if (tmp == 40) {
#line 4024
    goto case_40;
  } else {

  }
#line 4121
  if (tmp == 41) {
#line 4121
    goto case_41;
  } else {

  }
#line 4222
  if (tmp == 42) {
#line 4222
    goto case_42;
  } else {

  }
#line 4325
  if (tmp == 43) {
#line 4325
    goto case_43;
  } else {

  }
#line 4422
  if (tmp == 44) {
#line 4422
    goto case_44;
  } else {

  }
#line 4521
  if (tmp == 45) {
#line 4521
    goto case_45;
  } else {

  }
#line 4622
  if (tmp == 46) {
#line 4622
    goto case_46;
  } else {

  }
#line 4731
  if (tmp == 47) {
#line 4731
    goto case_47;
  } else {

  }
#line 4842
  if (tmp == 48) {
#line 4842
    goto case_48;
  } else {

  }
#line 4955
  if (tmp == 49) {
#line 4955
    goto case_49;
  } else {

  }
#line 5070
  if (tmp == 50) {
#line 5070
    goto case_50;
  } else {

  }
#line 5181
  if (tmp == 51) {
#line 5181
    goto case_51;
  } else {

  }
#line 5302
  if (tmp == 52) {
#line 5302
    goto case_52;
  } else {

  }
#line 5423
  if (tmp == 53) {
#line 5423
    goto case_53;
  } else {

  }
#line 5540
  if (tmp == 54) {
#line 5540
    goto case_54;
  } else {

  }
#line 5659
  if (tmp == 55) {
#line 5659
    goto case_55;
  } else {

  }
#line 5786
  if (tmp == 56) {
#line 5786
    goto case_56;
  } else {

  }
#line 5909
  if (tmp == 57) {
#line 5909
    goto case_57;
  } else {

  }
#line 6034
  if (tmp == 58) {
#line 6034
    goto case_58;
  } else {

  }
#line 6161
  if (tmp == 59) {
#line 6161
    goto case_59;
  } else {

  }
#line 6290
  if (tmp == 60) {
#line 6290
    goto case_60;
  } else {

  }
#line 6421
  if (tmp == 61) {
#line 6421
    goto case_61;
  } else {

  }
#line 6554
  if (tmp == 62) {
#line 6554
    goto case_62;
  } else {

  }
#line 6689
  if (tmp == 63) {
#line 6689
    goto case_63;
  } else {

  }
#line 6840
  if (tmp == 64) {
#line 6840
    goto case_64;
  } else {

  }
#line 6993
  if (tmp == 65) {
#line 6993
    goto case_65;
  } else {

  }
#line 7142
  if (tmp == 66) {
#line 7142
    goto case_66;
  } else {

  }
#line 7293
  if (tmp == 67) {
#line 7293
    goto case_67;
  } else {

  }
#line 7438
  if (tmp == 68) {
#line 7438
    goto case_68;
  } else {

  }
#line 7593
  if (tmp == 69) {
#line 7593
    goto case_69;
  } else {

  }
#line 7750
  if (tmp == 70) {
#line 7750
    goto case_70;
  } else {

  }
#line 7909
  if (tmp == 71) {
#line 7909
    goto case_71;
  } else {

  }
#line 8062
  if (tmp == 72) {
#line 8062
    goto case_72;
  } else {

  }
#line 8225
  if (tmp == 73) {
#line 8225
    goto case_73;
  } else {

  }
#line 8388
  if (tmp == 74) {
#line 8388
    goto case_74;
  } else {

  }
#line 8547
  if (tmp == 75) {
#line 8547
    goto case_75;
  } else {

  }
#line 8708
  if (tmp == 76) {
#line 8708
    goto case_76;
  } else {

  }
#line 8879
  if (tmp == 77) {
#line 8879
    goto case_77;
  } else {

  }
#line 9050
  if (tmp == 78) {
#line 9050
    goto case_78;
  } else {

  }
#line 9217
  if (tmp == 79) {
#line 9217
    goto case_79;
  } else {

  }
#line 9394
  if (tmp == 80) {
#line 9394
    goto case_80;
  } else {

  }
#line 9565
  if (tmp == 81) {
#line 9565
    goto case_81;
  } else {

  }
#line 9738
  if (tmp == 82) {
#line 9738
    goto case_82;
  } else {

  }
#line 9913
  if (tmp == 83) {
#line 9913
    goto case_83;
  } else {

  }
#line 10090
  if (tmp == 84) {
#line 10090
    goto case_84;
  } else {

  }
#line 10269
  if (tmp == 85) {
#line 10269
    goto case_85;
  } else {

  }
#line 10450
  if (tmp == 86) {
#line 10450
    goto case_86;
  } else {

  }
#line 10641
  if (tmp == 87) {
#line 10641
    goto case_87;
  } else {

  }
#line 10826
  if (tmp == 88) {
#line 10826
    goto case_88;
  } else {

  }
#line 11021
  if (tmp == 89) {
#line 11021
    goto case_89;
  } else {

  }
#line 11210
  if (tmp == 90) {
#line 11210
    goto case_90;
  } else {

  }
#line 11409
  if (tmp == 91) {
#line 11409
    goto case_91;
  } else {

  }
#line 11602
  if (tmp == 92) {
#line 11602
    goto case_92;
  } else {

  }
#line 11797
  if (tmp == 93) {
#line 11797
    goto case_93;
  } else {

  }
#line 11994
  if (tmp == 94) {
#line 11994
    goto case_94;
  } else {

  }
#line 12003
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1901
  ldv_dummy_resourceless_instance_callback_6_190(ldv_6_callback_setstate, ldv_6_container_net_device,
                                                 (int )ldv_6_ldv_param_190_1_default);
  }
#line 1911
  goto ldv_call_6;
  case_2: /* CIL Label */ 
  {
#line 1920
  ldv_dummy_resourceless_instance_callback_6_187(ldv_6_callback_setpgtccfgtx, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_187_1_default, (int )ldv_6_ldv_param_187_2_default,
                                                 (int )ldv_6_ldv_param_187_3_default,
                                                 (int )ldv_6_ldv_param_187_4_default,
                                                 (int )ldv_6_ldv_param_187_5_default);
  }
#line 1930
  goto ldv_call_6;
#line 1932
  goto ldv_call_6;
  case_3: /* CIL Label */ 
  {
#line 1941
  ldv_dummy_resourceless_instance_callback_6_184(ldv_6_callback_setpgtccfgrx, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_184_1_default, (int )ldv_6_ldv_param_184_2_default,
                                                 (int )ldv_6_ldv_param_184_3_default,
                                                 (int )ldv_6_ldv_param_184_4_default,
                                                 (int )ldv_6_ldv_param_184_5_default);
  }
#line 1951
  goto ldv_call_6;
#line 1953
  goto ldv_call_6;
#line 1955
  goto ldv_call_6;
  case_4: /* CIL Label */ 
  {
#line 1964
  ldv_dummy_resourceless_instance_callback_6_181(ldv_6_callback_setpgbwgcfgtx, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_181_1_default, (int )ldv_6_ldv_param_181_2_default);
  }
#line 1974
  goto ldv_call_6;
#line 1976
  goto ldv_call_6;
#line 1978
  goto ldv_call_6;
#line 1980
  goto ldv_call_6;
  case_5: /* CIL Label */ 
  {
#line 1989
  ldv_dummy_resourceless_instance_callback_6_178(ldv_6_callback_setpgbwgcfgrx, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_178_1_default, (int )ldv_6_ldv_param_178_2_default);
  }
#line 1999
  goto ldv_call_6;
#line 2001
  goto ldv_call_6;
#line 2003
  goto ldv_call_6;
#line 2005
  goto ldv_call_6;
#line 2007
  goto ldv_call_6;
  case_6: /* CIL Label */ 
  {
#line 2016
  ldv_dummy_resourceless_instance_callback_6_175(ldv_6_callback_setpfcstate, ldv_6_container_net_device,
                                                 (int )ldv_6_ldv_param_175_1_default);
  }
#line 2026
  goto ldv_call_6;
#line 2028
  goto ldv_call_6;
#line 2030
  goto ldv_call_6;
#line 2032
  goto ldv_call_6;
#line 2034
  goto ldv_call_6;
#line 2036
  goto ldv_call_6;
  case_7: /* CIL Label */ 
  {
#line 2045
  ldv_dummy_resourceless_instance_callback_6_172(ldv_6_callback_setpfccfg, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_172_1_default, (int )ldv_6_ldv_param_172_2_default);
  }
#line 2055
  goto ldv_call_6;
#line 2057
  goto ldv_call_6;
#line 2059
  goto ldv_call_6;
#line 2061
  goto ldv_call_6;
#line 2063
  goto ldv_call_6;
#line 2065
  goto ldv_call_6;
#line 2067
  goto ldv_call_6;
  case_8: /* CIL Label */ 
  {
#line 2076
  ldv_dummy_resourceless_instance_callback_6_169(ldv_6_callback_setnumtcs, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_169_1_default, (int )ldv_6_ldv_param_169_2_default);
  }
#line 2086
  goto ldv_call_6;
#line 2088
  goto ldv_call_6;
#line 2090
  goto ldv_call_6;
#line 2092
  goto ldv_call_6;
#line 2094
  goto ldv_call_6;
#line 2096
  goto ldv_call_6;
#line 2098
  goto ldv_call_6;
#line 2100
  goto ldv_call_6;
  case_9: /* CIL Label */ 
  {
#line 2109
  ldv_dummy_resourceless_instance_callback_6_166(ldv_6_callback_setdcbx, ldv_6_container_net_device,
                                                 (int )ldv_6_ldv_param_166_1_default);
  }
#line 2119
  goto ldv_call_6;
#line 2121
  goto ldv_call_6;
#line 2123
  goto ldv_call_6;
#line 2125
  goto ldv_call_6;
#line 2127
  goto ldv_call_6;
#line 2129
  goto ldv_call_6;
#line 2131
  goto ldv_call_6;
#line 2133
  goto ldv_call_6;
#line 2135
  goto ldv_call_6;
  case_10: /* CIL Label */ 
  {
#line 2141
  ldv_dummy_resourceless_instance_callback_6_165(ldv_6_callback_setall, ldv_6_container_net_device);
  }
#line 2148
  goto ldv_call_6;
#line 2150
  goto ldv_call_6;
#line 2152
  goto ldv_call_6;
#line 2154
  goto ldv_call_6;
#line 2156
  goto ldv_call_6;
#line 2158
  goto ldv_call_6;
#line 2160
  goto ldv_call_6;
#line 2162
  goto ldv_call_6;
#line 2164
  goto ldv_call_6;
#line 2166
  goto ldv_call_6;
  case_11: /* CIL Label */ 
  {
#line 2172
  ldv_dummy_resourceless_instance_callback_6_164(ldv_6_callback_set_wol, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_wolinfo_ptr);
  }
#line 2179
  goto ldv_call_6;
#line 2181
  goto ldv_call_6;
#line 2183
  goto ldv_call_6;
#line 2185
  goto ldv_call_6;
#line 2187
  goto ldv_call_6;
#line 2189
  goto ldv_call_6;
#line 2191
  goto ldv_call_6;
#line 2193
  goto ldv_call_6;
#line 2195
  goto ldv_call_6;
#line 2197
  goto ldv_call_6;
#line 2199
  goto ldv_call_6;
  case_12: /* CIL Label */ 
  {
#line 2205
  ldv_dummy_resourceless_instance_callback_6_163(ldv_6_callback_set_settings, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_cmd_ptr);
  }
#line 2212
  goto ldv_call_6;
#line 2214
  goto ldv_call_6;
#line 2216
  goto ldv_call_6;
#line 2218
  goto ldv_call_6;
#line 2220
  goto ldv_call_6;
#line 2222
  goto ldv_call_6;
#line 2224
  goto ldv_call_6;
#line 2226
  goto ldv_call_6;
#line 2228
  goto ldv_call_6;
#line 2230
  goto ldv_call_6;
#line 2232
  goto ldv_call_6;
#line 2234
  goto ldv_call_6;
  case_13: /* CIL Label */ 
  {
#line 2240
  ldv_dummy_resourceless_instance_callback_6_162(ldv_6_callback_set_rxnfc, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_rxnfc_ptr);
  }
#line 2247
  goto ldv_call_6;
#line 2249
  goto ldv_call_6;
#line 2251
  goto ldv_call_6;
#line 2253
  goto ldv_call_6;
#line 2255
  goto ldv_call_6;
#line 2257
  goto ldv_call_6;
#line 2259
  goto ldv_call_6;
#line 2261
  goto ldv_call_6;
#line 2263
  goto ldv_call_6;
#line 2265
  goto ldv_call_6;
#line 2267
  goto ldv_call_6;
#line 2269
  goto ldv_call_6;
#line 2271
  goto ldv_call_6;
  case_14: /* CIL Label */ 
  {
#line 2277
  ldv_dummy_resourceless_instance_callback_6_161(ldv_6_callback_set_ringparam, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_ringparam_ptr);
  }
#line 2284
  goto ldv_call_6;
#line 2286
  goto ldv_call_6;
#line 2288
  goto ldv_call_6;
#line 2290
  goto ldv_call_6;
#line 2292
  goto ldv_call_6;
#line 2294
  goto ldv_call_6;
#line 2296
  goto ldv_call_6;
#line 2298
  goto ldv_call_6;
#line 2300
  goto ldv_call_6;
#line 2302
  goto ldv_call_6;
#line 2304
  goto ldv_call_6;
#line 2306
  goto ldv_call_6;
#line 2308
  goto ldv_call_6;
#line 2310
  goto ldv_call_6;
  case_15: /* CIL Label */ 
  {
#line 2316
  ldv_dummy_resourceless_instance_callback_6_160(ldv_6_callback_set_phys_id, ldv_6_container_net_device,
                                                 ldv_6_container_enum_ethtool_phys_id_state);
  }
#line 2323
  goto ldv_call_6;
#line 2325
  goto ldv_call_6;
#line 2327
  goto ldv_call_6;
#line 2329
  goto ldv_call_6;
#line 2331
  goto ldv_call_6;
#line 2333
  goto ldv_call_6;
#line 2335
  goto ldv_call_6;
#line 2337
  goto ldv_call_6;
#line 2339
  goto ldv_call_6;
#line 2341
  goto ldv_call_6;
#line 2343
  goto ldv_call_6;
#line 2345
  goto ldv_call_6;
#line 2347
  goto ldv_call_6;
#line 2349
  goto ldv_call_6;
#line 2351
  goto ldv_call_6;
  case_16: /* CIL Label */ 
  {
#line 2357
  ldv_dummy_resourceless_instance_callback_6_159(ldv_6_callback_set_pauseparam, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_pauseparam_ptr);
  }
#line 2364
  goto ldv_call_6;
#line 2366
  goto ldv_call_6;
#line 2368
  goto ldv_call_6;
#line 2370
  goto ldv_call_6;
#line 2372
  goto ldv_call_6;
#line 2374
  goto ldv_call_6;
#line 2376
  goto ldv_call_6;
#line 2378
  goto ldv_call_6;
#line 2380
  goto ldv_call_6;
#line 2382
  goto ldv_call_6;
#line 2384
  goto ldv_call_6;
#line 2386
  goto ldv_call_6;
#line 2388
  goto ldv_call_6;
#line 2390
  goto ldv_call_6;
#line 2392
  goto ldv_call_6;
#line 2394
  goto ldv_call_6;
  case_17: /* CIL Label */ 
  {
#line 2403
  ldv_dummy_resourceless_instance_callback_6_156(ldv_6_callback_set_msglevel, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_156_1_default);
  }
#line 2413
  goto ldv_call_6;
#line 2415
  goto ldv_call_6;
#line 2417
  goto ldv_call_6;
#line 2419
  goto ldv_call_6;
#line 2421
  goto ldv_call_6;
#line 2423
  goto ldv_call_6;
#line 2425
  goto ldv_call_6;
#line 2427
  goto ldv_call_6;
#line 2429
  goto ldv_call_6;
#line 2431
  goto ldv_call_6;
#line 2433
  goto ldv_call_6;
#line 2435
  goto ldv_call_6;
#line 2437
  goto ldv_call_6;
#line 2439
  goto ldv_call_6;
#line 2441
  goto ldv_call_6;
#line 2443
  goto ldv_call_6;
#line 2445
  goto ldv_call_6;
  case_18: /* CIL Label */ 
  {
#line 2450
  tmp___0 = ldv_xmalloc(1UL);
#line 2450
  ldv_6_ldv_param_153_2_default = (unsigned char *)tmp___0;
#line 2455
  ldv_dummy_resourceless_instance_callback_6_153(ldv_6_callback_set_eeprom, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_eeprom_ptr,
                                                 ldv_6_ldv_param_153_2_default);
#line 2459
  ldv_free((void *)ldv_6_ldv_param_153_2_default);
  }
#line 2466
  goto ldv_call_6;
#line 2468
  goto ldv_call_6;
#line 2470
  goto ldv_call_6;
#line 2472
  goto ldv_call_6;
#line 2474
  goto ldv_call_6;
#line 2476
  goto ldv_call_6;
#line 2478
  goto ldv_call_6;
#line 2480
  goto ldv_call_6;
#line 2482
  goto ldv_call_6;
#line 2484
  goto ldv_call_6;
#line 2486
  goto ldv_call_6;
#line 2488
  goto ldv_call_6;
#line 2490
  goto ldv_call_6;
#line 2492
  goto ldv_call_6;
#line 2494
  goto ldv_call_6;
#line 2496
  goto ldv_call_6;
#line 2498
  goto ldv_call_6;
#line 2500
  goto ldv_call_6;
  case_19: /* CIL Label */ 
  {
#line 2506
  ldv_dummy_resourceless_instance_callback_6_152(ldv_6_callback_set_coalesce, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_coalesce_ptr);
  }
#line 2513
  goto ldv_call_6;
#line 2515
  goto ldv_call_6;
#line 2517
  goto ldv_call_6;
#line 2519
  goto ldv_call_6;
#line 2521
  goto ldv_call_6;
#line 2523
  goto ldv_call_6;
#line 2525
  goto ldv_call_6;
#line 2527
  goto ldv_call_6;
#line 2529
  goto ldv_call_6;
#line 2531
  goto ldv_call_6;
#line 2533
  goto ldv_call_6;
#line 2535
  goto ldv_call_6;
#line 2537
  goto ldv_call_6;
#line 2539
  goto ldv_call_6;
#line 2541
  goto ldv_call_6;
#line 2543
  goto ldv_call_6;
#line 2545
  goto ldv_call_6;
#line 2547
  goto ldv_call_6;
#line 2549
  goto ldv_call_6;
  case_20: /* CIL Label */ 
  {
#line 2555
  ldv_dummy_resourceless_instance_callback_6_151(ldv_6_callback_set_channels, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_channels_ptr);
  }
#line 2562
  goto ldv_call_6;
#line 2564
  goto ldv_call_6;
#line 2566
  goto ldv_call_6;
#line 2568
  goto ldv_call_6;
#line 2570
  goto ldv_call_6;
#line 2572
  goto ldv_call_6;
#line 2574
  goto ldv_call_6;
#line 2576
  goto ldv_call_6;
#line 2578
  goto ldv_call_6;
#line 2580
  goto ldv_call_6;
#line 2582
  goto ldv_call_6;
#line 2584
  goto ldv_call_6;
#line 2586
  goto ldv_call_6;
#line 2588
  goto ldv_call_6;
#line 2590
  goto ldv_call_6;
#line 2592
  goto ldv_call_6;
#line 2594
  goto ldv_call_6;
#line 2596
  goto ldv_call_6;
#line 2598
  goto ldv_call_6;
#line 2600
  goto ldv_call_6;
  case_21: /* CIL Label */ 
  {
#line 2605
  tmp___1 = ldv_xmalloc(8UL);
#line 2605
  ldv_6_ldv_param_148_2_default = (unsigned long long *)tmp___1;
#line 2610
  ldv_dummy_resourceless_instance_callback_6_148(ldv_6_callback_self_test, ldv_6_container_net_device,
                                                 ldv_6_container_struct_ethtool_test_ptr,
                                                 ldv_6_ldv_param_148_2_default);
#line 2614
  ldv_free((void *)ldv_6_ldv_param_148_2_default);
  }
#line 2621
  goto ldv_call_6;
#line 2623
  goto ldv_call_6;
#line 2625
  goto ldv_call_6;
#line 2627
  goto ldv_call_6;
#line 2629
  goto ldv_call_6;
#line 2631
  goto ldv_call_6;
#line 2633
  goto ldv_call_6;
#line 2635
  goto ldv_call_6;
#line 2637
  goto ldv_call_6;
#line 2639
  goto ldv_call_6;
#line 2641
  goto ldv_call_6;
#line 2643
  goto ldv_call_6;
#line 2645
  goto ldv_call_6;
#line 2647
  goto ldv_call_6;
#line 2649
  goto ldv_call_6;
#line 2651
  goto ldv_call_6;
#line 2653
  goto ldv_call_6;
#line 2655
  goto ldv_call_6;
#line 2657
  goto ldv_call_6;
#line 2659
  goto ldv_call_6;
#line 2661
  goto ldv_call_6;
  case_22: /* CIL Label */ 
  {
#line 2667
  ldv_dummy_resourceless_instance_callback_6_147(ldv_6_callback_nway_reset, ldv_6_container_net_device);
  }
#line 2674
  goto ldv_call_6;
#line 2676
  goto ldv_call_6;
#line 2678
  goto ldv_call_6;
#line 2680
  goto ldv_call_6;
#line 2682
  goto ldv_call_6;
#line 2684
  goto ldv_call_6;
#line 2686
  goto ldv_call_6;
#line 2688
  goto ldv_call_6;
#line 2690
  goto ldv_call_6;
#line 2692
  goto ldv_call_6;
#line 2694
  goto ldv_call_6;
#line 2696
  goto ldv_call_6;
#line 2698
  goto ldv_call_6;
#line 2700
  goto ldv_call_6;
#line 2702
  goto ldv_call_6;
#line 2704
  goto ldv_call_6;
#line 2706
  goto ldv_call_6;
#line 2708
  goto ldv_call_6;
#line 2710
  goto ldv_call_6;
#line 2712
  goto ldv_call_6;
#line 2714
  goto ldv_call_6;
#line 2716
  goto ldv_call_6;
  case_23: /* CIL Label */ 
  {
#line 2725
  ldv_dummy_resourceless_instance_callback_6_144(ldv_6_callback_ndo_vlan_rx_kill_vid,
                                                 ldv_6_container_net_device, (int )ldv_6_ldv_param_144_1_default,
                                                 (int )ldv_6_ldv_param_144_2_default);
  }
#line 2735
  goto ldv_call_6;
#line 2737
  goto ldv_call_6;
#line 2739
  goto ldv_call_6;
#line 2741
  goto ldv_call_6;
#line 2743
  goto ldv_call_6;
#line 2745
  goto ldv_call_6;
#line 2747
  goto ldv_call_6;
#line 2749
  goto ldv_call_6;
#line 2751
  goto ldv_call_6;
#line 2753
  goto ldv_call_6;
#line 2755
  goto ldv_call_6;
#line 2757
  goto ldv_call_6;
#line 2759
  goto ldv_call_6;
#line 2761
  goto ldv_call_6;
#line 2763
  goto ldv_call_6;
#line 2765
  goto ldv_call_6;
#line 2767
  goto ldv_call_6;
#line 2769
  goto ldv_call_6;
#line 2771
  goto ldv_call_6;
#line 2773
  goto ldv_call_6;
#line 2775
  goto ldv_call_6;
#line 2777
  goto ldv_call_6;
#line 2779
  goto ldv_call_6;
  case_24: /* CIL Label */ 
  {
#line 2788
  ldv_dummy_resourceless_instance_callback_6_141(ldv_6_callback_ndo_vlan_rx_add_vid,
                                                 ldv_6_container_net_device, (int )ldv_6_ldv_param_141_1_default,
                                                 (int )ldv_6_ldv_param_141_2_default);
  }
#line 2798
  goto ldv_call_6;
#line 2800
  goto ldv_call_6;
#line 2802
  goto ldv_call_6;
#line 2804
  goto ldv_call_6;
#line 2806
  goto ldv_call_6;
#line 2808
  goto ldv_call_6;
#line 2810
  goto ldv_call_6;
#line 2812
  goto ldv_call_6;
#line 2814
  goto ldv_call_6;
#line 2816
  goto ldv_call_6;
#line 2818
  goto ldv_call_6;
#line 2820
  goto ldv_call_6;
#line 2822
  goto ldv_call_6;
#line 2824
  goto ldv_call_6;
#line 2826
  goto ldv_call_6;
#line 2828
  goto ldv_call_6;
#line 2830
  goto ldv_call_6;
#line 2832
  goto ldv_call_6;
#line 2834
  goto ldv_call_6;
#line 2836
  goto ldv_call_6;
#line 2838
  goto ldv_call_6;
#line 2840
  goto ldv_call_6;
#line 2842
  goto ldv_call_6;
#line 2844
  goto ldv_call_6;
  case_25: /* CIL Label */ 
  {
#line 2850
  ldv_dummy_resourceless_instance_callback_6_140(ldv_6_callback_ndo_validate_addr,
                                                 ldv_6_container_net_device);
  }
#line 2857
  goto ldv_call_6;
#line 2859
  goto ldv_call_6;
#line 2861
  goto ldv_call_6;
#line 2863
  goto ldv_call_6;
#line 2865
  goto ldv_call_6;
#line 2867
  goto ldv_call_6;
#line 2869
  goto ldv_call_6;
#line 2871
  goto ldv_call_6;
#line 2873
  goto ldv_call_6;
#line 2875
  goto ldv_call_6;
#line 2877
  goto ldv_call_6;
#line 2879
  goto ldv_call_6;
#line 2881
  goto ldv_call_6;
#line 2883
  goto ldv_call_6;
#line 2885
  goto ldv_call_6;
#line 2887
  goto ldv_call_6;
#line 2889
  goto ldv_call_6;
#line 2891
  goto ldv_call_6;
#line 2893
  goto ldv_call_6;
#line 2895
  goto ldv_call_6;
#line 2897
  goto ldv_call_6;
#line 2899
  goto ldv_call_6;
#line 2901
  goto ldv_call_6;
#line 2903
  goto ldv_call_6;
#line 2905
  goto ldv_call_6;
  case_26: /* CIL Label */ 
  {
#line 2911
  ldv_dummy_resourceless_instance_callback_6_139(ldv_6_callback_ndo_tx_timeout, ldv_6_container_net_device);
  }
#line 2918
  goto ldv_call_6;
#line 2920
  goto ldv_call_6;
#line 2922
  goto ldv_call_6;
#line 2924
  goto ldv_call_6;
#line 2926
  goto ldv_call_6;
#line 2928
  goto ldv_call_6;
#line 2930
  goto ldv_call_6;
#line 2932
  goto ldv_call_6;
#line 2934
  goto ldv_call_6;
#line 2936
  goto ldv_call_6;
#line 2938
  goto ldv_call_6;
#line 2940
  goto ldv_call_6;
#line 2942
  goto ldv_call_6;
#line 2944
  goto ldv_call_6;
#line 2946
  goto ldv_call_6;
#line 2948
  goto ldv_call_6;
#line 2950
  goto ldv_call_6;
#line 2952
  goto ldv_call_6;
#line 2954
  goto ldv_call_6;
#line 2956
  goto ldv_call_6;
#line 2958
  goto ldv_call_6;
#line 2960
  goto ldv_call_6;
#line 2962
  goto ldv_call_6;
#line 2964
  goto ldv_call_6;
#line 2966
  goto ldv_call_6;
#line 2968
  goto ldv_call_6;
  case_27: /* CIL Label */ 
  {
#line 2974
  ldv_dummy_resourceless_instance_callback_6_138(ldv_6_callback_ndo_start_xmit, ldv_6_container_struct_sk_buff_ptr,
                                                 ldv_6_container_net_device);
  }
#line 2981
  goto ldv_call_6;
#line 2983
  goto ldv_call_6;
#line 2985
  goto ldv_call_6;
#line 2987
  goto ldv_call_6;
#line 2989
  goto ldv_call_6;
#line 2991
  goto ldv_call_6;
#line 2993
  goto ldv_call_6;
#line 2995
  goto ldv_call_6;
#line 2997
  goto ldv_call_6;
#line 2999
  goto ldv_call_6;
#line 3001
  goto ldv_call_6;
#line 3003
  goto ldv_call_6;
#line 3005
  goto ldv_call_6;
#line 3007
  goto ldv_call_6;
#line 3009
  goto ldv_call_6;
#line 3011
  goto ldv_call_6;
#line 3013
  goto ldv_call_6;
#line 3015
  goto ldv_call_6;
#line 3017
  goto ldv_call_6;
#line 3019
  goto ldv_call_6;
#line 3021
  goto ldv_call_6;
#line 3023
  goto ldv_call_6;
#line 3025
  goto ldv_call_6;
#line 3027
  goto ldv_call_6;
#line 3029
  goto ldv_call_6;
#line 3031
  goto ldv_call_6;
#line 3033
  goto ldv_call_6;
  case_28: /* CIL Label */ 
  {
#line 3042
  ldv_dummy_resourceless_instance_callback_6_135(ldv_6_callback_ndo_setup_tc, ldv_6_container_net_device,
                                                 (int )ldv_6_ldv_param_135_1_default);
  }
#line 3052
  goto ldv_call_6;
#line 3054
  goto ldv_call_6;
#line 3056
  goto ldv_call_6;
#line 3058
  goto ldv_call_6;
#line 3060
  goto ldv_call_6;
#line 3062
  goto ldv_call_6;
#line 3064
  goto ldv_call_6;
#line 3066
  goto ldv_call_6;
#line 3068
  goto ldv_call_6;
#line 3070
  goto ldv_call_6;
#line 3072
  goto ldv_call_6;
#line 3074
  goto ldv_call_6;
#line 3076
  goto ldv_call_6;
#line 3078
  goto ldv_call_6;
#line 3080
  goto ldv_call_6;
#line 3082
  goto ldv_call_6;
#line 3084
  goto ldv_call_6;
#line 3086
  goto ldv_call_6;
#line 3088
  goto ldv_call_6;
#line 3090
  goto ldv_call_6;
#line 3092
  goto ldv_call_6;
#line 3094
  goto ldv_call_6;
#line 3096
  goto ldv_call_6;
#line 3098
  goto ldv_call_6;
#line 3100
  goto ldv_call_6;
#line 3102
  goto ldv_call_6;
#line 3104
  goto ldv_call_6;
#line 3106
  goto ldv_call_6;
  case_29: /* CIL Label */ 
  {
#line 3115
  ldv_dummy_resourceless_instance_callback_6_132(ldv_6_callback_ndo_set_vf_vlan, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_132_1_default, (int )ldv_6_ldv_param_132_2_default,
                                                 (int )ldv_6_ldv_param_132_3_default);
  }
#line 3125
  goto ldv_call_6;
#line 3127
  goto ldv_call_6;
#line 3129
  goto ldv_call_6;
#line 3131
  goto ldv_call_6;
#line 3133
  goto ldv_call_6;
#line 3135
  goto ldv_call_6;
#line 3137
  goto ldv_call_6;
#line 3139
  goto ldv_call_6;
#line 3141
  goto ldv_call_6;
#line 3143
  goto ldv_call_6;
#line 3145
  goto ldv_call_6;
#line 3147
  goto ldv_call_6;
#line 3149
  goto ldv_call_6;
#line 3151
  goto ldv_call_6;
#line 3153
  goto ldv_call_6;
#line 3155
  goto ldv_call_6;
#line 3157
  goto ldv_call_6;
#line 3159
  goto ldv_call_6;
#line 3161
  goto ldv_call_6;
#line 3163
  goto ldv_call_6;
#line 3165
  goto ldv_call_6;
#line 3167
  goto ldv_call_6;
#line 3169
  goto ldv_call_6;
#line 3171
  goto ldv_call_6;
#line 3173
  goto ldv_call_6;
#line 3175
  goto ldv_call_6;
#line 3177
  goto ldv_call_6;
#line 3179
  goto ldv_call_6;
#line 3181
  goto ldv_call_6;
  case_30: /* CIL Label */ 
  {
#line 3190
  ldv_dummy_resourceless_instance_callback_6_129(ldv_6_callback_ndo_set_vf_tx_rate,
                                                 ldv_6_container_net_device, ldv_6_ldv_param_129_1_default,
                                                 ldv_6_ldv_param_129_2_default);
  }
#line 3200
  goto ldv_call_6;
#line 3202
  goto ldv_call_6;
#line 3204
  goto ldv_call_6;
#line 3206
  goto ldv_call_6;
#line 3208
  goto ldv_call_6;
#line 3210
  goto ldv_call_6;
#line 3212
  goto ldv_call_6;
#line 3214
  goto ldv_call_6;
#line 3216
  goto ldv_call_6;
#line 3218
  goto ldv_call_6;
#line 3220
  goto ldv_call_6;
#line 3222
  goto ldv_call_6;
#line 3224
  goto ldv_call_6;
#line 3226
  goto ldv_call_6;
#line 3228
  goto ldv_call_6;
#line 3230
  goto ldv_call_6;
#line 3232
  goto ldv_call_6;
#line 3234
  goto ldv_call_6;
#line 3236
  goto ldv_call_6;
#line 3238
  goto ldv_call_6;
#line 3240
  goto ldv_call_6;
#line 3242
  goto ldv_call_6;
#line 3244
  goto ldv_call_6;
#line 3246
  goto ldv_call_6;
#line 3248
  goto ldv_call_6;
#line 3250
  goto ldv_call_6;
#line 3252
  goto ldv_call_6;
#line 3254
  goto ldv_call_6;
#line 3256
  goto ldv_call_6;
#line 3258
  goto ldv_call_6;
  case_31: /* CIL Label */ 
  {
#line 3267
  ldv_dummy_resourceless_instance_callback_6_126(ldv_6_callback_ndo_set_vf_spoofchk,
                                                 ldv_6_container_net_device, ldv_6_ldv_param_126_1_default,
                                                 (int )ldv_6_ldv_param_126_2_default);
  }
#line 3277
  goto ldv_call_6;
#line 3279
  goto ldv_call_6;
#line 3281
  goto ldv_call_6;
#line 3283
  goto ldv_call_6;
#line 3285
  goto ldv_call_6;
#line 3287
  goto ldv_call_6;
#line 3289
  goto ldv_call_6;
#line 3291
  goto ldv_call_6;
#line 3293
  goto ldv_call_6;
#line 3295
  goto ldv_call_6;
#line 3297
  goto ldv_call_6;
#line 3299
  goto ldv_call_6;
#line 3301
  goto ldv_call_6;
#line 3303
  goto ldv_call_6;
#line 3305
  goto ldv_call_6;
#line 3307
  goto ldv_call_6;
#line 3309
  goto ldv_call_6;
#line 3311
  goto ldv_call_6;
#line 3313
  goto ldv_call_6;
#line 3315
  goto ldv_call_6;
#line 3317
  goto ldv_call_6;
#line 3319
  goto ldv_call_6;
#line 3321
  goto ldv_call_6;
#line 3323
  goto ldv_call_6;
#line 3325
  goto ldv_call_6;
#line 3327
  goto ldv_call_6;
#line 3329
  goto ldv_call_6;
#line 3331
  goto ldv_call_6;
#line 3333
  goto ldv_call_6;
#line 3335
  goto ldv_call_6;
#line 3337
  goto ldv_call_6;
  case_32: /* CIL Label */ 
  {
#line 3342
  tmp___2 = ldv_xmalloc(1UL);
#line 3342
  ldv_6_ldv_param_123_2_default = (unsigned char *)tmp___2;
#line 3347
  ldv_dummy_resourceless_instance_callback_6_123(ldv_6_callback_ndo_set_vf_mac, ldv_6_container_net_device,
                                                 ldv_6_ldv_param_123_1_default, ldv_6_ldv_param_123_2_default);
#line 3351
  ldv_free((void *)ldv_6_ldv_param_123_2_default);
  }
#line 3358
  goto ldv_call_6;
#line 3360
  goto ldv_call_6;
#line 3362
  goto ldv_call_6;
#line 3364
  goto ldv_call_6;
#line 3366
  goto ldv_call_6;
#line 3368
  goto ldv_call_6;
#line 3370
  goto ldv_call_6;
#line 3372
  goto ldv_call_6;
#line 3374
  goto ldv_call_6;
#line 3376
  goto ldv_call_6;
#line 3378
  goto ldv_call_6;
#line 3380
  goto ldv_call_6;
#line 3382
  goto ldv_call_6;
#line 3384
  goto ldv_call_6;
#line 3386
  goto ldv_call_6;
#line 3388
  goto ldv_call_6;
#line 3390
  goto ldv_call_6;
#line 3392
  goto ldv_call_6;
#line 3394
  goto ldv_call_6;
#line 3396
  goto ldv_call_6;
#line 3398
  goto ldv_call_6;
#line 3400
  goto ldv_call_6;
#line 3402
  goto ldv_call_6;
#line 3404
  goto ldv_call_6;
#line 3406
  goto ldv_call_6;
#line 3408
  goto ldv_call_6;
#line 3410
  goto ldv_call_6;
#line 3412
  goto ldv_call_6;
#line 3414
  goto ldv_call_6;
#line 3416
  goto ldv_call_6;
#line 3418
  goto ldv_call_6;
#line 3420
  goto ldv_call_6;
  case_33: /* CIL Label */ 
  {
#line 3426
  ldv_dummy_resourceless_instance_callback_6_122(ldv_6_callback_ndo_set_rx_mode, ldv_6_container_net_device);
  }
#line 3433
  goto ldv_call_6;
#line 3435
  goto ldv_call_6;
#line 3437
  goto ldv_call_6;
#line 3439
  goto ldv_call_6;
#line 3441
  goto ldv_call_6;
#line 3443
  goto ldv_call_6;
#line 3445
  goto ldv_call_6;
#line 3447
  goto ldv_call_6;
#line 3449
  goto ldv_call_6;
#line 3451
  goto ldv_call_6;
#line 3453
  goto ldv_call_6;
#line 3455
  goto ldv_call_6;
#line 3457
  goto ldv_call_6;
#line 3459
  goto ldv_call_6;
#line 3461
  goto ldv_call_6;
#line 3463
  goto ldv_call_6;
#line 3465
  goto ldv_call_6;
#line 3467
  goto ldv_call_6;
#line 3469
  goto ldv_call_6;
#line 3471
  goto ldv_call_6;
#line 3473
  goto ldv_call_6;
#line 3475
  goto ldv_call_6;
#line 3477
  goto ldv_call_6;
#line 3479
  goto ldv_call_6;
#line 3481
  goto ldv_call_6;
#line 3483
  goto ldv_call_6;
#line 3485
  goto ldv_call_6;
#line 3487
  goto ldv_call_6;
#line 3489
  goto ldv_call_6;
#line 3491
  goto ldv_call_6;
#line 3493
  goto ldv_call_6;
#line 3495
  goto ldv_call_6;
#line 3497
  goto ldv_call_6;
  case_34: /* CIL Label */ 
  {
#line 3503
  ldv_dummy_resourceless_instance_callback_6_121(ldv_6_callback_ndo_set_mac_address,
                                                 ldv_6_container_net_device, (void *)ldv_6_container_func_2_ptr);
  }
#line 3510
  goto ldv_call_6;
#line 3512
  goto ldv_call_6;
#line 3514
  goto ldv_call_6;
#line 3516
  goto ldv_call_6;
#line 3518
  goto ldv_call_6;
#line 3520
  goto ldv_call_6;
#line 3522
  goto ldv_call_6;
#line 3524
  goto ldv_call_6;
#line 3526
  goto ldv_call_6;
#line 3528
  goto ldv_call_6;
#line 3530
  goto ldv_call_6;
#line 3532
  goto ldv_call_6;
#line 3534
  goto ldv_call_6;
#line 3536
  goto ldv_call_6;
#line 3538
  goto ldv_call_6;
#line 3540
  goto ldv_call_6;
#line 3542
  goto ldv_call_6;
#line 3544
  goto ldv_call_6;
#line 3546
  goto ldv_call_6;
#line 3548
  goto ldv_call_6;
#line 3550
  goto ldv_call_6;
#line 3552
  goto ldv_call_6;
#line 3554
  goto ldv_call_6;
#line 3556
  goto ldv_call_6;
#line 3558
  goto ldv_call_6;
#line 3560
  goto ldv_call_6;
#line 3562
  goto ldv_call_6;
#line 3564
  goto ldv_call_6;
#line 3566
  goto ldv_call_6;
#line 3568
  goto ldv_call_6;
#line 3570
  goto ldv_call_6;
#line 3572
  goto ldv_call_6;
#line 3574
  goto ldv_call_6;
#line 3576
  goto ldv_call_6;
  case_35: /* CIL Label */ 
  {
#line 3585
  ldv_dummy_resourceless_instance_callback_6_118(ldv_6_callback_ndo_set_features,
                                                 ldv_6_container_net_device, ldv_6_ldv_param_118_1_default);
  }
#line 3595
  goto ldv_call_6;
#line 3597
  goto ldv_call_6;
#line 3599
  goto ldv_call_6;
#line 3601
  goto ldv_call_6;
#line 3603
  goto ldv_call_6;
#line 3605
  goto ldv_call_6;
#line 3607
  goto ldv_call_6;
#line 3609
  goto ldv_call_6;
#line 3611
  goto ldv_call_6;
#line 3613
  goto ldv_call_6;
#line 3615
  goto ldv_call_6;
#line 3617
  goto ldv_call_6;
#line 3619
  goto ldv_call_6;
#line 3621
  goto ldv_call_6;
#line 3623
  goto ldv_call_6;
#line 3625
  goto ldv_call_6;
#line 3627
  goto ldv_call_6;
#line 3629
  goto ldv_call_6;
#line 3631
  goto ldv_call_6;
#line 3633
  goto ldv_call_6;
#line 3635
  goto ldv_call_6;
#line 3637
  goto ldv_call_6;
#line 3639
  goto ldv_call_6;
#line 3641
  goto ldv_call_6;
#line 3643
  goto ldv_call_6;
#line 3645
  goto ldv_call_6;
#line 3647
  goto ldv_call_6;
#line 3649
  goto ldv_call_6;
#line 3651
  goto ldv_call_6;
#line 3653
  goto ldv_call_6;
#line 3655
  goto ldv_call_6;
#line 3657
  goto ldv_call_6;
#line 3659
  goto ldv_call_6;
#line 3661
  goto ldv_call_6;
#line 3663
  goto ldv_call_6;
  case_36: /* CIL Label */ 
  {
#line 3668
  tmp___3 = ldv_xmalloc(1UL);
#line 3668
  ldv_6_ldv_param_115_3_default = (unsigned short (*)(struct net_device * , struct sk_buff * ))tmp___3;
#line 3673
  ldv_dummy_resourceless_instance_callback_6_115(ldv_6_callback_ndo_select_queue,
                                                 ldv_6_container_net_device, ldv_6_container_struct_sk_buff_ptr,
                                                 (void *)ldv_6_container_func_2_ptr,
                                                 ldv_6_ldv_param_115_3_default);
#line 3677
  ldv_free((void *)ldv_6_ldv_param_115_3_default);
  }
#line 3684
  goto ldv_call_6;
#line 3686
  goto ldv_call_6;
#line 3688
  goto ldv_call_6;
#line 3690
  goto ldv_call_6;
#line 3692
  goto ldv_call_6;
#line 3694
  goto ldv_call_6;
#line 3696
  goto ldv_call_6;
#line 3698
  goto ldv_call_6;
#line 3700
  goto ldv_call_6;
#line 3702
  goto ldv_call_6;
#line 3704
  goto ldv_call_6;
#line 3706
  goto ldv_call_6;
#line 3708
  goto ldv_call_6;
#line 3710
  goto ldv_call_6;
#line 3712
  goto ldv_call_6;
#line 3714
  goto ldv_call_6;
#line 3716
  goto ldv_call_6;
#line 3718
  goto ldv_call_6;
#line 3720
  goto ldv_call_6;
#line 3722
  goto ldv_call_6;
#line 3724
  goto ldv_call_6;
#line 3726
  goto ldv_call_6;
#line 3728
  goto ldv_call_6;
#line 3730
  goto ldv_call_6;
#line 3732
  goto ldv_call_6;
#line 3734
  goto ldv_call_6;
#line 3736
  goto ldv_call_6;
#line 3738
  goto ldv_call_6;
#line 3740
  goto ldv_call_6;
#line 3742
  goto ldv_call_6;
#line 3744
  goto ldv_call_6;
#line 3746
  goto ldv_call_6;
#line 3748
  goto ldv_call_6;
#line 3750
  goto ldv_call_6;
#line 3752
  goto ldv_call_6;
#line 3754
  goto ldv_call_6;
  case_37: /* CIL Label */ 
  {
#line 3760
  ldv_dummy_resourceless_instance_callback_6_114(ldv_6_callback_ndo_poll_controller,
                                                 ldv_6_container_net_device);
  }
#line 3767
  goto ldv_call_6;
#line 3769
  goto ldv_call_6;
#line 3771
  goto ldv_call_6;
#line 3773
  goto ldv_call_6;
#line 3775
  goto ldv_call_6;
#line 3777
  goto ldv_call_6;
#line 3779
  goto ldv_call_6;
#line 3781
  goto ldv_call_6;
#line 3783
  goto ldv_call_6;
#line 3785
  goto ldv_call_6;
#line 3787
  goto ldv_call_6;
#line 3789
  goto ldv_call_6;
#line 3791
  goto ldv_call_6;
#line 3793
  goto ldv_call_6;
#line 3795
  goto ldv_call_6;
#line 3797
  goto ldv_call_6;
#line 3799
  goto ldv_call_6;
#line 3801
  goto ldv_call_6;
#line 3803
  goto ldv_call_6;
#line 3805
  goto ldv_call_6;
#line 3807
  goto ldv_call_6;
#line 3809
  goto ldv_call_6;
#line 3811
  goto ldv_call_6;
#line 3813
  goto ldv_call_6;
#line 3815
  goto ldv_call_6;
#line 3817
  goto ldv_call_6;
#line 3819
  goto ldv_call_6;
#line 3821
  goto ldv_call_6;
#line 3823
  goto ldv_call_6;
#line 3825
  goto ldv_call_6;
#line 3827
  goto ldv_call_6;
#line 3829
  goto ldv_call_6;
#line 3831
  goto ldv_call_6;
#line 3833
  goto ldv_call_6;
#line 3835
  goto ldv_call_6;
#line 3837
  goto ldv_call_6;
#line 3839
  goto ldv_call_6;
  case_38: /* CIL Label */ 
  {
#line 3848
  ldv_dummy_resourceless_instance_callback_6_111(ldv_6_callback_ndo_get_vf_config,
                                                 ldv_6_container_net_device, ldv_6_ldv_param_111_1_default,
                                                 ldv_6_container_struct_ifla_vf_info_ptr);
  }
#line 3858
  goto ldv_call_6;
#line 3860
  goto ldv_call_6;
#line 3862
  goto ldv_call_6;
#line 3864
  goto ldv_call_6;
#line 3866
  goto ldv_call_6;
#line 3868
  goto ldv_call_6;
#line 3870
  goto ldv_call_6;
#line 3872
  goto ldv_call_6;
#line 3874
  goto ldv_call_6;
#line 3876
  goto ldv_call_6;
#line 3878
  goto ldv_call_6;
#line 3880
  goto ldv_call_6;
#line 3882
  goto ldv_call_6;
#line 3884
  goto ldv_call_6;
#line 3886
  goto ldv_call_6;
#line 3888
  goto ldv_call_6;
#line 3890
  goto ldv_call_6;
#line 3892
  goto ldv_call_6;
#line 3894
  goto ldv_call_6;
#line 3896
  goto ldv_call_6;
#line 3898
  goto ldv_call_6;
#line 3900
  goto ldv_call_6;
#line 3902
  goto ldv_call_6;
#line 3904
  goto ldv_call_6;
#line 3906
  goto ldv_call_6;
#line 3908
  goto ldv_call_6;
#line 3910
  goto ldv_call_6;
#line 3912
  goto ldv_call_6;
#line 3914
  goto ldv_call_6;
#line 3916
  goto ldv_call_6;
#line 3918
  goto ldv_call_6;
#line 3920
  goto ldv_call_6;
#line 3922
  goto ldv_call_6;
#line 3924
  goto ldv_call_6;
#line 3926
  goto ldv_call_6;
#line 3928
  goto ldv_call_6;
#line 3930
  goto ldv_call_6;
#line 3932
  goto ldv_call_6;
  case_39: /* CIL Label */ 
  {
#line 3938
  ldv_dummy_resourceless_instance_callback_6_110(ldv_6_callback_ndo_get_stats64, ldv_6_container_net_device,
                                                 ldv_6_container_struct_rtnl_link_stats64_ptr);
  }
#line 3945
  goto ldv_call_6;
#line 3947
  goto ldv_call_6;
#line 3949
  goto ldv_call_6;
#line 3951
  goto ldv_call_6;
#line 3953
  goto ldv_call_6;
#line 3955
  goto ldv_call_6;
#line 3957
  goto ldv_call_6;
#line 3959
  goto ldv_call_6;
#line 3961
  goto ldv_call_6;
#line 3963
  goto ldv_call_6;
#line 3965
  goto ldv_call_6;
#line 3967
  goto ldv_call_6;
#line 3969
  goto ldv_call_6;
#line 3971
  goto ldv_call_6;
#line 3973
  goto ldv_call_6;
#line 3975
  goto ldv_call_6;
#line 3977
  goto ldv_call_6;
#line 3979
  goto ldv_call_6;
#line 3981
  goto ldv_call_6;
#line 3983
  goto ldv_call_6;
#line 3985
  goto ldv_call_6;
#line 3987
  goto ldv_call_6;
#line 3989
  goto ldv_call_6;
#line 3991
  goto ldv_call_6;
#line 3993
  goto ldv_call_6;
#line 3995
  goto ldv_call_6;
#line 3997
  goto ldv_call_6;
#line 3999
  goto ldv_call_6;
#line 4001
  goto ldv_call_6;
#line 4003
  goto ldv_call_6;
#line 4005
  goto ldv_call_6;
#line 4007
  goto ldv_call_6;
#line 4009
  goto ldv_call_6;
#line 4011
  goto ldv_call_6;
#line 4013
  goto ldv_call_6;
#line 4015
  goto ldv_call_6;
#line 4017
  goto ldv_call_6;
#line 4019
  goto ldv_call_6;
#line 4021
  goto ldv_call_6;
  case_40: /* CIL Label */ 
  {
#line 4030
  ldv_dummy_resourceless_instance_callback_6_107(ldv_6_callback_ndo_fix_features,
                                                 ldv_6_container_net_device, ldv_6_ldv_param_107_1_default);
  }
#line 4040
  goto ldv_call_6;
#line 4042
  goto ldv_call_6;
#line 4044
  goto ldv_call_6;
#line 4046
  goto ldv_call_6;
#line 4048
  goto ldv_call_6;
#line 4050
  goto ldv_call_6;
#line 4052
  goto ldv_call_6;
#line 4054
  goto ldv_call_6;
#line 4056
  goto ldv_call_6;
#line 4058
  goto ldv_call_6;
#line 4060
  goto ldv_call_6;
#line 4062
  goto ldv_call_6;
#line 4064
  goto ldv_call_6;
#line 4066
  goto ldv_call_6;
#line 4068
  goto ldv_call_6;
#line 4070
  goto ldv_call_6;
#line 4072
  goto ldv_call_6;
#line 4074
  goto ldv_call_6;
#line 4076
  goto ldv_call_6;
#line 4078
  goto ldv_call_6;
#line 4080
  goto ldv_call_6;
#line 4082
  goto ldv_call_6;
#line 4084
  goto ldv_call_6;
#line 4086
  goto ldv_call_6;
#line 4088
  goto ldv_call_6;
#line 4090
  goto ldv_call_6;
#line 4092
  goto ldv_call_6;
#line 4094
  goto ldv_call_6;
#line 4096
  goto ldv_call_6;
#line 4098
  goto ldv_call_6;
#line 4100
  goto ldv_call_6;
#line 4102
  goto ldv_call_6;
#line 4104
  goto ldv_call_6;
#line 4106
  goto ldv_call_6;
#line 4108
  goto ldv_call_6;
#line 4110
  goto ldv_call_6;
#line 4112
  goto ldv_call_6;
#line 4114
  goto ldv_call_6;
#line 4116
  goto ldv_call_6;
#line 4118
  goto ldv_call_6;
  case_41: /* CIL Label */ 
  {
#line 4123
  tmp___4 = ldv_xmalloc(1UL);
#line 4123
  ldv_6_ldv_param_104_3_default = (unsigned char *)tmp___4;
#line 4128
  ldv_dummy_resourceless_instance_callback_6_104(ldv_6_callback_ndo_fdb_add, ldv_6_container_struct_ndmsg_ptr,
                                                 ldv_6_container_struct_nlattr_ptr_ptr,
                                                 ldv_6_container_net_device, ldv_6_ldv_param_104_3_default,
                                                 (int )ldv_6_ldv_param_104_4_default);
#line 4132
  ldv_free((void *)ldv_6_ldv_param_104_3_default);
  }
#line 4139
  goto ldv_call_6;
#line 4141
  goto ldv_call_6;
#line 4143
  goto ldv_call_6;
#line 4145
  goto ldv_call_6;
#line 4147
  goto ldv_call_6;
#line 4149
  goto ldv_call_6;
#line 4151
  goto ldv_call_6;
#line 4153
  goto ldv_call_6;
#line 4155
  goto ldv_call_6;
#line 4157
  goto ldv_call_6;
#line 4159
  goto ldv_call_6;
#line 4161
  goto ldv_call_6;
#line 4163
  goto ldv_call_6;
#line 4165
  goto ldv_call_6;
#line 4167
  goto ldv_call_6;
#line 4169
  goto ldv_call_6;
#line 4171
  goto ldv_call_6;
#line 4173
  goto ldv_call_6;
#line 4175
  goto ldv_call_6;
#line 4177
  goto ldv_call_6;
#line 4179
  goto ldv_call_6;
#line 4181
  goto ldv_call_6;
#line 4183
  goto ldv_call_6;
#line 4185
  goto ldv_call_6;
#line 4187
  goto ldv_call_6;
#line 4189
  goto ldv_call_6;
#line 4191
  goto ldv_call_6;
#line 4193
  goto ldv_call_6;
#line 4195
  goto ldv_call_6;
#line 4197
  goto ldv_call_6;
#line 4199
  goto ldv_call_6;
#line 4201
  goto ldv_call_6;
#line 4203
  goto ldv_call_6;
#line 4205
  goto ldv_call_6;
#line 4207
  goto ldv_call_6;
#line 4209
  goto ldv_call_6;
#line 4211
  goto ldv_call_6;
#line 4213
  goto ldv_call_6;
#line 4215
  goto ldv_call_6;
#line 4217
  goto ldv_call_6;
#line 4219
  goto ldv_call_6;
  case_42: /* CIL Label */ 
  {
#line 4224
  tmp___5 = ldv_xmalloc(8UL);
#line 4224
  ldv_6_ldv_param_101_1_default = (unsigned long long *)tmp___5;
#line 4229
  ldv_dummy_resourceless_instance_callback_6_101(ldv_6_callback_ndo_fcoe_get_wwn,
                                                 ldv_6_container_net_device, ldv_6_ldv_param_101_1_default,
                                                 ldv_6_ldv_param_101_2_default);
#line 4233
  ldv_free((void *)ldv_6_ldv_param_101_1_default);
  }
#line 4240
  goto ldv_call_6;
#line 4242
  goto ldv_call_6;
#line 4244
  goto ldv_call_6;
#line 4246
  goto ldv_call_6;
#line 4248
  goto ldv_call_6;
#line 4250
  goto ldv_call_6;
#line 4252
  goto ldv_call_6;
#line 4254
  goto ldv_call_6;
#line 4256
  goto ldv_call_6;
#line 4258
  goto ldv_call_6;
#line 4260
  goto ldv_call_6;
#line 4262
  goto ldv_call_6;
#line 4264
  goto ldv_call_6;
#line 4266
  goto ldv_call_6;
#line 4268
  goto ldv_call_6;
#line 4270
  goto ldv_call_6;
#line 4272
  goto ldv_call_6;
#line 4274
  goto ldv_call_6;
#line 4276
  goto ldv_call_6;
#line 4278
  goto ldv_call_6;
#line 4280
  goto ldv_call_6;
#line 4282
  goto ldv_call_6;
#line 4284
  goto ldv_call_6;
#line 4286
  goto ldv_call_6;
#line 4288
  goto ldv_call_6;
#line 4290
  goto ldv_call_6;
#line 4292
  goto ldv_call_6;
#line 4294
  goto ldv_call_6;
#line 4296
  goto ldv_call_6;
#line 4298
  goto ldv_call_6;
#line 4300
  goto ldv_call_6;
#line 4302
  goto ldv_call_6;
#line 4304
  goto ldv_call_6;
#line 4306
  goto ldv_call_6;
#line 4308
  goto ldv_call_6;
#line 4310
  goto ldv_call_6;
#line 4312
  goto ldv_call_6;
#line 4314
  goto ldv_call_6;
#line 4316
  goto ldv_call_6;
#line 4318
  goto ldv_call_6;
#line 4320
  goto ldv_call_6;
#line 4322
  goto ldv_call_6;
  case_43: /* CIL Label */ 
  {
#line 4328
  ldv_dummy_resourceless_instance_callback_6_100(ldv_6_callback_ndo_fcoe_get_hbainfo,
                                                 ldv_6_container_net_device, ldv_6_container_struct_netdev_fcoe_hbainfo_ptr);
  }
#line 4335
  goto ldv_call_6;
#line 4337
  goto ldv_call_6;
#line 4339
  goto ldv_call_6;
#line 4341
  goto ldv_call_6;
#line 4343
  goto ldv_call_6;
#line 4345
  goto ldv_call_6;
#line 4347
  goto ldv_call_6;
#line 4349
  goto ldv_call_6;
#line 4351
  goto ldv_call_6;
#line 4353
  goto ldv_call_6;
#line 4355
  goto ldv_call_6;
#line 4357
  goto ldv_call_6;
#line 4359
  goto ldv_call_6;
#line 4361
  goto ldv_call_6;
#line 4363
  goto ldv_call_6;
#line 4365
  goto ldv_call_6;
#line 4367
  goto ldv_call_6;
#line 4369
  goto ldv_call_6;
#line 4371
  goto ldv_call_6;
#line 4373
  goto ldv_call_6;
#line 4375
  goto ldv_call_6;
#line 4377
  goto ldv_call_6;
#line 4379
  goto ldv_call_6;
#line 4381
  goto ldv_call_6;
#line 4383
  goto ldv_call_6;
#line 4385
  goto ldv_call_6;
#line 4387
  goto ldv_call_6;
#line 4389
  goto ldv_call_6;
#line 4391
  goto ldv_call_6;
#line 4393
  goto ldv_call_6;
#line 4395
  goto ldv_call_6;
#line 4397
  goto ldv_call_6;
#line 4399
  goto ldv_call_6;
#line 4401
  goto ldv_call_6;
#line 4403
  goto ldv_call_6;
#line 4405
  goto ldv_call_6;
#line 4407
  goto ldv_call_6;
#line 4409
  goto ldv_call_6;
#line 4411
  goto ldv_call_6;
#line 4413
  goto ldv_call_6;
#line 4415
  goto ldv_call_6;
#line 4417
  goto ldv_call_6;
#line 4419
  goto ldv_call_6;
  case_44: /* CIL Label */ 
  {
#line 4425
  ldv_dummy_resourceless_instance_callback_6_99(ldv_6_callback_ndo_fcoe_enable, ldv_6_container_net_device);
  }
#line 4432
  goto ldv_call_6;
#line 4434
  goto ldv_call_6;
#line 4436
  goto ldv_call_6;
#line 4438
  goto ldv_call_6;
#line 4440
  goto ldv_call_6;
#line 4442
  goto ldv_call_6;
#line 4444
  goto ldv_call_6;
#line 4446
  goto ldv_call_6;
#line 4448
  goto ldv_call_6;
#line 4450
  goto ldv_call_6;
#line 4452
  goto ldv_call_6;
#line 4454
  goto ldv_call_6;
#line 4456
  goto ldv_call_6;
#line 4458
  goto ldv_call_6;
#line 4460
  goto ldv_call_6;
#line 4462
  goto ldv_call_6;
#line 4464
  goto ldv_call_6;
#line 4466
  goto ldv_call_6;
#line 4468
  goto ldv_call_6;
#line 4470
  goto ldv_call_6;
#line 4472
  goto ldv_call_6;
#line 4474
  goto ldv_call_6;
#line 4476
  goto ldv_call_6;
#line 4478
  goto ldv_call_6;
#line 4480
  goto ldv_call_6;
#line 4482
  goto ldv_call_6;
#line 4484
  goto ldv_call_6;
#line 4486
  goto ldv_call_6;
#line 4488
  goto ldv_call_6;
#line 4490
  goto ldv_call_6;
#line 4492
  goto ldv_call_6;
#line 4494
  goto ldv_call_6;
#line 4496
  goto ldv_call_6;
#line 4498
  goto ldv_call_6;
#line 4500
  goto ldv_call_6;
#line 4502
  goto ldv_call_6;
#line 4504
  goto ldv_call_6;
#line 4506
  goto ldv_call_6;
#line 4508
  goto ldv_call_6;
#line 4510
  goto ldv_call_6;
#line 4512
  goto ldv_call_6;
#line 4514
  goto ldv_call_6;
#line 4516
  goto ldv_call_6;
#line 4518
  goto ldv_call_6;
  case_45: /* CIL Label */ 
  {
#line 4524
  ldv_dummy_resourceless_instance_callback_6_98(ldv_6_callback_ndo_fcoe_disable, ldv_6_container_net_device);
  }
#line 4531
  goto ldv_call_6;
#line 4533
  goto ldv_call_6;
#line 4535
  goto ldv_call_6;
#line 4537
  goto ldv_call_6;
#line 4539
  goto ldv_call_6;
#line 4541
  goto ldv_call_6;
#line 4543
  goto ldv_call_6;
#line 4545
  goto ldv_call_6;
#line 4547
  goto ldv_call_6;
#line 4549
  goto ldv_call_6;
#line 4551
  goto ldv_call_6;
#line 4553
  goto ldv_call_6;
#line 4555
  goto ldv_call_6;
#line 4557
  goto ldv_call_6;
#line 4559
  goto ldv_call_6;
#line 4561
  goto ldv_call_6;
#line 4563
  goto ldv_call_6;
#line 4565
  goto ldv_call_6;
#line 4567
  goto ldv_call_6;
#line 4569
  goto ldv_call_6;
#line 4571
  goto ldv_call_6;
#line 4573
  goto ldv_call_6;
#line 4575
  goto ldv_call_6;
#line 4577
  goto ldv_call_6;
#line 4579
  goto ldv_call_6;
#line 4581
  goto ldv_call_6;
#line 4583
  goto ldv_call_6;
#line 4585
  goto ldv_call_6;
#line 4587
  goto ldv_call_6;
#line 4589
  goto ldv_call_6;
#line 4591
  goto ldv_call_6;
#line 4593
  goto ldv_call_6;
#line 4595
  goto ldv_call_6;
#line 4597
  goto ldv_call_6;
#line 4599
  goto ldv_call_6;
#line 4601
  goto ldv_call_6;
#line 4603
  goto ldv_call_6;
#line 4605
  goto ldv_call_6;
#line 4607
  goto ldv_call_6;
#line 4609
  goto ldv_call_6;
#line 4611
  goto ldv_call_6;
#line 4613
  goto ldv_call_6;
#line 4615
  goto ldv_call_6;
#line 4617
  goto ldv_call_6;
#line 4619
  goto ldv_call_6;
  case_46: /* CIL Label */ 
  {
#line 4628
  ldv_dummy_resourceless_instance_callback_6_95(ldv_6_callback_ndo_fcoe_ddp_target,
                                                ldv_6_container_net_device, (int )ldv_6_ldv_param_95_1_default,
                                                ldv_6_container_struct_scatterlist_ptr,
                                                ldv_6_ldv_param_95_3_default);
  }
#line 4638
  goto ldv_call_6;
#line 4640
  goto ldv_call_6;
#line 4642
  goto ldv_call_6;
#line 4644
  goto ldv_call_6;
#line 4646
  goto ldv_call_6;
#line 4648
  goto ldv_call_6;
#line 4650
  goto ldv_call_6;
#line 4652
  goto ldv_call_6;
#line 4654
  goto ldv_call_6;
#line 4656
  goto ldv_call_6;
#line 4658
  goto ldv_call_6;
#line 4660
  goto ldv_call_6;
#line 4662
  goto ldv_call_6;
#line 4664
  goto ldv_call_6;
#line 4666
  goto ldv_call_6;
#line 4668
  goto ldv_call_6;
#line 4670
  goto ldv_call_6;
#line 4672
  goto ldv_call_6;
#line 4674
  goto ldv_call_6;
#line 4676
  goto ldv_call_6;
#line 4678
  goto ldv_call_6;
#line 4680
  goto ldv_call_6;
#line 4682
  goto ldv_call_6;
#line 4684
  goto ldv_call_6;
#line 4686
  goto ldv_call_6;
#line 4688
  goto ldv_call_6;
#line 4690
  goto ldv_call_6;
#line 4692
  goto ldv_call_6;
#line 4694
  goto ldv_call_6;
#line 4696
  goto ldv_call_6;
#line 4698
  goto ldv_call_6;
#line 4700
  goto ldv_call_6;
#line 4702
  goto ldv_call_6;
#line 4704
  goto ldv_call_6;
#line 4706
  goto ldv_call_6;
#line 4708
  goto ldv_call_6;
#line 4710
  goto ldv_call_6;
#line 4712
  goto ldv_call_6;
#line 4714
  goto ldv_call_6;
#line 4716
  goto ldv_call_6;
#line 4718
  goto ldv_call_6;
#line 4720
  goto ldv_call_6;
#line 4722
  goto ldv_call_6;
#line 4724
  goto ldv_call_6;
#line 4726
  goto ldv_call_6;
#line 4728
  goto ldv_call_6;
  case_47: /* CIL Label */ 
  {
#line 4737
  ldv_dummy_resourceless_instance_callback_6_92(ldv_6_callback_ndo_fcoe_ddp_setup,
                                                ldv_6_container_net_device, (int )ldv_6_ldv_param_92_1_default,
                                                ldv_6_container_struct_scatterlist_ptr,
                                                ldv_6_ldv_param_92_3_default);
  }
#line 4747
  goto ldv_call_6;
#line 4749
  goto ldv_call_6;
#line 4751
  goto ldv_call_6;
#line 4753
  goto ldv_call_6;
#line 4755
  goto ldv_call_6;
#line 4757
  goto ldv_call_6;
#line 4759
  goto ldv_call_6;
#line 4761
  goto ldv_call_6;
#line 4763
  goto ldv_call_6;
#line 4765
  goto ldv_call_6;
#line 4767
  goto ldv_call_6;
#line 4769
  goto ldv_call_6;
#line 4771
  goto ldv_call_6;
#line 4773
  goto ldv_call_6;
#line 4775
  goto ldv_call_6;
#line 4777
  goto ldv_call_6;
#line 4779
  goto ldv_call_6;
#line 4781
  goto ldv_call_6;
#line 4783
  goto ldv_call_6;
#line 4785
  goto ldv_call_6;
#line 4787
  goto ldv_call_6;
#line 4789
  goto ldv_call_6;
#line 4791
  goto ldv_call_6;
#line 4793
  goto ldv_call_6;
#line 4795
  goto ldv_call_6;
#line 4797
  goto ldv_call_6;
#line 4799
  goto ldv_call_6;
#line 4801
  goto ldv_call_6;
#line 4803
  goto ldv_call_6;
#line 4805
  goto ldv_call_6;
#line 4807
  goto ldv_call_6;
#line 4809
  goto ldv_call_6;
#line 4811
  goto ldv_call_6;
#line 4813
  goto ldv_call_6;
#line 4815
  goto ldv_call_6;
#line 4817
  goto ldv_call_6;
#line 4819
  goto ldv_call_6;
#line 4821
  goto ldv_call_6;
#line 4823
  goto ldv_call_6;
#line 4825
  goto ldv_call_6;
#line 4827
  goto ldv_call_6;
#line 4829
  goto ldv_call_6;
#line 4831
  goto ldv_call_6;
#line 4833
  goto ldv_call_6;
#line 4835
  goto ldv_call_6;
#line 4837
  goto ldv_call_6;
#line 4839
  goto ldv_call_6;
  case_48: /* CIL Label */ 
  {
#line 4848
  ldv_dummy_resourceless_instance_callback_6_89(ldv_6_callback_ndo_fcoe_ddp_done,
                                                ldv_6_container_net_device, (int )ldv_6_ldv_param_89_1_default);
  }
#line 4858
  goto ldv_call_6;
#line 4860
  goto ldv_call_6;
#line 4862
  goto ldv_call_6;
#line 4864
  goto ldv_call_6;
#line 4866
  goto ldv_call_6;
#line 4868
  goto ldv_call_6;
#line 4870
  goto ldv_call_6;
#line 4872
  goto ldv_call_6;
#line 4874
  goto ldv_call_6;
#line 4876
  goto ldv_call_6;
#line 4878
  goto ldv_call_6;
#line 4880
  goto ldv_call_6;
#line 4882
  goto ldv_call_6;
#line 4884
  goto ldv_call_6;
#line 4886
  goto ldv_call_6;
#line 4888
  goto ldv_call_6;
#line 4890
  goto ldv_call_6;
#line 4892
  goto ldv_call_6;
#line 4894
  goto ldv_call_6;
#line 4896
  goto ldv_call_6;
#line 4898
  goto ldv_call_6;
#line 4900
  goto ldv_call_6;
#line 4902
  goto ldv_call_6;
#line 4904
  goto ldv_call_6;
#line 4906
  goto ldv_call_6;
#line 4908
  goto ldv_call_6;
#line 4910
  goto ldv_call_6;
#line 4912
  goto ldv_call_6;
#line 4914
  goto ldv_call_6;
#line 4916
  goto ldv_call_6;
#line 4918
  goto ldv_call_6;
#line 4920
  goto ldv_call_6;
#line 4922
  goto ldv_call_6;
#line 4924
  goto ldv_call_6;
#line 4926
  goto ldv_call_6;
#line 4928
  goto ldv_call_6;
#line 4930
  goto ldv_call_6;
#line 4932
  goto ldv_call_6;
#line 4934
  goto ldv_call_6;
#line 4936
  goto ldv_call_6;
#line 4938
  goto ldv_call_6;
#line 4940
  goto ldv_call_6;
#line 4942
  goto ldv_call_6;
#line 4944
  goto ldv_call_6;
#line 4946
  goto ldv_call_6;
#line 4948
  goto ldv_call_6;
#line 4950
  goto ldv_call_6;
#line 4952
  goto ldv_call_6;
  case_49: /* CIL Label */ 
  {
#line 4961
  ldv_dummy_resourceless_instance_callback_6_86(ldv_6_callback_ndo_do_ioctl, ldv_6_container_net_device,
                                                ldv_6_container_struct_ifreq_ptr,
                                                ldv_6_ldv_param_86_2_default);
  }
#line 4971
  goto ldv_call_6;
#line 4973
  goto ldv_call_6;
#line 4975
  goto ldv_call_6;
#line 4977
  goto ldv_call_6;
#line 4979
  goto ldv_call_6;
#line 4981
  goto ldv_call_6;
#line 4983
  goto ldv_call_6;
#line 4985
  goto ldv_call_6;
#line 4987
  goto ldv_call_6;
#line 4989
  goto ldv_call_6;
#line 4991
  goto ldv_call_6;
#line 4993
  goto ldv_call_6;
#line 4995
  goto ldv_call_6;
#line 4997
  goto ldv_call_6;
#line 4999
  goto ldv_call_6;
#line 5001
  goto ldv_call_6;
#line 5003
  goto ldv_call_6;
#line 5005
  goto ldv_call_6;
#line 5007
  goto ldv_call_6;
#line 5009
  goto ldv_call_6;
#line 5011
  goto ldv_call_6;
#line 5013
  goto ldv_call_6;
#line 5015
  goto ldv_call_6;
#line 5017
  goto ldv_call_6;
#line 5019
  goto ldv_call_6;
#line 5021
  goto ldv_call_6;
#line 5023
  goto ldv_call_6;
#line 5025
  goto ldv_call_6;
#line 5027
  goto ldv_call_6;
#line 5029
  goto ldv_call_6;
#line 5031
  goto ldv_call_6;
#line 5033
  goto ldv_call_6;
#line 5035
  goto ldv_call_6;
#line 5037
  goto ldv_call_6;
#line 5039
  goto ldv_call_6;
#line 5041
  goto ldv_call_6;
#line 5043
  goto ldv_call_6;
#line 5045
  goto ldv_call_6;
#line 5047
  goto ldv_call_6;
#line 5049
  goto ldv_call_6;
#line 5051
  goto ldv_call_6;
#line 5053
  goto ldv_call_6;
#line 5055
  goto ldv_call_6;
#line 5057
  goto ldv_call_6;
#line 5059
  goto ldv_call_6;
#line 5061
  goto ldv_call_6;
#line 5063
  goto ldv_call_6;
#line 5065
  goto ldv_call_6;
#line 5067
  goto ldv_call_6;
  case_50: /* CIL Label */ 
  {
#line 5073
  ldv_dummy_resourceless_instance_callback_6_85(ldv_6_callback_ndo_dfwd_del_station,
                                                ldv_6_container_net_device, (void *)ldv_6_container_func_2_ptr);
  }
#line 5080
  goto ldv_call_6;
#line 5082
  goto ldv_call_6;
#line 5084
  goto ldv_call_6;
#line 5086
  goto ldv_call_6;
#line 5088
  goto ldv_call_6;
#line 5090
  goto ldv_call_6;
#line 5092
  goto ldv_call_6;
#line 5094
  goto ldv_call_6;
#line 5096
  goto ldv_call_6;
#line 5098
  goto ldv_call_6;
#line 5100
  goto ldv_call_6;
#line 5102
  goto ldv_call_6;
#line 5104
  goto ldv_call_6;
#line 5106
  goto ldv_call_6;
#line 5108
  goto ldv_call_6;
#line 5110
  goto ldv_call_6;
#line 5112
  goto ldv_call_6;
#line 5114
  goto ldv_call_6;
#line 5116
  goto ldv_call_6;
#line 5118
  goto ldv_call_6;
#line 5120
  goto ldv_call_6;
#line 5122
  goto ldv_call_6;
#line 5124
  goto ldv_call_6;
#line 5126
  goto ldv_call_6;
#line 5128
  goto ldv_call_6;
#line 5130
  goto ldv_call_6;
#line 5132
  goto ldv_call_6;
#line 5134
  goto ldv_call_6;
#line 5136
  goto ldv_call_6;
#line 5138
  goto ldv_call_6;
#line 5140
  goto ldv_call_6;
#line 5142
  goto ldv_call_6;
#line 5144
  goto ldv_call_6;
#line 5146
  goto ldv_call_6;
#line 5148
  goto ldv_call_6;
#line 5150
  goto ldv_call_6;
#line 5152
  goto ldv_call_6;
#line 5154
  goto ldv_call_6;
#line 5156
  goto ldv_call_6;
#line 5158
  goto ldv_call_6;
#line 5160
  goto ldv_call_6;
#line 5162
  goto ldv_call_6;
#line 5164
  goto ldv_call_6;
#line 5166
  goto ldv_call_6;
#line 5168
  goto ldv_call_6;
#line 5170
  goto ldv_call_6;
#line 5172
  goto ldv_call_6;
#line 5174
  goto ldv_call_6;
#line 5176
  goto ldv_call_6;
#line 5178
  goto ldv_call_6;
  case_51: /* CIL Label */ 
  {
#line 5183
  tmp___6 = ldv_xmalloc(3200UL);
#line 5183
  ldv_6_ldv_param_82_1_default = (struct net_device *)tmp___6;
#line 5188
  ldv_dummy_resourceless_instance_callback_6_82(ldv_6_callback_ndo_dfwd_add_station,
                                                ldv_6_container_net_device, ldv_6_ldv_param_82_1_default);
#line 5192
  ldv_free((void *)ldv_6_ldv_param_82_1_default);
  }
#line 5199
  goto ldv_call_6;
#line 5201
  goto ldv_call_6;
#line 5203
  goto ldv_call_6;
#line 5205
  goto ldv_call_6;
#line 5207
  goto ldv_call_6;
#line 5209
  goto ldv_call_6;
#line 5211
  goto ldv_call_6;
#line 5213
  goto ldv_call_6;
#line 5215
  goto ldv_call_6;
#line 5217
  goto ldv_call_6;
#line 5219
  goto ldv_call_6;
#line 5221
  goto ldv_call_6;
#line 5223
  goto ldv_call_6;
#line 5225
  goto ldv_call_6;
#line 5227
  goto ldv_call_6;
#line 5229
  goto ldv_call_6;
#line 5231
  goto ldv_call_6;
#line 5233
  goto ldv_call_6;
#line 5235
  goto ldv_call_6;
#line 5237
  goto ldv_call_6;
#line 5239
  goto ldv_call_6;
#line 5241
  goto ldv_call_6;
#line 5243
  goto ldv_call_6;
#line 5245
  goto ldv_call_6;
#line 5247
  goto ldv_call_6;
#line 5249
  goto ldv_call_6;
#line 5251
  goto ldv_call_6;
#line 5253
  goto ldv_call_6;
#line 5255
  goto ldv_call_6;
#line 5257
  goto ldv_call_6;
#line 5259
  goto ldv_call_6;
#line 5261
  goto ldv_call_6;
#line 5263
  goto ldv_call_6;
#line 5265
  goto ldv_call_6;
#line 5267
  goto ldv_call_6;
#line 5269
  goto ldv_call_6;
#line 5271
  goto ldv_call_6;
#line 5273
  goto ldv_call_6;
#line 5275
  goto ldv_call_6;
#line 5277
  goto ldv_call_6;
#line 5279
  goto ldv_call_6;
#line 5281
  goto ldv_call_6;
#line 5283
  goto ldv_call_6;
#line 5285
  goto ldv_call_6;
#line 5287
  goto ldv_call_6;
#line 5289
  goto ldv_call_6;
#line 5291
  goto ldv_call_6;
#line 5293
  goto ldv_call_6;
#line 5295
  goto ldv_call_6;
#line 5297
  goto ldv_call_6;
#line 5299
  goto ldv_call_6;
  case_52: /* CIL Label */ 
  {
#line 5308
  ldv_dummy_resourceless_instance_callback_6_79(ldv_6_callback_ndo_change_mtu, ldv_6_container_net_device,
                                                ldv_6_ldv_param_79_1_default);
  }
#line 5318
  goto ldv_call_6;
#line 5320
  goto ldv_call_6;
#line 5322
  goto ldv_call_6;
#line 5324
  goto ldv_call_6;
#line 5326
  goto ldv_call_6;
#line 5328
  goto ldv_call_6;
#line 5330
  goto ldv_call_6;
#line 5332
  goto ldv_call_6;
#line 5334
  goto ldv_call_6;
#line 5336
  goto ldv_call_6;
#line 5338
  goto ldv_call_6;
#line 5340
  goto ldv_call_6;
#line 5342
  goto ldv_call_6;
#line 5344
  goto ldv_call_6;
#line 5346
  goto ldv_call_6;
#line 5348
  goto ldv_call_6;
#line 5350
  goto ldv_call_6;
#line 5352
  goto ldv_call_6;
#line 5354
  goto ldv_call_6;
#line 5356
  goto ldv_call_6;
#line 5358
  goto ldv_call_6;
#line 5360
  goto ldv_call_6;
#line 5362
  goto ldv_call_6;
#line 5364
  goto ldv_call_6;
#line 5366
  goto ldv_call_6;
#line 5368
  goto ldv_call_6;
#line 5370
  goto ldv_call_6;
#line 5372
  goto ldv_call_6;
#line 5374
  goto ldv_call_6;
#line 5376
  goto ldv_call_6;
#line 5378
  goto ldv_call_6;
#line 5380
  goto ldv_call_6;
#line 5382
  goto ldv_call_6;
#line 5384
  goto ldv_call_6;
#line 5386
  goto ldv_call_6;
#line 5388
  goto ldv_call_6;
#line 5390
  goto ldv_call_6;
#line 5392
  goto ldv_call_6;
#line 5394
  goto ldv_call_6;
#line 5396
  goto ldv_call_6;
#line 5398
  goto ldv_call_6;
#line 5400
  goto ldv_call_6;
#line 5402
  goto ldv_call_6;
#line 5404
  goto ldv_call_6;
#line 5406
  goto ldv_call_6;
#line 5408
  goto ldv_call_6;
#line 5410
  goto ldv_call_6;
#line 5412
  goto ldv_call_6;
#line 5414
  goto ldv_call_6;
#line 5416
  goto ldv_call_6;
#line 5418
  goto ldv_call_6;
#line 5420
  goto ldv_call_6;
  case_53: /* CIL Label */ 
  {
#line 5426
  ldv_dummy_resourceless_instance_callback_6_78(ldv_6_callback_ndo_busy_poll, ldv_6_container_struct_napi_struct_ptr);
  }
#line 5433
  goto ldv_call_6;
#line 5435
  goto ldv_call_6;
#line 5437
  goto ldv_call_6;
#line 5439
  goto ldv_call_6;
#line 5441
  goto ldv_call_6;
#line 5443
  goto ldv_call_6;
#line 5445
  goto ldv_call_6;
#line 5447
  goto ldv_call_6;
#line 5449
  goto ldv_call_6;
#line 5451
  goto ldv_call_6;
#line 5453
  goto ldv_call_6;
#line 5455
  goto ldv_call_6;
#line 5457
  goto ldv_call_6;
#line 5459
  goto ldv_call_6;
#line 5461
  goto ldv_call_6;
#line 5463
  goto ldv_call_6;
#line 5465
  goto ldv_call_6;
#line 5467
  goto ldv_call_6;
#line 5469
  goto ldv_call_6;
#line 5471
  goto ldv_call_6;
#line 5473
  goto ldv_call_6;
#line 5475
  goto ldv_call_6;
#line 5477
  goto ldv_call_6;
#line 5479
  goto ldv_call_6;
#line 5481
  goto ldv_call_6;
#line 5483
  goto ldv_call_6;
#line 5485
  goto ldv_call_6;
#line 5487
  goto ldv_call_6;
#line 5489
  goto ldv_call_6;
#line 5491
  goto ldv_call_6;
#line 5493
  goto ldv_call_6;
#line 5495
  goto ldv_call_6;
#line 5497
  goto ldv_call_6;
#line 5499
  goto ldv_call_6;
#line 5501
  goto ldv_call_6;
#line 5503
  goto ldv_call_6;
#line 5505
  goto ldv_call_6;
#line 5507
  goto ldv_call_6;
#line 5509
  goto ldv_call_6;
#line 5511
  goto ldv_call_6;
#line 5513
  goto ldv_call_6;
#line 5515
  goto ldv_call_6;
#line 5517
  goto ldv_call_6;
#line 5519
  goto ldv_call_6;
#line 5521
  goto ldv_call_6;
#line 5523
  goto ldv_call_6;
#line 5525
  goto ldv_call_6;
#line 5527
  goto ldv_call_6;
#line 5529
  goto ldv_call_6;
#line 5531
  goto ldv_call_6;
#line 5533
  goto ldv_call_6;
#line 5535
  goto ldv_call_6;
#line 5537
  goto ldv_call_6;
  case_54: /* CIL Label */ 
  {
#line 5543
  ldv_dummy_resourceless_instance_callback_6_77(ldv_6_callback_ndo_bridge_setlink,
                                                ldv_6_container_net_device, ldv_6_container_struct_nlmsghdr_ptr);
  }
#line 5550
  goto ldv_call_6;
#line 5552
  goto ldv_call_6;
#line 5554
  goto ldv_call_6;
#line 5556
  goto ldv_call_6;
#line 5558
  goto ldv_call_6;
#line 5560
  goto ldv_call_6;
#line 5562
  goto ldv_call_6;
#line 5564
  goto ldv_call_6;
#line 5566
  goto ldv_call_6;
#line 5568
  goto ldv_call_6;
#line 5570
  goto ldv_call_6;
#line 5572
  goto ldv_call_6;
#line 5574
  goto ldv_call_6;
#line 5576
  goto ldv_call_6;
#line 5578
  goto ldv_call_6;
#line 5580
  goto ldv_call_6;
#line 5582
  goto ldv_call_6;
#line 5584
  goto ldv_call_6;
#line 5586
  goto ldv_call_6;
#line 5588
  goto ldv_call_6;
#line 5590
  goto ldv_call_6;
#line 5592
  goto ldv_call_6;
#line 5594
  goto ldv_call_6;
#line 5596
  goto ldv_call_6;
#line 5598
  goto ldv_call_6;
#line 5600
  goto ldv_call_6;
#line 5602
  goto ldv_call_6;
#line 5604
  goto ldv_call_6;
#line 5606
  goto ldv_call_6;
#line 5608
  goto ldv_call_6;
#line 5610
  goto ldv_call_6;
#line 5612
  goto ldv_call_6;
#line 5614
  goto ldv_call_6;
#line 5616
  goto ldv_call_6;
#line 5618
  goto ldv_call_6;
#line 5620
  goto ldv_call_6;
#line 5622
  goto ldv_call_6;
#line 5624
  goto ldv_call_6;
#line 5626
  goto ldv_call_6;
#line 5628
  goto ldv_call_6;
#line 5630
  goto ldv_call_6;
#line 5632
  goto ldv_call_6;
#line 5634
  goto ldv_call_6;
#line 5636
  goto ldv_call_6;
#line 5638
  goto ldv_call_6;
#line 5640
  goto ldv_call_6;
#line 5642
  goto ldv_call_6;
#line 5644
  goto ldv_call_6;
#line 5646
  goto ldv_call_6;
#line 5648
  goto ldv_call_6;
#line 5650
  goto ldv_call_6;
#line 5652
  goto ldv_call_6;
#line 5654
  goto ldv_call_6;
#line 5656
  goto ldv_call_6;
  case_55: /* CIL Label */ 
  {
#line 5665
  ldv_dummy_resourceless_instance_callback_6_74(ldv_6_callback_ndo_bridge_getlink,
                                                ldv_6_container_struct_sk_buff_ptr,
                                                ldv_6_ldv_param_74_1_default, ldv_6_ldv_param_74_2_default,
                                                ldv_6_container_net_device, ldv_6_ldv_param_74_4_default);
  }
#line 5675
  goto ldv_call_6;
#line 5677
  goto ldv_call_6;
#line 5679
  goto ldv_call_6;
#line 5681
  goto ldv_call_6;
#line 5683
  goto ldv_call_6;
#line 5685
  goto ldv_call_6;
#line 5687
  goto ldv_call_6;
#line 5689
  goto ldv_call_6;
#line 5691
  goto ldv_call_6;
#line 5693
  goto ldv_call_6;
#line 5695
  goto ldv_call_6;
#line 5697
  goto ldv_call_6;
#line 5699
  goto ldv_call_6;
#line 5701
  goto ldv_call_6;
#line 5703
  goto ldv_call_6;
#line 5705
  goto ldv_call_6;
#line 5707
  goto ldv_call_6;
#line 5709
  goto ldv_call_6;
#line 5711
  goto ldv_call_6;
#line 5713
  goto ldv_call_6;
#line 5715
  goto ldv_call_6;
#line 5717
  goto ldv_call_6;
#line 5719
  goto ldv_call_6;
#line 5721
  goto ldv_call_6;
#line 5723
  goto ldv_call_6;
#line 5725
  goto ldv_call_6;
#line 5727
  goto ldv_call_6;
#line 5729
  goto ldv_call_6;
#line 5731
  goto ldv_call_6;
#line 5733
  goto ldv_call_6;
#line 5735
  goto ldv_call_6;
#line 5737
  goto ldv_call_6;
#line 5739
  goto ldv_call_6;
#line 5741
  goto ldv_call_6;
#line 5743
  goto ldv_call_6;
#line 5745
  goto ldv_call_6;
#line 5747
  goto ldv_call_6;
#line 5749
  goto ldv_call_6;
#line 5751
  goto ldv_call_6;
#line 5753
  goto ldv_call_6;
#line 5755
  goto ldv_call_6;
#line 5757
  goto ldv_call_6;
#line 5759
  goto ldv_call_6;
#line 5761
  goto ldv_call_6;
#line 5763
  goto ldv_call_6;
#line 5765
  goto ldv_call_6;
#line 5767
  goto ldv_call_6;
#line 5769
  goto ldv_call_6;
#line 5771
  goto ldv_call_6;
#line 5773
  goto ldv_call_6;
#line 5775
  goto ldv_call_6;
#line 5777
  goto ldv_call_6;
#line 5779
  goto ldv_call_6;
#line 5781
  goto ldv_call_6;
#line 5783
  goto ldv_call_6;
  case_56: /* CIL Label */ 
  {
#line 5789
  ldv_dummy_resourceless_instance_callback_6_73(ldv_6_callback_ieee_setpfc, ldv_6_container_net_device,
                                                ldv_6_container_struct_ieee_pfc_ptr);
  }
#line 5796
  goto ldv_call_6;
#line 5798
  goto ldv_call_6;
#line 5800
  goto ldv_call_6;
#line 5802
  goto ldv_call_6;
#line 5804
  goto ldv_call_6;
#line 5806
  goto ldv_call_6;
#line 5808
  goto ldv_call_6;
#line 5810
  goto ldv_call_6;
#line 5812
  goto ldv_call_6;
#line 5814
  goto ldv_call_6;
#line 5816
  goto ldv_call_6;
#line 5818
  goto ldv_call_6;
#line 5820
  goto ldv_call_6;
#line 5822
  goto ldv_call_6;
#line 5824
  goto ldv_call_6;
#line 5826
  goto ldv_call_6;
#line 5828
  goto ldv_call_6;
#line 5830
  goto ldv_call_6;
#line 5832
  goto ldv_call_6;
#line 5834
  goto ldv_call_6;
#line 5836
  goto ldv_call_6;
#line 5838
  goto ldv_call_6;
#line 5840
  goto ldv_call_6;
#line 5842
  goto ldv_call_6;
#line 5844
  goto ldv_call_6;
#line 5846
  goto ldv_call_6;
#line 5848
  goto ldv_call_6;
#line 5850
  goto ldv_call_6;
#line 5852
  goto ldv_call_6;
#line 5854
  goto ldv_call_6;
#line 5856
  goto ldv_call_6;
#line 5858
  goto ldv_call_6;
#line 5860
  goto ldv_call_6;
#line 5862
  goto ldv_call_6;
#line 5864
  goto ldv_call_6;
#line 5866
  goto ldv_call_6;
#line 5868
  goto ldv_call_6;
#line 5870
  goto ldv_call_6;
#line 5872
  goto ldv_call_6;
#line 5874
  goto ldv_call_6;
#line 5876
  goto ldv_call_6;
#line 5878
  goto ldv_call_6;
#line 5880
  goto ldv_call_6;
#line 5882
  goto ldv_call_6;
#line 5884
  goto ldv_call_6;
#line 5886
  goto ldv_call_6;
#line 5888
  goto ldv_call_6;
#line 5890
  goto ldv_call_6;
#line 5892
  goto ldv_call_6;
#line 5894
  goto ldv_call_6;
#line 5896
  goto ldv_call_6;
#line 5898
  goto ldv_call_6;
#line 5900
  goto ldv_call_6;
#line 5902
  goto ldv_call_6;
#line 5904
  goto ldv_call_6;
#line 5906
  goto ldv_call_6;
  case_57: /* CIL Label */ 
  {
#line 5912
  ldv_dummy_resourceless_instance_callback_6_72(ldv_6_callback_ieee_setets, ldv_6_container_net_device,
                                                ldv_6_container_struct_ieee_ets_ptr);
  }
#line 5919
  goto ldv_call_6;
#line 5921
  goto ldv_call_6;
#line 5923
  goto ldv_call_6;
#line 5925
  goto ldv_call_6;
#line 5927
  goto ldv_call_6;
#line 5929
  goto ldv_call_6;
#line 5931
  goto ldv_call_6;
#line 5933
  goto ldv_call_6;
#line 5935
  goto ldv_call_6;
#line 5937
  goto ldv_call_6;
#line 5939
  goto ldv_call_6;
#line 5941
  goto ldv_call_6;
#line 5943
  goto ldv_call_6;
#line 5945
  goto ldv_call_6;
#line 5947
  goto ldv_call_6;
#line 5949
  goto ldv_call_6;
#line 5951
  goto ldv_call_6;
#line 5953
  goto ldv_call_6;
#line 5955
  goto ldv_call_6;
#line 5957
  goto ldv_call_6;
#line 5959
  goto ldv_call_6;
#line 5961
  goto ldv_call_6;
#line 5963
  goto ldv_call_6;
#line 5965
  goto ldv_call_6;
#line 5967
  goto ldv_call_6;
#line 5969
  goto ldv_call_6;
#line 5971
  goto ldv_call_6;
#line 5973
  goto ldv_call_6;
#line 5975
  goto ldv_call_6;
#line 5977
  goto ldv_call_6;
#line 5979
  goto ldv_call_6;
#line 5981
  goto ldv_call_6;
#line 5983
  goto ldv_call_6;
#line 5985
  goto ldv_call_6;
#line 5987
  goto ldv_call_6;
#line 5989
  goto ldv_call_6;
#line 5991
  goto ldv_call_6;
#line 5993
  goto ldv_call_6;
#line 5995
  goto ldv_call_6;
#line 5997
  goto ldv_call_6;
#line 5999
  goto ldv_call_6;
#line 6001
  goto ldv_call_6;
#line 6003
  goto ldv_call_6;
#line 6005
  goto ldv_call_6;
#line 6007
  goto ldv_call_6;
#line 6009
  goto ldv_call_6;
#line 6011
  goto ldv_call_6;
#line 6013
  goto ldv_call_6;
#line 6015
  goto ldv_call_6;
#line 6017
  goto ldv_call_6;
#line 6019
  goto ldv_call_6;
#line 6021
  goto ldv_call_6;
#line 6023
  goto ldv_call_6;
#line 6025
  goto ldv_call_6;
#line 6027
  goto ldv_call_6;
#line 6029
  goto ldv_call_6;
#line 6031
  goto ldv_call_6;
  case_58: /* CIL Label */ 
  {
#line 6037
  ldv_dummy_resourceless_instance_callback_6_71(ldv_6_callback_ieee_setapp, ldv_6_container_net_device,
                                                ldv_6_container_struct_dcb_app_ptr);
  }
#line 6044
  goto ldv_call_6;
#line 6046
  goto ldv_call_6;
#line 6048
  goto ldv_call_6;
#line 6050
  goto ldv_call_6;
#line 6052
  goto ldv_call_6;
#line 6054
  goto ldv_call_6;
#line 6056
  goto ldv_call_6;
#line 6058
  goto ldv_call_6;
#line 6060
  goto ldv_call_6;
#line 6062
  goto ldv_call_6;
#line 6064
  goto ldv_call_6;
#line 6066
  goto ldv_call_6;
#line 6068
  goto ldv_call_6;
#line 6070
  goto ldv_call_6;
#line 6072
  goto ldv_call_6;
#line 6074
  goto ldv_call_6;
#line 6076
  goto ldv_call_6;
#line 6078
  goto ldv_call_6;
#line 6080
  goto ldv_call_6;
#line 6082
  goto ldv_call_6;
#line 6084
  goto ldv_call_6;
#line 6086
  goto ldv_call_6;
#line 6088
  goto ldv_call_6;
#line 6090
  goto ldv_call_6;
#line 6092
  goto ldv_call_6;
#line 6094
  goto ldv_call_6;
#line 6096
  goto ldv_call_6;
#line 6098
  goto ldv_call_6;
#line 6100
  goto ldv_call_6;
#line 6102
  goto ldv_call_6;
#line 6104
  goto ldv_call_6;
#line 6106
  goto ldv_call_6;
#line 6108
  goto ldv_call_6;
#line 6110
  goto ldv_call_6;
#line 6112
  goto ldv_call_6;
#line 6114
  goto ldv_call_6;
#line 6116
  goto ldv_call_6;
#line 6118
  goto ldv_call_6;
#line 6120
  goto ldv_call_6;
#line 6122
  goto ldv_call_6;
#line 6124
  goto ldv_call_6;
#line 6126
  goto ldv_call_6;
#line 6128
  goto ldv_call_6;
#line 6130
  goto ldv_call_6;
#line 6132
  goto ldv_call_6;
#line 6134
  goto ldv_call_6;
#line 6136
  goto ldv_call_6;
#line 6138
  goto ldv_call_6;
#line 6140
  goto ldv_call_6;
#line 6142
  goto ldv_call_6;
#line 6144
  goto ldv_call_6;
#line 6146
  goto ldv_call_6;
#line 6148
  goto ldv_call_6;
#line 6150
  goto ldv_call_6;
#line 6152
  goto ldv_call_6;
#line 6154
  goto ldv_call_6;
#line 6156
  goto ldv_call_6;
#line 6158
  goto ldv_call_6;
  case_59: /* CIL Label */ 
  {
#line 6164
  ldv_dummy_resourceless_instance_callback_6_70(ldv_6_callback_ieee_getpfc, ldv_6_container_net_device,
                                                ldv_6_container_struct_ieee_pfc_ptr);
  }
#line 6171
  goto ldv_call_6;
#line 6173
  goto ldv_call_6;
#line 6175
  goto ldv_call_6;
#line 6177
  goto ldv_call_6;
#line 6179
  goto ldv_call_6;
#line 6181
  goto ldv_call_6;
#line 6183
  goto ldv_call_6;
#line 6185
  goto ldv_call_6;
#line 6187
  goto ldv_call_6;
#line 6189
  goto ldv_call_6;
#line 6191
  goto ldv_call_6;
#line 6193
  goto ldv_call_6;
#line 6195
  goto ldv_call_6;
#line 6197
  goto ldv_call_6;
#line 6199
  goto ldv_call_6;
#line 6201
  goto ldv_call_6;
#line 6203
  goto ldv_call_6;
#line 6205
  goto ldv_call_6;
#line 6207
  goto ldv_call_6;
#line 6209
  goto ldv_call_6;
#line 6211
  goto ldv_call_6;
#line 6213
  goto ldv_call_6;
#line 6215
  goto ldv_call_6;
#line 6217
  goto ldv_call_6;
#line 6219
  goto ldv_call_6;
#line 6221
  goto ldv_call_6;
#line 6223
  goto ldv_call_6;
#line 6225
  goto ldv_call_6;
#line 6227
  goto ldv_call_6;
#line 6229
  goto ldv_call_6;
#line 6231
  goto ldv_call_6;
#line 6233
  goto ldv_call_6;
#line 6235
  goto ldv_call_6;
#line 6237
  goto ldv_call_6;
#line 6239
  goto ldv_call_6;
#line 6241
  goto ldv_call_6;
#line 6243
  goto ldv_call_6;
#line 6245
  goto ldv_call_6;
#line 6247
  goto ldv_call_6;
#line 6249
  goto ldv_call_6;
#line 6251
  goto ldv_call_6;
#line 6253
  goto ldv_call_6;
#line 6255
  goto ldv_call_6;
#line 6257
  goto ldv_call_6;
#line 6259
  goto ldv_call_6;
#line 6261
  goto ldv_call_6;
#line 6263
  goto ldv_call_6;
#line 6265
  goto ldv_call_6;
#line 6267
  goto ldv_call_6;
#line 6269
  goto ldv_call_6;
#line 6271
  goto ldv_call_6;
#line 6273
  goto ldv_call_6;
#line 6275
  goto ldv_call_6;
#line 6277
  goto ldv_call_6;
#line 6279
  goto ldv_call_6;
#line 6281
  goto ldv_call_6;
#line 6283
  goto ldv_call_6;
#line 6285
  goto ldv_call_6;
#line 6287
  goto ldv_call_6;
  case_60: /* CIL Label */ 
  {
#line 6293
  ldv_dummy_resourceless_instance_callback_6_69(ldv_6_callback_ieee_getets, ldv_6_container_net_device,
                                                ldv_6_container_struct_ieee_ets_ptr);
  }
#line 6300
  goto ldv_call_6;
#line 6302
  goto ldv_call_6;
#line 6304
  goto ldv_call_6;
#line 6306
  goto ldv_call_6;
#line 6308
  goto ldv_call_6;
#line 6310
  goto ldv_call_6;
#line 6312
  goto ldv_call_6;
#line 6314
  goto ldv_call_6;
#line 6316
  goto ldv_call_6;
#line 6318
  goto ldv_call_6;
#line 6320
  goto ldv_call_6;
#line 6322
  goto ldv_call_6;
#line 6324
  goto ldv_call_6;
#line 6326
  goto ldv_call_6;
#line 6328
  goto ldv_call_6;
#line 6330
  goto ldv_call_6;
#line 6332
  goto ldv_call_6;
#line 6334
  goto ldv_call_6;
#line 6336
  goto ldv_call_6;
#line 6338
  goto ldv_call_6;
#line 6340
  goto ldv_call_6;
#line 6342
  goto ldv_call_6;
#line 6344
  goto ldv_call_6;
#line 6346
  goto ldv_call_6;
#line 6348
  goto ldv_call_6;
#line 6350
  goto ldv_call_6;
#line 6352
  goto ldv_call_6;
#line 6354
  goto ldv_call_6;
#line 6356
  goto ldv_call_6;
#line 6358
  goto ldv_call_6;
#line 6360
  goto ldv_call_6;
#line 6362
  goto ldv_call_6;
#line 6364
  goto ldv_call_6;
#line 6366
  goto ldv_call_6;
#line 6368
  goto ldv_call_6;
#line 6370
  goto ldv_call_6;
#line 6372
  goto ldv_call_6;
#line 6374
  goto ldv_call_6;
#line 6376
  goto ldv_call_6;
#line 6378
  goto ldv_call_6;
#line 6380
  goto ldv_call_6;
#line 6382
  goto ldv_call_6;
#line 6384
  goto ldv_call_6;
#line 6386
  goto ldv_call_6;
#line 6388
  goto ldv_call_6;
#line 6390
  goto ldv_call_6;
#line 6392
  goto ldv_call_6;
#line 6394
  goto ldv_call_6;
#line 6396
  goto ldv_call_6;
#line 6398
  goto ldv_call_6;
#line 6400
  goto ldv_call_6;
#line 6402
  goto ldv_call_6;
#line 6404
  goto ldv_call_6;
#line 6406
  goto ldv_call_6;
#line 6408
  goto ldv_call_6;
#line 6410
  goto ldv_call_6;
#line 6412
  goto ldv_call_6;
#line 6414
  goto ldv_call_6;
#line 6416
  goto ldv_call_6;
#line 6418
  goto ldv_call_6;
  case_61: /* CIL Label */ 
  {
#line 6424
  ldv_dummy_resourceless_instance_callback_6_68(ldv_6_callback_ieee_delapp, ldv_6_container_net_device,
                                                ldv_6_container_struct_dcb_app_ptr);
  }
#line 6431
  goto ldv_call_6;
#line 6433
  goto ldv_call_6;
#line 6435
  goto ldv_call_6;
#line 6437
  goto ldv_call_6;
#line 6439
  goto ldv_call_6;
#line 6441
  goto ldv_call_6;
#line 6443
  goto ldv_call_6;
#line 6445
  goto ldv_call_6;
#line 6447
  goto ldv_call_6;
#line 6449
  goto ldv_call_6;
#line 6451
  goto ldv_call_6;
#line 6453
  goto ldv_call_6;
#line 6455
  goto ldv_call_6;
#line 6457
  goto ldv_call_6;
#line 6459
  goto ldv_call_6;
#line 6461
  goto ldv_call_6;
#line 6463
  goto ldv_call_6;
#line 6465
  goto ldv_call_6;
#line 6467
  goto ldv_call_6;
#line 6469
  goto ldv_call_6;
#line 6471
  goto ldv_call_6;
#line 6473
  goto ldv_call_6;
#line 6475
  goto ldv_call_6;
#line 6477
  goto ldv_call_6;
#line 6479
  goto ldv_call_6;
#line 6481
  goto ldv_call_6;
#line 6483
  goto ldv_call_6;
#line 6485
  goto ldv_call_6;
#line 6487
  goto ldv_call_6;
#line 6489
  goto ldv_call_6;
#line 6491
  goto ldv_call_6;
#line 6493
  goto ldv_call_6;
#line 6495
  goto ldv_call_6;
#line 6497
  goto ldv_call_6;
#line 6499
  goto ldv_call_6;
#line 6501
  goto ldv_call_6;
#line 6503
  goto ldv_call_6;
#line 6505
  goto ldv_call_6;
#line 6507
  goto ldv_call_6;
#line 6509
  goto ldv_call_6;
#line 6511
  goto ldv_call_6;
#line 6513
  goto ldv_call_6;
#line 6515
  goto ldv_call_6;
#line 6517
  goto ldv_call_6;
#line 6519
  goto ldv_call_6;
#line 6521
  goto ldv_call_6;
#line 6523
  goto ldv_call_6;
#line 6525
  goto ldv_call_6;
#line 6527
  goto ldv_call_6;
#line 6529
  goto ldv_call_6;
#line 6531
  goto ldv_call_6;
#line 6533
  goto ldv_call_6;
#line 6535
  goto ldv_call_6;
#line 6537
  goto ldv_call_6;
#line 6539
  goto ldv_call_6;
#line 6541
  goto ldv_call_6;
#line 6543
  goto ldv_call_6;
#line 6545
  goto ldv_call_6;
#line 6547
  goto ldv_call_6;
#line 6549
  goto ldv_call_6;
#line 6551
  goto ldv_call_6;
  case_62: /* CIL Label */ 
  {
#line 6557
  ldv_dummy_resourceless_instance_callback_6_67(ldv_6_callback_getstate, ldv_6_container_net_device);
  }
#line 6564
  goto ldv_call_6;
#line 6566
  goto ldv_call_6;
#line 6568
  goto ldv_call_6;
#line 6570
  goto ldv_call_6;
#line 6572
  goto ldv_call_6;
#line 6574
  goto ldv_call_6;
#line 6576
  goto ldv_call_6;
#line 6578
  goto ldv_call_6;
#line 6580
  goto ldv_call_6;
#line 6582
  goto ldv_call_6;
#line 6584
  goto ldv_call_6;
#line 6586
  goto ldv_call_6;
#line 6588
  goto ldv_call_6;
#line 6590
  goto ldv_call_6;
#line 6592
  goto ldv_call_6;
#line 6594
  goto ldv_call_6;
#line 6596
  goto ldv_call_6;
#line 6598
  goto ldv_call_6;
#line 6600
  goto ldv_call_6;
#line 6602
  goto ldv_call_6;
#line 6604
  goto ldv_call_6;
#line 6606
  goto ldv_call_6;
#line 6608
  goto ldv_call_6;
#line 6610
  goto ldv_call_6;
#line 6612
  goto ldv_call_6;
#line 6614
  goto ldv_call_6;
#line 6616
  goto ldv_call_6;
#line 6618
  goto ldv_call_6;
#line 6620
  goto ldv_call_6;
#line 6622
  goto ldv_call_6;
#line 6624
  goto ldv_call_6;
#line 6626
  goto ldv_call_6;
#line 6628
  goto ldv_call_6;
#line 6630
  goto ldv_call_6;
#line 6632
  goto ldv_call_6;
#line 6634
  goto ldv_call_6;
#line 6636
  goto ldv_call_6;
#line 6638
  goto ldv_call_6;
#line 6640
  goto ldv_call_6;
#line 6642
  goto ldv_call_6;
#line 6644
  goto ldv_call_6;
#line 6646
  goto ldv_call_6;
#line 6648
  goto ldv_call_6;
#line 6650
  goto ldv_call_6;
#line 6652
  goto ldv_call_6;
#line 6654
  goto ldv_call_6;
#line 6656
  goto ldv_call_6;
#line 6658
  goto ldv_call_6;
#line 6660
  goto ldv_call_6;
#line 6662
  goto ldv_call_6;
#line 6664
  goto ldv_call_6;
#line 6666
  goto ldv_call_6;
#line 6668
  goto ldv_call_6;
#line 6670
  goto ldv_call_6;
#line 6672
  goto ldv_call_6;
#line 6674
  goto ldv_call_6;
#line 6676
  goto ldv_call_6;
#line 6678
  goto ldv_call_6;
#line 6680
  goto ldv_call_6;
#line 6682
  goto ldv_call_6;
#line 6684
  goto ldv_call_6;
#line 6686
  goto ldv_call_6;
  case_63: /* CIL Label */ 
  {
#line 6691
  tmp___7 = ldv_xmalloc(1UL);
#line 6691
  ldv_6_ldv_param_64_2_default = (unsigned char *)tmp___7;
#line 6692
  tmp___8 = ldv_xmalloc(1UL);
#line 6692
  ldv_6_ldv_param_64_3_default = (unsigned char *)tmp___8;
#line 6693
  tmp___9 = ldv_xmalloc(1UL);
#line 6693
  ldv_6_ldv_param_64_4_default = (unsigned char *)tmp___9;
#line 6694
  tmp___10 = ldv_xmalloc(1UL);
#line 6694
  ldv_6_ldv_param_64_5_default = (unsigned char *)tmp___10;
#line 6699
  ldv_dummy_resourceless_instance_callback_6_64(ldv_6_callback_getpgtccfgtx, ldv_6_container_net_device,
                                                ldv_6_ldv_param_64_1_default, ldv_6_ldv_param_64_2_default,
                                                ldv_6_ldv_param_64_3_default, ldv_6_ldv_param_64_4_default,
                                                ldv_6_ldv_param_64_5_default);
#line 6703
  ldv_free((void *)ldv_6_ldv_param_64_2_default);
#line 6704
  ldv_free((void *)ldv_6_ldv_param_64_3_default);
#line 6705
  ldv_free((void *)ldv_6_ldv_param_64_4_default);
#line 6706
  ldv_free((void *)ldv_6_ldv_param_64_5_default);
  }
#line 6713
  goto ldv_call_6;
#line 6715
  goto ldv_call_6;
#line 6717
  goto ldv_call_6;
#line 6719
  goto ldv_call_6;
#line 6721
  goto ldv_call_6;
#line 6723
  goto ldv_call_6;
#line 6725
  goto ldv_call_6;
#line 6727
  goto ldv_call_6;
#line 6729
  goto ldv_call_6;
#line 6731
  goto ldv_call_6;
#line 6733
  goto ldv_call_6;
#line 6735
  goto ldv_call_6;
#line 6737
  goto ldv_call_6;
#line 6739
  goto ldv_call_6;
#line 6741
  goto ldv_call_6;
#line 6743
  goto ldv_call_6;
#line 6745
  goto ldv_call_6;
#line 6747
  goto ldv_call_6;
#line 6749
  goto ldv_call_6;
#line 6751
  goto ldv_call_6;
#line 6753
  goto ldv_call_6;
#line 6755
  goto ldv_call_6;
#line 6757
  goto ldv_call_6;
#line 6759
  goto ldv_call_6;
#line 6761
  goto ldv_call_6;
#line 6763
  goto ldv_call_6;
#line 6765
  goto ldv_call_6;
#line 6767
  goto ldv_call_6;
#line 6769
  goto ldv_call_6;
#line 6771
  goto ldv_call_6;
#line 6773
  goto ldv_call_6;
#line 6775
  goto ldv_call_6;
#line 6777
  goto ldv_call_6;
#line 6779
  goto ldv_call_6;
#line 6781
  goto ldv_call_6;
#line 6783
  goto ldv_call_6;
#line 6785
  goto ldv_call_6;
#line 6787
  goto ldv_call_6;
#line 6789
  goto ldv_call_6;
#line 6791
  goto ldv_call_6;
#line 6793
  goto ldv_call_6;
#line 6795
  goto ldv_call_6;
#line 6797
  goto ldv_call_6;
#line 6799
  goto ldv_call_6;
#line 6801
  goto ldv_call_6;
#line 6803
  goto ldv_call_6;
#line 6805
  goto ldv_call_6;
#line 6807
  goto ldv_call_6;
#line 6809
  goto ldv_call_6;
#line 6811
  goto ldv_call_6;
#line 6813
  goto ldv_call_6;
#line 6815
  goto ldv_call_6;
#line 6817
  goto ldv_call_6;
#line 6819
  goto ldv_call_6;
#line 6821
  goto ldv_call_6;
#line 6823
  goto ldv_call_6;
#line 6825
  goto ldv_call_6;
#line 6827
  goto ldv_call_6;
#line 6829
  goto ldv_call_6;
#line 6831
  goto ldv_call_6;
#line 6833
  goto ldv_call_6;
#line 6835
  goto ldv_call_6;
#line 6837
  goto ldv_call_6;
  case_64: /* CIL Label */ 
  {
#line 6842
  tmp___11 = ldv_xmalloc(1UL);
#line 6842
  ldv_6_ldv_param_61_2_default = (unsigned char *)tmp___11;
#line 6843
  tmp___12 = ldv_xmalloc(1UL);
#line 6843
  ldv_6_ldv_param_61_3_default = (unsigned char *)tmp___12;
#line 6844
  tmp___13 = ldv_xmalloc(1UL);
#line 6844
  ldv_6_ldv_param_61_4_default = (unsigned char *)tmp___13;
#line 6845
  tmp___14 = ldv_xmalloc(1UL);
#line 6845
  ldv_6_ldv_param_61_5_default = (unsigned char *)tmp___14;
#line 6850
  ldv_dummy_resourceless_instance_callback_6_61(ldv_6_callback_getpgtccfgrx, ldv_6_container_net_device,
                                                ldv_6_ldv_param_61_1_default, ldv_6_ldv_param_61_2_default,
                                                ldv_6_ldv_param_61_3_default, ldv_6_ldv_param_61_4_default,
                                                ldv_6_ldv_param_61_5_default);
#line 6854
  ldv_free((void *)ldv_6_ldv_param_61_2_default);
#line 6855
  ldv_free((void *)ldv_6_ldv_param_61_3_default);
#line 6856
  ldv_free((void *)ldv_6_ldv_param_61_4_default);
#line 6857
  ldv_free((void *)ldv_6_ldv_param_61_5_default);
  }
#line 6864
  goto ldv_call_6;
#line 6866
  goto ldv_call_6;
#line 6868
  goto ldv_call_6;
#line 6870
  goto ldv_call_6;
#line 6872
  goto ldv_call_6;
#line 6874
  goto ldv_call_6;
#line 6876
  goto ldv_call_6;
#line 6878
  goto ldv_call_6;
#line 6880
  goto ldv_call_6;
#line 6882
  goto ldv_call_6;
#line 6884
  goto ldv_call_6;
#line 6886
  goto ldv_call_6;
#line 6888
  goto ldv_call_6;
#line 6890
  goto ldv_call_6;
#line 6892
  goto ldv_call_6;
#line 6894
  goto ldv_call_6;
#line 6896
  goto ldv_call_6;
#line 6898
  goto ldv_call_6;
#line 6900
  goto ldv_call_6;
#line 6902
  goto ldv_call_6;
#line 6904
  goto ldv_call_6;
#line 6906
  goto ldv_call_6;
#line 6908
  goto ldv_call_6;
#line 6910
  goto ldv_call_6;
#line 6912
  goto ldv_call_6;
#line 6914
  goto ldv_call_6;
#line 6916
  goto ldv_call_6;
#line 6918
  goto ldv_call_6;
#line 6920
  goto ldv_call_6;
#line 6922
  goto ldv_call_6;
#line 6924
  goto ldv_call_6;
#line 6926
  goto ldv_call_6;
#line 6928
  goto ldv_call_6;
#line 6930
  goto ldv_call_6;
#line 6932
  goto ldv_call_6;
#line 6934
  goto ldv_call_6;
#line 6936
  goto ldv_call_6;
#line 6938
  goto ldv_call_6;
#line 6940
  goto ldv_call_6;
#line 6942
  goto ldv_call_6;
#line 6944
  goto ldv_call_6;
#line 6946
  goto ldv_call_6;
#line 6948
  goto ldv_call_6;
#line 6950
  goto ldv_call_6;
#line 6952
  goto ldv_call_6;
#line 6954
  goto ldv_call_6;
#line 6956
  goto ldv_call_6;
#line 6958
  goto ldv_call_6;
#line 6960
  goto ldv_call_6;
#line 6962
  goto ldv_call_6;
#line 6964
  goto ldv_call_6;
#line 6966
  goto ldv_call_6;
#line 6968
  goto ldv_call_6;
#line 6970
  goto ldv_call_6;
#line 6972
  goto ldv_call_6;
#line 6974
  goto ldv_call_6;
#line 6976
  goto ldv_call_6;
#line 6978
  goto ldv_call_6;
#line 6980
  goto ldv_call_6;
#line 6982
  goto ldv_call_6;
#line 6984
  goto ldv_call_6;
#line 6986
  goto ldv_call_6;
#line 6988
  goto ldv_call_6;
#line 6990
  goto ldv_call_6;
  case_65: /* CIL Label */ 
  {
#line 6995
  tmp___15 = ldv_xmalloc(1UL);
#line 6995
  ldv_6_ldv_param_58_2_default = (unsigned char *)tmp___15;
#line 7000
  ldv_dummy_resourceless_instance_callback_6_58(ldv_6_callback_getpgbwgcfgtx, ldv_6_container_net_device,
                                                ldv_6_ldv_param_58_1_default, ldv_6_ldv_param_58_2_default);
#line 7004
  ldv_free((void *)ldv_6_ldv_param_58_2_default);
  }
#line 7011
  goto ldv_call_6;
#line 7013
  goto ldv_call_6;
#line 7015
  goto ldv_call_6;
#line 7017
  goto ldv_call_6;
#line 7019
  goto ldv_call_6;
#line 7021
  goto ldv_call_6;
#line 7023
  goto ldv_call_6;
#line 7025
  goto ldv_call_6;
#line 7027
  goto ldv_call_6;
#line 7029
  goto ldv_call_6;
#line 7031
  goto ldv_call_6;
#line 7033
  goto ldv_call_6;
#line 7035
  goto ldv_call_6;
#line 7037
  goto ldv_call_6;
#line 7039
  goto ldv_call_6;
#line 7041
  goto ldv_call_6;
#line 7043
  goto ldv_call_6;
#line 7045
  goto ldv_call_6;
#line 7047
  goto ldv_call_6;
#line 7049
  goto ldv_call_6;
#line 7051
  goto ldv_call_6;
#line 7053
  goto ldv_call_6;
#line 7055
  goto ldv_call_6;
#line 7057
  goto ldv_call_6;
#line 7059
  goto ldv_call_6;
#line 7061
  goto ldv_call_6;
#line 7063
  goto ldv_call_6;
#line 7065
  goto ldv_call_6;
#line 7067
  goto ldv_call_6;
#line 7069
  goto ldv_call_6;
#line 7071
  goto ldv_call_6;
#line 7073
  goto ldv_call_6;
#line 7075
  goto ldv_call_6;
#line 7077
  goto ldv_call_6;
#line 7079
  goto ldv_call_6;
#line 7081
  goto ldv_call_6;
#line 7083
  goto ldv_call_6;
#line 7085
  goto ldv_call_6;
#line 7087
  goto ldv_call_6;
#line 7089
  goto ldv_call_6;
#line 7091
  goto ldv_call_6;
#line 7093
  goto ldv_call_6;
#line 7095
  goto ldv_call_6;
#line 7097
  goto ldv_call_6;
#line 7099
  goto ldv_call_6;
#line 7101
  goto ldv_call_6;
#line 7103
  goto ldv_call_6;
#line 7105
  goto ldv_call_6;
#line 7107
  goto ldv_call_6;
#line 7109
  goto ldv_call_6;
#line 7111
  goto ldv_call_6;
#line 7113
  goto ldv_call_6;
#line 7115
  goto ldv_call_6;
#line 7117
  goto ldv_call_6;
#line 7119
  goto ldv_call_6;
#line 7121
  goto ldv_call_6;
#line 7123
  goto ldv_call_6;
#line 7125
  goto ldv_call_6;
#line 7127
  goto ldv_call_6;
#line 7129
  goto ldv_call_6;
#line 7131
  goto ldv_call_6;
#line 7133
  goto ldv_call_6;
#line 7135
  goto ldv_call_6;
#line 7137
  goto ldv_call_6;
#line 7139
  goto ldv_call_6;
  case_66: /* CIL Label */ 
  {
#line 7144
  tmp___16 = ldv_xmalloc(1UL);
#line 7144
  ldv_6_ldv_param_55_2_default = (unsigned char *)tmp___16;
#line 7149
  ldv_dummy_resourceless_instance_callback_6_55(ldv_6_callback_getpgbwgcfgrx, ldv_6_container_net_device,
                                                ldv_6_ldv_param_55_1_default, ldv_6_ldv_param_55_2_default);
#line 7153
  ldv_free((void *)ldv_6_ldv_param_55_2_default);
  }
#line 7160
  goto ldv_call_6;
#line 7162
  goto ldv_call_6;
#line 7164
  goto ldv_call_6;
#line 7166
  goto ldv_call_6;
#line 7168
  goto ldv_call_6;
#line 7170
  goto ldv_call_6;
#line 7172
  goto ldv_call_6;
#line 7174
  goto ldv_call_6;
#line 7176
  goto ldv_call_6;
#line 7178
  goto ldv_call_6;
#line 7180
  goto ldv_call_6;
#line 7182
  goto ldv_call_6;
#line 7184
  goto ldv_call_6;
#line 7186
  goto ldv_call_6;
#line 7188
  goto ldv_call_6;
#line 7190
  goto ldv_call_6;
#line 7192
  goto ldv_call_6;
#line 7194
  goto ldv_call_6;
#line 7196
  goto ldv_call_6;
#line 7198
  goto ldv_call_6;
#line 7200
  goto ldv_call_6;
#line 7202
  goto ldv_call_6;
#line 7204
  goto ldv_call_6;
#line 7206
  goto ldv_call_6;
#line 7208
  goto ldv_call_6;
#line 7210
  goto ldv_call_6;
#line 7212
  goto ldv_call_6;
#line 7214
  goto ldv_call_6;
#line 7216
  goto ldv_call_6;
#line 7218
  goto ldv_call_6;
#line 7220
  goto ldv_call_6;
#line 7222
  goto ldv_call_6;
#line 7224
  goto ldv_call_6;
#line 7226
  goto ldv_call_6;
#line 7228
  goto ldv_call_6;
#line 7230
  goto ldv_call_6;
#line 7232
  goto ldv_call_6;
#line 7234
  goto ldv_call_6;
#line 7236
  goto ldv_call_6;
#line 7238
  goto ldv_call_6;
#line 7240
  goto ldv_call_6;
#line 7242
  goto ldv_call_6;
#line 7244
  goto ldv_call_6;
#line 7246
  goto ldv_call_6;
#line 7248
  goto ldv_call_6;
#line 7250
  goto ldv_call_6;
#line 7252
  goto ldv_call_6;
#line 7254
  goto ldv_call_6;
#line 7256
  goto ldv_call_6;
#line 7258
  goto ldv_call_6;
#line 7260
  goto ldv_call_6;
#line 7262
  goto ldv_call_6;
#line 7264
  goto ldv_call_6;
#line 7266
  goto ldv_call_6;
#line 7268
  goto ldv_call_6;
#line 7270
  goto ldv_call_6;
#line 7272
  goto ldv_call_6;
#line 7274
  goto ldv_call_6;
#line 7276
  goto ldv_call_6;
#line 7278
  goto ldv_call_6;
#line 7280
  goto ldv_call_6;
#line 7282
  goto ldv_call_6;
#line 7284
  goto ldv_call_6;
#line 7286
  goto ldv_call_6;
#line 7288
  goto ldv_call_6;
#line 7290
  goto ldv_call_6;
  case_67: /* CIL Label */ 
  {
#line 7296
  ldv_dummy_resourceless_instance_callback_6_54(ldv_6_callback_getpfcstate, ldv_6_container_net_device);
  }
#line 7303
  goto ldv_call_6;
#line 7305
  goto ldv_call_6;
#line 7307
  goto ldv_call_6;
#line 7309
  goto ldv_call_6;
#line 7311
  goto ldv_call_6;
#line 7313
  goto ldv_call_6;
#line 7315
  goto ldv_call_6;
#line 7317
  goto ldv_call_6;
#line 7319
  goto ldv_call_6;
#line 7321
  goto ldv_call_6;
#line 7323
  goto ldv_call_6;
#line 7325
  goto ldv_call_6;
#line 7327
  goto ldv_call_6;
#line 7329
  goto ldv_call_6;
#line 7331
  goto ldv_call_6;
#line 7333
  goto ldv_call_6;
#line 7335
  goto ldv_call_6;
#line 7337
  goto ldv_call_6;
#line 7339
  goto ldv_call_6;
#line 7341
  goto ldv_call_6;
#line 7343
  goto ldv_call_6;
#line 7345
  goto ldv_call_6;
#line 7347
  goto ldv_call_6;
#line 7349
  goto ldv_call_6;
#line 7351
  goto ldv_call_6;
#line 7353
  goto ldv_call_6;
#line 7355
  goto ldv_call_6;
#line 7357
  goto ldv_call_6;
#line 7359
  goto ldv_call_6;
#line 7361
  goto ldv_call_6;
#line 7363
  goto ldv_call_6;
#line 7365
  goto ldv_call_6;
#line 7367
  goto ldv_call_6;
#line 7369
  goto ldv_call_6;
#line 7371
  goto ldv_call_6;
#line 7373
  goto ldv_call_6;
#line 7375
  goto ldv_call_6;
#line 7377
  goto ldv_call_6;
#line 7379
  goto ldv_call_6;
#line 7381
  goto ldv_call_6;
#line 7383
  goto ldv_call_6;
#line 7385
  goto ldv_call_6;
#line 7387
  goto ldv_call_6;
#line 7389
  goto ldv_call_6;
#line 7391
  goto ldv_call_6;
#line 7393
  goto ldv_call_6;
#line 7395
  goto ldv_call_6;
#line 7397
  goto ldv_call_6;
#line 7399
  goto ldv_call_6;
#line 7401
  goto ldv_call_6;
#line 7403
  goto ldv_call_6;
#line 7405
  goto ldv_call_6;
#line 7407
  goto ldv_call_6;
#line 7409
  goto ldv_call_6;
#line 7411
  goto ldv_call_6;
#line 7413
  goto ldv_call_6;
#line 7415
  goto ldv_call_6;
#line 7417
  goto ldv_call_6;
#line 7419
  goto ldv_call_6;
#line 7421
  goto ldv_call_6;
#line 7423
  goto ldv_call_6;
#line 7425
  goto ldv_call_6;
#line 7427
  goto ldv_call_6;
#line 7429
  goto ldv_call_6;
#line 7431
  goto ldv_call_6;
#line 7433
  goto ldv_call_6;
#line 7435
  goto ldv_call_6;
  case_68: /* CIL Label */ 
  {
#line 7440
  tmp___17 = ldv_xmalloc(1UL);
#line 7440
  ldv_6_ldv_param_51_2_default = (unsigned char *)tmp___17;
#line 7445
  ldv_dummy_resourceless_instance_callback_6_51(ldv_6_callback_getpfccfg, ldv_6_container_net_device,
                                                ldv_6_ldv_param_51_1_default, ldv_6_ldv_param_51_2_default);
#line 7449
  ldv_free((void *)ldv_6_ldv_param_51_2_default);
  }
#line 7456
  goto ldv_call_6;
#line 7458
  goto ldv_call_6;
#line 7460
  goto ldv_call_6;
#line 7462
  goto ldv_call_6;
#line 7464
  goto ldv_call_6;
#line 7466
  goto ldv_call_6;
#line 7468
  goto ldv_call_6;
#line 7470
  goto ldv_call_6;
#line 7472
  goto ldv_call_6;
#line 7474
  goto ldv_call_6;
#line 7476
  goto ldv_call_6;
#line 7478
  goto ldv_call_6;
#line 7480
  goto ldv_call_6;
#line 7482
  goto ldv_call_6;
#line 7484
  goto ldv_call_6;
#line 7486
  goto ldv_call_6;
#line 7488
  goto ldv_call_6;
#line 7490
  goto ldv_call_6;
#line 7492
  goto ldv_call_6;
#line 7494
  goto ldv_call_6;
#line 7496
  goto ldv_call_6;
#line 7498
  goto ldv_call_6;
#line 7500
  goto ldv_call_6;
#line 7502
  goto ldv_call_6;
#line 7504
  goto ldv_call_6;
#line 7506
  goto ldv_call_6;
#line 7508
  goto ldv_call_6;
#line 7510
  goto ldv_call_6;
#line 7512
  goto ldv_call_6;
#line 7514
  goto ldv_call_6;
#line 7516
  goto ldv_call_6;
#line 7518
  goto ldv_call_6;
#line 7520
  goto ldv_call_6;
#line 7522
  goto ldv_call_6;
#line 7524
  goto ldv_call_6;
#line 7526
  goto ldv_call_6;
#line 7528
  goto ldv_call_6;
#line 7530
  goto ldv_call_6;
#line 7532
  goto ldv_call_6;
#line 7534
  goto ldv_call_6;
#line 7536
  goto ldv_call_6;
#line 7538
  goto ldv_call_6;
#line 7540
  goto ldv_call_6;
#line 7542
  goto ldv_call_6;
#line 7544
  goto ldv_call_6;
#line 7546
  goto ldv_call_6;
#line 7548
  goto ldv_call_6;
#line 7550
  goto ldv_call_6;
#line 7552
  goto ldv_call_6;
#line 7554
  goto ldv_call_6;
#line 7556
  goto ldv_call_6;
#line 7558
  goto ldv_call_6;
#line 7560
  goto ldv_call_6;
#line 7562
  goto ldv_call_6;
#line 7564
  goto ldv_call_6;
#line 7566
  goto ldv_call_6;
#line 7568
  goto ldv_call_6;
#line 7570
  goto ldv_call_6;
#line 7572
  goto ldv_call_6;
#line 7574
  goto ldv_call_6;
#line 7576
  goto ldv_call_6;
#line 7578
  goto ldv_call_6;
#line 7580
  goto ldv_call_6;
#line 7582
  goto ldv_call_6;
#line 7584
  goto ldv_call_6;
#line 7586
  goto ldv_call_6;
#line 7588
  goto ldv_call_6;
#line 7590
  goto ldv_call_6;
  case_69: /* CIL Label */ 
  {
#line 7595
  tmp___18 = ldv_xmalloc(1UL);
#line 7595
  ldv_6_ldv_param_48_1_default = (unsigned char *)tmp___18;
#line 7600
  ldv_dummy_resourceless_instance_callback_6_48(ldv_6_callback_getpermhwaddr, ldv_6_container_net_device,
                                                ldv_6_ldv_param_48_1_default);
#line 7604
  ldv_free((void *)ldv_6_ldv_param_48_1_default);
  }
#line 7611
  goto ldv_call_6;
#line 7613
  goto ldv_call_6;
#line 7615
  goto ldv_call_6;
#line 7617
  goto ldv_call_6;
#line 7619
  goto ldv_call_6;
#line 7621
  goto ldv_call_6;
#line 7623
  goto ldv_call_6;
#line 7625
  goto ldv_call_6;
#line 7627
  goto ldv_call_6;
#line 7629
  goto ldv_call_6;
#line 7631
  goto ldv_call_6;
#line 7633
  goto ldv_call_6;
#line 7635
  goto ldv_call_6;
#line 7637
  goto ldv_call_6;
#line 7639
  goto ldv_call_6;
#line 7641
  goto ldv_call_6;
#line 7643
  goto ldv_call_6;
#line 7645
  goto ldv_call_6;
#line 7647
  goto ldv_call_6;
#line 7649
  goto ldv_call_6;
#line 7651
  goto ldv_call_6;
#line 7653
  goto ldv_call_6;
#line 7655
  goto ldv_call_6;
#line 7657
  goto ldv_call_6;
#line 7659
  goto ldv_call_6;
#line 7661
  goto ldv_call_6;
#line 7663
  goto ldv_call_6;
#line 7665
  goto ldv_call_6;
#line 7667
  goto ldv_call_6;
#line 7669
  goto ldv_call_6;
#line 7671
  goto ldv_call_6;
#line 7673
  goto ldv_call_6;
#line 7675
  goto ldv_call_6;
#line 7677
  goto ldv_call_6;
#line 7679
  goto ldv_call_6;
#line 7681
  goto ldv_call_6;
#line 7683
  goto ldv_call_6;
#line 7685
  goto ldv_call_6;
#line 7687
  goto ldv_call_6;
#line 7689
  goto ldv_call_6;
#line 7691
  goto ldv_call_6;
#line 7693
  goto ldv_call_6;
#line 7695
  goto ldv_call_6;
#line 7697
  goto ldv_call_6;
#line 7699
  goto ldv_call_6;
#line 7701
  goto ldv_call_6;
#line 7703
  goto ldv_call_6;
#line 7705
  goto ldv_call_6;
#line 7707
  goto ldv_call_6;
#line 7709
  goto ldv_call_6;
#line 7711
  goto ldv_call_6;
#line 7713
  goto ldv_call_6;
#line 7715
  goto ldv_call_6;
#line 7717
  goto ldv_call_6;
#line 7719
  goto ldv_call_6;
#line 7721
  goto ldv_call_6;
#line 7723
  goto ldv_call_6;
#line 7725
  goto ldv_call_6;
#line 7727
  goto ldv_call_6;
#line 7729
  goto ldv_call_6;
#line 7731
  goto ldv_call_6;
#line 7733
  goto ldv_call_6;
#line 7735
  goto ldv_call_6;
#line 7737
  goto ldv_call_6;
#line 7739
  goto ldv_call_6;
#line 7741
  goto ldv_call_6;
#line 7743
  goto ldv_call_6;
#line 7745
  goto ldv_call_6;
#line 7747
  goto ldv_call_6;
  case_70: /* CIL Label */ 
  {
#line 7752
  tmp___19 = ldv_xmalloc(1UL);
#line 7752
  ldv_6_ldv_param_45_2_default = (unsigned char *)tmp___19;
#line 7757
  ldv_dummy_resourceless_instance_callback_6_45(ldv_6_callback_getnumtcs, ldv_6_container_net_device,
                                                ldv_6_ldv_param_45_1_default, ldv_6_ldv_param_45_2_default);
#line 7761
  ldv_free((void *)ldv_6_ldv_param_45_2_default);
  }
#line 7768
  goto ldv_call_6;
#line 7770
  goto ldv_call_6;
#line 7772
  goto ldv_call_6;
#line 7774
  goto ldv_call_6;
#line 7776
  goto ldv_call_6;
#line 7778
  goto ldv_call_6;
#line 7780
  goto ldv_call_6;
#line 7782
  goto ldv_call_6;
#line 7784
  goto ldv_call_6;
#line 7786
  goto ldv_call_6;
#line 7788
  goto ldv_call_6;
#line 7790
  goto ldv_call_6;
#line 7792
  goto ldv_call_6;
#line 7794
  goto ldv_call_6;
#line 7796
  goto ldv_call_6;
#line 7798
  goto ldv_call_6;
#line 7800
  goto ldv_call_6;
#line 7802
  goto ldv_call_6;
#line 7804
  goto ldv_call_6;
#line 7806
  goto ldv_call_6;
#line 7808
  goto ldv_call_6;
#line 7810
  goto ldv_call_6;
#line 7812
  goto ldv_call_6;
#line 7814
  goto ldv_call_6;
#line 7816
  goto ldv_call_6;
#line 7818
  goto ldv_call_6;
#line 7820
  goto ldv_call_6;
#line 7822
  goto ldv_call_6;
#line 7824
  goto ldv_call_6;
#line 7826
  goto ldv_call_6;
#line 7828
  goto ldv_call_6;
#line 7830
  goto ldv_call_6;
#line 7832
  goto ldv_call_6;
#line 7834
  goto ldv_call_6;
#line 7836
  goto ldv_call_6;
#line 7838
  goto ldv_call_6;
#line 7840
  goto ldv_call_6;
#line 7842
  goto ldv_call_6;
#line 7844
  goto ldv_call_6;
#line 7846
  goto ldv_call_6;
#line 7848
  goto ldv_call_6;
#line 7850
  goto ldv_call_6;
#line 7852
  goto ldv_call_6;
#line 7854
  goto ldv_call_6;
#line 7856
  goto ldv_call_6;
#line 7858
  goto ldv_call_6;
#line 7860
  goto ldv_call_6;
#line 7862
  goto ldv_call_6;
#line 7864
  goto ldv_call_6;
#line 7866
  goto ldv_call_6;
#line 7868
  goto ldv_call_6;
#line 7870
  goto ldv_call_6;
#line 7872
  goto ldv_call_6;
#line 7874
  goto ldv_call_6;
#line 7876
  goto ldv_call_6;
#line 7878
  goto ldv_call_6;
#line 7880
  goto ldv_call_6;
#line 7882
  goto ldv_call_6;
#line 7884
  goto ldv_call_6;
#line 7886
  goto ldv_call_6;
#line 7888
  goto ldv_call_6;
#line 7890
  goto ldv_call_6;
#line 7892
  goto ldv_call_6;
#line 7894
  goto ldv_call_6;
#line 7896
  goto ldv_call_6;
#line 7898
  goto ldv_call_6;
#line 7900
  goto ldv_call_6;
#line 7902
  goto ldv_call_6;
#line 7904
  goto ldv_call_6;
#line 7906
  goto ldv_call_6;
  case_71: /* CIL Label */ 
  {
#line 7912
  ldv_dummy_resourceless_instance_callback_6_44(ldv_6_callback_getdcbx, ldv_6_container_net_device);
  }
#line 7919
  goto ldv_call_6;
#line 7921
  goto ldv_call_6;
#line 7923
  goto ldv_call_6;
#line 7925
  goto ldv_call_6;
#line 7927
  goto ldv_call_6;
#line 7929
  goto ldv_call_6;
#line 7931
  goto ldv_call_6;
#line 7933
  goto ldv_call_6;
#line 7935
  goto ldv_call_6;
#line 7937
  goto ldv_call_6;
#line 7939
  goto ldv_call_6;
#line 7941
  goto ldv_call_6;
#line 7943
  goto ldv_call_6;
#line 7945
  goto ldv_call_6;
#line 7947
  goto ldv_call_6;
#line 7949
  goto ldv_call_6;
#line 7951
  goto ldv_call_6;
#line 7953
  goto ldv_call_6;
#line 7955
  goto ldv_call_6;
#line 7957
  goto ldv_call_6;
#line 7959
  goto ldv_call_6;
#line 7961
  goto ldv_call_6;
#line 7963
  goto ldv_call_6;
#line 7965
  goto ldv_call_6;
#line 7967
  goto ldv_call_6;
#line 7969
  goto ldv_call_6;
#line 7971
  goto ldv_call_6;
#line 7973
  goto ldv_call_6;
#line 7975
  goto ldv_call_6;
#line 7977
  goto ldv_call_6;
#line 7979
  goto ldv_call_6;
#line 7981
  goto ldv_call_6;
#line 7983
  goto ldv_call_6;
#line 7985
  goto ldv_call_6;
#line 7987
  goto ldv_call_6;
#line 7989
  goto ldv_call_6;
#line 7991
  goto ldv_call_6;
#line 7993
  goto ldv_call_6;
#line 7995
  goto ldv_call_6;
#line 7997
  goto ldv_call_6;
#line 7999
  goto ldv_call_6;
#line 8001
  goto ldv_call_6;
#line 8003
  goto ldv_call_6;
#line 8005
  goto ldv_call_6;
#line 8007
  goto ldv_call_6;
#line 8009
  goto ldv_call_6;
#line 8011
  goto ldv_call_6;
#line 8013
  goto ldv_call_6;
#line 8015
  goto ldv_call_6;
#line 8017
  goto ldv_call_6;
#line 8019
  goto ldv_call_6;
#line 8021
  goto ldv_call_6;
#line 8023
  goto ldv_call_6;
#line 8025
  goto ldv_call_6;
#line 8027
  goto ldv_call_6;
#line 8029
  goto ldv_call_6;
#line 8031
  goto ldv_call_6;
#line 8033
  goto ldv_call_6;
#line 8035
  goto ldv_call_6;
#line 8037
  goto ldv_call_6;
#line 8039
  goto ldv_call_6;
#line 8041
  goto ldv_call_6;
#line 8043
  goto ldv_call_6;
#line 8045
  goto ldv_call_6;
#line 8047
  goto ldv_call_6;
#line 8049
  goto ldv_call_6;
#line 8051
  goto ldv_call_6;
#line 8053
  goto ldv_call_6;
#line 8055
  goto ldv_call_6;
#line 8057
  goto ldv_call_6;
#line 8059
  goto ldv_call_6;
  case_72: /* CIL Label */ 
  {
#line 8064
  tmp___20 = ldv_xmalloc(1UL);
#line 8064
  ldv_6_ldv_param_41_2_default = (unsigned char *)tmp___20;
#line 8069
  ldv_dummy_resourceless_instance_callback_6_41(ldv_6_callback_getcap, ldv_6_container_net_device,
                                                ldv_6_ldv_param_41_1_default, ldv_6_ldv_param_41_2_default);
#line 8073
  ldv_free((void *)ldv_6_ldv_param_41_2_default);
  }
#line 8080
  goto ldv_call_6;
#line 8082
  goto ldv_call_6;
#line 8084
  goto ldv_call_6;
#line 8086
  goto ldv_call_6;
#line 8088
  goto ldv_call_6;
#line 8090
  goto ldv_call_6;
#line 8092
  goto ldv_call_6;
#line 8094
  goto ldv_call_6;
#line 8096
  goto ldv_call_6;
#line 8098
  goto ldv_call_6;
#line 8100
  goto ldv_call_6;
#line 8102
  goto ldv_call_6;
#line 8104
  goto ldv_call_6;
#line 8106
  goto ldv_call_6;
#line 8108
  goto ldv_call_6;
#line 8110
  goto ldv_call_6;
#line 8112
  goto ldv_call_6;
#line 8114
  goto ldv_call_6;
#line 8116
  goto ldv_call_6;
#line 8118
  goto ldv_call_6;
#line 8120
  goto ldv_call_6;
#line 8122
  goto ldv_call_6;
#line 8124
  goto ldv_call_6;
#line 8126
  goto ldv_call_6;
#line 8128
  goto ldv_call_6;
#line 8130
  goto ldv_call_6;
#line 8132
  goto ldv_call_6;
#line 8134
  goto ldv_call_6;
#line 8136
  goto ldv_call_6;
#line 8138
  goto ldv_call_6;
#line 8140
  goto ldv_call_6;
#line 8142
  goto ldv_call_6;
#line 8144
  goto ldv_call_6;
#line 8146
  goto ldv_call_6;
#line 8148
  goto ldv_call_6;
#line 8150
  goto ldv_call_6;
#line 8152
  goto ldv_call_6;
#line 8154
  goto ldv_call_6;
#line 8156
  goto ldv_call_6;
#line 8158
  goto ldv_call_6;
#line 8160
  goto ldv_call_6;
#line 8162
  goto ldv_call_6;
#line 8164
  goto ldv_call_6;
#line 8166
  goto ldv_call_6;
#line 8168
  goto ldv_call_6;
#line 8170
  goto ldv_call_6;
#line 8172
  goto ldv_call_6;
#line 8174
  goto ldv_call_6;
#line 8176
  goto ldv_call_6;
#line 8178
  goto ldv_call_6;
#line 8180
  goto ldv_call_6;
#line 8182
  goto ldv_call_6;
#line 8184
  goto ldv_call_6;
#line 8186
  goto ldv_call_6;
#line 8188
  goto ldv_call_6;
#line 8190
  goto ldv_call_6;
#line 8192
  goto ldv_call_6;
#line 8194
  goto ldv_call_6;
#line 8196
  goto ldv_call_6;
#line 8198
  goto ldv_call_6;
#line 8200
  goto ldv_call_6;
#line 8202
  goto ldv_call_6;
#line 8204
  goto ldv_call_6;
#line 8206
  goto ldv_call_6;
#line 8208
  goto ldv_call_6;
#line 8210
  goto ldv_call_6;
#line 8212
  goto ldv_call_6;
#line 8214
  goto ldv_call_6;
#line 8216
  goto ldv_call_6;
#line 8218
  goto ldv_call_6;
#line 8220
  goto ldv_call_6;
#line 8222
  goto ldv_call_6;
  case_73: /* CIL Label */ 
  {
#line 8231
  ldv_dummy_resourceless_instance_callback_6_38(ldv_6_callback_getapp, ldv_6_container_net_device,
                                                (int )ldv_6_ldv_param_38_1_default,
                                                (int )ldv_6_ldv_param_38_2_default);
  }
#line 8241
  goto ldv_call_6;
#line 8243
  goto ldv_call_6;
#line 8245
  goto ldv_call_6;
#line 8247
  goto ldv_call_6;
#line 8249
  goto ldv_call_6;
#line 8251
  goto ldv_call_6;
#line 8253
  goto ldv_call_6;
#line 8255
  goto ldv_call_6;
#line 8257
  goto ldv_call_6;
#line 8259
  goto ldv_call_6;
#line 8261
  goto ldv_call_6;
#line 8263
  goto ldv_call_6;
#line 8265
  goto ldv_call_6;
#line 8267
  goto ldv_call_6;
#line 8269
  goto ldv_call_6;
#line 8271
  goto ldv_call_6;
#line 8273
  goto ldv_call_6;
#line 8275
  goto ldv_call_6;
#line 8277
  goto ldv_call_6;
#line 8279
  goto ldv_call_6;
#line 8281
  goto ldv_call_6;
#line 8283
  goto ldv_call_6;
#line 8285
  goto ldv_call_6;
#line 8287
  goto ldv_call_6;
#line 8289
  goto ldv_call_6;
#line 8291
  goto ldv_call_6;
#line 8293
  goto ldv_call_6;
#line 8295
  goto ldv_call_6;
#line 8297
  goto ldv_call_6;
#line 8299
  goto ldv_call_6;
#line 8301
  goto ldv_call_6;
#line 8303
  goto ldv_call_6;
#line 8305
  goto ldv_call_6;
#line 8307
  goto ldv_call_6;
#line 8309
  goto ldv_call_6;
#line 8311
  goto ldv_call_6;
#line 8313
  goto ldv_call_6;
#line 8315
  goto ldv_call_6;
#line 8317
  goto ldv_call_6;
#line 8319
  goto ldv_call_6;
#line 8321
  goto ldv_call_6;
#line 8323
  goto ldv_call_6;
#line 8325
  goto ldv_call_6;
#line 8327
  goto ldv_call_6;
#line 8329
  goto ldv_call_6;
#line 8331
  goto ldv_call_6;
#line 8333
  goto ldv_call_6;
#line 8335
  goto ldv_call_6;
#line 8337
  goto ldv_call_6;
#line 8339
  goto ldv_call_6;
#line 8341
  goto ldv_call_6;
#line 8343
  goto ldv_call_6;
#line 8345
  goto ldv_call_6;
#line 8347
  goto ldv_call_6;
#line 8349
  goto ldv_call_6;
#line 8351
  goto ldv_call_6;
#line 8353
  goto ldv_call_6;
#line 8355
  goto ldv_call_6;
#line 8357
  goto ldv_call_6;
#line 8359
  goto ldv_call_6;
#line 8361
  goto ldv_call_6;
#line 8363
  goto ldv_call_6;
#line 8365
  goto ldv_call_6;
#line 8367
  goto ldv_call_6;
#line 8369
  goto ldv_call_6;
#line 8371
  goto ldv_call_6;
#line 8373
  goto ldv_call_6;
#line 8375
  goto ldv_call_6;
#line 8377
  goto ldv_call_6;
#line 8379
  goto ldv_call_6;
#line 8381
  goto ldv_call_6;
#line 8383
  goto ldv_call_6;
#line 8385
  goto ldv_call_6;
  case_74: /* CIL Label */ 
  {
#line 8391
  ldv_dummy_resourceless_instance_callback_6_37(ldv_6_callback_get_wol, ldv_6_container_net_device,
                                                ldv_6_container_struct_ethtool_wolinfo_ptr);
  }
#line 8398
  goto ldv_call_6;
#line 8400
  goto ldv_call_6;
#line 8402
  goto ldv_call_6;
#line 8404
  goto ldv_call_6;
#line 8406
  goto ldv_call_6;
#line 8408
  goto ldv_call_6;
#line 8410
  goto ldv_call_6;
#line 8412
  goto ldv_call_6;
#line 8414
  goto ldv_call_6;
#line 8416
  goto ldv_call_6;
#line 8418
  goto ldv_call_6;
#line 8420
  goto ldv_call_6;
#line 8422
  goto ldv_call_6;
#line 8424
  goto ldv_call_6;
#line 8426
  goto ldv_call_6;
#line 8428
  goto ldv_call_6;
#line 8430
  goto ldv_call_6;
#line 8432
  goto ldv_call_6;
#line 8434
  goto ldv_call_6;
#line 8436
  goto ldv_call_6;
#line 8438
  goto ldv_call_6;
#line 8440
  goto ldv_call_6;
#line 8442
  goto ldv_call_6;
#line 8444
  goto ldv_call_6;
#line 8446
  goto ldv_call_6;
#line 8448
  goto ldv_call_6;
#line 8450
  goto ldv_call_6;
#line 8452
  goto ldv_call_6;
#line 8454
  goto ldv_call_6;
#line 8456
  goto ldv_call_6;
#line 8458
  goto ldv_call_6;
#line 8460
  goto ldv_call_6;
#line 8462
  goto ldv_call_6;
#line 8464
  goto ldv_call_6;
#line 8466
  goto ldv_call_6;
#line 8468
  goto ldv_call_6;
#line 8470
  goto ldv_call_6;
#line 8472
  goto ldv_call_6;
#line 8474
  goto ldv_call_6;
#line 8476
  goto ldv_call_6;
#line 8478
  goto ldv_call_6;
#line 8480
  goto ldv_call_6;
#line 8482
  goto ldv_call_6;
#line 8484
  goto ldv_call_6;
#line 8486
  goto ldv_call_6;
#line 8488
  goto ldv_call_6;
#line 8490
  goto ldv_call_6;
#line 8492
  goto ldv_call_6;
#line 8494
  goto ldv_call_6;
#line 8496
  goto ldv_call_6;
#line 8498
  goto ldv_call_6;
#line 8500
  goto ldv_call_6;
#line 8502
  goto ldv_call_6;
#line 8504
  goto ldv_call_6;
#line 8506
  goto ldv_call_6;
#line 8508
  goto ldv_call_6;
#line 8510
  goto ldv_call_6;
#line 8512
  goto ldv_call_6;
#line 8514
  goto ldv_call_6;
#line 8516
  goto ldv_call_6;
#line 8518
  goto ldv_call_6;
#line 8520
  goto ldv_call_6;
#line 8522
  goto ldv_call_6;
#line 8524
  goto ldv_call_6;
#line 8526
  goto ldv_call_6;
#line 8528
  goto ldv_call_6;
#line 8530
  goto ldv_call_6;
#line 8532
  goto ldv_call_6;
#line 8534
  goto ldv_call_6;
#line 8536
  goto ldv_call_6;
#line 8538
  goto ldv_call_6;
#line 8540
  goto ldv_call_6;
#line 8542
  goto ldv_call_6;
#line 8544
  goto ldv_call_6;
  case_75: /* CIL Label */ 
  {
#line 8550
  ldv_dummy_resourceless_instance_callback_6_36(ldv_6_callback_get_ts_info, ldv_6_container_net_device,
                                                ldv_6_container_struct_ethtool_ts_info_ptr);
  }
#line 8557
  goto ldv_call_6;
#line 8559
  goto ldv_call_6;
#line 8561
  goto ldv_call_6;
#line 8563
  goto ldv_call_6;
#line 8565
  goto ldv_call_6;
#line 8567
  goto ldv_call_6;
#line 8569
  goto ldv_call_6;
#line 8571
  goto ldv_call_6;
#line 8573
  goto ldv_call_6;
#line 8575
  goto ldv_call_6;
#line 8577
  goto ldv_call_6;
#line 8579
  goto ldv_call_6;
#line 8581
  goto ldv_call_6;
#line 8583
  goto ldv_call_6;
#line 8585
  goto ldv_call_6;
#line 8587
  goto ldv_call_6;
#line 8589
  goto ldv_call_6;
#line 8591
  goto ldv_call_6;
#line 8593
  goto ldv_call_6;
#line 8595
  goto ldv_call_6;
#line 8597
  goto ldv_call_6;
#line 8599
  goto ldv_call_6;
#line 8601
  goto ldv_call_6;
#line 8603
  goto ldv_call_6;
#line 8605
  goto ldv_call_6;
#line 8607
  goto ldv_call_6;
#line 8609
  goto ldv_call_6;
#line 8611
  goto ldv_call_6;
#line 8613
  goto ldv_call_6;
#line 8615
  goto ldv_call_6;
#line 8617
  goto ldv_call_6;
#line 8619
  goto ldv_call_6;
#line 8621
  goto ldv_call_6;
#line 8623
  goto ldv_call_6;
#line 8625
  goto ldv_call_6;
#line 8627
  goto ldv_call_6;
#line 8629
  goto ldv_call_6;
#line 8631
  goto ldv_call_6;
#line 8633
  goto ldv_call_6;
#line 8635
  goto ldv_call_6;
#line 8637
  goto ldv_call_6;
#line 8639
  goto ldv_call_6;
#line 8641
  goto ldv_call_6;
#line 8643
  goto ldv_call_6;
#line 8645
  goto ldv_call_6;
#line 8647
  goto ldv_call_6;
#line 8649
  goto ldv_call_6;
#line 8651
  goto ldv_call_6;
#line 8653
  goto ldv_call_6;
#line 8655
  goto ldv_call_6;
#line 8657
  goto ldv_call_6;
#line 8659
  goto ldv_call_6;
#line 8661
  goto ldv_call_6;
#line 8663
  goto ldv_call_6;
#line 8665
  goto ldv_call_6;
#line 8667
  goto ldv_call_6;
#line 8669
  goto ldv_call_6;
#line 8671
  goto ldv_call_6;
#line 8673
  goto ldv_call_6;
#line 8675
  goto ldv_call_6;
#line 8677
  goto ldv_call_6;
#line 8679
  goto ldv_call_6;
#line 8681
  goto ldv_call_6;
#line 8683
  goto ldv_call_6;
#line 8685
  goto ldv_call_6;
#line 8687
  goto ldv_call_6;
#line 8689
  goto ldv_call_6;
#line 8691
  goto ldv_call_6;
#line 8693
  goto ldv_call_6;
#line 8695
  goto ldv_call_6;
#line 8697
  goto ldv_call_6;
#line 8699
  goto ldv_call_6;
#line 8701
  goto ldv_call_6;
#line 8703
  goto ldv_call_6;
#line 8705
  goto ldv_call_6;
  case_76: /* CIL Label */ 
  {
#line 8710
  tmp___21 = ldv_xmalloc(1UL);
#line 8710
  ldv_6_ldv_param_33_2_default = (unsigned char *)tmp___21;
#line 8715
  ldv_dummy_resourceless_instance_callback_6_33(ldv_6_callback_get_strings, ldv_6_container_net_device,
                                                ldv_6_ldv_param_33_1_default, ldv_6_ldv_param_33_2_default);
#line 8719
  ldv_free((void *)ldv_6_ldv_param_33_2_default);
  }
#line 8726
  goto ldv_call_6;
#line 8728
  goto ldv_call_6;
#line 8730
  goto ldv_call_6;
#line 8732
  goto ldv_call_6;
#line 8734
  goto ldv_call_6;
#line 8736
  goto ldv_call_6;
#line 8738
  goto ldv_call_6;
#line 8740
  goto ldv_call_6;
#line 8742
  goto ldv_call_6;
#line 8744
  goto ldv_call_6;
#line 8746
  goto ldv_call_6;
#line 8748
  goto ldv_call_6;
#line 8750
  goto ldv_call_6;
#line 8752
  goto ldv_call_6;
#line 8754
  goto ldv_call_6;
#line 8756
  goto ldv_call_6;
#line 8758
  goto ldv_call_6;
#line 8760
  goto ldv_call_6;
#line 8762
  goto ldv_call_6;
#line 8764
  goto ldv_call_6;
#line 8766
  goto ldv_call_6;
#line 8768
  goto ldv_call_6;
#line 8770
  goto ldv_call_6;
#line 8772
  goto ldv_call_6;
#line 8774
  goto ldv_call_6;
#line 8776
  goto ldv_call_6;
#line 8778
  goto ldv_call_6;
#line 8780
  goto ldv_call_6;
#line 8782
  goto ldv_call_6;
#line 8784
  goto ldv_call_6;
#line 8786
  goto ldv_call_6;
#line 8788
  goto ldv_call_6;
#line 8790
  goto ldv_call_6;
#line 8792
  goto ldv_call_6;
#line 8794
  goto ldv_call_6;
#line 8796
  goto ldv_call_6;
#line 8798
  goto ldv_call_6;
#line 8800
  goto ldv_call_6;
#line 8802
  goto ldv_call_6;
#line 8804
  goto ldv_call_6;
#line 8806
  goto ldv_call_6;
#line 8808
  goto ldv_call_6;
#line 8810
  goto ldv_call_6;
#line 8812
  goto ldv_call_6;
#line 8814
  goto ldv_call_6;
#line 8816
  goto ldv_call_6;
#line 8818
  goto ldv_call_6;
#line 8820
  goto ldv_call_6;
#line 8822
  goto ldv_call_6;
#line 8824
  goto ldv_call_6;
#line 8826
  goto ldv_call_6;
#line 8828
  goto ldv_call_6;
#line 8830
  goto ldv_call_6;
#line 8832
  goto ldv_call_6;
#line 8834
  goto ldv_call_6;
#line 8836
  goto ldv_call_6;
#line 8838
  goto ldv_call_6;
#line 8840
  goto ldv_call_6;
#line 8842
  goto ldv_call_6;
#line 8844
  goto ldv_call_6;
#line 8846
  goto ldv_call_6;
#line 8848
  goto ldv_call_6;
#line 8850
  goto ldv_call_6;
#line 8852
  goto ldv_call_6;
#line 8854
  goto ldv_call_6;
#line 8856
  goto ldv_call_6;
#line 8858
  goto ldv_call_6;
#line 8860
  goto ldv_call_6;
#line 8862
  goto ldv_call_6;
#line 8864
  goto ldv_call_6;
#line 8866
  goto ldv_call_6;
#line 8868
  goto ldv_call_6;
#line 8870
  goto ldv_call_6;
#line 8872
  goto ldv_call_6;
#line 8874
  goto ldv_call_6;
#line 8876
  goto ldv_call_6;
  case_77: /* CIL Label */ 
  {
#line 8885
  ldv_dummy_resourceless_instance_callback_6_30(ldv_6_callback_get_sset_count, ldv_6_container_net_device,
                                                ldv_6_ldv_param_30_1_default);
  }
#line 8895
  goto ldv_call_6;
#line 8897
  goto ldv_call_6;
#line 8899
  goto ldv_call_6;
#line 8901
  goto ldv_call_6;
#line 8903
  goto ldv_call_6;
#line 8905
  goto ldv_call_6;
#line 8907
  goto ldv_call_6;
#line 8909
  goto ldv_call_6;
#line 8911
  goto ldv_call_6;
#line 8913
  goto ldv_call_6;
#line 8915
  goto ldv_call_6;
#line 8917
  goto ldv_call_6;
#line 8919
  goto ldv_call_6;
#line 8921
  goto ldv_call_6;
#line 8923
  goto ldv_call_6;
#line 8925
  goto ldv_call_6;
#line 8927
  goto ldv_call_6;
#line 8929
  goto ldv_call_6;
#line 8931
  goto ldv_call_6;
#line 8933
  goto ldv_call_6;
#line 8935
  goto ldv_call_6;
#line 8937
  goto ldv_call_6;
#line 8939
  goto ldv_call_6;
#line 8941
  goto ldv_call_6;
#line 8943
  goto ldv_call_6;
#line 8945
  goto ldv_call_6;
#line 8947
  goto ldv_call_6;
#line 8949
  goto ldv_call_6;
#line 8951
  goto ldv_call_6;
#line 8953
  goto ldv_call_6;
#line 8955
  goto ldv_call_6;
#line 8957
  goto ldv_call_6;
#line 8959
  goto ldv_call_6;
#line 8961
  goto ldv_call_6;
#line 8963
  goto ldv_call_6;
#line 8965
  goto ldv_call_6;
#line 8967
  goto ldv_call_6;
#line 8969
  goto ldv_call_6;
#line 8971
  goto ldv_call_6;
#line 8973
  goto ldv_call_6;
#line 8975
  goto ldv_call_6;
#line 8977
  goto ldv_call_6;
#line 8979
  goto ldv_call_6;
#line 8981
  goto ldv_call_6;
#line 8983
  goto ldv_call_6;
#line 8985
  goto ldv_call_6;
#line 8987
  goto ldv_call_6;
#line 8989
  goto ldv_call_6;
#line 8991
  goto ldv_call_6;
#line 8993
  goto ldv_call_6;
#line 8995
  goto ldv_call_6;
#line 8997
  goto ldv_call_6;
#line 8999
  goto ldv_call_6;
#line 9001
  goto ldv_call_6;
#line 9003
  goto ldv_call_6;
#line 9005
  goto ldv_call_6;
#line 9007
  goto ldv_call_6;
#line 9009
  goto ldv_call_6;
#line 9011
  goto ldv_call_6;
#line 9013
  goto ldv_call_6;
#line 9015
  goto ldv_call_6;
#line 9017
  goto ldv_call_6;
#line 9019
  goto ldv_call_6;
#line 9021
  goto ldv_call_6;
#line 9023
  goto ldv_call_6;
#line 9025
  goto ldv_call_6;
#line 9027
  goto ldv_call_6;
#line 9029
  goto ldv_call_6;
#line 9031
  goto ldv_call_6;
#line 9033
  goto ldv_call_6;
#line 9035
  goto ldv_call_6;
#line 9037
  goto ldv_call_6;
#line 9039
  goto ldv_call_6;
#line 9041
  goto ldv_call_6;
#line 9043
  goto ldv_call_6;
#line 9045
  goto ldv_call_6;
#line 9047
  goto ldv_call_6;
  case_78: /* CIL Label */ 
  {
#line 9053
  ldv_dummy_resourceless_instance_callback_6_29(ldv_6_callback_get_settings, ldv_6_container_net_device,
                                                ldv_6_container_struct_ethtool_cmd_ptr);
  }
#line 9060
  goto ldv_call_6;
#line 9062
  goto ldv_call_6;
#line 9064
  goto ldv_call_6;
#line 9066
  goto ldv_call_6;
#line 9068
  goto ldv_call_6;
#line 9070
  goto ldv_call_6;
#line 9072
  goto ldv_call_6;
#line 9074
  goto ldv_call_6;
#line 9076
  goto ldv_call_6;
#line 9078
  goto ldv_call_6;
#line 9080
  goto ldv_call_6;
#line 9082
  goto ldv_call_6;
#line 9084
  goto ldv_call_6;
#line 9086
  goto ldv_call_6;
#line 9088
  goto ldv_call_6;
#line 9090
  goto ldv_call_6;
#line 9092
  goto ldv_call_6;
#line 9094
  goto ldv_call_6;
#line 9096
  goto ldv_call_6;
#line 9098
  goto ldv_call_6;
#line 9100
  goto ldv_call_6;
#line 9102
  goto ldv_call_6;
#line 9104
  goto ldv_call_6;
#line 9106
  goto ldv_call_6;
#line 9108
  goto ldv_call_6;
#line 9110
  goto ldv_call_6;
#line 9112
  goto ldv_call_6;
#line 9114
  goto ldv_call_6;
#line 9116
  goto ldv_call_6;
#line 9118
  goto ldv_call_6;
#line 9120
  goto ldv_call_6;
#line 9122
  goto ldv_call_6;
#line 9124
  goto ldv_call_6;
#line 9126
  goto ldv_call_6;
#line 9128
  goto ldv_call_6;
#line 9130
  goto ldv_call_6;
#line 9132
  goto ldv_call_6;
#line 9134
  goto ldv_call_6;
#line 9136
  goto ldv_call_6;
#line 9138
  goto ldv_call_6;
#line 9140
  goto ldv_call_6;
#line 9142
  goto ldv_call_6;
#line 9144
  goto ldv_call_6;
#line 9146
  goto ldv_call_6;
#line 9148
  goto ldv_call_6;
#line 9150
  goto ldv_call_6;
#line 9152
  goto ldv_call_6;
#line 9154
  goto ldv_call_6;
#line 9156
  goto ldv_call_6;
#line 9158
  goto ldv_call_6;
#line 9160
  goto ldv_call_6;
#line 9162
  goto ldv_call_6;
#line 9164
  goto ldv_call_6;
#line 9166
  goto ldv_call_6;
#line 9168
  goto ldv_call_6;
#line 9170
  goto ldv_call_6;
#line 9172
  goto ldv_call_6;
#line 9174
  goto ldv_call_6;
#line 9176
  goto ldv_call_6;
#line 9178
  goto ldv_call_6;
#line 9180
  goto ldv_call_6;
#line 9182
  goto ldv_call_6;
#line 9184
  goto ldv_call_6;
#line 9186
  goto ldv_call_6;
#line 9188
  goto ldv_call_6;
#line 9190
  goto ldv_call_6;
#line 9192
  goto ldv_call_6;
#line 9194
  goto ldv_call_6;
#line 9196
  goto ldv_call_6;
#line 9198
  goto ldv_call_6;
#line 9200
  goto ldv_call_6;
#line 9202
  goto ldv_call_6;
#line 9204
  goto ldv_call_6;
#line 9206
  goto ldv_call_6;
#line 9208
  goto ldv_call_6;
#line 9210
  goto ldv_call_6;
#line 9212
  goto ldv_call_6;
#line 9214
  goto ldv_call_6;
  case_79: /* CIL Label */ 
  {
#line 9219
  tmp___22 = ldv_xmalloc(4UL);
#line 9219
  ldv_6_ldv_param_26_2_default = (unsigned int *)tmp___22;
#line 9224
  ldv_dummy_resourceless_instance_callback_6_26(ldv_6_callback_get_rxnfc, ldv_6_container_net_device,
                                                ldv_6_container_struct_ethtool_rxnfc_ptr,
                                                ldv_6_ldv_param_26_2_default);
#line 9228
  ldv_free((void *)ldv_6_ldv_param_26_2_default);
  }
#line 9235
  goto ldv_call_6;
#line 9237
  goto ldv_call_6;
#line 9239
  goto ldv_call_6;
#line 9241
  goto ldv_call_6;
#line 9243
  goto ldv_call_6;
#line 9245
  goto ldv_call_6;
#line 9247
  goto ldv_call_6;
#line 9249
  goto ldv_call_6;
#line 9251
  goto ldv_call_6;
#line 9253
  goto ldv_call_6;
#line 9255
  goto ldv_call_6;
#line 9257
  goto ldv_call_6;
#line 9259
  goto ldv_call_6;
#line 9261
  goto ldv_call_6;
#line 9263
  goto ldv_call_6;
#line 9265
  goto ldv_call_6;
#line 9267
  goto ldv_call_6;
#line 9269
  goto ldv_call_6;
#line 9271
  goto ldv_call_6;
#line 9273
  goto ldv_call_6;
#line 9275
  goto ldv_call_6;
#line 9277
  goto ldv_call_6;
#line 9279
  goto ldv_call_6;
#line 9281
  goto ldv_call_6;
#line 9283
  goto ldv_call_6;
#line 9285
  goto ldv_call_6;
#line 9287
  goto ldv_call_6;
#line 9289
  goto ldv_call_6;
#line 9291
  goto ldv_call_6;
#line 9293
  goto ldv_call_6;
#line 9295
  goto ldv_call_6;
#line 9297
  goto ldv_call_6;
#line 9299
  goto ldv_call_6;
#line 9301
  goto ldv_call_6;
#line 9303
  goto ldv_call_6;
#line 9305
  goto ldv_call_6;
#line 9307
  goto ldv_call_6;
#line 9309
  goto ldv_call_6;
#line 9311
  goto ldv_call_6;
#line 9313
  goto ldv_call_6;
#line 9315
  goto ldv_call_6;
#line 9317
  goto ldv_call_6;
#line 9319
  goto ldv_call_6;
#line 9321
  goto ldv_call_6;
#line 9323
  goto ldv_call_6;
#line 9325
  goto ldv_call_6;
#line 9327
  goto ldv_call_6;
#line 9329
  goto ldv_call_6;
#line 9331
  goto ldv_call_6;
#line 9333
  goto ldv_call_6;
#line 9335
  goto ldv_call_6;
#line 9337
  goto ldv_call_6;
#line 9339
  goto ldv_call_6;
#line 9341
  goto ldv_call_6;
#line 9343
  goto ldv_call_6;
#line 9345
  goto ldv_call_6;
#line 9347
  goto ldv_call_6;
#line 9349
  goto ldv_call_6;
#line 9351
  goto ldv_call_6;
#line 9353
  goto ldv_call_6;
#line 9355
  goto ldv_call_6;
#line 9357
  goto ldv_call_6;
#line 9359
  goto ldv_call_6;
#line 9361
  goto ldv_call_6;
#line 9363
  goto ldv_call_6;
#line 9365
  goto ldv_call_6;
#line 9367
  goto ldv_call_6;
#line 9369
  goto ldv_call_6;
#line 9371
  goto ldv_call_6;
#line 9373
  goto ldv_call_6;
#line 9375
  goto ldv_call_6;
#line 9377
  goto ldv_call_6;
#line 9379
  goto ldv_call_6;
#line 9381
  goto ldv_call_6;
#line 9383
  goto ldv_call_6;
#line 9385
  goto ldv_call_6;
#line 9387
  goto ldv_call_6;
#line 9389
  goto ldv_call_6;
#line 9391
  goto ldv_call_6;
  case_80: /* CIL Label */ 
  {
#line 9397
  ldv_dummy_resourceless_instance_callback_6_25(ldv_6_callback_get_ringparam, ldv_6_container_net_device,
                                                ldv_6_container_struct_ethtool_ringparam_ptr);
  }
#line 9404
  goto ldv_call_6;
#line 9406
  goto ldv_call_6;
#line 9408
  goto ldv_call_6;
#line 9410
  goto ldv_call_6;
#line 9412
  goto ldv_call_6;
#line 9414
  goto ldv_call_6;
#line 9416
  goto ldv_call_6;
#line 9418
  goto ldv_call_6;
#line 9420
  goto ldv_call_6;
#line 9422
  goto ldv_call_6;
#line 9424
  goto ldv_call_6;
#line 9426
  goto ldv_call_6;
#line 9428
  goto ldv_call_6;
#line 9430
  goto ldv_call_6;
#line 9432
  goto ldv_call_6;
#line 9434
  goto ldv_call_6;
#line 9436
  goto ldv_call_6;
#line 9438
  goto ldv_call_6;
#line 9440
  goto ldv_call_6;
#line 9442
  goto ldv_call_6;
#line 9444
  goto ldv_call_6;
#line 9446
  goto ldv_call_6;
#line 9448
  goto ldv_call_6;
#line 9450
  goto ldv_call_6;
#line 9452
  goto ldv_call_6;
#line 9454
  goto ldv_call_6;
#line 9456
  goto ldv_call_6;
#line 9458
  goto ldv_call_6;
#line 9460
  goto ldv_call_6;
#line 9462
  goto ldv_call_6;
#line 9464
  goto ldv_call_6;
#line 9466
  goto ldv_call_6;
#line 9468
  goto ldv_call_6;
#line 9470
  goto ldv_call_6;
#line 9472
  goto ldv_call_6;
#line 9474
  goto ldv_call_6;
#line 9476
  goto ldv_call_6;
#line 9478
  goto ldv_call_6;
#line 9480
  goto ldv_call_6;
#line 9482
  goto ldv_call_6;
#line 9484
  goto ldv_call_6;
#line 9486
  goto ldv_call_6;
#line 9488
  goto ldv_call_6;
#line 9490
  goto ldv_call_6;
#line 9492
  goto ldv_call_6;
#line 9494
  goto ldv_call_6;
#line 9496
  goto ldv_call_6;
#line 9498
  goto ldv_call_6;
#line 9500
  goto ldv_call_6;
#line 9502
  goto ldv_call_6;
#line 9504
  goto ldv_call_6;
#line 9506
  goto ldv_call_6;
#line 9508
  goto ldv_call_6;
#line 9510
  goto ldv_call_6;
#line 9512
  goto ldv_call_6;
#line 9514
  goto ldv_call_6;
#line 9516
  goto ldv_call_6;
#line 9518
  goto ldv_call_6;
#line 9520
  goto ldv_call_6;
#line 9522
  goto ldv_call_6;
#line 9524
  goto ldv_call_6;
#line 9526
  goto ldv_call_6;
#line 9528
  goto ldv_call_6;
#line 9530
  goto ldv_call_6;
#line 9532
  goto ldv_call_6;
#line 9534
  goto ldv_call_6;
#line 9536
  goto ldv_call_6;
#line 9538
  goto ldv_call_6;
#line 9540
  goto ldv_call_6;
#line 9542
  goto ldv_call_6;
#line 9544
  goto ldv_call_6;
#line 9546
  goto ldv_call_6;
#line 9548
  goto ldv_call_6;
#line 9550
  goto ldv_call_6;
#line 9552
  goto ldv_call_6;
#line 9554
  goto ldv_call_6;
#line 9556
  goto ldv_call_6;
#line 9558
  goto ldv_call_6;
#line 9560
  goto ldv_call_6;
#line 9562
  goto ldv_call_6;
  case_81: /* CIL Label */ 
  {
#line 9568
  ldv_dummy_resourceless_instance_callback_6_24(ldv_6_callback_get_regs_len, ldv_6_container_net_device);
  }
#line 9575
  goto ldv_call_6;
#line 9577
  goto ldv_call_6;
#line 9579
  goto ldv_call_6;
#line 9581
  goto ldv_call_6;
#line 9583
  goto ldv_call_6;
#line 9585
  goto ldv_call_6;
#line 9587
  goto ldv_call_6;
#line 9589
  goto ldv_call_6;
#line 9591
  goto ldv_call_6;
#line 9593
  goto ldv_call_6;
#line 9595
  goto ldv_call_6;
#line 9597
  goto ldv_call_6;
#line 9599
  goto ldv_call_6;
#line 9601
  goto ldv_call_6;
#line 9603
  goto ldv_call_6;
#line 9605
  goto ldv_call_6;
#line 9607
  goto ldv_call_6;
#line 9609
  goto ldv_call_6;
#line 9611
  goto ldv_call_6;
#line 9613
  goto ldv_call_6;
#line 9615
  goto ldv_call_6;
#line 9617
  goto ldv_call_6;
#line 9619
  goto ldv_call_6;
#line 9621
  goto ldv_call_6;
#line 9623
  goto ldv_call_6;
#line 9625
  goto ldv_call_6;
#line 9627
  goto ldv_call_6;
#line 9629
  goto ldv_call_6;
#line 9631
  goto ldv_call_6;
#line 9633
  goto ldv_call_6;
#line 9635
  goto ldv_call_6;
#line 9637
  goto ldv_call_6;
#line 9639
  goto ldv_call_6;
#line 9641
  goto ldv_call_6;
#line 9643
  goto ldv_call_6;
#line 9645
  goto ldv_call_6;
#line 9647
  goto ldv_call_6;
#line 9649
  goto ldv_call_6;
#line 9651
  goto ldv_call_6;
#line 9653
  goto ldv_call_6;
#line 9655
  goto ldv_call_6;
#line 9657
  goto ldv_call_6;
#line 9659
  goto ldv_call_6;
#line 9661
  goto ldv_call_6;
#line 9663
  goto ldv_call_6;
#line 9665
  goto ldv_call_6;
#line 9667
  goto ldv_call_6;
#line 9669
  goto ldv_call_6;
#line 9671
  goto ldv_call_6;
#line 9673
  goto ldv_call_6;
#line 9675
  goto ldv_call_6;
#line 9677
  goto ldv_call_6;
#line 9679
  goto ldv_call_6;
#line 9681
  goto ldv_call_6;
#line 9683
  goto ldv_call_6;
#line 9685
  goto ldv_call_6;
#line 9687
  goto ldv_call_6;
#line 9689
  goto ldv_call_6;
#line 9691
  goto ldv_call_6;
#line 9693
  goto ldv_call_6;
#line 9695
  goto ldv_call_6;
#line 9697
  goto ldv_call_6;
#line 9699
  goto ldv_call_6;
#line 9701
  goto ldv_call_6;
#line 9703
  goto ldv_call_6;
#line 9705
  goto ldv_call_6;
#line 9707
  goto ldv_call_6;
#line 9709
  goto ldv_call_6;
#line 9711
  goto ldv_call_6;
#line 9713
  goto ldv_call_6;
#line 9715
  goto ldv_call_6;
#line 9717
  goto ldv_call_6;
#line 9719
  goto ldv_call_6;
#line 9721
  goto ldv_call_6;
#line 9723
  goto ldv_call_6;
#line 9725
  goto ldv_call_6;
#line 9727
  goto ldv_call_6;
#line 9729
  goto ldv_call_6;
#line 9731
  goto ldv_call_6;
#line 9733
  goto ldv_call_6;
#line 9735
  goto ldv_call_6;
  case_82: /* CIL Label */ 
  {
#line 9741
  ldv_dummy_resourceless_instance_callback_6_23(ldv_6_callback_get_regs, ldv_6_container_net_device,
                                                ldv_6_container_struct_ethtool_regs_ptr,
                                                (void *)ldv_6_container_func_2_ptr);
  }
#line 9748
  goto ldv_call_6;
#line 9750
  goto ldv_call_6;
#line 9752
  goto ldv_call_6;
#line 9754
  goto ldv_call_6;
#line 9756
  goto ldv_call_6;
#line 9758
  goto ldv_call_6;
#line 9760
  goto ldv_call_6;
#line 9762
  goto ldv_call_6;
#line 9764
  goto ldv_call_6;
#line 9766
  goto ldv_call_6;
#line 9768
  goto ldv_call_6;
#line 9770
  goto ldv_call_6;
#line 9772
  goto ldv_call_6;
#line 9774
  goto ldv_call_6;
#line 9776
  goto ldv_call_6;
#line 9778
  goto ldv_call_6;
#line 9780
  goto ldv_call_6;
#line 9782
  goto ldv_call_6;
#line 9784
  goto ldv_call_6;
#line 9786
  goto ldv_call_6;
#line 9788
  goto ldv_call_6;
#line 9790
  goto ldv_call_6;
#line 9792
  goto ldv_call_6;
#line 9794
  goto ldv_call_6;
#line 9796
  goto ldv_call_6;
#line 9798
  goto ldv_call_6;
#line 9800
  goto ldv_call_6;
#line 9802
  goto ldv_call_6;
#line 9804
  goto ldv_call_6;
#line 9806
  goto ldv_call_6;
#line 9808
  goto ldv_call_6;
#line 9810
  goto ldv_call_6;
#line 9812
  goto ldv_call_6;
#line 9814
  goto ldv_call_6;
#line 9816
  goto ldv_call_6;
#line 9818
  goto ldv_call_6;
#line 9820
  goto ldv_call_6;
#line 9822
  goto ldv_call_6;
#line 9824
  goto ldv_call_6;
#line 9826
  goto ldv_call_6;
#line 9828
  goto ldv_call_6;
#line 9830
  goto ldv_call_6;
#line 9832
  goto ldv_call_6;
#line 9834
  goto ldv_call_6;
#line 9836
  goto ldv_call_6;
#line 9838
  goto ldv_call_6;
#line 9840
  goto ldv_call_6;
#line 9842
  goto ldv_call_6;
#line 9844
  goto ldv_call_6;
#line 9846
  goto ldv_call_6;
#line 9848
  goto ldv_call_6;
#line 9850
  goto ldv_call_6;
#line 9852
  goto ldv_call_6;
#line 9854
  goto ldv_call_6;
#line 9856
  goto ldv_call_6;
#line 9858
  goto ldv_call_6;
#line 9860
  goto ldv_call_6;
#line 9862
  goto ldv_call_6;
#line 9864
  goto ldv_call_6;
#line 9866
  goto ldv_call_6;
#line 9868
  goto ldv_call_6;
#line 9870
  goto ldv_call_6;
#line 9872
  goto ldv_call_6;
#line 9874
  goto ldv_call_6;
#line 9876
  goto ldv_call_6;
#line 9878
  goto ldv_call_6;
#line 9880
  goto ldv_call_6;
#line 9882
  goto ldv_call_6;
#line 9884
  goto ldv_call_6;
#line 9886
  goto ldv_call_6;
#line 9888
  goto ldv_call_6;
#line 9890
  goto ldv_call_6;
#line 9892
  goto ldv_call_6;
#line 9894
  goto ldv_call_6;
#line 9896
  goto ldv_call_6;
#line 9898
  goto ldv_call_6;
#line 9900
  goto ldv_call_6;
#line 9902
  goto ldv_call_6;
#line 9904
  goto ldv_call_6;
#line 9906
  goto ldv_call_6;
#line 9908
  goto ldv_call_6;
#line 9910
  goto ldv_call_6;
  case_83: /* CIL Label */ 
  {
#line 9916
  ldv_dummy_resourceless_instance_callback_6_22(ldv_6_callback_get_pauseparam, ldv_6_container_net_device,
                                                ldv_6_container_struct_ethtool_pauseparam_ptr);
  }
#line 9923
  goto ldv_call_6;
#line 9925
  goto ldv_call_6;
#line 9927
  goto ldv_call_6;
#line 9929
  goto ldv_call_6;
#line 9931
  goto ldv_call_6;
#line 9933
  goto ldv_call_6;
#line 9935
  goto ldv_call_6;
#line 9937
  goto ldv_call_6;
#line 9939
  goto ldv_call_6;
#line 9941
  goto ldv_call_6;
#line 9943
  goto ldv_call_6;
#line 9945
  goto ldv_call_6;
#line 9947
  goto ldv_call_6;
#line 9949
  goto ldv_call_6;
#line 9951
  goto ldv_call_6;
#line 9953
  goto ldv_call_6;
#line 9955
  goto ldv_call_6;
#line 9957
  goto ldv_call_6;
#line 9959
  goto ldv_call_6;
#line 9961
  goto ldv_call_6;
#line 9963
  goto ldv_call_6;
#line 9965
  goto ldv_call_6;
#line 9967
  goto ldv_call_6;
#line 9969
  goto ldv_call_6;
#line 9971
  goto ldv_call_6;
#line 9973
  goto ldv_call_6;
#line 9975
  goto ldv_call_6;
#line 9977
  goto ldv_call_6;
#line 9979
  goto ldv_call_6;
#line 9981
  goto ldv_call_6;
#line 9983
  goto ldv_call_6;
#line 9985
  goto ldv_call_6;
#line 9987
  goto ldv_call_6;
#line 9989
  goto ldv_call_6;
#line 9991
  goto ldv_call_6;
#line 9993
  goto ldv_call_6;
#line 9995
  goto ldv_call_6;
#line 9997
  goto ldv_call_6;
#line 9999
  goto ldv_call_6;
#line 10001
  goto ldv_call_6;
#line 10003
  goto ldv_call_6;
#line 10005
  goto ldv_call_6;
#line 10007
  goto ldv_call_6;
#line 10009
  goto ldv_call_6;
#line 10011
  goto ldv_call_6;
#line 10013
  goto ldv_call_6;
#line 10015
  goto ldv_call_6;
#line 10017
  goto ldv_call_6;
#line 10019
  goto ldv_call_6;
#line 10021
  goto ldv_call_6;
#line 10023
  goto ldv_call_6;
#line 10025
  goto ldv_call_6;
#line 10027
  goto ldv_call_6;
#line 10029
  goto ldv_call_6;
#line 10031
  goto ldv_call_6;
#line 10033
  goto ldv_call_6;
#line 10035
  goto ldv_call_6;
#line 10037
  goto ldv_call_6;
#line 10039
  goto ldv_call_6;
#line 10041
  goto ldv_call_6;
#line 10043
  goto ldv_call_6;
#line 10045
  goto ldv_call_6;
#line 10047
  goto ldv_call_6;
#line 10049
  goto ldv_call_6;
#line 10051
  goto ldv_call_6;
#line 10053
  goto ldv_call_6;
#line 10055
  goto ldv_call_6;
#line 10057
  goto ldv_call_6;
#line 10059
  goto ldv_call_6;
#line 10061
  goto ldv_call_6;
#line 10063
  goto ldv_call_6;
#line 10065
  goto ldv_call_6;
#line 10067
  goto ldv_call_6;
#line 10069
  goto ldv_call_6;
#line 10071
  goto ldv_call_6;
#line 10073
  goto ldv_call_6;
#line 10075
  goto ldv_call_6;
#line 10077
  goto ldv_call_6;
#line 10079
  goto ldv_call_6;
#line 10081
  goto ldv_call_6;
#line 10083
  goto ldv_call_6;
#line 10085
  goto ldv_call_6;
#line 10087
  goto ldv_call_6;
  case_84: /* CIL Label */ 
  {
#line 10093
  ldv_dummy_resourceless_instance_callback_6_21(ldv_6_callback_get_msglevel, ldv_6_container_net_device);
  }
#line 10100
  goto ldv_call_6;
#line 10102
  goto ldv_call_6;
#line 10104
  goto ldv_call_6;
#line 10106
  goto ldv_call_6;
#line 10108
  goto ldv_call_6;
#line 10110
  goto ldv_call_6;
#line 10112
  goto ldv_call_6;
#line 10114
  goto ldv_call_6;
#line 10116
  goto ldv_call_6;
#line 10118
  goto ldv_call_6;
#line 10120
  goto ldv_call_6;
#line 10122
  goto ldv_call_6;
#line 10124
  goto ldv_call_6;
#line 10126
  goto ldv_call_6;
#line 10128
  goto ldv_call_6;
#line 10130
  goto ldv_call_6;
#line 10132
  goto ldv_call_6;
#line 10134
  goto ldv_call_6;
#line 10136
  goto ldv_call_6;
#line 10138
  goto ldv_call_6;
#line 10140
  goto ldv_call_6;
#line 10142
  goto ldv_call_6;
#line 10144
  goto ldv_call_6;
#line 10146
  goto ldv_call_6;
#line 10148
  goto ldv_call_6;
#line 10150
  goto ldv_call_6;
#line 10152
  goto ldv_call_6;
#line 10154
  goto ldv_call_6;
#line 10156
  goto ldv_call_6;
#line 10158
  goto ldv_call_6;
#line 10160
  goto ldv_call_6;
#line 10162
  goto ldv_call_6;
#line 10164
  goto ldv_call_6;
#line 10166
  goto ldv_call_6;
#line 10168
  goto ldv_call_6;
#line 10170
  goto ldv_call_6;
#line 10172
  goto ldv_call_6;
#line 10174
  goto ldv_call_6;
#line 10176
  goto ldv_call_6;
#line 10178
  goto ldv_call_6;
#line 10180
  goto ldv_call_6;
#line 10182
  goto ldv_call_6;
#line 10184
  goto ldv_call_6;
#line 10186
  goto ldv_call_6;
#line 10188
  goto ldv_call_6;
#line 10190
  goto ldv_call_6;
#line 10192
  goto ldv_call_6;
#line 10194
  goto ldv_call_6;
#line 10196
  goto ldv_call_6;
#line 10198
  goto ldv_call_6;
#line 10200
  goto ldv_call_6;
#line 10202
  goto ldv_call_6;
#line 10204
  goto ldv_call_6;
#line 10206
  goto ldv_call_6;
#line 10208
  goto ldv_call_6;
#line 10210
  goto ldv_call_6;
#line 10212
  goto ldv_call_6;
#line 10214
  goto ldv_call_6;
#line 10216
  goto ldv_call_6;
#line 10218
  goto ldv_call_6;
#line 10220
  goto ldv_call_6;
#line 10222
  goto ldv_call_6;
#line 10224
  goto ldv_call_6;
#line 10226
  goto ldv_call_6;
#line 10228
  goto ldv_call_6;
#line 10230
  goto ldv_call_6;
#line 10232
  goto ldv_call_6;
#line 10234
  goto ldv_call_6;
#line 10236
  goto ldv_call_6;
#line 10238
  goto ldv_call_6;
#line 10240
  goto ldv_call_6;
#line 10242
  goto ldv_call_6;
#line 10244
  goto ldv_call_6;
#line 10246
  goto ldv_call_6;
#line 10248
  goto ldv_call_6;
#line 10250
  goto ldv_call_6;
#line 10252
  goto ldv_call_6;
#line 10254
  goto ldv_call_6;
#line 10256
  goto ldv_call_6;
#line 10258
  goto ldv_call_6;
#line 10260
  goto ldv_call_6;
#line 10262
  goto ldv_call_6;
#line 10264
  goto ldv_call_6;
#line 10266
  goto ldv_call_6;
  case_85: /* CIL Label */ 
  {
#line 10272
  ldv_dummy_resourceless_instance_callback_6_20(ldv_6_callback_get_module_info, ldv_6_container_net_device,
                                                ldv_6_container_struct_ethtool_modinfo_ptr);
  }
#line 10279
  goto ldv_call_6;
#line 10281
  goto ldv_call_6;
#line 10283
  goto ldv_call_6;
#line 10285
  goto ldv_call_6;
#line 10287
  goto ldv_call_6;
#line 10289
  goto ldv_call_6;
#line 10291
  goto ldv_call_6;
#line 10293
  goto ldv_call_6;
#line 10295
  goto ldv_call_6;
#line 10297
  goto ldv_call_6;
#line 10299
  goto ldv_call_6;
#line 10301
  goto ldv_call_6;
#line 10303
  goto ldv_call_6;
#line 10305
  goto ldv_call_6;
#line 10307
  goto ldv_call_6;
#line 10309
  goto ldv_call_6;
#line 10311
  goto ldv_call_6;
#line 10313
  goto ldv_call_6;
#line 10315
  goto ldv_call_6;
#line 10317
  goto ldv_call_6;
#line 10319
  goto ldv_call_6;
#line 10321
  goto ldv_call_6;
#line 10323
  goto ldv_call_6;
#line 10325
  goto ldv_call_6;
#line 10327
  goto ldv_call_6;
#line 10329
  goto ldv_call_6;
#line 10331
  goto ldv_call_6;
#line 10333
  goto ldv_call_6;
#line 10335
  goto ldv_call_6;
#line 10337
  goto ldv_call_6;
#line 10339
  goto ldv_call_6;
#line 10341
  goto ldv_call_6;
#line 10343
  goto ldv_call_6;
#line 10345
  goto ldv_call_6;
#line 10347
  goto ldv_call_6;
#line 10349
  goto ldv_call_6;
#line 10351
  goto ldv_call_6;
#line 10353
  goto ldv_call_6;
#line 10355
  goto ldv_call_6;
#line 10357
  goto ldv_call_6;
#line 10359
  goto ldv_call_6;
#line 10361
  goto ldv_call_6;
#line 10363
  goto ldv_call_6;
#line 10365
  goto ldv_call_6;
#line 10367
  goto ldv_call_6;
#line 10369
  goto ldv_call_6;
#line 10371
  goto ldv_call_6;
#line 10373
  goto ldv_call_6;
#line 10375
  goto ldv_call_6;
#line 10377
  goto ldv_call_6;
#line 10379
  goto ldv_call_6;
#line 10381
  goto ldv_call_6;
#line 10383
  goto ldv_call_6;
#line 10385
  goto ldv_call_6;
#line 10387
  goto ldv_call_6;
#line 10389
  goto ldv_call_6;
#line 10391
  goto ldv_call_6;
#line 10393
  goto ldv_call_6;
#line 10395
  goto ldv_call_6;
#line 10397
  goto ldv_call_6;
#line 10399
  goto ldv_call_6;
#line 10401
  goto ldv_call_6;
#line 10403
  goto ldv_call_6;
#line 10405
  goto ldv_call_6;
#line 10407
  goto ldv_call_6;
#line 10409
  goto ldv_call_6;
#line 10411
  goto ldv_call_6;
#line 10413
  goto ldv_call_6;
#line 10415
  goto ldv_call_6;
#line 10417
  goto ldv_call_6;
#line 10419
  goto ldv_call_6;
#line 10421
  goto ldv_call_6;
#line 10423
  goto ldv_call_6;
#line 10425
  goto ldv_call_6;
#line 10427
  goto ldv_call_6;
#line 10429
  goto ldv_call_6;
#line 10431
  goto ldv_call_6;
#line 10433
  goto ldv_call_6;
#line 10435
  goto ldv_call_6;
#line 10437
  goto ldv_call_6;
#line 10439
  goto ldv_call_6;
#line 10441
  goto ldv_call_6;
#line 10443
  goto ldv_call_6;
#line 10445
  goto ldv_call_6;
#line 10447
  goto ldv_call_6;
  case_86: /* CIL Label */ 
  {
#line 10452
  tmp___23 = ldv_xmalloc(1UL);
#line 10452
  ldv_6_ldv_param_17_2_default = (unsigned char *)tmp___23;
#line 10457
  ldv_dummy_resourceless_instance_callback_6_17(ldv_6_callback_get_module_eeprom,
                                                ldv_6_container_net_device, ldv_6_container_struct_ethtool_eeprom_ptr,
                                                ldv_6_ldv_param_17_2_default);
#line 10461
  ldv_free((void *)ldv_6_ldv_param_17_2_default);
  }
#line 10468
  goto ldv_call_6;
#line 10470
  goto ldv_call_6;
#line 10472
  goto ldv_call_6;
#line 10474
  goto ldv_call_6;
#line 10476
  goto ldv_call_6;
#line 10478
  goto ldv_call_6;
#line 10480
  goto ldv_call_6;
#line 10482
  goto ldv_call_6;
#line 10484
  goto ldv_call_6;
#line 10486
  goto ldv_call_6;
#line 10488
  goto ldv_call_6;
#line 10490
  goto ldv_call_6;
#line 10492
  goto ldv_call_6;
#line 10494
  goto ldv_call_6;
#line 10496
  goto ldv_call_6;
#line 10498
  goto ldv_call_6;
#line 10500
  goto ldv_call_6;
#line 10502
  goto ldv_call_6;
#line 10504
  goto ldv_call_6;
#line 10506
  goto ldv_call_6;
#line 10508
  goto ldv_call_6;
#line 10510
  goto ldv_call_6;
#line 10512
  goto ldv_call_6;
#line 10514
  goto ldv_call_6;
#line 10516
  goto ldv_call_6;
#line 10518
  goto ldv_call_6;
#line 10520
  goto ldv_call_6;
#line 10522
  goto ldv_call_6;
#line 10524
  goto ldv_call_6;
#line 10526
  goto ldv_call_6;
#line 10528
  goto ldv_call_6;
#line 10530
  goto ldv_call_6;
#line 10532
  goto ldv_call_6;
#line 10534
  goto ldv_call_6;
#line 10536
  goto ldv_call_6;
#line 10538
  goto ldv_call_6;
#line 10540
  goto ldv_call_6;
#line 10542
  goto ldv_call_6;
#line 10544
  goto ldv_call_6;
#line 10546
  goto ldv_call_6;
#line 10548
  goto ldv_call_6;
#line 10550
  goto ldv_call_6;
#line 10552
  goto ldv_call_6;
#line 10554
  goto ldv_call_6;
#line 10556
  goto ldv_call_6;
#line 10558
  goto ldv_call_6;
#line 10560
  goto ldv_call_6;
#line 10562
  goto ldv_call_6;
#line 10564
  goto ldv_call_6;
#line 10566
  goto ldv_call_6;
#line 10568
  goto ldv_call_6;
#line 10570
  goto ldv_call_6;
#line 10572
  goto ldv_call_6;
#line 10574
  goto ldv_call_6;
#line 10576
  goto ldv_call_6;
#line 10578
  goto ldv_call_6;
#line 10580
  goto ldv_call_6;
#line 10582
  goto ldv_call_6;
#line 10584
  goto ldv_call_6;
#line 10586
  goto ldv_call_6;
#line 10588
  goto ldv_call_6;
#line 10590
  goto ldv_call_6;
#line 10592
  goto ldv_call_6;
#line 10594
  goto ldv_call_6;
#line 10596
  goto ldv_call_6;
#line 10598
  goto ldv_call_6;
#line 10600
  goto ldv_call_6;
#line 10602
  goto ldv_call_6;
#line 10604
  goto ldv_call_6;
#line 10606
  goto ldv_call_6;
#line 10608
  goto ldv_call_6;
#line 10610
  goto ldv_call_6;
#line 10612
  goto ldv_call_6;
#line 10614
  goto ldv_call_6;
#line 10616
  goto ldv_call_6;
#line 10618
  goto ldv_call_6;
#line 10620
  goto ldv_call_6;
#line 10622
  goto ldv_call_6;
#line 10624
  goto ldv_call_6;
#line 10626
  goto ldv_call_6;
#line 10628
  goto ldv_call_6;
#line 10630
  goto ldv_call_6;
#line 10632
  goto ldv_call_6;
#line 10634
  goto ldv_call_6;
#line 10636
  goto ldv_call_6;
#line 10638
  goto ldv_call_6;
  case_87: /* CIL Label */ 
  {
#line 10644
  ldv_dummy_resourceless_instance_callback_6_16(ldv_6_callback_get_link, ldv_6_container_net_device);
  }
#line 10651
  goto ldv_call_6;
#line 10653
  goto ldv_call_6;
#line 10655
  goto ldv_call_6;
#line 10657
  goto ldv_call_6;
#line 10659
  goto ldv_call_6;
#line 10661
  goto ldv_call_6;
#line 10663
  goto ldv_call_6;
#line 10665
  goto ldv_call_6;
#line 10667
  goto ldv_call_6;
#line 10669
  goto ldv_call_6;
#line 10671
  goto ldv_call_6;
#line 10673
  goto ldv_call_6;
#line 10675
  goto ldv_call_6;
#line 10677
  goto ldv_call_6;
#line 10679
  goto ldv_call_6;
#line 10681
  goto ldv_call_6;
#line 10683
  goto ldv_call_6;
#line 10685
  goto ldv_call_6;
#line 10687
  goto ldv_call_6;
#line 10689
  goto ldv_call_6;
#line 10691
  goto ldv_call_6;
#line 10693
  goto ldv_call_6;
#line 10695
  goto ldv_call_6;
#line 10697
  goto ldv_call_6;
#line 10699
  goto ldv_call_6;
#line 10701
  goto ldv_call_6;
#line 10703
  goto ldv_call_6;
#line 10705
  goto ldv_call_6;
#line 10707
  goto ldv_call_6;
#line 10709
  goto ldv_call_6;
#line 10711
  goto ldv_call_6;
#line 10713
  goto ldv_call_6;
#line 10715
  goto ldv_call_6;
#line 10717
  goto ldv_call_6;
#line 10719
  goto ldv_call_6;
#line 10721
  goto ldv_call_6;
#line 10723
  goto ldv_call_6;
#line 10725
  goto ldv_call_6;
#line 10727
  goto ldv_call_6;
#line 10729
  goto ldv_call_6;
#line 10731
  goto ldv_call_6;
#line 10733
  goto ldv_call_6;
#line 10735
  goto ldv_call_6;
#line 10737
  goto ldv_call_6;
#line 10739
  goto ldv_call_6;
#line 10741
  goto ldv_call_6;
#line 10743
  goto ldv_call_6;
#line 10745
  goto ldv_call_6;
#line 10747
  goto ldv_call_6;
#line 10749
  goto ldv_call_6;
#line 10751
  goto ldv_call_6;
#line 10753
  goto ldv_call_6;
#line 10755
  goto ldv_call_6;
#line 10757
  goto ldv_call_6;
#line 10759
  goto ldv_call_6;
#line 10761
  goto ldv_call_6;
#line 10763
  goto ldv_call_6;
#line 10765
  goto ldv_call_6;
#line 10767
  goto ldv_call_6;
#line 10769
  goto ldv_call_6;
#line 10771
  goto ldv_call_6;
#line 10773
  goto ldv_call_6;
#line 10775
  goto ldv_call_6;
#line 10777
  goto ldv_call_6;
#line 10779
  goto ldv_call_6;
#line 10781
  goto ldv_call_6;
#line 10783
  goto ldv_call_6;
#line 10785
  goto ldv_call_6;
#line 10787
  goto ldv_call_6;
#line 10789
  goto ldv_call_6;
#line 10791
  goto ldv_call_6;
#line 10793
  goto ldv_call_6;
#line 10795
  goto ldv_call_6;
#line 10797
  goto ldv_call_6;
#line 10799
  goto ldv_call_6;
#line 10801
  goto ldv_call_6;
#line 10803
  goto ldv_call_6;
#line 10805
  goto ldv_call_6;
#line 10807
  goto ldv_call_6;
#line 10809
  goto ldv_call_6;
#line 10811
  goto ldv_call_6;
#line 10813
  goto ldv_call_6;
#line 10815
  goto ldv_call_6;
#line 10817
  goto ldv_call_6;
#line 10819
  goto ldv_call_6;
#line 10821
  goto ldv_call_6;
#line 10823
  goto ldv_call_6;
  case_88: /* CIL Label */ 
  {
#line 10828
  tmp___24 = ldv_xmalloc(8UL);
#line 10828
  ldv_6_ldv_param_13_2_default = (unsigned long long *)tmp___24;
#line 10833
  ldv_dummy_resourceless_instance_callback_6_13(ldv_6_callback_get_ethtool_stats,
                                                ldv_6_container_net_device, ldv_6_container_struct_ethtool_stats_ptr,
                                                ldv_6_ldv_param_13_2_default);
#line 10837
  ldv_free((void *)ldv_6_ldv_param_13_2_default);
  }
#line 10844
  goto ldv_call_6;
#line 10846
  goto ldv_call_6;
#line 10848
  goto ldv_call_6;
#line 10850
  goto ldv_call_6;
#line 10852
  goto ldv_call_6;
#line 10854
  goto ldv_call_6;
#line 10856
  goto ldv_call_6;
#line 10858
  goto ldv_call_6;
#line 10860
  goto ldv_call_6;
#line 10862
  goto ldv_call_6;
#line 10864
  goto ldv_call_6;
#line 10866
  goto ldv_call_6;
#line 10868
  goto ldv_call_6;
#line 10870
  goto ldv_call_6;
#line 10872
  goto ldv_call_6;
#line 10874
  goto ldv_call_6;
#line 10876
  goto ldv_call_6;
#line 10878
  goto ldv_call_6;
#line 10880
  goto ldv_call_6;
#line 10882
  goto ldv_call_6;
#line 10884
  goto ldv_call_6;
#line 10886
  goto ldv_call_6;
#line 10888
  goto ldv_call_6;
#line 10890
  goto ldv_call_6;
#line 10892
  goto ldv_call_6;
#line 10894
  goto ldv_call_6;
#line 10896
  goto ldv_call_6;
#line 10898
  goto ldv_call_6;
#line 10900
  goto ldv_call_6;
#line 10902
  goto ldv_call_6;
#line 10904
  goto ldv_call_6;
#line 10906
  goto ldv_call_6;
#line 10908
  goto ldv_call_6;
#line 10910
  goto ldv_call_6;
#line 10912
  goto ldv_call_6;
#line 10914
  goto ldv_call_6;
#line 10916
  goto ldv_call_6;
#line 10918
  goto ldv_call_6;
#line 10920
  goto ldv_call_6;
#line 10922
  goto ldv_call_6;
#line 10924
  goto ldv_call_6;
#line 10926
  goto ldv_call_6;
#line 10928
  goto ldv_call_6;
#line 10930
  goto ldv_call_6;
#line 10932
  goto ldv_call_6;
#line 10934
  goto ldv_call_6;
#line 10936
  goto ldv_call_6;
#line 10938
  goto ldv_call_6;
#line 10940
  goto ldv_call_6;
#line 10942
  goto ldv_call_6;
#line 10944
  goto ldv_call_6;
#line 10946
  goto ldv_call_6;
#line 10948
  goto ldv_call_6;
#line 10950
  goto ldv_call_6;
#line 10952
  goto ldv_call_6;
#line 10954
  goto ldv_call_6;
#line 10956
  goto ldv_call_6;
#line 10958
  goto ldv_call_6;
#line 10960
  goto ldv_call_6;
#line 10962
  goto ldv_call_6;
#line 10964
  goto ldv_call_6;
#line 10966
  goto ldv_call_6;
#line 10968
  goto ldv_call_6;
#line 10970
  goto ldv_call_6;
#line 10972
  goto ldv_call_6;
#line 10974
  goto ldv_call_6;
#line 10976
  goto ldv_call_6;
#line 10978
  goto ldv_call_6;
#line 10980
  goto ldv_call_6;
#line 10982
  goto ldv_call_6;
#line 10984
  goto ldv_call_6;
#line 10986
  goto ldv_call_6;
#line 10988
  goto ldv_call_6;
#line 10990
  goto ldv_call_6;
#line 10992
  goto ldv_call_6;
#line 10994
  goto ldv_call_6;
#line 10996
  goto ldv_call_6;
#line 10998
  goto ldv_call_6;
#line 11000
  goto ldv_call_6;
#line 11002
  goto ldv_call_6;
#line 11004
  goto ldv_call_6;
#line 11006
  goto ldv_call_6;
#line 11008
  goto ldv_call_6;
#line 11010
  goto ldv_call_6;
#line 11012
  goto ldv_call_6;
#line 11014
  goto ldv_call_6;
#line 11016
  goto ldv_call_6;
#line 11018
  goto ldv_call_6;
  case_89: /* CIL Label */ 
  {
#line 11024
  ldv_dummy_resourceless_instance_callback_6_12(ldv_6_callback_get_eeprom_len, ldv_6_container_net_device);
  }
#line 11031
  goto ldv_call_6;
#line 11033
  goto ldv_call_6;
#line 11035
  goto ldv_call_6;
#line 11037
  goto ldv_call_6;
#line 11039
  goto ldv_call_6;
#line 11041
  goto ldv_call_6;
#line 11043
  goto ldv_call_6;
#line 11045
  goto ldv_call_6;
#line 11047
  goto ldv_call_6;
#line 11049
  goto ldv_call_6;
#line 11051
  goto ldv_call_6;
#line 11053
  goto ldv_call_6;
#line 11055
  goto ldv_call_6;
#line 11057
  goto ldv_call_6;
#line 11059
  goto ldv_call_6;
#line 11061
  goto ldv_call_6;
#line 11063
  goto ldv_call_6;
#line 11065
  goto ldv_call_6;
#line 11067
  goto ldv_call_6;
#line 11069
  goto ldv_call_6;
#line 11071
  goto ldv_call_6;
#line 11073
  goto ldv_call_6;
#line 11075
  goto ldv_call_6;
#line 11077
  goto ldv_call_6;
#line 11079
  goto ldv_call_6;
#line 11081
  goto ldv_call_6;
#line 11083
  goto ldv_call_6;
#line 11085
  goto ldv_call_6;
#line 11087
  goto ldv_call_6;
#line 11089
  goto ldv_call_6;
#line 11091
  goto ldv_call_6;
#line 11093
  goto ldv_call_6;
#line 11095
  goto ldv_call_6;
#line 11097
  goto ldv_call_6;
#line 11099
  goto ldv_call_6;
#line 11101
  goto ldv_call_6;
#line 11103
  goto ldv_call_6;
#line 11105
  goto ldv_call_6;
#line 11107
  goto ldv_call_6;
#line 11109
  goto ldv_call_6;
#line 11111
  goto ldv_call_6;
#line 11113
  goto ldv_call_6;
#line 11115
  goto ldv_call_6;
#line 11117
  goto ldv_call_6;
#line 11119
  goto ldv_call_6;
#line 11121
  goto ldv_call_6;
#line 11123
  goto ldv_call_6;
#line 11125
  goto ldv_call_6;
#line 11127
  goto ldv_call_6;
#line 11129
  goto ldv_call_6;
#line 11131
  goto ldv_call_6;
#line 11133
  goto ldv_call_6;
#line 11135
  goto ldv_call_6;
#line 11137
  goto ldv_call_6;
#line 11139
  goto ldv_call_6;
#line 11141
  goto ldv_call_6;
#line 11143
  goto ldv_call_6;
#line 11145
  goto ldv_call_6;
#line 11147
  goto ldv_call_6;
#line 11149
  goto ldv_call_6;
#line 11151
  goto ldv_call_6;
#line 11153
  goto ldv_call_6;
#line 11155
  goto ldv_call_6;
#line 11157
  goto ldv_call_6;
#line 11159
  goto ldv_call_6;
#line 11161
  goto ldv_call_6;
#line 11163
  goto ldv_call_6;
#line 11165
  goto ldv_call_6;
#line 11167
  goto ldv_call_6;
#line 11169
  goto ldv_call_6;
#line 11171
  goto ldv_call_6;
#line 11173
  goto ldv_call_6;
#line 11175
  goto ldv_call_6;
#line 11177
  goto ldv_call_6;
#line 11179
  goto ldv_call_6;
#line 11181
  goto ldv_call_6;
#line 11183
  goto ldv_call_6;
#line 11185
  goto ldv_call_6;
#line 11187
  goto ldv_call_6;
#line 11189
  goto ldv_call_6;
#line 11191
  goto ldv_call_6;
#line 11193
  goto ldv_call_6;
#line 11195
  goto ldv_call_6;
#line 11197
  goto ldv_call_6;
#line 11199
  goto ldv_call_6;
#line 11201
  goto ldv_call_6;
#line 11203
  goto ldv_call_6;
#line 11205
  goto ldv_call_6;
#line 11207
  goto ldv_call_6;
  case_90: /* CIL Label */ 
  {
#line 11212
  tmp___25 = ldv_xmalloc(1UL);
#line 11212
  ldv_6_ldv_param_9_2_default = (unsigned char *)tmp___25;
#line 11217
  ldv_dummy_resourceless_instance_callback_6_9(ldv_6_callback_get_eeprom, ldv_6_container_net_device,
                                               ldv_6_container_struct_ethtool_eeprom_ptr,
                                               ldv_6_ldv_param_9_2_default);
#line 11221
  ldv_free((void *)ldv_6_ldv_param_9_2_default);
  }
#line 11228
  goto ldv_call_6;
#line 11230
  goto ldv_call_6;
#line 11232
  goto ldv_call_6;
#line 11234
  goto ldv_call_6;
#line 11236
  goto ldv_call_6;
#line 11238
  goto ldv_call_6;
#line 11240
  goto ldv_call_6;
#line 11242
  goto ldv_call_6;
#line 11244
  goto ldv_call_6;
#line 11246
  goto ldv_call_6;
#line 11248
  goto ldv_call_6;
#line 11250
  goto ldv_call_6;
#line 11252
  goto ldv_call_6;
#line 11254
  goto ldv_call_6;
#line 11256
  goto ldv_call_6;
#line 11258
  goto ldv_call_6;
#line 11260
  goto ldv_call_6;
#line 11262
  goto ldv_call_6;
#line 11264
  goto ldv_call_6;
#line 11266
  goto ldv_call_6;
#line 11268
  goto ldv_call_6;
#line 11270
  goto ldv_call_6;
#line 11272
  goto ldv_call_6;
#line 11274
  goto ldv_call_6;
#line 11276
  goto ldv_call_6;
#line 11278
  goto ldv_call_6;
#line 11280
  goto ldv_call_6;
#line 11282
  goto ldv_call_6;
#line 11284
  goto ldv_call_6;
#line 11286
  goto ldv_call_6;
#line 11288
  goto ldv_call_6;
#line 11290
  goto ldv_call_6;
#line 11292
  goto ldv_call_6;
#line 11294
  goto ldv_call_6;
#line 11296
  goto ldv_call_6;
#line 11298
  goto ldv_call_6;
#line 11300
  goto ldv_call_6;
#line 11302
  goto ldv_call_6;
#line 11304
  goto ldv_call_6;
#line 11306
  goto ldv_call_6;
#line 11308
  goto ldv_call_6;
#line 11310
  goto ldv_call_6;
#line 11312
  goto ldv_call_6;
#line 11314
  goto ldv_call_6;
#line 11316
  goto ldv_call_6;
#line 11318
  goto ldv_call_6;
#line 11320
  goto ldv_call_6;
#line 11322
  goto ldv_call_6;
#line 11324
  goto ldv_call_6;
#line 11326
  goto ldv_call_6;
#line 11328
  goto ldv_call_6;
#line 11330
  goto ldv_call_6;
#line 11332
  goto ldv_call_6;
#line 11334
  goto ldv_call_6;
#line 11336
  goto ldv_call_6;
#line 11338
  goto ldv_call_6;
#line 11340
  goto ldv_call_6;
#line 11342
  goto ldv_call_6;
#line 11344
  goto ldv_call_6;
#line 11346
  goto ldv_call_6;
#line 11348
  goto ldv_call_6;
#line 11350
  goto ldv_call_6;
#line 11352
  goto ldv_call_6;
#line 11354
  goto ldv_call_6;
#line 11356
  goto ldv_call_6;
#line 11358
  goto ldv_call_6;
#line 11360
  goto ldv_call_6;
#line 11362
  goto ldv_call_6;
#line 11364
  goto ldv_call_6;
#line 11366
  goto ldv_call_6;
#line 11368
  goto ldv_call_6;
#line 11370
  goto ldv_call_6;
#line 11372
  goto ldv_call_6;
#line 11374
  goto ldv_call_6;
#line 11376
  goto ldv_call_6;
#line 11378
  goto ldv_call_6;
#line 11380
  goto ldv_call_6;
#line 11382
  goto ldv_call_6;
#line 11384
  goto ldv_call_6;
#line 11386
  goto ldv_call_6;
#line 11388
  goto ldv_call_6;
#line 11390
  goto ldv_call_6;
#line 11392
  goto ldv_call_6;
#line 11394
  goto ldv_call_6;
#line 11396
  goto ldv_call_6;
#line 11398
  goto ldv_call_6;
#line 11400
  goto ldv_call_6;
#line 11402
  goto ldv_call_6;
#line 11404
  goto ldv_call_6;
#line 11406
  goto ldv_call_6;
  case_91: /* CIL Label */ 
  {
#line 11412
  ldv_dummy_resourceless_instance_callback_6_8(ldv_6_callback_get_drvinfo, ldv_6_container_net_device,
                                               ldv_6_container_struct_ethtool_drvinfo_ptr);
  }
#line 11419
  goto ldv_call_6;
#line 11421
  goto ldv_call_6;
#line 11423
  goto ldv_call_6;
#line 11425
  goto ldv_call_6;
#line 11427
  goto ldv_call_6;
#line 11429
  goto ldv_call_6;
#line 11431
  goto ldv_call_6;
#line 11433
  goto ldv_call_6;
#line 11435
  goto ldv_call_6;
#line 11437
  goto ldv_call_6;
#line 11439
  goto ldv_call_6;
#line 11441
  goto ldv_call_6;
#line 11443
  goto ldv_call_6;
#line 11445
  goto ldv_call_6;
#line 11447
  goto ldv_call_6;
#line 11449
  goto ldv_call_6;
#line 11451
  goto ldv_call_6;
#line 11453
  goto ldv_call_6;
#line 11455
  goto ldv_call_6;
#line 11457
  goto ldv_call_6;
#line 11459
  goto ldv_call_6;
#line 11461
  goto ldv_call_6;
#line 11463
  goto ldv_call_6;
#line 11465
  goto ldv_call_6;
#line 11467
  goto ldv_call_6;
#line 11469
  goto ldv_call_6;
#line 11471
  goto ldv_call_6;
#line 11473
  goto ldv_call_6;
#line 11475
  goto ldv_call_6;
#line 11477
  goto ldv_call_6;
#line 11479
  goto ldv_call_6;
#line 11481
  goto ldv_call_6;
#line 11483
  goto ldv_call_6;
#line 11485
  goto ldv_call_6;
#line 11487
  goto ldv_call_6;
#line 11489
  goto ldv_call_6;
#line 11491
  goto ldv_call_6;
#line 11493
  goto ldv_call_6;
#line 11495
  goto ldv_call_6;
#line 11497
  goto ldv_call_6;
#line 11499
  goto ldv_call_6;
#line 11501
  goto ldv_call_6;
#line 11503
  goto ldv_call_6;
#line 11505
  goto ldv_call_6;
#line 11507
  goto ldv_call_6;
#line 11509
  goto ldv_call_6;
#line 11511
  goto ldv_call_6;
#line 11513
  goto ldv_call_6;
#line 11515
  goto ldv_call_6;
#line 11517
  goto ldv_call_6;
#line 11519
  goto ldv_call_6;
#line 11521
  goto ldv_call_6;
#line 11523
  goto ldv_call_6;
#line 11525
  goto ldv_call_6;
#line 11527
  goto ldv_call_6;
#line 11529
  goto ldv_call_6;
#line 11531
  goto ldv_call_6;
#line 11533
  goto ldv_call_6;
#line 11535
  goto ldv_call_6;
#line 11537
  goto ldv_call_6;
#line 11539
  goto ldv_call_6;
#line 11541
  goto ldv_call_6;
#line 11543
  goto ldv_call_6;
#line 11545
  goto ldv_call_6;
#line 11547
  goto ldv_call_6;
#line 11549
  goto ldv_call_6;
#line 11551
  goto ldv_call_6;
#line 11553
  goto ldv_call_6;
#line 11555
  goto ldv_call_6;
#line 11557
  goto ldv_call_6;
#line 11559
  goto ldv_call_6;
#line 11561
  goto ldv_call_6;
#line 11563
  goto ldv_call_6;
#line 11565
  goto ldv_call_6;
#line 11567
  goto ldv_call_6;
#line 11569
  goto ldv_call_6;
#line 11571
  goto ldv_call_6;
#line 11573
  goto ldv_call_6;
#line 11575
  goto ldv_call_6;
#line 11577
  goto ldv_call_6;
#line 11579
  goto ldv_call_6;
#line 11581
  goto ldv_call_6;
#line 11583
  goto ldv_call_6;
#line 11585
  goto ldv_call_6;
#line 11587
  goto ldv_call_6;
#line 11589
  goto ldv_call_6;
#line 11591
  goto ldv_call_6;
#line 11593
  goto ldv_call_6;
#line 11595
  goto ldv_call_6;
#line 11597
  goto ldv_call_6;
#line 11599
  goto ldv_call_6;
  case_92: /* CIL Label */ 
  {
#line 11605
  ldv_dummy_resourceless_instance_callback_6_7(ldv_6_callback_get_coalesce, ldv_6_container_net_device,
                                               ldv_6_container_struct_ethtool_coalesce_ptr);
  }
#line 11612
  goto ldv_call_6;
#line 11614
  goto ldv_call_6;
#line 11616
  goto ldv_call_6;
#line 11618
  goto ldv_call_6;
#line 11620
  goto ldv_call_6;
#line 11622
  goto ldv_call_6;
#line 11624
  goto ldv_call_6;
#line 11626
  goto ldv_call_6;
#line 11628
  goto ldv_call_6;
#line 11630
  goto ldv_call_6;
#line 11632
  goto ldv_call_6;
#line 11634
  goto ldv_call_6;
#line 11636
  goto ldv_call_6;
#line 11638
  goto ldv_call_6;
#line 11640
  goto ldv_call_6;
#line 11642
  goto ldv_call_6;
#line 11644
  goto ldv_call_6;
#line 11646
  goto ldv_call_6;
#line 11648
  goto ldv_call_6;
#line 11650
  goto ldv_call_6;
#line 11652
  goto ldv_call_6;
#line 11654
  goto ldv_call_6;
#line 11656
  goto ldv_call_6;
#line 11658
  goto ldv_call_6;
#line 11660
  goto ldv_call_6;
#line 11662
  goto ldv_call_6;
#line 11664
  goto ldv_call_6;
#line 11666
  goto ldv_call_6;
#line 11668
  goto ldv_call_6;
#line 11670
  goto ldv_call_6;
#line 11672
  goto ldv_call_6;
#line 11674
  goto ldv_call_6;
#line 11676
  goto ldv_call_6;
#line 11678
  goto ldv_call_6;
#line 11680
  goto ldv_call_6;
#line 11682
  goto ldv_call_6;
#line 11684
  goto ldv_call_6;
#line 11686
  goto ldv_call_6;
#line 11688
  goto ldv_call_6;
#line 11690
  goto ldv_call_6;
#line 11692
  goto ldv_call_6;
#line 11694
  goto ldv_call_6;
#line 11696
  goto ldv_call_6;
#line 11698
  goto ldv_call_6;
#line 11700
  goto ldv_call_6;
#line 11702
  goto ldv_call_6;
#line 11704
  goto ldv_call_6;
#line 11706
  goto ldv_call_6;
#line 11708
  goto ldv_call_6;
#line 11710
  goto ldv_call_6;
#line 11712
  goto ldv_call_6;
#line 11714
  goto ldv_call_6;
#line 11716
  goto ldv_call_6;
#line 11718
  goto ldv_call_6;
#line 11720
  goto ldv_call_6;
#line 11722
  goto ldv_call_6;
#line 11724
  goto ldv_call_6;
#line 11726
  goto ldv_call_6;
#line 11728
  goto ldv_call_6;
#line 11730
  goto ldv_call_6;
#line 11732
  goto ldv_call_6;
#line 11734
  goto ldv_call_6;
#line 11736
  goto ldv_call_6;
#line 11738
  goto ldv_call_6;
#line 11740
  goto ldv_call_6;
#line 11742
  goto ldv_call_6;
#line 11744
  goto ldv_call_6;
#line 11746
  goto ldv_call_6;
#line 11748
  goto ldv_call_6;
#line 11750
  goto ldv_call_6;
#line 11752
  goto ldv_call_6;
#line 11754
  goto ldv_call_6;
#line 11756
  goto ldv_call_6;
#line 11758
  goto ldv_call_6;
#line 11760
  goto ldv_call_6;
#line 11762
  goto ldv_call_6;
#line 11764
  goto ldv_call_6;
#line 11766
  goto ldv_call_6;
#line 11768
  goto ldv_call_6;
#line 11770
  goto ldv_call_6;
#line 11772
  goto ldv_call_6;
#line 11774
  goto ldv_call_6;
#line 11776
  goto ldv_call_6;
#line 11778
  goto ldv_call_6;
#line 11780
  goto ldv_call_6;
#line 11782
  goto ldv_call_6;
#line 11784
  goto ldv_call_6;
#line 11786
  goto ldv_call_6;
#line 11788
  goto ldv_call_6;
#line 11790
  goto ldv_call_6;
#line 11792
  goto ldv_call_6;
#line 11794
  goto ldv_call_6;
  case_93: /* CIL Label */ 
  {
#line 11800
  ldv_dummy_resourceless_instance_callback_6_3(ldv_6_callback_get_channels, ldv_6_container_net_device,
                                               ldv_6_container_struct_ethtool_channels_ptr);
  }
#line 11807
  goto ldv_call_6;
#line 11809
  goto ldv_call_6;
#line 11811
  goto ldv_call_6;
#line 11813
  goto ldv_call_6;
#line 11815
  goto ldv_call_6;
#line 11817
  goto ldv_call_6;
#line 11819
  goto ldv_call_6;
#line 11821
  goto ldv_call_6;
#line 11823
  goto ldv_call_6;
#line 11825
  goto ldv_call_6;
#line 11827
  goto ldv_call_6;
#line 11829
  goto ldv_call_6;
#line 11831
  goto ldv_call_6;
#line 11833
  goto ldv_call_6;
#line 11835
  goto ldv_call_6;
#line 11837
  goto ldv_call_6;
#line 11839
  goto ldv_call_6;
#line 11841
  goto ldv_call_6;
#line 11843
  goto ldv_call_6;
#line 11845
  goto ldv_call_6;
#line 11847
  goto ldv_call_6;
#line 11849
  goto ldv_call_6;
#line 11851
  goto ldv_call_6;
#line 11853
  goto ldv_call_6;
#line 11855
  goto ldv_call_6;
#line 11857
  goto ldv_call_6;
#line 11859
  goto ldv_call_6;
#line 11861
  goto ldv_call_6;
#line 11863
  goto ldv_call_6;
#line 11865
  goto ldv_call_6;
#line 11867
  goto ldv_call_6;
#line 11869
  goto ldv_call_6;
#line 11871
  goto ldv_call_6;
#line 11873
  goto ldv_call_6;
#line 11875
  goto ldv_call_6;
#line 11877
  goto ldv_call_6;
#line 11879
  goto ldv_call_6;
#line 11881
  goto ldv_call_6;
#line 11883
  goto ldv_call_6;
#line 11885
  goto ldv_call_6;
#line 11887
  goto ldv_call_6;
#line 11889
  goto ldv_call_6;
#line 11891
  goto ldv_call_6;
#line 11893
  goto ldv_call_6;
#line 11895
  goto ldv_call_6;
#line 11897
  goto ldv_call_6;
#line 11899
  goto ldv_call_6;
#line 11901
  goto ldv_call_6;
#line 11903
  goto ldv_call_6;
#line 11905
  goto ldv_call_6;
#line 11907
  goto ldv_call_6;
#line 11909
  goto ldv_call_6;
#line 11911
  goto ldv_call_6;
#line 11913
  goto ldv_call_6;
#line 11915
  goto ldv_call_6;
#line 11917
  goto ldv_call_6;
#line 11919
  goto ldv_call_6;
#line 11921
  goto ldv_call_6;
#line 11923
  goto ldv_call_6;
#line 11925
  goto ldv_call_6;
#line 11927
  goto ldv_call_6;
#line 11929
  goto ldv_call_6;
#line 11931
  goto ldv_call_6;
#line 11933
  goto ldv_call_6;
#line 11935
  goto ldv_call_6;
#line 11937
  goto ldv_call_6;
#line 11939
  goto ldv_call_6;
#line 11941
  goto ldv_call_6;
#line 11943
  goto ldv_call_6;
#line 11945
  goto ldv_call_6;
#line 11947
  goto ldv_call_6;
#line 11949
  goto ldv_call_6;
#line 11951
  goto ldv_call_6;
#line 11953
  goto ldv_call_6;
#line 11955
  goto ldv_call_6;
#line 11957
  goto ldv_call_6;
#line 11959
  goto ldv_call_6;
#line 11961
  goto ldv_call_6;
#line 11963
  goto ldv_call_6;
#line 11965
  goto ldv_call_6;
#line 11967
  goto ldv_call_6;
#line 11969
  goto ldv_call_6;
#line 11971
  goto ldv_call_6;
#line 11973
  goto ldv_call_6;
#line 11975
  goto ldv_call_6;
#line 11977
  goto ldv_call_6;
#line 11979
  goto ldv_call_6;
#line 11981
  goto ldv_call_6;
#line 11983
  goto ldv_call_6;
#line 11985
  goto ldv_call_6;
#line 11987
  goto ldv_call_6;
#line 11989
  goto ldv_call_6;
#line 11991
  goto ldv_call_6;
  case_94: /* CIL Label */ ;
#line 12000
  return;
  switch_default: /* CIL Label */ 
  {
#line 12003
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 12006
  return;
}
}
#line 12011 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_instance_callback_7_10(unsigned int (*arg0)(struct pci_dev * , enum pci_channel_state  ) ,
                                    struct pci_dev *arg1 , enum pci_channel_state arg2 ) 
{ 


  {
  {
#line 12012
  ixgbe_io_error_detected(arg1, (pci_channel_state_t )arg2);
  }
#line 12013
  return;
}
}
#line 12016 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_instance_callback_7_23(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 12017
  ixgbe_io_resume(arg1);
  }
#line 12018
  return;
}
}
#line 12021 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_instance_callback_7_24(unsigned int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 12022
  ixgbe_io_slot_reset(arg1);
  }
#line 12023
  return;
}
}
#line 12026 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_instance_callback_7_25(int (*arg0)(struct pci_dev * , int  ) , struct pci_dev *arg1 ,
                                    int arg2 ) 
{ 


  {
  {
#line 12027
  ixgbe_pci_sriov_configure(arg1, arg2);
  }
#line 12028
  return;
}
}
#line 12031 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv_pci_instance_probe_7_17(int (*arg0)(struct pci_dev * , struct pci_device_id * ) ,
                                struct pci_dev *arg1 , struct pci_device_id *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 12032
  tmp = ixgbe_probe(arg1, (struct pci_device_id  const  *)arg2);
  }
#line 12032
  return (tmp);
}
}
#line 12036 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_instance_release_7_2(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 12037
  ixgbe_remove(arg1);
  }
#line 12038
  return;
}
}
#line 12041 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_instance_resume_7_5(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 12042
  ixgbe_resume(arg1);
  }
#line 12043
  return;
}
}
#line 12046 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_instance_resume_early_7_6(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 12047
  (*arg0)(arg1);
  }
#line 12048
  return;
}
}
#line 12051 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_instance_shutdown_7_3(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 12052
  ixgbe_shutdown(arg1);
  }
#line 12053
  return;
}
}
#line 12056 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv_pci_instance_suspend_7_8(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                 struct pci_dev *arg1 , struct pm_message arg2 ) 
{ 
  int tmp ;

  {
  {
#line 12057
  tmp = ixgbe_suspend(arg1, arg2);
  }
#line 12057
  return (tmp);
}
}
#line 12061 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv_pci_instance_suspend_late_7_7(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                      struct pci_dev *arg1 , struct pm_message arg2 ) 
{ 
  int tmp ;

  {
  {
#line 12062
  tmp = (*arg0)(arg1, arg2);
  }
#line 12062
  return (tmp);
}
}
#line 12066 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_pci_instance_7(void *arg0 ) 
{ 
  unsigned int (*ldv_7_callback_error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
  void (*ldv_7_callback_func_1_ptr)(struct pci_dev * ) ;
  unsigned int (*ldv_7_callback_slot_reset)(struct pci_dev * ) ;
  int (*ldv_7_callback_sriov_configure)(struct pci_dev * , int  ) ;
  struct pci_driver *ldv_7_container_pci_driver ;
  int ldv_7_ldv_param_25_1_default ;
  struct pci_dev *ldv_7_resource_dev ;
  enum pci_channel_state ldv_7_resource_enum_pci_channel_state ;
  struct pm_message ldv_7_resource_pm_message ;
  struct pci_device_id *ldv_7_resource_struct_pci_device_id_ptr ;
  int ldv_7_ret_default ;
  struct ldv_struct_pci_instance_7 *data ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 12081
  data = (struct ldv_struct_pci_instance_7 *)arg0;
#line 12085
  ldv_7_ret_default = 1;
#line 12088
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_pci_instance_7 *)0)) {
    {
#line 12089
    ldv_7_container_pci_driver = data->arg0;
#line 12090
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 12095
  tmp = ldv_xmalloc(2936UL);
#line 12095
  ldv_7_resource_dev = (struct pci_dev *)tmp;
#line 12096
  tmp___0 = ldv_xmalloc(32UL);
#line 12096
  ldv_7_resource_struct_pci_device_id_ptr = (struct pci_device_id *)tmp___0;
  }
#line 12103
  goto ldv_main_7;
#line 12105
  return;
  ldv_main_7: 
  {
#line 12111
  tmp___2 = ldv_undef_int();
  }
#line 12111
  if (tmp___2 != 0) {
    {
#line 12114
    ldv_pre_probe();
#line 12116
    ldv_7_ret_default = ldv_pci_instance_probe_7_17((int (*)(struct pci_dev * , struct pci_device_id * ))ldv_7_container_pci_driver->probe,
                                                    ldv_7_resource_dev, ldv_7_resource_struct_pci_device_id_ptr);
#line 12118
    ldv_7_ret_default = ldv_post_probe(ldv_7_ret_default);
#line 12121
    tmp___1 = ldv_undef_int();
    }
#line 12121
    if (tmp___1 != 0) {
      {
#line 12123
      ldv_assume(ldv_7_ret_default == 0);
      }
#line 12130
      goto ldv_call_7;
    } else {
      {
#line 12134
      ldv_assume(ldv_7_ret_default != 0);
      }
#line 12141
      goto ldv_main_7;
    }
  } else {
    {
#line 12146
    ldv_free((void *)ldv_7_resource_dev);
#line 12147
    ldv_free((void *)ldv_7_resource_struct_pci_device_id_ptr);
    }
#line 12155
    return;
  }
#line 12158
  return;
  ldv_call_7: 
  {
#line 12164
  tmp___3 = ldv_undef_int();
  }
  {
#line 12165
  if (tmp___3 == 1) {
#line 12165
    goto case_1;
  } else {

  }
#line 12184
  if (tmp___3 == 2) {
#line 12184
    goto case_2;
  } else {

  }
#line 12199
  if (tmp___3 == 3) {
#line 12199
    goto case_3;
  } else {

  }
#line 12216
  if (tmp___3 == 4) {
#line 12216
    goto case_4;
  } else {

  }
#line 12235
  if (tmp___3 == 5) {
#line 12235
    goto case_5;
  } else {

  }
#line 12271
  if (tmp___3 == 6) {
#line 12271
    goto case_6;
  } else {

  }
#line 12289
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 12171
  ldv_pci_instance_callback_7_25(ldv_7_callback_sriov_configure, ldv_7_resource_dev,
                                 ldv_7_ldv_param_25_1_default);
  }
#line 12181
  goto ldv_call_7;
  case_2: /* CIL Label */ 
  {
#line 12187
  ldv_pci_instance_callback_7_24(ldv_7_callback_slot_reset, ldv_7_resource_dev);
  }
#line 12194
  goto ldv_call_7;
#line 12196
  goto ldv_call_7;
  case_3: /* CIL Label */ 
  {
#line 12202
  ldv_pci_instance_callback_7_23(ldv_7_callback_func_1_ptr, ldv_7_resource_dev);
  }
#line 12209
  goto ldv_call_7;
#line 12211
  goto ldv_call_7;
#line 12213
  goto ldv_call_7;
  case_4: /* CIL Label */ 
  {
#line 12219
  ldv_pci_instance_callback_7_10(ldv_7_callback_error_detected, ldv_7_resource_dev,
                                 ldv_7_resource_enum_pci_channel_state);
  }
#line 12226
  goto ldv_call_7;
#line 12228
  goto ldv_call_7;
#line 12230
  goto ldv_call_7;
#line 12232
  goto ldv_call_7;
  case_5: /* CIL Label */ 
  {
#line 12238
  ldv_7_ret_default = ldv_pci_instance_suspend_7_8(ldv_7_container_pci_driver->suspend,
                                                   ldv_7_resource_dev, ldv_7_resource_pm_message);
#line 12240
  ldv_7_ret_default = ldv_filter_err_code(ldv_7_ret_default);
  }
#line 12244
  if ((unsigned long )ldv_7_container_pci_driver->suspend_late != (unsigned long )((int (*)(struct pci_dev * ,
                                                                                            pm_message_t  ))0)) {
    {
#line 12246
    ldv_7_ret_default = ldv_pci_instance_suspend_late_7_7(ldv_7_container_pci_driver->suspend_late,
                                                          ldv_7_resource_dev, ldv_7_resource_pm_message);
    }
  } else {

  }
  {
#line 12249
  ldv_7_ret_default = ldv_filter_err_code(ldv_7_ret_default);
  }
#line 12253
  if ((unsigned long )ldv_7_container_pci_driver->resume_early != (unsigned long )((int (*)(struct pci_dev * ))0)) {
    {
#line 12255
    ldv_pci_instance_resume_early_7_6(ldv_7_container_pci_driver->resume_early, ldv_7_resource_dev);
    }
  } else {

  }
  {
#line 12261
  ldv_pci_instance_resume_7_5(ldv_7_container_pci_driver->resume, ldv_7_resource_dev);
  }
#line 12268
  goto ldv_call_7;
  case_6: /* CIL Label */ 
  {
#line 12274
  ldv_pci_instance_shutdown_7_3(ldv_7_container_pci_driver->shutdown, ldv_7_resource_dev);
#line 12279
  ldv_pci_instance_release_7_2(ldv_7_container_pci_driver->remove, ldv_7_resource_dev);
  }
#line 12286
  goto ldv_main_7;
  switch_default: /* CIL Label */ 
  {
#line 12289
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 12292
  return;
}
}
#line 12297 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_pci_unregister_driver(void *arg0 , struct pci_driver *arg1 ) 
{ 
  struct pci_driver *ldv_27_pci_driver_pci_driver ;

  {
  {
#line 12303
  ldv_27_pci_driver_pci_driver = arg1;
#line 12307
  ldv_dispatch_deregister_27_1(ldv_27_pci_driver_pci_driver);
  }
#line 12311
  return;
#line 12313
  return;
}
}
#line 12318 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv_register_netdev(int arg0 , struct net_device *arg1 ) 
{ 
  struct net_device *ldv_21_netdev_net_device ;
  int ldv_21_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 12325
  ldv_21_ret_default = 1;
#line 12327
  ldv_21_ret_default = ldv_pre_register_netdev();
#line 12328
  ldv_21_netdev_net_device = arg1;
#line 12331
  tmp___0 = ldv_undef_int();
  }
#line 12331
  if (tmp___0 != 0) {
    {
#line 12333
    ldv_assume(ldv_21_ret_default == 0);
#line 12338
    ldv_21_ret_default = ldv_register_netdev_open_21_6((ldv_21_netdev_net_device->netdev_ops)->ndo_open,
                                                       ldv_21_netdev_net_device);
#line 12341
    tmp = ldv_undef_int();
    }
#line 12341
    if (tmp != 0) {
      {
#line 12343
      ldv_assume(ldv_21_ret_default == 0);
#line 12347
      ldv_dispatch_register_21_4(ldv_21_netdev_net_device);
      }
    } else {
      {
#line 12353
      ldv_assume(ldv_21_ret_default != 0);
      }
    }
  } else {
    {
#line 12360
    ldv_assume(ldv_21_ret_default != 0);
    }
  }
#line 12365
  return (ldv_21_ret_default);
#line 12369
  return (arg0);
#line 12371
  return (arg0);
}
}
#line 12376 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv_register_netdev_open_21_6(int (*arg0)(struct net_device * ) , struct net_device *arg1 ) 
{ 
  int tmp ;

  {
  {
#line 12377
  tmp = ixgbe_open(arg1);
  }
#line 12377
  return (tmp);
}
}
#line 12381 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) 
{ 
  enum irqreturn (*ldv_24_callback_handler)(int  , void * ) ;
  void *ldv_24_data_data ;
  int ldv_24_line_line ;
  enum irqreturn (*ldv_24_thread_thread)(int  , void * ) ;
  int tmp ;

  {
  {
#line 12391
  tmp = ldv_undef_int();
  }
#line 12391
  if (tmp != 0) {
    {
#line 12393
    ldv_assume(arg0 == 0);
#line 12394
    ldv_24_line_line = (int )arg1;
#line 12395
    ldv_24_callback_handler = arg2;
#line 12396
    ldv_24_thread_thread = (enum irqreturn (*)(int  , void * ))0;
#line 12397
    ldv_24_data_data = arg5;
#line 12401
    ldv_dispatch_irq_register_24_2(ldv_24_line_line, ldv_24_callback_handler, ldv_24_thread_thread,
                                   ldv_24_data_data);
    }
#line 12405
    return (arg0);
  } else {
    {
#line 12409
    ldv_assume(arg0 != 0);
    }
#line 12413
    return (arg0);
  }
#line 12416
  return (arg0);
}
}
#line 12421 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_10(void *arg0 ) 
{ 
  int (*ldv_10_callback_acquire_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_10_callback_blink_led_start)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_10_callback_blink_led_stop)(struct ixgbe_hw * , unsigned int  ) ;
  unsigned short (*ldv_10_callback_calc_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_check_for_ack)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_10_callback_check_for_msg)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_10_callback_check_for_rst)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_10_callback_check_link)(struct ixgbe_hw * , unsigned int * , _Bool * ,
                                    _Bool  ) ;
  int (*ldv_10_callback_check_overtemp)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_clear_hw_cntrs)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_clear_rar)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_10_callback_clear_vfta)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_clear_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_10_callback_disable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_disable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_enable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_enable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_enable_rx_dma)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_10_callback_fc_enable)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_get_bus_info)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_get_device_caps)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_10_callback_get_firmware_version)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_10_callback_get_invariants)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_get_link_capabilities)(struct ixgbe_hw * , unsigned int * ,
                                               _Bool * ) ;
  int (*ldv_10_callback_get_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  enum ixgbe_media_type (*ldv_10_callback_get_media_type)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_get_san_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  unsigned int (*ldv_10_callback_get_supported_physical_layer)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_get_thermal_sensor_data)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_get_wwn_prefix)(struct ixgbe_hw * , unsigned short * , unsigned short * ) ;
  int (*ldv_10_callback_identify)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_identify_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_init)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_init_hw)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_init_params)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_init_rx_addrs)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_init_thermal_sensor_thresh)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_init_uta_tables)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_led_off)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_10_callback_led_on)(struct ixgbe_hw * , unsigned int  ) ;
  _Bool (*ldv_10_callback_mng_fw_enabled)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_read)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                              unsigned short  ) ;
  int (*ldv_10_callback_read_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char * ) ;
  int (*ldv_10_callback_read_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                     unsigned short * ) ;
  int (*ldv_10_callback_read_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                       unsigned char * ) ;
  int (*ldv_10_callback_read_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_10_callback_read_i2c_sff8472)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_10_callback_read_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                     unsigned short  ) ;
  int (*ldv_10_callback_read_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  unsigned short * ) ;
  int (*ldv_10_callback_read_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                      unsigned short * ) ;
  void (*ldv_10_callback_release_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_10_callback_reset)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_reset_hw)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_set_fw_drv_ver)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                        unsigned char  , unsigned char  ) ;
  void (*ldv_10_callback_set_lan_id)(struct ixgbe_hw * ) ;
  void (*ldv_10_callback_set_mac_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_10_callback_set_rar)(struct ixgbe_hw * , unsigned int  , unsigned char * ,
                                 unsigned int  , unsigned int  ) ;
  void (*ldv_10_callback_set_rxpba)(struct ixgbe_hw * , int  , unsigned int  , int  ) ;
  int (*ldv_10_callback_set_vfta)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  _Bool  ) ;
  void (*ldv_10_callback_set_vlan_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_10_callback_set_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_10_callback_set_vmdq_san_mac)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_10_callback_setup_link)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_setup_link_speed)(struct ixgbe_hw * , unsigned int  , _Bool  ) ;
  int (*ldv_10_callback_setup_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_start_hw)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_stop_adapter)(struct ixgbe_hw * ) ;
  void (*ldv_10_callback_stop_link_on_d3)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_update_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_10_callback_update_mc_addr_list)(struct ixgbe_hw * , struct net_device * ) ;
  int (*ldv_10_callback_validate_checksum)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_10_callback_write)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                               unsigned short  ) ;
  int (*ldv_10_callback_write_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char  ) ;
  int (*ldv_10_callback_write_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                      unsigned short * ) ;
  int (*ldv_10_callback_write_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                        unsigned char  ) ;
  int (*ldv_10_callback_write_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char  ) ;
  int (*ldv_10_callback_write_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                      unsigned short  ) ;
  int (*ldv_10_callback_write_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                   unsigned short  ) ;
  int (*ldv_10_callback_write_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                       unsigned short  ) ;
  struct ixgbe_hw *ldv_10_container_struct_ixgbe_hw_ptr ;
  struct net_device *ldv_10_container_struct_net_device_ptr ;
  unsigned int *ldv_10_ldv_param_101_1_default ;
  unsigned short ldv_10_ldv_param_101_2_default ;
  unsigned short ldv_10_ldv_param_101_3_default ;
  unsigned int ldv_10_ldv_param_104_1_default ;
  unsigned int ldv_10_ldv_param_104_2_default ;
  unsigned short *ldv_10_ldv_param_104_3_default ;
  unsigned int ldv_10_ldv_param_107_1_default ;
  unsigned int ldv_10_ldv_param_107_2_default ;
  unsigned short *ldv_10_ldv_param_107_3_default ;
  unsigned short ldv_10_ldv_param_110_1_default ;
  unsigned char ldv_10_ldv_param_115_1_default ;
  unsigned char ldv_10_ldv_param_115_2_default ;
  unsigned char ldv_10_ldv_param_115_3_default ;
  unsigned char ldv_10_ldv_param_115_4_default ;
  _Bool ldv_10_ldv_param_119_1_default ;
  int ldv_10_ldv_param_119_2_default ;
  unsigned int ldv_10_ldv_param_122_1_default ;
  unsigned char *ldv_10_ldv_param_122_2_default ;
  unsigned int ldv_10_ldv_param_122_3_default ;
  unsigned int ldv_10_ldv_param_122_4_default ;
  int ldv_10_ldv_param_125_1_default ;
  unsigned int ldv_10_ldv_param_125_2_default ;
  int ldv_10_ldv_param_125_3_default ;
  unsigned int ldv_10_ldv_param_128_1_default ;
  unsigned int ldv_10_ldv_param_128_2_default ;
  _Bool ldv_10_ldv_param_128_3_default ;
  unsigned int ldv_10_ldv_param_12_1_default ;
  _Bool ldv_10_ldv_param_131_1_default ;
  int ldv_10_ldv_param_131_2_default ;
  unsigned int ldv_10_ldv_param_134_1_default ;
  unsigned int ldv_10_ldv_param_134_2_default ;
  unsigned int ldv_10_ldv_param_137_1_default ;
  unsigned int ldv_10_ldv_param_141_1_default ;
  _Bool ldv_10_ldv_param_141_2_default ;
  unsigned short *ldv_10_ldv_param_150_1_default ;
  unsigned int *ldv_10_ldv_param_153_1_default ;
  unsigned short ldv_10_ldv_param_153_2_default ;
  unsigned short ldv_10_ldv_param_153_3_default ;
  unsigned int ldv_10_ldv_param_156_1_default ;
  unsigned char ldv_10_ldv_param_156_2_default ;
  unsigned short ldv_10_ldv_param_159_1_default ;
  unsigned short ldv_10_ldv_param_159_2_default ;
  unsigned short *ldv_10_ldv_param_159_3_default ;
  unsigned char ldv_10_ldv_param_162_1_default ;
  unsigned char ldv_10_ldv_param_162_2_default ;
  unsigned char ldv_10_ldv_param_162_3_default ;
  unsigned char ldv_10_ldv_param_165_1_default ;
  unsigned char ldv_10_ldv_param_165_2_default ;
  unsigned int *ldv_10_ldv_param_168_1_default ;
  unsigned short ldv_10_ldv_param_168_2_default ;
  unsigned short ldv_10_ldv_param_168_3_default ;
  unsigned short ldv_10_ldv_param_16_1_default ;
  unsigned int ldv_10_ldv_param_171_1_default ;
  unsigned int ldv_10_ldv_param_171_2_default ;
  unsigned short ldv_10_ldv_param_171_3_default ;
  unsigned int ldv_10_ldv_param_174_1_default ;
  unsigned int ldv_10_ldv_param_174_2_default ;
  unsigned short ldv_10_ldv_param_174_3_default ;
  unsigned short ldv_10_ldv_param_19_1_default ;
  unsigned short ldv_10_ldv_param_22_1_default ;
  unsigned int *ldv_10_ldv_param_25_1_default ;
  _Bool *ldv_10_ldv_param_25_2_default ;
  _Bool ldv_10_ldv_param_25_3_default ;
  unsigned int ldv_10_ldv_param_30_1_default ;
  unsigned int ldv_10_ldv_param_34_1_default ;
  unsigned int ldv_10_ldv_param_34_2_default ;
  unsigned short ldv_10_ldv_param_3_1_default ;
  unsigned int ldv_10_ldv_param_41_1_default ;
  unsigned short *ldv_10_ldv_param_46_1_default ;
  unsigned short *ldv_10_ldv_param_49_1_default ;
  unsigned int *ldv_10_ldv_param_53_1_default ;
  _Bool *ldv_10_ldv_param_53_2_default ;
  unsigned char *ldv_10_ldv_param_56_1_default ;
  unsigned char *ldv_10_ldv_param_60_1_default ;
  unsigned short *ldv_10_ldv_param_65_1_default ;
  unsigned short *ldv_10_ldv_param_65_2_default ;
  unsigned int ldv_10_ldv_param_76_1_default ;
  unsigned int ldv_10_ldv_param_79_1_default ;
  unsigned int *ldv_10_ldv_param_83_1_default ;
  unsigned short ldv_10_ldv_param_83_2_default ;
  unsigned short ldv_10_ldv_param_83_3_default ;
  unsigned int ldv_10_ldv_param_86_1_default ;
  unsigned char *ldv_10_ldv_param_86_2_default ;
  unsigned short ldv_10_ldv_param_89_1_default ;
  unsigned short ldv_10_ldv_param_89_2_default ;
  unsigned short *ldv_10_ldv_param_89_3_default ;
  unsigned char ldv_10_ldv_param_92_1_default ;
  unsigned char ldv_10_ldv_param_92_2_default ;
  unsigned char *ldv_10_ldv_param_92_3_default ;
  unsigned char ldv_10_ldv_param_95_1_default ;
  unsigned char *ldv_10_ldv_param_95_2_default ;
  unsigned char ldv_10_ldv_param_98_1_default ;
  unsigned char *ldv_10_ldv_param_98_2_default ;
  unsigned int ldv_10_ldv_param_9_1_default ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;

  {
#line 12607
  goto ldv_call_10;
#line 12609
  return;
  ldv_call_10: 
  {
#line 12615
  tmp___24 = ldv_undef_int();
  }
#line 12615
  if (tmp___24 != 0) {
    {
#line 12619
    tmp = ldv_undef_int();
    }
    {
#line 12620
    if (tmp == 1) {
#line 12620
      goto case_1;
    } else {

    }
#line 12634
    if (tmp == 2) {
#line 12634
      goto case_2;
    } else {

    }
#line 12648
    if (tmp == 3) {
#line 12648
      goto case_3;
    } else {

    }
#line 12664
    if (tmp == 4) {
#line 12664
      goto case_4;
    } else {

    }
#line 12678
    if (tmp == 5) {
#line 12678
      goto case_5;
    } else {

    }
#line 12692
    if (tmp == 6) {
#line 12692
      goto case_6;
    } else {

    }
#line 12708
    if (tmp == 7) {
#line 12708
      goto case_7;
    } else {

    }
#line 12722
    if (tmp == 8) {
#line 12722
      goto case_8;
    } else {

    }
#line 12738
    if (tmp == 9) {
#line 12738
      goto case_9;
    } else {

    }
#line 12754
    if (tmp == 10) {
#line 12754
      goto case_10;
    } else {

    }
#line 12762
    if (tmp == 11) {
#line 12762
      goto case_11;
    } else {

    }
#line 12770
    if (tmp == 12) {
#line 12770
      goto case_12;
    } else {

    }
#line 12778
    if (tmp == 13) {
#line 12778
      goto case_13;
    } else {

    }
#line 12786
    if (tmp == 14) {
#line 12786
      goto case_14;
    } else {

    }
#line 12794
    if (tmp == 15) {
#line 12794
      goto case_15;
    } else {

    }
#line 12802
    if (tmp == 16) {
#line 12802
      goto case_16;
    } else {

    }
#line 12816
    if (tmp == 17) {
#line 12816
      goto case_17;
    } else {

    }
#line 12824
    if (tmp == 18) {
#line 12824
      goto case_18;
    } else {

    }
#line 12838
    if (tmp == 19) {
#line 12838
      goto case_19;
    } else {

    }
#line 12852
    if (tmp == 20) {
#line 12852
      goto case_20;
    } else {

    }
#line 12866
    if (tmp == 21) {
#line 12866
      goto case_21;
    } else {

    }
#line 12880
    if (tmp == 22) {
#line 12880
      goto case_22;
    } else {

    }
#line 12894
    if (tmp == 23) {
#line 12894
      goto case_23;
    } else {

    }
#line 12910
    if (tmp == 24) {
#line 12910
      goto case_24;
    } else {

    }
#line 12924
    if (tmp == 25) {
#line 12924
      goto case_25;
    } else {

    }
#line 12932
    if (tmp == 26) {
#line 12932
      goto case_26;
    } else {

    }
#line 12946
    if (tmp == 27) {
#line 12946
      goto case_27;
    } else {

    }
#line 12954
    if (tmp == 28) {
#line 12954
      goto case_28;
    } else {

    }
#line 12962
    if (tmp == 29) {
#line 12962
      goto case_29;
    } else {

    }
#line 12976
    if (tmp == 30) {
#line 12976
      goto case_30;
    } else {

    }
#line 12992
    if (tmp == 31) {
#line 12992
      goto case_31;
    } else {

    }
#line 13008
    if (tmp == 32) {
#line 13008
      goto case_32;
    } else {

    }
#line 13024
    if (tmp == 33) {
#line 13024
      goto case_33;
    } else {

    }
#line 13040
    if (tmp == 34) {
#line 13040
      goto case_34;
    } else {

    }
#line 13056
    if (tmp == 35) {
#line 13056
      goto case_35;
    } else {

    }
#line 13072
    if (tmp == 36) {
#line 13072
      goto case_36;
    } else {

    }
#line 13088
    if (tmp == 37) {
#line 13088
      goto case_37;
    } else {

    }
#line 13104
    if (tmp == 38) {
#line 13104
      goto case_38;
    } else {

    }
#line 13120
    if (tmp == 39) {
#line 13120
      goto case_39;
    } else {

    }
#line 13128
    if (tmp == 40) {
#line 13128
      goto case_40;
    } else {

    }
#line 13142
    if (tmp == 41) {
#line 13142
      goto case_41;
    } else {

    }
#line 13156
    if (tmp == 42) {
#line 13156
      goto case_42;
    } else {

    }
#line 13164
    if (tmp == 43) {
#line 13164
      goto case_43;
    } else {

    }
#line 13172
    if (tmp == 44) {
#line 13172
      goto case_44;
    } else {

    }
#line 13180
    if (tmp == 45) {
#line 13180
      goto case_45;
    } else {

    }
#line 13188
    if (tmp == 46) {
#line 13188
      goto case_46;
    } else {

    }
#line 13196
    if (tmp == 47) {
#line 13196
      goto case_47;
    } else {

    }
#line 13204
    if (tmp == 48) {
#line 13204
      goto case_48;
    } else {

    }
#line 13212
    if (tmp == 49) {
#line 13212
      goto case_49;
    } else {

    }
#line 13220
    if (tmp == 50) {
#line 13220
      goto case_50;
    } else {

    }
#line 13238
    if (tmp == 51) {
#line 13238
      goto case_51;
    } else {

    }
#line 13246
    if (tmp == 52) {
#line 13246
      goto case_52;
    } else {

    }
#line 13254
    if (tmp == 53) {
#line 13254
      goto case_53;
    } else {

    }
#line 13270
    if (tmp == 54) {
#line 13270
      goto case_54;
    } else {

    }
#line 13278
    if (tmp == 55) {
#line 13278
      goto case_55;
    } else {

    }
#line 13294
    if (tmp == 56) {
#line 13294
      goto case_56;
    } else {

    }
#line 13312
    if (tmp == 57) {
#line 13312
      goto case_57;
    } else {

    }
#line 13320
    if (tmp == 58) {
#line 13320
      goto case_58;
    } else {

    }
#line 13336
    if (tmp == 59) {
#line 13336
      goto case_59;
    } else {

    }
#line 13352
    if (tmp == 60) {
#line 13352
      goto case_60;
    } else {

    }
#line 13360
    if (tmp == 61) {
#line 13360
      goto case_61;
    } else {

    }
#line 13368
    if (tmp == 62) {
#line 13368
      goto case_62;
    } else {

    }
#line 13382
    if (tmp == 63) {
#line 13382
      goto case_63;
    } else {

    }
#line 13390
    if (tmp == 64) {
#line 13390
      goto case_64;
    } else {

    }
#line 13398
    if (tmp == 65) {
#line 13398
      goto case_65;
    } else {

    }
#line 13406
    if (tmp == 66) {
#line 13406
      goto case_66;
    } else {

    }
#line 13414
    if (tmp == 67) {
#line 13414
      goto case_67;
    } else {

    }
#line 13428
    if (tmp == 68) {
#line 13428
      goto case_68;
    } else {

    }
#line 13436
    if (tmp == 69) {
#line 13436
      goto case_69;
    } else {

    }
#line 13450
    if (tmp == 70) {
#line 13450
      goto case_70;
    } else {

    }
#line 13458
    if (tmp == 71) {
#line 13458
      goto case_71;
    } else {

    }
#line 13466
    if (tmp == 72) {
#line 13466
      goto case_72;
    } else {

    }
#line 13484
    if (tmp == 73) {
#line 13484
      goto case_73;
    } else {

    }
#line 13498
    if (tmp == 74) {
#line 13498
      goto case_74;
    } else {

    }
#line 13512
    if (tmp == 75) {
#line 13512
      goto case_75;
    } else {

    }
#line 13526
    if (tmp == 76) {
#line 13526
      goto case_76;
    } else {

    }
#line 13534
    if (tmp == 77) {
#line 13534
      goto case_77;
    } else {

    }
#line 13548
    if (tmp == 78) {
#line 13548
      goto case_78;
    } else {

    }
#line 13562
    if (tmp == 79) {
#line 13562
      goto case_79;
    } else {

    }
#line 13570
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 12626
    ldv_dummy_resourceless_instance_callback_10_174(ldv_10_callback_write_reg_mdi,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_174_1_default,
                                                    ldv_10_ldv_param_174_2_default,
                                                    (int )ldv_10_ldv_param_174_3_default);
    }
#line 12632
    goto ldv_61223;
    case_2: /* CIL Label */ 
    {
#line 12640
    ldv_dummy_resourceless_instance_callback_10_171(ldv_10_callback_write_reg, ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_171_1_default,
                                                    ldv_10_ldv_param_171_2_default,
                                                    (int )ldv_10_ldv_param_171_3_default);
    }
#line 12646
    goto ldv_61223;
    case_3: /* CIL Label */ 
    {
#line 12650
    tmp___0 = ldv_xmalloc(4UL);
#line 12650
    ldv_10_ldv_param_168_1_default = (unsigned int *)tmp___0;
#line 12655
    ldv_dummy_resourceless_instance_callback_10_168(ldv_10_callback_write_posted,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_168_1_default,
                                                    (int )ldv_10_ldv_param_168_2_default,
                                                    (int )ldv_10_ldv_param_168_3_default);
#line 12659
    ldv_free((void *)ldv_10_ldv_param_168_1_default);
    }
#line 12662
    goto ldv_61223;
    case_4: /* CIL Label */ 
    {
#line 12670
    ldv_dummy_resourceless_instance_callback_10_165(ldv_10_callback_write_i2c_eeprom,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_10_ldv_param_165_1_default,
                                                    (int )ldv_10_ldv_param_165_2_default);
    }
#line 12676
    goto ldv_61223;
    case_5: /* CIL Label */ 
    {
#line 12684
    ldv_dummy_resourceless_instance_callback_10_162(ldv_10_callback_write_i2c_byte,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_10_ldv_param_162_1_default,
                                                    (int )ldv_10_ldv_param_162_2_default,
                                                    (int )ldv_10_ldv_param_162_3_default);
    }
#line 12690
    goto ldv_61223;
    case_6: /* CIL Label */ 
    {
#line 12694
    tmp___1 = ldv_xmalloc(2UL);
#line 12694
    ldv_10_ldv_param_159_3_default = (unsigned short *)tmp___1;
#line 12699
    ldv_dummy_resourceless_instance_callback_10_159(ldv_10_callback_write_buffer,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_10_ldv_param_159_1_default,
                                                    (int )ldv_10_ldv_param_159_2_default,
                                                    ldv_10_ldv_param_159_3_default);
#line 12703
    ldv_free((void *)ldv_10_ldv_param_159_3_default);
    }
#line 12706
    goto ldv_61223;
    case_7: /* CIL Label */ 
    {
#line 12714
    ldv_dummy_resourceless_instance_callback_10_156(ldv_10_callback_write_analog_reg8,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_156_1_default,
                                                    (int )ldv_10_ldv_param_156_2_default);
    }
#line 12720
    goto ldv_61223;
    case_8: /* CIL Label */ 
    {
#line 12724
    tmp___2 = ldv_xmalloc(4UL);
#line 12724
    ldv_10_ldv_param_153_1_default = (unsigned int *)tmp___2;
#line 12729
    ldv_dummy_resourceless_instance_callback_10_153(ldv_10_callback_write, ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_153_1_default,
                                                    (int )ldv_10_ldv_param_153_2_default,
                                                    (int )ldv_10_ldv_param_153_3_default);
#line 12733
    ldv_free((void *)ldv_10_ldv_param_153_1_default);
    }
#line 12736
    goto ldv_61223;
    case_9: /* CIL Label */ 
    {
#line 12740
    tmp___3 = ldv_xmalloc(2UL);
#line 12740
    ldv_10_ldv_param_150_1_default = (unsigned short *)tmp___3;
#line 12745
    ldv_dummy_resourceless_instance_callback_10_150(ldv_10_callback_validate_checksum,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_150_1_default);
#line 12749
    ldv_free((void *)ldv_10_ldv_param_150_1_default);
    }
#line 12752
    goto ldv_61223;
    case_10: /* CIL Label */ 
    {
#line 12757
    ldv_dummy_resourceless_instance_callback_10_149(ldv_10_callback_update_mc_addr_list,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_container_struct_net_device_ptr);
    }
#line 12760
    goto ldv_61223;
    case_11: /* CIL Label */ 
    {
#line 12765
    ldv_dummy_resourceless_instance_callback_10_148(ldv_10_callback_update_checksum,
                                                    ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12768
    goto ldv_61223;
    case_12: /* CIL Label */ 
    {
#line 12773
    ldv_dummy_resourceless_instance_callback_10_147(ldv_10_callback_stop_link_on_d3,
                                                    ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12776
    goto ldv_61223;
    case_13: /* CIL Label */ 
    {
#line 12781
    ldv_dummy_resourceless_instance_callback_10_146(ldv_10_callback_stop_adapter,
                                                    ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12784
    goto ldv_61223;
    case_14: /* CIL Label */ 
    {
#line 12789
    ldv_dummy_resourceless_instance_callback_10_145(ldv_10_callback_start_hw, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12792
    goto ldv_61223;
    case_15: /* CIL Label */ 
    {
#line 12797
    ldv_dummy_resourceless_instance_callback_10_144(ldv_10_callback_setup_sfp, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12800
    goto ldv_61223;
    case_16: /* CIL Label */ 
    {
#line 12808
    ldv_dummy_resourceless_instance_callback_10_141(ldv_10_callback_setup_link_speed,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_141_1_default,
                                                    (int )ldv_10_ldv_param_141_2_default);
    }
#line 12814
    goto ldv_61223;
    case_17: /* CIL Label */ 
    {
#line 12819
    ldv_dummy_resourceless_instance_callback_10_140(ldv_10_callback_setup_link, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12822
    goto ldv_61223;
    case_18: /* CIL Label */ 
    {
#line 12830
    ldv_dummy_resourceless_instance_callback_10_137(ldv_10_callback_set_vmdq_san_mac,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_137_1_default);
    }
#line 12836
    goto ldv_61223;
    case_19: /* CIL Label */ 
    {
#line 12844
    ldv_dummy_resourceless_instance_callback_10_134(ldv_10_callback_set_vmdq, ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_134_1_default,
                                                    ldv_10_ldv_param_134_2_default);
    }
#line 12850
    goto ldv_61223;
    case_20: /* CIL Label */ 
    {
#line 12858
    ldv_dummy_resourceless_instance_callback_10_131(ldv_10_callback_set_vlan_anti_spoofing,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_10_ldv_param_131_1_default,
                                                    ldv_10_ldv_param_131_2_default);
    }
#line 12864
    goto ldv_61223;
    case_21: /* CIL Label */ 
    {
#line 12872
    ldv_dummy_resourceless_instance_callback_10_128(ldv_10_callback_set_vfta, ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_128_1_default,
                                                    ldv_10_ldv_param_128_2_default,
                                                    (int )ldv_10_ldv_param_128_3_default);
    }
#line 12878
    goto ldv_61223;
    case_22: /* CIL Label */ 
    {
#line 12886
    ldv_dummy_resourceless_instance_callback_10_125(ldv_10_callback_set_rxpba, ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_125_1_default,
                                                    ldv_10_ldv_param_125_2_default,
                                                    ldv_10_ldv_param_125_3_default);
    }
#line 12892
    goto ldv_61223;
    case_23: /* CIL Label */ 
    {
#line 12896
    tmp___4 = ldv_xmalloc(1UL);
#line 12896
    ldv_10_ldv_param_122_2_default = (unsigned char *)tmp___4;
#line 12901
    ldv_dummy_resourceless_instance_callback_10_122(ldv_10_callback_set_rar, ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_122_1_default,
                                                    ldv_10_ldv_param_122_2_default,
                                                    ldv_10_ldv_param_122_3_default,
                                                    ldv_10_ldv_param_122_4_default);
#line 12905
    ldv_free((void *)ldv_10_ldv_param_122_2_default);
    }
#line 12908
    goto ldv_61223;
    case_24: /* CIL Label */ 
    {
#line 12916
    ldv_dummy_resourceless_instance_callback_10_119(ldv_10_callback_set_mac_anti_spoofing,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_10_ldv_param_119_1_default,
                                                    ldv_10_ldv_param_119_2_default);
    }
#line 12922
    goto ldv_61223;
    case_25: /* CIL Label */ 
    {
#line 12927
    ldv_dummy_resourceless_instance_callback_10_118(ldv_10_callback_set_lan_id, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12930
    goto ldv_61223;
    case_26: /* CIL Label */ 
    {
#line 12938
    ldv_dummy_resourceless_instance_callback_10_115(ldv_10_callback_set_fw_drv_ver,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_10_ldv_param_115_1_default,
                                                    (int )ldv_10_ldv_param_115_2_default,
                                                    (int )ldv_10_ldv_param_115_3_default,
                                                    (int )ldv_10_ldv_param_115_4_default);
    }
#line 12944
    goto ldv_61223;
    case_27: /* CIL Label */ 
    {
#line 12949
    ldv_dummy_resourceless_instance_callback_10_114(ldv_10_callback_reset_hw, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12952
    goto ldv_61223;
    case_28: /* CIL Label */ 
    {
#line 12957
    ldv_dummy_resourceless_instance_callback_10_113(ldv_10_callback_reset, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 12960
    goto ldv_61223;
    case_29: /* CIL Label */ 
    {
#line 12968
    ldv_dummy_resourceless_instance_callback_10_110(ldv_10_callback_release_swfw_sync,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_10_ldv_param_110_1_default);
    }
#line 12974
    goto ldv_61223;
    case_30: /* CIL Label */ 
    {
#line 12978
    tmp___5 = ldv_xmalloc(2UL);
#line 12978
    ldv_10_ldv_param_107_3_default = (unsigned short *)tmp___5;
#line 12983
    ldv_dummy_resourceless_instance_callback_10_107(ldv_10_callback_read_reg_mdi,
                                                    ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_107_1_default,
                                                    ldv_10_ldv_param_107_2_default,
                                                    ldv_10_ldv_param_107_3_default);
#line 12987
    ldv_free((void *)ldv_10_ldv_param_107_3_default);
    }
#line 12990
    goto ldv_61223;
    case_31: /* CIL Label */ 
    {
#line 12994
    tmp___6 = ldv_xmalloc(2UL);
#line 12994
    ldv_10_ldv_param_104_3_default = (unsigned short *)tmp___6;
#line 12999
    ldv_dummy_resourceless_instance_callback_10_104(ldv_10_callback_read_reg, ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_104_1_default,
                                                    ldv_10_ldv_param_104_2_default,
                                                    ldv_10_ldv_param_104_3_default);
#line 13003
    ldv_free((void *)ldv_10_ldv_param_104_3_default);
    }
#line 13006
    goto ldv_61223;
    case_32: /* CIL Label */ 
    {
#line 13010
    tmp___7 = ldv_xmalloc(4UL);
#line 13010
    ldv_10_ldv_param_101_1_default = (unsigned int *)tmp___7;
#line 13015
    ldv_dummy_resourceless_instance_callback_10_101(ldv_10_callback_read_posted, ldv_10_container_struct_ixgbe_hw_ptr,
                                                    ldv_10_ldv_param_101_1_default,
                                                    (int )ldv_10_ldv_param_101_2_default,
                                                    (int )ldv_10_ldv_param_101_3_default);
#line 13019
    ldv_free((void *)ldv_10_ldv_param_101_1_default);
    }
#line 13022
    goto ldv_61223;
    case_33: /* CIL Label */ 
    {
#line 13026
    tmp___8 = ldv_xmalloc(1UL);
#line 13026
    ldv_10_ldv_param_98_2_default = (unsigned char *)tmp___8;
#line 13031
    ldv_dummy_resourceless_instance_callback_10_98(ldv_10_callback_read_i2c_sff8472,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_10_ldv_param_98_1_default,
                                                   ldv_10_ldv_param_98_2_default);
#line 13035
    ldv_free((void *)ldv_10_ldv_param_98_2_default);
    }
#line 13038
    goto ldv_61223;
    case_34: /* CIL Label */ 
    {
#line 13042
    tmp___9 = ldv_xmalloc(1UL);
#line 13042
    ldv_10_ldv_param_95_2_default = (unsigned char *)tmp___9;
#line 13047
    ldv_dummy_resourceless_instance_callback_10_95(ldv_10_callback_read_i2c_eeprom,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_10_ldv_param_95_1_default,
                                                   ldv_10_ldv_param_95_2_default);
#line 13051
    ldv_free((void *)ldv_10_ldv_param_95_2_default);
    }
#line 13054
    goto ldv_61223;
    case_35: /* CIL Label */ 
    {
#line 13058
    tmp___10 = ldv_xmalloc(1UL);
#line 13058
    ldv_10_ldv_param_92_3_default = (unsigned char *)tmp___10;
#line 13063
    ldv_dummy_resourceless_instance_callback_10_92(ldv_10_callback_read_i2c_byte,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_10_ldv_param_92_1_default,
                                                   (int )ldv_10_ldv_param_92_2_default,
                                                   ldv_10_ldv_param_92_3_default);
#line 13067
    ldv_free((void *)ldv_10_ldv_param_92_3_default);
    }
#line 13070
    goto ldv_61223;
    case_36: /* CIL Label */ 
    {
#line 13074
    tmp___11 = ldv_xmalloc(2UL);
#line 13074
    ldv_10_ldv_param_89_3_default = (unsigned short *)tmp___11;
#line 13079
    ldv_dummy_resourceless_instance_callback_10_89(ldv_10_callback_read_buffer, ldv_10_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_10_ldv_param_89_1_default,
                                                   (int )ldv_10_ldv_param_89_2_default,
                                                   ldv_10_ldv_param_89_3_default);
#line 13083
    ldv_free((void *)ldv_10_ldv_param_89_3_default);
    }
#line 13086
    goto ldv_61223;
    case_37: /* CIL Label */ 
    {
#line 13090
    tmp___12 = ldv_xmalloc(1UL);
#line 13090
    ldv_10_ldv_param_86_2_default = (unsigned char *)tmp___12;
#line 13095
    ldv_dummy_resourceless_instance_callback_10_86(ldv_10_callback_read_analog_reg8,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_86_1_default,
                                                   ldv_10_ldv_param_86_2_default);
#line 13099
    ldv_free((void *)ldv_10_ldv_param_86_2_default);
    }
#line 13102
    goto ldv_61223;
    case_38: /* CIL Label */ 
    {
#line 13106
    tmp___13 = ldv_xmalloc(4UL);
#line 13106
    ldv_10_ldv_param_83_1_default = (unsigned int *)tmp___13;
#line 13111
    ldv_dummy_resourceless_instance_callback_10_83(ldv_10_callback_read, ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_83_1_default,
                                                   (int )ldv_10_ldv_param_83_2_default,
                                                   (int )ldv_10_ldv_param_83_3_default);
#line 13115
    ldv_free((void *)ldv_10_ldv_param_83_1_default);
    }
#line 13118
    goto ldv_61223;
    case_39: /* CIL Label */ 
    {
#line 13123
    ldv_dummy_resourceless_instance_callback_10_82(ldv_10_callback_mng_fw_enabled,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13126
    goto ldv_61223;
    case_40: /* CIL Label */ 
    {
#line 13134
    ldv_dummy_resourceless_instance_callback_10_79(ldv_10_callback_led_on, ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_79_1_default);
    }
#line 13140
    goto ldv_61223;
    case_41: /* CIL Label */ 
    {
#line 13148
    ldv_dummy_resourceless_instance_callback_10_76(ldv_10_callback_led_off, ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_76_1_default);
    }
#line 13154
    goto ldv_61223;
    case_42: /* CIL Label */ 
    {
#line 13159
    ldv_dummy_resourceless_instance_callback_10_75(ldv_10_callback_init_uta_tables,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13162
    goto ldv_61223;
    case_43: /* CIL Label */ 
    {
#line 13167
    ldv_dummy_resourceless_instance_callback_10_74(ldv_10_callback_init_thermal_sensor_thresh,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13170
    goto ldv_61223;
    case_44: /* CIL Label */ 
    {
#line 13175
    ldv_dummy_resourceless_instance_callback_10_73(ldv_10_callback_init_rx_addrs,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13178
    goto ldv_61223;
    case_45: /* CIL Label */ 
    {
#line 13183
    ldv_dummy_resourceless_instance_callback_10_72(ldv_10_callback_init_params, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13186
    goto ldv_61223;
    case_46: /* CIL Label */ 
    {
#line 13191
    ldv_dummy_resourceless_instance_callback_10_71(ldv_10_callback_init_hw, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13194
    goto ldv_61223;
    case_47: /* CIL Label */ 
    {
#line 13199
    ldv_dummy_resourceless_instance_callback_10_70(ldv_10_callback_init, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13202
    goto ldv_61223;
    case_48: /* CIL Label */ 
    {
#line 13207
    ldv_dummy_resourceless_instance_callback_10_69(ldv_10_callback_identify_sfp, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13210
    goto ldv_61223;
    case_49: /* CIL Label */ 
    {
#line 13215
    ldv_dummy_resourceless_instance_callback_10_68(ldv_10_callback_identify, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13218
    goto ldv_61223;
    case_50: /* CIL Label */ 
    {
#line 13222
    tmp___14 = ldv_xmalloc(2UL);
#line 13222
    ldv_10_ldv_param_65_1_default = (unsigned short *)tmp___14;
#line 13223
    tmp___15 = ldv_xmalloc(2UL);
#line 13223
    ldv_10_ldv_param_65_2_default = (unsigned short *)tmp___15;
#line 13228
    ldv_dummy_resourceless_instance_callback_10_65(ldv_10_callback_get_wwn_prefix,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_65_1_default,
                                                   ldv_10_ldv_param_65_2_default);
#line 13232
    ldv_free((void *)ldv_10_ldv_param_65_1_default);
#line 13233
    ldv_free((void *)ldv_10_ldv_param_65_2_default);
    }
#line 13236
    goto ldv_61223;
    case_51: /* CIL Label */ 
    {
#line 13241
    ldv_dummy_resourceless_instance_callback_10_64(ldv_10_callback_get_thermal_sensor_data,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13244
    goto ldv_61223;
    case_52: /* CIL Label */ 
    {
#line 13249
    ldv_dummy_resourceless_instance_callback_10_63(ldv_10_callback_get_supported_physical_layer,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13252
    goto ldv_61223;
    case_53: /* CIL Label */ 
    {
#line 13256
    tmp___16 = ldv_xmalloc(1UL);
#line 13256
    ldv_10_ldv_param_60_1_default = (unsigned char *)tmp___16;
#line 13261
    ldv_dummy_resourceless_instance_callback_10_60(ldv_10_callback_get_san_mac_addr,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_60_1_default);
#line 13265
    ldv_free((void *)ldv_10_ldv_param_60_1_default);
    }
#line 13268
    goto ldv_61223;
    case_54: /* CIL Label */ 
    {
#line 13273
    ldv_dummy_resourceless_instance_callback_10_59(ldv_10_callback_get_media_type,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13276
    goto ldv_61223;
    case_55: /* CIL Label */ 
    {
#line 13280
    tmp___17 = ldv_xmalloc(1UL);
#line 13280
    ldv_10_ldv_param_56_1_default = (unsigned char *)tmp___17;
#line 13285
    ldv_dummy_resourceless_instance_callback_10_56(ldv_10_callback_get_mac_addr, ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_56_1_default);
#line 13289
    ldv_free((void *)ldv_10_ldv_param_56_1_default);
    }
#line 13292
    goto ldv_61223;
    case_56: /* CIL Label */ 
    {
#line 13296
    tmp___18 = ldv_xmalloc(4UL);
#line 13296
    ldv_10_ldv_param_53_1_default = (unsigned int *)tmp___18;
#line 13297
    tmp___19 = ldv_xmalloc(1UL);
#line 13297
    ldv_10_ldv_param_53_2_default = (_Bool *)tmp___19;
#line 13302
    ldv_dummy_resourceless_instance_callback_10_53(ldv_10_callback_get_link_capabilities,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_53_1_default,
                                                   ldv_10_ldv_param_53_2_default);
#line 13306
    ldv_free((void *)ldv_10_ldv_param_53_1_default);
#line 13307
    ldv_free((void *)ldv_10_ldv_param_53_2_default);
    }
#line 13310
    goto ldv_61223;
    case_57: /* CIL Label */ 
    {
#line 13315
    ldv_dummy_resourceless_instance_callback_10_52(ldv_10_callback_get_invariants,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13318
    goto ldv_61223;
    case_58: /* CIL Label */ 
    {
#line 13322
    tmp___20 = ldv_xmalloc(2UL);
#line 13322
    ldv_10_ldv_param_49_1_default = (unsigned short *)tmp___20;
#line 13327
    ldv_dummy_resourceless_instance_callback_10_49(ldv_10_callback_get_firmware_version,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_49_1_default);
#line 13331
    ldv_free((void *)ldv_10_ldv_param_49_1_default);
    }
#line 13334
    goto ldv_61223;
    case_59: /* CIL Label */ 
    {
#line 13338
    tmp___21 = ldv_xmalloc(2UL);
#line 13338
    ldv_10_ldv_param_46_1_default = (unsigned short *)tmp___21;
#line 13343
    ldv_dummy_resourceless_instance_callback_10_46(ldv_10_callback_get_device_caps,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_46_1_default);
#line 13347
    ldv_free((void *)ldv_10_ldv_param_46_1_default);
    }
#line 13350
    goto ldv_61223;
    case_60: /* CIL Label */ 
    {
#line 13355
    ldv_dummy_resourceless_instance_callback_10_45(ldv_10_callback_get_bus_info, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13358
    goto ldv_61223;
    case_61: /* CIL Label */ 
    {
#line 13363
    ldv_dummy_resourceless_instance_callback_10_44(ldv_10_callback_fc_enable, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13366
    goto ldv_61223;
    case_62: /* CIL Label */ 
    {
#line 13374
    ldv_dummy_resourceless_instance_callback_10_41(ldv_10_callback_enable_rx_dma,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_41_1_default);
    }
#line 13380
    goto ldv_61223;
    case_63: /* CIL Label */ 
    {
#line 13385
    ldv_dummy_resourceless_instance_callback_10_40(ldv_10_callback_enable_rx_buff,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13388
    goto ldv_61223;
    case_64: /* CIL Label */ 
    {
#line 13393
    ldv_dummy_resourceless_instance_callback_10_39(ldv_10_callback_enable_mc, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13396
    goto ldv_61223;
    case_65: /* CIL Label */ 
    {
#line 13401
    ldv_dummy_resourceless_instance_callback_10_38(ldv_10_callback_disable_rx_buff,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13404
    goto ldv_61223;
    case_66: /* CIL Label */ 
    {
#line 13409
    ldv_dummy_resourceless_instance_callback_10_37(ldv_10_callback_disable_mc, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13412
    goto ldv_61223;
    case_67: /* CIL Label */ 
    {
#line 13420
    ldv_dummy_resourceless_instance_callback_10_34(ldv_10_callback_clear_vmdq, ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_34_1_default,
                                                   ldv_10_ldv_param_34_2_default);
    }
#line 13426
    goto ldv_61223;
    case_68: /* CIL Label */ 
    {
#line 13431
    ldv_dummy_resourceless_instance_callback_10_33(ldv_10_callback_clear_vfta, ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13434
    goto ldv_61223;
    case_69: /* CIL Label */ 
    {
#line 13442
    ldv_dummy_resourceless_instance_callback_10_30(ldv_10_callback_clear_rar, ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_30_1_default);
    }
#line 13448
    goto ldv_61223;
    case_70: /* CIL Label */ 
    {
#line 13453
    ldv_dummy_resourceless_instance_callback_10_29(ldv_10_callback_clear_hw_cntrs,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13456
    goto ldv_61223;
    case_71: /* CIL Label */ 
    {
#line 13461
    ldv_dummy_resourceless_instance_callback_10_28(ldv_10_callback_check_overtemp,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13464
    goto ldv_61223;
    case_72: /* CIL Label */ 
    {
#line 13468
    tmp___22 = ldv_xmalloc(4UL);
#line 13468
    ldv_10_ldv_param_25_1_default = (unsigned int *)tmp___22;
#line 13469
    tmp___23 = ldv_xmalloc(1UL);
#line 13469
    ldv_10_ldv_param_25_2_default = (_Bool *)tmp___23;
#line 13474
    ldv_dummy_resourceless_instance_callback_10_25(ldv_10_callback_check_link, ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_25_1_default,
                                                   ldv_10_ldv_param_25_2_default,
                                                   (int )ldv_10_ldv_param_25_3_default);
#line 13478
    ldv_free((void *)ldv_10_ldv_param_25_1_default);
#line 13479
    ldv_free((void *)ldv_10_ldv_param_25_2_default);
    }
#line 13482
    goto ldv_61223;
    case_73: /* CIL Label */ 
    {
#line 13490
    ldv_dummy_resourceless_instance_callback_10_22(ldv_10_callback_check_for_rst,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_10_ldv_param_22_1_default);
    }
#line 13496
    goto ldv_61223;
    case_74: /* CIL Label */ 
    {
#line 13504
    ldv_dummy_resourceless_instance_callback_10_19(ldv_10_callback_check_for_msg,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_10_ldv_param_19_1_default);
    }
#line 13510
    goto ldv_61223;
    case_75: /* CIL Label */ 
    {
#line 13518
    ldv_dummy_resourceless_instance_callback_10_16(ldv_10_callback_check_for_ack,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_10_ldv_param_16_1_default);
    }
#line 13524
    goto ldv_61223;
    case_76: /* CIL Label */ 
    {
#line 13529
    ldv_dummy_resourceless_instance_callback_10_15(ldv_10_callback_calc_checksum,
                                                   ldv_10_container_struct_ixgbe_hw_ptr);
    }
#line 13532
    goto ldv_61223;
    case_77: /* CIL Label */ 
    {
#line 13540
    ldv_dummy_resourceless_instance_callback_10_12(ldv_10_callback_blink_led_stop,
                                                   ldv_10_container_struct_ixgbe_hw_ptr,
                                                   ldv_10_ldv_param_12_1_default);
    }
#line 13546
    goto ldv_61223;
    case_78: /* CIL Label */ 
    {
#line 13554
    ldv_dummy_resourceless_instance_callback_10_9(ldv_10_callback_blink_led_start,
                                                  ldv_10_container_struct_ixgbe_hw_ptr,
                                                  ldv_10_ldv_param_9_1_default);
    }
#line 13560
    goto ldv_61223;
    case_79: /* CIL Label */ 
    {
#line 13565
    ldv_dummy_resourceless_instance_callback_10_3(ldv_10_callback_acquire_swfw_sync,
                                                  ldv_10_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_10_ldv_param_3_1_default);
    }
#line 13568
    goto ldv_61223;
    switch_default: /* CIL Label */ 
    {
#line 13570
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_61223: ;
#line 13579
    goto ldv_call_10;
  } else {
#line 13587
    return;
  }
#line 13590
  return;
}
}
#line 13595 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_11(void *arg0 ) 
{ 
  int (*ldv_11_callback_acquire_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_11_callback_blink_led_start)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_11_callback_blink_led_stop)(struct ixgbe_hw * , unsigned int  ) ;
  unsigned short (*ldv_11_callback_calc_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_check_for_ack)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_11_callback_check_for_msg)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_11_callback_check_for_rst)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_11_callback_check_link)(struct ixgbe_hw * , unsigned int * , _Bool * ,
                                    _Bool  ) ;
  int (*ldv_11_callback_check_overtemp)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_clear_hw_cntrs)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_clear_rar)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_11_callback_clear_vfta)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_clear_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_11_callback_disable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_disable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_enable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_enable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_enable_rx_dma)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_11_callback_fc_enable)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_get_bus_info)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_get_device_caps)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_11_callback_get_firmware_version)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_11_callback_get_invariants)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_get_link_capabilities)(struct ixgbe_hw * , unsigned int * ,
                                               _Bool * ) ;
  int (*ldv_11_callback_get_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  enum ixgbe_media_type (*ldv_11_callback_get_media_type)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_get_san_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  unsigned int (*ldv_11_callback_get_supported_physical_layer)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_get_thermal_sensor_data)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_get_wwn_prefix)(struct ixgbe_hw * , unsigned short * , unsigned short * ) ;
  int (*ldv_11_callback_identify)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_identify_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_init)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_init_hw)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_init_params)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_init_rx_addrs)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_init_thermal_sensor_thresh)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_init_uta_tables)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_led_off)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_11_callback_led_on)(struct ixgbe_hw * , unsigned int  ) ;
  _Bool (*ldv_11_callback_mng_fw_enabled)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_read)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                              unsigned short  ) ;
  int (*ldv_11_callback_read_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char * ) ;
  int (*ldv_11_callback_read_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                     unsigned short * ) ;
  int (*ldv_11_callback_read_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                       unsigned char * ) ;
  int (*ldv_11_callback_read_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_11_callback_read_i2c_sff8472)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_11_callback_read_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                     unsigned short  ) ;
  int (*ldv_11_callback_read_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  unsigned short * ) ;
  int (*ldv_11_callback_read_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                      unsigned short * ) ;
  void (*ldv_11_callback_release_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_11_callback_reset)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_reset_hw)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_set_fw_drv_ver)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                        unsigned char  , unsigned char  ) ;
  void (*ldv_11_callback_set_lan_id)(struct ixgbe_hw * ) ;
  void (*ldv_11_callback_set_mac_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_11_callback_set_rar)(struct ixgbe_hw * , unsigned int  , unsigned char * ,
                                 unsigned int  , unsigned int  ) ;
  void (*ldv_11_callback_set_rxpba)(struct ixgbe_hw * , int  , unsigned int  , int  ) ;
  int (*ldv_11_callback_set_vfta)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  _Bool  ) ;
  void (*ldv_11_callback_set_vlan_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_11_callback_set_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_11_callback_set_vmdq_san_mac)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_11_callback_setup_link)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_setup_link_speed)(struct ixgbe_hw * , unsigned int  , _Bool  ) ;
  int (*ldv_11_callback_setup_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_start_hw)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_stop_adapter)(struct ixgbe_hw * ) ;
  void (*ldv_11_callback_stop_link_on_d3)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_update_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_11_callback_update_mc_addr_list)(struct ixgbe_hw * , struct net_device * ) ;
  int (*ldv_11_callback_validate_checksum)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_11_callback_write)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                               unsigned short  ) ;
  int (*ldv_11_callback_write_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char  ) ;
  int (*ldv_11_callback_write_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                      unsigned short * ) ;
  int (*ldv_11_callback_write_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                        unsigned char  ) ;
  int (*ldv_11_callback_write_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char  ) ;
  int (*ldv_11_callback_write_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                      unsigned short  ) ;
  int (*ldv_11_callback_write_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                   unsigned short  ) ;
  int (*ldv_11_callback_write_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                       unsigned short  ) ;
  struct ixgbe_hw *ldv_11_container_struct_ixgbe_hw_ptr ;
  struct net_device *ldv_11_container_struct_net_device_ptr ;
  unsigned int *ldv_11_ldv_param_101_1_default ;
  unsigned short ldv_11_ldv_param_101_2_default ;
  unsigned short ldv_11_ldv_param_101_3_default ;
  unsigned int ldv_11_ldv_param_104_1_default ;
  unsigned int ldv_11_ldv_param_104_2_default ;
  unsigned short *ldv_11_ldv_param_104_3_default ;
  unsigned int ldv_11_ldv_param_107_1_default ;
  unsigned int ldv_11_ldv_param_107_2_default ;
  unsigned short *ldv_11_ldv_param_107_3_default ;
  unsigned short ldv_11_ldv_param_110_1_default ;
  unsigned char ldv_11_ldv_param_115_1_default ;
  unsigned char ldv_11_ldv_param_115_2_default ;
  unsigned char ldv_11_ldv_param_115_3_default ;
  unsigned char ldv_11_ldv_param_115_4_default ;
  _Bool ldv_11_ldv_param_119_1_default ;
  int ldv_11_ldv_param_119_2_default ;
  unsigned int ldv_11_ldv_param_122_1_default ;
  unsigned char *ldv_11_ldv_param_122_2_default ;
  unsigned int ldv_11_ldv_param_122_3_default ;
  unsigned int ldv_11_ldv_param_122_4_default ;
  int ldv_11_ldv_param_125_1_default ;
  unsigned int ldv_11_ldv_param_125_2_default ;
  int ldv_11_ldv_param_125_3_default ;
  unsigned int ldv_11_ldv_param_128_1_default ;
  unsigned int ldv_11_ldv_param_128_2_default ;
  _Bool ldv_11_ldv_param_128_3_default ;
  unsigned int ldv_11_ldv_param_12_1_default ;
  _Bool ldv_11_ldv_param_131_1_default ;
  int ldv_11_ldv_param_131_2_default ;
  unsigned int ldv_11_ldv_param_134_1_default ;
  unsigned int ldv_11_ldv_param_134_2_default ;
  unsigned int ldv_11_ldv_param_137_1_default ;
  unsigned int ldv_11_ldv_param_141_1_default ;
  _Bool ldv_11_ldv_param_141_2_default ;
  unsigned short *ldv_11_ldv_param_150_1_default ;
  unsigned int *ldv_11_ldv_param_153_1_default ;
  unsigned short ldv_11_ldv_param_153_2_default ;
  unsigned short ldv_11_ldv_param_153_3_default ;
  unsigned int ldv_11_ldv_param_156_1_default ;
  unsigned char ldv_11_ldv_param_156_2_default ;
  unsigned short ldv_11_ldv_param_159_1_default ;
  unsigned short ldv_11_ldv_param_159_2_default ;
  unsigned short *ldv_11_ldv_param_159_3_default ;
  unsigned char ldv_11_ldv_param_162_1_default ;
  unsigned char ldv_11_ldv_param_162_2_default ;
  unsigned char ldv_11_ldv_param_162_3_default ;
  unsigned char ldv_11_ldv_param_165_1_default ;
  unsigned char ldv_11_ldv_param_165_2_default ;
  unsigned int *ldv_11_ldv_param_168_1_default ;
  unsigned short ldv_11_ldv_param_168_2_default ;
  unsigned short ldv_11_ldv_param_168_3_default ;
  unsigned short ldv_11_ldv_param_16_1_default ;
  unsigned int ldv_11_ldv_param_171_1_default ;
  unsigned int ldv_11_ldv_param_171_2_default ;
  unsigned short ldv_11_ldv_param_171_3_default ;
  unsigned int ldv_11_ldv_param_174_1_default ;
  unsigned int ldv_11_ldv_param_174_2_default ;
  unsigned short ldv_11_ldv_param_174_3_default ;
  unsigned short ldv_11_ldv_param_19_1_default ;
  unsigned short ldv_11_ldv_param_22_1_default ;
  unsigned int *ldv_11_ldv_param_25_1_default ;
  _Bool *ldv_11_ldv_param_25_2_default ;
  _Bool ldv_11_ldv_param_25_3_default ;
  unsigned int ldv_11_ldv_param_30_1_default ;
  unsigned int ldv_11_ldv_param_34_1_default ;
  unsigned int ldv_11_ldv_param_34_2_default ;
  unsigned short ldv_11_ldv_param_3_1_default ;
  unsigned int ldv_11_ldv_param_41_1_default ;
  unsigned short *ldv_11_ldv_param_46_1_default ;
  unsigned short *ldv_11_ldv_param_49_1_default ;
  unsigned int *ldv_11_ldv_param_53_1_default ;
  _Bool *ldv_11_ldv_param_53_2_default ;
  unsigned char *ldv_11_ldv_param_56_1_default ;
  unsigned char *ldv_11_ldv_param_60_1_default ;
  unsigned short *ldv_11_ldv_param_65_1_default ;
  unsigned short *ldv_11_ldv_param_65_2_default ;
  unsigned int ldv_11_ldv_param_76_1_default ;
  unsigned int ldv_11_ldv_param_79_1_default ;
  unsigned int *ldv_11_ldv_param_83_1_default ;
  unsigned short ldv_11_ldv_param_83_2_default ;
  unsigned short ldv_11_ldv_param_83_3_default ;
  unsigned int ldv_11_ldv_param_86_1_default ;
  unsigned char *ldv_11_ldv_param_86_2_default ;
  unsigned short ldv_11_ldv_param_89_1_default ;
  unsigned short ldv_11_ldv_param_89_2_default ;
  unsigned short *ldv_11_ldv_param_89_3_default ;
  unsigned char ldv_11_ldv_param_92_1_default ;
  unsigned char ldv_11_ldv_param_92_2_default ;
  unsigned char *ldv_11_ldv_param_92_3_default ;
  unsigned char ldv_11_ldv_param_95_1_default ;
  unsigned char *ldv_11_ldv_param_95_2_default ;
  unsigned char ldv_11_ldv_param_98_1_default ;
  unsigned char *ldv_11_ldv_param_98_2_default ;
  unsigned int ldv_11_ldv_param_9_1_default ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;

  {
#line 13781
  goto ldv_call_11;
#line 13783
  return;
  ldv_call_11: 
  {
#line 13789
  tmp___24 = ldv_undef_int();
  }
#line 13789
  if (tmp___24 != 0) {
    {
#line 13793
    tmp = ldv_undef_int();
    }
    {
#line 13794
    if (tmp == 1) {
#line 13794
      goto case_1;
    } else {

    }
#line 13808
    if (tmp == 2) {
#line 13808
      goto case_2;
    } else {

    }
#line 13822
    if (tmp == 3) {
#line 13822
      goto case_3;
    } else {

    }
#line 13838
    if (tmp == 4) {
#line 13838
      goto case_4;
    } else {

    }
#line 13852
    if (tmp == 5) {
#line 13852
      goto case_5;
    } else {

    }
#line 13866
    if (tmp == 6) {
#line 13866
      goto case_6;
    } else {

    }
#line 13882
    if (tmp == 7) {
#line 13882
      goto case_7;
    } else {

    }
#line 13896
    if (tmp == 8) {
#line 13896
      goto case_8;
    } else {

    }
#line 13912
    if (tmp == 9) {
#line 13912
      goto case_9;
    } else {

    }
#line 13928
    if (tmp == 10) {
#line 13928
      goto case_10;
    } else {

    }
#line 13936
    if (tmp == 11) {
#line 13936
      goto case_11;
    } else {

    }
#line 13944
    if (tmp == 12) {
#line 13944
      goto case_12;
    } else {

    }
#line 13952
    if (tmp == 13) {
#line 13952
      goto case_13;
    } else {

    }
#line 13960
    if (tmp == 14) {
#line 13960
      goto case_14;
    } else {

    }
#line 13968
    if (tmp == 15) {
#line 13968
      goto case_15;
    } else {

    }
#line 13976
    if (tmp == 16) {
#line 13976
      goto case_16;
    } else {

    }
#line 13990
    if (tmp == 17) {
#line 13990
      goto case_17;
    } else {

    }
#line 13998
    if (tmp == 18) {
#line 13998
      goto case_18;
    } else {

    }
#line 14012
    if (tmp == 19) {
#line 14012
      goto case_19;
    } else {

    }
#line 14026
    if (tmp == 20) {
#line 14026
      goto case_20;
    } else {

    }
#line 14040
    if (tmp == 21) {
#line 14040
      goto case_21;
    } else {

    }
#line 14054
    if (tmp == 22) {
#line 14054
      goto case_22;
    } else {

    }
#line 14068
    if (tmp == 23) {
#line 14068
      goto case_23;
    } else {

    }
#line 14084
    if (tmp == 24) {
#line 14084
      goto case_24;
    } else {

    }
#line 14098
    if (tmp == 25) {
#line 14098
      goto case_25;
    } else {

    }
#line 14106
    if (tmp == 26) {
#line 14106
      goto case_26;
    } else {

    }
#line 14120
    if (tmp == 27) {
#line 14120
      goto case_27;
    } else {

    }
#line 14128
    if (tmp == 28) {
#line 14128
      goto case_28;
    } else {

    }
#line 14136
    if (tmp == 29) {
#line 14136
      goto case_29;
    } else {

    }
#line 14150
    if (tmp == 30) {
#line 14150
      goto case_30;
    } else {

    }
#line 14166
    if (tmp == 31) {
#line 14166
      goto case_31;
    } else {

    }
#line 14182
    if (tmp == 32) {
#line 14182
      goto case_32;
    } else {

    }
#line 14198
    if (tmp == 33) {
#line 14198
      goto case_33;
    } else {

    }
#line 14214
    if (tmp == 34) {
#line 14214
      goto case_34;
    } else {

    }
#line 14230
    if (tmp == 35) {
#line 14230
      goto case_35;
    } else {

    }
#line 14246
    if (tmp == 36) {
#line 14246
      goto case_36;
    } else {

    }
#line 14262
    if (tmp == 37) {
#line 14262
      goto case_37;
    } else {

    }
#line 14278
    if (tmp == 38) {
#line 14278
      goto case_38;
    } else {

    }
#line 14294
    if (tmp == 39) {
#line 14294
      goto case_39;
    } else {

    }
#line 14302
    if (tmp == 40) {
#line 14302
      goto case_40;
    } else {

    }
#line 14316
    if (tmp == 41) {
#line 14316
      goto case_41;
    } else {

    }
#line 14330
    if (tmp == 42) {
#line 14330
      goto case_42;
    } else {

    }
#line 14338
    if (tmp == 43) {
#line 14338
      goto case_43;
    } else {

    }
#line 14346
    if (tmp == 44) {
#line 14346
      goto case_44;
    } else {

    }
#line 14354
    if (tmp == 45) {
#line 14354
      goto case_45;
    } else {

    }
#line 14362
    if (tmp == 46) {
#line 14362
      goto case_46;
    } else {

    }
#line 14370
    if (tmp == 47) {
#line 14370
      goto case_47;
    } else {

    }
#line 14378
    if (tmp == 48) {
#line 14378
      goto case_48;
    } else {

    }
#line 14386
    if (tmp == 49) {
#line 14386
      goto case_49;
    } else {

    }
#line 14394
    if (tmp == 50) {
#line 14394
      goto case_50;
    } else {

    }
#line 14412
    if (tmp == 51) {
#line 14412
      goto case_51;
    } else {

    }
#line 14420
    if (tmp == 52) {
#line 14420
      goto case_52;
    } else {

    }
#line 14428
    if (tmp == 53) {
#line 14428
      goto case_53;
    } else {

    }
#line 14444
    if (tmp == 54) {
#line 14444
      goto case_54;
    } else {

    }
#line 14452
    if (tmp == 55) {
#line 14452
      goto case_55;
    } else {

    }
#line 14468
    if (tmp == 56) {
#line 14468
      goto case_56;
    } else {

    }
#line 14486
    if (tmp == 57) {
#line 14486
      goto case_57;
    } else {

    }
#line 14494
    if (tmp == 58) {
#line 14494
      goto case_58;
    } else {

    }
#line 14510
    if (tmp == 59) {
#line 14510
      goto case_59;
    } else {

    }
#line 14526
    if (tmp == 60) {
#line 14526
      goto case_60;
    } else {

    }
#line 14534
    if (tmp == 61) {
#line 14534
      goto case_61;
    } else {

    }
#line 14542
    if (tmp == 62) {
#line 14542
      goto case_62;
    } else {

    }
#line 14556
    if (tmp == 63) {
#line 14556
      goto case_63;
    } else {

    }
#line 14564
    if (tmp == 64) {
#line 14564
      goto case_64;
    } else {

    }
#line 14572
    if (tmp == 65) {
#line 14572
      goto case_65;
    } else {

    }
#line 14580
    if (tmp == 66) {
#line 14580
      goto case_66;
    } else {

    }
#line 14588
    if (tmp == 67) {
#line 14588
      goto case_67;
    } else {

    }
#line 14602
    if (tmp == 68) {
#line 14602
      goto case_68;
    } else {

    }
#line 14610
    if (tmp == 69) {
#line 14610
      goto case_69;
    } else {

    }
#line 14624
    if (tmp == 70) {
#line 14624
      goto case_70;
    } else {

    }
#line 14632
    if (tmp == 71) {
#line 14632
      goto case_71;
    } else {

    }
#line 14640
    if (tmp == 72) {
#line 14640
      goto case_72;
    } else {

    }
#line 14658
    if (tmp == 73) {
#line 14658
      goto case_73;
    } else {

    }
#line 14672
    if (tmp == 74) {
#line 14672
      goto case_74;
    } else {

    }
#line 14686
    if (tmp == 75) {
#line 14686
      goto case_75;
    } else {

    }
#line 14700
    if (tmp == 76) {
#line 14700
      goto case_76;
    } else {

    }
#line 14708
    if (tmp == 77) {
#line 14708
      goto case_77;
    } else {

    }
#line 14722
    if (tmp == 78) {
#line 14722
      goto case_78;
    } else {

    }
#line 14736
    if (tmp == 79) {
#line 14736
      goto case_79;
    } else {

    }
#line 14744
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 13800
    ldv_dummy_resourceless_instance_callback_11_174(ldv_11_callback_write_reg_mdi,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_174_1_default,
                                                    ldv_11_ldv_param_174_2_default,
                                                    (int )ldv_11_ldv_param_174_3_default);
    }
#line 13806
    goto ldv_61657;
    case_2: /* CIL Label */ 
    {
#line 13814
    ldv_dummy_resourceless_instance_callback_11_171(ldv_11_callback_write_reg, ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_171_1_default,
                                                    ldv_11_ldv_param_171_2_default,
                                                    (int )ldv_11_ldv_param_171_3_default);
    }
#line 13820
    goto ldv_61657;
    case_3: /* CIL Label */ 
    {
#line 13824
    tmp___0 = ldv_xmalloc(4UL);
#line 13824
    ldv_11_ldv_param_168_1_default = (unsigned int *)tmp___0;
#line 13829
    ldv_dummy_resourceless_instance_callback_11_168(ldv_11_callback_write_posted,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_168_1_default,
                                                    (int )ldv_11_ldv_param_168_2_default,
                                                    (int )ldv_11_ldv_param_168_3_default);
#line 13833
    ldv_free((void *)ldv_11_ldv_param_168_1_default);
    }
#line 13836
    goto ldv_61657;
    case_4: /* CIL Label */ 
    {
#line 13844
    ldv_dummy_resourceless_instance_callback_11_165(ldv_11_callback_write_i2c_eeprom,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_11_ldv_param_165_1_default,
                                                    (int )ldv_11_ldv_param_165_2_default);
    }
#line 13850
    goto ldv_61657;
    case_5: /* CIL Label */ 
    {
#line 13858
    ldv_dummy_resourceless_instance_callback_11_162(ldv_11_callback_write_i2c_byte,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_11_ldv_param_162_1_default,
                                                    (int )ldv_11_ldv_param_162_2_default,
                                                    (int )ldv_11_ldv_param_162_3_default);
    }
#line 13864
    goto ldv_61657;
    case_6: /* CIL Label */ 
    {
#line 13868
    tmp___1 = ldv_xmalloc(2UL);
#line 13868
    ldv_11_ldv_param_159_3_default = (unsigned short *)tmp___1;
#line 13873
    ldv_dummy_resourceless_instance_callback_11_159(ldv_11_callback_write_buffer,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_11_ldv_param_159_1_default,
                                                    (int )ldv_11_ldv_param_159_2_default,
                                                    ldv_11_ldv_param_159_3_default);
#line 13877
    ldv_free((void *)ldv_11_ldv_param_159_3_default);
    }
#line 13880
    goto ldv_61657;
    case_7: /* CIL Label */ 
    {
#line 13888
    ldv_dummy_resourceless_instance_callback_11_156(ldv_11_callback_write_analog_reg8,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_156_1_default,
                                                    (int )ldv_11_ldv_param_156_2_default);
    }
#line 13894
    goto ldv_61657;
    case_8: /* CIL Label */ 
    {
#line 13898
    tmp___2 = ldv_xmalloc(4UL);
#line 13898
    ldv_11_ldv_param_153_1_default = (unsigned int *)tmp___2;
#line 13903
    ldv_dummy_resourceless_instance_callback_11_153(ldv_11_callback_write, ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_153_1_default,
                                                    (int )ldv_11_ldv_param_153_2_default,
                                                    (int )ldv_11_ldv_param_153_3_default);
#line 13907
    ldv_free((void *)ldv_11_ldv_param_153_1_default);
    }
#line 13910
    goto ldv_61657;
    case_9: /* CIL Label */ 
    {
#line 13914
    tmp___3 = ldv_xmalloc(2UL);
#line 13914
    ldv_11_ldv_param_150_1_default = (unsigned short *)tmp___3;
#line 13919
    ldv_dummy_resourceless_instance_callback_11_150(ldv_11_callback_validate_checksum,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_150_1_default);
#line 13923
    ldv_free((void *)ldv_11_ldv_param_150_1_default);
    }
#line 13926
    goto ldv_61657;
    case_10: /* CIL Label */ 
    {
#line 13931
    ldv_dummy_resourceless_instance_callback_11_149(ldv_11_callback_update_mc_addr_list,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_container_struct_net_device_ptr);
    }
#line 13934
    goto ldv_61657;
    case_11: /* CIL Label */ 
    {
#line 13939
    ldv_dummy_resourceless_instance_callback_11_148(ldv_11_callback_update_checksum,
                                                    ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 13942
    goto ldv_61657;
    case_12: /* CIL Label */ 
    {
#line 13947
    ldv_dummy_resourceless_instance_callback_11_147(ldv_11_callback_stop_link_on_d3,
                                                    ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 13950
    goto ldv_61657;
    case_13: /* CIL Label */ 
    {
#line 13955
    ldv_dummy_resourceless_instance_callback_11_146(ldv_11_callback_stop_adapter,
                                                    ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 13958
    goto ldv_61657;
    case_14: /* CIL Label */ 
    {
#line 13963
    ldv_dummy_resourceless_instance_callback_11_145(ldv_11_callback_start_hw, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 13966
    goto ldv_61657;
    case_15: /* CIL Label */ 
    {
#line 13971
    ldv_dummy_resourceless_instance_callback_11_144(ldv_11_callback_setup_sfp, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 13974
    goto ldv_61657;
    case_16: /* CIL Label */ 
    {
#line 13982
    ldv_dummy_resourceless_instance_callback_11_141(ldv_11_callback_setup_link_speed,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_141_1_default,
                                                    (int )ldv_11_ldv_param_141_2_default);
    }
#line 13988
    goto ldv_61657;
    case_17: /* CIL Label */ 
    {
#line 13993
    ldv_dummy_resourceless_instance_callback_11_140(ldv_11_callback_setup_link, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 13996
    goto ldv_61657;
    case_18: /* CIL Label */ 
    {
#line 14004
    ldv_dummy_resourceless_instance_callback_11_137(ldv_11_callback_set_vmdq_san_mac,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_137_1_default);
    }
#line 14010
    goto ldv_61657;
    case_19: /* CIL Label */ 
    {
#line 14018
    ldv_dummy_resourceless_instance_callback_11_134(ldv_11_callback_set_vmdq, ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_134_1_default,
                                                    ldv_11_ldv_param_134_2_default);
    }
#line 14024
    goto ldv_61657;
    case_20: /* CIL Label */ 
    {
#line 14032
    ldv_dummy_resourceless_instance_callback_11_131(ldv_11_callback_set_vlan_anti_spoofing,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_11_ldv_param_131_1_default,
                                                    ldv_11_ldv_param_131_2_default);
    }
#line 14038
    goto ldv_61657;
    case_21: /* CIL Label */ 
    {
#line 14046
    ldv_dummy_resourceless_instance_callback_11_128(ldv_11_callback_set_vfta, ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_128_1_default,
                                                    ldv_11_ldv_param_128_2_default,
                                                    (int )ldv_11_ldv_param_128_3_default);
    }
#line 14052
    goto ldv_61657;
    case_22: /* CIL Label */ 
    {
#line 14060
    ldv_dummy_resourceless_instance_callback_11_125(ldv_11_callback_set_rxpba, ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_125_1_default,
                                                    ldv_11_ldv_param_125_2_default,
                                                    ldv_11_ldv_param_125_3_default);
    }
#line 14066
    goto ldv_61657;
    case_23: /* CIL Label */ 
    {
#line 14070
    tmp___4 = ldv_xmalloc(1UL);
#line 14070
    ldv_11_ldv_param_122_2_default = (unsigned char *)tmp___4;
#line 14075
    ldv_dummy_resourceless_instance_callback_11_122(ldv_11_callback_set_rar, ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_122_1_default,
                                                    ldv_11_ldv_param_122_2_default,
                                                    ldv_11_ldv_param_122_3_default,
                                                    ldv_11_ldv_param_122_4_default);
#line 14079
    ldv_free((void *)ldv_11_ldv_param_122_2_default);
    }
#line 14082
    goto ldv_61657;
    case_24: /* CIL Label */ 
    {
#line 14090
    ldv_dummy_resourceless_instance_callback_11_119(ldv_11_callback_set_mac_anti_spoofing,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_11_ldv_param_119_1_default,
                                                    ldv_11_ldv_param_119_2_default);
    }
#line 14096
    goto ldv_61657;
    case_25: /* CIL Label */ 
    {
#line 14101
    ldv_dummy_resourceless_instance_callback_11_118(ldv_11_callback_set_lan_id, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14104
    goto ldv_61657;
    case_26: /* CIL Label */ 
    {
#line 14112
    ldv_dummy_resourceless_instance_callback_11_115(ldv_11_callback_set_fw_drv_ver,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_11_ldv_param_115_1_default,
                                                    (int )ldv_11_ldv_param_115_2_default,
                                                    (int )ldv_11_ldv_param_115_3_default,
                                                    (int )ldv_11_ldv_param_115_4_default);
    }
#line 14118
    goto ldv_61657;
    case_27: /* CIL Label */ 
    {
#line 14123
    ldv_dummy_resourceless_instance_callback_11_114(ldv_11_callback_reset_hw, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14126
    goto ldv_61657;
    case_28: /* CIL Label */ 
    {
#line 14131
    ldv_dummy_resourceless_instance_callback_11_113(ldv_11_callback_reset, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14134
    goto ldv_61657;
    case_29: /* CIL Label */ 
    {
#line 14142
    ldv_dummy_resourceless_instance_callback_11_110(ldv_11_callback_release_swfw_sync,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_11_ldv_param_110_1_default);
    }
#line 14148
    goto ldv_61657;
    case_30: /* CIL Label */ 
    {
#line 14152
    tmp___5 = ldv_xmalloc(2UL);
#line 14152
    ldv_11_ldv_param_107_3_default = (unsigned short *)tmp___5;
#line 14157
    ldv_dummy_resourceless_instance_callback_11_107(ldv_11_callback_read_reg_mdi,
                                                    ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_107_1_default,
                                                    ldv_11_ldv_param_107_2_default,
                                                    ldv_11_ldv_param_107_3_default);
#line 14161
    ldv_free((void *)ldv_11_ldv_param_107_3_default);
    }
#line 14164
    goto ldv_61657;
    case_31: /* CIL Label */ 
    {
#line 14168
    tmp___6 = ldv_xmalloc(2UL);
#line 14168
    ldv_11_ldv_param_104_3_default = (unsigned short *)tmp___6;
#line 14173
    ldv_dummy_resourceless_instance_callback_11_104(ldv_11_callback_read_reg, ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_104_1_default,
                                                    ldv_11_ldv_param_104_2_default,
                                                    ldv_11_ldv_param_104_3_default);
#line 14177
    ldv_free((void *)ldv_11_ldv_param_104_3_default);
    }
#line 14180
    goto ldv_61657;
    case_32: /* CIL Label */ 
    {
#line 14184
    tmp___7 = ldv_xmalloc(4UL);
#line 14184
    ldv_11_ldv_param_101_1_default = (unsigned int *)tmp___7;
#line 14189
    ldv_dummy_resourceless_instance_callback_11_101(ldv_11_callback_read_posted, ldv_11_container_struct_ixgbe_hw_ptr,
                                                    ldv_11_ldv_param_101_1_default,
                                                    (int )ldv_11_ldv_param_101_2_default,
                                                    (int )ldv_11_ldv_param_101_3_default);
#line 14193
    ldv_free((void *)ldv_11_ldv_param_101_1_default);
    }
#line 14196
    goto ldv_61657;
    case_33: /* CIL Label */ 
    {
#line 14200
    tmp___8 = ldv_xmalloc(1UL);
#line 14200
    ldv_11_ldv_param_98_2_default = (unsigned char *)tmp___8;
#line 14205
    ldv_dummy_resourceless_instance_callback_11_98(ldv_11_callback_read_i2c_sff8472,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_11_ldv_param_98_1_default,
                                                   ldv_11_ldv_param_98_2_default);
#line 14209
    ldv_free((void *)ldv_11_ldv_param_98_2_default);
    }
#line 14212
    goto ldv_61657;
    case_34: /* CIL Label */ 
    {
#line 14216
    tmp___9 = ldv_xmalloc(1UL);
#line 14216
    ldv_11_ldv_param_95_2_default = (unsigned char *)tmp___9;
#line 14221
    ldv_dummy_resourceless_instance_callback_11_95(ldv_11_callback_read_i2c_eeprom,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_11_ldv_param_95_1_default,
                                                   ldv_11_ldv_param_95_2_default);
#line 14225
    ldv_free((void *)ldv_11_ldv_param_95_2_default);
    }
#line 14228
    goto ldv_61657;
    case_35: /* CIL Label */ 
    {
#line 14232
    tmp___10 = ldv_xmalloc(1UL);
#line 14232
    ldv_11_ldv_param_92_3_default = (unsigned char *)tmp___10;
#line 14237
    ldv_dummy_resourceless_instance_callback_11_92(ldv_11_callback_read_i2c_byte,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_11_ldv_param_92_1_default,
                                                   (int )ldv_11_ldv_param_92_2_default,
                                                   ldv_11_ldv_param_92_3_default);
#line 14241
    ldv_free((void *)ldv_11_ldv_param_92_3_default);
    }
#line 14244
    goto ldv_61657;
    case_36: /* CIL Label */ 
    {
#line 14248
    tmp___11 = ldv_xmalloc(2UL);
#line 14248
    ldv_11_ldv_param_89_3_default = (unsigned short *)tmp___11;
#line 14253
    ldv_dummy_resourceless_instance_callback_11_89(ldv_11_callback_read_buffer, ldv_11_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_11_ldv_param_89_1_default,
                                                   (int )ldv_11_ldv_param_89_2_default,
                                                   ldv_11_ldv_param_89_3_default);
#line 14257
    ldv_free((void *)ldv_11_ldv_param_89_3_default);
    }
#line 14260
    goto ldv_61657;
    case_37: /* CIL Label */ 
    {
#line 14264
    tmp___12 = ldv_xmalloc(1UL);
#line 14264
    ldv_11_ldv_param_86_2_default = (unsigned char *)tmp___12;
#line 14269
    ldv_dummy_resourceless_instance_callback_11_86(ldv_11_callback_read_analog_reg8,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_86_1_default,
                                                   ldv_11_ldv_param_86_2_default);
#line 14273
    ldv_free((void *)ldv_11_ldv_param_86_2_default);
    }
#line 14276
    goto ldv_61657;
    case_38: /* CIL Label */ 
    {
#line 14280
    tmp___13 = ldv_xmalloc(4UL);
#line 14280
    ldv_11_ldv_param_83_1_default = (unsigned int *)tmp___13;
#line 14285
    ldv_dummy_resourceless_instance_callback_11_83(ldv_11_callback_read, ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_83_1_default,
                                                   (int )ldv_11_ldv_param_83_2_default,
                                                   (int )ldv_11_ldv_param_83_3_default);
#line 14289
    ldv_free((void *)ldv_11_ldv_param_83_1_default);
    }
#line 14292
    goto ldv_61657;
    case_39: /* CIL Label */ 
    {
#line 14297
    ldv_dummy_resourceless_instance_callback_11_82(ldv_11_callback_mng_fw_enabled,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14300
    goto ldv_61657;
    case_40: /* CIL Label */ 
    {
#line 14308
    ldv_dummy_resourceless_instance_callback_11_79(ldv_11_callback_led_on, ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_79_1_default);
    }
#line 14314
    goto ldv_61657;
    case_41: /* CIL Label */ 
    {
#line 14322
    ldv_dummy_resourceless_instance_callback_11_76(ldv_11_callback_led_off, ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_76_1_default);
    }
#line 14328
    goto ldv_61657;
    case_42: /* CIL Label */ 
    {
#line 14333
    ldv_dummy_resourceless_instance_callback_11_75(ldv_11_callback_init_uta_tables,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14336
    goto ldv_61657;
    case_43: /* CIL Label */ 
    {
#line 14341
    ldv_dummy_resourceless_instance_callback_11_74(ldv_11_callback_init_thermal_sensor_thresh,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14344
    goto ldv_61657;
    case_44: /* CIL Label */ 
    {
#line 14349
    ldv_dummy_resourceless_instance_callback_11_73(ldv_11_callback_init_rx_addrs,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14352
    goto ldv_61657;
    case_45: /* CIL Label */ 
    {
#line 14357
    ldv_dummy_resourceless_instance_callback_11_72(ldv_11_callback_init_params, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14360
    goto ldv_61657;
    case_46: /* CIL Label */ 
    {
#line 14365
    ldv_dummy_resourceless_instance_callback_11_71(ldv_11_callback_init_hw, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14368
    goto ldv_61657;
    case_47: /* CIL Label */ 
    {
#line 14373
    ldv_dummy_resourceless_instance_callback_11_70(ldv_11_callback_init, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14376
    goto ldv_61657;
    case_48: /* CIL Label */ 
    {
#line 14381
    ldv_dummy_resourceless_instance_callback_11_69(ldv_11_callback_identify_sfp, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14384
    goto ldv_61657;
    case_49: /* CIL Label */ 
    {
#line 14389
    ldv_dummy_resourceless_instance_callback_11_68(ldv_11_callback_identify, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14392
    goto ldv_61657;
    case_50: /* CIL Label */ 
    {
#line 14396
    tmp___14 = ldv_xmalloc(2UL);
#line 14396
    ldv_11_ldv_param_65_1_default = (unsigned short *)tmp___14;
#line 14397
    tmp___15 = ldv_xmalloc(2UL);
#line 14397
    ldv_11_ldv_param_65_2_default = (unsigned short *)tmp___15;
#line 14402
    ldv_dummy_resourceless_instance_callback_11_65(ldv_11_callback_get_wwn_prefix,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_65_1_default,
                                                   ldv_11_ldv_param_65_2_default);
#line 14406
    ldv_free((void *)ldv_11_ldv_param_65_1_default);
#line 14407
    ldv_free((void *)ldv_11_ldv_param_65_2_default);
    }
#line 14410
    goto ldv_61657;
    case_51: /* CIL Label */ 
    {
#line 14415
    ldv_dummy_resourceless_instance_callback_11_64(ldv_11_callback_get_thermal_sensor_data,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14418
    goto ldv_61657;
    case_52: /* CIL Label */ 
    {
#line 14423
    ldv_dummy_resourceless_instance_callback_11_63(ldv_11_callback_get_supported_physical_layer,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14426
    goto ldv_61657;
    case_53: /* CIL Label */ 
    {
#line 14430
    tmp___16 = ldv_xmalloc(1UL);
#line 14430
    ldv_11_ldv_param_60_1_default = (unsigned char *)tmp___16;
#line 14435
    ldv_dummy_resourceless_instance_callback_11_60(ldv_11_callback_get_san_mac_addr,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_60_1_default);
#line 14439
    ldv_free((void *)ldv_11_ldv_param_60_1_default);
    }
#line 14442
    goto ldv_61657;
    case_54: /* CIL Label */ 
    {
#line 14447
    ldv_dummy_resourceless_instance_callback_11_59(ldv_11_callback_get_media_type,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14450
    goto ldv_61657;
    case_55: /* CIL Label */ 
    {
#line 14454
    tmp___17 = ldv_xmalloc(1UL);
#line 14454
    ldv_11_ldv_param_56_1_default = (unsigned char *)tmp___17;
#line 14459
    ldv_dummy_resourceless_instance_callback_11_56(ldv_11_callback_get_mac_addr, ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_56_1_default);
#line 14463
    ldv_free((void *)ldv_11_ldv_param_56_1_default);
    }
#line 14466
    goto ldv_61657;
    case_56: /* CIL Label */ 
    {
#line 14470
    tmp___18 = ldv_xmalloc(4UL);
#line 14470
    ldv_11_ldv_param_53_1_default = (unsigned int *)tmp___18;
#line 14471
    tmp___19 = ldv_xmalloc(1UL);
#line 14471
    ldv_11_ldv_param_53_2_default = (_Bool *)tmp___19;
#line 14476
    ldv_dummy_resourceless_instance_callback_11_53(ldv_11_callback_get_link_capabilities,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_53_1_default,
                                                   ldv_11_ldv_param_53_2_default);
#line 14480
    ldv_free((void *)ldv_11_ldv_param_53_1_default);
#line 14481
    ldv_free((void *)ldv_11_ldv_param_53_2_default);
    }
#line 14484
    goto ldv_61657;
    case_57: /* CIL Label */ 
    {
#line 14489
    ldv_dummy_resourceless_instance_callback_11_52(ldv_11_callback_get_invariants,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14492
    goto ldv_61657;
    case_58: /* CIL Label */ 
    {
#line 14496
    tmp___20 = ldv_xmalloc(2UL);
#line 14496
    ldv_11_ldv_param_49_1_default = (unsigned short *)tmp___20;
#line 14501
    ldv_dummy_resourceless_instance_callback_11_49(ldv_11_callback_get_firmware_version,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_49_1_default);
#line 14505
    ldv_free((void *)ldv_11_ldv_param_49_1_default);
    }
#line 14508
    goto ldv_61657;
    case_59: /* CIL Label */ 
    {
#line 14512
    tmp___21 = ldv_xmalloc(2UL);
#line 14512
    ldv_11_ldv_param_46_1_default = (unsigned short *)tmp___21;
#line 14517
    ldv_dummy_resourceless_instance_callback_11_46(ldv_11_callback_get_device_caps,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_46_1_default);
#line 14521
    ldv_free((void *)ldv_11_ldv_param_46_1_default);
    }
#line 14524
    goto ldv_61657;
    case_60: /* CIL Label */ 
    {
#line 14529
    ldv_dummy_resourceless_instance_callback_11_45(ldv_11_callback_get_bus_info, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14532
    goto ldv_61657;
    case_61: /* CIL Label */ 
    {
#line 14537
    ldv_dummy_resourceless_instance_callback_11_44(ldv_11_callback_fc_enable, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14540
    goto ldv_61657;
    case_62: /* CIL Label */ 
    {
#line 14548
    ldv_dummy_resourceless_instance_callback_11_41(ldv_11_callback_enable_rx_dma,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_41_1_default);
    }
#line 14554
    goto ldv_61657;
    case_63: /* CIL Label */ 
    {
#line 14559
    ldv_dummy_resourceless_instance_callback_11_40(ldv_11_callback_enable_rx_buff,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14562
    goto ldv_61657;
    case_64: /* CIL Label */ 
    {
#line 14567
    ldv_dummy_resourceless_instance_callback_11_39(ldv_11_callback_enable_mc, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14570
    goto ldv_61657;
    case_65: /* CIL Label */ 
    {
#line 14575
    ldv_dummy_resourceless_instance_callback_11_38(ldv_11_callback_disable_rx_buff,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14578
    goto ldv_61657;
    case_66: /* CIL Label */ 
    {
#line 14583
    ldv_dummy_resourceless_instance_callback_11_37(ldv_11_callback_disable_mc, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14586
    goto ldv_61657;
    case_67: /* CIL Label */ 
    {
#line 14594
    ldv_dummy_resourceless_instance_callback_11_34(ldv_11_callback_clear_vmdq, ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_34_1_default,
                                                   ldv_11_ldv_param_34_2_default);
    }
#line 14600
    goto ldv_61657;
    case_68: /* CIL Label */ 
    {
#line 14605
    ldv_dummy_resourceless_instance_callback_11_33(ldv_11_callback_clear_vfta, ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14608
    goto ldv_61657;
    case_69: /* CIL Label */ 
    {
#line 14616
    ldv_dummy_resourceless_instance_callback_11_30(ldv_11_callback_clear_rar, ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_30_1_default);
    }
#line 14622
    goto ldv_61657;
    case_70: /* CIL Label */ 
    {
#line 14627
    ldv_dummy_resourceless_instance_callback_11_29(ldv_11_callback_clear_hw_cntrs,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14630
    goto ldv_61657;
    case_71: /* CIL Label */ 
    {
#line 14635
    ldv_dummy_resourceless_instance_callback_11_28(ldv_11_callback_check_overtemp,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14638
    goto ldv_61657;
    case_72: /* CIL Label */ 
    {
#line 14642
    tmp___22 = ldv_xmalloc(4UL);
#line 14642
    ldv_11_ldv_param_25_1_default = (unsigned int *)tmp___22;
#line 14643
    tmp___23 = ldv_xmalloc(1UL);
#line 14643
    ldv_11_ldv_param_25_2_default = (_Bool *)tmp___23;
#line 14648
    ldv_dummy_resourceless_instance_callback_11_25(ldv_11_callback_check_link, ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_25_1_default,
                                                   ldv_11_ldv_param_25_2_default,
                                                   (int )ldv_11_ldv_param_25_3_default);
#line 14652
    ldv_free((void *)ldv_11_ldv_param_25_1_default);
#line 14653
    ldv_free((void *)ldv_11_ldv_param_25_2_default);
    }
#line 14656
    goto ldv_61657;
    case_73: /* CIL Label */ 
    {
#line 14664
    ldv_dummy_resourceless_instance_callback_11_22(ldv_11_callback_check_for_rst,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_11_ldv_param_22_1_default);
    }
#line 14670
    goto ldv_61657;
    case_74: /* CIL Label */ 
    {
#line 14678
    ldv_dummy_resourceless_instance_callback_11_19(ldv_11_callback_check_for_msg,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_11_ldv_param_19_1_default);
    }
#line 14684
    goto ldv_61657;
    case_75: /* CIL Label */ 
    {
#line 14692
    ldv_dummy_resourceless_instance_callback_11_16(ldv_11_callback_check_for_ack,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_11_ldv_param_16_1_default);
    }
#line 14698
    goto ldv_61657;
    case_76: /* CIL Label */ 
    {
#line 14703
    ldv_dummy_resourceless_instance_callback_11_15(ldv_11_callback_calc_checksum,
                                                   ldv_11_container_struct_ixgbe_hw_ptr);
    }
#line 14706
    goto ldv_61657;
    case_77: /* CIL Label */ 
    {
#line 14714
    ldv_dummy_resourceless_instance_callback_11_12(ldv_11_callback_blink_led_stop,
                                                   ldv_11_container_struct_ixgbe_hw_ptr,
                                                   ldv_11_ldv_param_12_1_default);
    }
#line 14720
    goto ldv_61657;
    case_78: /* CIL Label */ 
    {
#line 14728
    ldv_dummy_resourceless_instance_callback_11_9(ldv_11_callback_blink_led_start,
                                                  ldv_11_container_struct_ixgbe_hw_ptr,
                                                  ldv_11_ldv_param_9_1_default);
    }
#line 14734
    goto ldv_61657;
    case_79: /* CIL Label */ 
    {
#line 14739
    ldv_dummy_resourceless_instance_callback_11_3(ldv_11_callback_acquire_swfw_sync,
                                                  ldv_11_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_11_ldv_param_3_1_default);
    }
#line 14742
    goto ldv_61657;
    switch_default: /* CIL Label */ 
    {
#line 14744
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_61657: ;
#line 14753
    goto ldv_call_11;
  } else {
#line 14761
    return;
  }
#line 14764
  return;
}
}
#line 14769 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_12(void *arg0 ) 
{ 
  int (*ldv_12_callback_acquire_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_12_callback_blink_led_start)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_12_callback_blink_led_stop)(struct ixgbe_hw * , unsigned int  ) ;
  unsigned short (*ldv_12_callback_calc_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_check_for_ack)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_12_callback_check_for_msg)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_12_callback_check_for_rst)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_12_callback_check_link)(struct ixgbe_hw * , unsigned int * , _Bool * ,
                                    _Bool  ) ;
  int (*ldv_12_callback_check_overtemp)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_clear_hw_cntrs)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_clear_rar)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_12_callback_clear_vfta)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_clear_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_12_callback_disable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_disable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_enable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_enable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_enable_rx_dma)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_12_callback_fc_enable)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_get_bus_info)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_get_device_caps)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_12_callback_get_firmware_version)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_12_callback_get_invariants)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_get_link_capabilities)(struct ixgbe_hw * , unsigned int * ,
                                               _Bool * ) ;
  int (*ldv_12_callback_get_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  enum ixgbe_media_type (*ldv_12_callback_get_media_type)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_get_san_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  unsigned int (*ldv_12_callback_get_supported_physical_layer)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_get_thermal_sensor_data)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_get_wwn_prefix)(struct ixgbe_hw * , unsigned short * , unsigned short * ) ;
  int (*ldv_12_callback_identify)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_identify_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_init)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_init_hw)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_init_params)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_init_rx_addrs)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_init_thermal_sensor_thresh)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_init_uta_tables)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_led_off)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_12_callback_led_on)(struct ixgbe_hw * , unsigned int  ) ;
  _Bool (*ldv_12_callback_mng_fw_enabled)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_read)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                              unsigned short  ) ;
  int (*ldv_12_callback_read_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char * ) ;
  int (*ldv_12_callback_read_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                     unsigned short * ) ;
  int (*ldv_12_callback_read_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                       unsigned char * ) ;
  int (*ldv_12_callback_read_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_12_callback_read_i2c_sff8472)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_12_callback_read_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                     unsigned short  ) ;
  int (*ldv_12_callback_read_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  unsigned short * ) ;
  int (*ldv_12_callback_read_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                      unsigned short * ) ;
  void (*ldv_12_callback_release_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_12_callback_reset)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_reset_hw)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_set_fw_drv_ver)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                        unsigned char  , unsigned char  ) ;
  void (*ldv_12_callback_set_lan_id)(struct ixgbe_hw * ) ;
  void (*ldv_12_callback_set_mac_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_12_callback_set_rar)(struct ixgbe_hw * , unsigned int  , unsigned char * ,
                                 unsigned int  , unsigned int  ) ;
  void (*ldv_12_callback_set_rxpba)(struct ixgbe_hw * , int  , unsigned int  , int  ) ;
  int (*ldv_12_callback_set_vfta)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  _Bool  ) ;
  void (*ldv_12_callback_set_vlan_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_12_callback_set_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_12_callback_set_vmdq_san_mac)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_12_callback_setup_link)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_setup_link_speed)(struct ixgbe_hw * , unsigned int  , _Bool  ) ;
  int (*ldv_12_callback_setup_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_start_hw)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_stop_adapter)(struct ixgbe_hw * ) ;
  void (*ldv_12_callback_stop_link_on_d3)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_update_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_12_callback_update_mc_addr_list)(struct ixgbe_hw * , struct net_device * ) ;
  int (*ldv_12_callback_validate_checksum)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_12_callback_write)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                               unsigned short  ) ;
  int (*ldv_12_callback_write_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char  ) ;
  int (*ldv_12_callback_write_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                      unsigned short * ) ;
  int (*ldv_12_callback_write_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                        unsigned char  ) ;
  int (*ldv_12_callback_write_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char  ) ;
  int (*ldv_12_callback_write_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                      unsigned short  ) ;
  int (*ldv_12_callback_write_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                   unsigned short  ) ;
  int (*ldv_12_callback_write_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                       unsigned short  ) ;
  struct ixgbe_hw *ldv_12_container_struct_ixgbe_hw_ptr ;
  struct net_device *ldv_12_container_struct_net_device_ptr ;
  unsigned int *ldv_12_ldv_param_101_1_default ;
  unsigned short ldv_12_ldv_param_101_2_default ;
  unsigned short ldv_12_ldv_param_101_3_default ;
  unsigned int ldv_12_ldv_param_104_1_default ;
  unsigned int ldv_12_ldv_param_104_2_default ;
  unsigned short *ldv_12_ldv_param_104_3_default ;
  unsigned int ldv_12_ldv_param_107_1_default ;
  unsigned int ldv_12_ldv_param_107_2_default ;
  unsigned short *ldv_12_ldv_param_107_3_default ;
  unsigned short ldv_12_ldv_param_110_1_default ;
  unsigned char ldv_12_ldv_param_115_1_default ;
  unsigned char ldv_12_ldv_param_115_2_default ;
  unsigned char ldv_12_ldv_param_115_3_default ;
  unsigned char ldv_12_ldv_param_115_4_default ;
  _Bool ldv_12_ldv_param_119_1_default ;
  int ldv_12_ldv_param_119_2_default ;
  unsigned int ldv_12_ldv_param_122_1_default ;
  unsigned char *ldv_12_ldv_param_122_2_default ;
  unsigned int ldv_12_ldv_param_122_3_default ;
  unsigned int ldv_12_ldv_param_122_4_default ;
  int ldv_12_ldv_param_125_1_default ;
  unsigned int ldv_12_ldv_param_125_2_default ;
  int ldv_12_ldv_param_125_3_default ;
  unsigned int ldv_12_ldv_param_128_1_default ;
  unsigned int ldv_12_ldv_param_128_2_default ;
  _Bool ldv_12_ldv_param_128_3_default ;
  unsigned int ldv_12_ldv_param_12_1_default ;
  _Bool ldv_12_ldv_param_131_1_default ;
  int ldv_12_ldv_param_131_2_default ;
  unsigned int ldv_12_ldv_param_134_1_default ;
  unsigned int ldv_12_ldv_param_134_2_default ;
  unsigned int ldv_12_ldv_param_137_1_default ;
  unsigned int ldv_12_ldv_param_141_1_default ;
  _Bool ldv_12_ldv_param_141_2_default ;
  unsigned short *ldv_12_ldv_param_150_1_default ;
  unsigned int *ldv_12_ldv_param_153_1_default ;
  unsigned short ldv_12_ldv_param_153_2_default ;
  unsigned short ldv_12_ldv_param_153_3_default ;
  unsigned int ldv_12_ldv_param_156_1_default ;
  unsigned char ldv_12_ldv_param_156_2_default ;
  unsigned short ldv_12_ldv_param_159_1_default ;
  unsigned short ldv_12_ldv_param_159_2_default ;
  unsigned short *ldv_12_ldv_param_159_3_default ;
  unsigned char ldv_12_ldv_param_162_1_default ;
  unsigned char ldv_12_ldv_param_162_2_default ;
  unsigned char ldv_12_ldv_param_162_3_default ;
  unsigned char ldv_12_ldv_param_165_1_default ;
  unsigned char ldv_12_ldv_param_165_2_default ;
  unsigned int *ldv_12_ldv_param_168_1_default ;
  unsigned short ldv_12_ldv_param_168_2_default ;
  unsigned short ldv_12_ldv_param_168_3_default ;
  unsigned short ldv_12_ldv_param_16_1_default ;
  unsigned int ldv_12_ldv_param_171_1_default ;
  unsigned int ldv_12_ldv_param_171_2_default ;
  unsigned short ldv_12_ldv_param_171_3_default ;
  unsigned int ldv_12_ldv_param_174_1_default ;
  unsigned int ldv_12_ldv_param_174_2_default ;
  unsigned short ldv_12_ldv_param_174_3_default ;
  unsigned short ldv_12_ldv_param_19_1_default ;
  unsigned short ldv_12_ldv_param_22_1_default ;
  unsigned int *ldv_12_ldv_param_25_1_default ;
  _Bool *ldv_12_ldv_param_25_2_default ;
  _Bool ldv_12_ldv_param_25_3_default ;
  unsigned int ldv_12_ldv_param_30_1_default ;
  unsigned int ldv_12_ldv_param_34_1_default ;
  unsigned int ldv_12_ldv_param_34_2_default ;
  unsigned short ldv_12_ldv_param_3_1_default ;
  unsigned int ldv_12_ldv_param_41_1_default ;
  unsigned short *ldv_12_ldv_param_46_1_default ;
  unsigned short *ldv_12_ldv_param_49_1_default ;
  unsigned int *ldv_12_ldv_param_53_1_default ;
  _Bool *ldv_12_ldv_param_53_2_default ;
  unsigned char *ldv_12_ldv_param_56_1_default ;
  unsigned char *ldv_12_ldv_param_60_1_default ;
  unsigned short *ldv_12_ldv_param_65_1_default ;
  unsigned short *ldv_12_ldv_param_65_2_default ;
  unsigned int ldv_12_ldv_param_76_1_default ;
  unsigned int ldv_12_ldv_param_79_1_default ;
  unsigned int *ldv_12_ldv_param_83_1_default ;
  unsigned short ldv_12_ldv_param_83_2_default ;
  unsigned short ldv_12_ldv_param_83_3_default ;
  unsigned int ldv_12_ldv_param_86_1_default ;
  unsigned char *ldv_12_ldv_param_86_2_default ;
  unsigned short ldv_12_ldv_param_89_1_default ;
  unsigned short ldv_12_ldv_param_89_2_default ;
  unsigned short *ldv_12_ldv_param_89_3_default ;
  unsigned char ldv_12_ldv_param_92_1_default ;
  unsigned char ldv_12_ldv_param_92_2_default ;
  unsigned char *ldv_12_ldv_param_92_3_default ;
  unsigned char ldv_12_ldv_param_95_1_default ;
  unsigned char *ldv_12_ldv_param_95_2_default ;
  unsigned char ldv_12_ldv_param_98_1_default ;
  unsigned char *ldv_12_ldv_param_98_2_default ;
  unsigned int ldv_12_ldv_param_9_1_default ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;

  {
#line 14955
  goto ldv_call_12;
#line 14957
  return;
  ldv_call_12: 
  {
#line 14963
  tmp___24 = ldv_undef_int();
  }
#line 14963
  if (tmp___24 != 0) {
    {
#line 14967
    tmp = ldv_undef_int();
    }
    {
#line 14968
    if (tmp == 1) {
#line 14968
      goto case_1;
    } else {

    }
#line 14982
    if (tmp == 2) {
#line 14982
      goto case_2;
    } else {

    }
#line 14996
    if (tmp == 3) {
#line 14996
      goto case_3;
    } else {

    }
#line 15012
    if (tmp == 4) {
#line 15012
      goto case_4;
    } else {

    }
#line 15026
    if (tmp == 5) {
#line 15026
      goto case_5;
    } else {

    }
#line 15040
    if (tmp == 6) {
#line 15040
      goto case_6;
    } else {

    }
#line 15056
    if (tmp == 7) {
#line 15056
      goto case_7;
    } else {

    }
#line 15070
    if (tmp == 8) {
#line 15070
      goto case_8;
    } else {

    }
#line 15086
    if (tmp == 9) {
#line 15086
      goto case_9;
    } else {

    }
#line 15102
    if (tmp == 10) {
#line 15102
      goto case_10;
    } else {

    }
#line 15110
    if (tmp == 11) {
#line 15110
      goto case_11;
    } else {

    }
#line 15118
    if (tmp == 12) {
#line 15118
      goto case_12;
    } else {

    }
#line 15126
    if (tmp == 13) {
#line 15126
      goto case_13;
    } else {

    }
#line 15134
    if (tmp == 14) {
#line 15134
      goto case_14;
    } else {

    }
#line 15142
    if (tmp == 15) {
#line 15142
      goto case_15;
    } else {

    }
#line 15150
    if (tmp == 16) {
#line 15150
      goto case_16;
    } else {

    }
#line 15164
    if (tmp == 17) {
#line 15164
      goto case_17;
    } else {

    }
#line 15172
    if (tmp == 18) {
#line 15172
      goto case_18;
    } else {

    }
#line 15186
    if (tmp == 19) {
#line 15186
      goto case_19;
    } else {

    }
#line 15200
    if (tmp == 20) {
#line 15200
      goto case_20;
    } else {

    }
#line 15214
    if (tmp == 21) {
#line 15214
      goto case_21;
    } else {

    }
#line 15228
    if (tmp == 22) {
#line 15228
      goto case_22;
    } else {

    }
#line 15242
    if (tmp == 23) {
#line 15242
      goto case_23;
    } else {

    }
#line 15258
    if (tmp == 24) {
#line 15258
      goto case_24;
    } else {

    }
#line 15272
    if (tmp == 25) {
#line 15272
      goto case_25;
    } else {

    }
#line 15280
    if (tmp == 26) {
#line 15280
      goto case_26;
    } else {

    }
#line 15294
    if (tmp == 27) {
#line 15294
      goto case_27;
    } else {

    }
#line 15302
    if (tmp == 28) {
#line 15302
      goto case_28;
    } else {

    }
#line 15310
    if (tmp == 29) {
#line 15310
      goto case_29;
    } else {

    }
#line 15324
    if (tmp == 30) {
#line 15324
      goto case_30;
    } else {

    }
#line 15340
    if (tmp == 31) {
#line 15340
      goto case_31;
    } else {

    }
#line 15356
    if (tmp == 32) {
#line 15356
      goto case_32;
    } else {

    }
#line 15372
    if (tmp == 33) {
#line 15372
      goto case_33;
    } else {

    }
#line 15388
    if (tmp == 34) {
#line 15388
      goto case_34;
    } else {

    }
#line 15404
    if (tmp == 35) {
#line 15404
      goto case_35;
    } else {

    }
#line 15420
    if (tmp == 36) {
#line 15420
      goto case_36;
    } else {

    }
#line 15436
    if (tmp == 37) {
#line 15436
      goto case_37;
    } else {

    }
#line 15452
    if (tmp == 38) {
#line 15452
      goto case_38;
    } else {

    }
#line 15468
    if (tmp == 39) {
#line 15468
      goto case_39;
    } else {

    }
#line 15476
    if (tmp == 40) {
#line 15476
      goto case_40;
    } else {

    }
#line 15490
    if (tmp == 41) {
#line 15490
      goto case_41;
    } else {

    }
#line 15504
    if (tmp == 42) {
#line 15504
      goto case_42;
    } else {

    }
#line 15512
    if (tmp == 43) {
#line 15512
      goto case_43;
    } else {

    }
#line 15520
    if (tmp == 44) {
#line 15520
      goto case_44;
    } else {

    }
#line 15528
    if (tmp == 45) {
#line 15528
      goto case_45;
    } else {

    }
#line 15536
    if (tmp == 46) {
#line 15536
      goto case_46;
    } else {

    }
#line 15544
    if (tmp == 47) {
#line 15544
      goto case_47;
    } else {

    }
#line 15552
    if (tmp == 48) {
#line 15552
      goto case_48;
    } else {

    }
#line 15560
    if (tmp == 49) {
#line 15560
      goto case_49;
    } else {

    }
#line 15568
    if (tmp == 50) {
#line 15568
      goto case_50;
    } else {

    }
#line 15586
    if (tmp == 51) {
#line 15586
      goto case_51;
    } else {

    }
#line 15594
    if (tmp == 52) {
#line 15594
      goto case_52;
    } else {

    }
#line 15602
    if (tmp == 53) {
#line 15602
      goto case_53;
    } else {

    }
#line 15618
    if (tmp == 54) {
#line 15618
      goto case_54;
    } else {

    }
#line 15626
    if (tmp == 55) {
#line 15626
      goto case_55;
    } else {

    }
#line 15642
    if (tmp == 56) {
#line 15642
      goto case_56;
    } else {

    }
#line 15660
    if (tmp == 57) {
#line 15660
      goto case_57;
    } else {

    }
#line 15668
    if (tmp == 58) {
#line 15668
      goto case_58;
    } else {

    }
#line 15684
    if (tmp == 59) {
#line 15684
      goto case_59;
    } else {

    }
#line 15700
    if (tmp == 60) {
#line 15700
      goto case_60;
    } else {

    }
#line 15708
    if (tmp == 61) {
#line 15708
      goto case_61;
    } else {

    }
#line 15716
    if (tmp == 62) {
#line 15716
      goto case_62;
    } else {

    }
#line 15730
    if (tmp == 63) {
#line 15730
      goto case_63;
    } else {

    }
#line 15738
    if (tmp == 64) {
#line 15738
      goto case_64;
    } else {

    }
#line 15746
    if (tmp == 65) {
#line 15746
      goto case_65;
    } else {

    }
#line 15754
    if (tmp == 66) {
#line 15754
      goto case_66;
    } else {

    }
#line 15762
    if (tmp == 67) {
#line 15762
      goto case_67;
    } else {

    }
#line 15776
    if (tmp == 68) {
#line 15776
      goto case_68;
    } else {

    }
#line 15784
    if (tmp == 69) {
#line 15784
      goto case_69;
    } else {

    }
#line 15798
    if (tmp == 70) {
#line 15798
      goto case_70;
    } else {

    }
#line 15806
    if (tmp == 71) {
#line 15806
      goto case_71;
    } else {

    }
#line 15814
    if (tmp == 72) {
#line 15814
      goto case_72;
    } else {

    }
#line 15832
    if (tmp == 73) {
#line 15832
      goto case_73;
    } else {

    }
#line 15846
    if (tmp == 74) {
#line 15846
      goto case_74;
    } else {

    }
#line 15860
    if (tmp == 75) {
#line 15860
      goto case_75;
    } else {

    }
#line 15874
    if (tmp == 76) {
#line 15874
      goto case_76;
    } else {

    }
#line 15882
    if (tmp == 77) {
#line 15882
      goto case_77;
    } else {

    }
#line 15896
    if (tmp == 78) {
#line 15896
      goto case_78;
    } else {

    }
#line 15910
    if (tmp == 79) {
#line 15910
      goto case_79;
    } else {

    }
#line 15918
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 14974
    ldv_dummy_resourceless_instance_callback_12_174(ldv_12_callback_write_reg_mdi,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_174_1_default,
                                                    ldv_12_ldv_param_174_2_default,
                                                    (int )ldv_12_ldv_param_174_3_default);
    }
#line 14980
    goto ldv_62091;
    case_2: /* CIL Label */ 
    {
#line 14988
    ldv_dummy_resourceless_instance_callback_12_171(ldv_12_callback_write_reg, ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_171_1_default,
                                                    ldv_12_ldv_param_171_2_default,
                                                    (int )ldv_12_ldv_param_171_3_default);
    }
#line 14994
    goto ldv_62091;
    case_3: /* CIL Label */ 
    {
#line 14998
    tmp___0 = ldv_xmalloc(4UL);
#line 14998
    ldv_12_ldv_param_168_1_default = (unsigned int *)tmp___0;
#line 15003
    ldv_dummy_resourceless_instance_callback_12_168(ldv_12_callback_write_posted,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_168_1_default,
                                                    (int )ldv_12_ldv_param_168_2_default,
                                                    (int )ldv_12_ldv_param_168_3_default);
#line 15007
    ldv_free((void *)ldv_12_ldv_param_168_1_default);
    }
#line 15010
    goto ldv_62091;
    case_4: /* CIL Label */ 
    {
#line 15018
    ldv_dummy_resourceless_instance_callback_12_165(ldv_12_callback_write_i2c_eeprom,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_12_ldv_param_165_1_default,
                                                    (int )ldv_12_ldv_param_165_2_default);
    }
#line 15024
    goto ldv_62091;
    case_5: /* CIL Label */ 
    {
#line 15032
    ldv_dummy_resourceless_instance_callback_12_162(ldv_12_callback_write_i2c_byte,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_12_ldv_param_162_1_default,
                                                    (int )ldv_12_ldv_param_162_2_default,
                                                    (int )ldv_12_ldv_param_162_3_default);
    }
#line 15038
    goto ldv_62091;
    case_6: /* CIL Label */ 
    {
#line 15042
    tmp___1 = ldv_xmalloc(2UL);
#line 15042
    ldv_12_ldv_param_159_3_default = (unsigned short *)tmp___1;
#line 15047
    ldv_dummy_resourceless_instance_callback_12_159(ldv_12_callback_write_buffer,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_12_ldv_param_159_1_default,
                                                    (int )ldv_12_ldv_param_159_2_default,
                                                    ldv_12_ldv_param_159_3_default);
#line 15051
    ldv_free((void *)ldv_12_ldv_param_159_3_default);
    }
#line 15054
    goto ldv_62091;
    case_7: /* CIL Label */ 
    {
#line 15062
    ldv_dummy_resourceless_instance_callback_12_156(ldv_12_callback_write_analog_reg8,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_156_1_default,
                                                    (int )ldv_12_ldv_param_156_2_default);
    }
#line 15068
    goto ldv_62091;
    case_8: /* CIL Label */ 
    {
#line 15072
    tmp___2 = ldv_xmalloc(4UL);
#line 15072
    ldv_12_ldv_param_153_1_default = (unsigned int *)tmp___2;
#line 15077
    ldv_dummy_resourceless_instance_callback_12_153(ldv_12_callback_write, ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_153_1_default,
                                                    (int )ldv_12_ldv_param_153_2_default,
                                                    (int )ldv_12_ldv_param_153_3_default);
#line 15081
    ldv_free((void *)ldv_12_ldv_param_153_1_default);
    }
#line 15084
    goto ldv_62091;
    case_9: /* CIL Label */ 
    {
#line 15088
    tmp___3 = ldv_xmalloc(2UL);
#line 15088
    ldv_12_ldv_param_150_1_default = (unsigned short *)tmp___3;
#line 15093
    ldv_dummy_resourceless_instance_callback_12_150(ldv_12_callback_validate_checksum,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_150_1_default);
#line 15097
    ldv_free((void *)ldv_12_ldv_param_150_1_default);
    }
#line 15100
    goto ldv_62091;
    case_10: /* CIL Label */ 
    {
#line 15105
    ldv_dummy_resourceless_instance_callback_12_149(ldv_12_callback_update_mc_addr_list,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_container_struct_net_device_ptr);
    }
#line 15108
    goto ldv_62091;
    case_11: /* CIL Label */ 
    {
#line 15113
    ldv_dummy_resourceless_instance_callback_12_148(ldv_12_callback_update_checksum,
                                                    ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15116
    goto ldv_62091;
    case_12: /* CIL Label */ 
    {
#line 15121
    ldv_dummy_resourceless_instance_callback_12_147(ldv_12_callback_stop_link_on_d3,
                                                    ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15124
    goto ldv_62091;
    case_13: /* CIL Label */ 
    {
#line 15129
    ldv_dummy_resourceless_instance_callback_12_146(ldv_12_callback_stop_adapter,
                                                    ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15132
    goto ldv_62091;
    case_14: /* CIL Label */ 
    {
#line 15137
    ldv_dummy_resourceless_instance_callback_12_145(ldv_12_callback_start_hw, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15140
    goto ldv_62091;
    case_15: /* CIL Label */ 
    {
#line 15145
    ldv_dummy_resourceless_instance_callback_12_144(ldv_12_callback_setup_sfp, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15148
    goto ldv_62091;
    case_16: /* CIL Label */ 
    {
#line 15156
    ldv_dummy_resourceless_instance_callback_12_141(ldv_12_callback_setup_link_speed,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_141_1_default,
                                                    (int )ldv_12_ldv_param_141_2_default);
    }
#line 15162
    goto ldv_62091;
    case_17: /* CIL Label */ 
    {
#line 15167
    ldv_dummy_resourceless_instance_callback_12_140(ldv_12_callback_setup_link, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15170
    goto ldv_62091;
    case_18: /* CIL Label */ 
    {
#line 15178
    ldv_dummy_resourceless_instance_callback_12_137(ldv_12_callback_set_vmdq_san_mac,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_137_1_default);
    }
#line 15184
    goto ldv_62091;
    case_19: /* CIL Label */ 
    {
#line 15192
    ldv_dummy_resourceless_instance_callback_12_134(ldv_12_callback_set_vmdq, ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_134_1_default,
                                                    ldv_12_ldv_param_134_2_default);
    }
#line 15198
    goto ldv_62091;
    case_20: /* CIL Label */ 
    {
#line 15206
    ldv_dummy_resourceless_instance_callback_12_131(ldv_12_callback_set_vlan_anti_spoofing,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_12_ldv_param_131_1_default,
                                                    ldv_12_ldv_param_131_2_default);
    }
#line 15212
    goto ldv_62091;
    case_21: /* CIL Label */ 
    {
#line 15220
    ldv_dummy_resourceless_instance_callback_12_128(ldv_12_callback_set_vfta, ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_128_1_default,
                                                    ldv_12_ldv_param_128_2_default,
                                                    (int )ldv_12_ldv_param_128_3_default);
    }
#line 15226
    goto ldv_62091;
    case_22: /* CIL Label */ 
    {
#line 15234
    ldv_dummy_resourceless_instance_callback_12_125(ldv_12_callback_set_rxpba, ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_125_1_default,
                                                    ldv_12_ldv_param_125_2_default,
                                                    ldv_12_ldv_param_125_3_default);
    }
#line 15240
    goto ldv_62091;
    case_23: /* CIL Label */ 
    {
#line 15244
    tmp___4 = ldv_xmalloc(1UL);
#line 15244
    ldv_12_ldv_param_122_2_default = (unsigned char *)tmp___4;
#line 15249
    ldv_dummy_resourceless_instance_callback_12_122(ldv_12_callback_set_rar, ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_122_1_default,
                                                    ldv_12_ldv_param_122_2_default,
                                                    ldv_12_ldv_param_122_3_default,
                                                    ldv_12_ldv_param_122_4_default);
#line 15253
    ldv_free((void *)ldv_12_ldv_param_122_2_default);
    }
#line 15256
    goto ldv_62091;
    case_24: /* CIL Label */ 
    {
#line 15264
    ldv_dummy_resourceless_instance_callback_12_119(ldv_12_callback_set_mac_anti_spoofing,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_12_ldv_param_119_1_default,
                                                    ldv_12_ldv_param_119_2_default);
    }
#line 15270
    goto ldv_62091;
    case_25: /* CIL Label */ 
    {
#line 15275
    ldv_dummy_resourceless_instance_callback_12_118(ldv_12_callback_set_lan_id, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15278
    goto ldv_62091;
    case_26: /* CIL Label */ 
    {
#line 15286
    ldv_dummy_resourceless_instance_callback_12_115(ldv_12_callback_set_fw_drv_ver,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_12_ldv_param_115_1_default,
                                                    (int )ldv_12_ldv_param_115_2_default,
                                                    (int )ldv_12_ldv_param_115_3_default,
                                                    (int )ldv_12_ldv_param_115_4_default);
    }
#line 15292
    goto ldv_62091;
    case_27: /* CIL Label */ 
    {
#line 15297
    ldv_dummy_resourceless_instance_callback_12_114(ldv_12_callback_reset_hw, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15300
    goto ldv_62091;
    case_28: /* CIL Label */ 
    {
#line 15305
    ldv_dummy_resourceless_instance_callback_12_113(ldv_12_callback_reset, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15308
    goto ldv_62091;
    case_29: /* CIL Label */ 
    {
#line 15316
    ldv_dummy_resourceless_instance_callback_12_110(ldv_12_callback_release_swfw_sync,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_12_ldv_param_110_1_default);
    }
#line 15322
    goto ldv_62091;
    case_30: /* CIL Label */ 
    {
#line 15326
    tmp___5 = ldv_xmalloc(2UL);
#line 15326
    ldv_12_ldv_param_107_3_default = (unsigned short *)tmp___5;
#line 15331
    ldv_dummy_resourceless_instance_callback_12_107(ldv_12_callback_read_reg_mdi,
                                                    ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_107_1_default,
                                                    ldv_12_ldv_param_107_2_default,
                                                    ldv_12_ldv_param_107_3_default);
#line 15335
    ldv_free((void *)ldv_12_ldv_param_107_3_default);
    }
#line 15338
    goto ldv_62091;
    case_31: /* CIL Label */ 
    {
#line 15342
    tmp___6 = ldv_xmalloc(2UL);
#line 15342
    ldv_12_ldv_param_104_3_default = (unsigned short *)tmp___6;
#line 15347
    ldv_dummy_resourceless_instance_callback_12_104(ldv_12_callback_read_reg, ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_104_1_default,
                                                    ldv_12_ldv_param_104_2_default,
                                                    ldv_12_ldv_param_104_3_default);
#line 15351
    ldv_free((void *)ldv_12_ldv_param_104_3_default);
    }
#line 15354
    goto ldv_62091;
    case_32: /* CIL Label */ 
    {
#line 15358
    tmp___7 = ldv_xmalloc(4UL);
#line 15358
    ldv_12_ldv_param_101_1_default = (unsigned int *)tmp___7;
#line 15363
    ldv_dummy_resourceless_instance_callback_12_101(ldv_12_callback_read_posted, ldv_12_container_struct_ixgbe_hw_ptr,
                                                    ldv_12_ldv_param_101_1_default,
                                                    (int )ldv_12_ldv_param_101_2_default,
                                                    (int )ldv_12_ldv_param_101_3_default);
#line 15367
    ldv_free((void *)ldv_12_ldv_param_101_1_default);
    }
#line 15370
    goto ldv_62091;
    case_33: /* CIL Label */ 
    {
#line 15374
    tmp___8 = ldv_xmalloc(1UL);
#line 15374
    ldv_12_ldv_param_98_2_default = (unsigned char *)tmp___8;
#line 15379
    ldv_dummy_resourceless_instance_callback_12_98(ldv_12_callback_read_i2c_sff8472,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_12_ldv_param_98_1_default,
                                                   ldv_12_ldv_param_98_2_default);
#line 15383
    ldv_free((void *)ldv_12_ldv_param_98_2_default);
    }
#line 15386
    goto ldv_62091;
    case_34: /* CIL Label */ 
    {
#line 15390
    tmp___9 = ldv_xmalloc(1UL);
#line 15390
    ldv_12_ldv_param_95_2_default = (unsigned char *)tmp___9;
#line 15395
    ldv_dummy_resourceless_instance_callback_12_95(ldv_12_callback_read_i2c_eeprom,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_12_ldv_param_95_1_default,
                                                   ldv_12_ldv_param_95_2_default);
#line 15399
    ldv_free((void *)ldv_12_ldv_param_95_2_default);
    }
#line 15402
    goto ldv_62091;
    case_35: /* CIL Label */ 
    {
#line 15406
    tmp___10 = ldv_xmalloc(1UL);
#line 15406
    ldv_12_ldv_param_92_3_default = (unsigned char *)tmp___10;
#line 15411
    ldv_dummy_resourceless_instance_callback_12_92(ldv_12_callback_read_i2c_byte,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_12_ldv_param_92_1_default,
                                                   (int )ldv_12_ldv_param_92_2_default,
                                                   ldv_12_ldv_param_92_3_default);
#line 15415
    ldv_free((void *)ldv_12_ldv_param_92_3_default);
    }
#line 15418
    goto ldv_62091;
    case_36: /* CIL Label */ 
    {
#line 15422
    tmp___11 = ldv_xmalloc(2UL);
#line 15422
    ldv_12_ldv_param_89_3_default = (unsigned short *)tmp___11;
#line 15427
    ldv_dummy_resourceless_instance_callback_12_89(ldv_12_callback_read_buffer, ldv_12_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_12_ldv_param_89_1_default,
                                                   (int )ldv_12_ldv_param_89_2_default,
                                                   ldv_12_ldv_param_89_3_default);
#line 15431
    ldv_free((void *)ldv_12_ldv_param_89_3_default);
    }
#line 15434
    goto ldv_62091;
    case_37: /* CIL Label */ 
    {
#line 15438
    tmp___12 = ldv_xmalloc(1UL);
#line 15438
    ldv_12_ldv_param_86_2_default = (unsigned char *)tmp___12;
#line 15443
    ldv_dummy_resourceless_instance_callback_12_86(ldv_12_callback_read_analog_reg8,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_86_1_default,
                                                   ldv_12_ldv_param_86_2_default);
#line 15447
    ldv_free((void *)ldv_12_ldv_param_86_2_default);
    }
#line 15450
    goto ldv_62091;
    case_38: /* CIL Label */ 
    {
#line 15454
    tmp___13 = ldv_xmalloc(4UL);
#line 15454
    ldv_12_ldv_param_83_1_default = (unsigned int *)tmp___13;
#line 15459
    ldv_dummy_resourceless_instance_callback_12_83(ldv_12_callback_read, ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_83_1_default,
                                                   (int )ldv_12_ldv_param_83_2_default,
                                                   (int )ldv_12_ldv_param_83_3_default);
#line 15463
    ldv_free((void *)ldv_12_ldv_param_83_1_default);
    }
#line 15466
    goto ldv_62091;
    case_39: /* CIL Label */ 
    {
#line 15471
    ldv_dummy_resourceless_instance_callback_12_82(ldv_12_callback_mng_fw_enabled,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15474
    goto ldv_62091;
    case_40: /* CIL Label */ 
    {
#line 15482
    ldv_dummy_resourceless_instance_callback_12_79(ldv_12_callback_led_on, ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_79_1_default);
    }
#line 15488
    goto ldv_62091;
    case_41: /* CIL Label */ 
    {
#line 15496
    ldv_dummy_resourceless_instance_callback_12_76(ldv_12_callback_led_off, ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_76_1_default);
    }
#line 15502
    goto ldv_62091;
    case_42: /* CIL Label */ 
    {
#line 15507
    ldv_dummy_resourceless_instance_callback_12_75(ldv_12_callback_init_uta_tables,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15510
    goto ldv_62091;
    case_43: /* CIL Label */ 
    {
#line 15515
    ldv_dummy_resourceless_instance_callback_12_74(ldv_12_callback_init_thermal_sensor_thresh,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15518
    goto ldv_62091;
    case_44: /* CIL Label */ 
    {
#line 15523
    ldv_dummy_resourceless_instance_callback_12_73(ldv_12_callback_init_rx_addrs,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15526
    goto ldv_62091;
    case_45: /* CIL Label */ 
    {
#line 15531
    ldv_dummy_resourceless_instance_callback_12_72(ldv_12_callback_init_params, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15534
    goto ldv_62091;
    case_46: /* CIL Label */ 
    {
#line 15539
    ldv_dummy_resourceless_instance_callback_12_71(ldv_12_callback_init_hw, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15542
    goto ldv_62091;
    case_47: /* CIL Label */ 
    {
#line 15547
    ldv_dummy_resourceless_instance_callback_12_70(ldv_12_callback_init, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15550
    goto ldv_62091;
    case_48: /* CIL Label */ 
    {
#line 15555
    ldv_dummy_resourceless_instance_callback_12_69(ldv_12_callback_identify_sfp, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15558
    goto ldv_62091;
    case_49: /* CIL Label */ 
    {
#line 15563
    ldv_dummy_resourceless_instance_callback_12_68(ldv_12_callback_identify, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15566
    goto ldv_62091;
    case_50: /* CIL Label */ 
    {
#line 15570
    tmp___14 = ldv_xmalloc(2UL);
#line 15570
    ldv_12_ldv_param_65_1_default = (unsigned short *)tmp___14;
#line 15571
    tmp___15 = ldv_xmalloc(2UL);
#line 15571
    ldv_12_ldv_param_65_2_default = (unsigned short *)tmp___15;
#line 15576
    ldv_dummy_resourceless_instance_callback_12_65(ldv_12_callback_get_wwn_prefix,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_65_1_default,
                                                   ldv_12_ldv_param_65_2_default);
#line 15580
    ldv_free((void *)ldv_12_ldv_param_65_1_default);
#line 15581
    ldv_free((void *)ldv_12_ldv_param_65_2_default);
    }
#line 15584
    goto ldv_62091;
    case_51: /* CIL Label */ 
    {
#line 15589
    ldv_dummy_resourceless_instance_callback_12_64(ldv_12_callback_get_thermal_sensor_data,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15592
    goto ldv_62091;
    case_52: /* CIL Label */ 
    {
#line 15597
    ldv_dummy_resourceless_instance_callback_12_63(ldv_12_callback_get_supported_physical_layer,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15600
    goto ldv_62091;
    case_53: /* CIL Label */ 
    {
#line 15604
    tmp___16 = ldv_xmalloc(1UL);
#line 15604
    ldv_12_ldv_param_60_1_default = (unsigned char *)tmp___16;
#line 15609
    ldv_dummy_resourceless_instance_callback_12_60(ldv_12_callback_get_san_mac_addr,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_60_1_default);
#line 15613
    ldv_free((void *)ldv_12_ldv_param_60_1_default);
    }
#line 15616
    goto ldv_62091;
    case_54: /* CIL Label */ 
    {
#line 15621
    ldv_dummy_resourceless_instance_callback_12_59(ldv_12_callback_get_media_type,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15624
    goto ldv_62091;
    case_55: /* CIL Label */ 
    {
#line 15628
    tmp___17 = ldv_xmalloc(1UL);
#line 15628
    ldv_12_ldv_param_56_1_default = (unsigned char *)tmp___17;
#line 15633
    ldv_dummy_resourceless_instance_callback_12_56(ldv_12_callback_get_mac_addr, ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_56_1_default);
#line 15637
    ldv_free((void *)ldv_12_ldv_param_56_1_default);
    }
#line 15640
    goto ldv_62091;
    case_56: /* CIL Label */ 
    {
#line 15644
    tmp___18 = ldv_xmalloc(4UL);
#line 15644
    ldv_12_ldv_param_53_1_default = (unsigned int *)tmp___18;
#line 15645
    tmp___19 = ldv_xmalloc(1UL);
#line 15645
    ldv_12_ldv_param_53_2_default = (_Bool *)tmp___19;
#line 15650
    ldv_dummy_resourceless_instance_callback_12_53(ldv_12_callback_get_link_capabilities,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_53_1_default,
                                                   ldv_12_ldv_param_53_2_default);
#line 15654
    ldv_free((void *)ldv_12_ldv_param_53_1_default);
#line 15655
    ldv_free((void *)ldv_12_ldv_param_53_2_default);
    }
#line 15658
    goto ldv_62091;
    case_57: /* CIL Label */ 
    {
#line 15663
    ldv_dummy_resourceless_instance_callback_12_52(ldv_12_callback_get_invariants,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15666
    goto ldv_62091;
    case_58: /* CIL Label */ 
    {
#line 15670
    tmp___20 = ldv_xmalloc(2UL);
#line 15670
    ldv_12_ldv_param_49_1_default = (unsigned short *)tmp___20;
#line 15675
    ldv_dummy_resourceless_instance_callback_12_49(ldv_12_callback_get_firmware_version,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_49_1_default);
#line 15679
    ldv_free((void *)ldv_12_ldv_param_49_1_default);
    }
#line 15682
    goto ldv_62091;
    case_59: /* CIL Label */ 
    {
#line 15686
    tmp___21 = ldv_xmalloc(2UL);
#line 15686
    ldv_12_ldv_param_46_1_default = (unsigned short *)tmp___21;
#line 15691
    ldv_dummy_resourceless_instance_callback_12_46(ldv_12_callback_get_device_caps,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_46_1_default);
#line 15695
    ldv_free((void *)ldv_12_ldv_param_46_1_default);
    }
#line 15698
    goto ldv_62091;
    case_60: /* CIL Label */ 
    {
#line 15703
    ldv_dummy_resourceless_instance_callback_12_45(ldv_12_callback_get_bus_info, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15706
    goto ldv_62091;
    case_61: /* CIL Label */ 
    {
#line 15711
    ldv_dummy_resourceless_instance_callback_12_44(ldv_12_callback_fc_enable, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15714
    goto ldv_62091;
    case_62: /* CIL Label */ 
    {
#line 15722
    ldv_dummy_resourceless_instance_callback_12_41(ldv_12_callback_enable_rx_dma,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_41_1_default);
    }
#line 15728
    goto ldv_62091;
    case_63: /* CIL Label */ 
    {
#line 15733
    ldv_dummy_resourceless_instance_callback_12_40(ldv_12_callback_enable_rx_buff,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15736
    goto ldv_62091;
    case_64: /* CIL Label */ 
    {
#line 15741
    ldv_dummy_resourceless_instance_callback_12_39(ldv_12_callback_enable_mc, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15744
    goto ldv_62091;
    case_65: /* CIL Label */ 
    {
#line 15749
    ldv_dummy_resourceless_instance_callback_12_38(ldv_12_callback_disable_rx_buff,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15752
    goto ldv_62091;
    case_66: /* CIL Label */ 
    {
#line 15757
    ldv_dummy_resourceless_instance_callback_12_37(ldv_12_callback_disable_mc, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15760
    goto ldv_62091;
    case_67: /* CIL Label */ 
    {
#line 15768
    ldv_dummy_resourceless_instance_callback_12_34(ldv_12_callback_clear_vmdq, ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_34_1_default,
                                                   ldv_12_ldv_param_34_2_default);
    }
#line 15774
    goto ldv_62091;
    case_68: /* CIL Label */ 
    {
#line 15779
    ldv_dummy_resourceless_instance_callback_12_33(ldv_12_callback_clear_vfta, ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15782
    goto ldv_62091;
    case_69: /* CIL Label */ 
    {
#line 15790
    ldv_dummy_resourceless_instance_callback_12_30(ldv_12_callback_clear_rar, ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_30_1_default);
    }
#line 15796
    goto ldv_62091;
    case_70: /* CIL Label */ 
    {
#line 15801
    ldv_dummy_resourceless_instance_callback_12_29(ldv_12_callback_clear_hw_cntrs,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15804
    goto ldv_62091;
    case_71: /* CIL Label */ 
    {
#line 15809
    ldv_dummy_resourceless_instance_callback_12_28(ldv_12_callback_check_overtemp,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15812
    goto ldv_62091;
    case_72: /* CIL Label */ 
    {
#line 15816
    tmp___22 = ldv_xmalloc(4UL);
#line 15816
    ldv_12_ldv_param_25_1_default = (unsigned int *)tmp___22;
#line 15817
    tmp___23 = ldv_xmalloc(1UL);
#line 15817
    ldv_12_ldv_param_25_2_default = (_Bool *)tmp___23;
#line 15822
    ldv_dummy_resourceless_instance_callback_12_25(ldv_12_callback_check_link, ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_25_1_default,
                                                   ldv_12_ldv_param_25_2_default,
                                                   (int )ldv_12_ldv_param_25_3_default);
#line 15826
    ldv_free((void *)ldv_12_ldv_param_25_1_default);
#line 15827
    ldv_free((void *)ldv_12_ldv_param_25_2_default);
    }
#line 15830
    goto ldv_62091;
    case_73: /* CIL Label */ 
    {
#line 15838
    ldv_dummy_resourceless_instance_callback_12_22(ldv_12_callback_check_for_rst,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_12_ldv_param_22_1_default);
    }
#line 15844
    goto ldv_62091;
    case_74: /* CIL Label */ 
    {
#line 15852
    ldv_dummy_resourceless_instance_callback_12_19(ldv_12_callback_check_for_msg,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_12_ldv_param_19_1_default);
    }
#line 15858
    goto ldv_62091;
    case_75: /* CIL Label */ 
    {
#line 15866
    ldv_dummy_resourceless_instance_callback_12_16(ldv_12_callback_check_for_ack,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_12_ldv_param_16_1_default);
    }
#line 15872
    goto ldv_62091;
    case_76: /* CIL Label */ 
    {
#line 15877
    ldv_dummy_resourceless_instance_callback_12_15(ldv_12_callback_calc_checksum,
                                                   ldv_12_container_struct_ixgbe_hw_ptr);
    }
#line 15880
    goto ldv_62091;
    case_77: /* CIL Label */ 
    {
#line 15888
    ldv_dummy_resourceless_instance_callback_12_12(ldv_12_callback_blink_led_stop,
                                                   ldv_12_container_struct_ixgbe_hw_ptr,
                                                   ldv_12_ldv_param_12_1_default);
    }
#line 15894
    goto ldv_62091;
    case_78: /* CIL Label */ 
    {
#line 15902
    ldv_dummy_resourceless_instance_callback_12_9(ldv_12_callback_blink_led_start,
                                                  ldv_12_container_struct_ixgbe_hw_ptr,
                                                  ldv_12_ldv_param_9_1_default);
    }
#line 15908
    goto ldv_62091;
    case_79: /* CIL Label */ 
    {
#line 15913
    ldv_dummy_resourceless_instance_callback_12_3(ldv_12_callback_acquire_swfw_sync,
                                                  ldv_12_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_12_ldv_param_3_1_default);
    }
#line 15916
    goto ldv_62091;
    switch_default: /* CIL Label */ 
    {
#line 15918
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_62091: ;
#line 15927
    goto ldv_call_12;
  } else {
#line 15935
    return;
  }
#line 15938
  return;
}
}
#line 15943 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_13(void *arg0 ) 
{ 
  int (*ldv_13_callback_acquire_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_13_callback_blink_led_start)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_13_callback_blink_led_stop)(struct ixgbe_hw * , unsigned int  ) ;
  unsigned short (*ldv_13_callback_calc_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_check_for_ack)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_13_callback_check_for_msg)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_13_callback_check_for_rst)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_13_callback_check_link)(struct ixgbe_hw * , unsigned int * , _Bool * ,
                                    _Bool  ) ;
  int (*ldv_13_callback_check_overtemp)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_clear_hw_cntrs)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_clear_rar)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_13_callback_clear_vfta)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_clear_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_13_callback_disable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_disable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_enable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_enable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_enable_rx_dma)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_13_callback_fc_enable)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_get_bus_info)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_get_device_caps)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_13_callback_get_firmware_version)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_13_callback_get_invariants)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_get_link_capabilities)(struct ixgbe_hw * , unsigned int * ,
                                               _Bool * ) ;
  int (*ldv_13_callback_get_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  enum ixgbe_media_type (*ldv_13_callback_get_media_type)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_get_san_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  unsigned int (*ldv_13_callback_get_supported_physical_layer)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_get_thermal_sensor_data)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_get_wwn_prefix)(struct ixgbe_hw * , unsigned short * , unsigned short * ) ;
  int (*ldv_13_callback_identify)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_identify_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_init)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_init_hw)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_init_params)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_init_rx_addrs)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_init_thermal_sensor_thresh)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_init_uta_tables)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_led_off)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_13_callback_led_on)(struct ixgbe_hw * , unsigned int  ) ;
  _Bool (*ldv_13_callback_mng_fw_enabled)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_read)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                              unsigned short  ) ;
  int (*ldv_13_callback_read_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char * ) ;
  int (*ldv_13_callback_read_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                     unsigned short * ) ;
  int (*ldv_13_callback_read_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                       unsigned char * ) ;
  int (*ldv_13_callback_read_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_13_callback_read_i2c_sff8472)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_13_callback_read_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                     unsigned short  ) ;
  int (*ldv_13_callback_read_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  unsigned short * ) ;
  int (*ldv_13_callback_read_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                      unsigned short * ) ;
  void (*ldv_13_callback_release_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_13_callback_reset)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_reset_hw)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_set_fw_drv_ver)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                        unsigned char  , unsigned char  ) ;
  void (*ldv_13_callback_set_lan_id)(struct ixgbe_hw * ) ;
  void (*ldv_13_callback_set_mac_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_13_callback_set_rar)(struct ixgbe_hw * , unsigned int  , unsigned char * ,
                                 unsigned int  , unsigned int  ) ;
  void (*ldv_13_callback_set_rxpba)(struct ixgbe_hw * , int  , unsigned int  , int  ) ;
  int (*ldv_13_callback_set_vfta)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  _Bool  ) ;
  void (*ldv_13_callback_set_vlan_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_13_callback_set_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_13_callback_set_vmdq_san_mac)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_13_callback_setup_link)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_setup_link_speed)(struct ixgbe_hw * , unsigned int  , _Bool  ) ;
  int (*ldv_13_callback_setup_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_start_hw)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_stop_adapter)(struct ixgbe_hw * ) ;
  void (*ldv_13_callback_stop_link_on_d3)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_update_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_13_callback_update_mc_addr_list)(struct ixgbe_hw * , struct net_device * ) ;
  int (*ldv_13_callback_validate_checksum)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_13_callback_write)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                               unsigned short  ) ;
  int (*ldv_13_callback_write_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char  ) ;
  int (*ldv_13_callback_write_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                      unsigned short * ) ;
  int (*ldv_13_callback_write_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                        unsigned char  ) ;
  int (*ldv_13_callback_write_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char  ) ;
  int (*ldv_13_callback_write_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                      unsigned short  ) ;
  int (*ldv_13_callback_write_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                   unsigned short  ) ;
  int (*ldv_13_callback_write_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                       unsigned short  ) ;
  struct ixgbe_hw *ldv_13_container_struct_ixgbe_hw_ptr ;
  struct net_device *ldv_13_container_struct_net_device_ptr ;
  unsigned int *ldv_13_ldv_param_101_1_default ;
  unsigned short ldv_13_ldv_param_101_2_default ;
  unsigned short ldv_13_ldv_param_101_3_default ;
  unsigned int ldv_13_ldv_param_104_1_default ;
  unsigned int ldv_13_ldv_param_104_2_default ;
  unsigned short *ldv_13_ldv_param_104_3_default ;
  unsigned int ldv_13_ldv_param_107_1_default ;
  unsigned int ldv_13_ldv_param_107_2_default ;
  unsigned short *ldv_13_ldv_param_107_3_default ;
  unsigned short ldv_13_ldv_param_110_1_default ;
  unsigned char ldv_13_ldv_param_115_1_default ;
  unsigned char ldv_13_ldv_param_115_2_default ;
  unsigned char ldv_13_ldv_param_115_3_default ;
  unsigned char ldv_13_ldv_param_115_4_default ;
  _Bool ldv_13_ldv_param_119_1_default ;
  int ldv_13_ldv_param_119_2_default ;
  unsigned int ldv_13_ldv_param_122_1_default ;
  unsigned char *ldv_13_ldv_param_122_2_default ;
  unsigned int ldv_13_ldv_param_122_3_default ;
  unsigned int ldv_13_ldv_param_122_4_default ;
  int ldv_13_ldv_param_125_1_default ;
  unsigned int ldv_13_ldv_param_125_2_default ;
  int ldv_13_ldv_param_125_3_default ;
  unsigned int ldv_13_ldv_param_128_1_default ;
  unsigned int ldv_13_ldv_param_128_2_default ;
  _Bool ldv_13_ldv_param_128_3_default ;
  unsigned int ldv_13_ldv_param_12_1_default ;
  _Bool ldv_13_ldv_param_131_1_default ;
  int ldv_13_ldv_param_131_2_default ;
  unsigned int ldv_13_ldv_param_134_1_default ;
  unsigned int ldv_13_ldv_param_134_2_default ;
  unsigned int ldv_13_ldv_param_137_1_default ;
  unsigned int ldv_13_ldv_param_141_1_default ;
  _Bool ldv_13_ldv_param_141_2_default ;
  unsigned short *ldv_13_ldv_param_150_1_default ;
  unsigned int *ldv_13_ldv_param_153_1_default ;
  unsigned short ldv_13_ldv_param_153_2_default ;
  unsigned short ldv_13_ldv_param_153_3_default ;
  unsigned int ldv_13_ldv_param_156_1_default ;
  unsigned char ldv_13_ldv_param_156_2_default ;
  unsigned short ldv_13_ldv_param_159_1_default ;
  unsigned short ldv_13_ldv_param_159_2_default ;
  unsigned short *ldv_13_ldv_param_159_3_default ;
  unsigned char ldv_13_ldv_param_162_1_default ;
  unsigned char ldv_13_ldv_param_162_2_default ;
  unsigned char ldv_13_ldv_param_162_3_default ;
  unsigned char ldv_13_ldv_param_165_1_default ;
  unsigned char ldv_13_ldv_param_165_2_default ;
  unsigned int *ldv_13_ldv_param_168_1_default ;
  unsigned short ldv_13_ldv_param_168_2_default ;
  unsigned short ldv_13_ldv_param_168_3_default ;
  unsigned short ldv_13_ldv_param_16_1_default ;
  unsigned int ldv_13_ldv_param_171_1_default ;
  unsigned int ldv_13_ldv_param_171_2_default ;
  unsigned short ldv_13_ldv_param_171_3_default ;
  unsigned int ldv_13_ldv_param_174_1_default ;
  unsigned int ldv_13_ldv_param_174_2_default ;
  unsigned short ldv_13_ldv_param_174_3_default ;
  unsigned short ldv_13_ldv_param_19_1_default ;
  unsigned short ldv_13_ldv_param_22_1_default ;
  unsigned int *ldv_13_ldv_param_25_1_default ;
  _Bool *ldv_13_ldv_param_25_2_default ;
  _Bool ldv_13_ldv_param_25_3_default ;
  unsigned int ldv_13_ldv_param_30_1_default ;
  unsigned int ldv_13_ldv_param_34_1_default ;
  unsigned int ldv_13_ldv_param_34_2_default ;
  unsigned short ldv_13_ldv_param_3_1_default ;
  unsigned int ldv_13_ldv_param_41_1_default ;
  unsigned short *ldv_13_ldv_param_46_1_default ;
  unsigned short *ldv_13_ldv_param_49_1_default ;
  unsigned int *ldv_13_ldv_param_53_1_default ;
  _Bool *ldv_13_ldv_param_53_2_default ;
  unsigned char *ldv_13_ldv_param_56_1_default ;
  unsigned char *ldv_13_ldv_param_60_1_default ;
  unsigned short *ldv_13_ldv_param_65_1_default ;
  unsigned short *ldv_13_ldv_param_65_2_default ;
  unsigned int ldv_13_ldv_param_76_1_default ;
  unsigned int ldv_13_ldv_param_79_1_default ;
  unsigned int *ldv_13_ldv_param_83_1_default ;
  unsigned short ldv_13_ldv_param_83_2_default ;
  unsigned short ldv_13_ldv_param_83_3_default ;
  unsigned int ldv_13_ldv_param_86_1_default ;
  unsigned char *ldv_13_ldv_param_86_2_default ;
  unsigned short ldv_13_ldv_param_89_1_default ;
  unsigned short ldv_13_ldv_param_89_2_default ;
  unsigned short *ldv_13_ldv_param_89_3_default ;
  unsigned char ldv_13_ldv_param_92_1_default ;
  unsigned char ldv_13_ldv_param_92_2_default ;
  unsigned char *ldv_13_ldv_param_92_3_default ;
  unsigned char ldv_13_ldv_param_95_1_default ;
  unsigned char *ldv_13_ldv_param_95_2_default ;
  unsigned char ldv_13_ldv_param_98_1_default ;
  unsigned char *ldv_13_ldv_param_98_2_default ;
  unsigned int ldv_13_ldv_param_9_1_default ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;

  {
#line 16129
  goto ldv_call_13;
#line 16131
  return;
  ldv_call_13: 
  {
#line 16137
  tmp___24 = ldv_undef_int();
  }
#line 16137
  if (tmp___24 != 0) {
    {
#line 16141
    tmp = ldv_undef_int();
    }
    {
#line 16142
    if (tmp == 1) {
#line 16142
      goto case_1;
    } else {

    }
#line 16156
    if (tmp == 2) {
#line 16156
      goto case_2;
    } else {

    }
#line 16170
    if (tmp == 3) {
#line 16170
      goto case_3;
    } else {

    }
#line 16186
    if (tmp == 4) {
#line 16186
      goto case_4;
    } else {

    }
#line 16200
    if (tmp == 5) {
#line 16200
      goto case_5;
    } else {

    }
#line 16214
    if (tmp == 6) {
#line 16214
      goto case_6;
    } else {

    }
#line 16230
    if (tmp == 7) {
#line 16230
      goto case_7;
    } else {

    }
#line 16244
    if (tmp == 8) {
#line 16244
      goto case_8;
    } else {

    }
#line 16260
    if (tmp == 9) {
#line 16260
      goto case_9;
    } else {

    }
#line 16276
    if (tmp == 10) {
#line 16276
      goto case_10;
    } else {

    }
#line 16284
    if (tmp == 11) {
#line 16284
      goto case_11;
    } else {

    }
#line 16292
    if (tmp == 12) {
#line 16292
      goto case_12;
    } else {

    }
#line 16300
    if (tmp == 13) {
#line 16300
      goto case_13;
    } else {

    }
#line 16308
    if (tmp == 14) {
#line 16308
      goto case_14;
    } else {

    }
#line 16316
    if (tmp == 15) {
#line 16316
      goto case_15;
    } else {

    }
#line 16324
    if (tmp == 16) {
#line 16324
      goto case_16;
    } else {

    }
#line 16338
    if (tmp == 17) {
#line 16338
      goto case_17;
    } else {

    }
#line 16346
    if (tmp == 18) {
#line 16346
      goto case_18;
    } else {

    }
#line 16360
    if (tmp == 19) {
#line 16360
      goto case_19;
    } else {

    }
#line 16374
    if (tmp == 20) {
#line 16374
      goto case_20;
    } else {

    }
#line 16388
    if (tmp == 21) {
#line 16388
      goto case_21;
    } else {

    }
#line 16402
    if (tmp == 22) {
#line 16402
      goto case_22;
    } else {

    }
#line 16416
    if (tmp == 23) {
#line 16416
      goto case_23;
    } else {

    }
#line 16432
    if (tmp == 24) {
#line 16432
      goto case_24;
    } else {

    }
#line 16446
    if (tmp == 25) {
#line 16446
      goto case_25;
    } else {

    }
#line 16454
    if (tmp == 26) {
#line 16454
      goto case_26;
    } else {

    }
#line 16468
    if (tmp == 27) {
#line 16468
      goto case_27;
    } else {

    }
#line 16476
    if (tmp == 28) {
#line 16476
      goto case_28;
    } else {

    }
#line 16484
    if (tmp == 29) {
#line 16484
      goto case_29;
    } else {

    }
#line 16498
    if (tmp == 30) {
#line 16498
      goto case_30;
    } else {

    }
#line 16514
    if (tmp == 31) {
#line 16514
      goto case_31;
    } else {

    }
#line 16530
    if (tmp == 32) {
#line 16530
      goto case_32;
    } else {

    }
#line 16546
    if (tmp == 33) {
#line 16546
      goto case_33;
    } else {

    }
#line 16562
    if (tmp == 34) {
#line 16562
      goto case_34;
    } else {

    }
#line 16578
    if (tmp == 35) {
#line 16578
      goto case_35;
    } else {

    }
#line 16594
    if (tmp == 36) {
#line 16594
      goto case_36;
    } else {

    }
#line 16610
    if (tmp == 37) {
#line 16610
      goto case_37;
    } else {

    }
#line 16626
    if (tmp == 38) {
#line 16626
      goto case_38;
    } else {

    }
#line 16642
    if (tmp == 39) {
#line 16642
      goto case_39;
    } else {

    }
#line 16650
    if (tmp == 40) {
#line 16650
      goto case_40;
    } else {

    }
#line 16664
    if (tmp == 41) {
#line 16664
      goto case_41;
    } else {

    }
#line 16678
    if (tmp == 42) {
#line 16678
      goto case_42;
    } else {

    }
#line 16686
    if (tmp == 43) {
#line 16686
      goto case_43;
    } else {

    }
#line 16694
    if (tmp == 44) {
#line 16694
      goto case_44;
    } else {

    }
#line 16702
    if (tmp == 45) {
#line 16702
      goto case_45;
    } else {

    }
#line 16710
    if (tmp == 46) {
#line 16710
      goto case_46;
    } else {

    }
#line 16718
    if (tmp == 47) {
#line 16718
      goto case_47;
    } else {

    }
#line 16726
    if (tmp == 48) {
#line 16726
      goto case_48;
    } else {

    }
#line 16734
    if (tmp == 49) {
#line 16734
      goto case_49;
    } else {

    }
#line 16742
    if (tmp == 50) {
#line 16742
      goto case_50;
    } else {

    }
#line 16760
    if (tmp == 51) {
#line 16760
      goto case_51;
    } else {

    }
#line 16768
    if (tmp == 52) {
#line 16768
      goto case_52;
    } else {

    }
#line 16776
    if (tmp == 53) {
#line 16776
      goto case_53;
    } else {

    }
#line 16792
    if (tmp == 54) {
#line 16792
      goto case_54;
    } else {

    }
#line 16800
    if (tmp == 55) {
#line 16800
      goto case_55;
    } else {

    }
#line 16816
    if (tmp == 56) {
#line 16816
      goto case_56;
    } else {

    }
#line 16834
    if (tmp == 57) {
#line 16834
      goto case_57;
    } else {

    }
#line 16842
    if (tmp == 58) {
#line 16842
      goto case_58;
    } else {

    }
#line 16858
    if (tmp == 59) {
#line 16858
      goto case_59;
    } else {

    }
#line 16874
    if (tmp == 60) {
#line 16874
      goto case_60;
    } else {

    }
#line 16882
    if (tmp == 61) {
#line 16882
      goto case_61;
    } else {

    }
#line 16890
    if (tmp == 62) {
#line 16890
      goto case_62;
    } else {

    }
#line 16904
    if (tmp == 63) {
#line 16904
      goto case_63;
    } else {

    }
#line 16912
    if (tmp == 64) {
#line 16912
      goto case_64;
    } else {

    }
#line 16920
    if (tmp == 65) {
#line 16920
      goto case_65;
    } else {

    }
#line 16928
    if (tmp == 66) {
#line 16928
      goto case_66;
    } else {

    }
#line 16936
    if (tmp == 67) {
#line 16936
      goto case_67;
    } else {

    }
#line 16950
    if (tmp == 68) {
#line 16950
      goto case_68;
    } else {

    }
#line 16958
    if (tmp == 69) {
#line 16958
      goto case_69;
    } else {

    }
#line 16972
    if (tmp == 70) {
#line 16972
      goto case_70;
    } else {

    }
#line 16980
    if (tmp == 71) {
#line 16980
      goto case_71;
    } else {

    }
#line 16988
    if (tmp == 72) {
#line 16988
      goto case_72;
    } else {

    }
#line 17006
    if (tmp == 73) {
#line 17006
      goto case_73;
    } else {

    }
#line 17020
    if (tmp == 74) {
#line 17020
      goto case_74;
    } else {

    }
#line 17034
    if (tmp == 75) {
#line 17034
      goto case_75;
    } else {

    }
#line 17048
    if (tmp == 76) {
#line 17048
      goto case_76;
    } else {

    }
#line 17056
    if (tmp == 77) {
#line 17056
      goto case_77;
    } else {

    }
#line 17070
    if (tmp == 78) {
#line 17070
      goto case_78;
    } else {

    }
#line 17084
    if (tmp == 79) {
#line 17084
      goto case_79;
    } else {

    }
#line 17092
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 16148
    ldv_dummy_resourceless_instance_callback_13_174(ldv_13_callback_write_reg_mdi,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_174_1_default,
                                                    ldv_13_ldv_param_174_2_default,
                                                    (int )ldv_13_ldv_param_174_3_default);
    }
#line 16154
    goto ldv_62525;
    case_2: /* CIL Label */ 
    {
#line 16162
    ldv_dummy_resourceless_instance_callback_13_171(ldv_13_callback_write_reg, ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_171_1_default,
                                                    ldv_13_ldv_param_171_2_default,
                                                    (int )ldv_13_ldv_param_171_3_default);
    }
#line 16168
    goto ldv_62525;
    case_3: /* CIL Label */ 
    {
#line 16172
    tmp___0 = ldv_xmalloc(4UL);
#line 16172
    ldv_13_ldv_param_168_1_default = (unsigned int *)tmp___0;
#line 16177
    ldv_dummy_resourceless_instance_callback_13_168(ldv_13_callback_write_posted,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_168_1_default,
                                                    (int )ldv_13_ldv_param_168_2_default,
                                                    (int )ldv_13_ldv_param_168_3_default);
#line 16181
    ldv_free((void *)ldv_13_ldv_param_168_1_default);
    }
#line 16184
    goto ldv_62525;
    case_4: /* CIL Label */ 
    {
#line 16192
    ldv_dummy_resourceless_instance_callback_13_165(ldv_13_callback_write_i2c_eeprom,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_13_ldv_param_165_1_default,
                                                    (int )ldv_13_ldv_param_165_2_default);
    }
#line 16198
    goto ldv_62525;
    case_5: /* CIL Label */ 
    {
#line 16206
    ldv_dummy_resourceless_instance_callback_13_162(ldv_13_callback_write_i2c_byte,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_13_ldv_param_162_1_default,
                                                    (int )ldv_13_ldv_param_162_2_default,
                                                    (int )ldv_13_ldv_param_162_3_default);
    }
#line 16212
    goto ldv_62525;
    case_6: /* CIL Label */ 
    {
#line 16216
    tmp___1 = ldv_xmalloc(2UL);
#line 16216
    ldv_13_ldv_param_159_3_default = (unsigned short *)tmp___1;
#line 16221
    ldv_dummy_resourceless_instance_callback_13_159(ldv_13_callback_write_buffer,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_13_ldv_param_159_1_default,
                                                    (int )ldv_13_ldv_param_159_2_default,
                                                    ldv_13_ldv_param_159_3_default);
#line 16225
    ldv_free((void *)ldv_13_ldv_param_159_3_default);
    }
#line 16228
    goto ldv_62525;
    case_7: /* CIL Label */ 
    {
#line 16236
    ldv_dummy_resourceless_instance_callback_13_156(ldv_13_callback_write_analog_reg8,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_156_1_default,
                                                    (int )ldv_13_ldv_param_156_2_default);
    }
#line 16242
    goto ldv_62525;
    case_8: /* CIL Label */ 
    {
#line 16246
    tmp___2 = ldv_xmalloc(4UL);
#line 16246
    ldv_13_ldv_param_153_1_default = (unsigned int *)tmp___2;
#line 16251
    ldv_dummy_resourceless_instance_callback_13_153(ldv_13_callback_write, ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_153_1_default,
                                                    (int )ldv_13_ldv_param_153_2_default,
                                                    (int )ldv_13_ldv_param_153_3_default);
#line 16255
    ldv_free((void *)ldv_13_ldv_param_153_1_default);
    }
#line 16258
    goto ldv_62525;
    case_9: /* CIL Label */ 
    {
#line 16262
    tmp___3 = ldv_xmalloc(2UL);
#line 16262
    ldv_13_ldv_param_150_1_default = (unsigned short *)tmp___3;
#line 16267
    ldv_dummy_resourceless_instance_callback_13_150(ldv_13_callback_validate_checksum,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_150_1_default);
#line 16271
    ldv_free((void *)ldv_13_ldv_param_150_1_default);
    }
#line 16274
    goto ldv_62525;
    case_10: /* CIL Label */ 
    {
#line 16279
    ldv_dummy_resourceless_instance_callback_13_149(ldv_13_callback_update_mc_addr_list,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_container_struct_net_device_ptr);
    }
#line 16282
    goto ldv_62525;
    case_11: /* CIL Label */ 
    {
#line 16287
    ldv_dummy_resourceless_instance_callback_13_148(ldv_13_callback_update_checksum,
                                                    ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16290
    goto ldv_62525;
    case_12: /* CIL Label */ 
    {
#line 16295
    ldv_dummy_resourceless_instance_callback_13_147(ldv_13_callback_stop_link_on_d3,
                                                    ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16298
    goto ldv_62525;
    case_13: /* CIL Label */ 
    {
#line 16303
    ldv_dummy_resourceless_instance_callback_13_146(ldv_13_callback_stop_adapter,
                                                    ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16306
    goto ldv_62525;
    case_14: /* CIL Label */ 
    {
#line 16311
    ldv_dummy_resourceless_instance_callback_13_145(ldv_13_callback_start_hw, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16314
    goto ldv_62525;
    case_15: /* CIL Label */ 
    {
#line 16319
    ldv_dummy_resourceless_instance_callback_13_144(ldv_13_callback_setup_sfp, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16322
    goto ldv_62525;
    case_16: /* CIL Label */ 
    {
#line 16330
    ldv_dummy_resourceless_instance_callback_13_141(ldv_13_callback_setup_link_speed,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_141_1_default,
                                                    (int )ldv_13_ldv_param_141_2_default);
    }
#line 16336
    goto ldv_62525;
    case_17: /* CIL Label */ 
    {
#line 16341
    ldv_dummy_resourceless_instance_callback_13_140(ldv_13_callback_setup_link, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16344
    goto ldv_62525;
    case_18: /* CIL Label */ 
    {
#line 16352
    ldv_dummy_resourceless_instance_callback_13_137(ldv_13_callback_set_vmdq_san_mac,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_137_1_default);
    }
#line 16358
    goto ldv_62525;
    case_19: /* CIL Label */ 
    {
#line 16366
    ldv_dummy_resourceless_instance_callback_13_134(ldv_13_callback_set_vmdq, ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_134_1_default,
                                                    ldv_13_ldv_param_134_2_default);
    }
#line 16372
    goto ldv_62525;
    case_20: /* CIL Label */ 
    {
#line 16380
    ldv_dummy_resourceless_instance_callback_13_131(ldv_13_callback_set_vlan_anti_spoofing,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_13_ldv_param_131_1_default,
                                                    ldv_13_ldv_param_131_2_default);
    }
#line 16386
    goto ldv_62525;
    case_21: /* CIL Label */ 
    {
#line 16394
    ldv_dummy_resourceless_instance_callback_13_128(ldv_13_callback_set_vfta, ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_128_1_default,
                                                    ldv_13_ldv_param_128_2_default,
                                                    (int )ldv_13_ldv_param_128_3_default);
    }
#line 16400
    goto ldv_62525;
    case_22: /* CIL Label */ 
    {
#line 16408
    ldv_dummy_resourceless_instance_callback_13_125(ldv_13_callback_set_rxpba, ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_125_1_default,
                                                    ldv_13_ldv_param_125_2_default,
                                                    ldv_13_ldv_param_125_3_default);
    }
#line 16414
    goto ldv_62525;
    case_23: /* CIL Label */ 
    {
#line 16418
    tmp___4 = ldv_xmalloc(1UL);
#line 16418
    ldv_13_ldv_param_122_2_default = (unsigned char *)tmp___4;
#line 16423
    ldv_dummy_resourceless_instance_callback_13_122(ldv_13_callback_set_rar, ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_122_1_default,
                                                    ldv_13_ldv_param_122_2_default,
                                                    ldv_13_ldv_param_122_3_default,
                                                    ldv_13_ldv_param_122_4_default);
#line 16427
    ldv_free((void *)ldv_13_ldv_param_122_2_default);
    }
#line 16430
    goto ldv_62525;
    case_24: /* CIL Label */ 
    {
#line 16438
    ldv_dummy_resourceless_instance_callback_13_119(ldv_13_callback_set_mac_anti_spoofing,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_13_ldv_param_119_1_default,
                                                    ldv_13_ldv_param_119_2_default);
    }
#line 16444
    goto ldv_62525;
    case_25: /* CIL Label */ 
    {
#line 16449
    ldv_dummy_resourceless_instance_callback_13_118(ldv_13_callback_set_lan_id, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16452
    goto ldv_62525;
    case_26: /* CIL Label */ 
    {
#line 16460
    ldv_dummy_resourceless_instance_callback_13_115(ldv_13_callback_set_fw_drv_ver,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_13_ldv_param_115_1_default,
                                                    (int )ldv_13_ldv_param_115_2_default,
                                                    (int )ldv_13_ldv_param_115_3_default,
                                                    (int )ldv_13_ldv_param_115_4_default);
    }
#line 16466
    goto ldv_62525;
    case_27: /* CIL Label */ 
    {
#line 16471
    ldv_dummy_resourceless_instance_callback_13_114(ldv_13_callback_reset_hw, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16474
    goto ldv_62525;
    case_28: /* CIL Label */ 
    {
#line 16479
    ldv_dummy_resourceless_instance_callback_13_113(ldv_13_callback_reset, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16482
    goto ldv_62525;
    case_29: /* CIL Label */ 
    {
#line 16490
    ldv_dummy_resourceless_instance_callback_13_110(ldv_13_callback_release_swfw_sync,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    (int )ldv_13_ldv_param_110_1_default);
    }
#line 16496
    goto ldv_62525;
    case_30: /* CIL Label */ 
    {
#line 16500
    tmp___5 = ldv_xmalloc(2UL);
#line 16500
    ldv_13_ldv_param_107_3_default = (unsigned short *)tmp___5;
#line 16505
    ldv_dummy_resourceless_instance_callback_13_107(ldv_13_callback_read_reg_mdi,
                                                    ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_107_1_default,
                                                    ldv_13_ldv_param_107_2_default,
                                                    ldv_13_ldv_param_107_3_default);
#line 16509
    ldv_free((void *)ldv_13_ldv_param_107_3_default);
    }
#line 16512
    goto ldv_62525;
    case_31: /* CIL Label */ 
    {
#line 16516
    tmp___6 = ldv_xmalloc(2UL);
#line 16516
    ldv_13_ldv_param_104_3_default = (unsigned short *)tmp___6;
#line 16521
    ldv_dummy_resourceless_instance_callback_13_104(ldv_13_callback_read_reg, ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_104_1_default,
                                                    ldv_13_ldv_param_104_2_default,
                                                    ldv_13_ldv_param_104_3_default);
#line 16525
    ldv_free((void *)ldv_13_ldv_param_104_3_default);
    }
#line 16528
    goto ldv_62525;
    case_32: /* CIL Label */ 
    {
#line 16532
    tmp___7 = ldv_xmalloc(4UL);
#line 16532
    ldv_13_ldv_param_101_1_default = (unsigned int *)tmp___7;
#line 16537
    ldv_dummy_resourceless_instance_callback_13_101(ldv_13_callback_read_posted, ldv_13_container_struct_ixgbe_hw_ptr,
                                                    ldv_13_ldv_param_101_1_default,
                                                    (int )ldv_13_ldv_param_101_2_default,
                                                    (int )ldv_13_ldv_param_101_3_default);
#line 16541
    ldv_free((void *)ldv_13_ldv_param_101_1_default);
    }
#line 16544
    goto ldv_62525;
    case_33: /* CIL Label */ 
    {
#line 16548
    tmp___8 = ldv_xmalloc(1UL);
#line 16548
    ldv_13_ldv_param_98_2_default = (unsigned char *)tmp___8;
#line 16553
    ldv_dummy_resourceless_instance_callback_13_98(ldv_13_callback_read_i2c_sff8472,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_13_ldv_param_98_1_default,
                                                   ldv_13_ldv_param_98_2_default);
#line 16557
    ldv_free((void *)ldv_13_ldv_param_98_2_default);
    }
#line 16560
    goto ldv_62525;
    case_34: /* CIL Label */ 
    {
#line 16564
    tmp___9 = ldv_xmalloc(1UL);
#line 16564
    ldv_13_ldv_param_95_2_default = (unsigned char *)tmp___9;
#line 16569
    ldv_dummy_resourceless_instance_callback_13_95(ldv_13_callback_read_i2c_eeprom,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_13_ldv_param_95_1_default,
                                                   ldv_13_ldv_param_95_2_default);
#line 16573
    ldv_free((void *)ldv_13_ldv_param_95_2_default);
    }
#line 16576
    goto ldv_62525;
    case_35: /* CIL Label */ 
    {
#line 16580
    tmp___10 = ldv_xmalloc(1UL);
#line 16580
    ldv_13_ldv_param_92_3_default = (unsigned char *)tmp___10;
#line 16585
    ldv_dummy_resourceless_instance_callback_13_92(ldv_13_callback_read_i2c_byte,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_13_ldv_param_92_1_default,
                                                   (int )ldv_13_ldv_param_92_2_default,
                                                   ldv_13_ldv_param_92_3_default);
#line 16589
    ldv_free((void *)ldv_13_ldv_param_92_3_default);
    }
#line 16592
    goto ldv_62525;
    case_36: /* CIL Label */ 
    {
#line 16596
    tmp___11 = ldv_xmalloc(2UL);
#line 16596
    ldv_13_ldv_param_89_3_default = (unsigned short *)tmp___11;
#line 16601
    ldv_dummy_resourceless_instance_callback_13_89(ldv_13_callback_read_buffer, ldv_13_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_13_ldv_param_89_1_default,
                                                   (int )ldv_13_ldv_param_89_2_default,
                                                   ldv_13_ldv_param_89_3_default);
#line 16605
    ldv_free((void *)ldv_13_ldv_param_89_3_default);
    }
#line 16608
    goto ldv_62525;
    case_37: /* CIL Label */ 
    {
#line 16612
    tmp___12 = ldv_xmalloc(1UL);
#line 16612
    ldv_13_ldv_param_86_2_default = (unsigned char *)tmp___12;
#line 16617
    ldv_dummy_resourceless_instance_callback_13_86(ldv_13_callback_read_analog_reg8,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_86_1_default,
                                                   ldv_13_ldv_param_86_2_default);
#line 16621
    ldv_free((void *)ldv_13_ldv_param_86_2_default);
    }
#line 16624
    goto ldv_62525;
    case_38: /* CIL Label */ 
    {
#line 16628
    tmp___13 = ldv_xmalloc(4UL);
#line 16628
    ldv_13_ldv_param_83_1_default = (unsigned int *)tmp___13;
#line 16633
    ldv_dummy_resourceless_instance_callback_13_83(ldv_13_callback_read, ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_83_1_default,
                                                   (int )ldv_13_ldv_param_83_2_default,
                                                   (int )ldv_13_ldv_param_83_3_default);
#line 16637
    ldv_free((void *)ldv_13_ldv_param_83_1_default);
    }
#line 16640
    goto ldv_62525;
    case_39: /* CIL Label */ 
    {
#line 16645
    ldv_dummy_resourceless_instance_callback_13_82(ldv_13_callback_mng_fw_enabled,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16648
    goto ldv_62525;
    case_40: /* CIL Label */ 
    {
#line 16656
    ldv_dummy_resourceless_instance_callback_13_79(ldv_13_callback_led_on, ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_79_1_default);
    }
#line 16662
    goto ldv_62525;
    case_41: /* CIL Label */ 
    {
#line 16670
    ldv_dummy_resourceless_instance_callback_13_76(ldv_13_callback_led_off, ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_76_1_default);
    }
#line 16676
    goto ldv_62525;
    case_42: /* CIL Label */ 
    {
#line 16681
    ldv_dummy_resourceless_instance_callback_13_75(ldv_13_callback_init_uta_tables,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16684
    goto ldv_62525;
    case_43: /* CIL Label */ 
    {
#line 16689
    ldv_dummy_resourceless_instance_callback_13_74(ldv_13_callback_init_thermal_sensor_thresh,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16692
    goto ldv_62525;
    case_44: /* CIL Label */ 
    {
#line 16697
    ldv_dummy_resourceless_instance_callback_13_73(ldv_13_callback_init_rx_addrs,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16700
    goto ldv_62525;
    case_45: /* CIL Label */ 
    {
#line 16705
    ldv_dummy_resourceless_instance_callback_13_72(ldv_13_callback_init_params, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16708
    goto ldv_62525;
    case_46: /* CIL Label */ 
    {
#line 16713
    ldv_dummy_resourceless_instance_callback_13_71(ldv_13_callback_init_hw, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16716
    goto ldv_62525;
    case_47: /* CIL Label */ 
    {
#line 16721
    ldv_dummy_resourceless_instance_callback_13_70(ldv_13_callback_init, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16724
    goto ldv_62525;
    case_48: /* CIL Label */ 
    {
#line 16729
    ldv_dummy_resourceless_instance_callback_13_69(ldv_13_callback_identify_sfp, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16732
    goto ldv_62525;
    case_49: /* CIL Label */ 
    {
#line 16737
    ldv_dummy_resourceless_instance_callback_13_68(ldv_13_callback_identify, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16740
    goto ldv_62525;
    case_50: /* CIL Label */ 
    {
#line 16744
    tmp___14 = ldv_xmalloc(2UL);
#line 16744
    ldv_13_ldv_param_65_1_default = (unsigned short *)tmp___14;
#line 16745
    tmp___15 = ldv_xmalloc(2UL);
#line 16745
    ldv_13_ldv_param_65_2_default = (unsigned short *)tmp___15;
#line 16750
    ldv_dummy_resourceless_instance_callback_13_65(ldv_13_callback_get_wwn_prefix,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_65_1_default,
                                                   ldv_13_ldv_param_65_2_default);
#line 16754
    ldv_free((void *)ldv_13_ldv_param_65_1_default);
#line 16755
    ldv_free((void *)ldv_13_ldv_param_65_2_default);
    }
#line 16758
    goto ldv_62525;
    case_51: /* CIL Label */ 
    {
#line 16763
    ldv_dummy_resourceless_instance_callback_13_64(ldv_13_callback_get_thermal_sensor_data,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16766
    goto ldv_62525;
    case_52: /* CIL Label */ 
    {
#line 16771
    ldv_dummy_resourceless_instance_callback_13_63(ldv_13_callback_get_supported_physical_layer,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16774
    goto ldv_62525;
    case_53: /* CIL Label */ 
    {
#line 16778
    tmp___16 = ldv_xmalloc(1UL);
#line 16778
    ldv_13_ldv_param_60_1_default = (unsigned char *)tmp___16;
#line 16783
    ldv_dummy_resourceless_instance_callback_13_60(ldv_13_callback_get_san_mac_addr,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_60_1_default);
#line 16787
    ldv_free((void *)ldv_13_ldv_param_60_1_default);
    }
#line 16790
    goto ldv_62525;
    case_54: /* CIL Label */ 
    {
#line 16795
    ldv_dummy_resourceless_instance_callback_13_59(ldv_13_callback_get_media_type,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16798
    goto ldv_62525;
    case_55: /* CIL Label */ 
    {
#line 16802
    tmp___17 = ldv_xmalloc(1UL);
#line 16802
    ldv_13_ldv_param_56_1_default = (unsigned char *)tmp___17;
#line 16807
    ldv_dummy_resourceless_instance_callback_13_56(ldv_13_callback_get_mac_addr, ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_56_1_default);
#line 16811
    ldv_free((void *)ldv_13_ldv_param_56_1_default);
    }
#line 16814
    goto ldv_62525;
    case_56: /* CIL Label */ 
    {
#line 16818
    tmp___18 = ldv_xmalloc(4UL);
#line 16818
    ldv_13_ldv_param_53_1_default = (unsigned int *)tmp___18;
#line 16819
    tmp___19 = ldv_xmalloc(1UL);
#line 16819
    ldv_13_ldv_param_53_2_default = (_Bool *)tmp___19;
#line 16824
    ldv_dummy_resourceless_instance_callback_13_53(ldv_13_callback_get_link_capabilities,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_53_1_default,
                                                   ldv_13_ldv_param_53_2_default);
#line 16828
    ldv_free((void *)ldv_13_ldv_param_53_1_default);
#line 16829
    ldv_free((void *)ldv_13_ldv_param_53_2_default);
    }
#line 16832
    goto ldv_62525;
    case_57: /* CIL Label */ 
    {
#line 16837
    ldv_dummy_resourceless_instance_callback_13_52(ldv_13_callback_get_invariants,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16840
    goto ldv_62525;
    case_58: /* CIL Label */ 
    {
#line 16844
    tmp___20 = ldv_xmalloc(2UL);
#line 16844
    ldv_13_ldv_param_49_1_default = (unsigned short *)tmp___20;
#line 16849
    ldv_dummy_resourceless_instance_callback_13_49(ldv_13_callback_get_firmware_version,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_49_1_default);
#line 16853
    ldv_free((void *)ldv_13_ldv_param_49_1_default);
    }
#line 16856
    goto ldv_62525;
    case_59: /* CIL Label */ 
    {
#line 16860
    tmp___21 = ldv_xmalloc(2UL);
#line 16860
    ldv_13_ldv_param_46_1_default = (unsigned short *)tmp___21;
#line 16865
    ldv_dummy_resourceless_instance_callback_13_46(ldv_13_callback_get_device_caps,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_46_1_default);
#line 16869
    ldv_free((void *)ldv_13_ldv_param_46_1_default);
    }
#line 16872
    goto ldv_62525;
    case_60: /* CIL Label */ 
    {
#line 16877
    ldv_dummy_resourceless_instance_callback_13_45(ldv_13_callback_get_bus_info, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16880
    goto ldv_62525;
    case_61: /* CIL Label */ 
    {
#line 16885
    ldv_dummy_resourceless_instance_callback_13_44(ldv_13_callback_fc_enable, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16888
    goto ldv_62525;
    case_62: /* CIL Label */ 
    {
#line 16896
    ldv_dummy_resourceless_instance_callback_13_41(ldv_13_callback_enable_rx_dma,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_41_1_default);
    }
#line 16902
    goto ldv_62525;
    case_63: /* CIL Label */ 
    {
#line 16907
    ldv_dummy_resourceless_instance_callback_13_40(ldv_13_callback_enable_rx_buff,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16910
    goto ldv_62525;
    case_64: /* CIL Label */ 
    {
#line 16915
    ldv_dummy_resourceless_instance_callback_13_39(ldv_13_callback_enable_mc, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16918
    goto ldv_62525;
    case_65: /* CIL Label */ 
    {
#line 16923
    ldv_dummy_resourceless_instance_callback_13_38(ldv_13_callback_disable_rx_buff,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16926
    goto ldv_62525;
    case_66: /* CIL Label */ 
    {
#line 16931
    ldv_dummy_resourceless_instance_callback_13_37(ldv_13_callback_disable_mc, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16934
    goto ldv_62525;
    case_67: /* CIL Label */ 
    {
#line 16942
    ldv_dummy_resourceless_instance_callback_13_34(ldv_13_callback_clear_vmdq, ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_34_1_default,
                                                   ldv_13_ldv_param_34_2_default);
    }
#line 16948
    goto ldv_62525;
    case_68: /* CIL Label */ 
    {
#line 16953
    ldv_dummy_resourceless_instance_callback_13_33(ldv_13_callback_clear_vfta, ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16956
    goto ldv_62525;
    case_69: /* CIL Label */ 
    {
#line 16964
    ldv_dummy_resourceless_instance_callback_13_30(ldv_13_callback_clear_rar, ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_30_1_default);
    }
#line 16970
    goto ldv_62525;
    case_70: /* CIL Label */ 
    {
#line 16975
    ldv_dummy_resourceless_instance_callback_13_29(ldv_13_callback_clear_hw_cntrs,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16978
    goto ldv_62525;
    case_71: /* CIL Label */ 
    {
#line 16983
    ldv_dummy_resourceless_instance_callback_13_28(ldv_13_callback_check_overtemp,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 16986
    goto ldv_62525;
    case_72: /* CIL Label */ 
    {
#line 16990
    tmp___22 = ldv_xmalloc(4UL);
#line 16990
    ldv_13_ldv_param_25_1_default = (unsigned int *)tmp___22;
#line 16991
    tmp___23 = ldv_xmalloc(1UL);
#line 16991
    ldv_13_ldv_param_25_2_default = (_Bool *)tmp___23;
#line 16996
    ldv_dummy_resourceless_instance_callback_13_25(ldv_13_callback_check_link, ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_25_1_default,
                                                   ldv_13_ldv_param_25_2_default,
                                                   (int )ldv_13_ldv_param_25_3_default);
#line 17000
    ldv_free((void *)ldv_13_ldv_param_25_1_default);
#line 17001
    ldv_free((void *)ldv_13_ldv_param_25_2_default);
    }
#line 17004
    goto ldv_62525;
    case_73: /* CIL Label */ 
    {
#line 17012
    ldv_dummy_resourceless_instance_callback_13_22(ldv_13_callback_check_for_rst,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_13_ldv_param_22_1_default);
    }
#line 17018
    goto ldv_62525;
    case_74: /* CIL Label */ 
    {
#line 17026
    ldv_dummy_resourceless_instance_callback_13_19(ldv_13_callback_check_for_msg,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_13_ldv_param_19_1_default);
    }
#line 17032
    goto ldv_62525;
    case_75: /* CIL Label */ 
    {
#line 17040
    ldv_dummy_resourceless_instance_callback_13_16(ldv_13_callback_check_for_ack,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_13_ldv_param_16_1_default);
    }
#line 17046
    goto ldv_62525;
    case_76: /* CIL Label */ 
    {
#line 17051
    ldv_dummy_resourceless_instance_callback_13_15(ldv_13_callback_calc_checksum,
                                                   ldv_13_container_struct_ixgbe_hw_ptr);
    }
#line 17054
    goto ldv_62525;
    case_77: /* CIL Label */ 
    {
#line 17062
    ldv_dummy_resourceless_instance_callback_13_12(ldv_13_callback_blink_led_stop,
                                                   ldv_13_container_struct_ixgbe_hw_ptr,
                                                   ldv_13_ldv_param_12_1_default);
    }
#line 17068
    goto ldv_62525;
    case_78: /* CIL Label */ 
    {
#line 17076
    ldv_dummy_resourceless_instance_callback_13_9(ldv_13_callback_blink_led_start,
                                                  ldv_13_container_struct_ixgbe_hw_ptr,
                                                  ldv_13_ldv_param_9_1_default);
    }
#line 17082
    goto ldv_62525;
    case_79: /* CIL Label */ 
    {
#line 17087
    ldv_dummy_resourceless_instance_callback_13_3(ldv_13_callback_acquire_swfw_sync,
                                                  ldv_13_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_13_ldv_param_3_1_default);
    }
#line 17090
    goto ldv_62525;
    switch_default: /* CIL Label */ 
    {
#line 17092
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_62525: ;
#line 17101
    goto ldv_call_13;
  } else {
#line 17109
    return;
  }
#line 17112
  return;
}
}
#line 17117 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_8(void *arg0 ) 
{ 
  int (*ldv_8_callback_acquire_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_8_callback_blink_led_start)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_8_callback_blink_led_stop)(struct ixgbe_hw * , unsigned int  ) ;
  unsigned short (*ldv_8_callback_calc_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_check_for_ack)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_8_callback_check_for_msg)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_8_callback_check_for_rst)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_8_callback_check_link)(struct ixgbe_hw * , unsigned int * , _Bool * ,
                                   _Bool  ) ;
  int (*ldv_8_callback_check_overtemp)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_clear_hw_cntrs)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_clear_rar)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_8_callback_clear_vfta)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_clear_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_8_callback_disable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_disable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_enable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_enable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_enable_rx_dma)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_8_callback_fc_enable)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_get_bus_info)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_get_device_caps)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_8_callback_get_firmware_version)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_8_callback_get_invariants)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_get_link_capabilities)(struct ixgbe_hw * , unsigned int * ,
                                              _Bool * ) ;
  int (*ldv_8_callback_get_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  enum ixgbe_media_type (*ldv_8_callback_get_media_type)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_get_san_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  unsigned int (*ldv_8_callback_get_supported_physical_layer)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_get_thermal_sensor_data)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_get_wwn_prefix)(struct ixgbe_hw * , unsigned short * , unsigned short * ) ;
  int (*ldv_8_callback_identify)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_identify_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_init)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_init_hw)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_init_params)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_init_rx_addrs)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_init_thermal_sensor_thresh)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_init_uta_tables)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_led_off)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_8_callback_led_on)(struct ixgbe_hw * , unsigned int  ) ;
  _Bool (*ldv_8_callback_mng_fw_enabled)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_read)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                             unsigned short  ) ;
  int (*ldv_8_callback_read_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char * ) ;
  int (*ldv_8_callback_read_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                    unsigned short * ) ;
  int (*ldv_8_callback_read_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                      unsigned char * ) ;
  int (*ldv_8_callback_read_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_8_callback_read_i2c_sff8472)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_8_callback_read_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                    unsigned short  ) ;
  int (*ldv_8_callback_read_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                 unsigned short * ) ;
  int (*ldv_8_callback_read_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                     unsigned short * ) ;
  void (*ldv_8_callback_release_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_8_callback_reset)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_reset_hw)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_set_fw_drv_ver)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                       unsigned char  , unsigned char  ) ;
  void (*ldv_8_callback_set_lan_id)(struct ixgbe_hw * ) ;
  void (*ldv_8_callback_set_mac_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_8_callback_set_rar)(struct ixgbe_hw * , unsigned int  , unsigned char * ,
                                unsigned int  , unsigned int  ) ;
  void (*ldv_8_callback_set_rxpba)(struct ixgbe_hw * , int  , unsigned int  , int  ) ;
  int (*ldv_8_callback_set_vfta)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                 _Bool  ) ;
  void (*ldv_8_callback_set_vlan_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_8_callback_set_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_8_callback_set_vmdq_san_mac)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_8_callback_setup_link)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_setup_link_speed)(struct ixgbe_hw * , unsigned int  , _Bool  ) ;
  int (*ldv_8_callback_setup_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_start_hw)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_stop_adapter)(struct ixgbe_hw * ) ;
  void (*ldv_8_callback_stop_link_on_d3)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_update_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_8_callback_update_mc_addr_list)(struct ixgbe_hw * , struct net_device * ) ;
  int (*ldv_8_callback_validate_checksum)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_8_callback_write)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                              unsigned short  ) ;
  int (*ldv_8_callback_write_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char  ) ;
  int (*ldv_8_callback_write_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                     unsigned short * ) ;
  int (*ldv_8_callback_write_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                       unsigned char  ) ;
  int (*ldv_8_callback_write_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char  ) ;
  int (*ldv_8_callback_write_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                     unsigned short  ) ;
  int (*ldv_8_callback_write_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  unsigned short  ) ;
  int (*ldv_8_callback_write_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                      unsigned short  ) ;
  struct ixgbe_hw *ldv_8_container_struct_ixgbe_hw_ptr ;
  struct net_device *ldv_8_container_struct_net_device_ptr ;
  unsigned int *ldv_8_ldv_param_101_1_default ;
  unsigned short ldv_8_ldv_param_101_2_default ;
  unsigned short ldv_8_ldv_param_101_3_default ;
  unsigned int ldv_8_ldv_param_104_1_default ;
  unsigned int ldv_8_ldv_param_104_2_default ;
  unsigned short *ldv_8_ldv_param_104_3_default ;
  unsigned int ldv_8_ldv_param_107_1_default ;
  unsigned int ldv_8_ldv_param_107_2_default ;
  unsigned short *ldv_8_ldv_param_107_3_default ;
  unsigned short ldv_8_ldv_param_110_1_default ;
  unsigned char ldv_8_ldv_param_115_1_default ;
  unsigned char ldv_8_ldv_param_115_2_default ;
  unsigned char ldv_8_ldv_param_115_3_default ;
  unsigned char ldv_8_ldv_param_115_4_default ;
  _Bool ldv_8_ldv_param_119_1_default ;
  int ldv_8_ldv_param_119_2_default ;
  unsigned int ldv_8_ldv_param_122_1_default ;
  unsigned char *ldv_8_ldv_param_122_2_default ;
  unsigned int ldv_8_ldv_param_122_3_default ;
  unsigned int ldv_8_ldv_param_122_4_default ;
  int ldv_8_ldv_param_125_1_default ;
  unsigned int ldv_8_ldv_param_125_2_default ;
  int ldv_8_ldv_param_125_3_default ;
  unsigned int ldv_8_ldv_param_128_1_default ;
  unsigned int ldv_8_ldv_param_128_2_default ;
  _Bool ldv_8_ldv_param_128_3_default ;
  unsigned int ldv_8_ldv_param_12_1_default ;
  _Bool ldv_8_ldv_param_131_1_default ;
  int ldv_8_ldv_param_131_2_default ;
  unsigned int ldv_8_ldv_param_134_1_default ;
  unsigned int ldv_8_ldv_param_134_2_default ;
  unsigned int ldv_8_ldv_param_137_1_default ;
  unsigned int ldv_8_ldv_param_141_1_default ;
  _Bool ldv_8_ldv_param_141_2_default ;
  unsigned short *ldv_8_ldv_param_150_1_default ;
  unsigned int *ldv_8_ldv_param_153_1_default ;
  unsigned short ldv_8_ldv_param_153_2_default ;
  unsigned short ldv_8_ldv_param_153_3_default ;
  unsigned int ldv_8_ldv_param_156_1_default ;
  unsigned char ldv_8_ldv_param_156_2_default ;
  unsigned short ldv_8_ldv_param_159_1_default ;
  unsigned short ldv_8_ldv_param_159_2_default ;
  unsigned short *ldv_8_ldv_param_159_3_default ;
  unsigned char ldv_8_ldv_param_162_1_default ;
  unsigned char ldv_8_ldv_param_162_2_default ;
  unsigned char ldv_8_ldv_param_162_3_default ;
  unsigned char ldv_8_ldv_param_165_1_default ;
  unsigned char ldv_8_ldv_param_165_2_default ;
  unsigned int *ldv_8_ldv_param_168_1_default ;
  unsigned short ldv_8_ldv_param_168_2_default ;
  unsigned short ldv_8_ldv_param_168_3_default ;
  unsigned short ldv_8_ldv_param_16_1_default ;
  unsigned int ldv_8_ldv_param_171_1_default ;
  unsigned int ldv_8_ldv_param_171_2_default ;
  unsigned short ldv_8_ldv_param_171_3_default ;
  unsigned int ldv_8_ldv_param_174_1_default ;
  unsigned int ldv_8_ldv_param_174_2_default ;
  unsigned short ldv_8_ldv_param_174_3_default ;
  unsigned short ldv_8_ldv_param_19_1_default ;
  unsigned short ldv_8_ldv_param_22_1_default ;
  unsigned int *ldv_8_ldv_param_25_1_default ;
  _Bool *ldv_8_ldv_param_25_2_default ;
  _Bool ldv_8_ldv_param_25_3_default ;
  unsigned int ldv_8_ldv_param_30_1_default ;
  unsigned int ldv_8_ldv_param_34_1_default ;
  unsigned int ldv_8_ldv_param_34_2_default ;
  unsigned short ldv_8_ldv_param_3_1_default ;
  unsigned int ldv_8_ldv_param_41_1_default ;
  unsigned short *ldv_8_ldv_param_46_1_default ;
  unsigned short *ldv_8_ldv_param_49_1_default ;
  unsigned int *ldv_8_ldv_param_53_1_default ;
  _Bool *ldv_8_ldv_param_53_2_default ;
  unsigned char *ldv_8_ldv_param_56_1_default ;
  unsigned char *ldv_8_ldv_param_60_1_default ;
  unsigned short *ldv_8_ldv_param_65_1_default ;
  unsigned short *ldv_8_ldv_param_65_2_default ;
  unsigned int ldv_8_ldv_param_76_1_default ;
  unsigned int ldv_8_ldv_param_79_1_default ;
  unsigned int *ldv_8_ldv_param_83_1_default ;
  unsigned short ldv_8_ldv_param_83_2_default ;
  unsigned short ldv_8_ldv_param_83_3_default ;
  unsigned int ldv_8_ldv_param_86_1_default ;
  unsigned char *ldv_8_ldv_param_86_2_default ;
  unsigned short ldv_8_ldv_param_89_1_default ;
  unsigned short ldv_8_ldv_param_89_2_default ;
  unsigned short *ldv_8_ldv_param_89_3_default ;
  unsigned char ldv_8_ldv_param_92_1_default ;
  unsigned char ldv_8_ldv_param_92_2_default ;
  unsigned char *ldv_8_ldv_param_92_3_default ;
  unsigned char ldv_8_ldv_param_95_1_default ;
  unsigned char *ldv_8_ldv_param_95_2_default ;
  unsigned char ldv_8_ldv_param_98_1_default ;
  unsigned char *ldv_8_ldv_param_98_2_default ;
  unsigned int ldv_8_ldv_param_9_1_default ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;

  {
#line 17303
  goto ldv_call_8;
#line 17305
  return;
  ldv_call_8: 
  {
#line 17311
  tmp___24 = ldv_undef_int();
  }
#line 17311
  if (tmp___24 != 0) {
    {
#line 17315
    tmp = ldv_undef_int();
    }
    {
#line 17316
    if (tmp == 1) {
#line 17316
      goto case_1;
    } else {

    }
#line 17330
    if (tmp == 2) {
#line 17330
      goto case_2;
    } else {

    }
#line 17344
    if (tmp == 3) {
#line 17344
      goto case_3;
    } else {

    }
#line 17360
    if (tmp == 4) {
#line 17360
      goto case_4;
    } else {

    }
#line 17374
    if (tmp == 5) {
#line 17374
      goto case_5;
    } else {

    }
#line 17388
    if (tmp == 6) {
#line 17388
      goto case_6;
    } else {

    }
#line 17404
    if (tmp == 7) {
#line 17404
      goto case_7;
    } else {

    }
#line 17418
    if (tmp == 8) {
#line 17418
      goto case_8;
    } else {

    }
#line 17434
    if (tmp == 9) {
#line 17434
      goto case_9;
    } else {

    }
#line 17450
    if (tmp == 10) {
#line 17450
      goto case_10;
    } else {

    }
#line 17458
    if (tmp == 11) {
#line 17458
      goto case_11;
    } else {

    }
#line 17466
    if (tmp == 12) {
#line 17466
      goto case_12;
    } else {

    }
#line 17474
    if (tmp == 13) {
#line 17474
      goto case_13;
    } else {

    }
#line 17482
    if (tmp == 14) {
#line 17482
      goto case_14;
    } else {

    }
#line 17490
    if (tmp == 15) {
#line 17490
      goto case_15;
    } else {

    }
#line 17498
    if (tmp == 16) {
#line 17498
      goto case_16;
    } else {

    }
#line 17512
    if (tmp == 17) {
#line 17512
      goto case_17;
    } else {

    }
#line 17520
    if (tmp == 18) {
#line 17520
      goto case_18;
    } else {

    }
#line 17534
    if (tmp == 19) {
#line 17534
      goto case_19;
    } else {

    }
#line 17548
    if (tmp == 20) {
#line 17548
      goto case_20;
    } else {

    }
#line 17562
    if (tmp == 21) {
#line 17562
      goto case_21;
    } else {

    }
#line 17576
    if (tmp == 22) {
#line 17576
      goto case_22;
    } else {

    }
#line 17590
    if (tmp == 23) {
#line 17590
      goto case_23;
    } else {

    }
#line 17606
    if (tmp == 24) {
#line 17606
      goto case_24;
    } else {

    }
#line 17620
    if (tmp == 25) {
#line 17620
      goto case_25;
    } else {

    }
#line 17628
    if (tmp == 26) {
#line 17628
      goto case_26;
    } else {

    }
#line 17642
    if (tmp == 27) {
#line 17642
      goto case_27;
    } else {

    }
#line 17650
    if (tmp == 28) {
#line 17650
      goto case_28;
    } else {

    }
#line 17658
    if (tmp == 29) {
#line 17658
      goto case_29;
    } else {

    }
#line 17672
    if (tmp == 30) {
#line 17672
      goto case_30;
    } else {

    }
#line 17688
    if (tmp == 31) {
#line 17688
      goto case_31;
    } else {

    }
#line 17704
    if (tmp == 32) {
#line 17704
      goto case_32;
    } else {

    }
#line 17720
    if (tmp == 33) {
#line 17720
      goto case_33;
    } else {

    }
#line 17736
    if (tmp == 34) {
#line 17736
      goto case_34;
    } else {

    }
#line 17752
    if (tmp == 35) {
#line 17752
      goto case_35;
    } else {

    }
#line 17768
    if (tmp == 36) {
#line 17768
      goto case_36;
    } else {

    }
#line 17784
    if (tmp == 37) {
#line 17784
      goto case_37;
    } else {

    }
#line 17800
    if (tmp == 38) {
#line 17800
      goto case_38;
    } else {

    }
#line 17816
    if (tmp == 39) {
#line 17816
      goto case_39;
    } else {

    }
#line 17824
    if (tmp == 40) {
#line 17824
      goto case_40;
    } else {

    }
#line 17838
    if (tmp == 41) {
#line 17838
      goto case_41;
    } else {

    }
#line 17852
    if (tmp == 42) {
#line 17852
      goto case_42;
    } else {

    }
#line 17860
    if (tmp == 43) {
#line 17860
      goto case_43;
    } else {

    }
#line 17868
    if (tmp == 44) {
#line 17868
      goto case_44;
    } else {

    }
#line 17876
    if (tmp == 45) {
#line 17876
      goto case_45;
    } else {

    }
#line 17884
    if (tmp == 46) {
#line 17884
      goto case_46;
    } else {

    }
#line 17892
    if (tmp == 47) {
#line 17892
      goto case_47;
    } else {

    }
#line 17900
    if (tmp == 48) {
#line 17900
      goto case_48;
    } else {

    }
#line 17908
    if (tmp == 49) {
#line 17908
      goto case_49;
    } else {

    }
#line 17916
    if (tmp == 50) {
#line 17916
      goto case_50;
    } else {

    }
#line 17934
    if (tmp == 51) {
#line 17934
      goto case_51;
    } else {

    }
#line 17942
    if (tmp == 52) {
#line 17942
      goto case_52;
    } else {

    }
#line 17950
    if (tmp == 53) {
#line 17950
      goto case_53;
    } else {

    }
#line 17966
    if (tmp == 54) {
#line 17966
      goto case_54;
    } else {

    }
#line 17974
    if (tmp == 55) {
#line 17974
      goto case_55;
    } else {

    }
#line 17990
    if (tmp == 56) {
#line 17990
      goto case_56;
    } else {

    }
#line 18008
    if (tmp == 57) {
#line 18008
      goto case_57;
    } else {

    }
#line 18016
    if (tmp == 58) {
#line 18016
      goto case_58;
    } else {

    }
#line 18032
    if (tmp == 59) {
#line 18032
      goto case_59;
    } else {

    }
#line 18048
    if (tmp == 60) {
#line 18048
      goto case_60;
    } else {

    }
#line 18056
    if (tmp == 61) {
#line 18056
      goto case_61;
    } else {

    }
#line 18064
    if (tmp == 62) {
#line 18064
      goto case_62;
    } else {

    }
#line 18078
    if (tmp == 63) {
#line 18078
      goto case_63;
    } else {

    }
#line 18086
    if (tmp == 64) {
#line 18086
      goto case_64;
    } else {

    }
#line 18094
    if (tmp == 65) {
#line 18094
      goto case_65;
    } else {

    }
#line 18102
    if (tmp == 66) {
#line 18102
      goto case_66;
    } else {

    }
#line 18110
    if (tmp == 67) {
#line 18110
      goto case_67;
    } else {

    }
#line 18124
    if (tmp == 68) {
#line 18124
      goto case_68;
    } else {

    }
#line 18132
    if (tmp == 69) {
#line 18132
      goto case_69;
    } else {

    }
#line 18146
    if (tmp == 70) {
#line 18146
      goto case_70;
    } else {

    }
#line 18154
    if (tmp == 71) {
#line 18154
      goto case_71;
    } else {

    }
#line 18162
    if (tmp == 72) {
#line 18162
      goto case_72;
    } else {

    }
#line 18180
    if (tmp == 73) {
#line 18180
      goto case_73;
    } else {

    }
#line 18194
    if (tmp == 74) {
#line 18194
      goto case_74;
    } else {

    }
#line 18208
    if (tmp == 75) {
#line 18208
      goto case_75;
    } else {

    }
#line 18222
    if (tmp == 76) {
#line 18222
      goto case_76;
    } else {

    }
#line 18230
    if (tmp == 77) {
#line 18230
      goto case_77;
    } else {

    }
#line 18244
    if (tmp == 78) {
#line 18244
      goto case_78;
    } else {

    }
#line 18258
    if (tmp == 79) {
#line 18258
      goto case_79;
    } else {

    }
#line 18266
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 17322
    ldv_dummy_resourceless_instance_callback_8_174(ldv_8_callback_write_reg_mdi, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_174_1_default,
                                                   ldv_8_ldv_param_174_2_default,
                                                   (int )ldv_8_ldv_param_174_3_default);
    }
#line 17328
    goto ldv_62959;
    case_2: /* CIL Label */ 
    {
#line 17336
    ldv_dummy_resourceless_instance_callback_8_171(ldv_8_callback_write_reg, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_171_1_default,
                                                   ldv_8_ldv_param_171_2_default,
                                                   (int )ldv_8_ldv_param_171_3_default);
    }
#line 17342
    goto ldv_62959;
    case_3: /* CIL Label */ 
    {
#line 17346
    tmp___0 = ldv_xmalloc(4UL);
#line 17346
    ldv_8_ldv_param_168_1_default = (unsigned int *)tmp___0;
#line 17351
    ldv_dummy_resourceless_instance_callback_8_168(ldv_8_callback_write_posted, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_168_1_default,
                                                   (int )ldv_8_ldv_param_168_2_default,
                                                   (int )ldv_8_ldv_param_168_3_default);
#line 17355
    ldv_free((void *)ldv_8_ldv_param_168_1_default);
    }
#line 17358
    goto ldv_62959;
    case_4: /* CIL Label */ 
    {
#line 17366
    ldv_dummy_resourceless_instance_callback_8_165(ldv_8_callback_write_i2c_eeprom,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_8_ldv_param_165_1_default,
                                                   (int )ldv_8_ldv_param_165_2_default);
    }
#line 17372
    goto ldv_62959;
    case_5: /* CIL Label */ 
    {
#line 17380
    ldv_dummy_resourceless_instance_callback_8_162(ldv_8_callback_write_i2c_byte,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_8_ldv_param_162_1_default,
                                                   (int )ldv_8_ldv_param_162_2_default,
                                                   (int )ldv_8_ldv_param_162_3_default);
    }
#line 17386
    goto ldv_62959;
    case_6: /* CIL Label */ 
    {
#line 17390
    tmp___1 = ldv_xmalloc(2UL);
#line 17390
    ldv_8_ldv_param_159_3_default = (unsigned short *)tmp___1;
#line 17395
    ldv_dummy_resourceless_instance_callback_8_159(ldv_8_callback_write_buffer, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_8_ldv_param_159_1_default,
                                                   (int )ldv_8_ldv_param_159_2_default,
                                                   ldv_8_ldv_param_159_3_default);
#line 17399
    ldv_free((void *)ldv_8_ldv_param_159_3_default);
    }
#line 17402
    goto ldv_62959;
    case_7: /* CIL Label */ 
    {
#line 17410
    ldv_dummy_resourceless_instance_callback_8_156(ldv_8_callback_write_analog_reg8,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_156_1_default,
                                                   (int )ldv_8_ldv_param_156_2_default);
    }
#line 17416
    goto ldv_62959;
    case_8: /* CIL Label */ 
    {
#line 17420
    tmp___2 = ldv_xmalloc(4UL);
#line 17420
    ldv_8_ldv_param_153_1_default = (unsigned int *)tmp___2;
#line 17425
    ldv_dummy_resourceless_instance_callback_8_153(ldv_8_callback_write, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_153_1_default,
                                                   (int )ldv_8_ldv_param_153_2_default,
                                                   (int )ldv_8_ldv_param_153_3_default);
#line 17429
    ldv_free((void *)ldv_8_ldv_param_153_1_default);
    }
#line 17432
    goto ldv_62959;
    case_9: /* CIL Label */ 
    {
#line 17436
    tmp___3 = ldv_xmalloc(2UL);
#line 17436
    ldv_8_ldv_param_150_1_default = (unsigned short *)tmp___3;
#line 17441
    ldv_dummy_resourceless_instance_callback_8_150(ldv_8_callback_validate_checksum,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_150_1_default);
#line 17445
    ldv_free((void *)ldv_8_ldv_param_150_1_default);
    }
#line 17448
    goto ldv_62959;
    case_10: /* CIL Label */ 
    {
#line 17453
    ldv_dummy_resourceless_instance_callback_8_149(ldv_8_callback_update_mc_addr_list,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_container_struct_net_device_ptr);
    }
#line 17456
    goto ldv_62959;
    case_11: /* CIL Label */ 
    {
#line 17461
    ldv_dummy_resourceless_instance_callback_8_148(ldv_8_callback_update_checksum,
                                                   ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17464
    goto ldv_62959;
    case_12: /* CIL Label */ 
    {
#line 17469
    ldv_dummy_resourceless_instance_callback_8_147(ldv_8_callback_stop_link_on_d3,
                                                   ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17472
    goto ldv_62959;
    case_13: /* CIL Label */ 
    {
#line 17477
    ldv_dummy_resourceless_instance_callback_8_146(ldv_8_callback_stop_adapter, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17480
    goto ldv_62959;
    case_14: /* CIL Label */ 
    {
#line 17485
    ldv_dummy_resourceless_instance_callback_8_145(ldv_8_callback_start_hw, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17488
    goto ldv_62959;
    case_15: /* CIL Label */ 
    {
#line 17493
    ldv_dummy_resourceless_instance_callback_8_144(ldv_8_callback_setup_sfp, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17496
    goto ldv_62959;
    case_16: /* CIL Label */ 
    {
#line 17504
    ldv_dummy_resourceless_instance_callback_8_141(ldv_8_callback_setup_link_speed,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_141_1_default,
                                                   (int )ldv_8_ldv_param_141_2_default);
    }
#line 17510
    goto ldv_62959;
    case_17: /* CIL Label */ 
    {
#line 17515
    ldv_dummy_resourceless_instance_callback_8_140(ldv_8_callback_setup_link, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17518
    goto ldv_62959;
    case_18: /* CIL Label */ 
    {
#line 17526
    ldv_dummy_resourceless_instance_callback_8_137(ldv_8_callback_set_vmdq_san_mac,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_137_1_default);
    }
#line 17532
    goto ldv_62959;
    case_19: /* CIL Label */ 
    {
#line 17540
    ldv_dummy_resourceless_instance_callback_8_134(ldv_8_callback_set_vmdq, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_134_1_default,
                                                   ldv_8_ldv_param_134_2_default);
    }
#line 17546
    goto ldv_62959;
    case_20: /* CIL Label */ 
    {
#line 17554
    ldv_dummy_resourceless_instance_callback_8_131(ldv_8_callback_set_vlan_anti_spoofing,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_8_ldv_param_131_1_default,
                                                   ldv_8_ldv_param_131_2_default);
    }
#line 17560
    goto ldv_62959;
    case_21: /* CIL Label */ 
    {
#line 17568
    ldv_dummy_resourceless_instance_callback_8_128(ldv_8_callback_set_vfta, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_128_1_default,
                                                   ldv_8_ldv_param_128_2_default,
                                                   (int )ldv_8_ldv_param_128_3_default);
    }
#line 17574
    goto ldv_62959;
    case_22: /* CIL Label */ 
    {
#line 17582
    ldv_dummy_resourceless_instance_callback_8_125(ldv_8_callback_set_rxpba, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_125_1_default,
                                                   ldv_8_ldv_param_125_2_default,
                                                   ldv_8_ldv_param_125_3_default);
    }
#line 17588
    goto ldv_62959;
    case_23: /* CIL Label */ 
    {
#line 17592
    tmp___4 = ldv_xmalloc(1UL);
#line 17592
    ldv_8_ldv_param_122_2_default = (unsigned char *)tmp___4;
#line 17597
    ldv_dummy_resourceless_instance_callback_8_122(ldv_8_callback_set_rar, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_122_1_default,
                                                   ldv_8_ldv_param_122_2_default,
                                                   ldv_8_ldv_param_122_3_default,
                                                   ldv_8_ldv_param_122_4_default);
#line 17601
    ldv_free((void *)ldv_8_ldv_param_122_2_default);
    }
#line 17604
    goto ldv_62959;
    case_24: /* CIL Label */ 
    {
#line 17612
    ldv_dummy_resourceless_instance_callback_8_119(ldv_8_callback_set_mac_anti_spoofing,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_8_ldv_param_119_1_default,
                                                   ldv_8_ldv_param_119_2_default);
    }
#line 17618
    goto ldv_62959;
    case_25: /* CIL Label */ 
    {
#line 17623
    ldv_dummy_resourceless_instance_callback_8_118(ldv_8_callback_set_lan_id, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17626
    goto ldv_62959;
    case_26: /* CIL Label */ 
    {
#line 17634
    ldv_dummy_resourceless_instance_callback_8_115(ldv_8_callback_set_fw_drv_ver,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_8_ldv_param_115_1_default,
                                                   (int )ldv_8_ldv_param_115_2_default,
                                                   (int )ldv_8_ldv_param_115_3_default,
                                                   (int )ldv_8_ldv_param_115_4_default);
    }
#line 17640
    goto ldv_62959;
    case_27: /* CIL Label */ 
    {
#line 17645
    ldv_dummy_resourceless_instance_callback_8_114(ldv_8_callback_reset_hw, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17648
    goto ldv_62959;
    case_28: /* CIL Label */ 
    {
#line 17653
    ldv_dummy_resourceless_instance_callback_8_113(ldv_8_callback_reset, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17656
    goto ldv_62959;
    case_29: /* CIL Label */ 
    {
#line 17664
    ldv_dummy_resourceless_instance_callback_8_110(ldv_8_callback_release_swfw_sync,
                                                   ldv_8_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_8_ldv_param_110_1_default);
    }
#line 17670
    goto ldv_62959;
    case_30: /* CIL Label */ 
    {
#line 17674
    tmp___5 = ldv_xmalloc(2UL);
#line 17674
    ldv_8_ldv_param_107_3_default = (unsigned short *)tmp___5;
#line 17679
    ldv_dummy_resourceless_instance_callback_8_107(ldv_8_callback_read_reg_mdi, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_107_1_default,
                                                   ldv_8_ldv_param_107_2_default,
                                                   ldv_8_ldv_param_107_3_default);
#line 17683
    ldv_free((void *)ldv_8_ldv_param_107_3_default);
    }
#line 17686
    goto ldv_62959;
    case_31: /* CIL Label */ 
    {
#line 17690
    tmp___6 = ldv_xmalloc(2UL);
#line 17690
    ldv_8_ldv_param_104_3_default = (unsigned short *)tmp___6;
#line 17695
    ldv_dummy_resourceless_instance_callback_8_104(ldv_8_callback_read_reg, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_104_1_default,
                                                   ldv_8_ldv_param_104_2_default,
                                                   ldv_8_ldv_param_104_3_default);
#line 17699
    ldv_free((void *)ldv_8_ldv_param_104_3_default);
    }
#line 17702
    goto ldv_62959;
    case_32: /* CIL Label */ 
    {
#line 17706
    tmp___7 = ldv_xmalloc(4UL);
#line 17706
    ldv_8_ldv_param_101_1_default = (unsigned int *)tmp___7;
#line 17711
    ldv_dummy_resourceless_instance_callback_8_101(ldv_8_callback_read_posted, ldv_8_container_struct_ixgbe_hw_ptr,
                                                   ldv_8_ldv_param_101_1_default,
                                                   (int )ldv_8_ldv_param_101_2_default,
                                                   (int )ldv_8_ldv_param_101_3_default);
#line 17715
    ldv_free((void *)ldv_8_ldv_param_101_1_default);
    }
#line 17718
    goto ldv_62959;
    case_33: /* CIL Label */ 
    {
#line 17722
    tmp___8 = ldv_xmalloc(1UL);
#line 17722
    ldv_8_ldv_param_98_2_default = (unsigned char *)tmp___8;
#line 17727
    ldv_dummy_resourceless_instance_callback_8_98(ldv_8_callback_read_i2c_sff8472,
                                                  ldv_8_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_8_ldv_param_98_1_default,
                                                  ldv_8_ldv_param_98_2_default);
#line 17731
    ldv_free((void *)ldv_8_ldv_param_98_2_default);
    }
#line 17734
    goto ldv_62959;
    case_34: /* CIL Label */ 
    {
#line 17738
    tmp___9 = ldv_xmalloc(1UL);
#line 17738
    ldv_8_ldv_param_95_2_default = (unsigned char *)tmp___9;
#line 17743
    ldv_dummy_resourceless_instance_callback_8_95(ldv_8_callback_read_i2c_eeprom,
                                                  ldv_8_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_8_ldv_param_95_1_default,
                                                  ldv_8_ldv_param_95_2_default);
#line 17747
    ldv_free((void *)ldv_8_ldv_param_95_2_default);
    }
#line 17750
    goto ldv_62959;
    case_35: /* CIL Label */ 
    {
#line 17754
    tmp___10 = ldv_xmalloc(1UL);
#line 17754
    ldv_8_ldv_param_92_3_default = (unsigned char *)tmp___10;
#line 17759
    ldv_dummy_resourceless_instance_callback_8_92(ldv_8_callback_read_i2c_byte, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_8_ldv_param_92_1_default,
                                                  (int )ldv_8_ldv_param_92_2_default,
                                                  ldv_8_ldv_param_92_3_default);
#line 17763
    ldv_free((void *)ldv_8_ldv_param_92_3_default);
    }
#line 17766
    goto ldv_62959;
    case_36: /* CIL Label */ 
    {
#line 17770
    tmp___11 = ldv_xmalloc(2UL);
#line 17770
    ldv_8_ldv_param_89_3_default = (unsigned short *)tmp___11;
#line 17775
    ldv_dummy_resourceless_instance_callback_8_89(ldv_8_callback_read_buffer, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_8_ldv_param_89_1_default,
                                                  (int )ldv_8_ldv_param_89_2_default,
                                                  ldv_8_ldv_param_89_3_default);
#line 17779
    ldv_free((void *)ldv_8_ldv_param_89_3_default);
    }
#line 17782
    goto ldv_62959;
    case_37: /* CIL Label */ 
    {
#line 17786
    tmp___12 = ldv_xmalloc(1UL);
#line 17786
    ldv_8_ldv_param_86_2_default = (unsigned char *)tmp___12;
#line 17791
    ldv_dummy_resourceless_instance_callback_8_86(ldv_8_callback_read_analog_reg8,
                                                  ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_86_1_default, ldv_8_ldv_param_86_2_default);
#line 17795
    ldv_free((void *)ldv_8_ldv_param_86_2_default);
    }
#line 17798
    goto ldv_62959;
    case_38: /* CIL Label */ 
    {
#line 17802
    tmp___13 = ldv_xmalloc(4UL);
#line 17802
    ldv_8_ldv_param_83_1_default = (unsigned int *)tmp___13;
#line 17807
    ldv_dummy_resourceless_instance_callback_8_83(ldv_8_callback_read, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_83_1_default, (int )ldv_8_ldv_param_83_2_default,
                                                  (int )ldv_8_ldv_param_83_3_default);
#line 17811
    ldv_free((void *)ldv_8_ldv_param_83_1_default);
    }
#line 17814
    goto ldv_62959;
    case_39: /* CIL Label */ 
    {
#line 17819
    ldv_dummy_resourceless_instance_callback_8_82(ldv_8_callback_mng_fw_enabled, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17822
    goto ldv_62959;
    case_40: /* CIL Label */ 
    {
#line 17830
    ldv_dummy_resourceless_instance_callback_8_79(ldv_8_callback_led_on, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_79_1_default);
    }
#line 17836
    goto ldv_62959;
    case_41: /* CIL Label */ 
    {
#line 17844
    ldv_dummy_resourceless_instance_callback_8_76(ldv_8_callback_led_off, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_76_1_default);
    }
#line 17850
    goto ldv_62959;
    case_42: /* CIL Label */ 
    {
#line 17855
    ldv_dummy_resourceless_instance_callback_8_75(ldv_8_callback_init_uta_tables,
                                                  ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17858
    goto ldv_62959;
    case_43: /* CIL Label */ 
    {
#line 17863
    ldv_dummy_resourceless_instance_callback_8_74(ldv_8_callback_init_thermal_sensor_thresh,
                                                  ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17866
    goto ldv_62959;
    case_44: /* CIL Label */ 
    {
#line 17871
    ldv_dummy_resourceless_instance_callback_8_73(ldv_8_callback_init_rx_addrs, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17874
    goto ldv_62959;
    case_45: /* CIL Label */ 
    {
#line 17879
    ldv_dummy_resourceless_instance_callback_8_72(ldv_8_callback_init_params, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17882
    goto ldv_62959;
    case_46: /* CIL Label */ 
    {
#line 17887
    ldv_dummy_resourceless_instance_callback_8_71(ldv_8_callback_init_hw, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17890
    goto ldv_62959;
    case_47: /* CIL Label */ 
    {
#line 17895
    ldv_dummy_resourceless_instance_callback_8_70(ldv_8_callback_init, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17898
    goto ldv_62959;
    case_48: /* CIL Label */ 
    {
#line 17903
    ldv_dummy_resourceless_instance_callback_8_69(ldv_8_callback_identify_sfp, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17906
    goto ldv_62959;
    case_49: /* CIL Label */ 
    {
#line 17911
    ldv_dummy_resourceless_instance_callback_8_68(ldv_8_callback_identify, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17914
    goto ldv_62959;
    case_50: /* CIL Label */ 
    {
#line 17918
    tmp___14 = ldv_xmalloc(2UL);
#line 17918
    ldv_8_ldv_param_65_1_default = (unsigned short *)tmp___14;
#line 17919
    tmp___15 = ldv_xmalloc(2UL);
#line 17919
    ldv_8_ldv_param_65_2_default = (unsigned short *)tmp___15;
#line 17924
    ldv_dummy_resourceless_instance_callback_8_65(ldv_8_callback_get_wwn_prefix, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_65_1_default, ldv_8_ldv_param_65_2_default);
#line 17928
    ldv_free((void *)ldv_8_ldv_param_65_1_default);
#line 17929
    ldv_free((void *)ldv_8_ldv_param_65_2_default);
    }
#line 17932
    goto ldv_62959;
    case_51: /* CIL Label */ 
    {
#line 17937
    ldv_dummy_resourceless_instance_callback_8_64(ldv_8_callback_get_thermal_sensor_data,
                                                  ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17940
    goto ldv_62959;
    case_52: /* CIL Label */ 
    {
#line 17945
    ldv_dummy_resourceless_instance_callback_8_63(ldv_8_callback_get_supported_physical_layer,
                                                  ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17948
    goto ldv_62959;
    case_53: /* CIL Label */ 
    {
#line 17952
    tmp___16 = ldv_xmalloc(1UL);
#line 17952
    ldv_8_ldv_param_60_1_default = (unsigned char *)tmp___16;
#line 17957
    ldv_dummy_resourceless_instance_callback_8_60(ldv_8_callback_get_san_mac_addr,
                                                  ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_60_1_default);
#line 17961
    ldv_free((void *)ldv_8_ldv_param_60_1_default);
    }
#line 17964
    goto ldv_62959;
    case_54: /* CIL Label */ 
    {
#line 17969
    ldv_dummy_resourceless_instance_callback_8_59(ldv_8_callback_get_media_type, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 17972
    goto ldv_62959;
    case_55: /* CIL Label */ 
    {
#line 17976
    tmp___17 = ldv_xmalloc(1UL);
#line 17976
    ldv_8_ldv_param_56_1_default = (unsigned char *)tmp___17;
#line 17981
    ldv_dummy_resourceless_instance_callback_8_56(ldv_8_callback_get_mac_addr, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_56_1_default);
#line 17985
    ldv_free((void *)ldv_8_ldv_param_56_1_default);
    }
#line 17988
    goto ldv_62959;
    case_56: /* CIL Label */ 
    {
#line 17992
    tmp___18 = ldv_xmalloc(4UL);
#line 17992
    ldv_8_ldv_param_53_1_default = (unsigned int *)tmp___18;
#line 17993
    tmp___19 = ldv_xmalloc(1UL);
#line 17993
    ldv_8_ldv_param_53_2_default = (_Bool *)tmp___19;
#line 17998
    ldv_dummy_resourceless_instance_callback_8_53(ldv_8_callback_get_link_capabilities,
                                                  ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_53_1_default, ldv_8_ldv_param_53_2_default);
#line 18002
    ldv_free((void *)ldv_8_ldv_param_53_1_default);
#line 18003
    ldv_free((void *)ldv_8_ldv_param_53_2_default);
    }
#line 18006
    goto ldv_62959;
    case_57: /* CIL Label */ 
    {
#line 18011
    ldv_dummy_resourceless_instance_callback_8_52(ldv_8_callback_get_invariants, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18014
    goto ldv_62959;
    case_58: /* CIL Label */ 
    {
#line 18018
    tmp___20 = ldv_xmalloc(2UL);
#line 18018
    ldv_8_ldv_param_49_1_default = (unsigned short *)tmp___20;
#line 18023
    ldv_dummy_resourceless_instance_callback_8_49(ldv_8_callback_get_firmware_version,
                                                  ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_49_1_default);
#line 18027
    ldv_free((void *)ldv_8_ldv_param_49_1_default);
    }
#line 18030
    goto ldv_62959;
    case_59: /* CIL Label */ 
    {
#line 18034
    tmp___21 = ldv_xmalloc(2UL);
#line 18034
    ldv_8_ldv_param_46_1_default = (unsigned short *)tmp___21;
#line 18039
    ldv_dummy_resourceless_instance_callback_8_46(ldv_8_callback_get_device_caps,
                                                  ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_46_1_default);
#line 18043
    ldv_free((void *)ldv_8_ldv_param_46_1_default);
    }
#line 18046
    goto ldv_62959;
    case_60: /* CIL Label */ 
    {
#line 18051
    ldv_dummy_resourceless_instance_callback_8_45(ldv_8_callback_get_bus_info, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18054
    goto ldv_62959;
    case_61: /* CIL Label */ 
    {
#line 18059
    ldv_dummy_resourceless_instance_callback_8_44(ldv_8_callback_fc_enable, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18062
    goto ldv_62959;
    case_62: /* CIL Label */ 
    {
#line 18070
    ldv_dummy_resourceless_instance_callback_8_41(ldv_8_callback_enable_rx_dma, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_41_1_default);
    }
#line 18076
    goto ldv_62959;
    case_63: /* CIL Label */ 
    {
#line 18081
    ldv_dummy_resourceless_instance_callback_8_40(ldv_8_callback_enable_rx_buff, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18084
    goto ldv_62959;
    case_64: /* CIL Label */ 
    {
#line 18089
    ldv_dummy_resourceless_instance_callback_8_39(ldv_8_callback_enable_mc, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18092
    goto ldv_62959;
    case_65: /* CIL Label */ 
    {
#line 18097
    ldv_dummy_resourceless_instance_callback_8_38(ldv_8_callback_disable_rx_buff,
                                                  ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18100
    goto ldv_62959;
    case_66: /* CIL Label */ 
    {
#line 18105
    ldv_dummy_resourceless_instance_callback_8_37(ldv_8_callback_disable_mc, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18108
    goto ldv_62959;
    case_67: /* CIL Label */ 
    {
#line 18116
    ldv_dummy_resourceless_instance_callback_8_34(ldv_8_callback_clear_vmdq, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_34_1_default, ldv_8_ldv_param_34_2_default);
    }
#line 18122
    goto ldv_62959;
    case_68: /* CIL Label */ 
    {
#line 18127
    ldv_dummy_resourceless_instance_callback_8_33(ldv_8_callback_clear_vfta, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18130
    goto ldv_62959;
    case_69: /* CIL Label */ 
    {
#line 18138
    ldv_dummy_resourceless_instance_callback_8_30(ldv_8_callback_clear_rar, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_30_1_default);
    }
#line 18144
    goto ldv_62959;
    case_70: /* CIL Label */ 
    {
#line 18149
    ldv_dummy_resourceless_instance_callback_8_29(ldv_8_callback_clear_hw_cntrs, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18152
    goto ldv_62959;
    case_71: /* CIL Label */ 
    {
#line 18157
    ldv_dummy_resourceless_instance_callback_8_28(ldv_8_callback_check_overtemp, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18160
    goto ldv_62959;
    case_72: /* CIL Label */ 
    {
#line 18164
    tmp___22 = ldv_xmalloc(4UL);
#line 18164
    ldv_8_ldv_param_25_1_default = (unsigned int *)tmp___22;
#line 18165
    tmp___23 = ldv_xmalloc(1UL);
#line 18165
    ldv_8_ldv_param_25_2_default = (_Bool *)tmp___23;
#line 18170
    ldv_dummy_resourceless_instance_callback_8_25(ldv_8_callback_check_link, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_25_1_default, ldv_8_ldv_param_25_2_default,
                                                  (int )ldv_8_ldv_param_25_3_default);
#line 18174
    ldv_free((void *)ldv_8_ldv_param_25_1_default);
#line 18175
    ldv_free((void *)ldv_8_ldv_param_25_2_default);
    }
#line 18178
    goto ldv_62959;
    case_73: /* CIL Label */ 
    {
#line 18186
    ldv_dummy_resourceless_instance_callback_8_22(ldv_8_callback_check_for_rst, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_8_ldv_param_22_1_default);
    }
#line 18192
    goto ldv_62959;
    case_74: /* CIL Label */ 
    {
#line 18200
    ldv_dummy_resourceless_instance_callback_8_19(ldv_8_callback_check_for_msg, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_8_ldv_param_19_1_default);
    }
#line 18206
    goto ldv_62959;
    case_75: /* CIL Label */ 
    {
#line 18214
    ldv_dummy_resourceless_instance_callback_8_16(ldv_8_callback_check_for_ack, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_8_ldv_param_16_1_default);
    }
#line 18220
    goto ldv_62959;
    case_76: /* CIL Label */ 
    {
#line 18225
    ldv_dummy_resourceless_instance_callback_8_15(ldv_8_callback_calc_checksum, ldv_8_container_struct_ixgbe_hw_ptr);
    }
#line 18228
    goto ldv_62959;
    case_77: /* CIL Label */ 
    {
#line 18236
    ldv_dummy_resourceless_instance_callback_8_12(ldv_8_callback_blink_led_stop, ldv_8_container_struct_ixgbe_hw_ptr,
                                                  ldv_8_ldv_param_12_1_default);
    }
#line 18242
    goto ldv_62959;
    case_78: /* CIL Label */ 
    {
#line 18250
    ldv_dummy_resourceless_instance_callback_8_9(ldv_8_callback_blink_led_start, ldv_8_container_struct_ixgbe_hw_ptr,
                                                 ldv_8_ldv_param_9_1_default);
    }
#line 18256
    goto ldv_62959;
    case_79: /* CIL Label */ 
    {
#line 18261
    ldv_dummy_resourceless_instance_callback_8_3(ldv_8_callback_acquire_swfw_sync,
                                                 ldv_8_container_struct_ixgbe_hw_ptr,
                                                 (int )ldv_8_ldv_param_3_1_default);
    }
#line 18264
    goto ldv_62959;
    switch_default: /* CIL Label */ 
    {
#line 18266
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_62959: ;
#line 18275
    goto ldv_call_8;
  } else {
#line 18283
    return;
  }
#line 18286
  return;
}
}
#line 18291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_struct_ixgbe_phy_operations_dummy_resourceless_instance_9(void *arg0 ) 
{ 
  int (*ldv_9_callback_acquire_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_9_callback_blink_led_start)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_9_callback_blink_led_stop)(struct ixgbe_hw * , unsigned int  ) ;
  unsigned short (*ldv_9_callback_calc_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_check_for_ack)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_9_callback_check_for_msg)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_9_callback_check_for_rst)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_9_callback_check_link)(struct ixgbe_hw * , unsigned int * , _Bool * ,
                                   _Bool  ) ;
  int (*ldv_9_callback_check_overtemp)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_clear_hw_cntrs)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_clear_rar)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_9_callback_clear_vfta)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_clear_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_9_callback_disable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_disable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_enable_mc)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_enable_rx_buff)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_enable_rx_dma)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_9_callback_fc_enable)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_get_bus_info)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_get_device_caps)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_9_callback_get_firmware_version)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_9_callback_get_invariants)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_get_link_capabilities)(struct ixgbe_hw * , unsigned int * ,
                                              _Bool * ) ;
  int (*ldv_9_callback_get_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  enum ixgbe_media_type (*ldv_9_callback_get_media_type)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_get_san_mac_addr)(struct ixgbe_hw * , unsigned char * ) ;
  unsigned int (*ldv_9_callback_get_supported_physical_layer)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_get_thermal_sensor_data)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_get_wwn_prefix)(struct ixgbe_hw * , unsigned short * , unsigned short * ) ;
  int (*ldv_9_callback_identify)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_identify_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_init)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_init_hw)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_init_params)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_init_rx_addrs)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_init_thermal_sensor_thresh)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_init_uta_tables)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_led_off)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_9_callback_led_on)(struct ixgbe_hw * , unsigned int  ) ;
  _Bool (*ldv_9_callback_mng_fw_enabled)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_read)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                             unsigned short  ) ;
  int (*ldv_9_callback_read_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char * ) ;
  int (*ldv_9_callback_read_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                    unsigned short * ) ;
  int (*ldv_9_callback_read_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                      unsigned char * ) ;
  int (*ldv_9_callback_read_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_9_callback_read_i2c_sff8472)(struct ixgbe_hw * , unsigned char  , unsigned char * ) ;
  int (*ldv_9_callback_read_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                    unsigned short  ) ;
  int (*ldv_9_callback_read_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                 unsigned short * ) ;
  int (*ldv_9_callback_read_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                     unsigned short * ) ;
  void (*ldv_9_callback_release_swfw_sync)(struct ixgbe_hw * , unsigned short  ) ;
  int (*ldv_9_callback_reset)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_reset_hw)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_set_fw_drv_ver)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                       unsigned char  , unsigned char  ) ;
  void (*ldv_9_callback_set_lan_id)(struct ixgbe_hw * ) ;
  void (*ldv_9_callback_set_mac_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_9_callback_set_rar)(struct ixgbe_hw * , unsigned int  , unsigned char * ,
                                unsigned int  , unsigned int  ) ;
  void (*ldv_9_callback_set_rxpba)(struct ixgbe_hw * , int  , unsigned int  , int  ) ;
  int (*ldv_9_callback_set_vfta)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                 _Bool  ) ;
  void (*ldv_9_callback_set_vlan_anti_spoofing)(struct ixgbe_hw * , _Bool  , int  ) ;
  int (*ldv_9_callback_set_vmdq)(struct ixgbe_hw * , unsigned int  , unsigned int  ) ;
  int (*ldv_9_callback_set_vmdq_san_mac)(struct ixgbe_hw * , unsigned int  ) ;
  int (*ldv_9_callback_setup_link)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_setup_link_speed)(struct ixgbe_hw * , unsigned int  , _Bool  ) ;
  int (*ldv_9_callback_setup_sfp)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_start_hw)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_stop_adapter)(struct ixgbe_hw * ) ;
  void (*ldv_9_callback_stop_link_on_d3)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_update_checksum)(struct ixgbe_hw * ) ;
  int (*ldv_9_callback_update_mc_addr_list)(struct ixgbe_hw * , struct net_device * ) ;
  int (*ldv_9_callback_validate_checksum)(struct ixgbe_hw * , unsigned short * ) ;
  int (*ldv_9_callback_write)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                              unsigned short  ) ;
  int (*ldv_9_callback_write_analog_reg8)(struct ixgbe_hw * , unsigned int  , unsigned char  ) ;
  int (*ldv_9_callback_write_buffer)(struct ixgbe_hw * , unsigned short  , unsigned short  ,
                                     unsigned short * ) ;
  int (*ldv_9_callback_write_i2c_byte)(struct ixgbe_hw * , unsigned char  , unsigned char  ,
                                       unsigned char  ) ;
  int (*ldv_9_callback_write_i2c_eeprom)(struct ixgbe_hw * , unsigned char  , unsigned char  ) ;
  int (*ldv_9_callback_write_posted)(struct ixgbe_hw * , unsigned int * , unsigned short  ,
                                     unsigned short  ) ;
  int (*ldv_9_callback_write_reg)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                  unsigned short  ) ;
  int (*ldv_9_callback_write_reg_mdi)(struct ixgbe_hw * , unsigned int  , unsigned int  ,
                                      unsigned short  ) ;
  struct ixgbe_hw *ldv_9_container_struct_ixgbe_hw_ptr ;
  struct net_device *ldv_9_container_struct_net_device_ptr ;
  unsigned int *ldv_9_ldv_param_101_1_default ;
  unsigned short ldv_9_ldv_param_101_2_default ;
  unsigned short ldv_9_ldv_param_101_3_default ;
  unsigned int ldv_9_ldv_param_104_1_default ;
  unsigned int ldv_9_ldv_param_104_2_default ;
  unsigned short *ldv_9_ldv_param_104_3_default ;
  unsigned int ldv_9_ldv_param_107_1_default ;
  unsigned int ldv_9_ldv_param_107_2_default ;
  unsigned short *ldv_9_ldv_param_107_3_default ;
  unsigned short ldv_9_ldv_param_110_1_default ;
  unsigned char ldv_9_ldv_param_115_1_default ;
  unsigned char ldv_9_ldv_param_115_2_default ;
  unsigned char ldv_9_ldv_param_115_3_default ;
  unsigned char ldv_9_ldv_param_115_4_default ;
  _Bool ldv_9_ldv_param_119_1_default ;
  int ldv_9_ldv_param_119_2_default ;
  unsigned int ldv_9_ldv_param_122_1_default ;
  unsigned char *ldv_9_ldv_param_122_2_default ;
  unsigned int ldv_9_ldv_param_122_3_default ;
  unsigned int ldv_9_ldv_param_122_4_default ;
  int ldv_9_ldv_param_125_1_default ;
  unsigned int ldv_9_ldv_param_125_2_default ;
  int ldv_9_ldv_param_125_3_default ;
  unsigned int ldv_9_ldv_param_128_1_default ;
  unsigned int ldv_9_ldv_param_128_2_default ;
  _Bool ldv_9_ldv_param_128_3_default ;
  unsigned int ldv_9_ldv_param_12_1_default ;
  _Bool ldv_9_ldv_param_131_1_default ;
  int ldv_9_ldv_param_131_2_default ;
  unsigned int ldv_9_ldv_param_134_1_default ;
  unsigned int ldv_9_ldv_param_134_2_default ;
  unsigned int ldv_9_ldv_param_137_1_default ;
  unsigned int ldv_9_ldv_param_141_1_default ;
  _Bool ldv_9_ldv_param_141_2_default ;
  unsigned short *ldv_9_ldv_param_150_1_default ;
  unsigned int *ldv_9_ldv_param_153_1_default ;
  unsigned short ldv_9_ldv_param_153_2_default ;
  unsigned short ldv_9_ldv_param_153_3_default ;
  unsigned int ldv_9_ldv_param_156_1_default ;
  unsigned char ldv_9_ldv_param_156_2_default ;
  unsigned short ldv_9_ldv_param_159_1_default ;
  unsigned short ldv_9_ldv_param_159_2_default ;
  unsigned short *ldv_9_ldv_param_159_3_default ;
  unsigned char ldv_9_ldv_param_162_1_default ;
  unsigned char ldv_9_ldv_param_162_2_default ;
  unsigned char ldv_9_ldv_param_162_3_default ;
  unsigned char ldv_9_ldv_param_165_1_default ;
  unsigned char ldv_9_ldv_param_165_2_default ;
  unsigned int *ldv_9_ldv_param_168_1_default ;
  unsigned short ldv_9_ldv_param_168_2_default ;
  unsigned short ldv_9_ldv_param_168_3_default ;
  unsigned short ldv_9_ldv_param_16_1_default ;
  unsigned int ldv_9_ldv_param_171_1_default ;
  unsigned int ldv_9_ldv_param_171_2_default ;
  unsigned short ldv_9_ldv_param_171_3_default ;
  unsigned int ldv_9_ldv_param_174_1_default ;
  unsigned int ldv_9_ldv_param_174_2_default ;
  unsigned short ldv_9_ldv_param_174_3_default ;
  unsigned short ldv_9_ldv_param_19_1_default ;
  unsigned short ldv_9_ldv_param_22_1_default ;
  unsigned int *ldv_9_ldv_param_25_1_default ;
  _Bool *ldv_9_ldv_param_25_2_default ;
  _Bool ldv_9_ldv_param_25_3_default ;
  unsigned int ldv_9_ldv_param_30_1_default ;
  unsigned int ldv_9_ldv_param_34_1_default ;
  unsigned int ldv_9_ldv_param_34_2_default ;
  unsigned short ldv_9_ldv_param_3_1_default ;
  unsigned int ldv_9_ldv_param_41_1_default ;
  unsigned short *ldv_9_ldv_param_46_1_default ;
  unsigned short *ldv_9_ldv_param_49_1_default ;
  unsigned int *ldv_9_ldv_param_53_1_default ;
  _Bool *ldv_9_ldv_param_53_2_default ;
  unsigned char *ldv_9_ldv_param_56_1_default ;
  unsigned char *ldv_9_ldv_param_60_1_default ;
  unsigned short *ldv_9_ldv_param_65_1_default ;
  unsigned short *ldv_9_ldv_param_65_2_default ;
  unsigned int ldv_9_ldv_param_76_1_default ;
  unsigned int ldv_9_ldv_param_79_1_default ;
  unsigned int *ldv_9_ldv_param_83_1_default ;
  unsigned short ldv_9_ldv_param_83_2_default ;
  unsigned short ldv_9_ldv_param_83_3_default ;
  unsigned int ldv_9_ldv_param_86_1_default ;
  unsigned char *ldv_9_ldv_param_86_2_default ;
  unsigned short ldv_9_ldv_param_89_1_default ;
  unsigned short ldv_9_ldv_param_89_2_default ;
  unsigned short *ldv_9_ldv_param_89_3_default ;
  unsigned char ldv_9_ldv_param_92_1_default ;
  unsigned char ldv_9_ldv_param_92_2_default ;
  unsigned char *ldv_9_ldv_param_92_3_default ;
  unsigned char ldv_9_ldv_param_95_1_default ;
  unsigned char *ldv_9_ldv_param_95_2_default ;
  unsigned char ldv_9_ldv_param_98_1_default ;
  unsigned char *ldv_9_ldv_param_98_2_default ;
  unsigned int ldv_9_ldv_param_9_1_default ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  int tmp___24 ;

  {
#line 18477
  goto ldv_call_9;
#line 18479
  return;
  ldv_call_9: 
  {
#line 18485
  tmp___24 = ldv_undef_int();
  }
#line 18485
  if (tmp___24 != 0) {
    {
#line 18489
    tmp = ldv_undef_int();
    }
    {
#line 18490
    if (tmp == 1) {
#line 18490
      goto case_1;
    } else {

    }
#line 18504
    if (tmp == 2) {
#line 18504
      goto case_2;
    } else {

    }
#line 18518
    if (tmp == 3) {
#line 18518
      goto case_3;
    } else {

    }
#line 18534
    if (tmp == 4) {
#line 18534
      goto case_4;
    } else {

    }
#line 18548
    if (tmp == 5) {
#line 18548
      goto case_5;
    } else {

    }
#line 18562
    if (tmp == 6) {
#line 18562
      goto case_6;
    } else {

    }
#line 18578
    if (tmp == 7) {
#line 18578
      goto case_7;
    } else {

    }
#line 18592
    if (tmp == 8) {
#line 18592
      goto case_8;
    } else {

    }
#line 18608
    if (tmp == 9) {
#line 18608
      goto case_9;
    } else {

    }
#line 18624
    if (tmp == 10) {
#line 18624
      goto case_10;
    } else {

    }
#line 18632
    if (tmp == 11) {
#line 18632
      goto case_11;
    } else {

    }
#line 18640
    if (tmp == 12) {
#line 18640
      goto case_12;
    } else {

    }
#line 18648
    if (tmp == 13) {
#line 18648
      goto case_13;
    } else {

    }
#line 18656
    if (tmp == 14) {
#line 18656
      goto case_14;
    } else {

    }
#line 18664
    if (tmp == 15) {
#line 18664
      goto case_15;
    } else {

    }
#line 18672
    if (tmp == 16) {
#line 18672
      goto case_16;
    } else {

    }
#line 18686
    if (tmp == 17) {
#line 18686
      goto case_17;
    } else {

    }
#line 18694
    if (tmp == 18) {
#line 18694
      goto case_18;
    } else {

    }
#line 18708
    if (tmp == 19) {
#line 18708
      goto case_19;
    } else {

    }
#line 18722
    if (tmp == 20) {
#line 18722
      goto case_20;
    } else {

    }
#line 18736
    if (tmp == 21) {
#line 18736
      goto case_21;
    } else {

    }
#line 18750
    if (tmp == 22) {
#line 18750
      goto case_22;
    } else {

    }
#line 18764
    if (tmp == 23) {
#line 18764
      goto case_23;
    } else {

    }
#line 18780
    if (tmp == 24) {
#line 18780
      goto case_24;
    } else {

    }
#line 18794
    if (tmp == 25) {
#line 18794
      goto case_25;
    } else {

    }
#line 18802
    if (tmp == 26) {
#line 18802
      goto case_26;
    } else {

    }
#line 18816
    if (tmp == 27) {
#line 18816
      goto case_27;
    } else {

    }
#line 18824
    if (tmp == 28) {
#line 18824
      goto case_28;
    } else {

    }
#line 18832
    if (tmp == 29) {
#line 18832
      goto case_29;
    } else {

    }
#line 18846
    if (tmp == 30) {
#line 18846
      goto case_30;
    } else {

    }
#line 18862
    if (tmp == 31) {
#line 18862
      goto case_31;
    } else {

    }
#line 18878
    if (tmp == 32) {
#line 18878
      goto case_32;
    } else {

    }
#line 18894
    if (tmp == 33) {
#line 18894
      goto case_33;
    } else {

    }
#line 18910
    if (tmp == 34) {
#line 18910
      goto case_34;
    } else {

    }
#line 18926
    if (tmp == 35) {
#line 18926
      goto case_35;
    } else {

    }
#line 18942
    if (tmp == 36) {
#line 18942
      goto case_36;
    } else {

    }
#line 18958
    if (tmp == 37) {
#line 18958
      goto case_37;
    } else {

    }
#line 18974
    if (tmp == 38) {
#line 18974
      goto case_38;
    } else {

    }
#line 18990
    if (tmp == 39) {
#line 18990
      goto case_39;
    } else {

    }
#line 18998
    if (tmp == 40) {
#line 18998
      goto case_40;
    } else {

    }
#line 19012
    if (tmp == 41) {
#line 19012
      goto case_41;
    } else {

    }
#line 19026
    if (tmp == 42) {
#line 19026
      goto case_42;
    } else {

    }
#line 19034
    if (tmp == 43) {
#line 19034
      goto case_43;
    } else {

    }
#line 19042
    if (tmp == 44) {
#line 19042
      goto case_44;
    } else {

    }
#line 19050
    if (tmp == 45) {
#line 19050
      goto case_45;
    } else {

    }
#line 19058
    if (tmp == 46) {
#line 19058
      goto case_46;
    } else {

    }
#line 19066
    if (tmp == 47) {
#line 19066
      goto case_47;
    } else {

    }
#line 19074
    if (tmp == 48) {
#line 19074
      goto case_48;
    } else {

    }
#line 19082
    if (tmp == 49) {
#line 19082
      goto case_49;
    } else {

    }
#line 19090
    if (tmp == 50) {
#line 19090
      goto case_50;
    } else {

    }
#line 19108
    if (tmp == 51) {
#line 19108
      goto case_51;
    } else {

    }
#line 19116
    if (tmp == 52) {
#line 19116
      goto case_52;
    } else {

    }
#line 19124
    if (tmp == 53) {
#line 19124
      goto case_53;
    } else {

    }
#line 19140
    if (tmp == 54) {
#line 19140
      goto case_54;
    } else {

    }
#line 19148
    if (tmp == 55) {
#line 19148
      goto case_55;
    } else {

    }
#line 19164
    if (tmp == 56) {
#line 19164
      goto case_56;
    } else {

    }
#line 19182
    if (tmp == 57) {
#line 19182
      goto case_57;
    } else {

    }
#line 19190
    if (tmp == 58) {
#line 19190
      goto case_58;
    } else {

    }
#line 19206
    if (tmp == 59) {
#line 19206
      goto case_59;
    } else {

    }
#line 19222
    if (tmp == 60) {
#line 19222
      goto case_60;
    } else {

    }
#line 19230
    if (tmp == 61) {
#line 19230
      goto case_61;
    } else {

    }
#line 19238
    if (tmp == 62) {
#line 19238
      goto case_62;
    } else {

    }
#line 19252
    if (tmp == 63) {
#line 19252
      goto case_63;
    } else {

    }
#line 19260
    if (tmp == 64) {
#line 19260
      goto case_64;
    } else {

    }
#line 19268
    if (tmp == 65) {
#line 19268
      goto case_65;
    } else {

    }
#line 19276
    if (tmp == 66) {
#line 19276
      goto case_66;
    } else {

    }
#line 19284
    if (tmp == 67) {
#line 19284
      goto case_67;
    } else {

    }
#line 19298
    if (tmp == 68) {
#line 19298
      goto case_68;
    } else {

    }
#line 19306
    if (tmp == 69) {
#line 19306
      goto case_69;
    } else {

    }
#line 19320
    if (tmp == 70) {
#line 19320
      goto case_70;
    } else {

    }
#line 19328
    if (tmp == 71) {
#line 19328
      goto case_71;
    } else {

    }
#line 19336
    if (tmp == 72) {
#line 19336
      goto case_72;
    } else {

    }
#line 19354
    if (tmp == 73) {
#line 19354
      goto case_73;
    } else {

    }
#line 19368
    if (tmp == 74) {
#line 19368
      goto case_74;
    } else {

    }
#line 19382
    if (tmp == 75) {
#line 19382
      goto case_75;
    } else {

    }
#line 19396
    if (tmp == 76) {
#line 19396
      goto case_76;
    } else {

    }
#line 19404
    if (tmp == 77) {
#line 19404
      goto case_77;
    } else {

    }
#line 19418
    if (tmp == 78) {
#line 19418
      goto case_78;
    } else {

    }
#line 19432
    if (tmp == 79) {
#line 19432
      goto case_79;
    } else {

    }
#line 19440
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 18496
    ldv_dummy_resourceless_instance_callback_9_174(ldv_9_callback_write_reg_mdi, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_174_1_default,
                                                   ldv_9_ldv_param_174_2_default,
                                                   (int )ldv_9_ldv_param_174_3_default);
    }
#line 18502
    goto ldv_63393;
    case_2: /* CIL Label */ 
    {
#line 18510
    ldv_dummy_resourceless_instance_callback_9_171(ldv_9_callback_write_reg, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_171_1_default,
                                                   ldv_9_ldv_param_171_2_default,
                                                   (int )ldv_9_ldv_param_171_3_default);
    }
#line 18516
    goto ldv_63393;
    case_3: /* CIL Label */ 
    {
#line 18520
    tmp___0 = ldv_xmalloc(4UL);
#line 18520
    ldv_9_ldv_param_168_1_default = (unsigned int *)tmp___0;
#line 18525
    ldv_dummy_resourceless_instance_callback_9_168(ldv_9_callback_write_posted, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_168_1_default,
                                                   (int )ldv_9_ldv_param_168_2_default,
                                                   (int )ldv_9_ldv_param_168_3_default);
#line 18529
    ldv_free((void *)ldv_9_ldv_param_168_1_default);
    }
#line 18532
    goto ldv_63393;
    case_4: /* CIL Label */ 
    {
#line 18540
    ldv_dummy_resourceless_instance_callback_9_165(ldv_9_callback_write_i2c_eeprom,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_9_ldv_param_165_1_default,
                                                   (int )ldv_9_ldv_param_165_2_default);
    }
#line 18546
    goto ldv_63393;
    case_5: /* CIL Label */ 
    {
#line 18554
    ldv_dummy_resourceless_instance_callback_9_162(ldv_9_callback_write_i2c_byte,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_9_ldv_param_162_1_default,
                                                   (int )ldv_9_ldv_param_162_2_default,
                                                   (int )ldv_9_ldv_param_162_3_default);
    }
#line 18560
    goto ldv_63393;
    case_6: /* CIL Label */ 
    {
#line 18564
    tmp___1 = ldv_xmalloc(2UL);
#line 18564
    ldv_9_ldv_param_159_3_default = (unsigned short *)tmp___1;
#line 18569
    ldv_dummy_resourceless_instance_callback_9_159(ldv_9_callback_write_buffer, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_9_ldv_param_159_1_default,
                                                   (int )ldv_9_ldv_param_159_2_default,
                                                   ldv_9_ldv_param_159_3_default);
#line 18573
    ldv_free((void *)ldv_9_ldv_param_159_3_default);
    }
#line 18576
    goto ldv_63393;
    case_7: /* CIL Label */ 
    {
#line 18584
    ldv_dummy_resourceless_instance_callback_9_156(ldv_9_callback_write_analog_reg8,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_156_1_default,
                                                   (int )ldv_9_ldv_param_156_2_default);
    }
#line 18590
    goto ldv_63393;
    case_8: /* CIL Label */ 
    {
#line 18594
    tmp___2 = ldv_xmalloc(4UL);
#line 18594
    ldv_9_ldv_param_153_1_default = (unsigned int *)tmp___2;
#line 18599
    ldv_dummy_resourceless_instance_callback_9_153(ldv_9_callback_write, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_153_1_default,
                                                   (int )ldv_9_ldv_param_153_2_default,
                                                   (int )ldv_9_ldv_param_153_3_default);
#line 18603
    ldv_free((void *)ldv_9_ldv_param_153_1_default);
    }
#line 18606
    goto ldv_63393;
    case_9: /* CIL Label */ 
    {
#line 18610
    tmp___3 = ldv_xmalloc(2UL);
#line 18610
    ldv_9_ldv_param_150_1_default = (unsigned short *)tmp___3;
#line 18615
    ldv_dummy_resourceless_instance_callback_9_150(ldv_9_callback_validate_checksum,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_150_1_default);
#line 18619
    ldv_free((void *)ldv_9_ldv_param_150_1_default);
    }
#line 18622
    goto ldv_63393;
    case_10: /* CIL Label */ 
    {
#line 18627
    ldv_dummy_resourceless_instance_callback_9_149(ldv_9_callback_update_mc_addr_list,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_container_struct_net_device_ptr);
    }
#line 18630
    goto ldv_63393;
    case_11: /* CIL Label */ 
    {
#line 18635
    ldv_dummy_resourceless_instance_callback_9_148(ldv_9_callback_update_checksum,
                                                   ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18638
    goto ldv_63393;
    case_12: /* CIL Label */ 
    {
#line 18643
    ldv_dummy_resourceless_instance_callback_9_147(ldv_9_callback_stop_link_on_d3,
                                                   ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18646
    goto ldv_63393;
    case_13: /* CIL Label */ 
    {
#line 18651
    ldv_dummy_resourceless_instance_callback_9_146(ldv_9_callback_stop_adapter, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18654
    goto ldv_63393;
    case_14: /* CIL Label */ 
    {
#line 18659
    ldv_dummy_resourceless_instance_callback_9_145(ldv_9_callback_start_hw, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18662
    goto ldv_63393;
    case_15: /* CIL Label */ 
    {
#line 18667
    ldv_dummy_resourceless_instance_callback_9_144(ldv_9_callback_setup_sfp, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18670
    goto ldv_63393;
    case_16: /* CIL Label */ 
    {
#line 18678
    ldv_dummy_resourceless_instance_callback_9_141(ldv_9_callback_setup_link_speed,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_141_1_default,
                                                   (int )ldv_9_ldv_param_141_2_default);
    }
#line 18684
    goto ldv_63393;
    case_17: /* CIL Label */ 
    {
#line 18689
    ldv_dummy_resourceless_instance_callback_9_140(ldv_9_callback_setup_link, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18692
    goto ldv_63393;
    case_18: /* CIL Label */ 
    {
#line 18700
    ldv_dummy_resourceless_instance_callback_9_137(ldv_9_callback_set_vmdq_san_mac,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_137_1_default);
    }
#line 18706
    goto ldv_63393;
    case_19: /* CIL Label */ 
    {
#line 18714
    ldv_dummy_resourceless_instance_callback_9_134(ldv_9_callback_set_vmdq, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_134_1_default,
                                                   ldv_9_ldv_param_134_2_default);
    }
#line 18720
    goto ldv_63393;
    case_20: /* CIL Label */ 
    {
#line 18728
    ldv_dummy_resourceless_instance_callback_9_131(ldv_9_callback_set_vlan_anti_spoofing,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_9_ldv_param_131_1_default,
                                                   ldv_9_ldv_param_131_2_default);
    }
#line 18734
    goto ldv_63393;
    case_21: /* CIL Label */ 
    {
#line 18742
    ldv_dummy_resourceless_instance_callback_9_128(ldv_9_callback_set_vfta, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_128_1_default,
                                                   ldv_9_ldv_param_128_2_default,
                                                   (int )ldv_9_ldv_param_128_3_default);
    }
#line 18748
    goto ldv_63393;
    case_22: /* CIL Label */ 
    {
#line 18756
    ldv_dummy_resourceless_instance_callback_9_125(ldv_9_callback_set_rxpba, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_125_1_default,
                                                   ldv_9_ldv_param_125_2_default,
                                                   ldv_9_ldv_param_125_3_default);
    }
#line 18762
    goto ldv_63393;
    case_23: /* CIL Label */ 
    {
#line 18766
    tmp___4 = ldv_xmalloc(1UL);
#line 18766
    ldv_9_ldv_param_122_2_default = (unsigned char *)tmp___4;
#line 18771
    ldv_dummy_resourceless_instance_callback_9_122(ldv_9_callback_set_rar, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_122_1_default,
                                                   ldv_9_ldv_param_122_2_default,
                                                   ldv_9_ldv_param_122_3_default,
                                                   ldv_9_ldv_param_122_4_default);
#line 18775
    ldv_free((void *)ldv_9_ldv_param_122_2_default);
    }
#line 18778
    goto ldv_63393;
    case_24: /* CIL Label */ 
    {
#line 18786
    ldv_dummy_resourceless_instance_callback_9_119(ldv_9_callback_set_mac_anti_spoofing,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_9_ldv_param_119_1_default,
                                                   ldv_9_ldv_param_119_2_default);
    }
#line 18792
    goto ldv_63393;
    case_25: /* CIL Label */ 
    {
#line 18797
    ldv_dummy_resourceless_instance_callback_9_118(ldv_9_callback_set_lan_id, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18800
    goto ldv_63393;
    case_26: /* CIL Label */ 
    {
#line 18808
    ldv_dummy_resourceless_instance_callback_9_115(ldv_9_callback_set_fw_drv_ver,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_9_ldv_param_115_1_default,
                                                   (int )ldv_9_ldv_param_115_2_default,
                                                   (int )ldv_9_ldv_param_115_3_default,
                                                   (int )ldv_9_ldv_param_115_4_default);
    }
#line 18814
    goto ldv_63393;
    case_27: /* CIL Label */ 
    {
#line 18819
    ldv_dummy_resourceless_instance_callback_9_114(ldv_9_callback_reset_hw, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18822
    goto ldv_63393;
    case_28: /* CIL Label */ 
    {
#line 18827
    ldv_dummy_resourceless_instance_callback_9_113(ldv_9_callback_reset, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18830
    goto ldv_63393;
    case_29: /* CIL Label */ 
    {
#line 18838
    ldv_dummy_resourceless_instance_callback_9_110(ldv_9_callback_release_swfw_sync,
                                                   ldv_9_container_struct_ixgbe_hw_ptr,
                                                   (int )ldv_9_ldv_param_110_1_default);
    }
#line 18844
    goto ldv_63393;
    case_30: /* CIL Label */ 
    {
#line 18848
    tmp___5 = ldv_xmalloc(2UL);
#line 18848
    ldv_9_ldv_param_107_3_default = (unsigned short *)tmp___5;
#line 18853
    ldv_dummy_resourceless_instance_callback_9_107(ldv_9_callback_read_reg_mdi, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_107_1_default,
                                                   ldv_9_ldv_param_107_2_default,
                                                   ldv_9_ldv_param_107_3_default);
#line 18857
    ldv_free((void *)ldv_9_ldv_param_107_3_default);
    }
#line 18860
    goto ldv_63393;
    case_31: /* CIL Label */ 
    {
#line 18864
    tmp___6 = ldv_xmalloc(2UL);
#line 18864
    ldv_9_ldv_param_104_3_default = (unsigned short *)tmp___6;
#line 18869
    ldv_dummy_resourceless_instance_callback_9_104(ldv_9_callback_read_reg, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_104_1_default,
                                                   ldv_9_ldv_param_104_2_default,
                                                   ldv_9_ldv_param_104_3_default);
#line 18873
    ldv_free((void *)ldv_9_ldv_param_104_3_default);
    }
#line 18876
    goto ldv_63393;
    case_32: /* CIL Label */ 
    {
#line 18880
    tmp___7 = ldv_xmalloc(4UL);
#line 18880
    ldv_9_ldv_param_101_1_default = (unsigned int *)tmp___7;
#line 18885
    ldv_dummy_resourceless_instance_callback_9_101(ldv_9_callback_read_posted, ldv_9_container_struct_ixgbe_hw_ptr,
                                                   ldv_9_ldv_param_101_1_default,
                                                   (int )ldv_9_ldv_param_101_2_default,
                                                   (int )ldv_9_ldv_param_101_3_default);
#line 18889
    ldv_free((void *)ldv_9_ldv_param_101_1_default);
    }
#line 18892
    goto ldv_63393;
    case_33: /* CIL Label */ 
    {
#line 18896
    tmp___8 = ldv_xmalloc(1UL);
#line 18896
    ldv_9_ldv_param_98_2_default = (unsigned char *)tmp___8;
#line 18901
    ldv_dummy_resourceless_instance_callback_9_98(ldv_9_callback_read_i2c_sff8472,
                                                  ldv_9_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_9_ldv_param_98_1_default,
                                                  ldv_9_ldv_param_98_2_default);
#line 18905
    ldv_free((void *)ldv_9_ldv_param_98_2_default);
    }
#line 18908
    goto ldv_63393;
    case_34: /* CIL Label */ 
    {
#line 18912
    tmp___9 = ldv_xmalloc(1UL);
#line 18912
    ldv_9_ldv_param_95_2_default = (unsigned char *)tmp___9;
#line 18917
    ldv_dummy_resourceless_instance_callback_9_95(ldv_9_callback_read_i2c_eeprom,
                                                  ldv_9_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_9_ldv_param_95_1_default,
                                                  ldv_9_ldv_param_95_2_default);
#line 18921
    ldv_free((void *)ldv_9_ldv_param_95_2_default);
    }
#line 18924
    goto ldv_63393;
    case_35: /* CIL Label */ 
    {
#line 18928
    tmp___10 = ldv_xmalloc(1UL);
#line 18928
    ldv_9_ldv_param_92_3_default = (unsigned char *)tmp___10;
#line 18933
    ldv_dummy_resourceless_instance_callback_9_92(ldv_9_callback_read_i2c_byte, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_9_ldv_param_92_1_default,
                                                  (int )ldv_9_ldv_param_92_2_default,
                                                  ldv_9_ldv_param_92_3_default);
#line 18937
    ldv_free((void *)ldv_9_ldv_param_92_3_default);
    }
#line 18940
    goto ldv_63393;
    case_36: /* CIL Label */ 
    {
#line 18944
    tmp___11 = ldv_xmalloc(2UL);
#line 18944
    ldv_9_ldv_param_89_3_default = (unsigned short *)tmp___11;
#line 18949
    ldv_dummy_resourceless_instance_callback_9_89(ldv_9_callback_read_buffer, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_9_ldv_param_89_1_default,
                                                  (int )ldv_9_ldv_param_89_2_default,
                                                  ldv_9_ldv_param_89_3_default);
#line 18953
    ldv_free((void *)ldv_9_ldv_param_89_3_default);
    }
#line 18956
    goto ldv_63393;
    case_37: /* CIL Label */ 
    {
#line 18960
    tmp___12 = ldv_xmalloc(1UL);
#line 18960
    ldv_9_ldv_param_86_2_default = (unsigned char *)tmp___12;
#line 18965
    ldv_dummy_resourceless_instance_callback_9_86(ldv_9_callback_read_analog_reg8,
                                                  ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_86_1_default, ldv_9_ldv_param_86_2_default);
#line 18969
    ldv_free((void *)ldv_9_ldv_param_86_2_default);
    }
#line 18972
    goto ldv_63393;
    case_38: /* CIL Label */ 
    {
#line 18976
    tmp___13 = ldv_xmalloc(4UL);
#line 18976
    ldv_9_ldv_param_83_1_default = (unsigned int *)tmp___13;
#line 18981
    ldv_dummy_resourceless_instance_callback_9_83(ldv_9_callback_read, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_83_1_default, (int )ldv_9_ldv_param_83_2_default,
                                                  (int )ldv_9_ldv_param_83_3_default);
#line 18985
    ldv_free((void *)ldv_9_ldv_param_83_1_default);
    }
#line 18988
    goto ldv_63393;
    case_39: /* CIL Label */ 
    {
#line 18993
    ldv_dummy_resourceless_instance_callback_9_82(ldv_9_callback_mng_fw_enabled, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 18996
    goto ldv_63393;
    case_40: /* CIL Label */ 
    {
#line 19004
    ldv_dummy_resourceless_instance_callback_9_79(ldv_9_callback_led_on, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_79_1_default);
    }
#line 19010
    goto ldv_63393;
    case_41: /* CIL Label */ 
    {
#line 19018
    ldv_dummy_resourceless_instance_callback_9_76(ldv_9_callback_led_off, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_76_1_default);
    }
#line 19024
    goto ldv_63393;
    case_42: /* CIL Label */ 
    {
#line 19029
    ldv_dummy_resourceless_instance_callback_9_75(ldv_9_callback_init_uta_tables,
                                                  ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19032
    goto ldv_63393;
    case_43: /* CIL Label */ 
    {
#line 19037
    ldv_dummy_resourceless_instance_callback_9_74(ldv_9_callback_init_thermal_sensor_thresh,
                                                  ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19040
    goto ldv_63393;
    case_44: /* CIL Label */ 
    {
#line 19045
    ldv_dummy_resourceless_instance_callback_9_73(ldv_9_callback_init_rx_addrs, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19048
    goto ldv_63393;
    case_45: /* CIL Label */ 
    {
#line 19053
    ldv_dummy_resourceless_instance_callback_9_72(ldv_9_callback_init_params, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19056
    goto ldv_63393;
    case_46: /* CIL Label */ 
    {
#line 19061
    ldv_dummy_resourceless_instance_callback_9_71(ldv_9_callback_init_hw, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19064
    goto ldv_63393;
    case_47: /* CIL Label */ 
    {
#line 19069
    ldv_dummy_resourceless_instance_callback_9_70(ldv_9_callback_init, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19072
    goto ldv_63393;
    case_48: /* CIL Label */ 
    {
#line 19077
    ldv_dummy_resourceless_instance_callback_9_69(ldv_9_callback_identify_sfp, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19080
    goto ldv_63393;
    case_49: /* CIL Label */ 
    {
#line 19085
    ldv_dummy_resourceless_instance_callback_9_68(ldv_9_callback_identify, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19088
    goto ldv_63393;
    case_50: /* CIL Label */ 
    {
#line 19092
    tmp___14 = ldv_xmalloc(2UL);
#line 19092
    ldv_9_ldv_param_65_1_default = (unsigned short *)tmp___14;
#line 19093
    tmp___15 = ldv_xmalloc(2UL);
#line 19093
    ldv_9_ldv_param_65_2_default = (unsigned short *)tmp___15;
#line 19098
    ldv_dummy_resourceless_instance_callback_9_65(ldv_9_callback_get_wwn_prefix, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_65_1_default, ldv_9_ldv_param_65_2_default);
#line 19102
    ldv_free((void *)ldv_9_ldv_param_65_1_default);
#line 19103
    ldv_free((void *)ldv_9_ldv_param_65_2_default);
    }
#line 19106
    goto ldv_63393;
    case_51: /* CIL Label */ 
    {
#line 19111
    ldv_dummy_resourceless_instance_callback_9_64(ldv_9_callback_get_thermal_sensor_data,
                                                  ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19114
    goto ldv_63393;
    case_52: /* CIL Label */ 
    {
#line 19119
    ldv_dummy_resourceless_instance_callback_9_63(ldv_9_callback_get_supported_physical_layer,
                                                  ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19122
    goto ldv_63393;
    case_53: /* CIL Label */ 
    {
#line 19126
    tmp___16 = ldv_xmalloc(1UL);
#line 19126
    ldv_9_ldv_param_60_1_default = (unsigned char *)tmp___16;
#line 19131
    ldv_dummy_resourceless_instance_callback_9_60(ldv_9_callback_get_san_mac_addr,
                                                  ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_60_1_default);
#line 19135
    ldv_free((void *)ldv_9_ldv_param_60_1_default);
    }
#line 19138
    goto ldv_63393;
    case_54: /* CIL Label */ 
    {
#line 19143
    ldv_dummy_resourceless_instance_callback_9_59(ldv_9_callback_get_media_type, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19146
    goto ldv_63393;
    case_55: /* CIL Label */ 
    {
#line 19150
    tmp___17 = ldv_xmalloc(1UL);
#line 19150
    ldv_9_ldv_param_56_1_default = (unsigned char *)tmp___17;
#line 19155
    ldv_dummy_resourceless_instance_callback_9_56(ldv_9_callback_get_mac_addr, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_56_1_default);
#line 19159
    ldv_free((void *)ldv_9_ldv_param_56_1_default);
    }
#line 19162
    goto ldv_63393;
    case_56: /* CIL Label */ 
    {
#line 19166
    tmp___18 = ldv_xmalloc(4UL);
#line 19166
    ldv_9_ldv_param_53_1_default = (unsigned int *)tmp___18;
#line 19167
    tmp___19 = ldv_xmalloc(1UL);
#line 19167
    ldv_9_ldv_param_53_2_default = (_Bool *)tmp___19;
#line 19172
    ldv_dummy_resourceless_instance_callback_9_53(ldv_9_callback_get_link_capabilities,
                                                  ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_53_1_default, ldv_9_ldv_param_53_2_default);
#line 19176
    ldv_free((void *)ldv_9_ldv_param_53_1_default);
#line 19177
    ldv_free((void *)ldv_9_ldv_param_53_2_default);
    }
#line 19180
    goto ldv_63393;
    case_57: /* CIL Label */ 
    {
#line 19185
    ldv_dummy_resourceless_instance_callback_9_52(ldv_9_callback_get_invariants, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19188
    goto ldv_63393;
    case_58: /* CIL Label */ 
    {
#line 19192
    tmp___20 = ldv_xmalloc(2UL);
#line 19192
    ldv_9_ldv_param_49_1_default = (unsigned short *)tmp___20;
#line 19197
    ldv_dummy_resourceless_instance_callback_9_49(ldv_9_callback_get_firmware_version,
                                                  ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_49_1_default);
#line 19201
    ldv_free((void *)ldv_9_ldv_param_49_1_default);
    }
#line 19204
    goto ldv_63393;
    case_59: /* CIL Label */ 
    {
#line 19208
    tmp___21 = ldv_xmalloc(2UL);
#line 19208
    ldv_9_ldv_param_46_1_default = (unsigned short *)tmp___21;
#line 19213
    ldv_dummy_resourceless_instance_callback_9_46(ldv_9_callback_get_device_caps,
                                                  ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_46_1_default);
#line 19217
    ldv_free((void *)ldv_9_ldv_param_46_1_default);
    }
#line 19220
    goto ldv_63393;
    case_60: /* CIL Label */ 
    {
#line 19225
    ldv_dummy_resourceless_instance_callback_9_45(ldv_9_callback_get_bus_info, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19228
    goto ldv_63393;
    case_61: /* CIL Label */ 
    {
#line 19233
    ldv_dummy_resourceless_instance_callback_9_44(ldv_9_callback_fc_enable, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19236
    goto ldv_63393;
    case_62: /* CIL Label */ 
    {
#line 19244
    ldv_dummy_resourceless_instance_callback_9_41(ldv_9_callback_enable_rx_dma, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_41_1_default);
    }
#line 19250
    goto ldv_63393;
    case_63: /* CIL Label */ 
    {
#line 19255
    ldv_dummy_resourceless_instance_callback_9_40(ldv_9_callback_enable_rx_buff, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19258
    goto ldv_63393;
    case_64: /* CIL Label */ 
    {
#line 19263
    ldv_dummy_resourceless_instance_callback_9_39(ldv_9_callback_enable_mc, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19266
    goto ldv_63393;
    case_65: /* CIL Label */ 
    {
#line 19271
    ldv_dummy_resourceless_instance_callback_9_38(ldv_9_callback_disable_rx_buff,
                                                  ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19274
    goto ldv_63393;
    case_66: /* CIL Label */ 
    {
#line 19279
    ldv_dummy_resourceless_instance_callback_9_37(ldv_9_callback_disable_mc, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19282
    goto ldv_63393;
    case_67: /* CIL Label */ 
    {
#line 19290
    ldv_dummy_resourceless_instance_callback_9_34(ldv_9_callback_clear_vmdq, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_34_1_default, ldv_9_ldv_param_34_2_default);
    }
#line 19296
    goto ldv_63393;
    case_68: /* CIL Label */ 
    {
#line 19301
    ldv_dummy_resourceless_instance_callback_9_33(ldv_9_callback_clear_vfta, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19304
    goto ldv_63393;
    case_69: /* CIL Label */ 
    {
#line 19312
    ldv_dummy_resourceless_instance_callback_9_30(ldv_9_callback_clear_rar, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_30_1_default);
    }
#line 19318
    goto ldv_63393;
    case_70: /* CIL Label */ 
    {
#line 19323
    ldv_dummy_resourceless_instance_callback_9_29(ldv_9_callback_clear_hw_cntrs, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19326
    goto ldv_63393;
    case_71: /* CIL Label */ 
    {
#line 19331
    ldv_dummy_resourceless_instance_callback_9_28(ldv_9_callback_check_overtemp, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19334
    goto ldv_63393;
    case_72: /* CIL Label */ 
    {
#line 19338
    tmp___22 = ldv_xmalloc(4UL);
#line 19338
    ldv_9_ldv_param_25_1_default = (unsigned int *)tmp___22;
#line 19339
    tmp___23 = ldv_xmalloc(1UL);
#line 19339
    ldv_9_ldv_param_25_2_default = (_Bool *)tmp___23;
#line 19344
    ldv_dummy_resourceless_instance_callback_9_25(ldv_9_callback_check_link, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_25_1_default, ldv_9_ldv_param_25_2_default,
                                                  (int )ldv_9_ldv_param_25_3_default);
#line 19348
    ldv_free((void *)ldv_9_ldv_param_25_1_default);
#line 19349
    ldv_free((void *)ldv_9_ldv_param_25_2_default);
    }
#line 19352
    goto ldv_63393;
    case_73: /* CIL Label */ 
    {
#line 19360
    ldv_dummy_resourceless_instance_callback_9_22(ldv_9_callback_check_for_rst, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_9_ldv_param_22_1_default);
    }
#line 19366
    goto ldv_63393;
    case_74: /* CIL Label */ 
    {
#line 19374
    ldv_dummy_resourceless_instance_callback_9_19(ldv_9_callback_check_for_msg, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_9_ldv_param_19_1_default);
    }
#line 19380
    goto ldv_63393;
    case_75: /* CIL Label */ 
    {
#line 19388
    ldv_dummy_resourceless_instance_callback_9_16(ldv_9_callback_check_for_ack, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  (int )ldv_9_ldv_param_16_1_default);
    }
#line 19394
    goto ldv_63393;
    case_76: /* CIL Label */ 
    {
#line 19399
    ldv_dummy_resourceless_instance_callback_9_15(ldv_9_callback_calc_checksum, ldv_9_container_struct_ixgbe_hw_ptr);
    }
#line 19402
    goto ldv_63393;
    case_77: /* CIL Label */ 
    {
#line 19410
    ldv_dummy_resourceless_instance_callback_9_12(ldv_9_callback_blink_led_stop, ldv_9_container_struct_ixgbe_hw_ptr,
                                                  ldv_9_ldv_param_12_1_default);
    }
#line 19416
    goto ldv_63393;
    case_78: /* CIL Label */ 
    {
#line 19424
    ldv_dummy_resourceless_instance_callback_9_9(ldv_9_callback_blink_led_start, ldv_9_container_struct_ixgbe_hw_ptr,
                                                 ldv_9_ldv_param_9_1_default);
    }
#line 19430
    goto ldv_63393;
    case_79: /* CIL Label */ 
    {
#line 19435
    ldv_dummy_resourceless_instance_callback_9_3(ldv_9_callback_acquire_swfw_sync,
                                                 ldv_9_container_struct_ixgbe_hw_ptr,
                                                 (int )ldv_9_ldv_param_3_1_default);
    }
#line 19438
    goto ldv_63393;
    switch_default: /* CIL Label */ 
    {
#line 19440
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_63393: ;
#line 19449
    goto ldv_call_9;
  } else {
#line 19457
    return;
  }
#line 19460
  return;
}
}
#line 19465 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_struct_notifier_block_dummy_resourceless_instance_14(void *arg0 ) 
{ 
  int (*ldv_14_callback_notifier_call)(struct notifier_block * , unsigned long  ,
                                       void * ) ;
  struct notifier_block *ldv_14_container_struct_notifier_block ;
  unsigned long ldv_14_ldv_param_3_1_default ;
  void *ldv_14_ldv_param_3_2_default ;
  struct ldv_struct_dummy_resourceless_instance_14 *data ;
  int tmp ;

  {
#line 19473
  data = (struct ldv_struct_dummy_resourceless_instance_14 *)arg0;
#line 19478
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_dummy_resourceless_instance_14 *)0)) {
    {
#line 19479
    ldv_14_container_struct_notifier_block = data->arg0;
#line 19480
    ldv_free((void *)data);
    }
  } else {

  }
#line 19488
  goto ldv_call_14;
#line 19490
  return;
  ldv_call_14: 
  {
#line 19496
  tmp = ldv_undef_int();
  }
#line 19496
  if (tmp != 0) {
    {
#line 19498
    ldv_14_ldv_param_3_2_default = ldv_xmalloc(1UL);
#line 19503
    ldv_dummy_resourceless_instance_callback_14_3(ldv_14_callback_notifier_call, ldv_14_container_struct_notifier_block,
                                                  ldv_14_ldv_param_3_1_default, ldv_14_ldv_param_3_2_default);
#line 19507
    ldv_free(ldv_14_ldv_param_3_2_default);
    }
#line 19514
    goto ldv_call_14;
  } else {
#line 19522
    return;
  }
#line 19525
  return;
}
}
#line 19530 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_timer_instance_callback_15_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) 
{ 


  {
  {
#line 19531
  (*arg0)(arg1);
  }
#line 19532
  return;
}
}
#line 19535 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_timer_timer_instance_15(void *arg0 ) 
{ 
  struct timer_list *ldv_15_container_timer_list ;
  struct ldv_struct_timer_instance_15 *data ;

  {
#line 19540
  data = (struct ldv_struct_timer_instance_15 *)arg0;
#line 19545
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_timer_instance_15 *)0)) {
    {
#line 19546
    ldv_15_container_timer_list = data->arg0;
#line 19547
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 19553
  ldv_switch_to_interrupt_context();
  }
#line 19554
  if ((unsigned long )ldv_15_container_timer_list->function != (unsigned long )((void (*)(unsigned long  ))0)) {
    {
#line 19556
    ldv_timer_instance_callback_15_2(ldv_15_container_timer_list->function, ldv_15_container_timer_list->data);
    }
  } else {

  }
  {
#line 19559
  ldv_switch_to_process_context();
  }
#line 19567
  return;
#line 19569
  return;
}
}
#line 19574 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_unregister_netdev(void *arg0 , struct net_device *arg1 ) 
{ 
  struct net_device *ldv_26_netdev_net_device ;

  {
  {
#line 19580
  ldv_26_netdev_net_device = arg1;
#line 19585
  ldv_unregister_netdev_stop_26_2((ldv_26_netdev_net_device->netdev_ops)->ndo_stop,
                                  ldv_26_netdev_net_device);
#line 19589
  ldv_dispatch_deregister_26_1(ldv_26_netdev_net_device);
  }
#line 19593
  return;
#line 19595
  return;
}
}
#line 19600 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
void ldv_unregister_netdev_stop_26_2(int (*arg0)(struct net_device * ) , struct net_device *arg1 ) 
{ 


  {
  {
#line 19601
  ixgbe_close(arg1);
  }
#line 19602
  return;
}
}
#line 19605 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
  {
#line 19608
  tmp = ldv_err_ptr(error);
  }
#line 19608
  return (tmp);
}
}
#line 19635 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void *ldv_dev_get_drvdata_6(struct device  const  *dev ) 
{ 
  void *tmp ;

  {
  {
#line 19638
  tmp = ldv_dev_get_drvdata(dev);
  }
#line 19638
  return (tmp);
}
}
#line 19641 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static int ldv_dev_set_drvdata_7(struct device *dev , void *data ) 
{ 
  int tmp ;

  {
  {
#line 19644
  tmp = ldv_dev_set_drvdata(dev, data);
  }
#line 19644
  return (tmp);
}
}
#line 19647 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void *ldv_dev_get_drvdata_8(struct device  const  *dev ) 
{ 
  void *tmp ;

  {
  {
#line 19650
  tmp = ldv_dev_get_drvdata(dev);
  }
#line 19650
  return (tmp);
}
}
#line 19653 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
__inline static int ldv_request_irq_9(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                void * ) ,
                                      unsigned long flags , char const   *name , void *dev ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19657
  tmp = request_irq(irq, handler, flags, name, dev);
#line 19657
  ldv_func_res = tmp;
#line 19660
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 19660
  return (tmp___0);
#line 19662
  return (ldv_func_res);
}
}
#line 19665 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
__inline static int ldv_request_irq_10(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19669
  tmp = request_irq(irq, handler, flags, name, dev);
#line 19669
  ldv_func_res = tmp;
#line 19672
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 19672
  return (tmp___0);
#line 19674
  return (ldv_func_res);
}
}
#line 19677 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_free_irq_11(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 19680
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 19683
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 19684
  return;
}
}
#line 19686 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
__inline static int ldv_request_irq_12(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19690
  tmp = request_irq(irq, handler, flags, name, dev);
#line 19690
  ldv_func_res = tmp;
#line 19693
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 19693
  return (tmp___0);
#line 19695
  return (ldv_func_res);
}
}
#line 19698 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
__inline static int ldv_request_irq_13(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19702
  tmp = request_irq(irq, handler, flags, name, dev);
#line 19702
  ldv_func_res = tmp;
#line 19705
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 19705
  return (tmp___0);
#line 19707
  return (ldv_func_res);
}
}
#line 19710 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_free_irq_14(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 19713
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 19716
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 19717
  return;
}
}
#line 19719 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_free_irq_15(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 19722
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 19725
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 19726
  return;
}
}
#line 19728 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_free_irq_16(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 19731
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 19734
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 19735
  return;
}
}
#line 19737 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static int ldv_mod_timer_17(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19741
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 19741
  ldv_func_res = tmp;
#line 19744
  tmp___0 = ldv_mod_timer(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 19744
  return (tmp___0);
#line 19746
  return (ldv_func_res);
}
}
#line 19749 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static int ldv_del_timer_sync_18(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19753
  tmp = del_timer_sync(ldv_func_arg1);
#line 19753
  ldv_func_res = tmp;
#line 19756
  tmp___0 = ldv_del_timer_sync(ldv_func_res, ldv_func_arg1);
  }
#line 19756
  return (tmp___0);
#line 19758
  return (ldv_func_res);
}
}
#line 19761 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_unregister_netdev_19(struct net_device *ldv_func_arg1 ) 
{ 


  {
  {
#line 19764
  unregister_netdev(ldv_func_arg1);
#line 19767
  ldv_unregister_netdev((void *)0, ldv_func_arg1);
  }
#line 19768
  return;
}
}
#line 19770 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static int ldv_mod_timer_20(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19774
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
#line 19774
  ldv_func_res = tmp;
#line 19777
  tmp___0 = ldv_mod_timer(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 19777
  return (tmp___0);
#line 19779
  return (ldv_func_res);
}
}
#line 19782 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_21(int ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                                    unsigned int ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  struct net_device *tmp ;
  struct net_device *tmp___0 ;

  {
  {
#line 19786
  tmp = alloc_etherdev_mqs(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 19786
  ldv_func_res = tmp;
#line 19789
  tmp___0 = ldv_alloc_etherdev_mqs(ldv_func_res, ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  }
#line 19789
  return (tmp___0);
#line 19791
  return (ldv_func_res);
}
}
#line 19794 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static int ldv_register_netdev_22(struct net_device *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19798
  tmp = register_netdev(ldv_func_arg1);
#line 19798
  ldv_func_res = tmp;
#line 19801
  tmp___0 = ldv_register_netdev(ldv_func_res, ldv_func_arg1);
  }
#line 19801
  return (tmp___0);
#line 19803
  return (ldv_func_res);
}
}
#line 19806 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_free_netdev_23(struct net_device *ldv_func_arg1 ) 
{ 


  {
  {
#line 19809
  free_netdev(ldv_func_arg1);
#line 19812
  ldv_free_netdev((void *)0, ldv_func_arg1);
  }
#line 19813
  return;
}
}
#line 19815 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_unregister_netdev_24(struct net_device *ldv_func_arg1 ) 
{ 


  {
  {
#line 19818
  unregister_netdev(ldv_func_arg1);
#line 19821
  ldv_unregister_netdev((void *)0, ldv_func_arg1);
  }
#line 19822
  return;
}
}
#line 19824 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_free_netdev_25(struct net_device *ldv_func_arg1 ) 
{ 


  {
  {
#line 19827
  free_netdev(ldv_func_arg1);
#line 19830
  ldv_free_netdev((void *)0, ldv_func_arg1);
  }
#line 19831
  return;
}
}
#line 19833 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static int ldv___pci_register_driver_26(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                        char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 19837
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 19837
  ldv_func_res = tmp;
#line 19840
  tmp___0 = ldv___pci_register_driver(ldv_func_res, ldv_func_arg1, ldv_func_arg2,
                                      (char *)ldv_func_arg3);
  }
#line 19840
  return (tmp___0);
#line 19842
  return (ldv_func_res);
}
}
#line 19845 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_dca_register_notify_27(struct notifier_block *ldv_func_arg1 ) 
{ 


  {
  {
#line 19848
  dca_register_notify(ldv_func_arg1);
#line 19851
  ldv_dca_register_notify((void *)0, ldv_func_arg1);
  }
#line 19852
  return;
}
}
#line 19854 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_dca_unregister_notify_28(struct notifier_block *ldv_func_arg1 ) 
{ 


  {
  {
#line 19857
  dca_unregister_notify(ldv_func_arg1);
#line 19860
  ldv_dca_unregister_notify((void *)0, ldv_func_arg1);
  }
#line 19861
  return;
}
}
#line 19863 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_main.c.aux"
static void ldv_pci_unregister_driver_29(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
  {
#line 19866
  pci_unregister_driver(ldv_func_arg1);
#line 19869
  ldv_pci_unregister_driver((void *)0, ldv_func_arg1);
  }
#line 19870
  return;
}
}
#line 822 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 838 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
  {
#line 840
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  }
#line 840
  return (tmp);
}
}
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw ) ;
#line 36
s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw ) ;
#line 37
s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw ) ;
#line 38
s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw ) ;
#line 39
s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw ) ;
#line 42
s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw , u8 *mac_addr ) ;
#line 45
s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw ) ;
#line 46
void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw ) ;
#line 47
s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw ) ;
#line 49
s32 ixgbe_led_on_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 50
s32 ixgbe_led_off_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 53
s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw , u16 offset , u16 data ) ;
#line 54
s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw , u16 offset ,
                                               u16 words , u16 *data ) ;
#line 56
s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw , u16 offset , u16 *data ) ;
#line 57
s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                   u16 *data ) ;
#line 59
s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw , u16 offset , u16 data ) ;
#line 60
s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                    u16 *data ) ;
#line 64
s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                              u16 *data ) ;
#line 66
u16 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw ) ;
#line 67
s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw , u16 *checksum_val ) ;
#line 69
s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw ) ;
#line 71
s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw , u32 index , u8 *addr , u32 vmdq ,
                          u32 enable_addr ) ;
#line 73
s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 74
s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw ) ;
#line 75
s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw , struct net_device *netdev ) ;
#line 77
s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw ) ;
#line 78
s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw ) ;
#line 79
s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw ) ;
#line 80
s32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw ) ;
#line 81
s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw , u32 regval ) ;
#line 82
s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw ) ;
#line 84
void ixgbe_fc_autoneg(struct ixgbe_hw *hw ) ;
#line 86
s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw , u16 mask ) ;
#line 87
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw , u16 mask ) ;
#line 88
s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw , u8 *san_mac_addr ) ;
#line 89
s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) ;
#line 90
s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw , u32 vmdq ) ;
#line 91
s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) ;
#line 92
s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw ) ;
#line 93
s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw , u32 vlan , u32 vind , bool vlan_on ) ;
#line 95
s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw ) ;
#line 96
s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw , ixgbe_link_speed *speed , bool *link_up ,
                                 bool link_up_wait_to_complete ) ;
#line 99
s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw , u16 *wwnn_prefix , u16 *wwpn_prefix ) ;
#line 101
s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 102
s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw , u32 index ) ;
#line 103
void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw , bool enable , int pf ) ;
#line 104
void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw , bool enable , int vf ) ;
#line 105
s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw , u16 *device_caps ) ;
#line 106
s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw , u8 maj , u8 min , u8 build ,
                                 u8 sub ) ;
#line 108
void ixgbe_clear_tx_pending(struct ixgbe_hw *hw ) ;
#line 110
void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw , int num_pb , u32 headroom , int strategy ) ;
#line 112
s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw ) ;
#line 124
s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw ) ;
#line 125
s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw ) ;
#line 887 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw ) ;
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw ) ;
#line 38
static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw ) ;
#line 39
static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw ) ;
#line 40
static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw ) ;
#line 41
static void ixgbe_standby_eeprom(struct ixgbe_hw *hw ) ;
#line 42
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw , u16 data , u16 count ) ;
#line 44
static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw , u16 count ) ;
#line 45
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw , u32 *eec ) ;
#line 46
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw , u32 *eec ) ;
#line 47
static void ixgbe_release_eeprom(struct ixgbe_hw *hw ) ;
#line 49
static s32 ixgbe_mta_vector(struct ixgbe_hw *hw , u8 *mc_addr ) ;
#line 50
static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw , u32 ee_reg ) ;
#line 51
static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                             u16 *data ) ;
#line 53
static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                              u16 *data ) ;
#line 55
static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw , u16 offset ) ;
#line 57
static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw ) ;
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw ) 
{ 
  bool supported ;
  ixgbe_link_speed speed ;
  bool link_up ;

  {
#line 70
  supported = 0;
  {
#line 75
  if ((unsigned int )hw->phy.media_type == 2U) {
#line 75
    goto case_2;
  } else {

  }
#line 76
  if ((unsigned int )hw->phy.media_type == 1U) {
#line 76
    goto case_1;
  } else {

  }
#line 85
  if ((unsigned int )hw->phy.media_type == 6U) {
#line 85
    goto case_6;
  } else {

  }
#line 88
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 88
    goto case_5;
  } else {

  }
#line 99
  goto switch_default___0;
  case_2: /* CIL Label */ ;
  case_1: /* CIL Label */ 
  {
#line 77
  (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
  }
#line 79
  if ((int )link_up) {
#line 80
    supported = speed == 32U;
  } else {
#line 83
    supported = 1;
  }
#line 84
  goto ldv_50889;
  case_6: /* CIL Label */ 
#line 86
  supported = 1;
#line 87
  goto ldv_50889;
  case_5: /* CIL Label */ ;
  {
#line 91
  if ((int )hw->device_id == 5404) {
#line 91
    goto case_5404;
  } else {

  }
#line 92
  if ((int )hw->device_id == 5416) {
#line 92
    goto case_5416;
  } else {

  }
#line 93
  if ((int )hw->device_id == 5472) {
#line 93
    goto case_5472;
  } else {

  }
#line 96
  goto switch_default;
  case_5404: /* CIL Label */ ;
  case_5416: /* CIL Label */ ;
  case_5472: /* CIL Label */ 
#line 94
  supported = 1;
#line 95
  goto ldv_50895;
  switch_default: /* CIL Label */ ;
#line 97
  goto ldv_50895;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_50895: ;
  switch_default___0: /* CIL Label */ ;
#line 100
  goto ldv_50889;
  switch_break: /* CIL Label */ ;
  }
  ldv_50889: ;
#line 103
  return (supported);
}
}
#line 112 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_setup_fc(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u32 reg ;
  u32 reg_bp ;
  u16 reg_cu ;
  bool got_lock ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;

  {
#line 114
  ret_val = 0;
#line 115
  reg = 0U;
#line 115
  reg_bp = 0U;
#line 116
  reg_cu = 0U;
#line 117
  got_lock = 0;
#line 123
  if ((int )hw->fc.strict_ieee && (unsigned int )hw->fc.requested_mode == 1U) {
    {
#line 124
    descriptor.modname = "ixgbe";
#line 124
    descriptor.function = "ixgbe_setup_fc";
#line 124
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 124
    descriptor.format = "ixgbe_fc_rx_pause not valid in strict IEEE mode\n";
#line 124
    descriptor.lineno = 124U;
#line 124
    descriptor.flags = 0U;
#line 124
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 124
    if (tmp != 0L) {
      {
#line 124
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
      }
    } else {

    }
#line 125
    ret_val = -13;
#line 126
    goto out;
  } else {

  }
#line 133
  if ((unsigned int )hw->fc.requested_mode == 4U) {
#line 134
    hw->fc.requested_mode = 3;
  } else {

  }
  {
#line 142
  if ((unsigned int )hw->phy.media_type == 2U) {
#line 142
    goto case_2;
  } else {

  }
#line 143
  if ((unsigned int )hw->phy.media_type == 1U) {
#line 143
    goto case_1;
  } else {

  }
#line 144
  if ((unsigned int )hw->phy.media_type == 6U) {
#line 144
    goto case_6;
  } else {

  }
#line 148
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 148
    goto case_5;
  } else {

  }
#line 152
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_1: /* CIL Label */ ;
  case_6: /* CIL Label */ 
  {
#line 145
  reg = ixgbe_read_reg(hw, 16920U);
#line 146
  reg_bp = ixgbe_read_reg(hw, 17056U);
  }
#line 147
  goto ldv_50912;
  case_5: /* CIL Label */ 
  {
#line 149
  (*(hw->phy.ops.read_reg))(hw, 16U, 7U, & reg_cu);
  }
#line 151
  goto ldv_50912;
  switch_default: /* CIL Label */ ;
#line 153
  goto ldv_50912;
  switch_break: /* CIL Label */ ;
  }
  ldv_50912: ;
  {
#line 167
  if ((unsigned int )hw->fc.requested_mode == 0U) {
#line 167
    goto case_0;
  } else {

  }
#line 176
  if ((unsigned int )hw->fc.requested_mode == 2U) {
#line 176
    goto case_2___0;
  } else {

  }
#line 191
  if ((unsigned int )hw->fc.requested_mode == 1U) {
#line 191
    goto case_1___0;
  } else {

  }
#line 201
  if ((unsigned int )hw->fc.requested_mode == 3U) {
#line 201
    goto case_3;
  } else {

  }
#line 210
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 169
  reg = reg & 4294966911U;
#line 170
  if ((unsigned int )hw->phy.media_type == 6U) {
#line 171
    reg_bp = reg_bp & 3489660927U;
  } else
#line 173
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 174
    reg_cu = (unsigned int )reg_cu & 62463U;
  } else {

  }
#line 175
  goto ldv_50916;
  case_2___0: /* CIL Label */ 
#line 181
  reg = reg | 256U;
#line 182
  reg = reg & 4294967167U;
#line 183
  if ((unsigned int )hw->phy.media_type == 6U) {
#line 184
    reg_bp = reg_bp | 536870912U;
#line 185
    reg_bp = reg_bp & 4026531839U;
  } else
#line 186
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 187
    reg_cu = (u16 )((unsigned int )reg_cu | 2048U);
#line 188
    reg_cu = (unsigned int )reg_cu & 64511U;
  } else {

  }
#line 190
  goto ldv_50916;
  case_1___0: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 203
  reg = reg | 384U;
#line 204
  if ((unsigned int )hw->phy.media_type == 6U) {
#line 205
    reg_bp = reg_bp | 805306368U;
  } else
#line 207
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 208
    reg_cu = (u16 )((unsigned int )reg_cu | 3072U);
  } else {

  }
#line 209
  goto ldv_50916;
  switch_default___0: /* CIL Label */ 
  {
#line 211
  descriptor___0.modname = "ixgbe";
#line 211
  descriptor___0.function = "ixgbe_setup_fc";
#line 211
  descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 211
  descriptor___0.format = "Flow control param set incorrectly\n";
#line 211
  descriptor___0.lineno = 211U;
#line 211
  descriptor___0.flags = 0U;
#line 211
  tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
  }
#line 211
  if (tmp___0 != 0L) {
    {
#line 211
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Flow control param set incorrectly\n");
    }
  } else {

  }
#line 212
  ret_val = -4;
#line 213
  goto out;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_50916: ;
#line 217
  if ((unsigned int )hw->mac.type != 3U) {
    {
#line 222
    ixgbe_write_reg(hw, 16920U, reg);
#line 223
    reg = ixgbe_read_reg(hw, 16904U);
    }
#line 226
    if ((int )hw->fc.strict_ieee) {
#line 227
      reg = reg & 4294705151U;
    } else {

    }
    {
#line 229
    ixgbe_write_reg(hw, 16904U, reg);
#line 230
    descriptor___1.modname = "ixgbe";
#line 230
    descriptor___1.function = "ixgbe_setup_fc";
#line 230
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 230
    descriptor___1.format = "Set up FC; PCS1GLCTL = 0x%08X\n";
#line 230
    descriptor___1.lineno = 230U;
#line 230
    descriptor___1.flags = 0U;
#line 230
    tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 230
    if (tmp___1 != 0L) {
      {
#line 230
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Set up FC; PCS1GLCTL = 0x%08X\n", reg);
      }
    } else {

    }
  } else {

  }
#line 238
  if ((unsigned int )hw->phy.media_type == 6U) {
#line 243
    if ((unsigned int )hw->mac.type == 2U) {
      {
#line 243
      tmp___2 = ixgbe_verify_lesm_fw_enabled_82599(hw);
      }
#line 243
      if ((int )tmp___2) {
        {
#line 245
        ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8);
        }
#line 247
        if (ret_val != 0) {
#line 248
          goto out;
        } else {

        }
#line 250
        got_lock = 1;
      } else {

      }
    } else {

    }
    {
#line 253
    ixgbe_write_reg(hw, 17056U, reg_bp);
    }
#line 255
    if ((unsigned int )hw->mac.type == 2U) {
      {
#line 256
      ixgbe_reset_pipeline_82599(hw);
      }
    } else {

    }
#line 258
    if ((int )got_lock) {
      {
#line 259
      (*(hw->mac.ops.release_swfw_sync))(hw, 8);
      }
    } else {

    }
  } else
#line 262
  if ((unsigned int )hw->phy.media_type == 5U) {
    {
#line 262
    tmp___3 = ixgbe_device_supports_autoneg_fc(hw);
    }
#line 262
    if ((int )tmp___3) {
      {
#line 264
      (*(hw->phy.ops.write_reg))(hw, 16U, 7U, (int )reg_cu);
      }
    } else {

    }
  } else {

  }
  {
#line 268
  descriptor___2.modname = "ixgbe";
#line 268
  descriptor___2.function = "ixgbe_setup_fc";
#line 268
  descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 268
  descriptor___2.format = "Set up FC; IXGBE_AUTOC = 0x%08X\n";
#line 268
  descriptor___2.lineno = 268U;
#line 268
  descriptor___2.flags = 0U;
#line 268
  tmp___4 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
  }
#line 268
  if (tmp___4 != 0L) {
    {
#line 268
    __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Set up FC; IXGBE_AUTOC = 0x%08X\n", reg);
    }
  } else {

  }
  out: ;
#line 270
  return (ret_val);
}
}
#line 282 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw ) 
{ 
  u32 ctrl_ext ;

  {
  {
#line 287
  hw->phy.media_type = (*(hw->mac.ops.get_media_type))(hw);
#line 290
  (*(hw->phy.ops.identify))(hw);
#line 293
  (*(hw->mac.ops.clear_vfta))(hw);
#line 296
  (*(hw->mac.ops.clear_hw_cntrs))(hw);
#line 299
  ctrl_ext = ixgbe_read_reg(hw, 24U);
#line 300
  ctrl_ext = ctrl_ext | 65536U;
#line 301
  ixgbe_write_reg(hw, 24U, ctrl_ext);
#line 302
  ixgbe_read_reg(hw, 8U);
#line 305
  ixgbe_setup_fc(hw);
#line 308
  hw->adapter_stopped = 0;
  }
#line 310
  return (0);
}
}
#line 323 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u32 regval ;

  {
#line 329
  i = 0U;
#line 329
  goto ldv_50934;
  ldv_50933: 
  {
#line 330
  ixgbe_write_reg(hw, 18692U, i);
#line 331
  ixgbe_write_reg(hw, 18820U, 0U);
#line 329
  i = i + 1U;
  }
  ldv_50934: ;
#line 329
  if (i < hw->mac.max_tx_queues) {
#line 331
    goto ldv_50933;
  } else {

  }
  {
#line 333
  ixgbe_read_reg(hw, 8U);
#line 336
  i = 0U;
  }
#line 336
  goto ldv_50937;
  ldv_50936: 
  {
#line 337
  regval = ixgbe_read_reg(hw, i * 64U + 24588U);
#line 338
  regval = regval & 4294965247U;
#line 339
  ixgbe_write_reg(hw, i * 64U + 24588U, regval);
#line 336
  i = i + 1U;
  }
  ldv_50937: ;
#line 336
  if (i < hw->mac.max_tx_queues) {
#line 338
    goto ldv_50936;
  } else {

  }
#line 342
  i = 0U;
#line 342
  goto ldv_50940;
  ldv_50939: 
  {
#line 343
  regval = ixgbe_read_reg(hw, i <= 15U ? (i + 2176U) * 4U : (i <= 63U ? i * 64U + 4108U : (i + 67108800U) * 64U + 53260U));
#line 344
  regval = regval & 4294926335U;
#line 346
  ixgbe_write_reg(hw, i <= 15U ? (i + 2176U) * 4U : (i <= 63U ? i * 64U + 4108U : (i + 67108800U) * 64U + 53260U),
                  regval);
#line 342
  i = i + 1U;
  }
  ldv_50940: ;
#line 342
  if (i < hw->mac.max_rx_queues) {
#line 344
    goto ldv_50939;
  } else {

  }

#line 349
  return (0);
}
}
#line 362 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;

  {
  {
#line 367
  status = (*(hw->mac.ops.reset_hw))(hw);
  }
#line 369
  if (status == 0) {
    {
#line 371
    status = (*(hw->mac.ops.start_hw))(hw);
    }
  } else {

  }
#line 374
  return (status);
}
}
#line 384 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw ) 
{ 
  u16 i ;

  {
  {
#line 386
  i = 0U;
#line 388
  ixgbe_read_reg(hw, 16384U);
#line 389
  ixgbe_read_reg(hw, 16388U);
#line 390
  ixgbe_read_reg(hw, 16392U);
#line 391
  ixgbe_read_reg(hw, 16400U);
#line 392
  i = 0U;
  }
#line 392
  goto ldv_50951;
  ldv_50950: 
  {
#line 393
  ixgbe_read_reg(hw, (u32 )(((int )i + 4072) * 4));
#line 392
  i = (u16 )((int )i + 1);
  }
  ldv_50951: ;
#line 392
  if ((unsigned int )i <= 7U) {
#line 394
    goto ldv_50950;
  } else {

  }
  {
#line 395
  ixgbe_read_reg(hw, 16436U);
#line 396
  ixgbe_read_reg(hw, 16440U);
#line 397
  ixgbe_read_reg(hw, 16448U);
#line 398
  ixgbe_read_reg(hw, 16224U);
#line 399
  ixgbe_read_reg(hw, 16232U);
  }
#line 400
  if ((unsigned int )hw->mac.type > 1U) {
    {
#line 401
    ixgbe_read_reg(hw, 16804U);
#line 402
    ixgbe_read_reg(hw, 16808U);
    }
  } else {
    {
#line 404
    ixgbe_read_reg(hw, 53088U);
#line 405
    ixgbe_read_reg(hw, 53096U);
    }
  }
#line 408
  i = 0U;
#line 408
  goto ldv_50954;
  ldv_50953: 
  {
#line 409
  ixgbe_read_reg(hw, (u32 )(((int )i + 4032) * 4));
#line 410
  ixgbe_read_reg(hw, (u32 )(((int )i + 4040) * 4));
  }
#line 411
  if ((unsigned int )hw->mac.type > 1U) {
    {
#line 412
    ixgbe_read_reg(hw, (u32 )(((int )i + 4176) * 4));
#line 413
    ixgbe_read_reg(hw, (u32 )(((int )i + 4184) * 4));
    }
  } else {
    {
#line 415
    ixgbe_read_reg(hw, (u32 )(((int )i + 13248) * 4));
#line 416
    ixgbe_read_reg(hw, (u32 )(((int )i + 13256) * 4));
    }
  }
#line 408
  i = (u16 )((int )i + 1);
  ldv_50954: ;
#line 408
  if ((unsigned int )i <= 7U) {
#line 410
    goto ldv_50953;
  } else {

  }

#line 419
  if ((unsigned int )hw->mac.type > 1U) {
#line 420
    i = 0U;
#line 420
    goto ldv_50957;
    ldv_50956: 
    {
#line 421
    ixgbe_read_reg(hw, (u32 )(((int )i + 3216) * 4));
#line 420
    i = (u16 )((int )i + 1);
    }
    ldv_50957: ;
#line 420
    if ((unsigned int )i <= 7U) {
#line 422
      goto ldv_50956;
    } else {

    }

  } else {

  }
  {
#line 422
  ixgbe_read_reg(hw, 16476U);
#line 423
  ixgbe_read_reg(hw, 16480U);
#line 424
  ixgbe_read_reg(hw, 16484U);
#line 425
  ixgbe_read_reg(hw, 16488U);
#line 426
  ixgbe_read_reg(hw, 16492U);
#line 427
  ixgbe_read_reg(hw, 16496U);
#line 428
  ixgbe_read_reg(hw, 16500U);
#line 429
  ixgbe_read_reg(hw, 16504U);
#line 430
  ixgbe_read_reg(hw, 16508U);
#line 431
  ixgbe_read_reg(hw, 16512U);
#line 432
  ixgbe_read_reg(hw, 16520U);
#line 433
  ixgbe_read_reg(hw, 16524U);
#line 434
  ixgbe_read_reg(hw, 16528U);
#line 435
  ixgbe_read_reg(hw, 16532U);
  }
#line 436
  if ((unsigned int )hw->mac.type == 1U) {
#line 437
    i = 0U;
#line 437
    goto ldv_50960;
    ldv_50959: 
    {
#line 438
    ixgbe_read_reg(hw, (u32 )(((int )i + 4080) * 4));
#line 437
    i = (u16 )((int )i + 1);
    }
    ldv_50960: ;
#line 437
    if ((unsigned int )i <= 7U) {
#line 439
      goto ldv_50959;
    } else {

    }

  } else {

  }
  {
#line 439
  ixgbe_read_reg(hw, 16548U);
#line 440
  ixgbe_read_reg(hw, 16552U);
#line 441
  ixgbe_read_reg(hw, 16556U);
#line 442
  ixgbe_read_reg(hw, 16560U);
#line 443
  ixgbe_read_reg(hw, 16564U);
#line 444
  ixgbe_read_reg(hw, 16568U);
#line 445
  ixgbe_read_reg(hw, 53136U);
#line 446
  ixgbe_read_reg(hw, 16576U);
#line 447
  ixgbe_read_reg(hw, 16580U);
#line 448
  ixgbe_read_reg(hw, 16592U);
#line 449
  ixgbe_read_reg(hw, 16596U);
#line 450
  ixgbe_read_reg(hw, 16600U);
#line 451
  ixgbe_read_reg(hw, 16604U);
#line 452
  ixgbe_read_reg(hw, 16608U);
#line 453
  ixgbe_read_reg(hw, 16612U);
#line 454
  ixgbe_read_reg(hw, 16616U);
#line 455
  ixgbe_read_reg(hw, 16620U);
#line 456
  ixgbe_read_reg(hw, 16624U);
#line 457
  ixgbe_read_reg(hw, 16628U);
#line 458
  i = 0U;
  }
#line 458
  goto ldv_50963;
  ldv_50962: 
  {
#line 459
  ixgbe_read_reg(hw, (u32 )((int )i * 64 + 4144));
#line 460
  ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24624));
  }
#line 461
  if ((unsigned int )hw->mac.type > 1U) {
    {
#line 462
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 4148));
#line 463
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 4152));
#line 464
    ixgbe_read_reg(hw, (u32 )(((int )i + 4320) * 8));
#line 465
    ixgbe_read_reg(hw, (u32 )((int )i * 8 + 34564));
#line 466
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 5168));
    }
  } else {
    {
#line 468
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 4148));
#line 469
    ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24628));
    }
  }
#line 458
  i = (u16 )((int )i + 1);
  ldv_50963: ;
#line 458
  if ((unsigned int )i <= 15U) {
#line 460
    goto ldv_50962;
  } else {

  }

#line 473
  if ((unsigned int )hw->mac.type == 3U) {
#line 474
    if (hw->phy.id == 0U) {
      {
#line 475
      (*(hw->phy.ops.identify))(hw);
      }
    } else {

    }
    {
#line 476
    (*(hw->phy.ops.read_reg))(hw, 59408U, 3U, & i);
#line 477
    (*(hw->phy.ops.read_reg))(hw, 59409U, 3U, & i);
#line 478
    (*(hw->phy.ops.read_reg))(hw, 59424U, 3U, & i);
#line 479
    (*(hw->phy.ops.read_reg))(hw, 59425U, 3U, & i);
    }
  } else {

  }
#line 482
  return (0);
}
}
#line 493 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw , u8 *pba_num , u32 pba_num_size ) 
{ 
  s32 ret_val ;
  u16 data ;
  u16 pba_ptr ;
  u16 offset ;
  u16 length ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;
  struct _ddebug descriptor___7 ;
  long tmp___7 ;

  {
#line 502
  if ((unsigned long )pba_num == (unsigned long )((u8 *)0U)) {
    {
#line 503
    descriptor.modname = "ixgbe";
#line 503
    descriptor.function = "ixgbe_read_pba_string_generic";
#line 503
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 503
    descriptor.format = "PBA string buffer was null\n";
#line 503
    descriptor.lineno = 503U;
#line 503
    descriptor.flags = 0U;
#line 503
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 503
    if (tmp != 0L) {
      {
#line 503
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PBA string buffer was null\n");
      }
    } else {

    }
#line 504
    return (-32);
  } else {

  }
  {
#line 507
  ret_val = (*(hw->eeprom.ops.read))(hw, 21, & data);
  }
#line 508
  if (ret_val != 0) {
    {
#line 509
    descriptor___0.modname = "ixgbe";
#line 509
    descriptor___0.function = "ixgbe_read_pba_string_generic";
#line 509
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 509
    descriptor___0.format = "NVM Read Error\n";
#line 509
    descriptor___0.lineno = 509U;
#line 509
    descriptor___0.flags = 0U;
#line 509
    tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 509
    if (tmp___0 != 0L) {
      {
#line 509
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM Read Error\n");
      }
    } else {

    }
#line 510
    return (ret_val);
  } else {

  }
  {
#line 513
  ret_val = (*(hw->eeprom.ops.read))(hw, 22, & pba_ptr);
  }
#line 514
  if (ret_val != 0) {
    {
#line 515
    descriptor___1.modname = "ixgbe";
#line 515
    descriptor___1.function = "ixgbe_read_pba_string_generic";
#line 515
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 515
    descriptor___1.format = "NVM Read Error\n";
#line 515
    descriptor___1.lineno = 515U;
#line 515
    descriptor___1.flags = 0U;
#line 515
    tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 515
    if (tmp___1 != 0L) {
      {
#line 515
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM Read Error\n");
      }
    } else {

    }
#line 516
    return (ret_val);
  } else {

  }
#line 524
  if ((unsigned int )data != 64250U) {
    {
#line 525
    descriptor___2.modname = "ixgbe";
#line 525
    descriptor___2.function = "ixgbe_read_pba_string_generic";
#line 525
    descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 525
    descriptor___2.format = "NVM PBA number is not stored as string\n";
#line 525
    descriptor___2.lineno = 525U;
#line 525
    descriptor___2.flags = 0U;
#line 525
    tmp___2 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
    }
#line 525
    if (tmp___2 != 0L) {
      {
#line 525
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM PBA number is not stored as string\n");
      }
    } else {

    }
#line 528
    if (pba_num_size <= 10U) {
      {
#line 529
      descriptor___3.modname = "ixgbe";
#line 529
      descriptor___3.function = "ixgbe_read_pba_string_generic";
#line 529
      descriptor___3.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 529
      descriptor___3.format = "PBA string buffer too small\n";
#line 529
      descriptor___3.lineno = 529U;
#line 529
      descriptor___3.flags = 0U;
#line 529
      tmp___3 = __builtin_expect((long )descriptor___3.flags & 1L, 0L);
      }
#line 529
      if (tmp___3 != 0L) {
        {
#line 529
        __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "PBA string buffer too small\n");
        }
      } else {

      }
#line 530
      return (-25);
    } else {

    }
#line 534
    *pba_num = (unsigned int )((u8 )((int )data >> 12)) & 15U;
#line 535
    *(pba_num + 1UL) = (unsigned int )((u8 )((int )data >> 8)) & 15U;
#line 536
    *(pba_num + 2UL) = (unsigned int )((u8 )((int )data >> 4)) & 15U;
#line 537
    *(pba_num + 3UL) = (unsigned int )((u8 )data) & 15U;
#line 538
    *(pba_num + 4UL) = (unsigned int )((u8 )((int )pba_ptr >> 12)) & 15U;
#line 539
    *(pba_num + 5UL) = (unsigned int )((u8 )((int )pba_ptr >> 8)) & 15U;
#line 540
    *(pba_num + 6UL) = 45U;
#line 541
    *(pba_num + 7UL) = 0U;
#line 542
    *(pba_num + 8UL) = (unsigned int )((u8 )((int )pba_ptr >> 4)) & 15U;
#line 543
    *(pba_num + 9UL) = (unsigned int )((u8 )pba_ptr) & 15U;
#line 546
    *(pba_num + 10UL) = 0U;
#line 549
    offset = 0U;
#line 549
    goto ldv_50982;
    ldv_50981: ;
#line 550
    if ((unsigned int )*(pba_num + (unsigned long )offset) <= 9U) {
#line 551
      *(pba_num + (unsigned long )offset) = (unsigned int )*(pba_num + (unsigned long )offset) + 48U;
    } else
#line 552
    if ((unsigned int )*(pba_num + (unsigned long )offset) <= 15U) {
#line 553
      *(pba_num + (unsigned long )offset) = (unsigned int )*(pba_num + (unsigned long )offset) + 55U;
    } else {

    }
#line 549
    offset = (u16 )((int )offset + 1);
    ldv_50982: ;
#line 549
    if ((unsigned int )offset <= 9U) {
#line 551
      goto ldv_50981;
    } else {

    }

#line 556
    return (0);
  } else {

  }
  {
#line 559
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )pba_ptr, & length);
  }
#line 560
  if (ret_val != 0) {
    {
#line 561
    descriptor___4.modname = "ixgbe";
#line 561
    descriptor___4.function = "ixgbe_read_pba_string_generic";
#line 561
    descriptor___4.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 561
    descriptor___4.format = "NVM Read Error\n";
#line 561
    descriptor___4.lineno = 561U;
#line 561
    descriptor___4.flags = 0U;
#line 561
    tmp___4 = __builtin_expect((long )descriptor___4.flags & 1L, 0L);
    }
#line 561
    if (tmp___4 != 0L) {
      {
#line 561
      __dynamic_netdev_dbg(& descriptor___4, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM Read Error\n");
      }
    } else {

    }
#line 562
    return (ret_val);
  } else {

  }
#line 565
  if ((unsigned int )length - 1U > 65533U) {
    {
#line 566
    descriptor___5.modname = "ixgbe";
#line 566
    descriptor___5.function = "ixgbe_read_pba_string_generic";
#line 566
    descriptor___5.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 566
    descriptor___5.format = "NVM PBA number section invalid length\n";
#line 566
    descriptor___5.lineno = 566U;
#line 566
    descriptor___5.flags = 0U;
#line 566
    tmp___5 = __builtin_expect((long )descriptor___5.flags & 1L, 0L);
    }
#line 566
    if (tmp___5 != 0L) {
      {
#line 566
      __dynamic_netdev_dbg(& descriptor___5, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM PBA number section invalid length\n");
      }
    } else {

    }
#line 567
    return (-31);
  } else {

  }
#line 571
  if (pba_num_size < (unsigned int )length * 2U - 1U) {
    {
#line 572
    descriptor___6.modname = "ixgbe";
#line 572
    descriptor___6.function = "ixgbe_read_pba_string_generic";
#line 572
    descriptor___6.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 572
    descriptor___6.format = "PBA string buffer too small\n";
#line 572
    descriptor___6.lineno = 572U;
#line 572
    descriptor___6.flags = 0U;
#line 572
    tmp___6 = __builtin_expect((long )descriptor___6.flags & 1L, 0L);
    }
#line 572
    if (tmp___6 != 0L) {
      {
#line 572
      __dynamic_netdev_dbg(& descriptor___6, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PBA string buffer too small\n");
      }
    } else {

    }
#line 573
    return (-25);
  } else {

  }
#line 577
  pba_ptr = (u16 )((int )pba_ptr + 1);
#line 578
  length = (u16 )((int )length - 1);
#line 580
  offset = 0U;
#line 580
  goto ldv_50989;
  ldv_50988: 
  {
#line 581
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )pba_ptr + (int )offset, & data);
  }
#line 582
  if (ret_val != 0) {
    {
#line 583
    descriptor___7.modname = "ixgbe";
#line 583
    descriptor___7.function = "ixgbe_read_pba_string_generic";
#line 583
    descriptor___7.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 583
    descriptor___7.format = "NVM Read Error\n";
#line 583
    descriptor___7.lineno = 583U;
#line 583
    descriptor___7.flags = 0U;
#line 583
    tmp___7 = __builtin_expect((long )descriptor___7.flags & 1L, 0L);
    }
#line 583
    if (tmp___7 != 0L) {
      {
#line 583
      __dynamic_netdev_dbg(& descriptor___7, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "NVM Read Error\n");
      }
    } else {

    }
#line 584
    return (ret_val);
  } else {

  }
#line 586
  *(pba_num + (unsigned long )((int )offset * 2)) = (unsigned char )((int )data >> 8);
#line 587
  *(pba_num + ((unsigned long )((int )offset * 2) + 1UL)) = (unsigned char )data;
#line 580
  offset = (u16 )((int )offset + 1);
  ldv_50989: ;
#line 580
  if ((int )offset < (int )length) {
#line 582
    goto ldv_50988;
  } else {

  }
#line 589
  *(pba_num + (unsigned long )((int )offset * 2)) = 0U;
#line 591
  return (0);
}
}
#line 603 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw , u8 *mac_addr ) 
{ 
  u32 rar_high ;
  u32 rar_low ;
  u16 i ;

  {
  {
#line 609
  rar_high = ixgbe_read_reg(hw, 21508U);
#line 610
  rar_low = ixgbe_read_reg(hw, 21504U);
#line 612
  i = 0U;
  }
#line 612
  goto ldv_50999;
  ldv_50998: 
#line 613
  *(mac_addr + (unsigned long )i) = (unsigned char )(rar_low >> (int )i * 8);
#line 612
  i = (u16 )((int )i + 1);
  ldv_50999: ;
#line 612
  if ((unsigned int )i <= 3U) {
#line 614
    goto ldv_50998;
  } else {

  }
#line 615
  i = 0U;
#line 615
  goto ldv_51002;
  ldv_51001: 
#line 616
  *(mac_addr + ((unsigned long )i + 4UL)) = (unsigned char )(rar_high >> (int )i * 8);
#line 615
  i = (u16 )((int )i + 1);
  ldv_51002: ;
#line 615
  if ((unsigned int )i <= 1U) {
#line 617
    goto ldv_51001;
  } else {

  }

#line 618
  return (0);
}
}
#line 621 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
enum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status ) 
{ 


  {
  {
#line 624
  if (((int )link_status & 1008) == 16) {
#line 624
    goto case_16;
  } else {

  }
#line 626
  if (((int )link_status & 1008) == 32) {
#line 626
    goto case_32;
  } else {

  }
#line 628
  if (((int )link_status & 1008) == 64) {
#line 628
    goto case_64;
  } else {

  }
#line 630
  if (((int )link_status & 1008) == 128) {
#line 630
    goto case_128;
  } else {

  }
#line 632
  goto switch_default;
  case_16: /* CIL Label */ ;
#line 625
  return (1);
  case_32: /* CIL Label */ ;
#line 627
  return (2);
  case_64: /* CIL Label */ ;
#line 629
  return (4);
  case_128: /* CIL Label */ ;
#line 631
  return (8);
  switch_default: /* CIL Label */ ;
#line 633
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 637 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
enum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status ) 
{ 


  {
  {
#line 640
  if (((int )link_status & 15) == 1) {
#line 640
    goto case_1;
  } else {

  }
#line 642
  if (((int )link_status & 15) == 2) {
#line 642
    goto case_2;
  } else {

  }
#line 644
  if (((int )link_status & 15) == 3) {
#line 644
    goto case_3;
  } else {

  }
#line 646
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 641
  return (2500);
  case_2: /* CIL Label */ ;
#line 643
  return (5000);
  case_3: /* CIL Label */ ;
#line 645
  return (8000);
  switch_default: /* CIL Label */ ;
#line 647
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 657 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_mac_info *mac ;
  u16 link_status ;

  {
  {
#line 659
  adapter = (struct ixgbe_adapter *)hw->back;
#line 660
  mac = & hw->mac;
#line 663
  hw->bus.type = 3;
#line 666
  pci_read_config_word((struct pci_dev  const  *)adapter->pdev, 178, & link_status);
#line 669
  hw->bus.width = ixgbe_convert_bus_width((int )link_status);
#line 670
  hw->bus.speed = ixgbe_convert_bus_speed((int )link_status);
#line 672
  (*(mac->ops.set_lan_id))(hw);
  }
#line 674
  return (0);
}
}
#line 684 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_bus_info *bus ;
  u32 reg ;

  {
  {
#line 686
  bus = & hw->bus;
#line 689
  reg = ixgbe_read_reg(hw, 8U);
#line 690
  bus->func = (u16 )((reg & 12U) >> 2);
#line 691
  bus->lan_id = bus->func;
#line 694
  reg = ixgbe_read_reg(hw, 65872U);
  }
#line 695
  if ((reg & 1073741824U) != 0U) {
#line 696
    bus->func = (u16 )((unsigned int )bus->func ^ 1U);
  } else {

  }
#line 697
  return;
}
}
#line 708 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw ) 
{ 
  u32 reg_val ;
  u16 i ;
  s32 tmp ;

  {
  {
#line 717
  hw->adapter_stopped = 1;
#line 720
  ixgbe_write_reg(hw, 12288U, 0U);
#line 723
  ixgbe_write_reg(hw, 2184U, 4294967295U);
#line 726
  ixgbe_read_reg(hw, 2048U);
#line 729
  i = 0U;
  }
#line 729
  goto ldv_51036;
  ldv_51035: 
  {
#line 730
  ixgbe_write_reg(hw, (u32 )((int )i * 64 + 24616), 67108864U);
#line 729
  i = (u16 )((int )i + 1);
  }
  ldv_51036: ;
#line 729
  if ((u32 )i < hw->mac.max_tx_queues) {
#line 731
    goto ldv_51035;
  } else {

  }
#line 733
  i = 0U;
#line 733
  goto ldv_51039;
  ldv_51038: 
  {
#line 734
  reg_val = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4136 : ((int )i + -64) * 64 + 53288));
#line 735
  reg_val = reg_val & 4261412863U;
#line 736
  reg_val = reg_val | 67108864U;
#line 737
  ixgbe_write_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4136 : ((int )i + -64) * 64 + 53288),
                  reg_val);
#line 733
  i = (u16 )((int )i + 1);
  }
  ldv_51039: ;
#line 733
  if ((u32 )i < hw->mac.max_rx_queues) {
#line 735
    goto ldv_51038;
  } else {

  }
  {
#line 741
  ixgbe_read_reg(hw, 8U);
#line 742
  usleep_range(1000UL, 2000UL);
#line 748
  tmp = ixgbe_disable_pcie_master(hw);
  }
#line 748
  return (tmp);
}
}
#line 756 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_led_on_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 led_reg ;
  u32 tmp ;

  {
  {
#line 758
  tmp = ixgbe_read_reg(hw, 512U);
#line 758
  led_reg = tmp;
#line 761
  led_reg = led_reg & (u32 )(~ (15 << (int )(index * 8U)));
#line 762
  led_reg = led_reg | (u32 )(14 << (int )(index * 8U));
#line 763
  ixgbe_write_reg(hw, 512U, led_reg);
#line 764
  ixgbe_read_reg(hw, 8U);
  }
#line 766
  return (0);
}
}
#line 774 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_led_off_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 led_reg ;
  u32 tmp ;

  {
  {
#line 776
  tmp = ixgbe_read_reg(hw, 512U);
#line 776
  led_reg = tmp;
#line 779
  led_reg = led_reg & (u32 )(~ (15 << (int )(index * 8U)));
#line 780
  led_reg = led_reg | (u32 )(15 << (int )(index * 8U));
#line 781
  ixgbe_write_reg(hw, 512U, led_reg);
#line 782
  ixgbe_read_reg(hw, 8U);
  }
#line 784
  return (0);
}
}
#line 794 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  u32 eec ;
  u16 eeprom_size ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 796
  eeprom = & hw->eeprom;
#line 800
  if ((unsigned int )eeprom->type == 0U) {
    {
#line 801
    eeprom->type = 3;
#line 804
    eeprom->semaphore_delay = 10U;
#line 806
    eeprom->word_page_size = 0U;
#line 812
    eec = ixgbe_read_reg(hw, 65552U);
    }
#line 813
    if ((eec & 256U) != 0U) {
#line 814
      eeprom->type = 1;
#line 820
      eeprom_size = (unsigned short )((eec & 30720U) >> 11);
#line 822
      eeprom->word_size = (u16 )(1 << ((int )eeprom_size + 6));
    } else {

    }
#line 826
    if ((eec & 1024U) != 0U) {
#line 827
      eeprom->address_bits = 16U;
    } else {
#line 829
      eeprom->address_bits = 8U;
    }
    {
#line 830
    descriptor.modname = "ixgbe";
#line 830
    descriptor.function = "ixgbe_init_eeprom_params_generic";
#line 830
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 830
    descriptor.format = "Eeprom params: type = %d, size = %d, address bits: %d\n";
#line 830
    descriptor.lineno = 832U;
#line 830
    descriptor.flags = 0U;
#line 830
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 830
    if (tmp != 0L) {
      {
#line 830
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom params: type = %d, size = %d, address bits: %d\n",
                           (unsigned int )eeprom->type, (int )eeprom->word_size, (int )eeprom->address_bits);
      }
    } else {

    }
  } else {

  }
#line 835
  return (0);
}
}
#line 847 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw , u16 offset ,
                                               u16 words , u16 *data ) 
{ 
  s32 status ;
  u16 i ;
  u16 count ;

  {
  {
#line 850
  status = 0;
#line 853
  (*(hw->eeprom.ops.init_params))(hw);
  }
#line 855
  if ((unsigned int )words == 0U) {
#line 856
    status = -32;
#line 857
    goto out;
  } else {

  }
#line 860
  if ((int )offset + (int )words > (int )hw->eeprom.word_size) {
#line 861
    status = -1;
#line 862
    goto out;
  } else {

  }
#line 869
  if ((unsigned int )hw->eeprom.word_page_size == 0U && (unsigned int )words > 128U) {
    {
#line 871
    ixgbe_detect_eeprom_page_size_generic(hw, (int )offset);
    }
  } else {

  }
#line 878
  i = 0U;
#line 878
  goto ldv_51071;
  ldv_51070: 
  {
#line 879
  count = (u16 )(512 < (int )words - (int )i ? 512 : (int )words - (int )i);
#line 881 "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
  status = ixgbe_write_eeprom_buffer_bit_bang(hw, (int )offset + (int )i, (int )count,
                                              data + (unsigned long )i);
  }
#line 884
  if (status != 0) {
#line 885 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
    goto ldv_51069;
  } else {

  }
#line 878
  i = (unsigned int )i + 512U;
  ldv_51071: ;
#line 878
  if ((int )i < (int )words) {
#line 880
    goto ldv_51070;
  } else {

  }
  ldv_51069: ;
  out: ;
#line 889
  return (status);
}
}
#line 902 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                              u16 *data ) 
{ 
  s32 status ;
  u16 word ;
  u16 page_size ;
  u16 i ;
  u8 write_opcode ;
  s32 tmp ;

  {
  {
#line 909
  write_opcode = 2U;
#line 912
  status = ixgbe_acquire_eeprom(hw);
  }
#line 914
  if (status == 0) {
    {
#line 915
    tmp = ixgbe_ready_eeprom(hw);
    }
#line 915
    if (tmp != 0) {
      {
#line 916
      ixgbe_release_eeprom(hw);
#line 917
      status = -1;
      }
    } else {

    }
  } else {

  }
#line 921
  if (status == 0) {
#line 922
    i = 0U;
#line 922
    goto ldv_51086;
    ldv_51085: 
    {
#line 923
    ixgbe_standby_eeprom(hw);
#line 926
    ixgbe_shift_out_eeprom_bits(hw, 6, 8);
#line 930
    ixgbe_standby_eeprom(hw);
    }
#line 936
    if ((unsigned int )hw->eeprom.address_bits == 8U && (int )offset + (int )i > 127) {
#line 938
      write_opcode = (u8 )((unsigned int )write_opcode | 8U);
    } else {

    }
    {
#line 941
    ixgbe_shift_out_eeprom_bits(hw, (int )write_opcode, 8);
#line 943
    ixgbe_shift_out_eeprom_bits(hw, (int )((unsigned int )((unsigned short )((int )offset + (int )i)) * 2U),
                                (int )hw->eeprom.address_bits);
#line 946
    page_size = hw->eeprom.word_page_size;
    }
    ldv_51084: 
    {
#line 950
    word = *(data + (unsigned long )i);
#line 951
    word = (u16 )((int )((short )((int )word >> 8)) | (int )((short )((int )word << 8)));
#line 952
    ixgbe_shift_out_eeprom_bits(hw, (int )word, 16);
    }
#line 954
    if ((unsigned int )page_size == 0U) {
#line 955
      goto ldv_51083;
    } else {

    }
#line 958
    if ((((int )offset + (int )i) & ((int )page_size + -1)) == (int )page_size + -1) {
#line 960
      goto ldv_51083;
    } else {

    }
#line 961
    i = (u16 )((int )i + 1);
#line 961
    if ((int )i < (int )words) {
#line 963
      goto ldv_51084;
    } else {

    }
    ldv_51083: 
    {
#line 963
    ixgbe_standby_eeprom(hw);
#line 964
    usleep_range(10000UL, 20000UL);
#line 922
    i = (u16 )((int )i + 1);
    }
    ldv_51086: ;
#line 922
    if ((int )i < (int )words) {
#line 924
      goto ldv_51085;
    } else {

    }
    {
#line 967
    ixgbe_release_eeprom(hw);
    }
  } else {

  }
#line 970
  return (status);
}
}
#line 982 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw , u16 offset , u16 data ) 
{ 
  s32 status ;

  {
  {
#line 986
  (*(hw->eeprom.ops.init_params))(hw);
  }
#line 988
  if ((int )offset >= (int )hw->eeprom.word_size) {
#line 989
    status = -1;
#line 990
    goto out;
  } else {

  }
  {
#line 993
  status = ixgbe_write_eeprom_buffer_bit_bang(hw, (int )offset, 1, & data);
  }
  out: ;
#line 996
  return (status);
}
}
#line 1008 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                              u16 *data ) 
{ 
  s32 status ;
  u16 i ;
  u16 count ;

  {
  {
#line 1011
  status = 0;
#line 1014
  (*(hw->eeprom.ops.init_params))(hw);
  }
#line 1016
  if ((unsigned int )words == 0U) {
#line 1017
    status = -32;
#line 1018
    goto out;
  } else {

  }
#line 1021
  if ((int )offset + (int )words > (int )hw->eeprom.word_size) {
#line 1022
    status = -1;
#line 1023
    goto out;
  } else {

  }
#line 1031
  i = 0U;
#line 1031
  goto ldv_51107;
  ldv_51106: 
  {
#line 1032
  count = (u16 )(512 < (int )words - (int )i ? 512 : (int )words - (int )i);
#line 1035 "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
  status = ixgbe_read_eeprom_buffer_bit_bang(hw, (int )offset + (int )i, (int )count,
                                             data + (unsigned long )i);
  }
#line 1038
  if (status != 0) {
#line 1039 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
    goto ldv_51105;
  } else {

  }
#line 1031
  i = (unsigned int )i + 512U;
  ldv_51107: ;
#line 1031
  if ((int )i < (int )words) {
#line 1033
    goto ldv_51106;
  } else {

  }
  ldv_51105: ;
  out: ;
#line 1043
  return (status);
}
}
#line 1055 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                             u16 *data ) 
{ 
  s32 status ;
  u16 word_in ;
  u8 read_opcode ;
  u16 i ;
  s32 tmp ;

  {
  {
#line 1060
  read_opcode = 3U;
#line 1064
  status = ixgbe_acquire_eeprom(hw);
  }
#line 1066
  if (status == 0) {
    {
#line 1067
    tmp = ixgbe_ready_eeprom(hw);
    }
#line 1067
    if (tmp != 0) {
      {
#line 1068
      ixgbe_release_eeprom(hw);
#line 1069
      status = -1;
      }
    } else {

    }
  } else {

  }
#line 1073
  if (status == 0) {
#line 1074
    i = 0U;
#line 1074
    goto ldv_51119;
    ldv_51118: 
    {
#line 1075
    ixgbe_standby_eeprom(hw);
    }
#line 1080
    if ((unsigned int )hw->eeprom.address_bits == 8U && (int )offset + (int )i > 127) {
#line 1082
      read_opcode = (u8 )((unsigned int )read_opcode | 8U);
    } else {

    }
    {
#line 1085
    ixgbe_shift_out_eeprom_bits(hw, (int )read_opcode, 8);
#line 1087
    ixgbe_shift_out_eeprom_bits(hw, (int )((unsigned int )((unsigned short )((int )offset + (int )i)) * 2U),
                                (int )hw->eeprom.address_bits);
#line 1091
    word_in = ixgbe_shift_in_eeprom_bits(hw, 16);
#line 1092
    *(data + (unsigned long )i) = (u16 )((int )((short )((int )word_in >> 8)) | (int )((short )((int )word_in << 8)));
#line 1074
    i = (u16 )((int )i + 1);
    }
    ldv_51119: ;
#line 1074
    if ((int )i < (int )words) {
#line 1076
      goto ldv_51118;
    } else {

    }
    {
#line 1096
    ixgbe_release_eeprom(hw);
    }
  } else {

  }
#line 1099
  return (status);
}
}
#line 1110 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  s32 status ;

  {
  {
#line 1115
  (*(hw->eeprom.ops.init_params))(hw);
  }
#line 1117
  if ((int )offset >= (int )hw->eeprom.word_size) {
#line 1118
    status = -1;
#line 1119
    goto out;
  } else {

  }
  {
#line 1122
  status = ixgbe_read_eeprom_buffer_bit_bang(hw, (int )offset, 1, data);
  }
  out: ;
#line 1125
  return (status);
}
}
#line 1137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                   u16 *data ) 
{ 
  u32 eerd ;
  s32 status ;
  u32 i ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 1141
  status = 0;
#line 1144
  (*(hw->eeprom.ops.init_params))(hw);
  }
#line 1146
  if ((unsigned int )words == 0U) {
#line 1147
    status = -32;
#line 1148
    goto out;
  } else {

  }
#line 1151
  if ((int )offset >= (int )hw->eeprom.word_size) {
#line 1152
    status = -1;
#line 1153
    goto out;
  } else {

  }
#line 1156
  i = 0U;
#line 1156
  goto ldv_51141;
  ldv_51140: 
  {
#line 1157
  eerd = (((u32 )offset + i) << 2) | 1U;
#line 1160
  ixgbe_write_reg(hw, 65556U, eerd);
#line 1161
  status = ixgbe_poll_eerd_eewr_done(hw, 0U);
  }
#line 1163
  if (status == 0) {
    {
#line 1164
    tmp = ixgbe_read_reg(hw, 65556U);
#line 1164
    *(data + (unsigned long )i) = (u16 )(tmp >> 16);
    }
  } else {
    {
#line 1167
    descriptor.modname = "ixgbe";
#line 1167
    descriptor.function = "ixgbe_read_eerd_buffer_generic";
#line 1167
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1167
    descriptor.format = "Eeprom read timed out\n";
#line 1167
    descriptor.lineno = 1167U;
#line 1167
    descriptor.flags = 0U;
#line 1167
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1167
    if (tmp___0 != 0L) {
      {
#line 1167
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom read timed out\n");
      }
    } else {

    }
#line 1168
    goto out;
  }
#line 1156
  i = i + 1U;
  ldv_51141: ;
#line 1156
  if (i < (u32 )words) {
#line 1158
    goto ldv_51140;
  } else {

  }

  out: ;
#line 1172
  return (status);
}
}
#line 1184 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw , u16 offset ) 
{ 
  u16 data[128U] ;
  s32 status ;
  u16 i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1188
  status = 0;
#line 1191
  i = 0U;
#line 1191
  goto ldv_51151;
  ldv_51150: 
#line 1192
  data[(int )i] = i;
#line 1191
  i = (u16 )((int )i + 1);
  ldv_51151: ;
#line 1191
  if ((unsigned int )i <= 127U) {
#line 1193
    goto ldv_51150;
  } else {

  }
  {
#line 1194
  hw->eeprom.word_page_size = 128U;
#line 1195
  status = ixgbe_write_eeprom_buffer_bit_bang(hw, (int )offset, 128, (u16 *)(& data));
#line 1197
  hw->eeprom.word_page_size = 0U;
  }
#line 1198
  if (status != 0) {
#line 1199
    goto out;
  } else {

  }
  {
#line 1201
  status = ixgbe_read_eeprom_buffer_bit_bang(hw, (int )offset, 1, (u16 *)(& data));
  }
#line 1202
  if (status != 0) {
#line 1203
    goto out;
  } else {

  }
  {
#line 1209
  hw->eeprom.word_page_size = 128U - (unsigned int )data[0];
#line 1211
  descriptor.modname = "ixgbe";
#line 1211
  descriptor.function = "ixgbe_detect_eeprom_page_size_generic";
#line 1211
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1211
  descriptor.format = "Detected EEPROM page size = %d words.";
#line 1211
  descriptor.lineno = 1212U;
#line 1211
  descriptor.flags = 0U;
#line 1211
  tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 1211
  if (tmp != 0L) {
    {
#line 1211
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Detected EEPROM page size = %d words.", (int )hw->eeprom.word_page_size);
    }
  } else {

  }
  out: ;
#line 1214
  return (status);
}
}
#line 1225 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  s32 tmp ;

  {
  {
#line 1227
  tmp = ixgbe_read_eerd_buffer_generic(hw, (int )offset, 1, data);
  }
#line 1227
  return (tmp);
}
}
#line 1239 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                    u16 *data ) 
{ 
  u32 eewr ;
  s32 status ;
  u16 i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  {
#line 1243
  status = 0;
#line 1246
  (*(hw->eeprom.ops.init_params))(hw);
  }
#line 1248
  if ((unsigned int )words == 0U) {
#line 1249
    status = -32;
#line 1250
    goto out;
  } else {

  }
#line 1253
  if ((int )offset >= (int )hw->eeprom.word_size) {
#line 1254
    status = -1;
#line 1255
    goto out;
  } else {

  }
#line 1258
  i = 0U;
#line 1258
  goto ldv_51175;
  ldv_51174: 
  {
#line 1259
  eewr = (u32 )(((((int )offset + (int )i) << 2) | ((int )*(data + (unsigned long )i) << 16)) | 1);
#line 1263
  status = ixgbe_poll_eerd_eewr_done(hw, 1U);
  }
#line 1264
  if (status != 0) {
    {
#line 1265
    descriptor.modname = "ixgbe";
#line 1265
    descriptor.function = "ixgbe_write_eewr_buffer_generic";
#line 1265
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1265
    descriptor.format = "Eeprom write EEWR timed out\n";
#line 1265
    descriptor.lineno = 1265U;
#line 1265
    descriptor.flags = 0U;
#line 1265
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1265
    if (tmp != 0L) {
      {
#line 1265
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom write EEWR timed out\n");
      }
    } else {

    }
#line 1266
    goto out;
  } else {

  }
  {
#line 1269
  ixgbe_write_reg(hw, 65560U, eewr);
#line 1271
  status = ixgbe_poll_eerd_eewr_done(hw, 1U);
  }
#line 1272
  if (status != 0) {
    {
#line 1273
    descriptor___0.modname = "ixgbe";
#line 1273
    descriptor___0.function = "ixgbe_write_eewr_buffer_generic";
#line 1273
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1273
    descriptor___0.format = "Eeprom write EEWR timed out\n";
#line 1273
    descriptor___0.lineno = 1273U;
#line 1273
    descriptor___0.flags = 0U;
#line 1273
    tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 1273
    if (tmp___0 != 0L) {
      {
#line 1273
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom write EEWR timed out\n");
      }
    } else {

    }
#line 1274
    goto out;
  } else {

  }
#line 1258
  i = (u16 )((int )i + 1);
  ldv_51175: ;
#line 1258
  if ((int )i < (int )words) {
#line 1260
    goto ldv_51174;
  } else {

  }

  out: ;
#line 1279
  return (status);
}
}
#line 1290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw , u16 offset , u16 data ) 
{ 
  s32 tmp ;

  {
  {
#line 1292
  tmp = ixgbe_write_eewr_buffer_generic(hw, (int )offset, 1, & data);
  }
#line 1292
  return (tmp);
}
}
#line 1303 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw , u32 ee_reg ) 
{ 
  u32 i ;
  u32 reg ;
  s32 status ;

  {
#line 1307
  status = -1;
#line 1309
  i = 0U;
#line 1309
  goto ldv_51191;
  ldv_51190: ;
#line 1310
  if (ee_reg == 0U) {
    {
#line 1311
    reg = ixgbe_read_reg(hw, 65556U);
    }
  } else {
    {
#line 1313
    reg = ixgbe_read_reg(hw, 65560U);
    }
  }
#line 1315
  if ((reg & 2U) != 0U) {
#line 1316
    status = 0;
#line 1317
    goto ldv_51189;
  } else {

  }
  {
#line 1319
  __const_udelay(21475UL);
#line 1309
  i = i + 1U;
  }
  ldv_51191: ;
#line 1309
  if (i <= 99999U) {
#line 1311
    goto ldv_51190;
  } else {

  }
  ldv_51189: ;
#line 1321
  return (status);
}
}
#line 1331 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 eec ;
  u32 i ;
  s32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 1333
  status = 0;
#line 1337
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1);
  }
#line 1337
  if (tmp != 0) {
#line 1338
    status = -16;
  } else {

  }
#line 1340
  if (status == 0) {
    {
#line 1341
    eec = ixgbe_read_reg(hw, 65552U);
#line 1344
    eec = eec | 64U;
#line 1345
    ixgbe_write_reg(hw, 65552U, eec);
#line 1347
    i = 0U;
    }
#line 1347
    goto ldv_51200;
    ldv_51199: 
    {
#line 1348
    eec = ixgbe_read_reg(hw, 65552U);
    }
#line 1349
    if ((eec & 128U) != 0U) {
#line 1350
      goto ldv_51198;
    } else {

    }
    {
#line 1351
    __const_udelay(21475UL);
#line 1347
    i = i + 1U;
    }
    ldv_51200: ;
#line 1347
    if (i <= 999U) {
#line 1349
      goto ldv_51199;
    } else {

    }
    ldv_51198: ;
#line 1355
    if ((eec & 128U) == 0U) {
      {
#line 1356
      eec = eec & 4294967231U;
#line 1357
      ixgbe_write_reg(hw, 65552U, eec);
#line 1358
      descriptor.modname = "ixgbe";
#line 1358
      descriptor.function = "ixgbe_acquire_eeprom";
#line 1358
      descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1358
      descriptor.format = "Could not acquire EEPROM grant\n";
#line 1358
      descriptor.lineno = 1358U;
#line 1358
      descriptor.flags = 0U;
#line 1358
      tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
      }
#line 1358
      if (tmp___0 != 0L) {
        {
#line 1358
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Could not acquire EEPROM grant\n");
        }
      } else {

      }
      {
#line 1360
      (*(hw->mac.ops.release_swfw_sync))(hw, 1);
#line 1361
      status = -1;
      }
    } else {

    }
#line 1365
    if (status == 0) {
      {
#line 1367
      eec = eec & 4294967292U;
#line 1368
      ixgbe_write_reg(hw, 65552U, eec);
#line 1369
      ixgbe_read_reg(hw, 8U);
#line 1370
      __const_udelay(4295UL);
      }
    } else {

    }
  } else {

  }
#line 1373
  return (status);
}
}
#line 1382 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 timeout ;
  u32 i ;
  u32 swsm ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;

  {
#line 1384
  status = -1;
#line 1385
  timeout = 2000U;
#line 1390
  i = 0U;
#line 1390
  goto ldv_51212;
  ldv_51211: 
  {
#line 1395
  swsm = ixgbe_read_reg(hw, 65856U);
  }
#line 1396
  if ((swsm & 1U) == 0U) {
#line 1397
    status = 0;
#line 1398
    goto ldv_51210;
  } else {

  }
  {
#line 1400
  __const_udelay(214750UL);
#line 1390
  i = i + 1U;
  }
  ldv_51212: ;
#line 1390
  if (i < timeout) {
#line 1392
    goto ldv_51211;
  } else {

  }
  ldv_51210: ;
#line 1403
  if (i == timeout) {
    {
#line 1404
    descriptor.modname = "ixgbe";
#line 1404
    descriptor.function = "ixgbe_get_eeprom_semaphore";
#line 1404
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1404
    descriptor.format = "Driver can\'t access the Eeprom - SMBI Semaphore not granted.\n";
#line 1404
    descriptor.lineno = 1405U;
#line 1404
    descriptor.flags = 0U;
#line 1404
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1404
    if (tmp != 0L) {
      {
#line 1404
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Driver can\'t access the Eeprom - SMBI Semaphore not granted.\n");
      }
    } else {

    }
    {
#line 1412
    ixgbe_release_eeprom_semaphore(hw);
#line 1414
    __const_udelay(214750UL);
#line 1420
    swsm = ixgbe_read_reg(hw, 65856U);
    }
#line 1421
    if ((swsm & 1U) == 0U) {
#line 1422
      status = 0;
    } else {

    }
  } else {

  }
#line 1426
  if (status == 0) {
#line 1427
    i = 0U;
#line 1427
    goto ldv_51217;
    ldv_51216: 
    {
#line 1428
    swsm = ixgbe_read_reg(hw, 65856U);
#line 1431
    swsm = swsm | 2U;
#line 1432
    ixgbe_write_reg(hw, 65856U, swsm);
#line 1438
    swsm = ixgbe_read_reg(hw, 65856U);
    }
#line 1439
    if ((swsm & 2U) != 0U) {
#line 1440
      goto ldv_51215;
    } else {

    }
    {
#line 1442
    __const_udelay(214750UL);
#line 1427
    i = i + 1U;
    }
    ldv_51217: ;
#line 1427
    if (i < timeout) {
#line 1429
      goto ldv_51216;
    } else {

    }
    ldv_51215: ;
#line 1449
    if (i >= timeout) {
      {
#line 1450
      descriptor___0.modname = "ixgbe";
#line 1450
      descriptor___0.function = "ixgbe_get_eeprom_semaphore";
#line 1450
      descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1450
      descriptor___0.format = "SWESMBI Software EEPROM semaphore not granted.\n";
#line 1450
      descriptor___0.lineno = 1451U;
#line 1450
      descriptor___0.flags = 0U;
#line 1450
      tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
      }
#line 1450
      if (tmp___0 != 0L) {
        {
#line 1450
        __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "SWESMBI Software EEPROM semaphore not granted.\n");
        }
      } else {

      }
      {
#line 1452
      ixgbe_release_eeprom_semaphore(hw);
#line 1453
      status = -1;
      }
    } else {

    }
  } else {
    {
#line 1456
    descriptor___1.modname = "ixgbe";
#line 1456
    descriptor___1.function = "ixgbe_get_eeprom_semaphore";
#line 1456
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1456
    descriptor___1.format = "Software semaphore SMBI between device drivers not granted.\n";
#line 1456
    descriptor___1.lineno = 1457U;
#line 1456
    descriptor___1.flags = 0U;
#line 1456
    tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 1456
    if (tmp___1 != 0L) {
      {
#line 1456
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Software semaphore SMBI between device drivers not granted.\n");
      }
    } else {

    }
  }
#line 1460
  return (status);
}
}
#line 1469 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw ) 
{ 
  u32 swsm ;

  {
  {
#line 1473
  swsm = ixgbe_read_reg(hw, 65856U);
#line 1476
  swsm = swsm & 4294967292U;
#line 1477
  ixgbe_write_reg(hw, 65856U, swsm);
#line 1478
  ixgbe_read_reg(hw, 8U);
  }
#line 1479
  return;
}
}
#line 1485 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 i ;
  u8 spi_stat_reg ;
  u16 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 1487
  status = 0;
#line 1497
  i = 0U;
#line 1497
  goto ldv_51232;
  ldv_51231: 
  {
#line 1498
  ixgbe_shift_out_eeprom_bits(hw, 5, 8);
#line 1500
  tmp = ixgbe_shift_in_eeprom_bits(hw, 8);
#line 1500
  spi_stat_reg = (unsigned char )tmp;
  }
#line 1501
  if (((int )spi_stat_reg & 1) == 0) {
#line 1502
    goto ldv_51230;
  } else {

  }
  {
#line 1504
  __const_udelay(21475UL);
#line 1505
  ixgbe_standby_eeprom(hw);
#line 1497
  i = (unsigned int )i + 5U;
  }
  ldv_51232: ;
#line 1497
  if ((unsigned int )i <= 4999U) {
#line 1499
    goto ldv_51231;
  } else {

  }
  ldv_51230: ;
#line 1512
  if ((unsigned int )i > 4999U) {
    {
#line 1513
    descriptor.modname = "ixgbe";
#line 1513
    descriptor.function = "ixgbe_ready_eeprom";
#line 1513
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1513
    descriptor.format = "SPI EEPROM Status error\n";
#line 1513
    descriptor.lineno = 1513U;
#line 1513
    descriptor.flags = 0U;
#line 1513
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1513
    if (tmp___0 != 0L) {
      {
#line 1513
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "SPI EEPROM Status error\n");
      }
    } else {

    }
#line 1514
    status = -1;
  } else {

  }
#line 1517
  return (status);
}
}
#line 1524 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_standby_eeprom(struct ixgbe_hw *hw ) 
{ 
  u32 eec ;

  {
  {
#line 1528
  eec = ixgbe_read_reg(hw, 65552U);
#line 1531
  eec = eec | 2U;
#line 1532
  ixgbe_write_reg(hw, 65552U, eec);
#line 1533
  ixgbe_read_reg(hw, 8U);
#line 1534
  __const_udelay(4295UL);
#line 1535
  eec = eec & 4294967293U;
#line 1536
  ixgbe_write_reg(hw, 65552U, eec);
#line 1537
  ixgbe_read_reg(hw, 8U);
#line 1538
  __const_udelay(4295UL);
  }
#line 1540
  return;
}
}
#line 1547 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw , u16 data , u16 count ) 
{ 
  u32 eec ;
  u32 mask ;
  u32 i ;

  {
  {
#line 1554
  eec = ixgbe_read_reg(hw, 65552U);
#line 1560
  mask = (u32 )(1 << ((int )count + -1));
#line 1562
  i = 0U;
  }
#line 1562
  goto ldv_51248;
  ldv_51247: ;
#line 1570
  if (((u32 )data & mask) != 0U) {
#line 1571
    eec = eec | 4U;
  } else {
#line 1573
    eec = eec & 4294967291U;
  }
  {
#line 1575
  ixgbe_write_reg(hw, 65552U, eec);
#line 1576
  ixgbe_read_reg(hw, 8U);
#line 1578
  __const_udelay(4295UL);
#line 1580
  ixgbe_raise_eeprom_clk(hw, & eec);
#line 1581
  ixgbe_lower_eeprom_clk(hw, & eec);
#line 1587
  mask = mask >> 1;
#line 1562
  i = i + 1U;
  }
  ldv_51248: ;
#line 1562
  if (i < (u32 )count) {
#line 1564
    goto ldv_51247;
  } else {

  }
  {
#line 1591
  eec = eec & 4294967291U;
#line 1592
  ixgbe_write_reg(hw, 65552U, eec);
#line 1593
  ixgbe_read_reg(hw, 8U);
  }
#line 1594
  return;
}
}
#line 1600 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw , u16 count ) 
{ 
  u32 eec ;
  u32 i ;
  u16 data ;

  {
  {
#line 1604
  data = 0U;
#line 1613
  eec = ixgbe_read_reg(hw, 65552U);
#line 1615
  eec = eec & 4294967283U;
#line 1617
  i = 0U;
  }
#line 1617
  goto ldv_51258;
  ldv_51257: 
  {
#line 1618
  data = (int )data << 1U;
#line 1619
  ixgbe_raise_eeprom_clk(hw, & eec);
#line 1621
  eec = ixgbe_read_reg(hw, 65552U);
#line 1623
  eec = eec & 4294967291U;
  }
#line 1624
  if ((eec & 8U) != 0U) {
#line 1625
    data = (u16 )((unsigned int )data | 1U);
  } else {

  }
  {
#line 1627
  ixgbe_lower_eeprom_clk(hw, & eec);
#line 1617
  i = i + 1U;
  }
  ldv_51258: ;
#line 1617
  if (i < (u32 )count) {
#line 1619
    goto ldv_51257;
  } else {

  }

#line 1630
  return (data);
}
}
#line 1638 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw , u32 *eec ) 
{ 


  {
  {
#line 1644
  *eec = *eec | 1U;
#line 1645
  ixgbe_write_reg(hw, 65552U, *eec);
#line 1646
  ixgbe_read_reg(hw, 8U);
#line 1647
  __const_udelay(4295UL);
  }
#line 1649
  return;
}
}
#line 1655 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw , u32 *eec ) 
{ 


  {
  {
#line 1661
  *eec = *eec & 4294967294U;
#line 1662
  ixgbe_write_reg(hw, 65552U, *eec);
#line 1663
  ixgbe_read_reg(hw, 8U);
#line 1664
  __const_udelay(4295UL);
  }
#line 1666
  return;
}
}
#line 1671 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_release_eeprom(struct ixgbe_hw *hw ) 
{ 
  u32 eec ;

  {
  {
#line 1675
  eec = ixgbe_read_reg(hw, 65552U);
#line 1677
  eec = eec | 2U;
#line 1678
  eec = eec & 4294967294U;
#line 1680
  ixgbe_write_reg(hw, 65552U, eec);
#line 1681
  ixgbe_read_reg(hw, 8U);
#line 1683
  __const_udelay(4295UL);
#line 1686
  eec = eec & 4294967231U;
#line 1687
  ixgbe_write_reg(hw, 65552U, eec);
#line 1689
  (*(hw->mac.ops.release_swfw_sync))(hw, 1);
#line 1695
  usleep_range((unsigned long )(hw->eeprom.semaphore_delay * 1000U), (unsigned long )(hw->eeprom.semaphore_delay * 2000U));
  }
#line 1697
  return;
}
}
#line 1703 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
u16 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw ) 
{ 
  u16 i ;
  u16 j ;
  u16 checksum ;
  u16 length ;
  u16 pointer ;
  u16 word ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;

  {
#line 1707
  checksum = 0U;
#line 1708
  length = 0U;
#line 1709
  pointer = 0U;
#line 1710
  word = 0U;
#line 1713
  i = 0U;
#line 1713
  goto ldv_51285;
  ldv_51284: 
  {
#line 1714
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )i, & word);
  }
#line 1714
  if (tmp___0 != 0) {
    {
#line 1715
    descriptor.modname = "ixgbe";
#line 1715
    descriptor.function = "ixgbe_calc_eeprom_checksum_generic";
#line 1715
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1715
    descriptor.format = "EEPROM read failed\n";
#line 1715
    descriptor.lineno = 1715U;
#line 1715
    descriptor.flags = 0U;
#line 1715
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1715
    if (tmp != 0L) {
      {
#line 1715
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
#line 1716
    goto ldv_51283;
  } else {

  }
#line 1718
  checksum = (int )checksum + (int )word;
#line 1713
  i = (u16 )((int )i + 1);
  ldv_51285: ;
#line 1713
  if ((unsigned int )i <= 62U) {
#line 1715
    goto ldv_51284;
  } else {

  }
  ldv_51283: 
#line 1722
  i = 3U;
#line 1722
  goto ldv_51290;
  ldv_51289: 
  {
#line 1723
  (*(hw->eeprom.ops.read))(hw, (int )i, & pointer);
  }
#line 1726
  if ((unsigned int )pointer - 1U <= 65533U) {
    {
#line 1727
    (*(hw->eeprom.ops.read))(hw, (int )pointer, & length);
    }
#line 1729
    if ((unsigned int )length - 1U <= 65533U) {
#line 1730
      j = (unsigned int )pointer + 1U;
#line 1730
      goto ldv_51287;
      ldv_51286: 
      {
#line 1731
      (*(hw->eeprom.ops.read))(hw, (int )j, & word);
#line 1732
      checksum = (int )checksum + (int )word;
#line 1730
      j = (u16 )((int )j + 1);
      }
      ldv_51287: ;
#line 1730
      if ((int )j <= (int )pointer + (int )length) {
#line 1732
        goto ldv_51286;
      } else {

      }

    } else {

    }
  } else {

  }
#line 1722
  i = (u16 )((int )i + 1);
  ldv_51290: ;
#line 1722
  if ((unsigned int )i <= 14U) {
#line 1724
    goto ldv_51289;
  } else {

  }
#line 1738
  checksum = 47802U - (unsigned int )checksum;
#line 1740
  return (checksum);
}
}
#line 1751 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw , u16 *checksum_val ) 
{ 
  s32 status ;
  u16 checksum ;
  u16 read_checksum ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  {
#line 1756
  read_checksum = 0U;
#line 1763
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
  }
#line 1765
  if (status == 0) {
    {
#line 1766
    checksum = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 1768
    (*(hw->eeprom.ops.read))(hw, 63, & read_checksum);
    }
#line 1774
    if ((int )read_checksum != (int )checksum) {
#line 1775
      status = -2;
    } else {

    }
#line 1778
    if ((unsigned long )checksum_val != (unsigned long )((u16 *)0U)) {
#line 1779
      *checksum_val = checksum;
    } else {

    }
  } else {
    {
#line 1781
    descriptor.modname = "ixgbe";
#line 1781
    descriptor.function = "ixgbe_validate_eeprom_checksum_generic";
#line 1781
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1781
    descriptor.format = "EEPROM read failed\n";
#line 1781
    descriptor.lineno = 1781U;
#line 1781
    descriptor.flags = 0U;
#line 1781
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1781
    if (tmp != 0L) {
      {
#line 1781
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
  }
#line 1784
  return (status);
}
}
#line 1791 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 checksum ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  {
#line 1801
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
  }
#line 1803
  if (status == 0) {
    {
#line 1804
    checksum = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 1805
    status = (*(hw->eeprom.ops.write))(hw, 63, (int )checksum);
    }
  } else {
    {
#line 1808
    descriptor.modname = "ixgbe";
#line 1808
    descriptor.function = "ixgbe_update_eeprom_checksum_generic";
#line 1808
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1808
    descriptor.format = "EEPROM read failed\n";
#line 1808
    descriptor.lineno = 1808U;
#line 1808
    descriptor.flags = 0U;
#line 1808
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1808
    if (tmp != 0L) {
      {
#line 1808
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
  }
#line 1811
  return (status);
}
}
#line 1824 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw , u32 index , u8 *addr , u32 vmdq ,
                          u32 enable_addr ) 
{ 
  u32 rar_low ;
  u32 rar_high ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1828
  rar_entries = hw->mac.num_rar_entries;
#line 1831
  if (index >= rar_entries) {
    {
#line 1832
    descriptor.modname = "ixgbe";
#line 1832
    descriptor.function = "ixgbe_set_rar_generic";
#line 1832
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1832
    descriptor.format = "RAR index %d is out of range.\n";
#line 1832
    descriptor.lineno = 1832U;
#line 1832
    descriptor.flags = 0U;
#line 1832
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1832
    if (tmp != 0L) {
      {
#line 1832
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", index);
      }
    } else {

    }
#line 1833
    return (-32);
  } else {

  }
  {
#line 1837
  (*(hw->mac.ops.set_vmdq))(hw, index, vmdq);
#line 1843
  rar_low = (((unsigned int )*addr | ((unsigned int )*(addr + 1UL) << 8)) | ((unsigned int )*(addr + 2UL) << 16)) | ((unsigned int )*(addr + 3UL) << 24);
#line 1852
  rar_high = ixgbe_read_reg(hw, index <= 15U ? index * 8U + 21508U : index * 8U + 41476U);
#line 1853
  rar_high = rar_high & 2147418112U;
#line 1854
  rar_high = rar_high | ((unsigned int )*(addr + 4UL) | ((unsigned int )*(addr + 5UL) << 8));
  }
#line 1856
  if (enable_addr != 0U) {
#line 1857
    rar_high = rar_high | 2147483648U;
  } else {

  }
  {
#line 1859
  ixgbe_write_reg(hw, index <= 15U ? (index + 2688U) * 8U : (index + 5184U) * 8U,
                  rar_low);
#line 1860
  ixgbe_write_reg(hw, index <= 15U ? index * 8U + 21508U : index * 8U + 41476U, rar_high);
  }
#line 1862
  return (0);
}
}
#line 1872 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 rar_high ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1875
  rar_entries = hw->mac.num_rar_entries;
#line 1878
  if (index >= rar_entries) {
    {
#line 1879
    descriptor.modname = "ixgbe";
#line 1879
    descriptor.function = "ixgbe_clear_rar_generic";
#line 1879
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1879
    descriptor.format = "RAR index %d is out of range.\n";
#line 1879
    descriptor.lineno = 1879U;
#line 1879
    descriptor.flags = 0U;
#line 1879
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1879
    if (tmp != 0L) {
      {
#line 1879
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", index);
      }
    } else {

    }
#line 1880
    return (-32);
  } else {

  }
  {
#line 1888
  rar_high = ixgbe_read_reg(hw, index <= 15U ? index * 8U + 21508U : index * 8U + 41476U);
#line 1889
  rar_high = rar_high & 2147418112U;
#line 1891
  ixgbe_write_reg(hw, index <= 15U ? (index + 2688U) * 8U : (index + 5184U) * 8U,
                  0U);
#line 1892
  ixgbe_write_reg(hw, index <= 15U ? index * 8U + 21508U : index * 8U + 41476U, rar_high);
#line 1895
  (*(hw->mac.ops.clear_vmdq))(hw, index, 4294967295U);
  }
#line 1897
  return (0);
}
}
#line 1908 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;

  {
  {
#line 1911
  rar_entries = hw->mac.num_rar_entries;
#line 1918
  tmp___2 = is_valid_ether_addr((u8 const   *)(& hw->mac.addr));
  }
#line 1918
  if (tmp___2) {
#line 1918
    tmp___3 = 0;
  } else {
#line 1918
    tmp___3 = 1;
  }
#line 1918
  if (tmp___3) {
    {
#line 1920
    (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.addr));
#line 1922
    descriptor.modname = "ixgbe";
#line 1922
    descriptor.function = "ixgbe_init_rx_addrs_generic";
#line 1922
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1922
    descriptor.format = " Keeping Current RAR0 Addr =%pM\n";
#line 1922
    descriptor.lineno = 1922U;
#line 1922
    descriptor.flags = 0U;
#line 1922
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1922
    if (tmp != 0L) {
      {
#line 1922
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           " Keeping Current RAR0 Addr =%pM\n", (u8 *)(& hw->mac.addr));
      }
    } else {

    }
  } else {
    {
#line 1925
    descriptor___0.modname = "ixgbe";
#line 1925
    descriptor___0.function = "ixgbe_init_rx_addrs_generic";
#line 1925
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1925
    descriptor___0.format = "Overriding MAC Address in RAR[0]\n";
#line 1925
    descriptor___0.lineno = 1925U;
#line 1925
    descriptor___0.flags = 0U;
#line 1925
    tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 1925
    if (tmp___0 != 0L) {
      {
#line 1925
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Overriding MAC Address in RAR[0]\n");
      }
    } else {

    }
    {
#line 1926
    descriptor___1.modname = "ixgbe";
#line 1926
    descriptor___1.function = "ixgbe_init_rx_addrs_generic";
#line 1926
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1926
    descriptor___1.format = " New MAC Addr =%pM\n";
#line 1926
    descriptor___1.lineno = 1926U;
#line 1926
    descriptor___1.flags = 0U;
#line 1926
    tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 1926
    if (tmp___1 != 0L) {
      {
#line 1926
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           " New MAC Addr =%pM\n", (u8 *)(& hw->mac.addr));
      }
    } else {

    }
    {
#line 1928
    (*(hw->mac.ops.set_rar))(hw, 0U, (u8 *)(& hw->mac.addr), 0U, 2147483648U);
#line 1931
    (*(hw->mac.ops.clear_vmdq))(hw, 0U, 4294967295U);
    }
  }
  {
#line 1933
  hw->addr_ctrl.overflow_promisc = 0U;
#line 1935
  hw->addr_ctrl.rar_used_count = 1U;
#line 1938
  descriptor___2.modname = "ixgbe";
#line 1938
  descriptor___2.function = "ixgbe_init_rx_addrs_generic";
#line 1938
  descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1938
  descriptor___2.format = "Clearing RAR[1-%d]\n";
#line 1938
  descriptor___2.lineno = 1938U;
#line 1938
  descriptor___2.flags = 0U;
#line 1938
  tmp___4 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
  }
#line 1938
  if (tmp___4 != 0L) {
    {
#line 1938
    __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Clearing RAR[1-%d]\n", rar_entries - 1U);
    }
  } else {

  }
#line 1939
  i = 1U;
#line 1939
  goto ldv_51339;
  ldv_51338: 
  {
#line 1940
  ixgbe_write_reg(hw, i <= 15U ? (i + 2688U) * 8U : (i + 5184U) * 8U, 0U);
#line 1941
  ixgbe_write_reg(hw, i <= 15U ? i * 8U + 21508U : i * 8U + 41476U, 0U);
#line 1939
  i = i + 1U;
  }
  ldv_51339: ;
#line 1939
  if (i < rar_entries) {
#line 1941
    goto ldv_51338;
  } else {

  }
  {
#line 1945
  hw->addr_ctrl.mta_in_use = 0U;
#line 1946
  ixgbe_write_reg(hw, 20624U, (u32 )hw->mac.mc_filter_type);
#line 1948
  descriptor___3.modname = "ixgbe";
#line 1948
  descriptor___3.function = "ixgbe_init_rx_addrs_generic";
#line 1948
  descriptor___3.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1948
  descriptor___3.format = " Clearing MTA\n";
#line 1948
  descriptor___3.lineno = 1948U;
#line 1948
  descriptor___3.flags = 0U;
#line 1948
  tmp___5 = __builtin_expect((long )descriptor___3.flags & 1L, 0L);
  }
#line 1948
  if (tmp___5 != 0L) {
    {
#line 1948
    __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Clearing MTA\n");
    }
  } else {

  }
#line 1949
  i = 0U;
#line 1949
  goto ldv_51343;
  ldv_51342: 
  {
#line 1950
  ixgbe_write_reg(hw, (i + 5248U) * 4U, 0U);
#line 1949
  i = i + 1U;
  }
  ldv_51343: ;
#line 1949
  if (i < hw->mac.mcft_size) {
#line 1951
    goto ldv_51342;
  } else {

  }

#line 1952
  if ((unsigned long )hw->mac.ops.init_uta_tables != (unsigned long )((s32 (*)(struct ixgbe_hw * ))0)) {
    {
#line 1953
    (*(hw->mac.ops.init_uta_tables))(hw);
    }
  } else {

  }
#line 1955
  return (0);
}
}
#line 1970 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_mta_vector(struct ixgbe_hw *hw , u8 *mc_addr ) 
{ 
  u32 vector ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 1972
  vector = 0U;
  {
#line 1975
  if (hw->mac.mc_filter_type == 0) {
#line 1975
    goto case_0;
  } else {

  }
#line 1978
  if (hw->mac.mc_filter_type == 1) {
#line 1978
    goto case_1;
  } else {

  }
#line 1981
  if (hw->mac.mc_filter_type == 2) {
#line 1981
    goto case_2;
  } else {

  }
#line 1984
  if (hw->mac.mc_filter_type == 3) {
#line 1984
    goto case_3;
  } else {

  }
#line 1987
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1976
  vector = (u32 )(((int )*(mc_addr + 4UL) >> 4) | ((int )*(mc_addr + 5UL) << 4));
#line 1977
  goto ldv_51351;
  case_1: /* CIL Label */ 
#line 1979
  vector = (u32 )(((int )*(mc_addr + 4UL) >> 3) | ((int )*(mc_addr + 5UL) << 5));
#line 1980
  goto ldv_51351;
  case_2: /* CIL Label */ 
#line 1982
  vector = (u32 )(((int )*(mc_addr + 4UL) >> 2) | ((int )*(mc_addr + 5UL) << 6));
#line 1983
  goto ldv_51351;
  case_3: /* CIL Label */ 
#line 1985
  vector = (u32 )((int )*(mc_addr + 4UL) | ((int )*(mc_addr + 5UL) << 8));
#line 1986
  goto ldv_51351;
  switch_default: /* CIL Label */ 
  {
#line 1988
  descriptor.modname = "ixgbe";
#line 1988
  descriptor.function = "ixgbe_mta_vector";
#line 1988
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 1988
  descriptor.format = "MC filter type param set incorrectly\n";
#line 1988
  descriptor.lineno = 1988U;
#line 1988
  descriptor.flags = 0U;
#line 1988
  tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 1988
  if (tmp != 0L) {
    {
#line 1988
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "MC filter type param set incorrectly\n");
    }
  } else {

  }
#line 1989
  goto ldv_51351;
  switch_break: /* CIL Label */ ;
  }
  ldv_51351: 
#line 1993
  vector = vector & 4095U;
#line 1994
  return ((s32 )vector);
}
}
#line 2004 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static void ixgbe_set_mta(struct ixgbe_hw *hw , u8 *mc_addr ) 
{ 
  u32 vector ;
  u32 vector_bit ;
  u32 vector_reg ;
  s32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 2010
  hw->addr_ctrl.mta_in_use = hw->addr_ctrl.mta_in_use + 1U;
#line 2012
  tmp = ixgbe_mta_vector(hw, mc_addr);
#line 2012
  vector = (u32 )tmp;
#line 2013
  descriptor.modname = "ixgbe";
#line 2013
  descriptor.function = "ixgbe_set_mta";
#line 2013
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2013
  descriptor.format = " bit-vector = 0x%03X\n";
#line 2013
  descriptor.lineno = 2013U;
#line 2013
  descriptor.flags = 0U;
#line 2013
  tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 2013
  if (tmp___0 != 0L) {
    {
#line 2013
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " bit-vector = 0x%03X\n", vector);
    }
  } else {

  }
#line 2024
  vector_reg = (vector >> 5) & 127U;
#line 2025
  vector_bit = vector & 31U;
#line 2026
  hw->mac.mta_shadow[vector_reg] = hw->mac.mta_shadow[vector_reg] | (u32 )(1 << (int )vector_bit);
#line 2027
  return;
}
}
#line 2039 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw , struct net_device *netdev ) 
{ 
  struct netdev_hw_addr *ha ;
  u32 i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct list_head  const  *__mptr ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct list_head  const  *__mptr___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;

  {
  {
#line 2049
  hw->addr_ctrl.num_mc_addrs = (u32 )netdev->mc.count;
#line 2050
  hw->addr_ctrl.mta_in_use = 0U;
#line 2053
  descriptor.modname = "ixgbe";
#line 2053
  descriptor.function = "ixgbe_update_mc_addr_list_generic";
#line 2053
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2053
  descriptor.format = " Clearing MTA\n";
#line 2053
  descriptor.lineno = 2053U;
#line 2053
  descriptor.flags = 0U;
#line 2053
  tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 2053
  if (tmp != 0L) {
    {
#line 2053
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Clearing MTA\n");
    }
  } else {

  }
  {
#line 2054
  memset((void *)(& hw->mac.mta_shadow), 0, 512UL);
#line 2057
  __mptr = (struct list_head  const  *)netdev->mc.list.next;
#line 2057
  ha = (struct netdev_hw_addr *)__mptr;
  }
#line 2057
  goto ldv_51381;
  ldv_51380: 
  {
#line 2058
  descriptor___0.modname = "ixgbe";
#line 2058
  descriptor___0.function = "ixgbe_update_mc_addr_list_generic";
#line 2058
  descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2058
  descriptor___0.format = " Adding the multicast addresses:\n";
#line 2058
  descriptor___0.lineno = 2058U;
#line 2058
  descriptor___0.flags = 0U;
#line 2058
  tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
  }
#line 2058
  if (tmp___0 != 0L) {
    {
#line 2058
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Adding the multicast addresses:\n");
    }
  } else {

  }
  {
#line 2059
  ixgbe_set_mta(hw, (u8 *)(& ha->addr));
#line 2057
  __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 2057
  ha = (struct netdev_hw_addr *)__mptr___0;
  }
  ldv_51381: ;
#line 2057
  if ((unsigned long )(& ha->list) != (unsigned long )(& netdev->mc.list)) {
#line 2059
    goto ldv_51380;
  } else {

  }
#line 2063
  i = 0U;
#line 2063
  goto ldv_51384;
  ldv_51383: 
  {
#line 2064
  ixgbe_write_reg(hw, (i << 2) + 20992U, hw->mac.mta_shadow[i]);
#line 2063
  i = i + 1U;
  }
  ldv_51384: ;
#line 2063
  if (i < hw->mac.mcft_size) {
#line 2065
    goto ldv_51383;
  } else {

  }

#line 2067
  if (hw->addr_ctrl.mta_in_use != 0U) {
    {
#line 2068
    ixgbe_write_reg(hw, 20624U, (u32 )(hw->mac.mc_filter_type | 4));
    }
  } else {

  }
  {
#line 2071
  descriptor___1.modname = "ixgbe";
#line 2071
  descriptor___1.function = "ixgbe_update_mc_addr_list_generic";
#line 2071
  descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2071
  descriptor___1.format = "ixgbe_update_mc_addr_list_generic Complete\n";
#line 2071
  descriptor___1.lineno = 2071U;
#line 2071
  descriptor___1.flags = 0U;
#line 2071
  tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
  }
#line 2071
  if (tmp___1 != 0L) {
    {
#line 2071
    __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "ixgbe_update_mc_addr_list_generic Complete\n");
    }
  } else {

  }
#line 2072
  return (0);
}
}
#line 2081 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_addr_filter_info *a ;

  {
#line 2083
  a = & hw->addr_ctrl;
#line 2085
  if (a->mta_in_use != 0U) {
    {
#line 2086
    ixgbe_write_reg(hw, 20624U, (u32 )(hw->mac.mc_filter_type | 4));
    }
  } else {

  }
#line 2089
  return (0);
}
}
#line 2098 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_addr_filter_info *a ;

  {
#line 2100
  a = & hw->addr_ctrl;
#line 2102
  if (a->mta_in_use != 0U) {
    {
#line 2103
    ixgbe_write_reg(hw, 20624U, (u32 )hw->mac.mc_filter_type);
    }
  } else {

  }
#line 2105
  return (0);
}
}
#line 2114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u32 mflcn_reg ;
  u32 fccfg_reg ;
  u32 reg ;
  u32 fcrtl ;
  u32 fcrth ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  u32 tmp___1 ;

  {
#line 2116
  ret_val = 0;
#line 2127
  if ((hw->fc.low_water == 0U || hw->fc.high_water[0] == 0U) || (unsigned int )hw->fc.pause_time == 0U) {
    {
#line 2130
    descriptor.modname = "ixgbe";
#line 2130
    descriptor.function = "ixgbe_fc_enable_generic";
#line 2130
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2130
    descriptor.format = "Invalid water mark configuration\n";
#line 2130
    descriptor.lineno = 2130U;
#line 2130
    descriptor.flags = 0U;
#line 2130
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 2130
    if (tmp != 0L) {
      {
#line 2130
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Invalid water mark configuration\n");
      }
    } else {

    }
#line 2131
    ret_val = -13;
#line 2132
    goto out;
  } else {

  }
  {
#line 2136
  ixgbe_fc_autoneg(hw);
#line 2139
  mflcn_reg = ixgbe_read_reg(hw, 17044U);
#line 2140
  mflcn_reg = mflcn_reg & 4294963203U;
#line 2142
  fccfg_reg = ixgbe_read_reg(hw, 15616U);
#line 2143
  fccfg_reg = fccfg_reg & 4294967271U;
  }
  {
#line 2156
  if ((unsigned int )hw->fc.current_mode == 0U) {
#line 2156
    goto case_0;
  } else {

  }
#line 2162
  if ((unsigned int )hw->fc.current_mode == 1U) {
#line 2162
    goto case_1;
  } else {

  }
#line 2173
  if ((unsigned int )hw->fc.current_mode == 2U) {
#line 2173
    goto case_2;
  } else {

  }
#line 2180
  if ((unsigned int )hw->fc.current_mode == 3U) {
#line 2180
    goto case_3;
  } else {

  }
#line 2185
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 2161
  goto ldv_51409;
  case_1: /* CIL Label */ 
#line 2171
  mflcn_reg = mflcn_reg | 8U;
#line 2172
  goto ldv_51409;
  case_2: /* CIL Label */ 
#line 2178
  fccfg_reg = fccfg_reg | 8U;
#line 2179
  goto ldv_51409;
  case_3: /* CIL Label */ 
#line 2182
  mflcn_reg = mflcn_reg | 8U;
#line 2183
  fccfg_reg = fccfg_reg | 8U;
#line 2184
  goto ldv_51409;
  switch_default: /* CIL Label */ 
  {
#line 2186
  descriptor___0.modname = "ixgbe";
#line 2186
  descriptor___0.function = "ixgbe_fc_enable_generic";
#line 2186
  descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2186
  descriptor___0.format = "Flow control param set incorrectly\n";
#line 2186
  descriptor___0.lineno = 2186U;
#line 2186
  descriptor___0.flags = 0U;
#line 2186
  tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
  }
#line 2186
  if (tmp___0 != 0L) {
    {
#line 2186
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Flow control param set incorrectly\n");
    }
  } else {

  }
#line 2187
  ret_val = -4;
#line 2188
  goto out;
  switch_break: /* CIL Label */ ;
  }
  ldv_51409: 
  {
#line 2193
  mflcn_reg = mflcn_reg | 2U;
#line 2194
  ixgbe_write_reg(hw, 17044U, mflcn_reg);
#line 2195
  ixgbe_write_reg(hw, 15616U, fccfg_reg);
#line 2197
  fcrtl = (hw->fc.low_water << 10) | 2147483648U;
#line 2200
  i = 0;
  }
#line 2200
  goto ldv_51416;
  ldv_51415: ;
#line 2201
  if (((unsigned int )hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) {
    {
#line 2203
    ixgbe_write_reg(hw, (u32 )((i + 3208) * 4), fcrtl);
#line 2204
    fcrth = (hw->fc.high_water[i] << 10) | 2147483648U;
    }
  } else {
    {
#line 2206
    ixgbe_write_reg(hw, (u32 )((i + 3208) * 4), 0U);
#line 2213
    tmp___1 = ixgbe_read_reg(hw, (u32 )((i + 3840) * 4));
#line 2213
    fcrth = tmp___1 - 32U;
    }
  }
  {
#line 2216
  ixgbe_write_reg(hw, (u32 )((i + 3224) * 4), fcrth);
#line 2200
  i = i + 1;
  }
  ldv_51416: ;
#line 2200
  if (i <= 7) {
#line 2202
    goto ldv_51415;
  } else {

  }
#line 2220
  reg = (u32 )((int )hw->fc.pause_time * 65537);
#line 2221
  i = 0;
#line 2221
  goto ldv_51419;
  ldv_51418: 
  {
#line 2222
  ixgbe_write_reg(hw, (u32 )((i + 3200) * 4), reg);
#line 2221
  i = i + 1;
  }
  ldv_51419: ;
#line 2221
  if (i <= 3) {
#line 2223
    goto ldv_51418;
  } else {

  }
  {
#line 2224
  ixgbe_write_reg(hw, 12960U, (unsigned int )hw->fc.pause_time / 2U);
  }
  out: ;
#line 2227
  return (ret_val);
}
}
#line 2243 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw , u32 adv_reg , u32 lp_reg , u32 adv_sym ,
                              u32 adv_asm , u32 lp_sym , u32 lp_asm ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;

  {
#line 2246
  if (adv_reg == 0U || lp_reg == 0U) {
#line 2247
    return (-27);
  } else {

  }
#line 2249
  if ((adv_reg & adv_sym) != 0U && (lp_reg & lp_sym) != 0U) {
#line 2257
    if ((unsigned int )hw->fc.requested_mode == 3U) {
      {
#line 2258
      hw->fc.current_mode = 3;
#line 2259
      descriptor.modname = "ixgbe";
#line 2259
      descriptor.function = "ixgbe_negotiate_fc";
#line 2259
      descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2259
      descriptor.format = "Flow Control = FULL.\n";
#line 2259
      descriptor.lineno = 2259U;
#line 2259
      descriptor.flags = 0U;
#line 2259
      tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
      }
#line 2259
      if (tmp != 0L) {
        {
#line 2259
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Flow Control = FULL.\n");
        }
      } else {

      }
    } else {
      {
#line 2261
      hw->fc.current_mode = 1;
#line 2262
      descriptor___0.modname = "ixgbe";
#line 2262
      descriptor___0.function = "ixgbe_negotiate_fc";
#line 2262
      descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2262
      descriptor___0.format = "Flow Control=RX PAUSE frames only\n";
#line 2262
      descriptor___0.lineno = 2262U;
#line 2262
      descriptor___0.flags = 0U;
#line 2262
      tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
      }
#line 2262
      if (tmp___0 != 0L) {
        {
#line 2262
        __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Flow Control=RX PAUSE frames only\n");
        }
      } else {

      }
    }
  } else
#line 2264
  if ((((adv_reg & adv_sym) == 0U && (adv_reg & adv_asm) != 0U) && (lp_reg & lp_sym) != 0U) && (lp_reg & lp_asm) != 0U) {
    {
#line 2266
    hw->fc.current_mode = 2;
#line 2267
    descriptor___1.modname = "ixgbe";
#line 2267
    descriptor___1.function = "ixgbe_negotiate_fc";
#line 2267
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2267
    descriptor___1.format = "Flow Control = TX PAUSE frames only.\n";
#line 2267
    descriptor___1.lineno = 2267U;
#line 2267
    descriptor___1.flags = 0U;
#line 2267
    tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 2267
    if (tmp___1 != 0L) {
      {
#line 2267
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Control = TX PAUSE frames only.\n");
      }
    } else {

    }
  } else
#line 2268
  if ((((adv_reg & adv_sym) != 0U && (adv_reg & adv_asm) != 0U) && (lp_reg & lp_sym) == 0U) && (lp_reg & lp_asm) != 0U) {
    {
#line 2270
    hw->fc.current_mode = 1;
#line 2271
    descriptor___2.modname = "ixgbe";
#line 2271
    descriptor___2.function = "ixgbe_negotiate_fc";
#line 2271
    descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2271
    descriptor___2.format = "Flow Control = RX PAUSE frames only.\n";
#line 2271
    descriptor___2.lineno = 2271U;
#line 2271
    descriptor___2.flags = 0U;
#line 2271
    tmp___2 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
    }
#line 2271
    if (tmp___2 != 0L) {
      {
#line 2271
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Control = RX PAUSE frames only.\n");
      }
    } else {

    }
  } else {
    {
#line 2273
    hw->fc.current_mode = 0;
#line 2274
    descriptor___3.modname = "ixgbe";
#line 2274
    descriptor___3.function = "ixgbe_negotiate_fc";
#line 2274
    descriptor___3.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2274
    descriptor___3.format = "Flow Control = NONE.\n";
#line 2274
    descriptor___3.lineno = 2274U;
#line 2274
    descriptor___3.flags = 0U;
#line 2274
    tmp___3 = __builtin_expect((long )descriptor___3.flags & 1L, 0L);
    }
#line 2274
    if (tmp___3 != 0L) {
      {
#line 2274
      __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Control = NONE.\n");
      }
    } else {

    }
  }
#line 2276
  return (0);
}
}
#line 2285 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw ) 
{ 
  u32 pcs_anadv_reg ;
  u32 pcs_lpab_reg ;
  u32 linkstat ;
  s32 ret_val ;

  {
  {
#line 2288
  ret_val = -27;
#line 2296
  linkstat = ixgbe_read_reg(hw, 16908U);
  }
#line 2297
  if ((linkstat & 327680U) != 65536U) {
#line 2299
    goto out;
  } else {

  }
  {
#line 2301
  pcs_anadv_reg = ixgbe_read_reg(hw, 16920U);
#line 2302
  pcs_lpab_reg = ixgbe_read_reg(hw, 16924U);
#line 2304
  ret_val = ixgbe_negotiate_fc(hw, pcs_anadv_reg, pcs_lpab_reg, 128U, 256U, 128U,
                               256U);
  }
  out: ;
#line 2311
  return (ret_val);
}
}
#line 2320 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw ) 
{ 
  u32 links2 ;
  u32 anlp1_reg ;
  u32 autoc_reg ;
  u32 links ;
  s32 ret_val ;

  {
  {
#line 2323
  ret_val = -27;
#line 2330
  links = ixgbe_read_reg(hw, 17060U);
  }
#line 2331
  if ((int )links >= 0) {
#line 2332
    goto out;
  } else {

  }
#line 2334
  if ((unsigned int )hw->mac.type == 2U) {
    {
#line 2335
    links2 = ixgbe_read_reg(hw, 17188U);
    }
#line 2336
    if ((links2 & 64U) == 0U) {
#line 2337
      goto out;
    } else {

    }
  } else {

  }
  {
#line 2343
  autoc_reg = ixgbe_read_reg(hw, 17056U);
#line 2344
  anlp1_reg = ixgbe_read_reg(hw, 17072U);
#line 2346
  ret_val = ixgbe_negotiate_fc(hw, autoc_reg, anlp1_reg, 268435456U, 536870912U, 1024U,
                               2048U);
  }
  out: ;
#line 2351
  return (ret_val);
}
}
#line 2360 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw ) 
{ 
  u16 technology_ability_reg ;
  u16 lp_technology_ability_reg ;
  s32 tmp ;

  {
  {
#line 2362
  technology_ability_reg = 0U;
#line 2363
  lp_technology_ability_reg = 0U;
#line 2365
  (*(hw->phy.ops.read_reg))(hw, 16U, 7U, & technology_ability_reg);
#line 2368
  (*(hw->phy.ops.read_reg))(hw, 19U, 7U, & lp_technology_ability_reg);
#line 2372
  tmp = ixgbe_negotiate_fc(hw, (unsigned int )technology_ability_reg, (unsigned int )lp_technology_ability_reg,
                           1024U, 2048U, 1024U, 2048U);
  }
#line 2372
  return (tmp);
}
}
#line 2385 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_fc_autoneg(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  ixgbe_link_speed speed ;
  bool link_up ;
  bool tmp ;

  {
#line 2387
  ret_val = -27;
#line 2400
  if ((int )hw->fc.disable_fc_autoneg) {
#line 2401
    goto out;
  } else {

  }
  {
#line 2403
  (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
  }
#line 2404
  if (! link_up) {
#line 2405
    goto out;
  } else {

  }
  {
#line 2409
  if ((unsigned int )hw->phy.media_type == 2U) {
#line 2409
    goto case_2;
  } else {

  }
#line 2410
  if ((unsigned int )hw->phy.media_type == 1U) {
#line 2410
    goto case_1;
  } else {

  }
#line 2416
  if ((unsigned int )hw->phy.media_type == 6U) {
#line 2416
    goto case_6;
  } else {

  }
#line 2421
  if ((unsigned int )hw->phy.media_type == 5U) {
#line 2421
    goto case_5;
  } else {

  }
#line 2426
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_1: /* CIL Label */ ;
#line 2411
  if (speed == 32U) {
    {
#line 2412
    ret_val = ixgbe_fc_autoneg_fiber(hw);
    }
  } else {

  }
#line 2413
  goto ldv_51467;
  case_6: /* CIL Label */ 
  {
#line 2417
  ret_val = ixgbe_fc_autoneg_backplane(hw);
  }
#line 2418
  goto ldv_51467;
  case_5: /* CIL Label */ 
  {
#line 2422
  tmp = ixgbe_device_supports_autoneg_fc(hw);
  }
#line 2422
  if ((int )tmp) {
    {
#line 2423
    ret_val = ixgbe_fc_autoneg_copper(hw);
    }
  } else {

  }
#line 2424
  goto ldv_51467;
  switch_default: /* CIL Label */ ;
#line 2427
  goto ldv_51467;
  switch_break: /* CIL Label */ ;
  }
  ldv_51467: ;
  out: ;
#line 2431
  if (ret_val == 0) {
#line 2432
    hw->fc.fc_was_autonegged = 1;
  } else {
#line 2434
    hw->fc.fc_was_autonegged = 0;
#line 2435
    hw->fc.current_mode = hw->fc.requested_mode;
  }
#line 2437
  return;
}
}
#line 2448 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  s32 status ;
  u32 i ;
  u16 value ;
  u32 tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;

  {
  {
#line 2450
  adapter = (struct ixgbe_adapter *)hw->back;
#line 2451
  status = 0;
#line 2456
  ixgbe_write_reg(hw, 0U, 4U);
#line 2459
  tmp = ixgbe_read_reg(hw, 8U);
  }
#line 2459
  if ((tmp & 524288U) == 0U) {
#line 2460
    goto out;
  } else {

  }
#line 2463
  i = 0U;
#line 2463
  goto ldv_51480;
  ldv_51479: 
  {
#line 2464
  __const_udelay(429500UL);
#line 2465
  tmp___0 = ixgbe_read_reg(hw, 8U);
  }
#line 2465
  if ((tmp___0 & 524288U) == 0U) {
#line 2466
    goto out;
  } else {

  }
#line 2463
  i = i + 1U;
  ldv_51480: ;
#line 2463
  if (i <= 799U) {
#line 2465
    goto ldv_51479;
  } else {

  }
  {
#line 2477
  descriptor.modname = "ixgbe";
#line 2477
  descriptor.function = "ixgbe_disable_pcie_master";
#line 2477
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2477
  descriptor.format = "GIO Master Disable bit didn\'t clear - requesting resets\n";
#line 2477
  descriptor.lineno = 2477U;
#line 2477
  descriptor.flags = 0U;
#line 2477
  tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 2477
  if (tmp___1 != 0L) {
    {
#line 2477
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "GIO Master Disable bit didn\'t clear - requesting resets\n");
    }
  } else {

  }
#line 2478
  hw->mac.flags = (u8 )((unsigned int )hw->mac.flags | 1U);
#line 2484
  i = 0U;
#line 2484
  goto ldv_51485;
  ldv_51484: 
  {
#line 2485
  __const_udelay(429500UL);
#line 2486
  pci_read_config_word((struct pci_dev  const  *)adapter->pdev, 170, & value);
  }
#line 2488
  if (((int )value & 32) == 0) {
#line 2489
    goto out;
  } else {

  }
#line 2484
  i = i + 1U;
  ldv_51485: ;
#line 2484
  if (i <= 799U) {
#line 2486
    goto ldv_51484;
  } else {

  }
  {
#line 2492
  descriptor___0.modname = "ixgbe";
#line 2492
  descriptor___0.function = "ixgbe_disable_pcie_master";
#line 2492
  descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2492
  descriptor___0.format = "PCIe transaction pending bit also did not clear.\n";
#line 2492
  descriptor___0.lineno = 2492U;
#line 2492
  descriptor___0.flags = 0U;
#line 2492
  tmp___2 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
  }
#line 2492
  if (tmp___2 != 0L) {
    {
#line 2492
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "PCIe transaction pending bit also did not clear.\n");
    }
  } else {

  }
#line 2493
  status = -12;
  out: ;
#line 2496
  return (status);
}
}
#line 2507 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw , u16 mask ) 
{ 
  u32 gssr ;
  u32 swmask ;
  u32 fwmask ;
  u32 timeout ;
  u32 i ;
  s32 tmp ;

  {
#line 2509
  gssr = 0U;
#line 2510
  swmask = (u32 )mask;
#line 2511
  fwmask = (u32 )((int )mask << 5);
#line 2512
  timeout = 200U;
#line 2515
  i = 0U;
#line 2515
  goto ldv_51498;
  ldv_51497: 
  {
#line 2520
  tmp = ixgbe_get_eeprom_semaphore(hw);
  }
#line 2520
  if (tmp != 0) {
#line 2521
    return (-16);
  } else {

  }
  {
#line 2523
  gssr = ixgbe_read_reg(hw, 65888U);
  }
#line 2524
  if ((gssr & (fwmask | swmask)) == 0U) {
    {
#line 2525
    gssr = gssr | swmask;
#line 2526
    ixgbe_write_reg(hw, 65888U, gssr);
#line 2527
    ixgbe_release_eeprom_semaphore(hw);
    }
#line 2528
    return (0);
  } else {
    {
#line 2531
    ixgbe_release_eeprom_semaphore(hw);
#line 2532
    usleep_range(5000UL, 10000UL);
    }
  }
#line 2515
  i = i + 1U;
  ldv_51498: ;
#line 2515
  if (i < timeout) {
#line 2517
    goto ldv_51497;
  } else {

  }

#line 2537
  if ((gssr & (fwmask | swmask)) != 0U) {
    {
#line 2538
    ixgbe_release_swfw_sync(hw, (int )((u16 )gssr) & ((int )((u16 )fwmask) | (int )((u16 )swmask)));
    }
  } else {

  }
  {
#line 2540
  usleep_range(5000UL, 10000UL);
  }
#line 2541
  return (-16);
}
}
#line 2552 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw , u16 mask ) 
{ 
  u32 gssr ;
  u32 swmask ;

  {
  {
#line 2555
  swmask = (u32 )mask;
#line 2557
  ixgbe_get_eeprom_semaphore(hw);
#line 2559
  gssr = ixgbe_read_reg(hw, 65888U);
#line 2560
  gssr = gssr & ~ swmask;
#line 2561
  ixgbe_write_reg(hw, 65888U, gssr);
#line 2563
  ixgbe_release_eeprom_semaphore(hw);
  }
#line 2564
  return;
}
}
#line 2573 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw ) 
{ 
  int i ;
  int secrxreg ;
  u32 tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  {
#line 2579
  tmp = ixgbe_read_reg(hw, 36096U);
#line 2579
  secrxreg = (int )tmp;
#line 2580
  secrxreg = secrxreg | 2;
#line 2581
  ixgbe_write_reg(hw, 36096U, (u32 )secrxreg);
#line 2582
  i = 0;
  }
#line 2582
  goto ldv_51513;
  ldv_51512: 
  {
#line 2583
  tmp___0 = ixgbe_read_reg(hw, 36100U);
#line 2583
  secrxreg = (int )tmp___0;
  }
#line 2584
  if (secrxreg & 1) {
#line 2585
    goto ldv_51511;
  } else {
    {
#line 2588
    __const_udelay(4295000UL);
    }
  }
#line 2582
  i = i + 1;
  ldv_51513: ;
#line 2582
  if (i <= 39) {
#line 2584
    goto ldv_51512;
  } else {

  }
  ldv_51511: ;
#line 2592
  if (i > 39) {
    {
#line 2593
    descriptor.modname = "ixgbe";
#line 2593
    descriptor.function = "ixgbe_disable_rx_buff_generic";
#line 2593
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2593
    descriptor.format = "Rx unit being enabled before security path fully disabled.  Continuing with init.\n";
#line 2593
    descriptor.lineno = 2594U;
#line 2593
    descriptor.flags = 0U;
#line 2593
    tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 2593
    if (tmp___1 != 0L) {
      {
#line 2593
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Rx unit being enabled before security path fully disabled.  Continuing with init.\n");
      }
    } else {

    }
  } else {

  }
#line 2596
  return (0);
}
}
#line 2606 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw ) 
{ 
  int secrxreg ;
  u32 tmp ;

  {
  {
#line 2610
  tmp = ixgbe_read_reg(hw, 36096U);
#line 2610
  secrxreg = (int )tmp;
#line 2611
  secrxreg = secrxreg & -3;
#line 2612
  ixgbe_write_reg(hw, 36096U, (u32 )secrxreg);
#line 2613
  ixgbe_read_reg(hw, 8U);
  }
#line 2615
  return (0);
}
}
#line 2625 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw , u32 regval ) 
{ 


  {
  {
#line 2627
  ixgbe_write_reg(hw, 12288U, regval);
  }
#line 2629
  return (0);
}
}
#line 2637 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  ixgbe_link_speed speed ;
  bool link_up ;
  u32 autoc_reg ;
  u32 tmp ;
  u32 led_reg ;
  u32 tmp___0 ;
  s32 ret_val ;
  bool got_lock ;
  bool tmp___1 ;

  {
  {
#line 2639
  speed = 0U;
#line 2640
  link_up = 0;
#line 2641
  tmp = ixgbe_read_reg(hw, 17056U);
#line 2641
  autoc_reg = tmp;
#line 2642
  tmp___0 = ixgbe_read_reg(hw, 512U);
#line 2642
  led_reg = tmp___0;
#line 2643
  ret_val = 0;
#line 2649
  (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
  }
#line 2651
  if (! link_up) {
#line 2655
    got_lock = 0;
#line 2657
    if ((unsigned int )hw->mac.type == 2U) {
      {
#line 2657
      tmp___1 = ixgbe_verify_lesm_fw_enabled_82599(hw);
      }
#line 2657
      if ((int )tmp___1) {
        {
#line 2659
        ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8);
        }
#line 2661
        if (ret_val != 0) {
#line 2662
          goto out;
        } else {

        }
#line 2664
        got_lock = 1;
      } else {

      }
    } else {

    }
    {
#line 2666
    autoc_reg = autoc_reg | 4096U;
#line 2667
    autoc_reg = autoc_reg | 1U;
#line 2668
    ixgbe_write_reg(hw, 17056U, autoc_reg);
#line 2669
    ixgbe_read_reg(hw, 8U);
    }
#line 2671
    if ((int )got_lock) {
      {
#line 2672
      (*(hw->mac.ops.release_swfw_sync))(hw, 8);
      }
    } else {

    }
    {
#line 2674
    usleep_range(10000UL, 20000UL);
    }
  } else {

  }
  {
#line 2677
  led_reg = led_reg & (u32 )(~ (15 << (int )(index * 8U)));
#line 2678
  led_reg = led_reg | (u32 )(128 << (int )(index * 8U));
#line 2679
  ixgbe_write_reg(hw, 512U, led_reg);
#line 2680
  ixgbe_read_reg(hw, 8U);
  }
  out: ;
#line 2683
  return (ret_val);
}
}
#line 2691 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 autoc_reg ;
  u32 tmp ;
  u32 led_reg ;
  u32 tmp___0 ;
  s32 ret_val ;
  bool got_lock ;
  bool tmp___1 ;

  {
  {
#line 2693
  tmp = ixgbe_read_reg(hw, 17056U);
#line 2693
  autoc_reg = tmp;
#line 2694
  tmp___0 = ixgbe_read_reg(hw, 512U);
#line 2694
  led_reg = tmp___0;
#line 2695
  ret_val = 0;
#line 2696
  got_lock = 0;
  }
#line 2701
  if ((unsigned int )hw->mac.type == 2U) {
    {
#line 2701
    tmp___1 = ixgbe_verify_lesm_fw_enabled_82599(hw);
    }
#line 2701
    if ((int )tmp___1) {
      {
#line 2703
      ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8);
      }
#line 2705
      if (ret_val != 0) {
#line 2706
        goto out;
      } else {

      }
#line 2708
      got_lock = 1;
    } else {

    }
  } else {

  }
  {
#line 2711
  autoc_reg = autoc_reg & 4294967294U;
#line 2712
  autoc_reg = autoc_reg | 4096U;
#line 2713
  ixgbe_write_reg(hw, 17056U, autoc_reg);
  }
#line 2715
  if ((unsigned int )hw->mac.type == 2U) {
    {
#line 2716
    ixgbe_reset_pipeline_82599(hw);
    }
  } else {

  }
#line 2718
  if ((int )got_lock) {
    {
#line 2719
    (*(hw->mac.ops.release_swfw_sync))(hw, 8);
    }
  } else {

  }
  {
#line 2721
  led_reg = led_reg & (u32 )(~ (15 << (int )(index * 8U)));
#line 2722
  led_reg = led_reg & (u32 )(~ (128 << (int )(index * 8U)));
#line 2723
  led_reg = led_reg | (u32 )(4 << (int )(index * 8U));
#line 2724
  ixgbe_write_reg(hw, 512U, led_reg);
#line 2725
  ixgbe_read_reg(hw, 8U);
  }
  out: ;
#line 2728
  return (ret_val);
}
}
#line 2740 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw , u16 *san_mac_offset ) 
{ 
  s32 ret_val ;

  {
  {
#line 2749
  ret_val = (*(hw->eeprom.ops.read))(hw, 40, san_mac_offset);
  }
#line 2751
  if (ret_val != 0) {
    {
#line 2752
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at offset %d failed\n", 40);
    }
  } else {

  }
#line 2755
  return (ret_val);
}
}
#line 2768 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw , u8 *san_mac_addr ) 
{ 
  u16 san_mac_data ;
  u16 san_mac_offset ;
  u8 i ;
  s32 ret_val ;

  {
  {
#line 2778
  ret_val = ixgbe_get_san_mac_addr_offset(hw, & san_mac_offset);
  }
#line 2779
  if ((ret_val != 0 || (unsigned int )san_mac_offset == 0U) || (unsigned int )san_mac_offset == 65535U) {
#line 2781
    goto san_mac_addr_clr;
  } else {

  }
  {
#line 2784
  (*(hw->mac.ops.set_lan_id))(hw);
  }
#line 2786
  if ((unsigned int )hw->bus.func != 0U) {
#line 2786
    san_mac_offset = (unsigned int )san_mac_offset + 3U;
  } else {
#line 2786
    san_mac_offset = san_mac_offset;
  }
#line 2788
  i = 0U;
#line 2788
  goto ldv_51559;
  ldv_51558: 
  {
#line 2789
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )san_mac_offset, & san_mac_data);
  }
#line 2791
  if (ret_val != 0) {
    {
#line 2792
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at offset %d failed\n", (int )san_mac_offset);
    }
#line 2794
    goto san_mac_addr_clr;
  } else {

  }
#line 2796
  *(san_mac_addr + (unsigned long )((int )i * 2)) = (unsigned char )san_mac_data;
#line 2797
  *(san_mac_addr + ((unsigned long )((int )i * 2) + 1UL)) = (unsigned char )((int )san_mac_data >> 8);
#line 2798
  san_mac_offset = (u16 )((int )san_mac_offset + 1);
#line 2788
  i = (u8 )((int )i + 1);
  ldv_51559: ;
#line 2788
  if ((unsigned int )i <= 2U) {
#line 2790
    goto ldv_51558;
  } else {

  }

#line 2800
  return (0);
  san_mac_addr_clr: 
#line 2806
  i = 0U;
#line 2806
  goto ldv_51562;
  ldv_51561: 
#line 2807
  *(san_mac_addr + (unsigned long )i) = 255U;
#line 2806
  i = (u8 )((int )i + 1);
  ldv_51562: ;
#line 2806
  if ((unsigned int )i <= 5U) {
#line 2808
    goto ldv_51561;
  } else {

  }

#line 2808
  return (ret_val);
}
}
#line 2818 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  u16 msix_count ;
  u16 max_msix_count ;
  u16 pcie_offset ;

  {
#line 2820
  adapter = (struct ixgbe_adapter *)hw->back;
#line 2821
  msix_count = 1U;
  {
#line 2826
  if ((unsigned int )hw->mac.type == 1U) {
#line 2826
    goto case_1;
  } else {

  }
#line 2830
  if ((unsigned int )hw->mac.type == 2U) {
#line 2830
    goto case_2;
  } else {

  }
#line 2831
  if ((unsigned int )hw->mac.type == 3U) {
#line 2831
    goto case_3;
  } else {

  }
#line 2835
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2827
  pcie_offset = 98U;
#line 2828
  max_msix_count = 19U;
#line 2829
  goto ldv_51572;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 2832
  pcie_offset = 114U;
#line 2833
  max_msix_count = 64U;
#line 2834
  goto ldv_51572;
  switch_default: /* CIL Label */ ;
#line 2836
  return (msix_count);
  switch_break: /* CIL Label */ ;
  }
  ldv_51572: 
  {
#line 2839
  pci_read_config_word((struct pci_dev  const  *)adapter->pdev, (int )pcie_offset,
                       & msix_count);
#line 2840
  msix_count = (unsigned int )msix_count & 2047U;
#line 2843
  msix_count = (u16 )((int )msix_count + 1);
  }
#line 2845
  if ((int )msix_count > (int )max_msix_count) {
#line 2846
    msix_count = max_msix_count;
  } else {

  }
#line 2848
  return (msix_count);
}
}
#line 2857 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) 
{ 
  u32 mpsar_lo ;
  u32 mpsar_hi ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2860
  rar_entries = hw->mac.num_rar_entries;
#line 2863
  if (rar >= rar_entries) {
    {
#line 2864
    descriptor.modname = "ixgbe";
#line 2864
    descriptor.function = "ixgbe_clear_vmdq_generic";
#line 2864
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2864
    descriptor.format = "RAR index %d is out of range.\n";
#line 2864
    descriptor.lineno = 2864U;
#line 2864
    descriptor.flags = 0U;
#line 2864
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 2864
    if (tmp != 0L) {
      {
#line 2864
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", rar);
      }
    } else {

    }
#line 2865
    return (-32);
  } else {

  }
  {
#line 2868
  mpsar_lo = ixgbe_read_reg(hw, (rar + 5312U) * 8U);
#line 2869
  mpsar_hi = ixgbe_read_reg(hw, rar * 8U + 42500U);
  }
#line 2871
  if ((mpsar_lo | mpsar_hi) == 0U) {
#line 2872
    goto done;
  } else {

  }
#line 2874
  if (vmdq == 4294967295U) {
#line 2875
    if (mpsar_lo != 0U) {
      {
#line 2876
      ixgbe_write_reg(hw, (rar + 5312U) * 8U, 0U);
#line 2877
      mpsar_lo = 0U;
      }
    } else {

    }
#line 2879
    if (mpsar_hi != 0U) {
      {
#line 2880
      ixgbe_write_reg(hw, rar * 8U + 42500U, 0U);
#line 2881
      mpsar_hi = 0U;
      }
    } else {

    }
  } else
#line 2883
  if (vmdq <= 31U) {
    {
#line 2884
    mpsar_lo = mpsar_lo & (u32 )(~ (1 << (int )vmdq));
#line 2885
    ixgbe_write_reg(hw, (rar + 5312U) * 8U, mpsar_lo);
    }
  } else {
    {
#line 2887
    mpsar_hi = mpsar_hi & (u32 )(~ (1 << (int )(vmdq - 32U)));
#line 2888
    ixgbe_write_reg(hw, rar * 8U + 42500U, mpsar_hi);
    }
  }
#line 2892
  if ((mpsar_lo | mpsar_hi) == 0U && rar != 0U) {
    {
#line 2893
    (*(hw->mac.ops.clear_rar))(hw, rar);
    }
  } else {

  }
  done: ;
#line 2895
  return (0);
}
}
#line 2904 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) 
{ 
  u32 mpsar ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2907
  rar_entries = hw->mac.num_rar_entries;
#line 2910
  if (rar >= rar_entries) {
    {
#line 2911
    descriptor.modname = "ixgbe";
#line 2911
    descriptor.function = "ixgbe_set_vmdq_generic";
#line 2911
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 2911
    descriptor.format = "RAR index %d is out of range.\n";
#line 2911
    descriptor.lineno = 2911U;
#line 2911
    descriptor.flags = 0U;
#line 2911
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 2911
    if (tmp != 0L) {
      {
#line 2911
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", rar);
      }
    } else {

    }
#line 2912
    return (-32);
  } else {

  }
#line 2915
  if (vmdq <= 31U) {
    {
#line 2916
    mpsar = ixgbe_read_reg(hw, (rar + 5312U) * 8U);
#line 2917
    mpsar = mpsar | (u32 )(1 << (int )vmdq);
#line 2918
    ixgbe_write_reg(hw, (rar + 5312U) * 8U, mpsar);
    }
  } else {
    {
#line 2920
    mpsar = ixgbe_read_reg(hw, rar * 8U + 42500U);
#line 2921
    mpsar = mpsar | (u32 )(1 << (int )(vmdq - 32U));
#line 2922
    ixgbe_write_reg(hw, rar * 8U + 42500U, mpsar);
    }
  }
#line 2924
  return (0);
}
}
#line 2937 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw , u32 vmdq ) 
{ 
  u32 rar ;

  {
#line 2939
  rar = (u32 )hw->mac.san_mac_rar_index;
#line 2941
  if (vmdq <= 31U) {
    {
#line 2942
    ixgbe_write_reg(hw, (rar + 5312U) * 8U, (u32 )(1 << (int )vmdq));
#line 2943
    ixgbe_write_reg(hw, rar * 8U + 42500U, 0U);
    }
  } else {
    {
#line 2945
    ixgbe_write_reg(hw, (rar + 5312U) * 8U, 0U);
#line 2946
    ixgbe_write_reg(hw, rar * 8U + 42500U, (u32 )(1 << (int )(vmdq - 32U)));
    }
  }
#line 2949
  return (0);
}
}
#line 2956 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw ) 
{ 
  int i ;

  {
#line 2960
  i = 0;
#line 2960
  goto ldv_51606;
  ldv_51605: 
  {
#line 2961
  ixgbe_write_reg(hw, (u32 )((i + 15616) * 4), 0U);
#line 2960
  i = i + 1;
  }
  ldv_51606: ;
#line 2960
  if (i <= 127) {
#line 2962
    goto ldv_51605;
  } else {

  }

#line 2963
  return (0);
}
}
#line 2974 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw , u32 vlan ) 
{ 
  u32 bits ;
  u32 first_empty_slot ;
  s32 regindex ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2976
  bits = 0U;
#line 2977
  first_empty_slot = 0U;
#line 2981
  if (vlan == 0U) {
#line 2982
    return (0);
  } else {

  }
#line 2988
  regindex = 1;
#line 2988
  goto ldv_51617;
  ldv_51616: 
  {
#line 2989
  bits = ixgbe_read_reg(hw, (u32 )((regindex + 15424) * 4));
  }
#line 2990
  if ((bits | first_empty_slot) == 0U) {
#line 2991
    first_empty_slot = (u32 )regindex;
  } else
#line 2992
  if ((bits & 4095U) == vlan) {
#line 2993
    goto ldv_51615;
  } else {

  }
#line 2988
  regindex = regindex + 1;
  ldv_51617: ;
#line 2988
  if (regindex <= 63) {
#line 2990
    goto ldv_51616;
  } else {

  }
  ldv_51615: ;
#line 3001
  if (regindex > 63) {
#line 3002
    if (first_empty_slot != 0U) {
#line 3003
      regindex = (s32 )first_empty_slot;
    } else {
      {
#line 3005
      descriptor.modname = "ixgbe";
#line 3005
      descriptor.function = "ixgbe_find_vlvf_slot";
#line 3005
      descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3005
      descriptor.format = "No space in VLVF.\n";
#line 3005
      descriptor.lineno = 3005U;
#line 3005
      descriptor.flags = 0U;
#line 3005
      tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
      }
#line 3005
      if (tmp != 0L) {
        {
#line 3005
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "No space in VLVF.\n");
        }
      } else {

      }
#line 3006
      regindex = -25;
    }
  } else {

  }
#line 3010
  return (regindex);
}
}
#line 3022 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw , u32 vlan , u32 vind , bool vlan_on ) 
{ 
  s32 regindex ;
  u32 bitindex ;
  u32 vfta ;
  u32 bits ;
  u32 vt ;
  u32 targetbit ;
  bool vfta_changed ;
  s32 vlvf_index ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 3031
  vfta_changed = 0;
#line 3033
  if (vlan > 4095U) {
#line 3034
    return (-5);
  } else {

  }
  {
#line 3048
  regindex = (s32 )(vlan >> 5) & 127;
#line 3049
  bitindex = vlan & 31U;
#line 3050
  targetbit = (u32 )(1 << (int )bitindex);
#line 3051
  vfta = ixgbe_read_reg(hw, (u32 )((regindex + 10240) * 4));
  }
#line 3053
  if ((int )vlan_on) {
#line 3054
    if ((vfta & targetbit) == 0U) {
#line 3055
      vfta = vfta | targetbit;
#line 3056
      vfta_changed = 1;
    } else {

    }
  } else
#line 3059
  if ((vfta & targetbit) != 0U) {
#line 3060
    vfta = vfta & ~ targetbit;
#line 3061
    vfta_changed = 1;
  } else {

  }
  {
#line 3073
  vt = ixgbe_read_reg(hw, 20912U);
  }
#line 3074
  if ((int )vt & 1) {
    {
#line 3077
    vlvf_index = ixgbe_find_vlvf_slot(hw, vlan);
    }
#line 3078
    if (vlvf_index < 0) {
#line 3079
      return (vlvf_index);
    } else {

    }
#line 3081
    if ((int )vlan_on) {
#line 3083
      if (vind <= 31U) {
        {
#line 3084
        bits = ixgbe_read_reg(hw, (u32 )((vlvf_index + 7744) * 8));
#line 3086
        bits = bits | (u32 )(1 << (int )vind);
#line 3087
        ixgbe_write_reg(hw, (u32 )((vlvf_index + 7744) * 8), bits);
        }
      } else {
        {
#line 3091
        bits = ixgbe_read_reg(hw, (u32 )(vlvf_index * 8 + 61956));
#line 3093
        bits = bits | (u32 )(1 << (int )(vind - 32U));
#line 3094
        ixgbe_write_reg(hw, (u32 )(vlvf_index * 8 + 61956), bits);
        }
      }
    } else
#line 3100
    if (vind <= 31U) {
      {
#line 3101
      bits = ixgbe_read_reg(hw, (u32 )((vlvf_index + 7744) * 8));
#line 3103
      bits = bits & (u32 )(~ (1 << (int )vind));
#line 3104
      ixgbe_write_reg(hw, (u32 )((vlvf_index + 7744) * 8), bits);
#line 3107
      tmp = ixgbe_read_reg(hw, (u32 )(vlvf_index * 8 + 61956));
#line 3107
      bits = bits | tmp;
      }
    } else {
      {
#line 3110
      bits = ixgbe_read_reg(hw, (u32 )(vlvf_index * 8 + 61956));
#line 3112
      bits = bits & (u32 )(~ (1 << (int )(vind - 32U)));
#line 3113
      ixgbe_write_reg(hw, (u32 )(vlvf_index * 8 + 61956), bits);
#line 3116
      tmp___0 = ixgbe_read_reg(hw, (u32 )((vlvf_index + 7744) * 8));
#line 3116
      bits = bits | tmp___0;
      }
    }
#line 3136
    if (bits != 0U) {
      {
#line 3137
      ixgbe_write_reg(hw, (u32 )((vlvf_index + 15424) * 4), vlan | 2147483648U);
      }
#line 3139
      if (! vlan_on) {
#line 3143
        vfta_changed = 0;
      } else {

      }
    } else {
      {
#line 3147
      ixgbe_write_reg(hw, (u32 )((vlvf_index + 15424) * 4), 0U);
      }
    }
  } else {

  }
#line 3150
  if ((int )vfta_changed) {
    {
#line 3151
    ixgbe_write_reg(hw, (u32 )((regindex + 10240) * 4), vfta);
    }
  } else {

  }
#line 3153
  return (0);
}
}
#line 3162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw ) 
{ 
  u32 offset ;

  {
#line 3166
  offset = 0U;
#line 3166
  goto ldv_51639;
  ldv_51638: 
  {
#line 3167
  ixgbe_write_reg(hw, (offset + 10240U) * 4U, 0U);
#line 3166
  offset = offset + 1U;
  }
  ldv_51639: ;
#line 3166
  if (offset < hw->mac.vft_size) {
#line 3168
    goto ldv_51638;
  } else {

  }
#line 3169
  offset = 0U;
#line 3169
  goto ldv_51642;
  ldv_51641: 
  {
#line 3170
  ixgbe_write_reg(hw, (offset + 15424U) * 4U, 0U);
#line 3171
  ixgbe_write_reg(hw, (offset + 7744U) * 8U, 0U);
#line 3172
  ixgbe_write_reg(hw, offset * 8U + 61956U, 0U);
#line 3169
  offset = offset + 1U;
  }
  ldv_51642: ;
#line 3169
  if (offset <= 63U) {
#line 3171
    goto ldv_51641;
  } else {

  }

#line 3175
  return (0);
}
}
#line 3187 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw , ixgbe_link_speed *speed , bool *link_up ,
                                 bool link_up_wait_to_complete ) 
{ 
  u32 links_reg ;
  u32 links_orig ;
  u32 i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  {
#line 3194
  links_orig = ixgbe_read_reg(hw, 17060U);
#line 3196
  links_reg = ixgbe_read_reg(hw, 17060U);
  }
#line 3198
  if (links_orig != links_reg) {
    {
#line 3199
    descriptor.modname = "ixgbe";
#line 3199
    descriptor.function = "ixgbe_check_mac_link_generic";
#line 3199
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3199
    descriptor.format = "LINKS changed from %08X to %08X\n";
#line 3199
    descriptor.lineno = 3200U;
#line 3199
    descriptor.flags = 0U;
#line 3199
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 3199
    if (tmp != 0L) {
      {
#line 3199
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "LINKS changed from %08X to %08X\n", links_orig, links_reg);
      }
    } else {

    }
  } else {

  }
#line 3203
  if ((int )link_up_wait_to_complete) {
#line 3204
    i = 0U;
#line 3204
    goto ldv_51657;
    ldv_51656: ;
#line 3205
    if ((links_reg & 1073741824U) != 0U) {
#line 3206
      *link_up = 1;
#line 3207
      goto ldv_51655;
    } else {
#line 3209
      *link_up = 0;
    }
    {
#line 3211
    msleep(100U);
#line 3212
    links_reg = ixgbe_read_reg(hw, 17060U);
#line 3204
    i = i + 1U;
    }
    ldv_51657: ;
#line 3204
    if (i <= 89U) {
#line 3206
      goto ldv_51656;
    } else {

    }
    ldv_51655: ;
  } else
#line 3215
  if ((links_reg & 1073741824U) != 0U) {
#line 3216
    *link_up = 1;
  } else {
#line 3218
    *link_up = 0;
  }
#line 3221
  if ((links_reg & 805306368U) == 805306368U) {
#line 3223
    *speed = 128U;
  } else
#line 3224
  if ((links_reg & 805306368U) == 536870912U) {
#line 3226
    *speed = 32U;
  } else
#line 3227
  if ((links_reg & 805306368U) == 268435456U) {
#line 3229
    *speed = 8U;
  } else {
#line 3231
    *speed = 0U;
  }
#line 3233
  return (0);
}
}
#line 3246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw , u16 *wwnn_prefix , u16 *wwpn_prefix ) 
{ 
  u16 offset ;
  u16 caps ;
  u16 alt_san_mac_blk_offset ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;

  {
  {
#line 3253
  *wwnn_prefix = 65535U;
#line 3254
  *wwpn_prefix = 65535U;
#line 3257
  offset = 39U;
#line 3258
  tmp = (*(hw->eeprom.ops.read))(hw, (int )offset, & alt_san_mac_blk_offset);
  }
#line 3258
  if (tmp != 0) {
#line 3259
    goto wwn_prefix_err;
  } else {

  }
#line 3261
  if ((unsigned int )alt_san_mac_blk_offset - 1U > 65533U) {
#line 3263
    goto wwn_prefix_out;
  } else {

  }
  {
#line 3266
  offset = alt_san_mac_blk_offset;
#line 3267
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )offset, & caps);
  }
#line 3267
  if (tmp___0 != 0) {
#line 3268
    goto wwn_prefix_err;
  } else {

  }
#line 3269
  if (((int )caps & 1) == 0) {
#line 3270
    goto wwn_prefix_out;
  } else {

  }
  {
#line 3273
  offset = (unsigned int )alt_san_mac_blk_offset + 7U;
#line 3274
  tmp___1 = (*(hw->eeprom.ops.read))(hw, (int )offset, wwnn_prefix);
  }
#line 3274
  if (tmp___1 != 0) {
    {
#line 3275
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at offset %d failed\n", (int )offset);
    }
  } else {

  }
  {
#line 3277
  offset = (unsigned int )alt_san_mac_blk_offset + 8U;
#line 3278
  tmp___2 = (*(hw->eeprom.ops.read))(hw, (int )offset, wwpn_prefix);
  }
#line 3278
  if (tmp___2 != 0) {
#line 3279
    goto wwn_prefix_err;
  } else {

  }
  wwn_prefix_out: ;
#line 3282
  return (0);
  wwn_prefix_err: 
  {
#line 3285
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )offset);
  }
#line 3286
  return (0);
}
}
#line 3296 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw , bool enable , int pf ) 
{ 
  int j ;
  int pf_target_reg ;
  int pf_target_shift ;
  u32 pfvfspoof ;

  {
#line 3299
  pf_target_reg = pf >> 3;
#line 3300
  pf_target_shift = pf % 8;
#line 3301
  pfvfspoof = 0U;
#line 3303
  if ((unsigned int )hw->mac.type == 1U) {
#line 3304
    return;
  } else {

  }
#line 3306
  if ((int )enable) {
#line 3307
    pfvfspoof = 255U;
  } else {

  }
#line 3313
  j = 0;
#line 3313
  goto ldv_51678;
  ldv_51677: 
  {
#line 3314
  ixgbe_write_reg(hw, (u32 )((j + 8320) * 4), pfvfspoof);
#line 3313
  j = j + 1;
  }
  ldv_51678: ;
#line 3313
  if (j < pf_target_reg) {
#line 3315
    goto ldv_51677;
  } else {

  }
  {
#line 3320
  pfvfspoof = pfvfspoof & (u32 )((1 << pf_target_shift) + -1);
#line 3321
  ixgbe_write_reg(hw, (u32 )((j + 8320) * 4), pfvfspoof);
#line 3327
  j = j + 1;
  }
#line 3327
  goto ldv_51681;
  ldv_51680: 
  {
#line 3328
  ixgbe_write_reg(hw, (u32 )((j + 8320) * 4), 0U);
#line 3327
  j = j + 1;
  }
  ldv_51681: ;
#line 3327
  if (j <= 7) {
#line 3329
    goto ldv_51680;
  } else {

  }

#line 3334
  return;
}
}
#line 3338 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw , bool enable , int vf ) 
{ 
  int vf_target_reg ;
  int vf_target_shift ;
  u32 pfvfspoof ;

  {
#line 3340
  vf_target_reg = vf >> 3;
#line 3341
  vf_target_shift = vf % 8 + 8;
#line 3344
  if ((unsigned int )hw->mac.type == 1U) {
#line 3345
    return;
  } else {

  }
  {
#line 3347
  pfvfspoof = ixgbe_read_reg(hw, (u32 )((vf_target_reg + 8320) * 4));
  }
#line 3348
  if ((int )enable) {
#line 3349
    pfvfspoof = pfvfspoof | (u32 )(1 << vf_target_shift);
  } else {
#line 3351
    pfvfspoof = pfvfspoof & (u32 )(~ (1 << vf_target_shift));
  }
  {
#line 3352
  ixgbe_write_reg(hw, (u32 )((vf_target_reg + 8320) * 4), pfvfspoof);
  }
#line 3353
  return;
}
}
#line 3363 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw , u16 *device_caps ) 
{ 


  {
  {
#line 3365
  (*(hw->eeprom.ops.read))(hw, 44, device_caps);
  }
#line 3367
  return (0);
}
}
#line 3377 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw , int num_pb , u32 headroom , int strategy ) 
{ 
  u32 pbsize ;
  int i ;
  u32 rxpktsize ;
  u32 txpktsize ;
  u32 txpbthresh ;

  {
#line 3382
  pbsize = hw->mac.rx_pb_size;
#line 3383
  i = 0;
#line 3387
  pbsize = pbsize - headroom;
#line 3389
  if (num_pb == 0) {
#line 3390
    num_pb = 1;
  } else {

  }
  {
#line 3396
  if (strategy == 1) {
#line 3396
    goto case_1;
  } else {

  }
#line 3406
  if (strategy == 0) {
#line 3406
    goto case_0;
  } else {

  }
#line 3412
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3400
  rxpktsize = (pbsize * 10U) / (u32 )(num_pb * 8);
#line 3401
  pbsize = pbsize - rxpktsize * (u32 )(num_pb / 2);
#line 3402
  rxpktsize = rxpktsize << 10;
#line 3403
  goto ldv_51708;
  ldv_51707: 
  {
#line 3404
  ixgbe_write_reg(hw, (u32 )((i + 3840) * 4), rxpktsize);
#line 3403
  i = i + 1;
  }
  ldv_51708: ;
#line 3403
  if (i < num_pb / 2) {
#line 3405
    goto ldv_51707;
  } else {

  }

  case_0: /* CIL Label */ 
#line 3408
  rxpktsize = pbsize / (u32 )(num_pb - i) << 10;
#line 3409
  goto ldv_51712;
  ldv_51711: 
  {
#line 3410
  ixgbe_write_reg(hw, (u32 )((i + 3840) * 4), rxpktsize);
#line 3409
  i = i + 1;
  }
  ldv_51712: ;
#line 3409
  if (i < num_pb) {
#line 3411
    goto ldv_51711;
  } else {

  }

#line 3411
  goto ldv_51714;
  switch_default: /* CIL Label */ ;
#line 3413
  goto ldv_51714;
  switch_break: /* CIL Label */ ;
  }
  ldv_51714: 
#line 3421
  txpktsize = (u32 )(163840 / num_pb);
#line 3422
  txpbthresh = txpktsize / 1024U - 10U;
#line 3423
  i = 0;
#line 3423
  goto ldv_51717;
  ldv_51716: 
  {
#line 3424
  ixgbe_write_reg(hw, (u32 )((i + 13056) * 4), txpktsize);
#line 3425
  ixgbe_write_reg(hw, (u32 )((i + 4692) * 4), txpbthresh);
#line 3423
  i = i + 1;
  }
  ldv_51717: ;
#line 3423
  if (i < num_pb) {
#line 3425
    goto ldv_51716;
  } else {

  }

#line 3429
  goto ldv_51720;
  ldv_51719: 
  {
#line 3430
  ixgbe_write_reg(hw, (u32 )((i + 3840) * 4), 0U);
#line 3431
  ixgbe_write_reg(hw, (u32 )((i + 13056) * 4), 0U);
#line 3432
  ixgbe_write_reg(hw, (u32 )((i + 4692) * 4), 0U);
#line 3429
  i = i + 1;
  }
  ldv_51720: ;
#line 3429
  if (i <= 7) {
#line 3431
    goto ldv_51719;
  } else {

  }

#line 3436
  return;
}
}
#line 3444 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u8 ixgbe_calculate_checksum(u8 *buffer , u32 length ) 
{ 
  u32 i ;
  u8 sum ;

  {
#line 3447
  sum = 0U;
#line 3449
  if ((unsigned long )buffer == (unsigned long )((u8 *)0U)) {
#line 3450
    return (0U);
  } else {

  }
#line 3452
  i = 0U;
#line 3452
  goto ldv_51729;
  ldv_51728: 
#line 3453
  sum = (int )sum + (int )*(buffer + (unsigned long )i);
#line 3452
  i = i + 1U;
  ldv_51729: ;
#line 3452
  if (i < length) {
#line 3454
    goto ldv_51728;
  } else {

  }

#line 3455
  return (- ((int )sum));
}
}
#line 3468 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_host_interface_command(struct ixgbe_hw *hw , u32 *buffer , u32 length ) 
{ 
  u32 hicr ;
  u32 i ;
  u32 bi ;
  u32 hdr_size ;
  u8 buf_len ;
  u8 dword_len ;
  s32 ret_val ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  u32 tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;

  {
#line 3472
  hdr_size = 4U;
#line 3475
  ret_val = 0;
#line 3477
  if (length == 0U || ((length & 3U) != 0U || length > 1792U)) {
    {
#line 3479
    descriptor.modname = "ixgbe";
#line 3479
    descriptor.function = "ixgbe_host_interface_command";
#line 3479
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3479
    descriptor.format = "Buffer length failure.\n";
#line 3479
    descriptor.lineno = 3479U;
#line 3479
    descriptor.flags = 0U;
#line 3479
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 3479
    if (tmp != 0L) {
      {
#line 3479
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Buffer length failure.\n");
      }
    } else {

    }
#line 3480
    ret_val = -33;
#line 3481
    goto out;
  } else {

  }
  {
#line 3485
  hicr = ixgbe_read_reg(hw, 89856U);
  }
#line 3486
  if ((hicr & 1U) == 0U) {
    {
#line 3487
    descriptor___0.modname = "ixgbe";
#line 3487
    descriptor___0.function = "ixgbe_host_interface_command";
#line 3487
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3487
    descriptor___0.format = "IXGBE_HOST_EN bit disabled.\n";
#line 3487
    descriptor___0.lineno = 3487U;
#line 3487
    descriptor___0.flags = 0U;
#line 3487
    tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 3487
    if (tmp___0 != 0L) {
      {
#line 3487
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "IXGBE_HOST_EN bit disabled.\n");
      }
    } else {

    }
#line 3488
    ret_val = -33;
#line 3489
    goto out;
  } else {

  }
#line 3493
  dword_len = (u8 )(length >> 2);
#line 3499
  i = 0U;
#line 3499
  goto ldv_51748;
  ldv_51747: 
  {
#line 3500
  ixgbe_write_reg(hw, (i << 2) + 88064U, *(buffer + (unsigned long )i));
#line 3499
  i = i + 1U;
  }
  ldv_51748: ;
#line 3499
  if (i < (u32 )dword_len) {
#line 3501
    goto ldv_51747;
  } else {

  }
  {
#line 3504
  ixgbe_write_reg(hw, 89856U, hicr | 2U);
#line 3506
  i = 0U;
  }
#line 3506
  goto ldv_51752;
  ldv_51751: 
  {
#line 3507
  hicr = ixgbe_read_reg(hw, 89856U);
  }
#line 3508
  if ((hicr & 2U) == 0U) {
#line 3509
    goto ldv_51750;
  } else {

  }
  {
#line 3510
  usleep_range(1000UL, 2000UL);
#line 3506
  i = i + 1U;
  }
  ldv_51752: ;
#line 3506
  if (i <= 499U) {
#line 3508
    goto ldv_51751;
  } else {

  }
  ldv_51750: ;
#line 3514
  if (i == 500U) {
#line 3514
    goto _L;
  } else {
    {
#line 3514
    tmp___2 = ixgbe_read_reg(hw, 89856U);
    }
#line 3514
    if ((tmp___2 & 4U) == 0U) {
      _L: /* CIL Label */ 
      {
#line 3516
      descriptor___1.modname = "ixgbe";
#line 3516
      descriptor___1.function = "ixgbe_host_interface_command";
#line 3516
      descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3516
      descriptor___1.format = "Command has failed with no status valid.\n";
#line 3516
      descriptor___1.lineno = 3516U;
#line 3516
      descriptor___1.flags = 0U;
#line 3516
      tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
      }
#line 3516
      if (tmp___1 != 0L) {
        {
#line 3516
        __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Command has failed with no status valid.\n");
        }
      } else {

      }
#line 3517
      ret_val = -33;
#line 3518
      goto out;
    } else {

    }
  }
#line 3522
  dword_len = (u8 )(hdr_size >> 2);
#line 3525
  bi = 0U;
#line 3525
  goto ldv_51755;
  ldv_51754: 
  {
#line 3526
  *(buffer + (unsigned long )bi) = ixgbe_read_reg(hw, (bi << 2) + 88064U);
#line 3525
  bi = bi + 1U;
  }
  ldv_51755: ;
#line 3525
  if (bi < (u32 )dword_len) {
#line 3527
    goto ldv_51754;
  } else {

  }
#line 3531
  buf_len = ((struct ixgbe_hic_hdr *)buffer)->buf_len;
#line 3532
  if ((unsigned int )buf_len == 0U) {
#line 3533
    goto out;
  } else {

  }
#line 3535
  if (length < (u32 )buf_len + hdr_size) {
    {
#line 3536
    descriptor___2.modname = "ixgbe";
#line 3536
    descriptor___2.function = "ixgbe_host_interface_command";
#line 3536
    descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_common.c";
#line 3536
    descriptor___2.format = "Buffer not large enough for reply message.\n";
#line 3536
    descriptor___2.lineno = 3536U;
#line 3536
    descriptor___2.flags = 0U;
#line 3536
    tmp___3 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
    }
#line 3536
    if (tmp___3 != 0L) {
      {
#line 3536
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Buffer not large enough for reply message.\n");
      }
    } else {

    }
#line 3537
    ret_val = -33;
#line 3538
    goto out;
  } else {

  }
#line 3542
  dword_len = (u8 )(((int )buf_len + 3) >> 2);
#line 3545
  goto ldv_51759;
  ldv_51758: 
  {
#line 3546
  *(buffer + (unsigned long )bi) = ixgbe_read_reg(hw, (bi << 2) + 88064U);
#line 3545
  bi = bi + 1U;
  }
  ldv_51759: ;
#line 3545
  if (bi <= (u32 )dword_len) {
#line 3547
    goto ldv_51758;
  } else {

  }

  out: ;
#line 3551
  return (ret_val);
}
}
#line 3567 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw , u8 maj , u8 min , u8 build ,
                                 u8 sub ) 
{ 
  struct ixgbe_hic_drv_info fw_cmd ;
  int i ;
  s32 ret_val ;
  s32 tmp ;

  {
  {
#line 3572
  ret_val = 0;
#line 3574
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1024);
  }
#line 3574
  if (tmp != 0) {
#line 3575
    ret_val = -16;
#line 3576
    goto out;
  } else {

  }
  {
#line 3579
  fw_cmd.hdr.cmd = 221U;
#line 3580
  fw_cmd.hdr.buf_len = 5U;
#line 3581
  fw_cmd.hdr.cmd_or_resp.cmd_resv = 0U;
#line 3582
  fw_cmd.port_num = (unsigned char )hw->bus.func;
#line 3583
  fw_cmd.ver_maj = maj;
#line 3584
  fw_cmd.ver_min = min;
#line 3585
  fw_cmd.ver_build = build;
#line 3586
  fw_cmd.ver_sub = sub;
#line 3587
  fw_cmd.hdr.checksum = 0U;
#line 3588
  fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)(& fw_cmd), (u32 )((int )fw_cmd.hdr.buf_len + 4));
#line 3590
  fw_cmd.pad = 0U;
#line 3591
  fw_cmd.pad2 = 0U;
#line 3593
  i = 0;
  }
#line 3593
  goto ldv_51775;
  ldv_51774: 
  {
#line 3594
  ret_val = ixgbe_host_interface_command(hw, (u32 *)(& fw_cmd), 12U);
  }
#line 3596
  if (ret_val != 0) {
#line 3597
    goto ldv_51772;
  } else {

  }
#line 3599
  if ((unsigned int )fw_cmd.hdr.cmd_or_resp.ret_status == 1U) {
#line 3601
    ret_val = 0;
  } else {
#line 3603
    ret_val = -33;
  }
#line 3605
  goto ldv_51773;
  ldv_51772: 
#line 3593
  i = i + 1;
  ldv_51775: ;
#line 3593
  if (i <= 3) {
#line 3595
    goto ldv_51774;
  } else {

  }
  ldv_51773: 
  {
#line 3608
  (*(hw->mac.ops.release_swfw_sync))(hw, 1024);
  }
  out: ;
#line 3610
  return (ret_val);
}
}
#line 3621 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
void ixgbe_clear_tx_pending(struct ixgbe_hw *hw ) 
{ 
  u32 gcr_ext ;
  u32 hlreg0 ;

  {
#line 3629
  if (((int )hw->mac.flags & 1) == 0) {
#line 3630
    return;
  } else {

  }
  {
#line 3637
  hlreg0 = ixgbe_read_reg(hw, 16960U);
#line 3638
  ixgbe_write_reg(hw, 16960U, hlreg0 | 32768U);
#line 3641
  gcr_ext = ixgbe_read_reg(hw, 69712U);
#line 3642
  ixgbe_write_reg(hw, 69712U, gcr_ext | 1073741824U);
#line 3646
  ixgbe_read_reg(hw, 8U);
#line 3647
  __const_udelay(85900UL);
#line 3650
  ixgbe_write_reg(hw, 69712U, gcr_ext);
#line 3651
  ixgbe_write_reg(hw, 16960U, hlreg0);
  }
#line 3652
  return;
}
}
#line 3654 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u8 const   ixgbe_emc_temp_data[4U]  = {      0U,      1U,      35U,      42U};
#line 3660 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static u8 const   ixgbe_emc_therm_limit[4U]  = {      32U,      25U,      26U,      48U};
#line 3675 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
static s32 ixgbe_get_ets_data(struct ixgbe_hw *hw , u16 *ets_cfg , u16 *ets_offset ) 
{ 
  s32 status ;

  {
  {
#line 3678
  status = 0;
#line 3680
  status = (*(hw->eeprom.ops.read))(hw, 38, ets_offset);
  }
#line 3681
  if (status != 0) {
#line 3682
    goto out;
  } else {

  }
#line 3684
  if ((unsigned int )*ets_offset - 1U > 65533U) {
#line 3685
    status = 2147483647;
#line 3686
    goto out;
  } else {

  }
  {
#line 3689
  status = (*(hw->eeprom.ops.read))(hw, (int )*ets_offset, ets_cfg);
  }
#line 3690
  if (status != 0) {
#line 3691
    goto out;
  } else {

  }
#line 3693
  if (((int )*ets_cfg & 56) != 0) {
#line 3694
    status = 2147483647;
#line 3695
    goto out;
  } else {

  }
  out: ;
#line 3699
  return (status);
}
}
#line 3708 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 ets_offset ;
  u16 ets_cfg ;
  u16 ets_sensor ;
  u8 num_sensors ;
  u8 i ;
  struct ixgbe_thermal_sensor_data *data ;
  u32 tmp ;
  u8 sensor_index ;
  u8 sensor_location ;

  {
  {
#line 3710
  status = 0;
#line 3716
  data = & hw->mac.thermal_sensor_data;
#line 3719
  tmp = ixgbe_read_reg(hw, 8U);
  }
#line 3719
  if ((tmp & 4U) != 0U) {
#line 3720
    status = 2147483647;
#line 3721
    goto out;
  } else {

  }
  {
#line 3724
  status = ixgbe_get_ets_data(hw, & ets_cfg, & ets_offset);
  }
#line 3725
  if (status != 0) {
#line 3726
    goto out;
  } else {

  }
#line 3728
  num_sensors = (unsigned int )((u8 )ets_cfg) & 7U;
#line 3729
  if ((unsigned int )num_sensors > 3U) {
#line 3730
    num_sensors = 3U;
  } else {

  }
#line 3732
  i = 0U;
#line 3732
  goto ldv_51804;
  ldv_51803: 
  {
#line 3736
  status = (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )((int )ets_offset + (int )((u16 )i)) + 1U),
                                    & ets_sensor);
  }
#line 3738
  if (status != 0) {
#line 3739
    goto out;
  } else {

  }
#line 3741
  sensor_index = (u8 )(((int )ets_sensor & 768) >> 8);
#line 3743
  sensor_location = (u8 )(((int )ets_sensor & 15360) >> 10);
#line 3746
  if ((unsigned int )sensor_location != 0U) {
    {
#line 3747
    status = (*(hw->phy.ops.read_i2c_byte))(hw, (int )ixgbe_emc_temp_data[(int )sensor_index],
                                            248, & data->sensor[(int )i].temp);
    }
#line 3751
    if (status != 0) {
#line 3752
      goto out;
    } else {

    }
  } else {

  }
#line 3732
  i = (u8 )((int )i + 1);
  ldv_51804: ;
#line 3732
  if ((int )i < (int )num_sensors) {
#line 3734
    goto ldv_51803;
  } else {

  }

  out: ;
#line 3756
  return (status);
}
}
#line 3766 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c"
s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 ets_offset ;
  u16 ets_cfg ;
  u16 ets_sensor ;
  u8 low_thresh_delta ;
  u8 num_sensors ;
  u8 therm_limit ;
  u8 i ;
  struct ixgbe_thermal_sensor_data *data ;
  u32 tmp ;
  u8 sensor_index ;
  u8 sensor_location ;
  s32 tmp___0 ;

  {
  {
#line 3768
  status = 0;
#line 3776
  data = & hw->mac.thermal_sensor_data;
#line 3778
  memset((void *)data, 0, 12UL);
#line 3781
  tmp = ixgbe_read_reg(hw, 8U);
  }
#line 3781
  if ((tmp & 4U) != 0U) {
#line 3782
    status = 2147483647;
#line 3783
    goto out;
  } else {

  }
  {
#line 3786
  status = ixgbe_get_ets_data(hw, & ets_cfg, & ets_offset);
  }
#line 3787
  if (status != 0) {
#line 3788
    goto out;
  } else {

  }
#line 3790
  low_thresh_delta = (u8 )(((int )ets_cfg & 1984) >> 6);
#line 3792
  num_sensors = (unsigned int )((u8 )ets_cfg) & 7U;
#line 3793
  if ((unsigned int )num_sensors > 3U) {
#line 3794
    num_sensors = 3U;
  } else {

  }
#line 3796
  i = 0U;
#line 3796
  goto ldv_51823;
  ldv_51822: 
  {
#line 3800
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )((int )ets_offset + (int )((u16 )i)) + 1U),
                                     & ets_sensor);
  }
#line 3800
  if (tmp___0 != 0) {
    {
#line 3801
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at offset %d failed\n", ((int )ets_offset + 1) + (int )i);
    }
#line 3803
    goto ldv_51821;
  } else {

  }
  {
#line 3805
  sensor_index = (u8 )(((int )ets_sensor & 768) >> 8);
#line 3807
  sensor_location = (u8 )(((int )ets_sensor & 15360) >> 10);
#line 3809
  therm_limit = (u8 )ets_sensor;
#line 3811
  (*(hw->phy.ops.write_i2c_byte))(hw, (int )ixgbe_emc_therm_limit[(int )sensor_index],
                                  248, (int )therm_limit);
  }
#line 3815
  if ((unsigned int )sensor_location == 0U) {
#line 3816
    goto ldv_51821;
  } else {

  }
#line 3818
  data->sensor[(int )i].location = sensor_location;
#line 3819
  data->sensor[(int )i].caution_thresh = therm_limit;
#line 3820
  data->sensor[(int )i].max_op_thresh = (int )therm_limit - (int )low_thresh_delta;
  ldv_51821: 
#line 3796
  i = (u8 )((int )i + 1);
  ldv_51823: ;
#line 3796
  if ((int )i < (int )num_sensors) {
#line 3798
    goto ldv_51822;
  } else {

  }

  out: ;
#line 3823
  return (status);
}
}
#line 1 "<compiler builtins>"
int __builtin_bswap32(int  ) ;
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void *ldv_kzalloc(size_t size , gfp_t flags ) ;
#line 597 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
__inline static void INIT_HLIST_NODE(struct hlist_node *h ) 
{ 


  {
#line 599
  h->next = (struct hlist_node *)0;
#line 600
  h->pprev = (struct hlist_node **)0;
#line 601
  return;
}
}
#line 637 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
__inline static void hlist_add_head(struct hlist_node *n , struct hlist_head *h ) 
{ 
  struct hlist_node *first ;

  {
#line 639
  first = h->first;
#line 640
  n->next = first;
#line 641
  if ((unsigned long )first != (unsigned long )((struct hlist_node *)0)) {
#line 642
    first->pprev = & n->next;
  } else {

  }
#line 643
  h->first = n;
#line 644
  n->pprev = & h->first;
#line 645
  return;
}
}
#line 657 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
__inline static void hlist_add_after(struct hlist_node *n , struct hlist_node *next ) 
{ 


  {
#line 660
  next->next = n->next;
#line 661
  n->next = next;
#line 662
  next->pprev = & n->next;
#line 664
  if ((unsigned long )next->next != (unsigned long )((struct hlist_node *)0)) {
#line 665
    (next->next)->pprev = & next->next;
  } else {

  }
#line 666
  return;
}
}
#line 57 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  int tmp ;

  {
  {
#line 60
  tmp = __builtin_bswap32(val);
  }
#line 60
  return ((__u32 )tmp);
}
}
#line 388 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/vmalloc.h"
extern void *vmalloc(unsigned long  ) ;
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pm_wakeup.h"
__inline static bool device_can_wakeup(struct device *dev ) 
{ 


  {
#line 74
  return ((int )dev->power.can_wakeup != 0);
}
}
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 441 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  {
#line 458
  tmp___2 = __kmalloc(size, flags);
  }
#line 458
  return (tmp___2);
}
}
#line 638
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-debug.h"
extern void debug_dma_sync_single_for_cpu(struct device * , dma_addr_t  , size_t  ,
                                          int  ) ;
#line 63
extern void debug_dma_sync_single_for_device(struct device * , dma_addr_t  , size_t  ,
                                             int  ) ;
#line 97 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_cpu(struct device *dev , dma_addr_t addr ,
                                             size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 101
  tmp = get_dma_ops(dev);
#line 101
  ops = tmp;
#line 103
  tmp___0 = valid_dma_direction((int )dir);
#line 103
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 103
  if (tmp___1 != 0L) {
    {
#line 103
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (103), "i" (12UL));
#line 103
    __builtin_unreachable();
    }
  } else {

  }
#line 104
  if ((unsigned long )ops->sync_single_for_cpu != (unsigned long )((void (*)(struct device * ,
                                                                             dma_addr_t  ,
                                                                             size_t  ,
                                                                             enum dma_data_direction  ))0)) {
    {
#line 105
    (*(ops->sync_single_for_cpu))(dev, addr, size, dir);
    }
  } else {

  }
  {
#line 106
  debug_dma_sync_single_for_cpu(dev, addr, size, (int )dir);
  }
#line 107
  return;
}
}
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_sync_single_for_device(struct device *dev , dma_addr_t addr ,
                                                size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 113
  tmp = get_dma_ops(dev);
#line 113
  ops = tmp;
#line 115
  tmp___0 = valid_dma_direction((int )dir);
#line 115
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 115
  if (tmp___1 != 0L) {
    {
#line 115
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (115), "i" (12UL));
#line 115
    __builtin_unreachable();
    }
  } else {

  }
#line 116
  if ((unsigned long )ops->sync_single_for_device != (unsigned long )((void (*)(struct device * ,
                                                                                dma_addr_t  ,
                                                                                size_t  ,
                                                                                enum dma_data_direction  ))0)) {
    {
#line 117
    (*(ops->sync_single_for_device))(dev, addr, size, dir);
    }
  } else {

  }
  {
#line 118
  debug_dma_sync_single_for_device(dev, addr, size, (int )dir);
  }
#line 119
  return;
}
}
#line 651 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
extern void kfree_skb(struct sk_buff * ) ;
#line 662
extern struct sk_buff *__alloc_skb(unsigned int  , gfp_t  , int  , int  ) ;
#line 665 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static struct sk_buff *alloc_skb(unsigned int size , gfp_t priority ) 
{ 
  struct sk_buff *tmp ;

  {
  {
#line 668
  tmp = __alloc_skb(size, priority, 0, -1);
  }
#line 668
  return (tmp);
}
}
#line 1494
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep , __u32 speed ) 
{ 


  {
#line 57
  ep->speed = (unsigned short )speed;
#line 58
  ep->speed_hi = (unsigned short )(speed >> 16);
#line 59
  return;
}
}
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd  const  *ep ) 
{ 


  {
#line 63
  return ((__u32 )(((int )ep->speed_hi << 16) | (int )ep->speed));
}
}
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ethtool.h"
extern u32 ethtool_op_get_link(struct net_device * ) ;
#line 66
extern int ethtool_op_get_ts_info(struct net_device * , struct ethtool_ts_info * ) ;
#line 1862 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
extern int dev_open(struct net_device * ) ;
#line 1863
extern int dev_close(struct net_device * ) ;
#line 2953
extern struct rtnl_link_stats64 *dev_get_stats(struct net_device * , struct rtnl_link_stats64 * ) ;
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/highmem.h"
__inline static void *kmap(struct page *page ) 
{ 
  void *tmp ;

  {
  {
#line 58
  __might_sleep("include/linux/highmem.h", 58, 0);
#line 59
  tmp = lowmem_page_address((struct page  const  *)page);
  }
#line 59
  return (tmp);
}
}
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/highmem.h"
__inline static void kunmap(struct page *page ) 
{ 


  {
#line 64
  return;
}
}
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/interrupt.h"
__inline static int ldv_request_irq_9(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                void * ) ,
                                      unsigned long flags , char const   *name , void *dev ) ;
#line 141
__inline static int ldv_request_irq_10(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 145
__inline static int ldv_request_irq_12(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 157
static void ldv_free_irq_11___0(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 157 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ptp_clock_kernel.h"
extern int ptp_clock_index(struct ptp_clock * ) ;
#line 882 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe.h"
s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input ,
                                          u16 soft_id ) ;
#line 885
void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input , union ixgbe_atr_input *input_mask ) ;
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_stats  const  ixgbe_gstrings_stats[57U]  = 
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
  {      {{'r', 'x', '_', 'p', 'a', 'c', 'k', 'e', 't', 's', '\000'}, 0, 8, 0}, 
        {{'t', 'x', '_', 'p', 'a', 'c', 'k', 'e', 't', 's', '\000'}, 0, 8, 8}, 
        {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 0, 8, 16}, 
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 0, 8, 24}, 
        {{'r', 'x', '_', 'p', 'k', 't', 's', '_', 'n', 'i', 'c', '\000'}, 1, 8, 38880}, 
        {{'t',
       'x', '_', 'p', 'k', 't', 's', '_', 'n', 'i', 'c', '\000'}, 1, 8, 38904}, 
        {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '_', 'n', 'i', 'c', '\000'}, 1, 8,
      38912}, 
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '_', 'n', 'i', 'c', '\000'}, 1, 8,
      38920}, 
        {{'l', 's', 'c', '_', 'i', 'n', 't', '\000'}, 1, 8, 1096}, 
        {{'t', 'x', '_', 'b', 'u', 's', 'y', '\000'}, 1, 8, 40184}, 
        {{'n', 'o', 'n', '_', 'e', 'o', 'p', '_', 'd', 'e', 's', 'c', 's', '\000'}, 1,
      8, 1664}, 
        {{'r', 'x', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 0, 8, 32}, 
        {{'t', 'x', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 0, 8, 40}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '\000'}, 0, 8, 48}, 
        {{'t', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '\000'}, 0, 8, 56}, 
        {{'m', 'u', 'l', 't', 'i', 'c', 'a', 's', 't', '\000'}, 0, 8, 64}, 
        {{'b', 'r', 'o', 'a', 'd', 'c', 'a', 's', 't', '\000'}, 1, 8, 38888}, 
        {{'r', 'x', '_', 'n', 'o', '_', 'b', 'u', 'f', 'f', 'e', 'r', '_', 'c', 'o',
       'u', 'n', 't', '\000'}, 1, 8, 38928}, 
        {{'c', 'o', 'l', 'l', 'i', 's', 'i', 'o', 'n', 's', '\000'}, 0, 8, 72}, 
        {{'r', 'x', '_', 'o', 'v', 'e', 'r', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'},
      0, 8, 88}, 
        {{'r', 'x', '_', 'c', 'r', 'c', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 0,
      8, 96}, 
        {{'r', 'x', '_', 'f', 'r', 'a', 'm', 'e', '_', 'e', 'r', 'r', 'o', 'r', 's',
       '\000'}, 0, 8, 104}, 
        {{'h', 'w', '_', 'r', 's', 'c', '_', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't',
       'e', 'd', '\000'}, 1, 8, 1648}, 
        {{'h', 'w', '_', 'r', 's', 'c', '_', 'f', 'l', 'u', 's', 'h', 'e', 'd', '\000'},
      1, 8, 1656}, 
        {{'f', 'd', 'i', 'r', '_', 'm', 'a', 't', 'c', 'h', '\000'}, 1, 8, 40072}, 
        {{'f', 'd', 'i', 'r', '_', 'm', 'i', 's', 's', '\000'}, 1, 8, 40080}, 
        {{'f', 'd', 'i', 'r', '_', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', '\000'}, 1,
      8, 40432}, 
        {{'r', 'x', '_', 'f', 'i', 'f', 'o', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'},
      0, 8, 112}, 
        {{'r', 'x', '_', 'm', 'i', 's', 's', 'e', 'd', '_', 'e', 'r', 'r', 'o', 'r',
       's', '\000'}, 0, 8, 120}, 
        {{'t', 'x', '_', 'a', 'b', 'o', 'r', 't', 'e', 'd', '_', 'e', 'r', 'r', 'o',
       'r', 's', '\000'}, 0, 8, 128}, 
        {{'t', 'x', '_', 'c', 'a', 'r', 'r', 'i', 'e', 'r', '_', 'e', 'r', 'r', 'o',
       'r', 's', '\000'}, 0, 8, 136}, 
        {{'t', 'x', '_', 'f', 'i', 'f', 'o', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'},
      0, 8, 144}, 
        {{'t', 'x', '_', 'h', 'e', 'a', 'r', 't', 'b', 'e', 'a', 't', '_', 'e', 'r',
       'r', 'o', 'r', 's', '\000'}, 0, 8, 152}, 
        {{'t', 'x', '_', 't', 'i', 'm', 'e', 'o', 'u', 't', '_', 'c', 'o', 'u', 'n',
       't', '\000'}, 1, 4, 1104}, 
        {{'t', 'x', '_', 'r', 'e', 's', 't', 'a', 'r', 't', '_', 'q', 'u', 'e', 'u',
       'e', '\000'}, 1, 8, 1088}, 
        {{'r', 'x', '_', 'l', 'o', 'n', 'g', '_', 'l', 'e', 'n', 'g', 't', 'h', '_',
       'e', 'r', 'r', 'o', 'r', 's', '\000'}, 1, 8, 39008}, 
        {{'r', 'x', '_', 's', 'h', 'o', 'r', 't', '_', 'l', 'e', 'n', 'g', 't', 'h',
       '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 1, 8, 38992}, 
        {{'t', 'x', '_', 'f', 'l', 'o', 'w', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l',
       '_', 'x', 'o', 'n', '\000'}, 1, 8, 38544}, 
        {{'r', 'x', '_', 'f', 'l', 'o', 'w', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l',
       '_', 'x', 'o', 'n', '\000'}, 1, 8, 38552}, 
        {{'t', 'x', '_', 'f', 'l', 'o', 'w', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l',
       '_', 'x', 'o', 'f', 'f', '\000'}, 1, 8, 38560}, 
        {{'r', 'x', '_', 'f', 'l', 'o', 'w', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l',
       '_', 'x', 'o', 'f', 'f', '\000'}, 1, 8, 38568}, 
        {{'r', 'x', '_', 'c', 's', 'u', 'm', '_', 'o', 'f', 'f', 'l', 'o', 'a', 'd',
       '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 1, 8, 1632}, 
        {{'a', 'l', 'l', 'o', 'c', '_', 'r', 'x', '_', 'p', 'a', 'g', 'e', '_', 'f',
       'a', 'i', 'l', 'e', 'd', '\000'}, 1, 4, 1672}, 
        {{'a', 'l', 'l', 'o', 'c', '_', 'r', 'x', '_', 'b', 'u', 'f', 'f', '_', 'f',
       'a', 'i', 'l', 'e', 'd', '\000'}, 1, 4, 1676}, 
        {{'r', 'x', '_', 'n', 'o', '_', 'd', 'm', 'a', '_', 'r', 'e', 's', 'o', 'u',
       'r', 'c', 'e', 's', '\000'}, 1, 8, 1640}, 
        {{'o', 's', '2', 'b', 'm', 'c', '_', 'r', 'x', '_', 'b', 'y', '_', 'b', 'm',
       'c', '\000'}, 1, 8, 40168}, 
        {{'o', 's', '2', 'b', 'm', 'c', '_', 't', 'x', '_', 'b', 'y', '_', 'b', 'm',
       'c', '\000'}, 1, 8, 40152}, 
        {{'o', 's', '2', 'b', 'm', 'c', '_', 't', 'x', '_', 'b', 'y', '_', 'h', 'o',
       's', 't', '\000'}, 1, 8, 40176}, 
        {{'o', 's', '2', 'b', 'm', 'c', '_', 'r', 'x', '_', 'b', 'y', '_', 'h', 'o',
       's', 't', '\000'}, 1, 8, 40160}, 
        {{'f', 'c', 'o', 'e', '_', 'b', 'a', 'd', '_', 'f', 'c', 'c', 'r', 'c', '\000'},
      1, 8, 40088}, 
        {{'r', 'x', '_', 'f', 'c', 'o', 'e', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd',
       '\000'}, 1, 8, 40096}, 
        {{'r', 'x', '_', 'f', 'c', 'o', 'e', '_', 'p', 'a', 'c', 'k', 'e', 't', 's',
       '\000'}, 1, 8, 40104}, 
        {{'r', 'x', '_', 'f', 'c', 'o', 'e', '_', 'd', 'w', 'o', 'r', 'd', 's', '\000'},
      1, 8, 40120}, 
        {{'f', 'c', 'o', 'e', '_', 'n', 'o', 'd', 'd', 'p', '\000'}, 1, 8, 40136}, 
        {{'f', 'c', 'o', 'e', '_', 'n', 'o', 'd', 'd', 'p', '_', 'e', 'x', 't', '_',
       'b', 'u', 'f', 'f', '\000'}, 1, 8, 40144}, 
        {{'t', 'x', '_', 'f', 'c', 'o', 'e', '_', 'p', 'a', 'c', 'k', 'e', 't', 's',
       '\000'}, 1, 8, 40112}, 
        {{'t', 'x', '_', 'f', 'c', 'o', 'e', '_', 'd', 'w', 'o', 'r', 'd', 's', '\000'},
      1, 8, 40128}};
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static char const   ixgbe_gstrings_test[5U][32U]  = { {        'R',        'e',        'g',        'i', 
            's',        't',        'e',        'r', 
            ' ',        't',        'e',        's', 
            't',        ' ',        ' ',        '(', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}, 
   {        'E',        'e',        'p',        'r', 
            'o',        'm',        ' ',        't', 
            'e',        's',        't',        ' ', 
            ' ',        ' ',        ' ',        '(', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}, 
   {        'I',        'n',        't',        'e', 
            'r',        'r',        'u',        'p', 
            't',        ' ',        't',        'e', 
            's',        't',        ' ',        '(', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}, 
   {        'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        ' ',        ' ',        '(', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}, 
   {        'L',        'i',        'n',        'k', 
            ' ',        't',        'e',        's', 
            't',        ' ',        ' ',        ' ', 
            '(',        'o',        'n',        '/', 
            'o',        'f',        'f',        'l', 
            'i',        'n',        'e',        ')', 
            '\000'}};
#line 153 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_settings(struct net_device *netdev , struct ethtool_cmd *ecmd ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  ixgbe_link_speed supported_link ;
  u32 link_speed ;
  bool autoneg ;
  bool link_up ;

  {
  {
#line 156
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 156
  adapter = (struct ixgbe_adapter *)tmp;
#line 157
  hw = & adapter->hw;
#line 159
  link_speed = 0U;
#line 160
  autoneg = 0;
  }
#line 164
  if (((unsigned int )hw->phy.media_type & 3U) != 0U) {
#line 166
    if ((unsigned int )hw->phy.sfp_type == 65534U) {
      {
#line 167
      (*(hw->phy.ops.identify_sfp))(hw);
      }
    } else {

    }
  } else {

  }
  {
#line 170
  (*(hw->mac.ops.get_link_capabilities))(hw, & supported_link, & autoneg);
  }
#line 173
  if ((supported_link & 128U) != 0U) {
#line 174
    ecmd->supported = ecmd->supported | 4096U;
  } else {

  }
#line 175
  if ((supported_link & 32U) != 0U) {
#line 176
    ecmd->supported = ecmd->supported | 32U;
  } else {

  }
#line 177
  if ((supported_link & 8U) != 0U) {
#line 178
    ecmd->supported = ecmd->supported | 8U;
  } else {

  }
#line 181
  if (hw->phy.autoneg_advertised != 0U) {
#line 182
    if ((hw->phy.autoneg_advertised & 8U) != 0U) {
#line 183
      ecmd->advertising = ecmd->advertising | 8U;
    } else {

    }
#line 184
    if ((hw->phy.autoneg_advertised & 128U) != 0U) {
#line 185
      ecmd->advertising = ecmd->advertising | 4096U;
    } else {

    }
#line 186
    if ((hw->phy.autoneg_advertised & 32U) != 0U) {
#line 187
      ecmd->advertising = ecmd->advertising | 32U;
    } else {

    }
  } else {
#line 190
    if ((supported_link & 128U) != 0U) {
#line 191
      ecmd->advertising = ecmd->advertising | 4096U;
    } else {

    }
#line 192
    if ((supported_link & 32U) != 0U) {
#line 193
      ecmd->advertising = ecmd->advertising | 32U;
    } else {

    }
#line 194
    if ((supported_link & 8U) != 0U) {
#line 195
      ecmd->advertising = ecmd->advertising | 8U;
    } else {

    }
#line 197
    if ((int )hw->phy.multispeed_fiber && ! autoneg) {
#line 198
      if ((supported_link & 128U) != 0U) {
#line 199
        ecmd->advertising = 4096U;
      } else {

      }
    } else {

    }
  }
#line 203
  if ((int )autoneg) {
#line 204
    ecmd->supported = ecmd->supported | 64U;
#line 205
    ecmd->advertising = ecmd->advertising | 64U;
#line 206
    ecmd->autoneg = 1U;
  } else {
#line 208
    ecmd->autoneg = 0U;
  }
#line 210
  ecmd->transceiver = 1U;
  {
#line 214
  if ((unsigned int )adapter->hw.phy.type == 2U) {
#line 214
    goto case_2;
  } else {

  }
#line 215
  if ((unsigned int )adapter->hw.phy.type == 3U) {
#line 215
    goto case_3;
  } else {

  }
#line 216
  if ((unsigned int )adapter->hw.phy.type == 4U) {
#line 216
    goto case_4;
  } else {

  }
#line 221
  if ((unsigned int )adapter->hw.phy.type == 5U) {
#line 221
    goto case_5;
  } else {

  }
#line 226
  if ((unsigned int )adapter->hw.phy.type == 7U) {
#line 226
    goto case_7;
  } else {

  }
#line 227
  if ((unsigned int )adapter->hw.phy.type == 8U) {
#line 227
    goto case_8;
  } else {

  }
#line 228
  if ((unsigned int )adapter->hw.phy.type == 9U) {
#line 228
    goto case_9;
  } else {

  }
#line 229
  if ((unsigned int )adapter->hw.phy.type == 12U) {
#line 229
    goto case_12;
  } else {

  }
#line 230
  if ((unsigned int )adapter->hw.phy.type == 11U) {
#line 230
    goto case_11;
  } else {

  }
#line 231
  if ((unsigned int )adapter->hw.phy.type == 15U) {
#line 231
    goto case_15;
  } else {

  }
#line 232
  if ((unsigned int )adapter->hw.phy.type == 14U) {
#line 232
    goto case_14;
  } else {

  }
#line 273
  if ((unsigned int )adapter->hw.phy.type == 6U) {
#line 273
    goto case_6___0;
  } else {

  }
#line 278
  if ((unsigned int )adapter->hw.phy.type == 0U) {
#line 278
    goto case_0___0;
  } else {

  }
#line 279
  if ((unsigned int )adapter->hw.phy.type == 21U) {
#line 279
    goto case_21;
  } else {

  }
#line 280
  if ((unsigned int )adapter->hw.phy.type == 20U) {
#line 280
    goto case_20;
  } else {

  }
#line 281
  goto switch_default___0;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
  case_4: /* CIL Label */ 
#line 217
  ecmd->supported = ecmd->supported | 128U;
#line 218
  ecmd->advertising = ecmd->advertising | 128U;
#line 219
  ecmd->port = 0U;
#line 220
  goto ldv_52061;
  case_5: /* CIL Label */ 
#line 222
  ecmd->supported = ecmd->supported | 1024U;
#line 223
  ecmd->advertising = ecmd->advertising | 1024U;
#line 224
  ecmd->port = 3U;
#line 225
  goto ldv_52061;
  case_7: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_12: /* CIL Label */ ;
  case_11: /* CIL Label */ ;
  case_15: /* CIL Label */ ;
  case_14: /* CIL Label */ ;
  {
#line 235
  if ((unsigned int )adapter->hw.phy.sfp_type == 0U) {
#line 235
    goto case_0;
  } else {

  }
#line 236
  if ((unsigned int )adapter->hw.phy.sfp_type == 3U) {
#line 236
    goto case_3___0;
  } else {

  }
#line 237
  if ((unsigned int )adapter->hw.phy.sfp_type == 4U) {
#line 237
    goto case_4___0;
  } else {

  }
#line 242
  if ((unsigned int )adapter->hw.phy.sfp_type == 1U) {
#line 242
    goto case_1;
  } else {

  }
#line 243
  if ((unsigned int )adapter->hw.phy.sfp_type == 2U) {
#line 243
    goto case_2___0;
  } else {

  }
#line 244
  if ((unsigned int )adapter->hw.phy.sfp_type == 5U) {
#line 244
    goto case_5___0;
  } else {

  }
#line 245
  if ((unsigned int )adapter->hw.phy.sfp_type == 6U) {
#line 245
    goto case_6;
  } else {

  }
#line 246
  if ((unsigned int )adapter->hw.phy.sfp_type == 11U) {
#line 246
    goto case_11___0;
  } else {

  }
#line 247
  if ((unsigned int )adapter->hw.phy.sfp_type == 12U) {
#line 247
    goto case_12___0;
  } else {

  }
#line 248
  if ((unsigned int )adapter->hw.phy.sfp_type == 13U) {
#line 248
    goto case_13;
  } else {

  }
#line 249
  if ((unsigned int )adapter->hw.phy.sfp_type == 14U) {
#line 249
    goto case_14___0;
  } else {

  }
#line 254
  if ((unsigned int )adapter->hw.phy.sfp_type == 65534U) {
#line 254
    goto case_65534;
  } else {

  }
#line 259
  if ((unsigned int )adapter->hw.phy.sfp_type == 9U) {
#line 259
    goto case_9___0;
  } else {

  }
#line 260
  if ((unsigned int )adapter->hw.phy.sfp_type == 10U) {
#line 260
    goto case_10;
  } else {

  }
#line 265
  if ((unsigned int )adapter->hw.phy.sfp_type == 65535U) {
#line 265
    goto case_65535;
  } else {

  }
#line 266
  goto switch_default;
  case_0: /* CIL Label */ ;
  case_3___0: /* CIL Label */ ;
  case_4___0: /* CIL Label */ 
#line 238
  ecmd->supported = ecmd->supported | 1024U;
#line 239
  ecmd->advertising = ecmd->advertising | 1024U;
#line 240
  ecmd->port = 5U;
#line 241
  goto ldv_52073;
  case_1: /* CIL Label */ ;
  case_2___0: /* CIL Label */ ;
  case_5___0: /* CIL Label */ ;
  case_6: /* CIL Label */ ;
  case_11___0: /* CIL Label */ ;
  case_12___0: /* CIL Label */ ;
  case_13: /* CIL Label */ ;
  case_14___0: /* CIL Label */ 
#line 250
  ecmd->supported = ecmd->supported | 1024U;
#line 251
  ecmd->advertising = ecmd->advertising | 1024U;
#line 252
  ecmd->port = 3U;
#line 253
  goto ldv_52073;
  case_65534: /* CIL Label */ 
#line 255
  ecmd->supported = ecmd->supported | 1024U;
#line 256
  ecmd->advertising = ecmd->advertising | 1024U;
#line 257
  ecmd->port = 239U;
#line 258
  goto ldv_52073;
  case_9___0: /* CIL Label */ ;
  case_10: /* CIL Label */ 
#line 261
  ecmd->supported = ecmd->supported | 128U;
#line 262
  ecmd->advertising = ecmd->advertising | 128U;
#line 263
  ecmd->port = 0U;
#line 264
  goto ldv_52073;
  case_65535: /* CIL Label */ ;
  switch_default: /* CIL Label */ 
#line 267
  ecmd->supported = ecmd->supported | 1024U;
#line 268
  ecmd->advertising = ecmd->advertising | 1024U;
#line 269
  ecmd->port = 255U;
#line 270
  goto ldv_52073;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_52073: ;
#line 272
  goto ldv_52061;
  case_6___0: /* CIL Label */ 
#line 274
  ecmd->supported = ecmd->supported | 1024U;
#line 275
  ecmd->advertising = ecmd->advertising | 1024U;
#line 276
  ecmd->port = 239U;
#line 277
  goto ldv_52061;
  case_0___0: /* CIL Label */ ;
  case_21: /* CIL Label */ ;
  case_20: /* CIL Label */ ;
  switch_default___0: /* CIL Label */ 
#line 282
  ecmd->supported = ecmd->supported | 1024U;
#line 283
  ecmd->advertising = ecmd->advertising | 1024U;
#line 284
  ecmd->port = 255U;
#line 285
  goto ldv_52061;
  switch_break: /* CIL Label */ ;
  }
  ldv_52061: 
  {
#line 288
  (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
  }
#line 289
  if ((int )link_up) {
    {
#line 291
    if (link_speed == 128U) {
#line 291
      goto case_128;
    } else {

    }
#line 294
    if (link_speed == 32U) {
#line 294
      goto case_32;
    } else {

    }
#line 297
    if (link_speed == 8U) {
#line 297
      goto case_8___0;
    } else {

    }
#line 300
    goto switch_default___1;
    case_128: /* CIL Label */ 
    {
#line 292
    ethtool_cmd_speed_set(ecmd, 10000U);
    }
#line 293
    goto ldv_52093;
    case_32: /* CIL Label */ 
    {
#line 295
    ethtool_cmd_speed_set(ecmd, 1000U);
    }
#line 296
    goto ldv_52093;
    case_8___0: /* CIL Label */ 
    {
#line 298
    ethtool_cmd_speed_set(ecmd, 100U);
    }
#line 299
    goto ldv_52093;
    switch_default___1: /* CIL Label */ ;
#line 301
    goto ldv_52093;
    switch_break___1: /* CIL Label */ ;
    }
    ldv_52093: 
#line 303
    ecmd->duplex = 1U;
  } else {
    {
#line 305
    ethtool_cmd_speed_set(ecmd, 4294967295U);
#line 306
    ecmd->duplex = 255U;
    }
  }
#line 309
  return (0);
}
}
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_settings(struct net_device *netdev , struct ethtool_cmd *ecmd ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u32 advertised ;
  u32 old ;
  s32 err ;
  u32 speed ;
  __u32 tmp___0 ;

  {
  {
#line 315
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 315
  adapter = (struct ixgbe_adapter *)tmp;
#line 316
  hw = & adapter->hw;
#line 318
  err = 0;
  }
#line 320
  if ((unsigned int )hw->phy.media_type == 5U || (int )hw->phy.multispeed_fiber) {
#line 326
    if ((ecmd->advertising & ~ ecmd->supported) != 0U) {
#line 327
      return (-22);
    } else {

    }
#line 330
    if ((unsigned int )ecmd->autoneg == 0U && (int )hw->phy.multispeed_fiber) {
#line 331
      if (ecmd->advertising == 4128U) {
#line 334
        return (-22);
      } else {

      }
    } else {

    }
#line 337
    old = hw->phy.autoneg_advertised;
#line 338
    advertised = 0U;
#line 339
    if ((ecmd->advertising & 4096U) != 0U) {
#line 340
      advertised = advertised | 128U;
    } else {

    }
#line 342
    if ((ecmd->advertising & 32U) != 0U) {
#line 343
      advertised = advertised | 32U;
    } else {

    }
#line 345
    if ((ecmd->advertising & 8U) != 0U) {
#line 346
      advertised = advertised | 8U;
    } else {

    }
#line 348
    if (old == advertised) {
#line 349
      return (err);
    } else {

    }
    {
#line 351
    hw->mac.autotry_restart = 1;
#line 352
    err = (*(hw->mac.ops.setup_link))(hw, advertised, 1);
    }
#line 353
    if (err != 0) {
#line 354
      if (((int )adapter->msg_enable & 2) != 0) {
        {
#line 354
        netdev_info((struct net_device  const  *)adapter->netdev, "setup link failed with code %d\n",
                    err);
        }
      } else {

      }
      {
#line 355
      (*(hw->mac.ops.setup_link))(hw, old, 1);
      }
    } else {

    }
  } else {
    {
#line 359
    tmp___0 = ethtool_cmd_speed((struct ethtool_cmd  const  *)ecmd);
#line 359
    speed = tmp___0;
    }
#line 360
    if (((unsigned int )ecmd->autoneg == 1U || ecmd->advertising != 4096U) || speed + (u32 )ecmd->duplex != 10001U) {
#line 363
      return (-22);
    } else {

    }
  }
#line 366
  return (err);
}
}
#line 369 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *pause ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  bool tmp___0 ;

  {
  {
#line 372
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 372
  adapter = (struct ixgbe_adapter *)tmp;
#line 373
  hw = & adapter->hw;
#line 375
  tmp___0 = ixgbe_device_supports_autoneg_fc(hw);
  }
#line 375
  if ((int )tmp___0 && ! hw->fc.disable_fc_autoneg) {
#line 377
    pause->autoneg = 1U;
  } else {
#line 379
    pause->autoneg = 0U;
  }
#line 381
  if ((unsigned int )hw->fc.current_mode == 1U) {
#line 382
    pause->rx_pause = 1U;
  } else
#line 383
  if ((unsigned int )hw->fc.current_mode == 2U) {
#line 384
    pause->tx_pause = 1U;
  } else
#line 385
  if ((unsigned int )hw->fc.current_mode == 3U) {
#line 386
    pause->rx_pause = 1U;
#line 387
    pause->tx_pause = 1U;
  } else {

  }
#line 389
  return;
}
}
#line 391 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *pause ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  struct ixgbe_fc_info fc ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
  {
#line 394
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 394
  adapter = (struct ixgbe_adapter *)tmp;
#line 395
  hw = & adapter->hw;
#line 396
  fc = hw->fc;
  }
#line 399
  if ((unsigned int )hw->mac.type == 1U && (adapter->flags & 4096U) != 0U) {
#line 401
    return (-22);
  } else {

  }
#line 404
  if (pause->autoneg == 1U) {
    {
#line 404
    tmp___0 = ixgbe_device_supports_autoneg_fc(hw);
    }
#line 404
    if (tmp___0) {
#line 404
      tmp___1 = 0;
    } else {
#line 404
      tmp___1 = 1;
    }
#line 404
    if (tmp___1) {
#line 406
      return (-22);
    } else {

    }
  } else {

  }
#line 408
  fc.disable_fc_autoneg = pause->autoneg != 1U;
#line 410
  if ((pause->rx_pause != 0U && pause->tx_pause != 0U) || pause->autoneg != 0U) {
#line 411
    fc.requested_mode = 3;
  } else
#line 412
  if (pause->rx_pause != 0U && pause->tx_pause == 0U) {
#line 413
    fc.requested_mode = 1;
  } else
#line 414
  if (pause->rx_pause == 0U && pause->tx_pause != 0U) {
#line 415
    fc.requested_mode = 2;
  } else {
#line 417
    fc.requested_mode = 0;
  }
  {
#line 420
  tmp___3 = memcmp((void const   *)(& fc), (void const   *)(& hw->fc), 52UL);
  }
#line 420
  if (tmp___3 != 0) {
    {
#line 421
    hw->fc = fc;
#line 422
    tmp___2 = netif_running((struct net_device  const  *)netdev);
    }
#line 422
    if ((int )tmp___2) {
      {
#line 423
      ixgbe_reinit_locked(adapter);
      }
    } else {
      {
#line 425
      ixgbe_reset(adapter);
      }
    }
  } else {

  }
#line 428
  return (0);
}
}
#line 431 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u32 ixgbe_get_msglevel(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 433
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 433
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 434
  return ((u32 )adapter->msg_enable);
}
}
#line 437 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_set_msglevel(struct net_device *netdev , u32 data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 439
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 439
  adapter = (struct ixgbe_adapter *)tmp;
#line 440
  adapter->msg_enable = (u16 )data;
  }
#line 441
  return;
}
}
#line 443 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_regs_len(struct net_device *netdev ) 
{ 


  {
#line 446
  return (4556);
}
}
#line 451 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_regs(struct net_device *netdev , struct ethtool_regs *regs ,
                           void *p ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u32 *regs_buff ;
  u8 i ;

  {
  {
#line 454
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 454
  adapter = (struct ixgbe_adapter *)tmp;
#line 455
  hw = & adapter->hw;
#line 456
  regs_buff = (u32 *)p;
#line 459
  memset(p, 0, 4556UL);
#line 461
  regs->version = (((unsigned int )hw->mac.type << 24) | (unsigned int )((int )hw->revision_id << 16)) | (unsigned int )hw->device_id;
#line 465
  *regs_buff = ixgbe_read_reg(hw, 0U);
#line 466
  *(regs_buff + 1UL) = ixgbe_read_reg(hw, 8U);
#line 467
  *(regs_buff + 2UL) = ixgbe_read_reg(hw, 24U);
#line 468
  *(regs_buff + 3UL) = ixgbe_read_reg(hw, 32U);
#line 469
  *(regs_buff + 4UL) = ixgbe_read_reg(hw, 40U);
#line 470
  *(regs_buff + 5UL) = ixgbe_read_reg(hw, 512U);
#line 471
  *(regs_buff + 6UL) = ixgbe_read_reg(hw, 72U);
#line 472
  *(regs_buff + 7UL) = ixgbe_read_reg(hw, 76U);
#line 475
  *(regs_buff + 8UL) = ixgbe_read_reg(hw, 65552U);
#line 476
  *(regs_buff + 9UL) = ixgbe_read_reg(hw, 65556U);
#line 477
  *(regs_buff + 10UL) = ixgbe_read_reg(hw, 65564U);
#line 478
  *(regs_buff + 11UL) = ixgbe_read_reg(hw, 65808U);
#line 479
  *(regs_buff + 12UL) = ixgbe_read_reg(hw, 65812U);
#line 480
  *(regs_buff + 13UL) = ixgbe_read_reg(hw, 65816U);
#line 481
  *(regs_buff + 14UL) = ixgbe_read_reg(hw, 65820U);
#line 482
  *(regs_buff + 15UL) = ixgbe_read_reg(hw, 65824U);
#line 483
  *(regs_buff + 16UL) = ixgbe_read_reg(hw, 65852U);
#line 484
  *(regs_buff + 17UL) = ixgbe_read_reg(hw, 66048U);
#line 489
  *(regs_buff + 18UL) = ixgbe_read_reg(hw, 2056U);
#line 490
  *(regs_buff + 19UL) = ixgbe_read_reg(hw, 2056U);
#line 491
  *(regs_buff + 20UL) = ixgbe_read_reg(hw, 2176U);
#line 492
  *(regs_buff + 21UL) = ixgbe_read_reg(hw, 2184U);
#line 493
  *(regs_buff + 22UL) = ixgbe_read_reg(hw, 2064U);
#line 494
  *(regs_buff + 23UL) = ixgbe_read_reg(hw, 2192U);
#line 495
  *(regs_buff + 24UL) = ixgbe_read_reg(hw, 2080U);
#line 496
  *(regs_buff + 25UL) = ixgbe_read_reg(hw, 2304U);
#line 497
  *(regs_buff + 26UL) = ixgbe_read_reg(hw, 0U);
#line 498
  *(regs_buff + 27UL) = ixgbe_read_reg(hw, 8192U);
#line 499
  *(regs_buff + 28UL) = ixgbe_read_reg(hw, 69736U);
#line 500
  *(regs_buff + 29UL) = ixgbe_read_reg(hw, 2200U);
#line 503
  *(regs_buff + 30UL) = ixgbe_read_reg(hw, 12296U);
#line 504
  *(regs_buff + 31UL) = ixgbe_read_reg(hw, 12800U);
#line 505
  *(regs_buff + 32UL) = ixgbe_read_reg(hw, 12804U);
#line 506
  *(regs_buff + 33UL) = ixgbe_read_reg(hw, 12808U);
#line 507
  *(regs_buff + 34UL) = ixgbe_read_reg(hw, 12812U);
#line 508
  i = 0U;
  }
#line 508
  goto ldv_52147;
  ldv_52146: ;
  {
#line 510
  if ((unsigned int )hw->mac.type == 1U) {
#line 510
    goto case_1;
  } else {

  }
#line 514
  if ((unsigned int )hw->mac.type == 2U) {
#line 514
    goto case_2;
  } else {

  }
#line 515
  if ((unsigned int )hw->mac.type == 3U) {
#line 515
    goto case_3;
  } else {

  }
#line 519
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 511
  *(regs_buff + (unsigned long )((int )i + 35)) = ixgbe_read_reg(hw, (u32 )(((int )i + 1604) * 8));
#line 512
  *(regs_buff + (unsigned long )((int )i + 43)) = ixgbe_read_reg(hw, (u32 )(((int )i + 1612) * 8));
  }
#line 513
  goto ldv_52142;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 516
  *(regs_buff + (unsigned long )((int )i + 35)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3208) * 4));
#line 517
  *(regs_buff + (unsigned long )((int )i + 43)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3224) * 4));
  }
#line 518
  goto ldv_52142;
  switch_default: /* CIL Label */ ;
#line 520
  goto ldv_52142;
  switch_break: /* CIL Label */ ;
  }
  ldv_52142: 
#line 508
  i = (u8 )((int )i + 1);
  ldv_52147: ;
#line 508
  if ((unsigned int )i <= 7U) {
#line 510
    goto ldv_52146;
  } else {

  }
  {
#line 523
  *(regs_buff + 51UL) = ixgbe_read_reg(hw, 12960U);
#line 524
  *(regs_buff + 52UL) = ixgbe_read_reg(hw, 52736U);
#line 527
  i = 0U;
  }
#line 527
  goto ldv_52150;
  ldv_52149: 
  {
#line 528
  *(regs_buff + (unsigned long )((int )i + 53)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? ((int )i + 64) * 64 : ((int )i + 768) * 64));
#line 527
  i = (u8 )((int )i + 1);
  }
  ldv_52150: ;
#line 527
  if ((unsigned int )i <= 63U) {
#line 529
    goto ldv_52149;
  } else {

  }
#line 529
  i = 0U;
#line 529
  goto ldv_52153;
  ldv_52152: 
  {
#line 530
  *(regs_buff + (unsigned long )((int )i + 117)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4100 : ((int )i + -64) * 64 + 53252));
#line 529
  i = (u8 )((int )i + 1);
  }
  ldv_52153: ;
#line 529
  if ((unsigned int )i <= 63U) {
#line 531
    goto ldv_52152;
  } else {

  }
#line 531
  i = 0U;
#line 531
  goto ldv_52156;
  ldv_52155: 
  {
#line 532
  *(regs_buff + (unsigned long )((int )i + 181)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4104 : ((int )i + -64) * 64 + 53256));
#line 531
  i = (u8 )((int )i + 1);
  }
  ldv_52156: ;
#line 531
  if ((unsigned int )i <= 63U) {
#line 533
    goto ldv_52155;
  } else {

  }
#line 533
  i = 0U;
#line 533
  goto ldv_52159;
  ldv_52158: 
  {
#line 534
  *(regs_buff + (unsigned long )((int )i + 245)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4112 : ((int )i + -64) * 64 + 53264));
#line 533
  i = (u8 )((int )i + 1);
  }
  ldv_52159: ;
#line 533
  if ((unsigned int )i <= 63U) {
#line 535
    goto ldv_52158;
  } else {

  }
#line 535
  i = 0U;
#line 535
  goto ldv_52162;
  ldv_52161: 
  {
#line 536
  *(regs_buff + (unsigned long )((int )i + 309)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4120 : ((int )i + -64) * 64 + 53272));
#line 535
  i = (u8 )((int )i + 1);
  }
  ldv_52162: ;
#line 535
  if ((unsigned int )i <= 63U) {
#line 537
    goto ldv_52161;
  } else {

  }
#line 537
  i = 0U;
#line 537
  goto ldv_52165;
  ldv_52164: 
  {
#line 538
  *(regs_buff + (unsigned long )((int )i + 373)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 63U ? (int )i * 64 + 4136 : ((int )i + -64) * 64 + 53288));
#line 537
  i = (u8 )((int )i + 1);
  }
  ldv_52165: ;
#line 537
  if ((unsigned int )i <= 63U) {
#line 539
    goto ldv_52164;
  } else {

  }
#line 539
  i = 0U;
#line 539
  goto ldv_52168;
  ldv_52167: 
  {
#line 540
  *(regs_buff + (unsigned long )((int )i + 437)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 15U ? ((int )i + 2112) * 4 : ((unsigned int )i <= 63U ? (int )i * 64 + 4116 : ((int )i + -64) * 64 + 53268)));
#line 539
  i = (u8 )((int )i + 1);
  }
  ldv_52168: ;
#line 539
  if ((unsigned int )i <= 15U) {
#line 541
    goto ldv_52167;
  } else {

  }
#line 541
  i = 0U;
#line 541
  goto ldv_52171;
  ldv_52170: 
  {
#line 542
  *(regs_buff + (unsigned long )((int )i + 453)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 15U ? ((int )i + 2176) * 4 : ((unsigned int )i <= 63U ? (int )i * 64 + 4108 : ((int )i + -64) * 64 + 53260)));
#line 541
  i = (u8 )((int )i + 1);
  }
  ldv_52171: ;
#line 541
  if ((unsigned int )i <= 15U) {
#line 543
    goto ldv_52170;
  } else {

  }
  {
#line 543
  *(regs_buff + 469UL) = ixgbe_read_reg(hw, 12032U);
#line 544
  i = 0U;
  }
#line 544
  goto ldv_52174;
  ldv_52173: 
  {
#line 545
  *(regs_buff + (unsigned long )((int )i + 470)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3840) * 4));
#line 544
  i = (u8 )((int )i + 1);
  }
  ldv_52174: ;
#line 544
  if ((unsigned int )i <= 7U) {
#line 546
    goto ldv_52173;
  } else {

  }
  {
#line 546
  *(regs_buff + 478UL) = ixgbe_read_reg(hw, 12288U);
#line 547
  *(regs_buff + 479UL) = ixgbe_read_reg(hw, 15620U);
#line 550
  *(regs_buff + 480UL) = ixgbe_read_reg(hw, 20480U);
#line 551
  *(regs_buff + 481UL) = ixgbe_read_reg(hw, 20488U);
#line 552
  i = 0U;
  }
#line 552
  goto ldv_52177;
  ldv_52176: 
  {
#line 553
  *(regs_buff + (unsigned long )((int )i + 482)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 15U ? ((int )i + 2688) * 8 : ((int )i + 5184) * 8));
#line 552
  i = (u8 )((int )i + 1);
  }
  ldv_52177: ;
#line 552
  if ((unsigned int )i <= 15U) {
#line 554
    goto ldv_52176;
  } else {

  }
#line 554
  i = 0U;
#line 554
  goto ldv_52180;
  ldv_52179: 
  {
#line 555
  *(regs_buff + (unsigned long )((int )i + 498)) = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 15U ? (int )i * 8 + 21508 : (int )i * 8 + 41476));
#line 554
  i = (u8 )((int )i + 1);
  }
  ldv_52180: ;
#line 554
  if ((unsigned int )i <= 15U) {
#line 556
    goto ldv_52179;
  } else {

  }
  {
#line 556
  *(regs_buff + 514UL) = ixgbe_read_reg(hw, 21632U);
#line 557
  *(regs_buff + 515UL) = ixgbe_read_reg(hw, 20608U);
#line 558
  *(regs_buff + 516UL) = ixgbe_read_reg(hw, 20616U);
#line 559
  *(regs_buff + 517UL) = ixgbe_read_reg(hw, 20624U);
#line 560
  *(regs_buff + 518UL) = ixgbe_read_reg(hw, 22552U);
#line 561
  *(regs_buff + 519UL) = ixgbe_read_reg(hw, 22556U);
#line 562
  i = 0U;
  }
#line 562
  goto ldv_52183;
  ldv_52182: 
  {
#line 563
  *(regs_buff + (unsigned long )((int )i + 520)) = ixgbe_read_reg(hw, (u32 )(((int )i + 5792) * 4));
#line 562
  i = (u8 )((int )i + 1);
  }
  ldv_52183: ;
#line 562
  if ((unsigned int )i <= 7U) {
#line 564
    goto ldv_52182;
  } else {

  }
#line 564
  i = 0U;
#line 564
  goto ldv_52186;
  ldv_52185: 
  {
#line 565
  *(regs_buff + (unsigned long )((int )i + 528)) = ixgbe_read_reg(hw, (u32 )(((int )i + 5800) * 4));
#line 564
  i = (u8 )((int )i + 1);
  }
  ldv_52186: ;
#line 564
  if ((unsigned int )i <= 7U) {
#line 566
    goto ldv_52185;
  } else {

  }
  {
#line 566
  *(regs_buff + 536UL) = ixgbe_read_reg(hw, 23232U);
#line 569
  i = 0U;
  }
#line 569
  goto ldv_52189;
  ldv_52188: 
  {
#line 570
  *(regs_buff + (unsigned long )((int )i + 537)) = ixgbe_read_reg(hw, (u32 )(((int )i + 384) * 64));
#line 569
  i = (u8 )((int )i + 1);
  }
  ldv_52189: ;
#line 569
  if ((unsigned int )i <= 31U) {
#line 571
    goto ldv_52188;
  } else {

  }
#line 571
  i = 0U;
#line 571
  goto ldv_52192;
  ldv_52191: 
  {
#line 572
  *(regs_buff + (unsigned long )((int )i + 569)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24580));
#line 571
  i = (u8 )((int )i + 1);
  }
  ldv_52192: ;
#line 571
  if ((unsigned int )i <= 31U) {
#line 573
    goto ldv_52191;
  } else {

  }
#line 573
  i = 0U;
#line 573
  goto ldv_52195;
  ldv_52194: 
  {
#line 574
  *(regs_buff + (unsigned long )((int )i + 601)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24584));
#line 573
  i = (u8 )((int )i + 1);
  }
  ldv_52195: ;
#line 573
  if ((unsigned int )i <= 31U) {
#line 575
    goto ldv_52194;
  } else {

  }
#line 575
  i = 0U;
#line 575
  goto ldv_52198;
  ldv_52197: 
  {
#line 576
  *(regs_buff + (unsigned long )((int )i + 633)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24592));
#line 575
  i = (u8 )((int )i + 1);
  }
  ldv_52198: ;
#line 575
  if ((unsigned int )i <= 31U) {
#line 577
    goto ldv_52197;
  } else {

  }
#line 577
  i = 0U;
#line 577
  goto ldv_52201;
  ldv_52200: 
  {
#line 578
  *(regs_buff + (unsigned long )((int )i + 665)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24600));
#line 577
  i = (u8 )((int )i + 1);
  }
  ldv_52201: ;
#line 577
  if ((unsigned int )i <= 31U) {
#line 579
    goto ldv_52200;
  } else {

  }
#line 579
  i = 0U;
#line 579
  goto ldv_52204;
  ldv_52203: 
  {
#line 580
  *(regs_buff + (unsigned long )((int )i + 697)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24616));
#line 579
  i = (u8 )((int )i + 1);
  }
  ldv_52204: ;
#line 579
  if ((unsigned int )i <= 31U) {
#line 581
    goto ldv_52203;
  } else {

  }
#line 581
  i = 0U;
#line 581
  goto ldv_52207;
  ldv_52206: 
  {
#line 582
  *(regs_buff + (unsigned long )((int )i + 729)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24632));
#line 581
  i = (u8 )((int )i + 1);
  }
  ldv_52207: ;
#line 581
  if ((unsigned int )i <= 31U) {
#line 583
    goto ldv_52206;
  } else {

  }
#line 583
  i = 0U;
#line 583
  goto ldv_52210;
  ldv_52209: 
  {
#line 584
  *(regs_buff + (unsigned long )((int )i + 761)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24636));
#line 583
  i = (u8 )((int )i + 1);
  }
  ldv_52210: ;
#line 583
  if ((unsigned int )i <= 31U) {
#line 585
    goto ldv_52209;
  } else {

  }
  {
#line 585
  *(regs_buff + 793UL) = ixgbe_read_reg(hw, 32256U);
#line 586
  i = 0U;
  }
#line 586
  goto ldv_52213;
  ldv_52212: 
  {
#line 587
  *(regs_buff + (unsigned long )((int )i + 794)) = ixgbe_read_reg(hw, (u32 )(((int )i + 7296) * 4));
#line 586
  i = (u8 )((int )i + 1);
  }
  ldv_52213: ;
#line 586
  if ((unsigned int )i <= 15U) {
#line 588
    goto ldv_52212;
  } else {

  }
  {
#line 588
  *(regs_buff + 810UL) = ixgbe_read_reg(hw, 51968U);
#line 589
  i = 0U;
  }
#line 589
  goto ldv_52216;
  ldv_52215: 
  {
#line 590
  *(regs_buff + (unsigned long )((int )i + 811)) = ixgbe_read_reg(hw, (u32 )(((int )i + 13056) * 4));
#line 589
  i = (u8 )((int )i + 1);
  }
  ldv_52216: ;
#line 589
  if ((unsigned int )i <= 7U) {
#line 591
    goto ldv_52215;
  } else {

  }
  {
#line 591
  *(regs_buff + 819UL) = ixgbe_read_reg(hw, 52496U);
#line 594
  *(regs_buff + 820UL) = ixgbe_read_reg(hw, 22528U);
#line 595
  *(regs_buff + 821UL) = ixgbe_read_reg(hw, 22536U);
#line 596
  *(regs_buff + 822UL) = ixgbe_read_reg(hw, 22544U);
#line 597
  *(regs_buff + 823UL) = ixgbe_read_reg(hw, 22584U);
#line 598
  *(regs_buff + 824UL) = ixgbe_read_reg(hw, 22592U);
#line 599
  *(regs_buff + 825UL) = ixgbe_read_reg(hw, 22656U);
#line 600
  *(regs_buff + 826UL) = ixgbe_read_reg(hw, 22784U);
#line 601
  *(regs_buff + 827UL) = ixgbe_read_reg(hw, 23040U);
#line 602
  *(regs_buff + 828UL) = ixgbe_read_reg(hw, 36864U);
#line 605
  *(regs_buff + 829UL) = ixgbe_read_reg(hw, 15616U);
#line 606
  *(regs_buff + 831UL) = ixgbe_read_reg(hw, 52480U);
  }
  {
#line 609
  if ((unsigned int )hw->mac.type == 1U) {
#line 609
    goto case_1___0;
  } else {

  }
#line 625
  if ((unsigned int )hw->mac.type == 2U) {
#line 625
    goto case_2___0;
  } else {

  }
#line 626
  if ((unsigned int )hw->mac.type == 3U) {
#line 626
    goto case_3___0;
  } else {

  }
#line 642
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 610
  *(regs_buff + 830UL) = ixgbe_read_reg(hw, 32576U);
#line 611
  *(regs_buff + 832UL) = ixgbe_read_reg(hw, 20640U);
#line 612
  i = 0U;
  }
#line 612
  goto ldv_52220;
  ldv_52219: 
  {
#line 613
  *(regs_buff + (unsigned long )((int )i + 833)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3848) * 4));
#line 612
  i = (u8 )((int )i + 1);
  }
  ldv_52220: ;
#line 612
  if ((unsigned int )i <= 7U) {
#line 614
    goto ldv_52219;
  } else {

  }
#line 615
  i = 0U;
#line 615
  goto ldv_52223;
  ldv_52222: 
  {
#line 616
  *(regs_buff + (unsigned long )((int )i + 841)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3856) * 4));
#line 615
  i = (u8 )((int )i + 1);
  }
  ldv_52223: ;
#line 615
  if ((unsigned int )i <= 7U) {
#line 617
    goto ldv_52222;
  } else {

  }
#line 618
  i = 0U;
#line 618
  goto ldv_52226;
  ldv_52225: 
  {
#line 619
  *(regs_buff + (unsigned long )((int )i + 849)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 24620));
#line 618
  i = (u8 )((int )i + 1);
  }
  ldv_52226: ;
#line 618
  if ((unsigned int )i <= 7U) {
#line 620
    goto ldv_52225;
  } else {

  }
#line 621
  i = 0U;
#line 621
  goto ldv_52229;
  ldv_52228: 
  {
#line 622
  *(regs_buff + (unsigned long )((int )i + 857)) = ixgbe_read_reg(hw, (u32 )((int )i * 64 + 25132));
#line 621
  i = (u8 )((int )i + 1);
  }
  ldv_52229: ;
#line 621
  if ((unsigned int )i <= 7U) {
#line 623
    goto ldv_52228;
  } else {

  }

#line 624
  goto ldv_52231;
  case_2___0: /* CIL Label */ ;
  case_3___0: /* CIL Label */ 
  {
#line 627
  *(regs_buff + 830UL) = ixgbe_read_reg(hw, 18688U);
#line 628
  *(regs_buff + 832UL) = ixgbe_read_reg(hw, 9264U);
#line 629
  i = 0U;
  }
#line 629
  goto ldv_52235;
  ldv_52234: 
  {
#line 630
  *(regs_buff + (unsigned long )((int )i + 833)) = ixgbe_read_reg(hw, (u32 )(((int )i + 2128) * 4));
#line 629
  i = (u8 )((int )i + 1);
  }
  ldv_52235: ;
#line 629
  if ((unsigned int )i <= 7U) {
#line 631
    goto ldv_52234;
  } else {

  }
#line 632
  i = 0U;
#line 632
  goto ldv_52238;
  ldv_52237: 
  {
#line 633
  *(regs_buff + (unsigned long )((int )i + 841)) = ixgbe_read_reg(hw, (u32 )(((int )i + 2136) * 4));
#line 632
  i = (u8 )((int )i + 1);
  }
  ldv_52238: ;
#line 632
  if ((unsigned int )i <= 7U) {
#line 634
    goto ldv_52237;
  } else {

  }
#line 635
  i = 0U;
#line 635
  goto ldv_52241;
  ldv_52240: 
  {
#line 636
  *(regs_buff + (unsigned long )((int )i + 849)) = ixgbe_read_reg(hw, (u32 )(((int )i + 4676) * 4));
#line 635
  i = (u8 )((int )i + 1);
  }
  ldv_52241: ;
#line 635
  if ((unsigned int )i <= 7U) {
#line 637
    goto ldv_52240;
  } else {

  }
#line 638
  i = 0U;
#line 638
  goto ldv_52244;
  ldv_52243: 
  {
#line 639
  *(regs_buff + (unsigned long )((int )i + 857)) = ixgbe_read_reg(hw, (u32 )(((int )i + 4684) * 4));
#line 638
  i = (u8 )((int )i + 1);
  }
  ldv_52244: ;
#line 638
  if ((unsigned int )i <= 7U) {
#line 640
    goto ldv_52243;
  } else {

  }

#line 641
  goto ldv_52231;
  switch_default___0: /* CIL Label */ ;
#line 643
  goto ldv_52231;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_52231: 
#line 646
  i = 0U;
#line 646
  goto ldv_52248;
  ldv_52247: 
  {
#line 647
  *(regs_buff + (unsigned long )((int )i + 865)) = ixgbe_read_reg(hw, (u32 )(((int )i + 13128) * 4));
#line 646
  i = (u8 )((int )i + 1);
  }
  ldv_52248: ;
#line 646
  if ((unsigned int )i <= 7U) {
#line 648
    goto ldv_52247;
  } else {

  }
#line 649
  i = 0U;
#line 649
  goto ldv_52251;
  ldv_52250: 
  {
#line 650
  *(regs_buff + (unsigned long )((int )i + 873)) = ixgbe_read_reg(hw, (u32 )(((int )i + 13136) * 4));
#line 649
  i = (u8 )((int )i + 1);
  }
  ldv_52251: ;
#line 649
  if ((unsigned int )i <= 7U) {
#line 651
    goto ldv_52250;
  } else {

  }
#line 654
  *(regs_buff + 881UL) = (u32 )adapter->stats.crcerrs;
#line 655
  *(regs_buff + 882UL) = (u32 )adapter->stats.illerrc;
#line 656
  *(regs_buff + 883UL) = (u32 )adapter->stats.errbc;
#line 657
  *(regs_buff + 884UL) = (u32 )adapter->stats.mspdc;
#line 658
  i = 0U;
#line 658
  goto ldv_52254;
  ldv_52253: 
#line 659
  *(regs_buff + (unsigned long )((int )i + 885)) = (u32 )adapter->stats.mpc[(int )i];
#line 658
  i = (u8 )((int )i + 1);
  ldv_52254: ;
#line 658
  if ((unsigned int )i <= 7U) {
#line 660
    goto ldv_52253;
  } else {

  }
#line 660
  *(regs_buff + 893UL) = (u32 )adapter->stats.mlfc;
#line 661
  *(regs_buff + 894UL) = (u32 )adapter->stats.mrfc;
#line 662
  *(regs_buff + 895UL) = (u32 )adapter->stats.rlec;
#line 663
  *(regs_buff + 896UL) = (u32 )adapter->stats.lxontxc;
#line 664
  *(regs_buff + 897UL) = (u32 )adapter->stats.lxonrxc;
#line 665
  *(regs_buff + 898UL) = (u32 )adapter->stats.lxofftxc;
#line 666
  *(regs_buff + 899UL) = (u32 )adapter->stats.lxoffrxc;
#line 667
  i = 0U;
#line 667
  goto ldv_52257;
  ldv_52256: 
#line 668
  *(regs_buff + (unsigned long )((int )i + 900)) = (u32 )adapter->stats.pxontxc[(int )i];
#line 667
  i = (u8 )((int )i + 1);
  ldv_52257: ;
#line 667
  if ((unsigned int )i <= 7U) {
#line 669
    goto ldv_52256;
  } else {

  }
#line 669
  i = 0U;
#line 669
  goto ldv_52260;
  ldv_52259: 
#line 670
  *(regs_buff + (unsigned long )((int )i + 908)) = (u32 )adapter->stats.pxonrxc[(int )i];
#line 669
  i = (u8 )((int )i + 1);
  ldv_52260: ;
#line 669
  if ((unsigned int )i <= 7U) {
#line 671
    goto ldv_52259;
  } else {

  }
#line 671
  i = 0U;
#line 671
  goto ldv_52263;
  ldv_52262: 
#line 672
  *(regs_buff + (unsigned long )((int )i + 916)) = (u32 )adapter->stats.pxofftxc[(int )i];
#line 671
  i = (u8 )((int )i + 1);
  ldv_52263: ;
#line 671
  if ((unsigned int )i <= 7U) {
#line 673
    goto ldv_52262;
  } else {

  }
#line 673
  i = 0U;
#line 673
  goto ldv_52266;
  ldv_52265: 
#line 674
  *(regs_buff + (unsigned long )((int )i + 924)) = (u32 )adapter->stats.pxoffrxc[(int )i];
#line 673
  i = (u8 )((int )i + 1);
  ldv_52266: ;
#line 673
  if ((unsigned int )i <= 7U) {
#line 675
    goto ldv_52265;
  } else {

  }
#line 675
  *(regs_buff + 932UL) = (u32 )adapter->stats.prc64;
#line 676
  *(regs_buff + 933UL) = (u32 )adapter->stats.prc127;
#line 677
  *(regs_buff + 934UL) = (u32 )adapter->stats.prc255;
#line 678
  *(regs_buff + 935UL) = (u32 )adapter->stats.prc511;
#line 679
  *(regs_buff + 936UL) = (u32 )adapter->stats.prc1023;
#line 680
  *(regs_buff + 937UL) = (u32 )adapter->stats.prc1522;
#line 681
  *(regs_buff + 938UL) = (u32 )adapter->stats.gprc;
#line 682
  *(regs_buff + 939UL) = (u32 )adapter->stats.bprc;
#line 683
  *(regs_buff + 940UL) = (u32 )adapter->stats.mprc;
#line 684
  *(regs_buff + 941UL) = (u32 )adapter->stats.gptc;
#line 685
  *(regs_buff + 942UL) = (u32 )adapter->stats.gorc;
#line 686
  *(regs_buff + 944UL) = (u32 )adapter->stats.gotc;
#line 687
  i = 0U;
#line 687
  goto ldv_52269;
  ldv_52268: 
#line 688
  *(regs_buff + (unsigned long )((int )i + 946)) = (u32 )adapter->stats.rnbc[(int )i];
#line 687
  i = (u8 )((int )i + 1);
  ldv_52269: ;
#line 687
  if ((unsigned int )i <= 7U) {
#line 689
    goto ldv_52268;
  } else {

  }
#line 689
  *(regs_buff + 954UL) = (u32 )adapter->stats.ruc;
#line 690
  *(regs_buff + 955UL) = (u32 )adapter->stats.rfc;
#line 691
  *(regs_buff + 956UL) = (u32 )adapter->stats.roc;
#line 692
  *(regs_buff + 957UL) = (u32 )adapter->stats.rjc;
#line 693
  *(regs_buff + 958UL) = (u32 )adapter->stats.mngprc;
#line 694
  *(regs_buff + 959UL) = (u32 )adapter->stats.mngpdc;
#line 695
  *(regs_buff + 960UL) = (u32 )adapter->stats.mngptc;
#line 696
  *(regs_buff + 961UL) = (u32 )adapter->stats.tor;
#line 697
  *(regs_buff + 963UL) = (u32 )adapter->stats.tpr;
#line 698
  *(regs_buff + 964UL) = (u32 )adapter->stats.tpt;
#line 699
  *(regs_buff + 965UL) = (u32 )adapter->stats.ptc64;
#line 700
  *(regs_buff + 966UL) = (u32 )adapter->stats.ptc127;
#line 701
  *(regs_buff + 967UL) = (u32 )adapter->stats.ptc255;
#line 702
  *(regs_buff + 968UL) = (u32 )adapter->stats.ptc511;
#line 703
  *(regs_buff + 969UL) = (u32 )adapter->stats.ptc1023;
#line 704
  *(regs_buff + 970UL) = (u32 )adapter->stats.ptc1522;
#line 705
  *(regs_buff + 971UL) = (u32 )adapter->stats.mptc;
#line 706
  *(regs_buff + 972UL) = (u32 )adapter->stats.bptc;
#line 707
  *(regs_buff + 973UL) = (u32 )adapter->stats.xec;
#line 708
  i = 0U;
#line 708
  goto ldv_52272;
  ldv_52271: 
#line 709
  *(regs_buff + (unsigned long )((int )i + 974)) = (u32 )adapter->stats.qprc[(int )i];
#line 708
  i = (u8 )((int )i + 1);
  ldv_52272: ;
#line 708
  if ((unsigned int )i <= 15U) {
#line 710
    goto ldv_52271;
  } else {

  }
#line 710
  i = 0U;
#line 710
  goto ldv_52275;
  ldv_52274: 
#line 711
  *(regs_buff + (unsigned long )((int )i + 990)) = (u32 )adapter->stats.qptc[(int )i];
#line 710
  i = (u8 )((int )i + 1);
  ldv_52275: ;
#line 710
  if ((unsigned int )i <= 15U) {
#line 712
    goto ldv_52274;
  } else {

  }
#line 712
  i = 0U;
#line 712
  goto ldv_52278;
  ldv_52277: 
#line 713
  *(regs_buff + (unsigned long )((int )i + 1006)) = (u32 )adapter->stats.qbrc[(int )i];
#line 712
  i = (u8 )((int )i + 1);
  ldv_52278: ;
#line 712
  if ((unsigned int )i <= 15U) {
#line 714
    goto ldv_52277;
  } else {

  }
#line 714
  i = 0U;
#line 714
  goto ldv_52281;
  ldv_52280: 
#line 715
  *(regs_buff + (unsigned long )((int )i + 1022)) = (u32 )adapter->stats.qbtc[(int )i];
#line 714
  i = (u8 )((int )i + 1);
  ldv_52281: ;
#line 714
  if ((unsigned int )i <= 15U) {
#line 716
    goto ldv_52280;
  } else {

  }
  {
#line 718
  *(regs_buff + 1038UL) = ixgbe_read_reg(hw, 16896U);
#line 719
  *(regs_buff + 1039UL) = ixgbe_read_reg(hw, 16904U);
#line 720
  *(regs_buff + 1040UL) = ixgbe_read_reg(hw, 16908U);
#line 721
  *(regs_buff + 1041UL) = ixgbe_read_reg(hw, 16912U);
#line 722
  *(regs_buff + 1042UL) = ixgbe_read_reg(hw, 16916U);
#line 723
  *(regs_buff + 1043UL) = ixgbe_read_reg(hw, 16920U);
#line 724
  *(regs_buff + 1044UL) = ixgbe_read_reg(hw, 16924U);
#line 725
  *(regs_buff + 1045UL) = ixgbe_read_reg(hw, 16928U);
#line 726
  *(regs_buff + 1046UL) = ixgbe_read_reg(hw, 16932U);
#line 727
  *(regs_buff + 1047UL) = ixgbe_read_reg(hw, 16960U);
#line 728
  *(regs_buff + 1048UL) = ixgbe_read_reg(hw, 16964U);
#line 729
  *(regs_buff + 1049UL) = ixgbe_read_reg(hw, 16968U);
#line 730
  *(regs_buff + 1050UL) = ixgbe_read_reg(hw, 16972U);
#line 731
  *(regs_buff + 1051UL) = ixgbe_read_reg(hw, 16976U);
#line 732
  *(regs_buff + 1052UL) = ixgbe_read_reg(hw, 16980U);
#line 733
  *(regs_buff + 1053UL) = ixgbe_read_reg(hw, 16984U);
#line 734
  *(regs_buff + 1054UL) = ixgbe_read_reg(hw, 16988U);
#line 735
  *(regs_buff + 1055UL) = ixgbe_read_reg(hw, 16992U);
#line 736
  *(regs_buff + 1056UL) = ixgbe_read_reg(hw, 16996U);
#line 737
  *(regs_buff + 1057UL) = ixgbe_read_reg(hw, 17000U);
#line 738
  *(regs_buff + 1058UL) = ixgbe_read_reg(hw, 17004U);
#line 739
  *(regs_buff + 1059UL) = ixgbe_read_reg(hw, 17032U);
#line 740
  *(regs_buff + 1060UL) = ixgbe_read_reg(hw, 17036U);
#line 741
  *(regs_buff + 1061UL) = ixgbe_read_reg(hw, 17040U);
#line 742
  *(regs_buff + 1062UL) = ixgbe_read_reg(hw, 17048U);
#line 743
  *(regs_buff + 1063UL) = ixgbe_read_reg(hw, 17052U);
#line 744
  *(regs_buff + 1064UL) = ixgbe_read_reg(hw, 17056U);
#line 745
  *(regs_buff + 1065UL) = ixgbe_read_reg(hw, 17060U);
#line 746
  *(regs_buff + 1066UL) = ixgbe_read_reg(hw, 17064U);
#line 747
  *(regs_buff + 1067UL) = ixgbe_read_reg(hw, 17068U);
#line 748
  *(regs_buff + 1068UL) = ixgbe_read_reg(hw, 17072U);
#line 749
  *(regs_buff + 1069UL) = ixgbe_read_reg(hw, 17076U);
#line 750
  *(regs_buff + 1070UL) = ixgbe_read_reg(hw, 18432U);
#line 753
  *(regs_buff + 1071UL) = ixgbe_read_reg(hw, 11296U);
#line 754
  i = 0U;
  }
#line 754
  goto ldv_52284;
  ldv_52283: 
  {
#line 755
  *(regs_buff + (unsigned long )((int )i + 1072)) = ixgbe_read_reg(hw, (u32 )(((int )i + 2816) * 4));
#line 754
  i = (u8 )((int )i + 1);
  }
  ldv_52284: ;
#line 754
  if ((unsigned int )i <= 7U) {
#line 756
    goto ldv_52283;
  } else {

  }
  {
#line 756
  *(regs_buff + 1080UL) = ixgbe_read_reg(hw, 12040U);
#line 757
  i = 0U;
  }
#line 757
  goto ldv_52287;
  ldv_52286: 
  {
#line 758
  *(regs_buff + (unsigned long )((int )i + 1081)) = ixgbe_read_reg(hw, (u32 )(((int )i + 3012) * 4));
#line 757
  i = (u8 )((int )i + 1);
  }
  ldv_52287: ;
#line 757
  if ((unsigned int )i <= 3U) {
#line 759
    goto ldv_52286;
  } else {

  }
  {
#line 759
  *(regs_buff + 1085UL) = ixgbe_read_reg(hw, 12064U);
#line 760
  *(regs_buff + 1086UL) = ixgbe_read_reg(hw, 31776U);
#line 761
  i = 0U;
  }
#line 761
  goto ldv_52290;
  ldv_52289: 
  {
#line 762
  *(regs_buff + (unsigned long )((int )i + 1087)) = ixgbe_read_reg(hw, (u32 )(((int )i + 7936) * 4));
#line 761
  i = (u8 )((int )i + 1);
  }
  ldv_52290: ;
#line 761
  if ((unsigned int )i <= 7U) {
#line 763
    goto ldv_52289;
  } else {

  }
  {
#line 763
  *(regs_buff + 1095UL) = ixgbe_read_reg(hw, 32520U);
#line 764
  i = 0U;
  }
#line 764
  goto ldv_52293;
  ldv_52292: 
  {
#line 765
  *(regs_buff + (unsigned long )((int )i + 1096)) = ixgbe_read_reg(hw, (u32 )(((int )i + 8132) * 4));
#line 764
  i = (u8 )((int )i + 1);
  }
  ldv_52293: ;
#line 764
  if ((unsigned int )i <= 3U) {
#line 766
    goto ldv_52292;
  } else {

  }
  {
#line 766
  *(regs_buff + 1100UL) = ixgbe_read_reg(hw, 32544U);
#line 767
  *(regs_buff + 1101UL) = ixgbe_read_reg(hw, 50688U);
#line 768
  *(regs_buff + 1102UL) = ixgbe_read_reg(hw, 50704U);
#line 769
  *(regs_buff + 1103UL) = ixgbe_read_reg(hw, 50708U);
#line 770
  *(regs_buff + 1104UL) = ixgbe_read_reg(hw, 50712U);
#line 771
  *(regs_buff + 1105UL) = ixgbe_read_reg(hw, 50716U);
#line 772
  *(regs_buff + 1106UL) = ixgbe_read_reg(hw, 13824U);
#line 773
  *(regs_buff + 1107UL) = ixgbe_read_reg(hw, 13840U);
#line 774
  *(regs_buff + 1108UL) = ixgbe_read_reg(hw, 13844U);
#line 775
  *(regs_buff + 1109UL) = ixgbe_read_reg(hw, 13848U);
#line 776
  *(regs_buff + 1110UL) = ixgbe_read_reg(hw, 13852U);
#line 777
  i = 0U;
  }
#line 777
  goto ldv_52296;
  ldv_52295: 
  {
#line 778
  *(regs_buff + (unsigned long )((int )i + 1111)) = ixgbe_read_reg(hw, (u32 )(((int )i + 17444) * 4));
#line 777
  i = (u8 )((int )i + 1);
  }
  ldv_52296: ;
#line 777
  if ((unsigned int )i <= 7U) {
#line 779
    goto ldv_52295;
  } else {

  }
  {
#line 779
  *(regs_buff + 1119UL) = ixgbe_read_reg(hw, 20644U);
#line 780
  *(regs_buff + 1120UL) = ixgbe_read_reg(hw, 17080U);
#line 781
  *(regs_buff + 1121UL) = ixgbe_read_reg(hw, 17088U);
#line 782
  *(regs_buff + 1122UL) = ixgbe_read_reg(hw, 17092U);
#line 783
  *(regs_buff + 1123UL) = ixgbe_read_reg(hw, 17096U);
#line 784
  *(regs_buff + 1124UL) = ixgbe_read_reg(hw, 17100U);
#line 785
  *(regs_buff + 1125UL) = ixgbe_read_reg(hw, 69740U);
#line 786
  *(regs_buff + 1126UL) = ixgbe_read_reg(hw, 49920U);
#line 787
  *(regs_buff + 1127UL) = ixgbe_read_reg(hw, 13056U);
#line 790
  *(regs_buff + 1128UL) = ixgbe_read_reg(hw, 17044U);
#line 793
  *(regs_buff + 1129UL) = ixgbe_read_reg(hw, 12320U);
#line 794
  *(regs_buff + 1130UL) = ixgbe_read_reg(hw, 51200U);
#line 795
  i = 0U;
  }
#line 795
  goto ldv_52299;
  ldv_52298: 
  {
#line 796
  *(regs_buff + (unsigned long )((int )i + 1131)) = ixgbe_read_reg(hw, (u32 )(((int )i + 8376) * 4));
#line 795
  i = (u8 )((int )i + 1);
  }
  ldv_52299: ;
#line 795
  if ((unsigned int )i <= 3U) {
#line 797
    goto ldv_52298;
  } else {

  }
  {
#line 797
  *(regs_buff + 1135UL) = ixgbe_read_reg(hw, 18816U);
#line 799
  *(regs_buff + 1136UL) = ixgbe_read_reg(hw, 18828U);
#line 803
  *(regs_buff + 1137UL) = ixgbe_read_reg(hw, 35584U);
#line 804
  *(regs_buff + 1138UL) = ixgbe_read_reg(hw, 19088U);
  }
#line 805
  return;
}
}
#line 807 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_eeprom_len(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 809
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 809
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 810
  return ((int )adapter->hw.eeprom.word_size * 2);
}
}
#line 813 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                            u8 *bytes ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u16 *eeprom_buff ;
  int first_word ;
  int last_word ;
  int eeprom_len ;
  int ret_val ;
  u16 i ;
  void *tmp___0 ;

  {
  {
#line 816
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 816
  adapter = (struct ixgbe_adapter *)tmp;
#line 817
  hw = & adapter->hw;
#line 820
  ret_val = 0;
  }
#line 823
  if (eeprom->len == 0U) {
#line 824
    return (-22);
  } else {

  }
  {
#line 826
  eeprom->magic = (__u32 )((int )hw->vendor_id | ((int )hw->device_id << 16));
#line 828
  first_word = (int )(eeprom->offset >> 1);
#line 829
  last_word = (int )(((eeprom->offset + eeprom->len) - 1U) >> 1);
#line 830
  eeprom_len = (last_word - first_word) + 1;
#line 832
  tmp___0 = kmalloc((unsigned long )eeprom_len * 2UL, 208U);
#line 832
  eeprom_buff = (u16 *)tmp___0;
  }
#line 833
  if ((unsigned long )eeprom_buff == (unsigned long )((u16 *)0U)) {
#line 834
    return (-12);
  } else {

  }
  {
#line 836
  ret_val = (*(hw->eeprom.ops.read_buffer))(hw, (int )((u16 )first_word), (int )((u16 )eeprom_len),
                                            eeprom_buff);
#line 840
  i = 0U;
  }
#line 840
  goto ldv_52319;
  ldv_52318: 
#line 840
  i = (u16 )((int )i + 1);
  ldv_52319: ;
#line 840
  if ((int )i < eeprom_len) {
#line 842
    goto ldv_52318;
  } else {

  }
  {
#line 843
  memcpy((void *)bytes, (void const   *)eeprom_buff + ((unsigned long )eeprom->offset & 1UL),
         (size_t )eeprom->len);
#line 844
  kfree((void const   *)eeprom_buff);
  }
#line 846
  return (ret_val);
}
}
#line 849 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                            u8 *bytes ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u16 *eeprom_buff ;
  void *ptr ;
  int max_len ;
  int first_word ;
  int last_word ;
  int ret_val ;
  u16 i ;
  void *tmp___0 ;

  {
  {
#line 852
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 852
  adapter = (struct ixgbe_adapter *)tmp;
#line 853
  hw = & adapter->hw;
#line 856
  ret_val = 0;
  }
#line 859
  if (eeprom->len == 0U) {
#line 860
    return (-22);
  } else {

  }
#line 862
  if (eeprom->magic != (__u32 )((int )hw->vendor_id | ((int )hw->device_id << 16))) {
#line 863
    return (-22);
  } else {

  }
  {
#line 865
  max_len = (int )hw->eeprom.word_size * 2;
#line 867
  first_word = (int )(eeprom->offset >> 1);
#line 868
  last_word = (int )(((eeprom->offset + eeprom->len) - 1U) >> 1);
#line 869
  tmp___0 = kmalloc((size_t )max_len, 208U);
#line 869
  eeprom_buff = (u16 *)tmp___0;
  }
#line 870
  if ((unsigned long )eeprom_buff == (unsigned long )((u16 *)0U)) {
#line 871
    return (-12);
  } else {

  }
#line 873
  ptr = (void *)eeprom_buff;
#line 875
  if ((int )eeprom->offset & 1) {
    {
#line 880
    ret_val = (*(hw->eeprom.ops.read))(hw, (int )((u16 )first_word), eeprom_buff);
    }
#line 881
    if (ret_val != 0) {
#line 882
      goto err;
    } else {

    }
#line 884
    ptr = ptr + 1;
  } else {

  }
#line 886
  if ((int )(eeprom->offset + eeprom->len) & 1) {
    {
#line 891
    ret_val = (*(hw->eeprom.ops.read))(hw, (int )((u16 )last_word), eeprom_buff + (unsigned long )(last_word - first_word));
    }
#line 893
    if (ret_val != 0) {
#line 894
      goto err;
    } else {

    }
  } else {

  }
#line 898
  i = 0U;
#line 898
  goto ldv_52337;
  ldv_52336: 
#line 898
  i = (u16 )((int )i + 1);
  ldv_52337: ;
#line 898
  if ((int )i < (last_word - first_word) + 1) {
#line 900
    goto ldv_52336;
  } else {

  }
  {
#line 901
  memcpy(ptr, (void const   *)bytes, (size_t )eeprom->len);
#line 903
  i = 0U;
  }
#line 903
  goto ldv_52340;
  ldv_52339: 
#line 903
  i = (u16 )((int )i + 1);
  ldv_52340: ;
#line 903
  if ((int )i < (last_word - first_word) + 1) {
#line 905
    goto ldv_52339;
  } else {

  }
  {
#line 906
  ret_val = (*(hw->eeprom.ops.write_buffer))(hw, (int )((u16 )first_word), (int )((unsigned int )((int )((u16 )last_word) - (int )((u16 )first_word)) + 1U),
                                             eeprom_buff);
  }
#line 911
  if (ret_val == 0) {
    {
#line 912
    (*(hw->eeprom.ops.update_checksum))(hw);
    }
  } else {

  }
  err: 
  {
#line 915
  kfree((void const   *)eeprom_buff);
  }
#line 916
  return (ret_val);
}
}
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_drvinfo(struct net_device *netdev , struct ethtool_drvinfo *drvinfo ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  u32 nvm_track_id ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 922
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 922
  adapter = (struct ixgbe_adapter *)tmp;
#line 925
  strlcpy((char *)(& drvinfo->driver), (char const   *)(& ixgbe_driver_name), 32UL);
#line 926
  strlcpy((char *)(& drvinfo->version), (char const   *)(& ixgbe_driver_version),
          32UL);
#line 929
  nvm_track_id = (u32 )(((int )adapter->eeprom_verh << 16) | (int )adapter->eeprom_verl);
#line 931
  snprintf((char *)(& drvinfo->fw_version), 32UL, "0x%08x", nvm_track_id);
#line 934
  tmp___0 = pci_name((struct pci_dev  const  *)adapter->pdev);
#line 934
  strlcpy((char *)(& drvinfo->bus_info), tmp___0, 32UL);
#line 936
  drvinfo->n_stats = netdev->num_tx_queues * 10U + 89U;
#line 937
  drvinfo->testinfo_len = 5U;
#line 938
  tmp___1 = ixgbe_get_regs_len(netdev);
#line 938
  drvinfo->regdump_len = (__u32 )tmp___1;
  }
#line 939
  return;
}
}
#line 941 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_ringparam(struct net_device *netdev , struct ethtool_ringparam *ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_ring *rx_ring ;

  {
  {
#line 944
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 944
  adapter = (struct ixgbe_adapter *)tmp;
#line 945
  tx_ring = adapter->tx_ring[0];
#line 946
  rx_ring = adapter->rx_ring[0];
#line 948
  ring->rx_max_pending = 4096U;
#line 949
  ring->tx_max_pending = 4096U;
#line 950
  ring->rx_pending = (__u32 )rx_ring->count;
#line 951
  ring->tx_pending = (__u32 )tx_ring->count;
  }
#line 952
  return;
}
}
#line 954 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_ringparam(struct net_device *netdev , struct ethtool_ringparam *ring ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_ring *temp_ring ;
  int i ;
  int err ;
  u32 new_rx_count ;
  u32 new_tx_count ;
  u32 __val ;
  u32 __min ;
  u32 __max ;
  u32 __val___0 ;
  u32 __min___0 ;
  u32 __max___0 ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int __max1 ;
  int __max2 ;
  void *tmp___3 ;

  {
  {
#line 957
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 957
  adapter = (struct ixgbe_adapter *)tmp;
#line 959
  err = 0;
  }
#line 962
  if (ring->rx_mini_pending != 0U || ring->rx_jumbo_pending != 0U) {
#line 963
    return (-22);
  } else {

  }
#line 965
  __val = ring->tx_pending;
#line 965
  __min = 64U;
#line 965
  __max = 4096U;
#line 965
  __val = __min > __val ? __min : __val;
#line 965
  new_tx_count = __max < __val ? __max : __val;
#line 967
  new_tx_count = (new_tx_count + 7U) & 4294967288U;
#line 969
  __val___0 = ring->rx_pending;
#line 969
  __min___0 = 64U;
#line 969
  __max___0 = 4096U;
#line 969
  __val___0 = __min___0 > __val___0 ? __min___0 : __val___0;
#line 969
  new_rx_count = __max___0 < __val___0 ? __max___0 : __val___0;
#line 971
  new_rx_count = (new_rx_count + 7U) & 4294967288U;
#line 973
  if (new_tx_count == adapter->tx_ring_count && new_rx_count == adapter->rx_ring_count) {
#line 976
    return (0);
  } else {

  }
#line 979
  goto ldv_52376;
  ldv_52375: 
  {
#line 980
  usleep_range(1000UL, 2000UL);
  }
  ldv_52376: 
  {
#line 979
  tmp___0 = test_and_set_bit(1L, (unsigned long volatile   *)(& adapter->state));
  }
#line 979
  if (tmp___0 != 0) {
#line 981
    goto ldv_52375;
  } else {

  }
  {
#line 982
  tmp___1 = netif_running((struct net_device  const  *)adapter->netdev);
  }
#line 982
  if (tmp___1) {
#line 982
    tmp___2 = 0;
  } else {
#line 982
    tmp___2 = 1;
  }
#line 982
  if (tmp___2) {
#line 983
    i = 0;
#line 983
    goto ldv_52379;
    ldv_52378: 
#line 984
    (adapter->tx_ring[i])->count = (u16 )new_tx_count;
#line 983
    i = i + 1;
    ldv_52379: ;
#line 983
    if (i < adapter->num_tx_queues) {
#line 985
      goto ldv_52378;
    } else {

    }
#line 985
    i = 0;
#line 985
    goto ldv_52382;
    ldv_52381: 
#line 986
    (adapter->rx_ring[i])->count = (u16 )new_rx_count;
#line 985
    i = i + 1;
    ldv_52382: ;
#line 985
    if (i < adapter->num_rx_queues) {
#line 987
      goto ldv_52381;
    } else {

    }
#line 987
    adapter->tx_ring_count = new_tx_count;
#line 988
    adapter->rx_ring_count = new_rx_count;
#line 989
    goto clear_reset;
  } else {

  }
  {
#line 993
  __max1 = adapter->num_tx_queues;
#line 993
  __max2 = adapter->num_rx_queues;
#line 993
  i = __max1 > __max2 ? __max1 : __max2;
#line 994
  tmp___3 = vmalloc((unsigned long )i * 4096UL);
#line 994
  temp_ring = (struct ixgbe_ring *)tmp___3;
  }
#line 996
  if ((unsigned long )temp_ring == (unsigned long )((struct ixgbe_ring *)0)) {
#line 997
    err = -12;
#line 998
    goto clear_reset;
  } else {

  }
  {
#line 1001
  ixgbe_down(adapter);
  }
#line 1009
  if (new_tx_count != adapter->tx_ring_count) {
#line 1010
    i = 0;
#line 1010
    goto ldv_52393;
    ldv_52392: 
    {
#line 1011
    memcpy((void *)temp_ring + (unsigned long )i, (void const   *)adapter->tx_ring[i],
           4096UL);
#line 1014
    (temp_ring + (unsigned long )i)->count = (u16 )new_tx_count;
#line 1015
    err = ixgbe_setup_tx_resources(temp_ring + (unsigned long )i);
    }
#line 1016
    if (err != 0) {
#line 1017
      goto ldv_52389;
      ldv_52388: 
      {
#line 1018
      i = i - 1;
#line 1019
      ixgbe_free_tx_resources(temp_ring + (unsigned long )i);
      }
      ldv_52389: ;
#line 1017
      if (i != 0) {
#line 1019
        goto ldv_52388;
      } else {

      }

#line 1021
      goto err_setup;
    } else {

    }
#line 1010
    i = i + 1;
    ldv_52393: ;
#line 1010
    if (i < adapter->num_tx_queues) {
#line 1012
      goto ldv_52392;
    } else {

    }
#line 1025
    i = 0;
#line 1025
    goto ldv_52396;
    ldv_52395: 
    {
#line 1026
    ixgbe_free_tx_resources(adapter->tx_ring[i]);
#line 1028
    memcpy((void *)adapter->tx_ring[i], (void const   *)temp_ring + (unsigned long )i,
           4096UL);
#line 1025
    i = i + 1;
    }
    ldv_52396: ;
#line 1025
    if (i < adapter->num_tx_queues) {
#line 1027
      goto ldv_52395;
    } else {

    }
#line 1032
    adapter->tx_ring_count = new_tx_count;
  } else {

  }
#line 1036
  if (new_rx_count != adapter->rx_ring_count) {
#line 1037
    i = 0;
#line 1037
    goto ldv_52402;
    ldv_52401: 
    {
#line 1038
    memcpy((void *)temp_ring + (unsigned long )i, (void const   *)adapter->rx_ring[i],
           4096UL);
#line 1041
    (temp_ring + (unsigned long )i)->count = (u16 )new_rx_count;
#line 1042
    err = ixgbe_setup_rx_resources(temp_ring + (unsigned long )i);
    }
#line 1043
    if (err != 0) {
#line 1044
      goto ldv_52399;
      ldv_52398: 
      {
#line 1045
      i = i - 1;
#line 1046
      ixgbe_free_rx_resources(temp_ring + (unsigned long )i);
      }
      ldv_52399: ;
#line 1044
      if (i != 0) {
#line 1046
        goto ldv_52398;
      } else {

      }

#line 1048
      goto err_setup;
    } else {

    }
#line 1037
    i = i + 1;
    ldv_52402: ;
#line 1037
    if (i < adapter->num_rx_queues) {
#line 1039
      goto ldv_52401;
    } else {

    }
#line 1053
    i = 0;
#line 1053
    goto ldv_52405;
    ldv_52404: 
    {
#line 1054
    ixgbe_free_rx_resources(adapter->rx_ring[i]);
#line 1056
    memcpy((void *)adapter->rx_ring[i], (void const   *)temp_ring + (unsigned long )i,
           4096UL);
#line 1053
    i = i + 1;
    }
    ldv_52405: ;
#line 1053
    if (i < adapter->num_rx_queues) {
#line 1055
      goto ldv_52404;
    } else {

    }
#line 1060
    adapter->rx_ring_count = new_rx_count;
  } else {

  }
  err_setup: 
  {
#line 1064
  ixgbe_up(adapter);
#line 1065
  vfree((void const   *)temp_ring);
  }
  clear_reset: 
  {
#line 1067
  clear_bit(1L, (unsigned long volatile   *)(& adapter->state));
  }
#line 1068
  return (err);
}
}
#line 1071 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_sset_count(struct net_device *netdev , int sset ) 
{ 


  {
  {
#line 1074
  if (sset == 0) {
#line 1074
    goto case_0;
  } else {

  }
#line 1076
  if (sset == 1) {
#line 1076
    goto case_1;
  } else {

  }
#line 1078
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 1075
  return (5);
  case_1: /* CIL Label */ ;
#line 1077
  return ((int )(netdev->num_tx_queues * 10U + 89U));
  switch_default: /* CIL Label */ ;
#line 1079
  return (-95);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1083 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_ethtool_stats(struct net_device *netdev , struct ethtool_stats *stats ,
                                    u64 *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct rtnl_link_stats64 temp ;
  struct rtnl_link_stats64  const  *net_stats ;
  unsigned int start ;
  struct ixgbe_ring *ring ;
  int i ;
  int j ;
  char *p ;
  struct rtnl_link_stats64 *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1086
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1086
  adapter = (struct ixgbe_adapter *)tmp;
#line 1092
  p = (char *)0;
#line 1094
  ixgbe_update_stats(adapter);
#line 1095
  tmp___0 = dev_get_stats(netdev, & temp);
#line 1095
  net_stats = (struct rtnl_link_stats64  const  *)tmp___0;
#line 1096
  i = 0;
  }
#line 1096
  goto ldv_52437;
  ldv_52436: ;
  {
#line 1098
  if (ixgbe_gstrings_stats[i].type == 0) {
#line 1098
    goto case_0;
  } else {

  }
#line 1102
  if (ixgbe_gstrings_stats[i].type == 1) {
#line 1102
    goto case_1;
  } else {

  }
#line 1106
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1099
  p = (char *)net_stats + (unsigned long )ixgbe_gstrings_stats[i].stat_offset;
#line 1101
  goto ldv_52432;
  case_1: /* CIL Label */ 
#line 1103
  p = (char *)adapter + (unsigned long )ixgbe_gstrings_stats[i].stat_offset;
#line 1105
  goto ldv_52432;
  switch_default: /* CIL Label */ 
#line 1107
  *(data + (unsigned long )i) = 0ULL;
#line 1108
  goto ldv_52435;
  switch_break: /* CIL Label */ ;
  }
  ldv_52432: 
#line 1111
  *(data + (unsigned long )i) = ixgbe_gstrings_stats[i].sizeof_stat == 8 ? *((u64 *)p) : (u64 )*((u32 *)p);
  ldv_52435: 
#line 1096
  i = i + 1;
  ldv_52437: ;
#line 1096
  if ((unsigned int )i <= 56U) {
#line 1098
    goto ldv_52436;
  } else {

  }
#line 1114
  j = 0;
#line 1114
  goto ldv_52443;
  ldv_52442: 
#line 1115
  ring = adapter->tx_ring[j];
#line 1116
  if ((unsigned long )ring == (unsigned long )((struct ixgbe_ring *)0)) {
#line 1117
    *(data + (unsigned long )i) = 0ULL;
#line 1118
    *(data + ((unsigned long )i + 1UL)) = 0ULL;
#line 1119
    i = i + 2;
#line 1121
    *(data + (unsigned long )i) = 0ULL;
#line 1122
    *(data + ((unsigned long )i + 1UL)) = 0ULL;
#line 1123
    *(data + ((unsigned long )i + 2UL)) = 0ULL;
#line 1124
    i = i + 3;
#line 1126
    goto ldv_52439;
  } else {

  }
  ldv_52440: 
  {
#line 1130
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& ring->syncp));
#line 1131
  *(data + (unsigned long )i) = ring->stats.packets;
#line 1132
  *(data + ((unsigned long )i + 1UL)) = ring->stats.bytes;
#line 1133
  tmp___1 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& ring->syncp),
                                     start);
  }
#line 1133
  if ((int )tmp___1) {
#line 1135
    goto ldv_52440;
  } else {

  }
#line 1134
  i = i + 2;
#line 1136
  *(data + (unsigned long )i) = ring->stats.yields;
#line 1137
  *(data + ((unsigned long )i + 1UL)) = ring->stats.misses;
#line 1138
  *(data + ((unsigned long )i + 2UL)) = ring->stats.cleaned;
#line 1139
  i = i + 3;
  ldv_52439: 
#line 1114
  j = j + 1;
  ldv_52443: ;
#line 1114
  if ((unsigned int )j < netdev->num_tx_queues) {
#line 1116
    goto ldv_52442;
  } else {

  }
#line 1142
  j = 0;
#line 1142
  goto ldv_52449;
  ldv_52448: 
#line 1143
  ring = adapter->rx_ring[j];
#line 1144
  if ((unsigned long )ring == (unsigned long )((struct ixgbe_ring *)0)) {
#line 1145
    *(data + (unsigned long )i) = 0ULL;
#line 1146
    *(data + ((unsigned long )i + 1UL)) = 0ULL;
#line 1147
    i = i + 2;
#line 1149
    *(data + (unsigned long )i) = 0ULL;
#line 1150
    *(data + ((unsigned long )i + 1UL)) = 0ULL;
#line 1151
    *(data + ((unsigned long )i + 2UL)) = 0ULL;
#line 1152
    i = i + 3;
#line 1154
    goto ldv_52445;
  } else {

  }
  ldv_52446: 
  {
#line 1158
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& ring->syncp));
#line 1159
  *(data + (unsigned long )i) = ring->stats.packets;
#line 1160
  *(data + ((unsigned long )i + 1UL)) = ring->stats.bytes;
#line 1161
  tmp___2 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& ring->syncp),
                                     start);
  }
#line 1161
  if ((int )tmp___2) {
#line 1163
    goto ldv_52446;
  } else {

  }
#line 1162
  i = i + 2;
#line 1164
  *(data + (unsigned long )i) = ring->stats.yields;
#line 1165
  *(data + ((unsigned long )i + 1UL)) = ring->stats.misses;
#line 1166
  *(data + ((unsigned long )i + 2UL)) = ring->stats.cleaned;
#line 1167
  i = i + 3;
  ldv_52445: 
#line 1142
  j = j + 1;
  ldv_52449: ;
#line 1142
  if ((unsigned int )j < netdev->num_tx_queues) {
#line 1144
    goto ldv_52448;
  } else {

  }
#line 1171
  j = 0;
#line 1171
  goto ldv_52452;
  ldv_52451: 
#line 1172
  tmp___3 = i;
#line 1172
  i = i + 1;
#line 1172
  *(data + (unsigned long )tmp___3) = adapter->stats.pxontxc[j];
#line 1173
  tmp___4 = i;
#line 1173
  i = i + 1;
#line 1173
  *(data + (unsigned long )tmp___4) = adapter->stats.pxofftxc[j];
#line 1171
  j = j + 1;
  ldv_52452: ;
#line 1171
  if (j <= 7) {
#line 1173
    goto ldv_52451;
  } else {

  }
#line 1175
  j = 0;
#line 1175
  goto ldv_52455;
  ldv_52454: 
#line 1176
  tmp___5 = i;
#line 1176
  i = i + 1;
#line 1176
  *(data + (unsigned long )tmp___5) = adapter->stats.pxonrxc[j];
#line 1177
  tmp___6 = i;
#line 1177
  i = i + 1;
#line 1177
  *(data + (unsigned long )tmp___6) = adapter->stats.pxoffrxc[j];
#line 1175
  j = j + 1;
  ldv_52455: ;
#line 1175
  if (j <= 7) {
#line 1177
    goto ldv_52454;
  } else {

  }

#line 1182
  return;
}
}
#line 1181 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_strings(struct net_device *netdev , u32 stringset , u8 *data ) 
{ 
  char *p ;
  int i ;

  {
#line 1184
  p = (char *)data;
  {
#line 1188
  if (stringset == 0U) {
#line 1188
    goto case_0;
  } else {

  }
#line 1194
  if (stringset == 1U) {
#line 1194
    goto case_1;
  } else {

  }
#line 1187
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1189
  i = 0;
#line 1189
  goto ldv_52466;
  ldv_52465: 
  {
#line 1190
  memcpy((void *)data, (void const   *)(& ixgbe_gstrings_test) + (unsigned long )i,
         32UL);
#line 1191
  data = data + 32UL;
#line 1189
  i = i + 1;
  }
  ldv_52466: ;
#line 1189
  if ((unsigned int )i <= 4U) {
#line 1191
    goto ldv_52465;
  } else {

  }

#line 1193
  goto ldv_52468;
  case_1: /* CIL Label */ 
#line 1195
  i = 0;
#line 1195
  goto ldv_52473;
  ldv_52472: 
  {
#line 1196
  memcpy((void *)p, (void const   *)(& ixgbe_gstrings_stats[i].stat_string), 32UL);
#line 1198
  p = p + 32UL;
#line 1195
  i = i + 1;
  }
  ldv_52473: ;
#line 1195
  if ((unsigned int )i <= 56U) {
#line 1197
    goto ldv_52472;
  } else {

  }
#line 1200
  i = 0;
#line 1200
  goto ldv_52476;
  ldv_52475: 
  {
#line 1201
  sprintf(p, "tx_queue_%u_packets", i);
#line 1202
  p = p + 32UL;
#line 1203
  sprintf(p, "tx_queue_%u_bytes", i);
#line 1204
  p = p + 32UL;
#line 1206
  sprintf(p, "tx_queue_%u_bp_napi_yield", i);
#line 1207
  p = p + 32UL;
#line 1208
  sprintf(p, "tx_queue_%u_bp_misses", i);
#line 1209
  p = p + 32UL;
#line 1210
  sprintf(p, "tx_queue_%u_bp_cleaned", i);
#line 1211
  p = p + 32UL;
#line 1200
  i = i + 1;
  }
  ldv_52476: ;
#line 1200
  if ((unsigned int )i < netdev->num_tx_queues) {
#line 1202
    goto ldv_52475;
  } else {

  }
#line 1214
  i = 0;
#line 1214
  goto ldv_52479;
  ldv_52478: 
  {
#line 1215
  sprintf(p, "rx_queue_%u_packets", i);
#line 1216
  p = p + 32UL;
#line 1217
  sprintf(p, "rx_queue_%u_bytes", i);
#line 1218
  p = p + 32UL;
#line 1220
  sprintf(p, "rx_queue_%u_bp_poll_yield", i);
#line 1221
  p = p + 32UL;
#line 1222
  sprintf(p, "rx_queue_%u_bp_misses", i);
#line 1223
  p = p + 32UL;
#line 1224
  sprintf(p, "rx_queue_%u_bp_cleaned", i);
#line 1225
  p = p + 32UL;
#line 1214
  i = i + 1;
  }
  ldv_52479: ;
#line 1214
  if ((unsigned int )i < netdev->num_tx_queues) {
#line 1216
    goto ldv_52478;
  } else {

  }
#line 1228
  i = 0;
#line 1228
  goto ldv_52482;
  ldv_52481: 
  {
#line 1229
  sprintf(p, "tx_pb_%u_pxon", i);
#line 1230
  p = p + 32UL;
#line 1231
  sprintf(p, "tx_pb_%u_pxoff", i);
#line 1232
  p = p + 32UL;
#line 1228
  i = i + 1;
  }
  ldv_52482: ;
#line 1228
  if (i <= 7) {
#line 1230
    goto ldv_52481;
  } else {

  }
#line 1234
  i = 0;
#line 1234
  goto ldv_52485;
  ldv_52484: 
  {
#line 1235
  sprintf(p, "rx_pb_%u_pxon", i);
#line 1236
  p = p + 32UL;
#line 1237
  sprintf(p, "rx_pb_%u_pxoff", i);
#line 1238
  p = p + 32UL;
#line 1234
  i = i + 1;
  }
  ldv_52485: ;
#line 1234
  if (i <= 7) {
#line 1236
    goto ldv_52484;
  } else {

  }

#line 1241
  goto ldv_52468;
  switch_break: /* CIL Label */ ;
  }
  ldv_52468: ;
#line 1244
  return;
}
}
#line 1245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_link_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  struct ixgbe_hw *hw ;
  bool link_up ;
  u32 link_speed ;

  {
  {
#line 1247
  hw = & adapter->hw;
#line 1249
  link_speed = 0U;
#line 1250
  *data = 0ULL;
#line 1252
  (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 1);
  }
#line 1253
  if ((int )link_up) {
#line 1254
    return ((int )*data);
  } else {
#line 1256
    *data = 1ULL;
  }
#line 1257
  return ((int )*data);
}
}
#line 1287 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_reg_test  const  reg_test_82599[20U]  = 
#line 1287
  {      {12832U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12896U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12296U, 1U, 1U, 4294967295U, 4294967295U}, 
        {20616U, 1U, 1U, 0U, 0U}, 
        {4096U, 4U, 1U, 4294967168U, 4294967168U}, 
        {4100U, 4U, 1U, 4294967295U, 4294967295U}, 
        {4104U, 4U, 1U, 1048448U, 1048575U}, 
        {4136U, 4U, 3U, 0U, 33554432U}, 
        {4120U, 4U, 1U, 65535U, 65535U}, 
        {4136U, 4U, 3U, 0U, 0U}, 
        {12896U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12800U, 1U, 1U, 4294967295U, 4294967295U}, 
        {24576U, 4U, 1U, 4294967168U, 4294967295U}, 
        {24580U, 4U, 1U, 4294967295U, 4294967295U}, 
        {24584U, 4U, 1U, 1048448U, 1048448U}, 
        {12288U, 1U, 2U, 1U, 1U}, 
        {21504U, 16U, 5U, 4294967295U, 4294967295U}, 
        {21504U, 16U, 6U, 2147614719U, 2148335615U}, 
        {20992U, 128U, 4U, 4294967295U, 4294967295U}, 
        {0U, 0U, 0U, 0U, 0U}};
#line 1311 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ixgbe_reg_test  const  reg_test_82598[22U]  = 
#line 1311
  {      {12832U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12896U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12296U, 1U, 1U, 4294967295U, 4294967295U}, 
        {20616U, 1U, 1U, 0U, 0U}, 
        {4096U, 4U, 1U, 4294967168U, 4294967295U}, 
        {4100U, 4U, 1U, 4294967295U, 4294967295U}, 
        {4104U, 4U, 1U, 1048448U, 1048575U}, 
        {4136U, 4U, 3U, 0U, 33554432U}, 
        {4120U, 4U, 1U, 65535U, 65535U}, 
        {4136U, 4U, 3U, 0U, 0U}, 
        {12896U, 1U, 1U, 2148007920U, 2148007920U}, 
        {12800U, 1U, 1U, 4294967295U, 4294967295U}, 
        {51968U, 1U, 1U, 255U, 255U}, 
        {24576U, 4U, 1U, 4294967168U, 4294967295U}, 
        {24580U, 4U, 1U, 4294967295U, 4294967295U}, 
        {24584U, 4U, 1U, 1048448U, 1048575U}, 
        {12288U, 1U, 2U, 3U, 3U}, 
        {32256U, 1U, 2U, 5U, 5U}, 
        {21504U, 16U, 5U, 4294967295U, 4294967295U}, 
        {21504U, 16U, 6U, 2148335615U, 2148335615U}, 
        {20992U, 128U, 4U, 4294967295U, 4294967295U}, 
        {0U, 0U, 0U, 0U, 0U}};
#line 1338 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool reg_pattern_test(struct ixgbe_adapter *adapter , u64 *data , int reg ,
                             u32 mask , u32 write ) 
{ 
  u32 pat ;
  u32 val ;
  u32 before ;
  u32 test_pattern[4U] ;
  bool tmp ;

  {
  {
#line 1342
  test_pattern[0] = 1515870810U;
#line 1342
  test_pattern[1] = 2779096485U;
#line 1342
  test_pattern[2] = 0U;
#line 1342
  test_pattern[3] = 4294967295U;
#line 1345
  tmp = ixgbe_removed((void *)adapter->hw.hw_addr);
  }
#line 1345
  if ((int )tmp) {
#line 1346
    *data = 1ULL;
#line 1347
    return (1);
  } else {

  }
#line 1349
  pat = 0U;
#line 1349
  goto ldv_52516;
  ldv_52515: 
  {
#line 1350
  before = ixgbe_read_reg(& adapter->hw, (u32 )reg);
#line 1351
  ixgbe_write_reg(& adapter->hw, (u32 )reg, test_pattern[pat] & write);
#line 1352
  val = ixgbe_read_reg(& adapter->hw, (u32 )reg);
  }
#line 1353
  if (val != ((test_pattern[pat] & write) & mask)) {
#line 1354
    if ((int )adapter->msg_enable & 1) {
      {
#line 1356
      netdev_err((struct net_device  const  *)adapter->netdev, "pattern test reg %04X failed: got 0x%08X expected 0x%08X\n",
                 reg, val, (test_pattern[pat] & write) & mask);
      }
    } else {

    }
    {
#line 1357
    *data = (u64 )reg;
#line 1358
    ixgbe_write_reg(& adapter->hw, (u32 )reg, before);
    }
#line 1359
    return (1);
  } else {

  }
  {
#line 1361
  ixgbe_write_reg(& adapter->hw, (u32 )reg, before);
#line 1349
  pat = pat + 1U;
  }
  ldv_52516: ;
#line 1349
  if (pat <= 3U) {
#line 1351
    goto ldv_52515;
  } else {

  }

#line 1363
  return (0);
}
}
#line 1366 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool reg_set_and_check(struct ixgbe_adapter *adapter , u64 *data , int reg ,
                              u32 mask , u32 write ) 
{ 
  u32 val ;
  u32 before ;
  bool tmp ;

  {
  {
#line 1371
  tmp = ixgbe_removed((void *)adapter->hw.hw_addr);
  }
#line 1371
  if ((int )tmp) {
#line 1372
    *data = 1ULL;
#line 1373
    return (1);
  } else {

  }
  {
#line 1375
  before = ixgbe_read_reg(& adapter->hw, (u32 )reg);
#line 1376
  ixgbe_write_reg(& adapter->hw, (u32 )reg, write & mask);
#line 1377
  val = ixgbe_read_reg(& adapter->hw, (u32 )reg);
  }
#line 1378
  if (((write ^ val) & mask) != 0U) {
#line 1379
    if ((int )adapter->msg_enable & 1) {
      {
#line 1380
      netdev_err((struct net_device  const  *)adapter->netdev, "set/check reg %04X test failed: got 0x%08X expected 0x%08X\n",
                 reg, val & mask, write & mask);
      }
    } else {

    }
    {
#line 1381
    *data = (u64 )reg;
#line 1382
    ixgbe_write_reg(& adapter->hw, (u32 )reg, before);
    }
#line 1383
    return (1);
  } else {

  }
  {
#line 1385
  ixgbe_write_reg(& adapter->hw, (u32 )reg, before);
  }
#line 1386
  return (0);
}
}
#line 1389 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_reg_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  struct ixgbe_reg_test  const  *test ;
  u32 value ;
  u32 before ;
  u32 after ;
  u32 i ;
  u32 toggle ;
  bool tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  bool b ;

  {
  {
#line 1395
  tmp = ixgbe_removed((void *)adapter->hw.hw_addr);
  }
#line 1395
  if ((int )tmp) {
#line 1396
    if ((int )adapter->msg_enable & 1) {
      {
#line 1396
      netdev_err((struct net_device  const  *)adapter->netdev, "Adapter removed - register test blocked\n");
      }
    } else {

    }
#line 1397
    *data = 1ULL;
#line 1398
    return (1);
  } else {

  }
  {
#line 1401
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 1401
    goto case_1;
  } else {

  }
#line 1405
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 1405
    goto case_2;
  } else {

  }
#line 1406
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 1406
    goto case_3;
  } else {

  }
#line 1410
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1402
  toggle = 2147480575U;
#line 1403
  test = (struct ixgbe_reg_test  const  *)(& reg_test_82598);
#line 1404
  goto ldv_52538;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 1407
  toggle = 2147480335U;
#line 1408
  test = (struct ixgbe_reg_test  const  *)(& reg_test_82599);
#line 1409
  goto ldv_52538;
  switch_default: /* CIL Label */ 
#line 1411
  *data = 1ULL;
#line 1412
  return (1);
  switch_break: /* CIL Label */ ;
  }
  ldv_52538: 
  {
#line 1422
  before = ixgbe_read_reg(& adapter->hw, 8U);
#line 1423
  tmp___0 = ixgbe_read_reg(& adapter->hw, 8U);
#line 1423
  value = tmp___0 & toggle;
#line 1424
  ixgbe_write_reg(& adapter->hw, 8U, toggle);
#line 1425
  tmp___1 = ixgbe_read_reg(& adapter->hw, 8U);
#line 1425
  after = tmp___1 & toggle;
  }
#line 1426
  if (value != after) {
#line 1427
    if ((int )adapter->msg_enable & 1) {
      {
#line 1428
      netdev_err((struct net_device  const  *)adapter->netdev, "failed STATUS register test got: 0x%08X expected: 0x%08X\n",
                 after, value);
      }
    } else {

    }
#line 1429
    *data = 1ULL;
#line 1430
    return (1);
  } else {

  }
  {
#line 1433
  ixgbe_write_reg(& adapter->hw, 8U, before);
  }
#line 1439
  goto ldv_52554;
  ldv_52553: 
#line 1440
  i = 0U;
#line 1440
  goto ldv_52551;
  ldv_52550: 
#line 1441
  b = 0;
  {
#line 1444
  if ((int )test->test_type == 1) {
#line 1444
    goto case_1___0;
  } else {

  }
#line 1450
  if ((int )test->test_type == 2) {
#line 1450
    goto case_2___0;
  } else {

  }
#line 1456
  if ((int )test->test_type == 3) {
#line 1456
    goto case_3___0;
  } else {

  }
#line 1461
  if ((int )test->test_type == 4) {
#line 1461
    goto case_4;
  } else {

  }
#line 1467
  if ((int )test->test_type == 5) {
#line 1467
    goto case_5;
  } else {

  }
#line 1473
  if ((int )test->test_type == 6) {
#line 1473
    goto case_6;
  } else {

  }
#line 1443
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 1445
  b = reg_pattern_test(adapter, data, (int )((u32 )test->reg + i * 64U), test->mask,
                       test->write);
  }
#line 1449
  goto ldv_52544;
  case_2___0: /* CIL Label */ 
  {
#line 1451
  b = reg_set_and_check(adapter, data, (int )((u32 )test->reg + i * 64U), test->mask,
                        test->write);
  }
#line 1455
  goto ldv_52544;
  case_3___0: /* CIL Label */ 
  {
#line 1457
  ixgbe_write_reg(& adapter->hw, (u32 )test->reg + i * 64U, test->write);
  }
#line 1460
  goto ldv_52544;
  case_4: /* CIL Label */ 
  {
#line 1462
  b = reg_pattern_test(adapter, data, (int )((u32 )test->reg + i * 4U), test->mask,
                       test->write);
  }
#line 1466
  goto ldv_52544;
  case_5: /* CIL Label */ 
  {
#line 1468
  b = reg_pattern_test(adapter, data, (int )((u32 )test->reg + i * 8U), test->mask,
                       test->write);
  }
#line 1472
  goto ldv_52544;
  case_6: /* CIL Label */ 
  {
#line 1474
  b = reg_pattern_test(adapter, data, (int )(((u32 )test->reg + i * 8U) + 4U), test->mask,
                       test->write);
  }
#line 1478
  goto ldv_52544;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_52544: ;
#line 1480
  if ((int )b) {
#line 1481
    return (1);
  } else {

  }
#line 1440
  i = i + 1U;
  ldv_52551: ;
#line 1440
  if (i < (u32 )test->array_len) {
#line 1442
    goto ldv_52550;
  } else {

  }
#line 1483
  test = test + 1;
  ldv_52554: ;
#line 1439
  if ((unsigned int )((unsigned short )test->reg) != 0U) {
#line 1441
    goto ldv_52553;
  } else {

  }
#line 1486
  *data = 0ULL;
#line 1487
  return (0);
}
}
#line 1490 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_eeprom_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  struct ixgbe_hw *hw ;
  s32 tmp ;

  {
  {
#line 1492
  hw = & adapter->hw;
#line 1493
  tmp = (*(hw->eeprom.ops.validate_checksum))(hw, (u16 *)0U);
  }
#line 1493
  if (tmp != 0) {
#line 1494
    *data = 1ULL;
  } else {
#line 1496
    *data = 0ULL;
  }
#line 1497
  return ((int )*data);
}
}
#line 1500 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static irqreturn_t ixgbe_test_intr(int irq , void *data ) 
{ 
  struct net_device *netdev ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  u32 tmp___0 ;

  {
  {
#line 1502
  netdev = (struct net_device *)data;
#line 1503
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1503
  adapter = (struct ixgbe_adapter *)tmp;
#line 1505
  tmp___0 = ixgbe_read_reg(& adapter->hw, 2048U);
#line 1505
  adapter->test_icr = adapter->test_icr | tmp___0;
  }
#line 1507
  return (1);
}
}
#line 1510 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_intr_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  struct net_device *netdev ;
  u32 mask ;
  u32 i ;
  u32 shared_int ;
  u32 irq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1512
  netdev = adapter->netdev;
#line 1513
  i = 0U;
#line 1513
  shared_int = 1U;
#line 1514
  irq = (adapter->pdev)->irq;
#line 1516
  *data = 0ULL;
#line 1519
  if ((unsigned long )adapter->msix_entries != (unsigned long )((struct msix_entry *)0)) {
#line 1521
    return (0);
  } else
#line 1522
  if ((adapter->flags & 2U) != 0U) {
    {
#line 1523
    shared_int = 0U;
#line 1524
    tmp = ldv_request_irq_9(irq, & ixgbe_test_intr, 0UL, (char const   *)(& netdev->name),
                            (void *)netdev);
    }
#line 1524
    if (tmp != 0) {
#line 1526
      *data = 1ULL;
#line 1527
      return (-1);
    } else {

    }
  } else {
    {
#line 1529
    tmp___1 = ldv_request_irq_10(irq, & ixgbe_test_intr, 256UL, (char const   *)(& netdev->name),
                                 (void *)netdev);
    }
#line 1529
    if (tmp___1 == 0) {
#line 1531
      shared_int = 0U;
    } else {
      {
#line 1532
      tmp___0 = ldv_request_irq_12(irq, & ixgbe_test_intr, 128UL, (char const   *)(& netdev->name),
                                   (void *)netdev);
      }
#line 1532
      if (tmp___0 != 0) {
#line 1534
        *data = 1ULL;
#line 1535
        return (-1);
      } else {

      }
    }
  }
#line 1537
  if (((int )adapter->msg_enable & 8192) != 0) {
    {
#line 1538
    netdev_info((struct net_device  const  *)adapter->netdev, "testing %s interrupt\n",
                shared_int != 0U ? (char *)"shared" : (char *)"unshared");
    }
  } else {

  }
  {
#line 1541
  ixgbe_write_reg(& adapter->hw, 2184U, 4294967295U);
#line 1542
  ixgbe_read_reg(& adapter->hw, 8U);
#line 1543
  usleep_range(10000UL, 20000UL);
  }
#line 1546
  goto ldv_52578;
  ldv_52577: 
#line 1548
  mask = (u32 )(1 << (int )i);
#line 1550
  if (shared_int == 0U) {
    {
#line 1558
    adapter->test_icr = 0U;
#line 1559
    ixgbe_write_reg(& adapter->hw, 2184U, ~ mask & 32767U);
#line 1561
    ixgbe_write_reg(& adapter->hw, 2056U, ~ mask & 32767U);
#line 1563
    ixgbe_read_reg(& adapter->hw, 8U);
#line 1564
    usleep_range(10000UL, 20000UL);
    }
#line 1566
    if ((adapter->test_icr & mask) != 0U) {
#line 1567
      *data = 3ULL;
#line 1568
      goto ldv_52576;
    } else {

    }
  } else {

  }
  {
#line 1578
  adapter->test_icr = 0U;
#line 1579
  ixgbe_write_reg(& adapter->hw, 2176U, mask);
#line 1580
  ixgbe_write_reg(& adapter->hw, 2056U, mask);
#line 1581
  ixgbe_read_reg(& adapter->hw, 8U);
#line 1582
  usleep_range(10000UL, 20000UL);
  }
#line 1584
  if ((adapter->test_icr & mask) == 0U) {
#line 1585
    *data = 4ULL;
#line 1586
    goto ldv_52576;
  } else {

  }
#line 1589
  if (shared_int == 0U) {
    {
#line 1597
    adapter->test_icr = 0U;
#line 1598
    ixgbe_write_reg(& adapter->hw, 2184U, ~ mask & 32767U);
#line 1600
    ixgbe_write_reg(& adapter->hw, 2056U, ~ mask & 32767U);
#line 1602
    ixgbe_read_reg(& adapter->hw, 8U);
#line 1603
    usleep_range(10000UL, 20000UL);
    }
#line 1605
    if (adapter->test_icr != 0U) {
#line 1606
      *data = 5ULL;
#line 1607
      goto ldv_52576;
    } else {

    }
  } else {

  }
#line 1546
  i = i + 1U;
  ldv_52578: ;
#line 1546
  if (i <= 9U) {
#line 1548
    goto ldv_52577;
  } else {

  }
  ldv_52576: 
  {
#line 1613
  ixgbe_write_reg(& adapter->hw, 2184U, 4294967295U);
#line 1614
  ixgbe_read_reg(& adapter->hw, 8U);
#line 1615
  usleep_range(10000UL, 20000UL);
#line 1618
  ldv_free_irq_11___0(irq, (void *)netdev);
  }
#line 1620
  return ((int )*data);
}
}
#line 1623 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_free_desc_rings(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_ring *rx_ring ;
  struct ixgbe_hw *hw ;
  u32 reg_ctl ;

  {
  {
#line 1625
  tx_ring = & adapter->test_tx_ring;
#line 1626
  rx_ring = & adapter->test_rx_ring;
#line 1627
  hw = & adapter->hw;
#line 1633
  reg_ctl = ixgbe_read_reg(hw, 12288U);
#line 1634
  reg_ctl = reg_ctl & 4294967294U;
#line 1635
  ixgbe_write_reg(hw, 12288U, reg_ctl);
#line 1636
  ixgbe_disable_rx_queue(adapter, rx_ring);
#line 1639
  reg_ctl = ixgbe_read_reg(hw, (u32 )((int )tx_ring->reg_idx * 64 + 24616));
#line 1640
  reg_ctl = reg_ctl & 4261412863U;
#line 1641
  ixgbe_write_reg(hw, (u32 )((int )tx_ring->reg_idx * 64 + 24616), reg_ctl);
  }
  {
#line 1644
  if ((unsigned int )hw->mac.type == 2U) {
#line 1644
    goto case_2;
  } else {

  }
#line 1645
  if ((unsigned int )hw->mac.type == 3U) {
#line 1645
    goto case_3;
  } else {

  }
#line 1650
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 1646
  reg_ctl = ixgbe_read_reg(hw, 19072U);
#line 1647
  reg_ctl = reg_ctl & 4294967294U;
#line 1648
  ixgbe_write_reg(hw, 19072U, reg_ctl);
  }
#line 1649
  goto ldv_52588;
  switch_default: /* CIL Label */ ;
#line 1651
  goto ldv_52588;
  switch_break: /* CIL Label */ ;
  }
  ldv_52588: 
  {
#line 1654
  ixgbe_reset(adapter);
#line 1656
  ixgbe_free_tx_resources(& adapter->test_tx_ring);
#line 1657
  ixgbe_free_rx_resources(& adapter->test_rx_ring);
  }
#line 1658
  return;
}
}
#line 1660 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_ring *rx_ring ;
  u32 rctl ;
  u32 reg_data ;
  int ret_val ;
  int err ;

  {
  {
#line 1662
  tx_ring = & adapter->test_tx_ring;
#line 1663
  rx_ring = & adapter->test_rx_ring;
#line 1669
  tx_ring->count = 512U;
#line 1670
  tx_ring->queue_index = 0U;
#line 1671
  tx_ring->dev = & (adapter->pdev)->dev;
#line 1672
  tx_ring->netdev = adapter->netdev;
#line 1673
  tx_ring->reg_idx = (adapter->tx_ring[0])->reg_idx;
#line 1675
  err = ixgbe_setup_tx_resources(tx_ring);
  }
#line 1676
  if (err != 0) {
#line 1677
    return (1);
  } else {

  }
  {
#line 1680
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 1680
    goto case_2;
  } else {

  }
#line 1681
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 1681
    goto case_3;
  } else {

  }
#line 1686
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 1682
  reg_data = ixgbe_read_reg(& adapter->hw, 19072U);
#line 1683
  reg_data = reg_data | 1U;
#line 1684
  ixgbe_write_reg(& adapter->hw, 19072U, reg_data);
  }
#line 1685
  goto ldv_52601;
  switch_default: /* CIL Label */ ;
#line 1687
  goto ldv_52601;
  switch_break: /* CIL Label */ ;
  }
  ldv_52601: 
  {
#line 1690
  ixgbe_configure_tx_ring(adapter, tx_ring);
#line 1693
  rx_ring->count = 512U;
#line 1694
  rx_ring->queue_index = 0U;
#line 1695
  rx_ring->dev = & (adapter->pdev)->dev;
#line 1696
  rx_ring->netdev = adapter->netdev;
#line 1697
  rx_ring->reg_idx = (adapter->rx_ring[0])->reg_idx;
#line 1699
  err = ixgbe_setup_rx_resources(rx_ring);
  }
#line 1700
  if (err != 0) {
#line 1701
    ret_val = 4;
#line 1702
    goto err_nomem;
  } else {

  }
  {
#line 1705
  rctl = ixgbe_read_reg(& adapter->hw, 12288U);
#line 1706
  ixgbe_write_reg(& adapter->hw, 12288U, rctl & 4294967294U);
#line 1708
  ixgbe_configure_rx_ring(adapter, rx_ring);
#line 1710
  rctl = rctl | 3U;
#line 1711
  ixgbe_write_reg(& adapter->hw, 12288U, rctl);
  }
#line 1713
  return (0);
  err_nomem: 
  {
#line 1716
  ixgbe_free_desc_rings(adapter);
  }
#line 1717
  return (ret_val);
}
}
#line 1720 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_setup_loopback_test(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 reg_data ;
  u8 atlas ;

  {
  {
#line 1722
  hw = & adapter->hw;
#line 1727
  reg_data = ixgbe_read_reg(hw, 16960U);
#line 1728
  reg_data = reg_data | 32768U;
#line 1729
  ixgbe_write_reg(hw, 16960U, reg_data);
#line 1731
  reg_data = ixgbe_read_reg(hw, 20608U);
#line 1732
  reg_data = reg_data | 1282U;
#line 1733
  ixgbe_write_reg(hw, 20608U, reg_data);
  }
#line 1736
  if ((unsigned int )adapter->hw.mac.type == 3U) {
    {
#line 1737
    reg_data = ixgbe_read_reg(hw, 17200U);
#line 1738
    reg_data = reg_data | 1U;
#line 1739
    ixgbe_write_reg(hw, 17200U, reg_data);
    }
  } else
#line 1741
  if (hw->mac.orig_autoc != 0U) {
    {
#line 1742
    reg_data = hw->mac.orig_autoc | 1U;
#line 1743
    ixgbe_write_reg(hw, 17056U, reg_data);
    }
  } else {
#line 1745
    return (10);
  }
  {
#line 1748
  ixgbe_read_reg(hw, 8U);
#line 1749
  usleep_range(10000UL, 20000UL);
  }
#line 1752
  if ((unsigned int )hw->mac.type == 1U) {
    {
#line 1755
    (*(hw->mac.ops.read_analog_reg8))(hw, 36U, & atlas);
#line 1756
    atlas = (u8 )((unsigned int )atlas | 16U);
#line 1757
    (*(hw->mac.ops.write_analog_reg8))(hw, 36U, (int )atlas);
#line 1759
    (*(hw->mac.ops.read_analog_reg8))(hw, 11U, & atlas);
#line 1760
    atlas = (u8 )((unsigned int )atlas | 240U);
#line 1761
    (*(hw->mac.ops.write_analog_reg8))(hw, 11U, (int )atlas);
#line 1763
    (*(hw->mac.ops.read_analog_reg8))(hw, 12U, & atlas);
#line 1764
    atlas = (u8 )((unsigned int )atlas | 240U);
#line 1765
    (*(hw->mac.ops.write_analog_reg8))(hw, 12U, (int )atlas);
#line 1767
    (*(hw->mac.ops.read_analog_reg8))(hw, 13U, & atlas);
#line 1768
    atlas = (u8 )((unsigned int )atlas | 240U);
#line 1769
    (*(hw->mac.ops.write_analog_reg8))(hw, 13U, (int )atlas);
    }
  } else {

  }
#line 1772
  return (0);
}
}
#line 1775 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_loopback_cleanup(struct ixgbe_adapter *adapter ) 
{ 
  u32 reg_data ;

  {
  {
#line 1779
  reg_data = ixgbe_read_reg(& adapter->hw, 16960U);
#line 1780
  reg_data = reg_data & 4294934527U;
#line 1781
  ixgbe_write_reg(& adapter->hw, 16960U, reg_data);
  }
#line 1782
  return;
}
}
#line 1784 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_create_lbtest_frame(struct sk_buff *skb , unsigned int frame_size ) 
{ 


  {
  {
#line 1787
  memset((void *)skb->data, 255, (size_t )frame_size);
#line 1788
  frame_size = frame_size >> 1;
#line 1789
  memset((void *)skb->data + (unsigned long )frame_size, 170, (size_t )(frame_size / 2U - 1U));
#line 1790
  memset((void *)skb->data + (unsigned long )(frame_size + 10U), 190, 1UL);
#line 1791
  memset((void *)skb->data + (unsigned long )(frame_size + 12U), 175, 1UL);
  }
#line 1792
  return;
}
}
#line 1794 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool ixgbe_check_lbtest_frame(struct ixgbe_rx_buffer *rx_buffer , unsigned int frame_size ) 
{ 
  unsigned char *data ;
  bool match ;
  void *tmp ;

  {
  {
#line 1798
  match = 1;
#line 1800
  frame_size = frame_size >> 1;
#line 1802
  tmp = kmap(rx_buffer->page);
#line 1802
  data = (unsigned char *)tmp + (unsigned long )rx_buffer->page_offset;
  }
#line 1804
  if (((unsigned int )*(data + 3UL) != 255U || (unsigned int )*(data + (unsigned long )(frame_size + 10U)) != 190U) || (unsigned int )*(data + (unsigned long )(frame_size + 12U)) != 175U) {
#line 1807
    match = 0;
  } else {

  }
  {
#line 1809
  kunmap(rx_buffer->page);
  }
#line 1811
  return (match);
}
}
#line 1814 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring , struct ixgbe_ring *tx_ring ,
                                  unsigned int size ) 
{ 
  union ixgbe_adv_rx_desc *rx_desc ;
  struct ixgbe_rx_buffer *rx_buffer ;
  struct ixgbe_tx_buffer *tx_buffer ;
  u16 rx_ntc ;
  u16 tx_ntc ;
  u16 count ;
  unsigned int tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;
  __le32 tmp___2 ;
  struct netdev_queue *tmp___3 ;

  {
#line 1821
  count = 0U;
#line 1824
  rx_ntc = rx_ring->next_to_clean;
#line 1825
  tx_ntc = tx_ring->next_to_clean;
#line 1826
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )rx_ntc;
#line 1828
  goto ldv_52636;
  ldv_52635: 
  {
#line 1830
  rx_buffer = rx_ring->__annonCompField94.rx_buffer_info + (unsigned long )rx_ntc;
#line 1833
  tmp = ixgbe_rx_bufsz(rx_ring);
#line 1833
  dma_sync_single_for_cpu(rx_ring->dev, rx_buffer->dma, (size_t )tmp, 2);
#line 1839
  tmp___0 = ixgbe_check_lbtest_frame(rx_buffer, size);
  }
#line 1839
  if ((int )tmp___0) {
#line 1840
    count = (u16 )((int )count + 1);
  } else {

  }
  {
#line 1843
  tmp___1 = ixgbe_rx_bufsz(rx_ring);
#line 1843
  dma_sync_single_for_device(rx_ring->dev, rx_buffer->dma, (size_t )tmp___1, 2);
#line 1849
  tx_buffer = tx_ring->__annonCompField94.tx_buffer_info + (unsigned long )tx_ntc;
#line 1850
  ixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer);
#line 1853
  rx_ntc = (u16 )((int )rx_ntc + 1);
  }
#line 1854
  if ((int )rx_ntc == (int )rx_ring->count) {
#line 1855
    rx_ntc = 0U;
  } else {

  }
#line 1856
  tx_ntc = (u16 )((int )tx_ntc + 1);
#line 1857
  if ((int )tx_ntc == (int )tx_ring->count) {
#line 1858
    tx_ntc = 0U;
  } else {

  }
#line 1861
  rx_desc = (union ixgbe_adv_rx_desc *)rx_ring->desc + (unsigned long )rx_ntc;
  ldv_52636: 
  {
#line 1828
  tmp___2 = ixgbe_test_staterr(rx_desc, 1U);
  }
#line 1828
  if (tmp___2 != 0U) {
#line 1830
    goto ldv_52635;
  } else {

  }
  {
#line 1864
  tmp___3 = txring_txq((struct ixgbe_ring  const  *)tx_ring);
#line 1864
  netdev_tx_reset_queue(tmp___3);
#line 1867
  ixgbe_alloc_rx_buffers(rx_ring, (int )count);
#line 1868
  rx_ring->next_to_clean = rx_ntc;
#line 1869
  tx_ring->next_to_clean = tx_ntc;
  }
#line 1871
  return (count);
}
}
#line 1874 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_run_loopback_test(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring *tx_ring ;
  struct ixgbe_ring *rx_ring ;
  int i ;
  int j ;
  int lc ;
  int good_cnt ;
  int ret_val ;
  unsigned int size ;
  netdev_tx_t tx_ret_val ;
  struct sk_buff *skb ;
  u32 flags_orig ;
  u16 tmp ;

  {
  {
#line 1876
  tx_ring = & adapter->test_tx_ring;
#line 1877
  rx_ring = & adapter->test_rx_ring;
#line 1878
  ret_val = 0;
#line 1879
  size = 1024U;
#line 1882
  flags_orig = adapter->flags;
#line 1885
  adapter->flags = adapter->flags & 4294963199U;
#line 1888
  skb = alloc_skb(size, 208U);
  }
#line 1889
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1890
    return (11);
  } else {

  }
  {
#line 1893
  ixgbe_create_lbtest_frame(skb, size);
#line 1894
  skb_put(skb, size);
  }
#line 1902
  if ((int )rx_ring->count <= (int )tx_ring->count) {
#line 1903
    lc = (int )((unsigned int )tx_ring->count / 64U) * 2 + 1;
  } else {
#line 1905
    lc = (int )((unsigned int )rx_ring->count / 64U) * 2 + 1;
  }
#line 1907
  j = 0;
#line 1907
  goto ldv_52657;
  ldv_52656: 
#line 1909
  good_cnt = 0;
#line 1912
  i = 0;
#line 1912
  goto ldv_52653;
  ldv_52652: 
  {
#line 1913
  skb_get(skb);
#line 1914
  tx_ret_val = ixgbe_xmit_frame_ring(skb, adapter, tx_ring);
  }
#line 1917
  if ((int )tx_ret_val == 0) {
#line 1918
    good_cnt = good_cnt + 1;
  } else {

  }
#line 1912
  i = i + 1;
  ldv_52653: ;
#line 1912
  if (i <= 63) {
#line 1914
    goto ldv_52652;
  } else {

  }

#line 1921
  if (good_cnt != 64) {
#line 1922
    ret_val = 12;
#line 1923
    goto ldv_52655;
  } else {

  }
  {
#line 1927
  msleep(200U);
#line 1929
  tmp = ixgbe_clean_test_rings(rx_ring, tx_ring, size);
#line 1929
  good_cnt = (int )tmp;
  }
#line 1930
  if (good_cnt != 64) {
#line 1931
    ret_val = 13;
#line 1932
    goto ldv_52655;
  } else {

  }
#line 1907
  j = j + 1;
  ldv_52657: ;
#line 1907
  if (j <= lc) {
#line 1909
    goto ldv_52656;
  } else {

  }
  ldv_52655: 
  {
#line 1937
  kfree_skb(skb);
#line 1938
  adapter->flags = flags_orig;
  }
#line 1940
  return (ret_val);
}
}
#line 1943 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_loopback_test(struct ixgbe_adapter *adapter , u64 *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1945
  tmp = ixgbe_setup_desc_rings(adapter);
#line 1945
  *data = (u64 )tmp;
  }
#line 1946
  if (*data != 0ULL) {
#line 1947
    goto out;
  } else {

  }
  {
#line 1948
  tmp___0 = ixgbe_setup_loopback_test(adapter);
#line 1948
  *data = (u64 )tmp___0;
  }
#line 1949
  if (*data != 0ULL) {
#line 1950
    goto err_loopback;
  } else {

  }
  {
#line 1951
  tmp___1 = ixgbe_run_loopback_test(adapter);
#line 1951
  *data = (u64 )tmp___1;
#line 1952
  ixgbe_loopback_cleanup(adapter);
  }
  err_loopback: 
  {
#line 1955
  ixgbe_free_desc_rings(adapter);
  }
  out: ;
#line 1957
  return ((int )*data);
}
}
#line 1960 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_diag_test(struct net_device *netdev , struct ethtool_test *eth_test ,
                            u64 *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  bool if_running ;
  bool tmp___0 ;
  bool tmp___1 ;
  struct ixgbe_hw *hw ;
  int i ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1963
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1963
  adapter = (struct ixgbe_adapter *)tmp;
#line 1964
  tmp___0 = netif_running((struct net_device  const  *)netdev);
#line 1964
  if_running = tmp___0;
#line 1966
  tmp___1 = ixgbe_removed((void *)adapter->hw.hw_addr);
  }
#line 1966
  if ((int )tmp___1) {
#line 1967
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 1967
      netdev_err((struct net_device  const  *)adapter->netdev, "Adapter removed - test blocked\n");
      }
    } else {

    }
#line 1968
    *data = 1ULL;
#line 1969
    *(data + 1UL) = 1ULL;
#line 1970
    *(data + 2UL) = 1ULL;
#line 1971
    *(data + 3UL) = 1ULL;
#line 1972
    eth_test->flags = eth_test->flags | 2U;
#line 1973
    return;
  } else {

  }
  {
#line 1975
  set_bit(0L, (unsigned long volatile   *)(& adapter->state));
  }
#line 1976
  if (eth_test->flags == 1U) {
#line 1977
    hw = & adapter->hw;
#line 1979
    if ((adapter->flags & 8388608U) != 0U) {
#line 1981
      i = 0;
#line 1981
      goto ldv_52675;
      ldv_52674: ;
#line 1982
      if ((int )(adapter->vfinfo + (unsigned long )i)->clear_to_send) {
        {
#line 1983
        netdev_warn((struct net_device  const  *)netdev, "%s", (char *)"offline diagnostic is not supported when VFs are present\n");
#line 1987
        *data = 1ULL;
#line 1988
        *(data + 1UL) = 1ULL;
#line 1989
        *(data + 2UL) = 1ULL;
#line 1990
        *(data + 3UL) = 1ULL;
#line 1991
        eth_test->flags = eth_test->flags | 2U;
#line 1992
        clear_bit(0L, (unsigned long volatile   *)(& adapter->state));
        }
#line 1994
        goto skip_ol_tests;
      } else {

      }
#line 1981
      i = i + 1;
      ldv_52675: ;
#line 1981
      if ((unsigned int )i < adapter->num_vfs) {
#line 1983
        goto ldv_52674;
      } else {

      }

    } else {

    }
#line 2000
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 2000
      netdev_info((struct net_device  const  *)adapter->netdev, "offline testing starting\n");
      }
    } else {

    }
    {
#line 2005
    tmp___2 = ixgbe_link_test(adapter, data + 4UL);
    }
#line 2005
    if (tmp___2 != 0) {
#line 2006
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
#line 2008
    if ((int )if_running) {
      {
#line 2010
      dev_close(netdev);
      }
    } else {
      {
#line 2012
      ixgbe_reset(adapter);
      }
    }
#line 2014
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 2014
      netdev_info((struct net_device  const  *)adapter->netdev, "register testing starting\n");
      }
    } else {

    }
    {
#line 2015
    tmp___3 = ixgbe_reg_test(adapter, data);
    }
#line 2015
    if (tmp___3 != 0) {
#line 2016
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
    {
#line 2018
    ixgbe_reset(adapter);
    }
#line 2019
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 2019
      netdev_info((struct net_device  const  *)adapter->netdev, "eeprom testing starting\n");
      }
    } else {

    }
    {
#line 2020
    tmp___4 = ixgbe_eeprom_test(adapter, data + 1UL);
    }
#line 2020
    if (tmp___4 != 0) {
#line 2021
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
    {
#line 2023
    ixgbe_reset(adapter);
    }
#line 2024
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 2024
      netdev_info((struct net_device  const  *)adapter->netdev, "interrupt testing starting\n");
      }
    } else {

    }
    {
#line 2025
    tmp___5 = ixgbe_intr_test(adapter, data + 2UL);
    }
#line 2025
    if (tmp___5 != 0) {
#line 2026
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
#line 2030
    if ((adapter->flags & 8404992U) != 0U) {
#line 2032
      if (((int )adapter->msg_enable & 8192) != 0) {
        {
#line 2033
        netdev_info((struct net_device  const  *)adapter->netdev, "Skip MAC loopback diagnostic in VT mode\n");
        }
      } else {

      }
#line 2034
      *(data + 3UL) = 0ULL;
#line 2035
      goto skip_loopback;
    } else {

    }
    {
#line 2038
    ixgbe_reset(adapter);
    }
#line 2039
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 2039
      netdev_info((struct net_device  const  *)adapter->netdev, "loopback testing starting\n");
      }
    } else {

    }
    {
#line 2040
    tmp___6 = ixgbe_loopback_test(adapter, data + 3UL);
    }
#line 2040
    if (tmp___6 != 0) {
#line 2041
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
    skip_loopback: 
    {
#line 2044
    ixgbe_reset(adapter);
#line 2047
    clear_bit(0L, (unsigned long volatile   *)(& adapter->state));
    }
#line 2048
    if ((int )if_running) {
      {
#line 2049
      dev_open(netdev);
      }
    } else
#line 2050
    if ((unsigned long )hw->mac.ops.disable_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
      {
#line 2051
      (*(hw->mac.ops.disable_tx_laser))(hw);
      }
    } else {

    }
  } else {
#line 2053
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 2053
      netdev_info((struct net_device  const  *)adapter->netdev, "online testing starting\n");
      }
    } else {

    }
    {
#line 2056
    tmp___7 = ixgbe_link_test(adapter, data + 4UL);
    }
#line 2056
    if (tmp___7 != 0) {
#line 2057
      eth_test->flags = eth_test->flags | 2U;
    } else {

    }
    {
#line 2060
    *data = 0ULL;
#line 2061
    *(data + 1UL) = 0ULL;
#line 2062
    *(data + 2UL) = 0ULL;
#line 2063
    *(data + 3UL) = 0ULL;
#line 2065
    clear_bit(0L, (unsigned long volatile   *)(& adapter->state));
    }
  }
  skip_ol_tests: 
  {
#line 2069
  msleep_interruptible(4000U);
  }
#line 2070
  return;
}
}
#line 2072 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_wol_exclusion(struct ixgbe_adapter *adapter , struct ethtool_wolinfo *wol ) 
{ 
  struct ixgbe_hw *hw ;
  int retval ;
  int tmp ;

  {
  {
#line 2075
  hw = & adapter->hw;
#line 2076
  retval = 0;
#line 2079
  tmp = ixgbe_wol_supported(adapter, (int )hw->device_id, (int )hw->subsystem_device_id);
  }
#line 2079
  if (tmp == 0) {
#line 2081
    retval = 1;
#line 2082
    wol->supported = 0U;
  } else {

  }
#line 2085
  return (retval);
}
}
#line 2088 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2091
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2091
  adapter = (struct ixgbe_adapter *)tmp;
#line 2093
  wol->supported = 46U;
#line 2095
  wol->wolopts = 0U;
#line 2097
  tmp___0 = ixgbe_wol_exclusion(adapter, wol);
  }
#line 2097
  if (tmp___0 != 0) {
#line 2099
    return;
  } else {
    {
#line 2097
    tmp___1 = device_can_wakeup(& (adapter->pdev)->dev);
    }
#line 2097
    if (tmp___1) {
#line 2097
      tmp___2 = 0;
    } else {
#line 2097
      tmp___2 = 1;
    }
#line 2097
    if (tmp___2) {
#line 2099
      return;
    } else {

    }
  }
#line 2101
  if ((adapter->wol & 4U) != 0U) {
#line 2102
    wol->wolopts = wol->wolopts | 2U;
  } else {

  }
#line 2103
  if ((adapter->wol & 8U) != 0U) {
#line 2104
    wol->wolopts = wol->wolopts | 4U;
  } else {

  }
#line 2105
  if ((adapter->wol & 16U) != 0U) {
#line 2106
    wol->wolopts = wol->wolopts | 8U;
  } else {

  }
#line 2107
  if ((adapter->wol & 2U) != 0U) {
#line 2108
    wol->wolopts = wol->wolopts | 32U;
  } else {

  }
#line 2109
  return;
}
}
#line 2111 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 2113
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2113
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 2115
  if ((wol->wolopts & 81U) != 0U) {
#line 2116
    return (-95);
  } else {

  }
  {
#line 2118
  tmp___0 = ixgbe_wol_exclusion(adapter, wol);
  }
#line 2118
  if (tmp___0 != 0) {
#line 2119
    return (wol->wolopts != 0U ? -95 : 0);
  } else {

  }
#line 2121
  adapter->wol = 0U;
#line 2123
  if ((wol->wolopts & 2U) != 0U) {
#line 2124
    adapter->wol = adapter->wol | 4U;
  } else {

  }
#line 2125
  if ((wol->wolopts & 4U) != 0U) {
#line 2126
    adapter->wol = adapter->wol | 8U;
  } else {

  }
#line 2127
  if ((wol->wolopts & 8U) != 0U) {
#line 2128
    adapter->wol = adapter->wol | 16U;
  } else {

  }
#line 2129
  if ((wol->wolopts & 32U) != 0U) {
#line 2130
    adapter->wol = adapter->wol | 2U;
  } else {

  }
  {
#line 2132
  device_set_wakeup_enable(& (adapter->pdev)->dev, adapter->wol != 0U);
  }
#line 2134
  return (0);
}
}
#line 2137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_nway_reset(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
  {
#line 2139
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2139
  adapter = (struct ixgbe_adapter *)tmp;
#line 2141
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 2141
  if ((int )tmp___0) {
    {
#line 2142
    ixgbe_reinit_locked(adapter);
    }
  } else {

  }
#line 2144
  return (0);
}
}
#line 2147 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_phys_id(struct net_device *netdev , enum ethtool_phys_id_state state ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;

  {
  {
#line 2150
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2150
  adapter = (struct ixgbe_adapter *)tmp;
#line 2151
  hw = & adapter->hw;
  }
  {
#line 2154
  if ((unsigned int )state == 1U) {
#line 2154
    goto case_1;
  } else {

  }
#line 2158
  if ((unsigned int )state == 2U) {
#line 2158
    goto case_2;
  } else {

  }
#line 2162
  if ((unsigned int )state == 3U) {
#line 2162
    goto case_3;
  } else {

  }
#line 2166
  if ((unsigned int )state == 0U) {
#line 2166
    goto case_0;
  } else {

  }
#line 2153
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2155
  adapter->led_reg = ixgbe_read_reg(hw, 512U);
  }
#line 2156
  return (2);
  case_2: /* CIL Label */ 
  {
#line 2159
  (*(hw->mac.ops.led_on))(hw, 14U);
  }
#line 2160
  goto ldv_52706;
  case_3: /* CIL Label */ 
  {
#line 2163
  (*(hw->mac.ops.led_off))(hw, 14U);
  }
#line 2164
  goto ldv_52706;
  case_0: /* CIL Label */ 
  {
#line 2168
  ixgbe_write_reg(& adapter->hw, 512U, adapter->led_reg);
  }
#line 2169
  goto ldv_52706;
  switch_break: /* CIL Label */ ;
  }
  ldv_52706: ;
#line 2172
  return (0);
}
}
#line 2175 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_coalesce(struct net_device *netdev , struct ethtool_coalesce *ec ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 2178
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2178
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 2181
  if ((unsigned int )adapter->rx_itr_setting <= 1U) {
#line 2182
    ec->rx_coalesce_usecs = (__u32 )adapter->rx_itr_setting;
  } else {
#line 2184
    ec->rx_coalesce_usecs = (__u32 )((int )adapter->rx_itr_setting >> 2);
  }
#line 2187
  if ((unsigned int )(adapter->q_vector[0])->tx.count != 0U && (unsigned int )(adapter->q_vector[0])->rx.count != 0U) {
#line 2188
    return (0);
  } else {

  }
#line 2191
  if ((unsigned int )adapter->tx_itr_setting <= 1U) {
#line 2192
    ec->tx_coalesce_usecs = (__u32 )adapter->tx_itr_setting;
  } else {
#line 2194
    ec->tx_coalesce_usecs = (__u32 )((int )adapter->tx_itr_setting >> 2);
  }
#line 2196
  return (0);
}
}
#line 2203 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static bool ixgbe_update_rsc(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;

  {
#line 2205
  netdev = adapter->netdev;
#line 2208
  if ((adapter->flags2 & 1U) == 0U || (netdev->features & 32768ULL) == 0ULL) {
#line 2210
    return (0);
  } else {

  }
#line 2213
  if ((unsigned int )adapter->rx_itr_setting == 1U || (unsigned int )adapter->rx_itr_setting > 24U) {
#line 2215
    if ((adapter->flags2 & 2U) == 0U) {
#line 2216
      adapter->flags2 = adapter->flags2 | 2U;
#line 2217
      if (((int )adapter->msg_enable & 2) != 0) {
        {
#line 2218
        netdev_info((struct net_device  const  *)adapter->netdev, "rx-usecs value high enough to re-enable RSC\n");
        }
      } else {

      }
#line 2219
      return (1);
    } else {

    }
  } else
#line 2222
  if ((adapter->flags2 & 2U) != 0U) {
#line 2223
    adapter->flags2 = adapter->flags2 & 4294967293U;
#line 2224
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 2224
      netdev_info((struct net_device  const  *)adapter->netdev, "rx-usecs set too low, disabling RSC\n");
      }
    } else {

    }
#line 2225
    return (1);
  } else {

  }
#line 2227
  return (0);
}
}
#line 2230 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_coalesce(struct net_device *netdev , struct ethtool_coalesce *ec ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_q_vector *q_vector ;
  int i ;
  u16 tx_itr_param ;
  u16 rx_itr_param ;
  u16 tx_itr_prev ;
  bool need_reset ;
  bool tmp___0 ;

  {
  {
#line 2233
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2233
  adapter = (struct ixgbe_adapter *)tmp;
#line 2237
  need_reset = 0;
  }
#line 2239
  if ((unsigned int )(adapter->q_vector[0])->tx.count != 0U && (unsigned int )(adapter->q_vector[0])->rx.count != 0U) {
#line 2241
    if (ec->tx_coalesce_usecs != 0U) {
#line 2242
      return (-22);
    } else {

    }
#line 2243
    tx_itr_prev = adapter->rx_itr_setting;
  } else {
#line 2245
    tx_itr_prev = adapter->tx_itr_setting;
  }
#line 2248
  if (ec->rx_coalesce_usecs > 1022U || ec->tx_coalesce_usecs > 1022U) {
#line 2250
    return (-22);
  } else {

  }
#line 2252
  if (ec->rx_coalesce_usecs > 1U) {
#line 2253
    adapter->rx_itr_setting = (int )((u16 )ec->rx_coalesce_usecs) << 2U;
  } else {
#line 2255
    adapter->rx_itr_setting = (u16 )ec->rx_coalesce_usecs;
  }
#line 2257
  if ((unsigned int )adapter->rx_itr_setting == 1U) {
#line 2258
    rx_itr_param = 200U;
  } else {
#line 2260
    rx_itr_param = adapter->rx_itr_setting;
  }
#line 2262
  if (ec->tx_coalesce_usecs > 1U) {
#line 2263
    adapter->tx_itr_setting = (int )((u16 )ec->tx_coalesce_usecs) << 2U;
  } else {
#line 2265
    adapter->tx_itr_setting = (u16 )ec->tx_coalesce_usecs;
  }
#line 2267
  if ((unsigned int )adapter->tx_itr_setting == 1U) {
#line 2268
    tx_itr_param = 400U;
  } else {
#line 2270
    tx_itr_param = adapter->tx_itr_setting;
  }
#line 2273
  if ((unsigned int )(adapter->q_vector[0])->tx.count != 0U && (unsigned int )(adapter->q_vector[0])->rx.count != 0U) {
#line 2274
    adapter->tx_itr_setting = adapter->rx_itr_setting;
  } else {

  }
#line 2278
  if ((unsigned int )adapter->tx_itr_setting != 1U && (unsigned int )adapter->tx_itr_setting <= 39U) {
#line 2280
    if ((unsigned int )tx_itr_prev == 1U || (unsigned int )tx_itr_prev > 39U) {
#line 2282
      need_reset = 1;
    } else {

    }
  } else
#line 2284
  if ((unsigned int )tx_itr_prev != 1U && (unsigned int )tx_itr_prev <= 39U) {
#line 2286
    need_reset = 1;
  } else {

  }
  {
#line 2290
  tmp___0 = ixgbe_update_rsc(adapter);
#line 2290
  need_reset = ((int )need_reset | (int )tmp___0) != 0;
#line 2292
  i = 0;
  }
#line 2292
  goto ldv_52730;
  ldv_52729: 
#line 2293
  q_vector = adapter->q_vector[i];
#line 2294
  if ((unsigned int )q_vector->tx.count != 0U && (unsigned int )q_vector->rx.count == 0U) {
#line 2296
    q_vector->itr = tx_itr_param;
  } else {
#line 2299
    q_vector->itr = rx_itr_param;
  }
  {
#line 2300
  ixgbe_write_eitr(q_vector);
#line 2292
  i = i + 1;
  }
  ldv_52730: ;
#line 2292
  if (i < adapter->num_q_vectors) {
#line 2294
    goto ldv_52729;
  } else {

  }

#line 2308
  if ((int )need_reset) {
    {
#line 2309
    ixgbe_do_reset(netdev);
    }
  } else {

  }
#line 2311
  return (0);
}
}
#line 2314 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  union ixgbe_atr_input *mask ;
  struct ethtool_rx_flow_spec *fsp ;
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *rule ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
#line 2317
  mask = & adapter->fdir_mask;
#line 2318
  fsp = & cmd->fs;
#line 2321
  rule = (struct ixgbe_fdir_filter *)0;
#line 2324
  cmd->data = (__u64 )((1024 << (int )adapter->fdir_pballoc) + -2);
#line 2326
  ____ptr = adapter->fdir_filter_list.first;
#line 2326
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 2326
    __mptr = (struct hlist_node  const  *)____ptr;
#line 2326
    tmp = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 2326
    tmp = (struct ixgbe_fdir_filter *)0;
  }
#line 2326
  rule = tmp;
#line 2326
  goto ldv_52751;
  ldv_52750: ;
#line 2328
  if (fsp->location <= (__u32 )rule->sw_idx) {
#line 2329
    goto ldv_52749;
  } else {

  }
#line 2326
  ____ptr___0 = node2;
#line 2326
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 2326
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 2326
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 2326
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 2326
  rule = tmp___0;
  ldv_52751: ;
#line 2326
  if ((unsigned long )rule != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2326
    node2 = rule->fdir_node.next;
#line 2328
    goto ldv_52750;
  } else {

  }
  ldv_52749: ;
#line 2332
  if ((unsigned long )rule == (unsigned long )((struct ixgbe_fdir_filter *)0) || fsp->location != (__u32 )rule->sw_idx) {
#line 2333
    return (-22);
  } else {

  }
  {
#line 2339
  if ((int )rule->filter.formatted.flow_type == 2) {
#line 2339
    goto case_2;
  } else {

  }
#line 2342
  if ((int )rule->filter.formatted.flow_type == 1) {
#line 2342
    goto case_1;
  } else {

  }
#line 2345
  if ((int )rule->filter.formatted.flow_type == 3) {
#line 2345
    goto case_3;
  } else {

  }
#line 2348
  if ((int )rule->filter.formatted.flow_type == 0) {
#line 2348
    goto case_0;
  } else {

  }
#line 2354
  goto switch_default;
  case_2: /* CIL Label */ 
#line 2340
  fsp->flow_type = 1U;
#line 2341
  goto ldv_52753;
  case_1: /* CIL Label */ 
#line 2343
  fsp->flow_type = 2U;
#line 2344
  goto ldv_52753;
  case_3: /* CIL Label */ 
#line 2346
  fsp->flow_type = 3U;
#line 2347
  goto ldv_52753;
  case_0: /* CIL Label */ 
#line 2349
  fsp->flow_type = 13U;
#line 2350
  fsp->h_u.usr_ip4_spec.ip_ver = 1U;
#line 2351
  fsp->h_u.usr_ip4_spec.proto = 0U;
#line 2352
  fsp->m_u.usr_ip4_spec.proto = 0U;
#line 2353
  goto ldv_52753;
  switch_default: /* CIL Label */ ;
#line 2355
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_52753: 
  {
#line 2358
  fsp->h_u.tcp_ip4_spec.psrc = rule->filter.formatted.src_port;
#line 2359
  fsp->m_u.tcp_ip4_spec.psrc = mask->formatted.src_port;
#line 2360
  fsp->h_u.tcp_ip4_spec.pdst = rule->filter.formatted.dst_port;
#line 2361
  fsp->m_u.tcp_ip4_spec.pdst = mask->formatted.dst_port;
#line 2362
  fsp->h_u.tcp_ip4_spec.ip4src = rule->filter.formatted.src_ip[0];
#line 2363
  fsp->m_u.tcp_ip4_spec.ip4src = mask->formatted.src_ip[0];
#line 2364
  fsp->h_u.tcp_ip4_spec.ip4dst = rule->filter.formatted.dst_ip[0];
#line 2365
  fsp->m_u.tcp_ip4_spec.ip4dst = mask->formatted.dst_ip[0];
#line 2366
  fsp->h_ext.vlan_tci = rule->filter.formatted.vlan_id;
#line 2367
  fsp->m_ext.vlan_tci = mask->formatted.vlan_id;
#line 2368
  fsp->h_ext.vlan_etype = rule->filter.formatted.flex_bytes;
#line 2369
  fsp->m_ext.vlan_etype = mask->formatted.flex_bytes;
#line 2370
  tmp___1 = __fswab32((__u32 )rule->filter.formatted.vm_pool);
#line 2370
  fsp->h_ext.data[1] = tmp___1;
#line 2371
  tmp___2 = __fswab32((__u32 )mask->formatted.vm_pool);
#line 2371
  fsp->m_ext.data[1] = tmp___2;
#line 2372
  fsp->flow_type = fsp->flow_type | 2147483648U;
  }
#line 2375
  if ((unsigned int )rule->action == 127U) {
#line 2376
    fsp->ring_cookie = 0xffffffffffffffffULL;
  } else {
#line 2378
    fsp->ring_cookie = (__u64 )rule->action;
  }
#line 2380
  return (0);
}
}
#line 2383 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ethtool_fdir_all(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ,
                                      u32 *rule_locs ) 
{ 
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *rule ;
  int cnt ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___0 ;

  {
#line 2389
  cnt = 0;
#line 2392
  cmd->data = (__u64 )((1024 << (int )adapter->fdir_pballoc) + -2);
#line 2394
  ____ptr = adapter->fdir_filter_list.first;
#line 2394
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 2394
    __mptr = (struct hlist_node  const  *)____ptr;
#line 2394
    tmp = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 2394
    tmp = (struct ixgbe_fdir_filter *)0;
  }
#line 2394
  rule = tmp;
#line 2394
  goto ldv_52776;
  ldv_52775: ;
#line 2396
  if ((__u32 )cnt == cmd->rule_cnt) {
#line 2397
    return (-90);
  } else {

  }
#line 2398
  *(rule_locs + (unsigned long )cnt) = (u32 )rule->sw_idx;
#line 2399
  cnt = cnt + 1;
#line 2394
  ____ptr___0 = node2;
#line 2394
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 2394
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 2394
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 2394
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 2394
  rule = tmp___0;
  ldv_52776: ;
#line 2394
  if ((unsigned long )rule != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2394
    node2 = rule->fdir_node.next;
#line 2396
    goto ldv_52775;
  } else {

  }
#line 2402
  cmd->rule_cnt = (__u32 )cnt;
#line 2404
  return (0);
}
}
#line 2407 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 


  {
#line 2410
  cmd->data = 0ULL;
  {
#line 2414
  if (cmd->flow_type == 1U) {
#line 2414
    goto case_1;
  } else {

  }
#line 2416
  if (cmd->flow_type == 2U) {
#line 2416
    goto case_2;
  } else {

  }
#line 2419
  if (cmd->flow_type == 3U) {
#line 2419
    goto case_3;
  } else {

  }
#line 2420
  if (cmd->flow_type == 4U) {
#line 2420
    goto case_4;
  } else {

  }
#line 2421
  if (cmd->flow_type == 9U) {
#line 2421
    goto case_9;
  } else {

  }
#line 2422
  if (cmd->flow_type == 10U) {
#line 2422
    goto case_10;
  } else {

  }
#line 2423
  if (cmd->flow_type == 16U) {
#line 2423
    goto case_16;
  } else {

  }
#line 2426
  if (cmd->flow_type == 5U) {
#line 2426
    goto case_5;
  } else {

  }
#line 2428
  if (cmd->flow_type == 6U) {
#line 2428
    goto case_6;
  } else {

  }
#line 2431
  if (cmd->flow_type == 7U) {
#line 2431
    goto case_7;
  } else {

  }
#line 2432
  if (cmd->flow_type == 8U) {
#line 2432
    goto case_8;
  } else {

  }
#line 2433
  if (cmd->flow_type == 11U) {
#line 2433
    goto case_11;
  } else {

  }
#line 2434
  if (cmd->flow_type == 12U) {
#line 2434
    goto case_12;
  } else {

  }
#line 2435
  if (cmd->flow_type == 17U) {
#line 2435
    goto case_17;
  } else {

  }
#line 2438
  goto switch_default;
  case_1: /* CIL Label */ 
#line 2415
  cmd->data = cmd->data | 192ULL;
  case_2: /* CIL Label */ ;
#line 2417
  if ((adapter->flags2 & 256U) != 0U) {
#line 2418
    cmd->data = cmd->data | 192ULL;
  } else {

  }
  case_3: /* CIL Label */ ;
  case_4: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_16: /* CIL Label */ 
#line 2424
  cmd->data = cmd->data | 48ULL;
#line 2425
  goto ldv_52789;
  case_5: /* CIL Label */ 
#line 2427
  cmd->data = cmd->data | 192ULL;
  case_6: /* CIL Label */ ;
#line 2429
  if ((adapter->flags2 & 512U) != 0U) {
#line 2430
    cmd->data = cmd->data | 192ULL;
  } else {

  }
  case_7: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_11: /* CIL Label */ ;
  case_12: /* CIL Label */ ;
  case_17: /* CIL Label */ 
#line 2436
  cmd->data = cmd->data | 48ULL;
#line 2437
  goto ldv_52789;
  switch_default: /* CIL Label */ ;
#line 2439
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_52789: ;
#line 2442
  return (0);
}
}
#line 2445 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_rxnfc(struct net_device *dev , struct ethtool_rxnfc *cmd , u32 *rule_locs ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int ret ;

  {
  {
#line 2448
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2448
  adapter = (struct ixgbe_adapter *)tmp;
#line 2449
  ret = -95;
  }
  {
#line 2452
  if (cmd->cmd == 45U) {
#line 2452
    goto case_45;
  } else {

  }
#line 2456
  if (cmd->cmd == 46U) {
#line 2456
    goto case_46;
  } else {

  }
#line 2460
  if (cmd->cmd == 47U) {
#line 2460
    goto case_47;
  } else {

  }
#line 2463
  if (cmd->cmd == 48U) {
#line 2463
    goto case_48;
  } else {

  }
#line 2466
  if (cmd->cmd == 41U) {
#line 2466
    goto case_41;
  } else {

  }
#line 2469
  goto switch_default;
  case_45: /* CIL Label */ 
#line 2453
  cmd->data = (__u64 )adapter->num_rx_queues;
#line 2454
  ret = 0;
#line 2455
  goto ldv_52806;
  case_46: /* CIL Label */ 
#line 2457
  cmd->rule_cnt = (__u32 )adapter->fdir_filter_count;
#line 2458
  ret = 0;
#line 2459
  goto ldv_52806;
  case_47: /* CIL Label */ 
  {
#line 2461
  ret = ixgbe_get_ethtool_fdir_entry(adapter, cmd);
  }
#line 2462
  goto ldv_52806;
  case_48: /* CIL Label */ 
  {
#line 2464
  ret = ixgbe_get_ethtool_fdir_all(adapter, cmd, rule_locs);
  }
#line 2465
  goto ldv_52806;
  case_41: /* CIL Label */ 
  {
#line 2467
  ret = ixgbe_get_rss_hash_opts(adapter, cmd);
  }
#line 2468
  goto ldv_52806;
  switch_default: /* CIL Label */ ;
#line 2470
  goto ldv_52806;
  switch_break: /* CIL Label */ ;
  }
  ldv_52806: ;
#line 2473
  return (ret);
}
}
#line 2476 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter , struct ixgbe_fdir_filter *input ,
                                           u16 sw_idx ) 
{ 
  struct ixgbe_hw *hw ;
  struct hlist_node *node2 ;
  struct ixgbe_fdir_filter *rule ;
  struct ixgbe_fdir_filter *parent ;
  int err ;
  struct hlist_node *____ptr ;
  struct hlist_node  const  *__mptr ;
  struct ixgbe_fdir_filter *tmp ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node  const  *__mptr___0 ;
  struct ixgbe_fdir_filter *tmp___0 ;

  {
#line 2480
  hw = & adapter->hw;
#line 2483
  err = -22;
#line 2485
  parent = (struct ixgbe_fdir_filter *)0;
#line 2486
  rule = (struct ixgbe_fdir_filter *)0;
#line 2488
  ____ptr = adapter->fdir_filter_list.first;
#line 2488
  if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 2488
    __mptr = (struct hlist_node  const  *)____ptr;
#line 2488
    tmp = (struct ixgbe_fdir_filter *)__mptr;
  } else {
#line 2488
    tmp = (struct ixgbe_fdir_filter *)0;
  }
#line 2488
  rule = tmp;
#line 2488
  goto ldv_52833;
  ldv_52832: ;
#line 2491
  if ((int )rule->sw_idx >= (int )sw_idx) {
#line 2492
    goto ldv_52831;
  } else {

  }
#line 2493
  parent = rule;
#line 2488
  ____ptr___0 = node2;
#line 2488
  if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 2488
    __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 2488
    tmp___0 = (struct ixgbe_fdir_filter *)__mptr___0;
  } else {
#line 2488
    tmp___0 = (struct ixgbe_fdir_filter *)0;
  }
#line 2488
  rule = tmp___0;
  ldv_52833: ;
#line 2488
  if ((unsigned long )rule != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2488
    node2 = rule->fdir_node.next;
#line 2490
    goto ldv_52832;
  } else {

  }
  ldv_52831: ;
#line 2497
  if ((unsigned long )rule != (unsigned long )((struct ixgbe_fdir_filter *)0) && (int )rule->sw_idx == (int )sw_idx) {
#line 2498
    if ((unsigned long )input == (unsigned long )((struct ixgbe_fdir_filter *)0) || (int )rule->filter.formatted.bkt_hash != (int )input->filter.formatted.bkt_hash) {
      {
#line 2500
      err = ixgbe_fdir_erase_perfect_filter_82599(hw, & rule->filter, (int )sw_idx);
      }
    } else {

    }
    {
#line 2505
    hlist_del(& rule->fdir_node);
#line 2506
    kfree((void const   *)rule);
#line 2507
    adapter->fdir_filter_count = adapter->fdir_filter_count - 1;
    }
  } else {

  }
#line 2514
  if ((unsigned long )input == (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2515
    return (err);
  } else {

  }
  {
#line 2518
  INIT_HLIST_NODE(& input->fdir_node);
  }
#line 2521
  if ((unsigned long )parent != (unsigned long )((struct ixgbe_fdir_filter *)0)) {
    {
#line 2522
    hlist_add_after(& parent->fdir_node, & input->fdir_node);
    }
  } else {
    {
#line 2524
    hlist_add_head(& input->fdir_node, & adapter->fdir_filter_list);
    }
  }
#line 2528
  adapter->fdir_filter_count = adapter->fdir_filter_count + 1;
#line 2530
  return (0);
}
}
#line 2533 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp , u8 *flow_type ) 
{ 


  {
  {
#line 2537
  if ((fsp->flow_type & 2147483647U) == 1U) {
#line 2537
    goto case_1;
  } else {

  }
#line 2540
  if ((fsp->flow_type & 2147483647U) == 2U) {
#line 2540
    goto case_2;
  } else {

  }
#line 2543
  if ((fsp->flow_type & 2147483647U) == 3U) {
#line 2543
    goto case_3;
  } else {

  }
#line 2546
  if ((fsp->flow_type & 2147483647U) == 13U) {
#line 2546
    goto case_13;
  } else {

  }
#line 2566
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 2538
  *flow_type = 2U;
#line 2539
  goto ldv_52839;
  case_2: /* CIL Label */ 
#line 2541
  *flow_type = 1U;
#line 2542
  goto ldv_52839;
  case_3: /* CIL Label */ 
#line 2544
  *flow_type = 3U;
#line 2545
  goto ldv_52839;
  case_13: /* CIL Label */ ;
  {
#line 2548
  if ((int )fsp->h_u.usr_ip4_spec.proto == 6) {
#line 2548
    goto case_6;
  } else {

  }
#line 2551
  if ((int )fsp->h_u.usr_ip4_spec.proto == 17) {
#line 2551
    goto case_17;
  } else {

  }
#line 2554
  if ((int )fsp->h_u.usr_ip4_spec.proto == 132) {
#line 2554
    goto case_132;
  } else {

  }
#line 2557
  if ((int )fsp->h_u.usr_ip4_spec.proto == 0) {
#line 2557
    goto case_0;
  } else {

  }
#line 2562
  goto switch_default;
  case_6: /* CIL Label */ 
#line 2549
  *flow_type = 2U;
#line 2550
  goto ldv_52844;
  case_17: /* CIL Label */ 
#line 2552
  *flow_type = 1U;
#line 2553
  goto ldv_52844;
  case_132: /* CIL Label */ 
#line 2555
  *flow_type = 3U;
#line 2556
  goto ldv_52844;
  case_0: /* CIL Label */ ;
#line 2558
  if ((unsigned int )fsp->m_u.usr_ip4_spec.proto == 0U) {
#line 2559
    *flow_type = 0U;
#line 2560
    goto ldv_52844;
  } else {

  }
  switch_default: /* CIL Label */ ;
#line 2563
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  ldv_52844: ;
#line 2565
  goto ldv_52839;
  switch_default___0: /* CIL Label */ ;
#line 2567
  return (0);
  switch_break: /* CIL Label */ ;
  }
  ldv_52839: ;
#line 2570
  return (1);
}
}
#line 2573 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  struct ethtool_rx_flow_spec *fsp ;
  struct ixgbe_hw *hw ;
  struct ixgbe_fdir_filter *input ;
  union ixgbe_atr_input mask ;
  int err ;
  void *tmp ;
  int tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2576
  fsp = & cmd->fs;
#line 2578
  hw = & adapter->hw;
#line 2583
  if ((adapter->flags & 524288U) == 0U) {
#line 2584
    return (-95);
  } else {

  }
#line 2590
  if (fsp->ring_cookie != 0xffffffffffffffffULL && fsp->ring_cookie >= (__u64 )adapter->num_rx_queues) {
#line 2592
    return (-22);
  } else {

  }
#line 2595
  if (fsp->location >= (__u32 )((1024 << (int )adapter->fdir_pballoc) + -2)) {
#line 2596
    if ((int )adapter->msg_enable & 1) {
      {
#line 2596
      netdev_err((struct net_device  const  *)adapter->netdev, "Location out of range\n");
      }
    } else {

    }
#line 2597
    return (-22);
  } else {

  }
  {
#line 2600
  tmp = kzalloc(64UL, 32U);
#line 2600
  input = (struct ixgbe_fdir_filter *)tmp;
  }
#line 2601
  if ((unsigned long )input == (unsigned long )((struct ixgbe_fdir_filter *)0)) {
#line 2602
    return (-12);
  } else {

  }
  {
#line 2604
  memset((void *)(& mask), 0, 44UL);
#line 2607
  input->sw_idx = (u16 )fsp->location;
#line 2610
  tmp___0 = ixgbe_flowspec_to_flow_type(fsp, & input->filter.formatted.flow_type);
  }
#line 2610
  if (tmp___0 == 0) {
#line 2612
    if ((int )adapter->msg_enable & 1) {
      {
#line 2612
      netdev_err((struct net_device  const  *)adapter->netdev, "Unrecognized flow type\n");
      }
    } else {

    }
#line 2613
    goto err_out;
  } else {

  }
#line 2616
  mask.formatted.flow_type = 7U;
#line 2619
  if ((unsigned int )input->filter.formatted.flow_type == 0U) {
#line 2620
    mask.formatted.flow_type = (unsigned int )mask.formatted.flow_type & 4U;
  } else {

  }
#line 2623
  input->filter.formatted.src_ip[0] = fsp->h_u.tcp_ip4_spec.ip4src;
#line 2624
  mask.formatted.src_ip[0] = fsp->m_u.tcp_ip4_spec.ip4src;
#line 2625
  input->filter.formatted.dst_ip[0] = fsp->h_u.tcp_ip4_spec.ip4dst;
#line 2626
  mask.formatted.dst_ip[0] = fsp->m_u.tcp_ip4_spec.ip4dst;
#line 2627
  input->filter.formatted.src_port = fsp->h_u.tcp_ip4_spec.psrc;
#line 2628
  mask.formatted.src_port = fsp->m_u.tcp_ip4_spec.psrc;
#line 2629
  input->filter.formatted.dst_port = fsp->h_u.tcp_ip4_spec.pdst;
#line 2630
  mask.formatted.dst_port = fsp->m_u.tcp_ip4_spec.pdst;
#line 2632
  if ((int )fsp->flow_type < 0) {
    {
#line 2633
    tmp___1 = __fswab32(fsp->h_ext.data[1]);
#line 2633
    input->filter.formatted.vm_pool = (unsigned char )tmp___1;
#line 2635
    tmp___2 = __fswab32(fsp->m_ext.data[1]);
#line 2635
    mask.formatted.vm_pool = (unsigned char )tmp___2;
#line 2637
    input->filter.formatted.vlan_id = fsp->h_ext.vlan_tci;
#line 2638
    mask.formatted.vlan_id = fsp->m_ext.vlan_tci;
#line 2639
    input->filter.formatted.flex_bytes = fsp->h_ext.vlan_etype;
#line 2641
    mask.formatted.flex_bytes = fsp->m_ext.vlan_etype;
    }
  } else {

  }
#line 2645
  if (fsp->ring_cookie == 0xffffffffffffffffULL) {
#line 2646
    input->action = 127U;
  } else {
#line 2648
    input->action = (u16 )fsp->ring_cookie;
  }
  {
#line 2650
  spin_lock(& adapter->fdir_perfect_lock);
#line 2652
  tmp___4 = hlist_empty((struct hlist_head  const  *)(& adapter->fdir_filter_list));
  }
#line 2652
  if (tmp___4 != 0) {
    {
#line 2654
    memcpy((void *)(& adapter->fdir_mask), (void const   *)(& mask), 44UL);
#line 2655
    err = ixgbe_fdir_set_input_mask_82599(hw, & mask);
    }
#line 2656
    if (err != 0) {
#line 2657
      if ((int )adapter->msg_enable & 1) {
        {
#line 2657
        netdev_err((struct net_device  const  *)adapter->netdev, "Error writing mask\n");
        }
      } else {

      }
#line 2658
      goto err_out_w_lock;
    } else {

    }
  } else {
    {
#line 2660
    tmp___3 = memcmp((void const   *)(& adapter->fdir_mask), (void const   *)(& mask),
                     44UL);
    }
#line 2660
    if (tmp___3 != 0) {
#line 2661
      if ((int )adapter->msg_enable & 1) {
        {
#line 2661
        netdev_err((struct net_device  const  *)adapter->netdev, "Only one mask supported per port\n");
        }
      } else {

      }
#line 2662
      goto err_out_w_lock;
    } else {

    }
  }
  {
#line 2666
  ixgbe_atr_compute_perfect_hash_82599(& input->filter, & mask);
#line 2669
  err = ixgbe_fdir_write_perfect_filter_82599(hw, & input->filter, (int )input->sw_idx,
                                              (unsigned int )input->action != 127U ? (int )(adapter->rx_ring[(int )input->action])->reg_idx : 127);
  }
#line 2674
  if (err != 0) {
#line 2675
    goto err_out_w_lock;
  } else {

  }
  {
#line 2677
  ixgbe_update_ethtool_fdir_entry(adapter, input, (int )input->sw_idx);
#line 2679
  spin_unlock(& adapter->fdir_perfect_lock);
  }
#line 2681
  return (err);
  err_out_w_lock: 
  {
#line 2683
  spin_unlock(& adapter->fdir_perfect_lock);
  }
  err_out: 
  {
#line 2685
  kfree((void const   *)input);
  }
#line 2686
  return (-22);
}
}
#line 2689 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_del_ethtool_fdir_entry(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  struct ethtool_rx_flow_spec *fsp ;
  int err ;

  {
  {
#line 2692
  fsp = & cmd->fs;
#line 2696
  spin_lock(& adapter->fdir_perfect_lock);
#line 2697
  err = ixgbe_update_ethtool_fdir_entry(adapter, (struct ixgbe_fdir_filter *)0, (int )((u16 )fsp->location));
#line 2698
  spin_unlock(& adapter->fdir_perfect_lock);
  }
#line 2700
  return (err);
}
}
#line 2705 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_rss_hash_opt(struct ixgbe_adapter *adapter , struct ethtool_rxnfc *nfc ) 
{ 
  u32 flags2 ;
  struct ixgbe_hw *hw ;
  u32 mrqc ;
  u32 tmp ;

  {
#line 2708
  flags2 = adapter->flags2;
#line 2714
  if ((nfc->data & 0xffffffffffffff0fULL) != 0ULL) {
#line 2716
    return (-22);
  } else {

  }
  {
#line 2719
  if (nfc->flow_type == 1U) {
#line 2719
    goto case_1;
  } else {

  }
#line 2720
  if (nfc->flow_type == 5U) {
#line 2720
    goto case_5;
  } else {

  }
#line 2727
  if (nfc->flow_type == 2U) {
#line 2727
    goto case_2;
  } else {

  }
#line 2742
  if (nfc->flow_type == 6U) {
#line 2742
    goto case_6;
  } else {

  }
#line 2757
  if (nfc->flow_type == 4U) {
#line 2757
    goto case_4;
  } else {

  }
#line 2758
  if (nfc->flow_type == 9U) {
#line 2758
    goto case_9;
  } else {

  }
#line 2759
  if (nfc->flow_type == 10U) {
#line 2759
    goto case_10;
  } else {

  }
#line 2760
  if (nfc->flow_type == 3U) {
#line 2760
    goto case_3;
  } else {

  }
#line 2761
  if (nfc->flow_type == 8U) {
#line 2761
    goto case_8;
  } else {

  }
#line 2762
  if (nfc->flow_type == 11U) {
#line 2762
    goto case_11;
  } else {

  }
#line 2763
  if (nfc->flow_type == 12U) {
#line 2763
    goto case_12;
  } else {

  }
#line 2764
  if (nfc->flow_type == 7U) {
#line 2764
    goto case_7;
  } else {

  }
#line 2771
  goto switch_default___1;
  case_1: /* CIL Label */ ;
  case_5: /* CIL Label */ ;
#line 2721
  if (*((unsigned long *)nfc + 1UL) != 240UL) {
#line 2725
    return (-22);
  } else {

  }
#line 2726
  goto ldv_52874;
  case_2: /* CIL Label */ ;
#line 2728
  if (*((unsigned long *)nfc + 1UL) != 48UL) {
#line 2730
    return (-22);
  } else {

  }
  {
#line 2732
  if ((nfc->data & 192ULL) == 0ULL) {
#line 2732
    goto case_0;
  } else {

  }
#line 2735
  if ((nfc->data & 192ULL) == 192ULL) {
#line 2735
    goto case_192;
  } else {

  }
#line 2738
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2733
  flags2 = flags2 & 4294967039U;
#line 2734
  goto ldv_52877;
  case_192: /* CIL Label */ 
#line 2736
  flags2 = flags2 | 256U;
#line 2737
  goto ldv_52877;
  switch_default: /* CIL Label */ ;
#line 2739
  return (-22);
  switch_break___0: /* CIL Label */ ;
  }
  ldv_52877: ;
#line 2741
  goto ldv_52874;
  case_6: /* CIL Label */ ;
#line 2743
  if (*((unsigned long *)nfc + 1UL) != 48UL) {
#line 2745
    return (-22);
  } else {

  }
  {
#line 2747
  if ((nfc->data & 192ULL) == 0ULL) {
#line 2747
    goto case_0___0;
  } else {

  }
#line 2750
  if ((nfc->data & 192ULL) == 192ULL) {
#line 2750
    goto case_192___0;
  } else {

  }
#line 2753
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 2748
  flags2 = flags2 & 4294966783U;
#line 2749
  goto ldv_52882;
  case_192___0: /* CIL Label */ 
#line 2751
  flags2 = flags2 | 512U;
#line 2752
  goto ldv_52882;
  switch_default___0: /* CIL Label */ ;
#line 2754
  return (-22);
  switch_break___1: /* CIL Label */ ;
  }
  ldv_52882: ;
#line 2756
  goto ldv_52874;
  case_4: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_11: /* CIL Label */ ;
  case_12: /* CIL Label */ ;
  case_7: /* CIL Label */ ;
#line 2765
  if (*((unsigned long *)nfc + 1UL) != 48UL) {
#line 2769
    return (-22);
  } else {

  }
#line 2770
  goto ldv_52874;
  switch_default___1: /* CIL Label */ ;
#line 2772
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_52874: ;
#line 2776
  if (flags2 != adapter->flags2) {
    {
#line 2777
    hw = & adapter->hw;
#line 2778
    tmp = ixgbe_read_reg(hw, 22552U);
#line 2778
    mrqc = tmp;
    }
#line 2780
    if ((flags2 & 768U) != 0U && (adapter->flags2 & 768U) == 0U) {
#line 2782
      if ((int )adapter->msg_enable & 1) {
        {
#line 2783
        netdev_warn((struct net_device  const  *)adapter->netdev, "enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");
        }
      } else {

      }
    } else {

    }
#line 2785
    adapter->flags2 = flags2;
#line 2788
    mrqc = mrqc | 3342336U;
#line 2793
    mrqc = mrqc & 4282384383U;
#line 2796
    if ((flags2 & 256U) != 0U) {
#line 2797
      mrqc = mrqc | 4194304U;
    } else {

    }
#line 2799
    if ((flags2 & 512U) != 0U) {
#line 2800
      mrqc = mrqc | 8388608U;
    } else {

    }
    {
#line 2802
    ixgbe_write_reg(hw, 22552U, mrqc);
    }
  } else {

  }
#line 2805
  return (0);
}
}
#line 2808 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_rxnfc(struct net_device *dev , struct ethtool_rxnfc *cmd ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int ret ;

  {
  {
#line 2810
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2810
  adapter = (struct ixgbe_adapter *)tmp;
#line 2811
  ret = -95;
  }
  {
#line 2814
  if (cmd->cmd == 50U) {
#line 2814
    goto case_50;
  } else {

  }
#line 2817
  if (cmd->cmd == 49U) {
#line 2817
    goto case_49;
  } else {

  }
#line 2820
  if (cmd->cmd == 42U) {
#line 2820
    goto case_42;
  } else {

  }
#line 2823
  goto switch_default;
  case_50: /* CIL Label */ 
  {
#line 2815
  ret = ixgbe_add_ethtool_fdir_entry(adapter, cmd);
  }
#line 2816
  goto ldv_52903;
  case_49: /* CIL Label */ 
  {
#line 2818
  ret = ixgbe_del_ethtool_fdir_entry(adapter, cmd);
  }
#line 2819
  goto ldv_52903;
  case_42: /* CIL Label */ 
  {
#line 2821
  ret = ixgbe_set_rss_hash_opt(adapter, cmd);
  }
#line 2822
  goto ldv_52903;
  switch_default: /* CIL Label */ ;
#line 2824
  goto ldv_52903;
  switch_break: /* CIL Label */ ;
  }
  ldv_52903: ;
#line 2827
  return (ret);
}
}
#line 2830 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_ts_info(struct net_device *dev , struct ethtool_ts_info *info ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 2833
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2833
  adapter = (struct ixgbe_adapter *)tmp;
  }
  {
#line 2836
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 2836
    goto case_3;
  } else {

  }
#line 2837
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 2837
    goto case_2;
  } else {

  }
#line 2869
  goto switch_default;
  case_3: /* CIL Label */ ;
  case_2: /* CIL Label */ 
#line 2838
  info->so_timestamping = 95U;
#line 2846
  if ((unsigned long )adapter->ptp_clock != (unsigned long )((struct ptp_clock *)0)) {
    {
#line 2847
    info->phc_index = ptp_clock_index(adapter->ptp_clock);
    }
  } else {
#line 2849
    info->phc_index = -1;
  }
#line 2851
  info->tx_types = 3U;
#line 2855
  info->rx_filters = 32753U;
#line 2868
  goto ldv_52914;
  switch_default: /* CIL Label */ 
  {
#line 2870
  tmp___0 = ethtool_op_get_ts_info(dev, info);
  }
#line 2870
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
  ldv_52914: ;
#line 2873
  return (0);
}
}
#line 2876 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static unsigned int ixgbe_max_channels(struct ixgbe_adapter *adapter ) 
{ 
  unsigned int max_combined ;
  u8 tcs ;
  int tmp ;

  {
  {
#line 2879
  tmp = netdev_get_num_tc(adapter->netdev);
#line 2879
  tcs = (u8 )tmp;
  }
#line 2881
  if ((adapter->flags & 8U) == 0U) {
#line 2883
    max_combined = 1U;
  } else
#line 2884
  if ((adapter->flags & 8388608U) != 0U) {
#line 2886
    max_combined = 1U;
  } else
#line 2887
  if ((unsigned int )tcs > 1U) {
#line 2889
    if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 2891
      max_combined = 4U;
    } else
#line 2892
    if ((unsigned int )tcs > 4U) {
#line 2894
      max_combined = 8U;
    } else {
#line 2897
      max_combined = 16U;
    }
  } else
#line 2899
  if (adapter->atr_sample_rate != 0U) {
#line 2901
    max_combined = 63U;
  } else {
#line 2904
    max_combined = 16U;
  }
#line 2907
  return (max_combined);
}
}
#line 2910 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static void ixgbe_get_channels(struct net_device *dev , struct ethtool_channels *ch ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 2913
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2913
  adapter = (struct ixgbe_adapter *)tmp;
#line 2916
  ch->max_combined = ixgbe_max_channels(adapter);
  }
#line 2919
  if ((adapter->flags & 8U) != 0U) {
#line 2920
    ch->max_other = 1U;
#line 2921
    ch->other_count = 1U;
  } else {

  }
#line 2925
  ch->combined_count = (__u32 )adapter->ring_feature[2].indices;
#line 2928
  if (ch->combined_count == 1U) {
#line 2929
    return;
  } else {

  }
#line 2932
  if ((adapter->flags & 8388608U) != 0U) {
#line 2933
    return;
  } else {

  }
  {
#line 2936
  tmp___0 = netdev_get_num_tc(dev);
  }
#line 2936
  if (tmp___0 > 1) {
#line 2937
    return;
  } else {

  }
#line 2940
  if (adapter->atr_sample_rate == 0U) {
#line 2941
    return;
  } else {

  }
#line 2944
  ch->combined_count = (__u32 )adapter->ring_feature[3].indices;
#line 2945
  return;
}
}
#line 2947 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_set_channels(struct net_device *dev , struct ethtool_channels *ch ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  unsigned int count ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2950
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2950
  adapter = (struct ixgbe_adapter *)tmp;
#line 2951
  count = ch->combined_count;
  }
#line 2954
  if ((count == 0U || ch->rx_count != 0U) || ch->tx_count != 0U) {
#line 2955
    return (-22);
  } else {

  }
#line 2958
  if (ch->other_count != 1U) {
#line 2959
    return (-22);
  } else {

  }
  {
#line 2962
  tmp___0 = ixgbe_max_channels(adapter);
  }
#line 2962
  if (count > tmp___0) {
#line 2963
    return (-22);
  } else {

  }
#line 2966
  adapter->ring_feature[3].limit = (u16 )count;
#line 2969
  if (count > 16U) {
#line 2970
    count = 16U;
  } else {

  }
#line 2971
  adapter->ring_feature[2].limit = (u16 )count;
#line 2975
  if (count > 8U) {
#line 2976
    count = 8U;
  } else {

  }
  {
#line 2977
  adapter->ring_feature[4].limit = (u16 )count;
#line 2981
  tmp___1 = netdev_get_num_tc(dev);
#line 2981
  tmp___2 = ixgbe_setup_tc(dev, (int )((u8 )tmp___1));
  }
#line 2981
  return (tmp___2);
}
}
#line 2984 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_module_info(struct net_device *dev , struct ethtool_modinfo *modinfo ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u32 status ;
  u8 sff8472_rev ;
  u8 addr_mode ;
  bool page_swap ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
  {
#line 2987
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 2987
  adapter = (struct ixgbe_adapter *)tmp;
#line 2988
  hw = & adapter->hw;
#line 2991
  page_swap = 0;
#line 2994
  tmp___0 = (*(hw->phy.ops.read_i2c_eeprom))(hw, 94, & sff8472_rev);
#line 2994
  status = (u32 )tmp___0;
  }
#line 2997
  if (status != 0U) {
#line 2998
    return (-5);
  } else {

  }
  {
#line 3001
  tmp___1 = (*(hw->phy.ops.read_i2c_eeprom))(hw, 92, & addr_mode);
#line 3001
  status = (u32 )tmp___1;
  }
#line 3004
  if (status != 0U) {
#line 3005
    return (-5);
  } else {

  }
#line 3007
  if (((int )addr_mode & 4) != 0) {
#line 3008
    if ((int )adapter->msg_enable & 1) {
      {
#line 3008
      netdev_err((struct net_device  const  *)adapter->netdev, "Address change required to access page 0xA2, but not supported. Please report the module type to the driver maintainers.\n");
      }
    } else {

    }
#line 3009
    page_swap = 1;
  } else {

  }
#line 3012
  if ((unsigned int )sff8472_rev == 0U || (int )page_swap) {
#line 3014
    modinfo->type = 1U;
#line 3015
    modinfo->eeprom_len = 256U;
  } else {
#line 3018
    modinfo->type = 2U;
#line 3019
    modinfo->eeprom_len = 512U;
  }
#line 3022
  return (0);
}
}
#line 3025 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static int ixgbe_get_module_eeprom(struct net_device *dev , struct ethtool_eeprom *ee ,
                                   u8 *data ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u32 status ;
  u8 databyte ;
  int i ;
  int tmp___0 ;
  s32 tmp___1 ;
  s32 tmp___2 ;

  {
  {
#line 3029
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 3029
  adapter = (struct ixgbe_adapter *)tmp;
#line 3030
  hw = & adapter->hw;
#line 3031
  status = 4294967279U;
#line 3032
  databyte = 255U;
#line 3033
  i = 0;
  }
#line 3035
  if (ee->len == 0U) {
#line 3036
    return (-22);
  } else {

  }
#line 3038
  i = (int )ee->offset;
#line 3038
  goto ldv_52953;
  ldv_52952: 
  {
#line 3040
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 3040
  if (tmp___0 != 0) {
#line 3041
    return (-16);
  } else {

  }
#line 3043
  if (i <= 255) {
    {
#line 3044
    tmp___1 = (*(hw->phy.ops.read_i2c_eeprom))(hw, (int )((u8 )i), & databyte);
#line 3044
    status = (u32 )tmp___1;
    }
  } else {
    {
#line 3046
    tmp___2 = (*(hw->phy.ops.read_i2c_sff8472))(hw, (int )((u8 )i), & databyte);
#line 3046
    status = (u32 )tmp___2;
    }
  }
#line 3048
  if (status != 0U) {
#line 3049
    return (-5);
  } else {

  }
#line 3051
  *(data + (unsigned long )((__u32 )i - ee->offset)) = databyte;
#line 3038
  i = i + 1;
  ldv_52953: ;
#line 3038
  if ((__u32 )i < ee->offset + ee->len) {
#line 3040
    goto ldv_52952;
  } else {

  }

#line 3054
  return (0);
}
}
#line 3057 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
static struct ethtool_ops  const  ixgbe_ethtool_ops  = 
#line 3057
     {& ixgbe_get_settings, & ixgbe_set_settings, & ixgbe_get_drvinfo, & ixgbe_get_regs_len,
    & ixgbe_get_regs, & ixgbe_get_wol, & ixgbe_set_wol, & ixgbe_get_msglevel, & ixgbe_set_msglevel,
    & ixgbe_nway_reset, & ethtool_op_get_link, & ixgbe_get_eeprom_len, & ixgbe_get_eeprom,
    & ixgbe_set_eeprom, & ixgbe_get_coalesce, & ixgbe_set_coalesce, & ixgbe_get_ringparam,
    & ixgbe_set_ringparam, & ixgbe_get_pauseparam, & ixgbe_set_pauseparam, & ixgbe_diag_test,
    & ixgbe_get_strings, & ixgbe_set_phys_id, & ixgbe_get_ethtool_stats, 0, 0, 0,
    0, & ixgbe_get_sset_count, & ixgbe_get_rxnfc, & ixgbe_set_rxnfc, 0, 0, 0, 0, 0,
    & ixgbe_get_channels, & ixgbe_set_channels, 0, 0, 0, & ixgbe_get_ts_info, & ixgbe_get_module_info,
    & ixgbe_get_module_eeprom, 0, 0};
#line 3092 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c"
void ixgbe_set_ethtool_ops(struct net_device *netdev ) 
{ 


  {
#line 3094
  netdev->ethtool_ops = & ixgbe_ethtool_ops;
#line 3095
  return;
}
}
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dispatch_irq_deregister_18_1(int arg0 ) ;
#line 81
void ldv_dispatch_irq_register_25_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 115
enum irqreturn ldv_interrupt_instance_handler_5_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
struct ldv_thread ldv_thread_5  ;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dispatch_irq_deregister_18_1(int arg0 ) 
{ 
  int tmp ;

  {
  {
#line 136
  tmp = ldv_undef_int();
  }
  {
#line 137
  if (tmp == 0) {
#line 137
    goto case_0;
  } else {

  }
#line 141
  if (tmp == 1) {
#line 141
    goto case_1;
  } else {

  }
#line 145
  if (tmp == 2) {
#line 145
    goto case_2;
  } else {

  }
#line 149
  if (tmp == 3) {
#line 149
    goto case_3;
  } else {

  }
#line 153
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 139
  goto ldv_53265;
  case_1: /* CIL Label */ ;
#line 143
  goto ldv_53265;
  case_2: /* CIL Label */ ;
#line 147
  goto ldv_53265;
  case_3: /* CIL Label */ ;
#line 151
  goto ldv_53265;
  switch_default: /* CIL Label */ 
  {
#line 153
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_53265: ;
#line 155
  return;
}
}
#line 159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dispatch_irq_register_25_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_2 *cf_arg_2 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_3 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_4 ;
  struct ldv_struct_interrupt_instance_2 *cf_arg_5 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 165
  tmp = ldv_undef_int();
  }
  {
#line 166
  if (tmp == 0) {
#line 166
    goto case_0;
  } else {

  }
#line 175
  if (tmp == 1) {
#line 175
    goto case_1;
  } else {

  }
#line 184
  if (tmp == 2) {
#line 184
    goto case_2;
  } else {

  }
#line 193
  if (tmp == 3) {
#line 193
    goto case_3;
  } else {

  }
#line 202
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 167
  tmp___0 = ldv_xmalloc(40UL);
#line 167
  cf_arg_2 = (struct ldv_struct_interrupt_instance_2 *)tmp___0;
#line 168
  cf_arg_2->arg0 = arg0;
#line 169
  cf_arg_2->arg1 = arg1;
#line 170
  cf_arg_2->arg2 = arg2;
#line 171
  cf_arg_2->arg3 = arg3;
#line 172
  ldv_interrupt_interrupt_instance_2((void *)cf_arg_2);
  }
#line 173
  goto ldv_53286;
  case_1: /* CIL Label */ 
  {
#line 176
  tmp___1 = ldv_xmalloc(40UL);
#line 176
  cf_arg_3 = (struct ldv_struct_interrupt_instance_2 *)tmp___1;
#line 177
  cf_arg_3->arg0 = arg0;
#line 178
  cf_arg_3->arg1 = arg1;
#line 179
  cf_arg_3->arg2 = arg2;
#line 180
  cf_arg_3->arg3 = arg3;
#line 181
  ldv_interrupt_interrupt_instance_3((void *)cf_arg_3);
  }
#line 182
  goto ldv_53286;
  case_2: /* CIL Label */ 
  {
#line 185
  tmp___2 = ldv_xmalloc(40UL);
#line 185
  cf_arg_4 = (struct ldv_struct_interrupt_instance_2 *)tmp___2;
#line 186
  cf_arg_4->arg0 = arg0;
#line 187
  cf_arg_4->arg1 = arg1;
#line 188
  cf_arg_4->arg2 = arg2;
#line 189
  cf_arg_4->arg3 = arg3;
#line 190
  ldv_interrupt_interrupt_instance_4((void *)cf_arg_4);
  }
#line 191
  goto ldv_53286;
  case_3: /* CIL Label */ 
  {
#line 194
  tmp___3 = ldv_xmalloc(40UL);
#line 194
  cf_arg_5 = (struct ldv_struct_interrupt_instance_2 *)tmp___3;
#line 195
  cf_arg_5->arg0 = arg0;
#line 196
  cf_arg_5->arg1 = arg1;
#line 197
  cf_arg_5->arg2 = arg2;
#line 198
  cf_arg_5->arg3 = arg3;
#line 199
  ldv_interrupt_interrupt_instance_5((void *)cf_arg_5);
  }
#line 200
  goto ldv_53286;
  switch_default: /* CIL Label */ 
  {
#line 202
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_53286: ;
#line 204
  return;
}
}
#line 208 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_12(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 209
  ixgbe_get_eeprom_len(arg1);
  }
#line 210
  return;
}
}
#line 213 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_13(void (*arg0)(struct net_device * ,
                                                                struct ethtool_stats * ,
                                                                unsigned long long * ) ,
                                                   struct net_device *arg1 , struct ethtool_stats *arg2 ,
                                                   unsigned long long *arg3 ) 
{ 


  {
  {
#line 214
  ixgbe_get_ethtool_stats(arg1, arg2, arg3);
  }
#line 215
  return;
}
}
#line 218 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_147(int (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) 
{ 


  {
  {
#line 219
  ixgbe_nway_reset(arg1);
  }
#line 220
  return;
}
}
#line 223 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_148(void (*arg0)(struct net_device * ,
                                                                 struct ethtool_test * ,
                                                                 unsigned long long * ) ,
                                                    struct net_device *arg1 , struct ethtool_test *arg2 ,
                                                    unsigned long long *arg3 ) 
{ 


  {
  {
#line 224
  ixgbe_diag_test(arg1, arg2, arg3);
  }
#line 225
  return;
}
}
#line 228 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_151(int (*arg0)(struct net_device * ,
                                                                struct ethtool_channels * ) ,
                                                    struct net_device *arg1 , struct ethtool_channels *arg2 ) 
{ 


  {
  {
#line 229
  ixgbe_set_channels(arg1, arg2);
  }
#line 230
  return;
}
}
#line 233 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_152(int (*arg0)(struct net_device * ,
                                                                struct ethtool_coalesce * ) ,
                                                    struct net_device *arg1 , struct ethtool_coalesce *arg2 ) 
{ 


  {
  {
#line 234
  ixgbe_set_coalesce(arg1, arg2);
  }
#line 235
  return;
}
}
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_153(int (*arg0)(struct net_device * ,
                                                                struct ethtool_eeprom * ,
                                                                unsigned char * ) ,
                                                    struct net_device *arg1 , struct ethtool_eeprom *arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 239
  ixgbe_set_eeprom(arg1, arg2, arg3);
  }
#line 240
  return;
}
}
#line 243 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_156(void (*arg0)(struct net_device * ,
                                                                 unsigned int  ) ,
                                                    struct net_device *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 244
  ixgbe_set_msglevel(arg1, arg2);
  }
#line 245
  return;
}
}
#line 248 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_159(int (*arg0)(struct net_device * ,
                                                                struct ethtool_pauseparam * ) ,
                                                    struct net_device *arg1 , struct ethtool_pauseparam *arg2 ) 
{ 


  {
  {
#line 249
  ixgbe_set_pauseparam(arg1, arg2);
  }
#line 250
  return;
}
}
#line 253 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_16(unsigned int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 254
  ethtool_op_get_link(arg1);
  }
#line 255
  return;
}
}
#line 258 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_160(int (*arg0)(struct net_device * ,
                                                                enum ethtool_phys_id_state  ) ,
                                                    struct net_device *arg1 , enum ethtool_phys_id_state arg2 ) 
{ 


  {
  {
#line 259
  ixgbe_set_phys_id(arg1, arg2);
  }
#line 260
  return;
}
}
#line 263 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_161(int (*arg0)(struct net_device * ,
                                                                struct ethtool_ringparam * ) ,
                                                    struct net_device *arg1 , struct ethtool_ringparam *arg2 ) 
{ 


  {
  {
#line 264
  ixgbe_set_ringparam(arg1, arg2);
  }
#line 265
  return;
}
}
#line 268 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_162(int (*arg0)(struct net_device * ,
                                                                struct ethtool_rxnfc * ) ,
                                                    struct net_device *arg1 , struct ethtool_rxnfc *arg2 ) 
{ 


  {
  {
#line 269
  ixgbe_set_rxnfc(arg1, arg2);
  }
#line 270
  return;
}
}
#line 273 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_163(int (*arg0)(struct net_device * ,
                                                                struct ethtool_cmd * ) ,
                                                    struct net_device *arg1 , struct ethtool_cmd *arg2 ) 
{ 


  {
  {
#line 274
  ixgbe_set_settings(arg1, arg2);
  }
#line 275
  return;
}
}
#line 278 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_164(int (*arg0)(struct net_device * ,
                                                                struct ethtool_wolinfo * ) ,
                                                    struct net_device *arg1 , struct ethtool_wolinfo *arg2 ) 
{ 


  {
  {
#line 279
  ixgbe_set_wol(arg1, arg2);
  }
#line 280
  return;
}
}
#line 283 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_17(int (*arg0)(struct net_device * ,
                                                               struct ethtool_eeprom * ,
                                                               unsigned char * ) ,
                                                   struct net_device *arg1 , struct ethtool_eeprom *arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 284
  ixgbe_get_module_eeprom(arg1, arg2, arg3);
  }
#line 285
  return;
}
}
#line 288 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_20(int (*arg0)(struct net_device * ,
                                                               struct ethtool_modinfo * ) ,
                                                   struct net_device *arg1 , struct ethtool_modinfo *arg2 ) 
{ 


  {
  {
#line 289
  ixgbe_get_module_info(arg1, arg2);
  }
#line 290
  return;
}
}
#line 293 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_21(unsigned int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 294
  ixgbe_get_msglevel(arg1);
  }
#line 295
  return;
}
}
#line 298 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_22(void (*arg0)(struct net_device * ,
                                                                struct ethtool_pauseparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_pauseparam *arg2 ) 
{ 


  {
  {
#line 299
  ixgbe_get_pauseparam(arg1, arg2);
  }
#line 300
  return;
}
}
#line 303 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_23(void (*arg0)(struct net_device * ,
                                                                struct ethtool_regs * ,
                                                                void * ) , struct net_device *arg1 ,
                                                   struct ethtool_regs *arg2 , void *arg3 ) 
{ 


  {
  {
#line 304
  ixgbe_get_regs(arg1, arg2, arg3);
  }
#line 305
  return;
}
}
#line 308 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_24(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 309
  ixgbe_get_regs_len(arg1);
  }
#line 310
  return;
}
}
#line 313 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_25(void (*arg0)(struct net_device * ,
                                                                struct ethtool_ringparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_ringparam *arg2 ) 
{ 


  {
  {
#line 314
  ixgbe_get_ringparam(arg1, arg2);
  }
#line 315
  return;
}
}
#line 318 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_26(int (*arg0)(struct net_device * ,
                                                               struct ethtool_rxnfc * ,
                                                               unsigned int * ) ,
                                                   struct net_device *arg1 , struct ethtool_rxnfc *arg2 ,
                                                   unsigned int *arg3 ) 
{ 


  {
  {
#line 319
  ixgbe_get_rxnfc(arg1, arg2, arg3);
  }
#line 320
  return;
}
}
#line 323 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_29(int (*arg0)(struct net_device * ,
                                                               struct ethtool_cmd * ) ,
                                                   struct net_device *arg1 , struct ethtool_cmd *arg2 ) 
{ 


  {
  {
#line 324
  ixgbe_get_settings(arg1, arg2);
  }
#line 325
  return;
}
}
#line 328 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_3(void (*arg0)(struct net_device * ,
                                                               struct ethtool_channels * ) ,
                                                  struct net_device *arg1 , struct ethtool_channels *arg2 ) 
{ 


  {
  {
#line 329
  ixgbe_get_channels(arg1, arg2);
  }
#line 330
  return;
}
}
#line 333 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_30(int (*arg0)(struct net_device * ,
                                                               int  ) , struct net_device *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 334
  ixgbe_get_sset_count(arg1, arg2);
  }
#line 335
  return;
}
}
#line 338 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_33(void (*arg0)(struct net_device * ,
                                                                unsigned int  , unsigned char * ) ,
                                                   struct net_device *arg1 , unsigned int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 339
  ixgbe_get_strings(arg1, arg2, arg3);
  }
#line 340
  return;
}
}
#line 343 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_36(int (*arg0)(struct net_device * ,
                                                               struct ethtool_ts_info * ) ,
                                                   struct net_device *arg1 , struct ethtool_ts_info *arg2 ) 
{ 


  {
  {
#line 344
  ixgbe_get_ts_info(arg1, arg2);
  }
#line 345
  return;
}
}
#line 348 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_37(void (*arg0)(struct net_device * ,
                                                                struct ethtool_wolinfo * ) ,
                                                   struct net_device *arg1 , struct ethtool_wolinfo *arg2 ) 
{ 


  {
  {
#line 349
  ixgbe_get_wol(arg1, arg2);
  }
#line 350
  return;
}
}
#line 353 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_7(int (*arg0)(struct net_device * ,
                                                              struct ethtool_coalesce * ) ,
                                                  struct net_device *arg1 , struct ethtool_coalesce *arg2 ) 
{ 


  {
  {
#line 354
  ixgbe_get_coalesce(arg1, arg2);
  }
#line 355
  return;
}
}
#line 358 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_8(void (*arg0)(struct net_device * ,
                                                               struct ethtool_drvinfo * ) ,
                                                  struct net_device *arg1 , struct ethtool_drvinfo *arg2 ) 
{ 


  {
  {
#line 359
  ixgbe_get_drvinfo(arg1, arg2);
  }
#line 360
  return;
}
}
#line 363 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_6_9(int (*arg0)(struct net_device * ,
                                                              struct ethtool_eeprom * ,
                                                              unsigned char * ) ,
                                                  struct net_device *arg1 , struct ethtool_eeprom *arg2 ,
                                                  unsigned char *arg3 ) 
{ 


  {
  {
#line 364
  ixgbe_get_eeprom(arg1, arg2, arg3);
  }
#line 365
  return;
}
}
#line 368 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) 
{ 
  int ldv_18_line_line ;

  {
  {
#line 374
  ldv_18_line_line = arg1;
#line 378
  ldv_dispatch_irq_deregister_18_1(ldv_18_line_line);
  }
#line 382
  return;
#line 384
  return;
}
}
#line 389 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
enum irqreturn ldv_interrupt_instance_handler_5_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 390
  tmp = ixgbe_test_intr(arg1, arg2);
  }
#line 390
  return (tmp);
}
}
#line 394 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
void ldv_interrupt_interrupt_instance_5(void *arg0 ) 
{ 
  enum irqreturn (*ldv_5_callback_handler)(int  , void * ) ;
  void *ldv_5_data_data ;
  int ldv_5_line_line ;
  enum irqreturn ldv_5_ret_val_default ;
  enum irqreturn (*ldv_5_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_2 *data ;
  int tmp ;

  {
#line 403
  data = (struct ldv_struct_interrupt_instance_2 *)arg0;
#line 408
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_2 *)0)) {
    {
#line 409
    ldv_5_line_line = data->arg0;
#line 410
    ldv_5_callback_handler = data->arg1;
#line 411
    ldv_5_thread_thread = data->arg2;
#line 412
    ldv_5_data_data = data->arg3;
#line 413
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 419
  ldv_switch_to_interrupt_context();
#line 421
  ldv_5_ret_val_default = ldv_interrupt_instance_handler_5_5(ldv_5_callback_handler,
                                                             ldv_5_line_line, ldv_5_data_data);
#line 423
  ldv_switch_to_process_context();
#line 426
  tmp = ldv_undef_int();
  }
#line 426
  if (tmp != 0) {
    {
#line 428
    ldv_assume((unsigned int )ldv_5_ret_val_default == 2U);
    }
#line 432
    if ((unsigned long )ldv_5_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                    void * ))0)) {
      {
#line 434
      ldv_interrupt_instance_thread_5_3(ldv_5_thread_thread, ldv_5_line_line, ldv_5_data_data);
      }
    } else {

    }
  } else {
    {
#line 441
    ldv_assume((unsigned int )ldv_5_ret_val_default != 2U);
    }
  }
#line 450
  return;
#line 452
  return;
}
}
#line 521 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 524
  tmp = ldv_kzalloc(size, flags);
  }
#line 524
  return (tmp);
}
}
#line 575 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ethtool.c.aux"
static void ldv_free_irq_11___0(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 578
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 581
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 582
  return;
}
}
#line 85 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/io.h"
__inline static void writeq(unsigned long val , void volatile   *addr ) 
{ 


  {
#line 85
  __asm__  volatile   ("movq %0,%1": : "r" (val), "m" (*((unsigned long volatile   *)addr)): "memory");
#line 86
  return;
}
}
#line 118 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
struct ixgbe_mbx_operations mbx_ops_generic ;
#line 155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h"
__inline static void ixgbe_write_reg64(struct ixgbe_hw *hw , u32 reg , u64 value ) 
{ 
  u8 *reg_addr ;
  bool tmp ;

  {
  {
#line 157
  reg_addr = *((u8 * volatile  *)(& hw->hw_addr));
#line 159
  tmp = ixgbe_removed((void *)reg_addr);
  }
#line 159
  if ((int )tmp) {
#line 160
    return;
  } else {

  }
  {
#line 161
  writeq((unsigned long )value, (void volatile   *)reg_addr + (unsigned long )reg);
  }
#line 162
  return;
}
}
#line 117 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw ) ;
#line 118
s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw ) ;
#line 119
s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                               u16 *phy_data ) ;
#line 121
s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                                u16 phy_data ) ;
#line 127
s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw ) ;
#line 128
s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                       bool autoneg_wait_to_complete ) ;
#line 131
s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                               bool *autoneg ) ;
#line 136
s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw , ixgbe_link_speed *speed , bool *link_up ) ;
#line 139
s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw ) ;
#line 140
s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw , u16 *firmware_version ) ;
#line 146
s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw ) ;
#line 148
s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw , u16 *list_offset , u16 *data_offset ) ;
#line 151
s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw ) ;
#line 152
s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                u8 *data ) ;
#line 154
s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                 u8 data ) ;
#line 156
s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 *eeprom_data ) ;
#line 158
s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 *sff8472_data ) ;
#line 160
s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 eeprom_data ) ;
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) ;
#line 44
static void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) ;
#line 45
static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) ;
#line 46
static s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                                 bool autoneg_wait_to_complete ) ;
#line 49
static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                           bool autoneg_wait_to_complete ) ;
#line 52
static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw ) ;
#line 53
static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw , bool autoneg_wait_to_complete ) ;
#line 55
static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                      bool autoneg_wait_to_complete ) ;
#line 58
static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait_to_complete ) ;
#line 61
static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw ) ;
#line 62
static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                     u8 *data ) ;
#line 64
static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                      u8 data ) ;
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static bool ixgbe_mng_enabled(struct ixgbe_hw *hw ) 
{ 
  u32 fwsm ;
  u32 manc ;
  u32 factps ;

  {
  {
#line 71
  fwsm = ixgbe_read_reg(hw, 65864U);
  }
#line 72
  if ((fwsm & 14U) != 4U) {
#line 73
    return (0);
  } else {

  }
  {
#line 75
  manc = ixgbe_read_reg(hw, 22560U);
  }
#line 76
  if ((manc & 131072U) == 0U) {
#line 77
    return (0);
  } else {

  }
  {
#line 79
  factps = ixgbe_read_reg(hw, 65872U);
  }
#line 80
  if ((factps & 536870912U) != 0U) {
#line 81
    return (0);
  } else {

  }
#line 83
  return (1);
}
}
#line 86 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;
  enum ixgbe_media_type tmp ;
  enum ixgbe_media_type tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  {
#line 88
  mac = & hw->mac;
#line 93
  tmp = (*(mac->ops.get_media_type))(hw);
  }
#line 93
  if ((unsigned int )tmp == 1U && ! hw->mng_fw_enabled) {
#line 95
    mac->ops.disable_tx_laser = & ixgbe_disable_tx_laser_multispeed_fiber;
#line 97
    mac->ops.enable_tx_laser = & ixgbe_enable_tx_laser_multispeed_fiber;
#line 99
    mac->ops.flap_tx_laser = & ixgbe_flap_tx_laser_multispeed_fiber;
  } else {
#line 101
    mac->ops.disable_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 102
    mac->ops.enable_tx_laser = (void (*)(struct ixgbe_hw * ))0;
#line 103
    mac->ops.flap_tx_laser = (void (*)(struct ixgbe_hw * ))0;
  }
#line 106
  if ((int )hw->phy.multispeed_fiber) {
#line 108
    mac->ops.setup_link = & ixgbe_setup_mac_link_multispeed_fiber;
  } else {
    {
#line 110
    tmp___0 = (*(mac->ops.get_media_type))(hw);
    }
#line 110
    if ((unsigned int )tmp___0 == 6U && (unsigned int )hw->phy.smart_speed <= 1U) {
      {
#line 110
      tmp___1 = ixgbe_verify_lesm_fw_enabled_82599(hw);
      }
#line 110
      if (tmp___1) {
#line 110
        tmp___2 = 0;
      } else {
#line 110
        tmp___2 = 1;
      }
#line 110
      if (tmp___2) {
#line 115
        mac->ops.setup_link = & ixgbe_setup_mac_link_smartspeed;
      } else {
#line 117
        mac->ops.setup_link = & ixgbe_setup_mac_link_82599;
      }
    } else {
#line 117
      mac->ops.setup_link = & ixgbe_setup_mac_link_82599;
    }
  }
#line 118
  return;
}
}
#line 121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u16 list_offset ;
  u16 data_offset ;
  u16 data_value ;
  bool got_lock ;
  s32 tmp ;
  s32 tmp___0 ;
  bool tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;

  {
#line 123
  ret_val = 0;
#line 125
  got_lock = 0;
#line 127
  if ((unsigned int )hw->phy.sfp_type != 65535U) {
    {
#line 128
    ixgbe_init_mac_link_ops_82599(hw);
#line 130
    hw->phy.ops.reset = (s32 (*)(struct ixgbe_hw * ))0;
#line 132
    ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, & list_offset, & data_offset);
    }
#line 134
    if (ret_val != 0) {
#line 135
      goto setup_sfp_out;
    } else {

    }
    {
#line 138
    ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8);
    }
#line 140
    if (ret_val != 0) {
#line 141
      ret_val = -16;
#line 142
      goto setup_sfp_out;
    } else {

    }
    {
#line 145
    data_offset = (u16 )((int )data_offset + 1);
#line 145
    tmp = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & data_value);
    }
#line 145
    if (tmp != 0) {
#line 146
      goto setup_sfp_err;
    } else {

    }
#line 147
    goto ldv_50895;
    ldv_50894: 
    {
#line 148
    ixgbe_write_reg(hw, 85760U, (u32 )data_value);
#line 149
    ixgbe_read_reg(hw, 8U);
#line 150
    data_offset = (u16 )((int )data_offset + 1);
#line 150
    tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & data_value);
    }
#line 150
    if (tmp___0 != 0) {
#line 151
      goto setup_sfp_err;
    } else {

    }
    ldv_50895: ;
#line 147
    if ((unsigned int )data_value != 65535U) {
#line 149
      goto ldv_50894;
    } else {

    }
    {
#line 155
    (*(hw->mac.ops.release_swfw_sync))(hw, 8);
#line 160
    usleep_range((unsigned long )(hw->eeprom.semaphore_delay * 1000U), (unsigned long )(hw->eeprom.semaphore_delay * 2000U));
#line 167
    tmp___1 = ixgbe_verify_lesm_fw_enabled_82599(hw);
    }
#line 167
    if ((int )tmp___1) {
      {
#line 168
      ret_val = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8);
      }
#line 170
      if (ret_val != 0) {
#line 171
        goto setup_sfp_out;
      } else {

      }
#line 173
      got_lock = 1;
    } else {

    }
    {
#line 177
    ixgbe_write_reg(hw, 17056U, hw->mac.orig_autoc | 24576U);
#line 179
    hw->mac.cached_autoc = ixgbe_read_reg(hw, 17056U);
#line 180
    ret_val = ixgbe_reset_pipeline_82599(hw);
    }
#line 182
    if ((int )got_lock) {
      {
#line 183
      (*(hw->mac.ops.release_swfw_sync))(hw, 8);
#line 185
      got_lock = 0;
      }
    } else {

    }
#line 188
    if (ret_val != 0) {
      {
#line 189
      descriptor.modname = "ixgbe";
#line 189
      descriptor.function = "ixgbe_setup_sfp_modules_82599";
#line 189
      descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 189
      descriptor.format = " sfp module setup not complete\n";
#line 189
      descriptor.lineno = 189U;
#line 189
      descriptor.flags = 0U;
#line 189
      tmp___2 = __builtin_expect((long )descriptor.flags & 1L, 0L);
      }
#line 189
      if (tmp___2 != 0L) {
        {
#line 189
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             " sfp module setup not complete\n");
        }
      } else {

      }
#line 190
      ret_val = -30;
#line 191
      goto setup_sfp_out;
    } else {

    }
  } else {

  }
  setup_sfp_out: ;
#line 196
  return (ret_val);
  setup_sfp_err: 
  {
#line 200
  (*(hw->mac.ops.release_swfw_sync))(hw, 8);
#line 204
  usleep_range((unsigned long )(hw->eeprom.semaphore_delay * 1000U), (unsigned long )(hw->eeprom.semaphore_delay * 2000U));
#line 206
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )data_offset);
  }
#line 207
  return (-30);
}
}
#line 210 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_get_invariants_82599(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;

  {
  {
#line 212
  mac = & hw->mac;
#line 214
  ixgbe_init_mac_link_ops_82599(hw);
#line 216
  mac->mcft_size = 128U;
#line 217
  mac->vft_size = 128U;
#line 218
  mac->num_rar_entries = 128U;
#line 219
  mac->max_rx_queues = 128U;
#line 220
  mac->max_tx_queues = 128U;
#line 221
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
  }
#line 223
  return (0);
}
}
#line 235 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;
  struct ixgbe_phy_info *phy ;
  s32 ret_val ;
  u32 esdp ;
  enum ixgbe_media_type tmp ;

  {
#line 237
  mac = & hw->mac;
#line 238
  phy = & hw->phy;
#line 239
  ret_val = 0;
#line 242
  if ((unsigned int )hw->device_id == 5464U) {
    {
#line 244
    hw->phy.qsfp_shared_i2c_bus = 1;
#line 247
    esdp = ixgbe_read_reg(hw, 32U);
#line 248
    esdp = esdp | 256U;
#line 249
    esdp = esdp & 4294966783U;
#line 250
    esdp = esdp & 4294967294U;
#line 251
    esdp = esdp & 4294901759U;
#line 252
    esdp = esdp & 4294836223U;
#line 253
    ixgbe_write_reg(hw, 32U, esdp);
#line 254
    ixgbe_read_reg(hw, 8U);
#line 256
    phy->ops.read_i2c_byte = & ixgbe_read_i2c_byte_82599;
#line 257
    phy->ops.write_i2c_byte = & ixgbe_write_i2c_byte_82599;
    }
  } else {

  }
  {
#line 261
  ret_val = (*(phy->ops.identify))(hw);
#line 264
  ixgbe_init_mac_link_ops_82599(hw);
#line 267
  tmp = (*(mac->ops.get_media_type))(hw);
  }
#line 267
  if ((unsigned int )tmp == 5U) {
#line 268
    mac->ops.setup_link = & ixgbe_setup_copper_link_82599;
#line 269
    mac->ops.get_link_capabilities = & ixgbe_get_copper_link_capabilities_generic;
  } else {

  }
  {
#line 275
  if ((unsigned int )hw->phy.type == 2U) {
#line 275
    goto case_2;
  } else {

  }
#line 281
  goto switch_default;
  case_2: /* CIL Label */ 
#line 276
  phy->ops.check_link = & ixgbe_check_phy_link_tnx;
#line 277
  phy->ops.setup_link = & ixgbe_setup_phy_link_tnx;
#line 278
  phy->ops.get_firmware_version = & ixgbe_get_phy_firmware_version_tnx;
#line 280
  goto ldv_50911;
  switch_default: /* CIL Label */ ;
#line 282
  goto ldv_50911;
  switch_break: /* CIL Label */ ;
  }
  ldv_50911: ;
#line 285
  return (ret_val);
}
}
#line 296 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                             bool *autoneg ) 
{ 
  s32 status ;
  u32 autoc ;

  {
#line 300
  status = 0;
#line 301
  autoc = 0U;
#line 304
  if (((((unsigned int )hw->phy.sfp_type - 9U <= 1U || (unsigned int )hw->phy.sfp_type == 13U) || (unsigned int )hw->phy.sfp_type == 14U) || (unsigned int )hw->phy.sfp_type == 11U) || (unsigned int )hw->phy.sfp_type == 12U) {
#line 310
    *speed = 32U;
#line 311
    *autoneg = 1;
#line 312
    goto out;
  } else {

  }
#line 320
  if ((int )hw->mac.orig_link_settings_stored) {
#line 321
    autoc = hw->mac.orig_autoc;
  } else {
    {
#line 323
    autoc = ixgbe_read_reg(hw, 17056U);
    }
  }
  {
#line 326
  if ((autoc & 57344U) == 0U) {
#line 326
    goto case_0;
  } else {

  }
#line 331
  if ((autoc & 57344U) == 8192U) {
#line 331
    goto case_8192;
  } else {

  }
#line 336
  if ((autoc & 57344U) == 16384U) {
#line 336
    goto case_16384;
  } else {

  }
#line 341
  if ((autoc & 57344U) == 24576U) {
#line 341
    goto case_24576;
  } else {

  }
#line 346
  if ((autoc & 57344U) == 32768U) {
#line 346
    goto case_32768;
  } else {

  }
#line 347
  if ((autoc & 57344U) == 49152U) {
#line 347
    goto case_49152;
  } else {

  }
#line 358
  if ((autoc & 57344U) == 57344U) {
#line 358
    goto case_57344;
  } else {

  }
#line 369
  if ((autoc & 57344U) == 40960U) {
#line 369
    goto case_40960;
  } else {

  }
#line 374
  goto switch_default;
  case_0: /* CIL Label */ 
#line 327
  *speed = 32U;
#line 328
  *autoneg = 0;
#line 329
  goto ldv_50922;
  case_8192: /* CIL Label */ 
#line 332
  *speed = 128U;
#line 333
  *autoneg = 0;
#line 334
  goto ldv_50922;
  case_16384: /* CIL Label */ 
#line 337
  *speed = 32U;
#line 338
  *autoneg = 1;
#line 339
  goto ldv_50922;
  case_24576: /* CIL Label */ 
#line 342
  *speed = 128U;
#line 343
  *autoneg = 0;
#line 344
  goto ldv_50922;
  case_32768: /* CIL Label */ ;
  case_49152: /* CIL Label */ 
#line 348
  *speed = 0U;
#line 349
  if ((autoc & 65536U) != 0U) {
#line 350
    *speed = *speed | 128U;
  } else {

  }
#line 351
  if ((int )autoc < 0) {
#line 352
    *speed = *speed | 128U;
  } else {

  }
#line 353
  if ((autoc & 1073741824U) != 0U) {
#line 354
    *speed = *speed | 32U;
  } else {

  }
#line 355
  *autoneg = 1;
#line 356
  goto ldv_50922;
  case_57344: /* CIL Label */ 
#line 359
  *speed = 8U;
#line 360
  if ((autoc & 65536U) != 0U) {
#line 361
    *speed = *speed | 128U;
  } else {

  }
#line 362
  if ((int )autoc < 0) {
#line 363
    *speed = *speed | 128U;
  } else {

  }
#line 364
  if ((autoc & 1073741824U) != 0U) {
#line 365
    *speed = *speed | 32U;
  } else {

  }
#line 366
  *autoneg = 1;
#line 367
  goto ldv_50922;
  case_40960: /* CIL Label */ 
#line 370
  *speed = 40U;
#line 371
  *autoneg = 0;
#line 372
  goto ldv_50922;
  switch_default: /* CIL Label */ 
#line 375
  status = -8;
#line 376
  goto out;
  switch_break: /* CIL Label */ ;
  }
  ldv_50922: ;
#line 380
  if ((int )hw->phy.multispeed_fiber) {
#line 381
    *speed = *speed | 160U;
#line 385
    if ((unsigned int )hw->phy.media_type == 3U) {
#line 386
      *autoneg = 0;
    } else {
#line 388
      *autoneg = 1;
    }
  } else {

  }
  out: ;
#line 392
  return (status);
}
}
#line 401 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw ) 
{ 
  enum ixgbe_media_type media_type ;

  {
  {
#line 407
  if ((unsigned int )hw->phy.type == 4U) {
#line 407
    goto case_4;
  } else {

  }
#line 408
  if ((unsigned int )hw->phy.type == 2U) {
#line 408
    goto case_2;
  } else {

  }
#line 411
  goto switch_default;
  case_4: /* CIL Label */ ;
  case_2: /* CIL Label */ 
#line 409
  media_type = 5;
#line 410
  goto out;
  switch_default: /* CIL Label */ ;
#line 412
  goto ldv_50939;
  switch_break: /* CIL Label */ ;
  }
  ldv_50939: ;
  {
#line 416
  if ((int )hw->device_id == 4343) {
#line 416
    goto case_4343;
  } else {

  }
#line 417
  if ((int )hw->device_id == 5396) {
#line 417
    goto case_5396;
  } else {

  }
#line 418
  if ((int )hw->device_id == 4344) {
#line 418
    goto case_4344;
  } else {

  }
#line 419
  if ((int )hw->device_id == 5399) {
#line 419
    goto case_5399;
  } else {

  }
#line 420
  if ((int )hw->device_id == 5418) {
#line 420
    goto case_5418;
  } else {

  }
#line 421
  if ((int )hw->device_id == 4348) {
#line 421
    goto case_4348;
  } else {

  }
#line 425
  if ((int )hw->device_id == 4347) {
#line 425
    goto case_4347;
  } else {

  }
#line 426
  if ((int )hw->device_id == 5417) {
#line 426
    goto case_5417;
  } else {

  }
#line 427
  if ((int )hw->device_id == 5383) {
#line 427
    goto case_5383;
  } else {

  }
#line 428
  if ((int )hw->device_id == 5453) {
#line 428
    goto case_5453;
  } else {

  }
#line 429
  if ((int )hw->device_id == 5450) {
#line 429
    goto case_5450;
  } else {

  }
#line 430
  if ((int )hw->device_id == 5463) {
#line 430
    goto case_5463;
  } else {

  }
#line 433
  if ((int )hw->device_id == 4345) {
#line 433
    goto case_4345;
  } else {

  }
#line 436
  if ((int )hw->device_id == 5404) {
#line 436
    goto case_5404;
  } else {

  }
#line 439
  if ((int )hw->device_id == 5455) {
#line 439
    goto case_5455;
  } else {

  }
#line 442
  if ((int )hw->device_id == 5464) {
#line 442
    goto case_5464;
  } else {

  }
#line 445
  goto switch_default___0;
  case_4343: /* CIL Label */ ;
  case_5396: /* CIL Label */ ;
  case_4344: /* CIL Label */ ;
  case_5399: /* CIL Label */ ;
  case_5418: /* CIL Label */ ;
  case_4348: /* CIL Label */ 
#line 423
  media_type = 6;
#line 424
  goto ldv_50946;
  case_4347: /* CIL Label */ ;
  case_5417: /* CIL Label */ ;
  case_5383: /* CIL Label */ ;
  case_5453: /* CIL Label */ ;
  case_5450: /* CIL Label */ ;
  case_5463: /* CIL Label */ 
#line 431
  media_type = 1;
#line 432
  goto ldv_50946;
  case_4345: /* CIL Label */ 
#line 434
  media_type = 7;
#line 435
  goto ldv_50946;
  case_5404: /* CIL Label */ 
#line 437
  media_type = 5;
#line 438
  goto ldv_50946;
  case_5455: /* CIL Label */ 
#line 440
  media_type = 4;
#line 441
  goto ldv_50946;
  case_5464: /* CIL Label */ 
#line 443
  media_type = 3;
#line 444
  goto ldv_50946;
  switch_default___0: /* CIL Label */ 
#line 446
  media_type = 0;
#line 447
  goto ldv_50946;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_50946: ;
  out: ;
#line 450
  return (media_type);
}
}
#line 460 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw ) 
{ 
  u32 autoc2_reg ;

  {
#line 464
  if (! hw->mng_fw_enabled && ! hw->wol_enabled) {
    {
#line 465
    autoc2_reg = ixgbe_read_reg(hw, 17064U);
#line 466
    autoc2_reg = autoc2_reg | 1342177280U;
#line 467
    ixgbe_write_reg(hw, 17064U, autoc2_reg);
    }
  } else {

  }
#line 469
  return;
}
}
#line 479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw , bool autoneg_wait_to_complete ) 
{ 
  u32 autoc_reg ;
  u32 links_reg ;
  u32 i ;
  s32 status ;
  bool got_lock ;
  bool tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 485
  status = 0;
#line 486
  got_lock = 0;
#line 488
  tmp = ixgbe_verify_lesm_fw_enabled_82599(hw);
  }
#line 488
  if ((int )tmp) {
    {
#line 489
    status = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8);
    }
#line 491
    if (status != 0) {
#line 492
      goto out;
    } else {

    }
#line 494
    got_lock = 1;
  } else {

  }
  {
#line 498
  ixgbe_reset_pipeline_82599(hw);
  }
#line 500
  if ((int )got_lock) {
    {
#line 501
    (*(hw->mac.ops.release_swfw_sync))(hw, 8);
    }
  } else {

  }
#line 504
  if ((int )autoneg_wait_to_complete) {
    {
#line 505
    autoc_reg = ixgbe_read_reg(hw, 17056U);
    }
#line 506
    if (((autoc_reg & 57344U) == 32768U || (autoc_reg & 57344U) == 49152U) || (autoc_reg & 57344U) == 57344U) {
#line 512
      links_reg = 0U;
#line 513
      i = 0U;
#line 513
      goto ldv_50974;
      ldv_50973: 
      {
#line 514
      links_reg = ixgbe_read_reg(hw, 17060U);
      }
#line 515
      if ((int )links_reg < 0) {
#line 516
        goto ldv_50972;
      } else {

      }
      {
#line 517
      msleep(100U);
#line 513
      i = i + 1U;
      }
      ldv_50974: ;
#line 513
      if (i <= 44U) {
#line 515
        goto ldv_50973;
      } else {

      }
      ldv_50972: ;
#line 519
      if ((int )links_reg >= 0) {
        {
#line 520
        status = -14;
#line 521
        descriptor.modname = "ixgbe";
#line 521
        descriptor.function = "ixgbe_start_mac_link_82599";
#line 521
        descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 521
        descriptor.format = "Autoneg did not complete.\n";
#line 521
        descriptor.lineno = 521U;
#line 521
        descriptor.flags = 0U;
#line 521
        tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
        }
#line 521
        if (tmp___0 != 0L) {
          {
#line 521
          __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                               "Autoneg did not complete.\n");
          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 527
  msleep(50U);
  }
  out: ;
#line 530
  return (status);
}
}
#line 541 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) 
{ 
  u32 esdp_reg ;
  u32 tmp ;

  {
  {
#line 543
  tmp = ixgbe_read_reg(hw, 32U);
#line 543
  esdp_reg = tmp;
#line 546
  esdp_reg = esdp_reg | 8U;
#line 547
  ixgbe_write_reg(hw, 32U, esdp_reg);
#line 548
  ixgbe_read_reg(hw, 8U);
#line 549
  __const_udelay(429500UL);
  }
#line 551
  return;
}
}
#line 560 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) 
{ 
  u32 esdp_reg ;
  u32 tmp ;

  {
  {
#line 562
  tmp = ixgbe_read_reg(hw, 32U);
#line 562
  esdp_reg = tmp;
#line 565
  esdp_reg = esdp_reg & 4294967287U;
#line 566
  ixgbe_write_reg(hw, 32U, esdp_reg);
#line 567
  ixgbe_read_reg(hw, 8U);
#line 568
  msleep(100U);
  }
#line 569
  return;
}
}
#line 583 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw ) 
{ 


  {
#line 585
  if ((int )hw->mac.autotry_restart) {
    {
#line 586
    ixgbe_disable_tx_laser_multispeed_fiber(hw);
#line 587
    ixgbe_enable_tx_laser_multispeed_fiber(hw);
#line 588
    hw->mac.autotry_restart = 0;
    }
  } else {

  }
#line 590
  return;
}
}
#line 601 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_set_fiber_fixed_speed(struct ixgbe_hw *hw , ixgbe_link_speed speed ) 
{ 
  s32 status ;
  u8 rs ;
  u8 eeprom_data ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;

  {
  {
#line 608
  if (speed == 128U) {
#line 608
    goto case_128;
  } else {

  }
#line 612
  if (speed == 32U) {
#line 612
    goto case_32;
  } else {

  }
#line 615
  goto switch_default;
  case_128: /* CIL Label */ 
#line 610
  rs = 8U;
#line 611
  goto ldv_50996;
  case_32: /* CIL Label */ 
#line 613
  rs = 0U;
#line 614
  goto ldv_50996;
  switch_default: /* CIL Label */ 
  {
#line 616
  descriptor.modname = "ixgbe";
#line 616
  descriptor.function = "ixgbe_set_fiber_fixed_speed";
#line 616
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 616
  descriptor.format = "Invalid fixed module speed\n";
#line 616
  descriptor.lineno = 616U;
#line 616
  descriptor.flags = 0U;
#line 616
  tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 616
  if (tmp != 0L) {
    {
#line 616
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Invalid fixed module speed\n");
    }
  } else {

  }
#line 617
  return;
  switch_break: /* CIL Label */ ;
  }
  ldv_50996: 
  {
#line 621
  status = (*(hw->phy.ops.read_i2c_byte))(hw, 110, 162, & eeprom_data);
  }
#line 624
  if (status != 0) {
    {
#line 625
    descriptor___0.modname = "ixgbe";
#line 625
    descriptor___0.function = "ixgbe_set_fiber_fixed_speed";
#line 625
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 625
    descriptor___0.format = "Failed to read Rx Rate Select RS0\n";
#line 625
    descriptor___0.lineno = 625U;
#line 625
    descriptor___0.flags = 0U;
#line 625
    tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 625
    if (tmp___0 != 0L) {
      {
#line 625
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Failed to read Rx Rate Select RS0\n");
      }
    } else {

    }
#line 626
    goto out;
  } else {

  }
  {
#line 629
  eeprom_data = (u8 )(((int )((signed char )eeprom_data) & -9) | (int )((signed char )rs));
#line 631
  status = (*(hw->phy.ops.write_i2c_byte))(hw, 110, 162, (int )eeprom_data);
  }
#line 634
  if (status != 0) {
    {
#line 635
    descriptor___1.modname = "ixgbe";
#line 635
    descriptor___1.function = "ixgbe_set_fiber_fixed_speed";
#line 635
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 635
    descriptor___1.format = "Failed to write Rx Rate Select RS0\n";
#line 635
    descriptor___1.lineno = 635U;
#line 635
    descriptor___1.flags = 0U;
#line 635
    tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 635
    if (tmp___1 != 0L) {
      {
#line 635
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Failed to write Rx Rate Select RS0\n");
      }
    } else {

    }
#line 636
    goto out;
  } else {

  }
  {
#line 640
  status = (*(hw->phy.ops.read_i2c_byte))(hw, 118, 162, & eeprom_data);
  }
#line 643
  if (status != 0) {
    {
#line 644
    descriptor___2.modname = "ixgbe";
#line 644
    descriptor___2.function = "ixgbe_set_fiber_fixed_speed";
#line 644
    descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 644
    descriptor___2.format = "Failed to read Rx Rate Select RS1\n";
#line 644
    descriptor___2.lineno = 644U;
#line 644
    descriptor___2.flags = 0U;
#line 644
    tmp___2 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
    }
#line 644
    if (tmp___2 != 0L) {
      {
#line 644
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Failed to read Rx Rate Select RS1\n");
      }
    } else {

    }
#line 645
    goto out;
  } else {

  }
  {
#line 648
  eeprom_data = (u8 )(((int )((signed char )eeprom_data) & -9) & (int )((signed char )rs));
#line 650
  status = (*(hw->phy.ops.write_i2c_byte))(hw, 118, 162, (int )eeprom_data);
  }
#line 653
  if (status != 0) {
    {
#line 654
    descriptor___3.modname = "ixgbe";
#line 654
    descriptor___3.function = "ixgbe_set_fiber_fixed_speed";
#line 654
    descriptor___3.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 654
    descriptor___3.format = "Failed to write Rx Rate Select RS1\n";
#line 654
    descriptor___3.lineno = 654U;
#line 654
    descriptor___3.flags = 0U;
#line 654
    tmp___3 = __builtin_expect((long )descriptor___3.flags & 1L, 0L);
    }
#line 654
    if (tmp___3 != 0L) {
      {
#line 654
      __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Failed to write Rx Rate Select RS1\n");
      }
    } else {

    }
#line 655
    goto out;
  } else {

  }
  out: ;
#line 658
  return;
}
}
#line 669 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                                 bool autoneg_wait_to_complete ) 
{ 
  s32 status ;
  ixgbe_link_speed link_speed ;
  ixgbe_link_speed highest_link_speed ;
  u32 speedcnt ;
  u32 esdp_reg ;
  u32 tmp ;
  u32 i ;
  bool link_up ;
  bool autoneg ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;

  {
  {
#line 673
  status = 0;
#line 674
  link_speed = 0U;
#line 675
  highest_link_speed = 0U;
#line 676
  speedcnt = 0U;
#line 677
  tmp = ixgbe_read_reg(hw, 32U);
#line 677
  esdp_reg = tmp;
#line 678
  i = 0U;
#line 679
  link_up = 0;
#line 680
  autoneg = 0;
#line 683
  status = (*(hw->mac.ops.get_link_capabilities))(hw, & link_speed, & autoneg);
  }
#line 685
  if (status != 0) {
#line 686
    return (status);
  } else {

  }
#line 688
  speed = speed & link_speed;
#line 694
  if ((speed & 128U) != 0U) {
    {
#line 695
    speedcnt = speedcnt + 1U;
#line 696
    highest_link_speed = 128U;
#line 699
    status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
    }
#line 701
    if (status != 0) {
#line 702
      return (status);
    } else {

    }
#line 704
    if (link_speed == 128U && (int )link_up) {
#line 705
      goto out;
    } else {

    }
    {
#line 709
    if ((unsigned int )hw->phy.media_type == 1U) {
#line 709
      goto case_1;
    } else {

    }
#line 714
    if ((unsigned int )hw->phy.media_type == 3U) {
#line 714
      goto case_3;
    } else {

    }
#line 717
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 710
    esdp_reg = esdp_reg | 8224U;
#line 711
    ixgbe_write_reg(hw, 32U, esdp_reg);
#line 712
    ixgbe_read_reg(hw, 8U);
    }
#line 713
    goto ldv_51021;
    case_3: /* CIL Label */ ;
#line 716
    goto ldv_51021;
    switch_default: /* CIL Label */ 
    {
#line 718
    descriptor.modname = "ixgbe";
#line 718
    descriptor.function = "ixgbe_setup_mac_link_multispeed_fiber";
#line 718
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 718
    descriptor.format = "Unexpected media type.\n";
#line 718
    descriptor.lineno = 718U;
#line 718
    descriptor.flags = 0U;
#line 718
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 718
    if (tmp___0 != 0L) {
      {
#line 718
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Unexpected media type.\n");
      }
    } else {

    }
#line 719
    goto ldv_51021;
    switch_break: /* CIL Label */ ;
    }
    ldv_51021: 
    {
#line 723
    msleep(40U);
#line 725
    status = ixgbe_setup_mac_link_82599(hw, 128U, (int )autoneg_wait_to_complete);
    }
#line 728
    if (status != 0) {
#line 729
      return (status);
    } else {

    }
#line 732
    if ((unsigned long )hw->mac.ops.flap_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
      {
#line 733
      (*(hw->mac.ops.flap_tx_laser))(hw);
      }
    } else {

    }
#line 740
    i = 0U;
#line 740
    goto ldv_51027;
    ldv_51026: 
    {
#line 742
    msleep(100U);
#line 745
    status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
    }
#line 747
    if (status != 0) {
#line 748
      return (status);
    } else {

    }
#line 750
    if ((int )link_up) {
#line 751
      goto out;
    } else {

    }
#line 740
    i = i + 1U;
    ldv_51027: ;
#line 740
    if (i <= 4U) {
#line 742
      goto ldv_51026;
    } else {

    }

  } else {

  }
#line 755
  if ((speed & 32U) != 0U) {
#line 756
    speedcnt = speedcnt + 1U;
#line 757
    if (highest_link_speed == 0U) {
#line 758
      highest_link_speed = 32U;
    } else {

    }
    {
#line 761
    status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
    }
#line 763
    if (status != 0) {
#line 764
      return (status);
    } else {

    }
#line 766
    if (link_speed == 32U && (int )link_up) {
#line 767
      goto out;
    } else {

    }
    {
#line 771
    if ((unsigned int )hw->phy.media_type == 2U) {
#line 771
      goto case_2;
    } else {

    }
#line 775
    if ((unsigned int )hw->phy.media_type == 1U) {
#line 775
      goto case_1___0;
    } else {

    }
#line 781
    if ((unsigned int )hw->phy.media_type == 3U) {
#line 781
      goto case_3___0;
    } else {

    }
#line 784
    goto switch_default___0;
    case_2: /* CIL Label */ 
    {
#line 772
    ixgbe_set_fiber_fixed_speed(hw, 32U);
    }
#line 774
    goto ldv_51030;
    case_1___0: /* CIL Label */ 
    {
#line 776
    esdp_reg = esdp_reg & 4294967263U;
#line 777
    esdp_reg = esdp_reg | 8192U;
#line 778
    ixgbe_write_reg(hw, 32U, esdp_reg);
#line 779
    ixgbe_read_reg(hw, 8U);
    }
#line 780
    goto ldv_51030;
    case_3___0: /* CIL Label */ ;
#line 783
    goto ldv_51030;
    switch_default___0: /* CIL Label */ 
    {
#line 785
    descriptor___0.modname = "ixgbe";
#line 785
    descriptor___0.function = "ixgbe_setup_mac_link_multispeed_fiber";
#line 785
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 785
    descriptor___0.format = "Unexpected media type.\n";
#line 785
    descriptor___0.lineno = 785U;
#line 785
    descriptor___0.flags = 0U;
#line 785
    tmp___1 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 785
    if (tmp___1 != 0L) {
      {
#line 785
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Unexpected media type.\n");
      }
    } else {

    }
#line 786
    goto ldv_51030;
    switch_break___0: /* CIL Label */ ;
    }
    ldv_51030: 
    {
#line 790
    msleep(40U);
#line 792
    status = ixgbe_setup_mac_link_82599(hw, 32U, (int )autoneg_wait_to_complete);
    }
#line 795
    if (status != 0) {
#line 796
      return (status);
    } else {

    }
#line 799
    if ((unsigned long )hw->mac.ops.flap_tx_laser != (unsigned long )((void (*)(struct ixgbe_hw * ))0)) {
      {
#line 800
      (*(hw->mac.ops.flap_tx_laser))(hw);
      }
    } else {

    }
    {
#line 803
    msleep(100U);
#line 806
    status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
    }
#line 808
    if (status != 0) {
#line 809
      return (status);
    } else {

    }
#line 811
    if ((int )link_up) {
#line 812
      goto out;
    } else {

    }
  } else {

  }
#line 820
  if (speedcnt > 1U) {
    {
#line 821
    status = ixgbe_setup_mac_link_multispeed_fiber(hw, highest_link_speed, (int )autoneg_wait_to_complete);
    }
  } else {

  }
  out: 
#line 827
  hw->phy.autoneg_advertised = 0U;
#line 829
  if ((speed & 128U) != 0U) {
#line 830
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 128U;
  } else {

  }
#line 832
  if ((speed & 32U) != 0U) {
#line 833
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 32U;
  } else {

  }
#line 835
  return (status);
}
}
#line 846 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                           bool autoneg_wait_to_complete ) 
{ 
  s32 status ;
  ixgbe_link_speed link_speed ;
  s32 i ;
  s32 j ;
  bool link_up ;
  u32 autoc_reg ;
  u32 tmp ;
  unsigned long __ms ;
  unsigned long tmp___0 ;
  unsigned long __ms___0 ;
  unsigned long tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;

  {
  {
#line 850
  status = 0;
#line 851
  link_speed = 0U;
#line 853
  link_up = 0;
#line 854
  tmp = ixgbe_read_reg(hw, 17056U);
#line 854
  autoc_reg = tmp;
#line 857
  hw->phy.autoneg_advertised = 0U;
  }
#line 859
  if ((speed & 128U) != 0U) {
#line 860
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 128U;
  } else {

  }
#line 862
  if ((speed & 32U) != 0U) {
#line 863
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 32U;
  } else {

  }
#line 865
  if ((speed & 8U) != 0U) {
#line 866
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 8U;
  } else {

  }
#line 876
  hw->phy.smart_speed_active = 0;
#line 877
  j = 0;
#line 877
  goto ldv_51055;
  ldv_51054: 
  {
#line 878
  status = ixgbe_setup_mac_link_82599(hw, speed, (int )autoneg_wait_to_complete);
  }
#line 880
  if (status != 0) {
#line 881
    goto out;
  } else {

  }
#line 889
  i = 0;
#line 889
  goto ldv_51052;
  ldv_51051: 
#line 890
  __ms = 100UL;
#line 890
  goto ldv_51049;
  ldv_51048: 
  {
#line 890
  __const_udelay(4295000UL);
  }
  ldv_51049: 
#line 890
  tmp___0 = __ms;
#line 890
  __ms = __ms - 1UL;
#line 890
  if (tmp___0 != 0UL) {
#line 892
    goto ldv_51048;
  } else {

  }
  {
#line 893
  status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
  }
#line 895
  if (status != 0) {
#line 896
    goto out;
  } else {

  }
#line 898
  if ((int )link_up) {
#line 899
    goto out;
  } else {

  }
#line 889
  i = i + 1;
  ldv_51052: ;
#line 889
  if (i <= 4) {
#line 891
    goto ldv_51051;
  } else {

  }
#line 877
  j = j + 1;
  ldv_51055: ;
#line 877
  if (j <= 2) {
#line 879
    goto ldv_51054;
  } else {

  }

#line 907
  if ((autoc_reg & 65536U) == 0U || (autoc_reg & 3221225472U) == 0U) {
#line 909
    goto out;
  } else {

  }
  {
#line 912
  hw->phy.smart_speed_active = 1;
#line 913
  status = ixgbe_setup_mac_link_82599(hw, speed, (int )autoneg_wait_to_complete);
  }
#line 915
  if (status != 0) {
#line 916
    goto out;
  } else {

  }
#line 924
  i = 0;
#line 924
  goto ldv_51062;
  ldv_51061: 
#line 925
  __ms___0 = 100UL;
#line 925
  goto ldv_51059;
  ldv_51058: 
  {
#line 925
  __const_udelay(4295000UL);
  }
  ldv_51059: 
#line 925
  tmp___1 = __ms___0;
#line 925
  __ms___0 = __ms___0 - 1UL;
#line 925
  if (tmp___1 != 0UL) {
#line 927
    goto ldv_51058;
  } else {

  }
  {
#line 928
  status = (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
  }
#line 930
  if (status != 0) {
#line 931
    goto out;
  } else {

  }
#line 933
  if ((int )link_up) {
#line 934
    goto out;
  } else {

  }
#line 924
  i = i + 1;
  ldv_51062: ;
#line 924
  if (i <= 5) {
#line 926
    goto ldv_51061;
  } else {

  }
  {
#line 938
  hw->phy.smart_speed_active = 0;
#line 939
  status = ixgbe_setup_mac_link_82599(hw, speed, (int )autoneg_wait_to_complete);
  }
  out: ;
#line 943
  if ((int )link_up && link_speed == 32U) {
    {
#line 944
    descriptor.modname = "ixgbe";
#line 944
    descriptor.function = "ixgbe_setup_mac_link_smartspeed";
#line 944
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 944
    descriptor.format = "Smartspeed has downgraded the link speed from the maximum advertised\n";
#line 944
    descriptor.lineno = 945U;
#line 944
    descriptor.flags = 0U;
#line 944
    tmp___2 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 944
    if (tmp___2 != 0L) {
      {
#line 944
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Smartspeed has downgraded the link speed from the maximum advertised\n");
      }
    } else {

    }
  } else {

  }
#line 946
  return (status);
}
}
#line 957 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                      bool autoneg_wait_to_complete ) 
{ 
  s32 status ;
  u32 autoc ;
  u32 pma_pmd_1g ;
  u32 link_mode ;
  u32 start_autoc ;
  u32 autoc2 ;
  u32 tmp ;
  u32 orig_autoc ;
  u32 pma_pmd_10g_serial ;
  u32 links_reg ;
  u32 i ;
  ixgbe_link_speed link_capabilities ;
  bool got_lock ;
  bool autoneg ;
  bool tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  {
#line 961
  status = 0;
#line 963
  tmp = ixgbe_read_reg(hw, 17064U);
#line 963
  autoc2 = tmp;
#line 964
  orig_autoc = 0U;
#line 965
  pma_pmd_10g_serial = autoc2 & 196608U;
#line 968
  link_capabilities = 0U;
#line 969
  got_lock = 0;
#line 970
  autoneg = 0;
#line 973
  status = (*(hw->mac.ops.get_link_capabilities))(hw, & link_capabilities, & autoneg);
  }
#line 975
  if (status != 0) {
#line 976
    goto out;
  } else {

  }
#line 978
  speed = speed & link_capabilities;
#line 980
  if (speed == 0U) {
#line 981
    status = -8;
#line 982
    goto out;
  } else {

  }
#line 986
  if ((int )hw->mac.orig_link_settings_stored) {
#line 987
    autoc = hw->mac.orig_autoc;
  } else {
    {
#line 989
    autoc = ixgbe_read_reg(hw, 17056U);
    }
  }
#line 991
  orig_autoc = autoc;
#line 992
  start_autoc = hw->mac.cached_autoc;
#line 993
  link_mode = autoc & 57344U;
#line 994
  pma_pmd_1g = autoc & 512U;
#line 996
  if ((link_mode == 32768U || link_mode == 49152U) || link_mode == 57344U) {
#line 1000
    autoc = autoc & 1073676287U;
#line 1001
    if ((speed & 128U) != 0U) {
#line 1002
      if ((int )orig_autoc < 0) {
#line 1003
        autoc = autoc | 2147483648U;
      } else {

      }
#line 1004
      if ((orig_autoc & 65536U) != 0U && ! hw->phy.smart_speed_active) {
#line 1006
        autoc = autoc | 65536U;
      } else {

      }
    } else {

    }
#line 1008
    if ((speed & 32U) != 0U) {
#line 1009
      autoc = autoc | 1073741824U;
    } else {

    }
  } else
#line 1010
  if (pma_pmd_1g == 0U && (link_mode == 0U || link_mode == 16384U)) {
#line 1014
    if (speed == 128U && pma_pmd_10g_serial == 131072U) {
#line 1016
      autoc = autoc & 4294909951U;
#line 1017
      autoc = autoc | 24576U;
    } else {

    }
  } else
#line 1019
  if (pma_pmd_10g_serial == 131072U && link_mode == 24576U) {
#line 1022
    if (speed == 32U && pma_pmd_1g == 0U) {
#line 1024
      autoc = autoc & 4294909951U;
#line 1025
      if ((int )autoneg) {
#line 1026
        autoc = autoc | 16384U;
      } else {
#line 1028
        autoc = autoc;
      }
    } else {

    }
  } else {

  }
#line 1032
  if (autoc != start_autoc) {
    {
#line 1037
    tmp___0 = ixgbe_verify_lesm_fw_enabled_82599(hw);
    }
#line 1037
    if ((int )tmp___0) {
      {
#line 1038
      status = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8);
      }
#line 1040
      if (status != 0) {
#line 1041
        goto out;
      } else {

      }
#line 1043
      got_lock = 1;
    } else {

    }
    {
#line 1047
    ixgbe_write_reg(hw, 17056U, autoc);
#line 1048
    hw->mac.cached_autoc = autoc;
#line 1049
    ixgbe_reset_pipeline_82599(hw);
    }
#line 1051
    if ((int )got_lock) {
      {
#line 1052
      (*(hw->mac.ops.release_swfw_sync))(hw, 8);
      }
    } else {

    }
#line 1056
    if ((int )autoneg_wait_to_complete) {
#line 1057
      if ((link_mode == 32768U || link_mode == 49152U) || link_mode == 57344U) {
#line 1060
        links_reg = 0U;
#line 1061
        i = 0U;
#line 1061
        goto ldv_51087;
        ldv_51086: 
        {
#line 1062
        links_reg = ixgbe_read_reg(hw, 17060U);
        }
#line 1064
        if ((int )links_reg < 0) {
#line 1065
          goto ldv_51085;
        } else {

        }
        {
#line 1066
        msleep(100U);
#line 1061
        i = i + 1U;
        }
        ldv_51087: ;
#line 1061
        if (i <= 44U) {
#line 1063
          goto ldv_51086;
        } else {

        }
        ldv_51085: ;
#line 1068
        if ((int )links_reg >= 0) {
          {
#line 1069
          status = -14;
#line 1071
          descriptor.modname = "ixgbe";
#line 1071
          descriptor.function = "ixgbe_setup_mac_link_82599";
#line 1071
          descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1071
          descriptor.format = "Autoneg did not complete.\n";
#line 1071
          descriptor.lineno = 1072U;
#line 1071
          descriptor.flags = 0U;
#line 1071
          tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
          }
#line 1071
          if (tmp___1 != 0L) {
            {
#line 1071
            __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                                 "Autoneg did not complete.\n");
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    {
#line 1078
    msleep(50U);
    }
  } else {

  }
  out: ;
#line 1082
  return (status);
}
}
#line 1093 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait_to_complete ) 
{ 
  s32 status ;

  {
  {
#line 1100
  status = (*(hw->phy.ops.setup_link_speed))(hw, speed, (int )autoneg_wait_to_complete);
#line 1103
  ixgbe_start_mac_link_82599(hw, (int )autoneg_wait_to_complete);
  }
#line 1105
  return (status);
}
}
#line 1116 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw ) 
{ 
  ixgbe_link_speed link_speed ;
  s32 status ;
  u32 ctrl ;
  u32 i ;
  u32 autoc2 ;
  u32 curr_lms ;
  bool link_up ;
  u32 tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  bool got_lock ;
  bool tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 1122
  link_up = 0;
#line 1125
  status = (*(hw->mac.ops.stop_adapter))(hw);
  }
#line 1126
  if (status != 0) {
#line 1127
    goto reset_hw_out;
  } else {

  }
  {
#line 1130
  ixgbe_clear_tx_pending(hw);
#line 1135
  status = (*(hw->phy.ops.init))(hw);
  }
#line 1137
  if (status == -19) {
#line 1138
    goto reset_hw_out;
  } else {

  }
#line 1141
  if ((int )hw->phy.sfp_setup_needed) {
    {
#line 1142
    status = (*(hw->mac.ops.setup_sfp))(hw);
#line 1143
    hw->phy.sfp_setup_needed = 0;
    }
  } else {

  }
#line 1146
  if (status == -19) {
#line 1147
    goto reset_hw_out;
  } else {

  }
#line 1150
  if (! hw->phy.reset_disable && (unsigned long )hw->phy.ops.reset != (unsigned long )((s32 (*)(struct ixgbe_hw * ))0)) {
    {
#line 1151
    (*(hw->phy.ops.reset))(hw);
    }
  } else {

  }
#line 1154
  if (hw->mac.cached_autoc != 0U) {
#line 1155
    curr_lms = hw->mac.cached_autoc & 57344U;
  } else {
    {
#line 1157
    tmp = ixgbe_read_reg(hw, 17056U);
#line 1157
    curr_lms = tmp & 57344U;
    }
  }
  mac_reset_top: 
#line 1167
  ctrl = 8U;
#line 1168
  if (! hw->force_full_reset) {
    {
#line 1169
    (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
    }
#line 1170
    if ((int )link_up) {
#line 1171
      ctrl = 67108864U;
    } else {

    }
  } else {

  }
  {
#line 1174
  tmp___0 = ixgbe_read_reg(hw, 0U);
#line 1174
  ctrl = ctrl | tmp___0;
#line 1175
  ixgbe_write_reg(hw, 0U, ctrl);
#line 1176
  ixgbe_read_reg(hw, 8U);
#line 1179
  i = 0U;
  }
#line 1179
  goto ldv_51110;
  ldv_51109: 
  {
#line 1180
  __const_udelay(4295UL);
#line 1181
  ctrl = ixgbe_read_reg(hw, 0U);
  }
#line 1182
  if ((ctrl & 67108872U) == 0U) {
#line 1183
    goto ldv_51108;
  } else {

  }
#line 1179
  i = i + 1U;
  ldv_51110: ;
#line 1179
  if (i <= 9U) {
#line 1181
    goto ldv_51109;
  } else {

  }
  ldv_51108: ;
#line 1186
  if ((ctrl & 67108872U) != 0U) {
    {
#line 1187
    status = -15;
#line 1188
    descriptor.modname = "ixgbe";
#line 1188
    descriptor.function = "ixgbe_reset_hw_82599";
#line 1188
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1188
    descriptor.format = "Reset polling failed to complete.\n";
#line 1188
    descriptor.lineno = 1188U;
#line 1188
    descriptor.flags = 0U;
#line 1188
    tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1188
    if (tmp___1 != 0L) {
      {
#line 1188
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Reset polling failed to complete.\n");
      }
    } else {

    }
  } else {

  }
  {
#line 1191
  msleep(50U);
  }
#line 1198
  if ((int )hw->mac.flags & 1) {
#line 1199
    hw->mac.flags = (unsigned int )hw->mac.flags & 254U;
#line 1200
    goto mac_reset_top;
  } else {

  }
  {
#line 1208
  hw->mac.cached_autoc = ixgbe_read_reg(hw, 17056U);
#line 1209
  autoc2 = ixgbe_read_reg(hw, 17064U);
  }
#line 1212
  if ((autoc2 & 1879048192U) != 0U) {
    {
#line 1213
    autoc2 = autoc2 & 2415919103U;
#line 1214
    ixgbe_write_reg(hw, 17064U, autoc2);
#line 1215
    ixgbe_read_reg(hw, 8U);
    }
  } else {

  }
#line 1218
  if (! hw->mac.orig_link_settings_stored) {
#line 1219
    hw->mac.orig_autoc = hw->mac.cached_autoc;
#line 1220
    hw->mac.orig_autoc2 = autoc2;
#line 1221
    hw->mac.orig_link_settings_stored = 1;
  } else {
#line 1230
    if (((int )hw->phy.multispeed_fiber && (int )hw->mng_fw_enabled) || (int )hw->wol_enabled) {
#line 1232
      hw->mac.orig_autoc = (hw->mac.orig_autoc & 4294909951U) | curr_lms;
    } else {

    }
#line 1236
    if (hw->mac.cached_autoc != hw->mac.orig_autoc) {
      {
#line 1241
      got_lock = 0;
#line 1242
      tmp___2 = ixgbe_verify_lesm_fw_enabled_82599(hw);
      }
#line 1242
      if ((int )tmp___2) {
        {
#line 1243
        status = (*(hw->mac.ops.acquire_swfw_sync))(hw, 8);
        }
#line 1245
        if (status != 0) {
#line 1246
          goto reset_hw_out;
        } else {

        }
#line 1248
        got_lock = 1;
      } else {

      }
      {
#line 1251
      ixgbe_write_reg(hw, 17056U, hw->mac.orig_autoc);
#line 1252
      hw->mac.cached_autoc = hw->mac.orig_autoc;
#line 1253
      ixgbe_reset_pipeline_82599(hw);
      }
#line 1255
      if ((int )got_lock) {
        {
#line 1256
        (*(hw->mac.ops.release_swfw_sync))(hw, 8);
        }
      } else {

      }
    } else {

    }
#line 1260
    if (((autoc2 ^ hw->mac.orig_autoc2) & 4294901760U) != 0U) {
      {
#line 1262
      autoc2 = autoc2 & 65535U;
#line 1263
      autoc2 = autoc2 | (hw->mac.orig_autoc2 & 4294901760U);
#line 1265
      ixgbe_write_reg(hw, 17064U, autoc2);
      }
    } else {

    }
  }
  {
#line 1270
  (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.perm_addr));
#line 1277
  hw->mac.num_rar_entries = 128U;
#line 1278
  (*(hw->mac.ops.init_rx_addrs))(hw);
#line 1281
  (*(hw->mac.ops.get_san_mac_addr))(hw, (u8 *)(& hw->mac.san_addr));
#line 1284
  tmp___3 = is_valid_ether_addr((u8 const   *)(& hw->mac.san_addr));
  }
#line 1284
  if ((int )tmp___3) {
    {
#line 1285
    (*(hw->mac.ops.set_rar))(hw, hw->mac.num_rar_entries - 1U, (u8 *)(& hw->mac.san_addr),
                             0U, 2147483648U);
#line 1289
    hw->mac.san_mac_rar_index = (unsigned int )((u8 )hw->mac.num_rar_entries) - 1U;
#line 1292
    hw->mac.num_rar_entries = hw->mac.num_rar_entries - 1U;
    }
  } else {

  }
  {
#line 1296
  (*(hw->mac.ops.get_wwn_prefix))(hw, & hw->mac.wwnn_prefix, & hw->mac.wwpn_prefix);
  }
  reset_hw_out: ;
#line 1300
  return (status);
}
}
#line 1307 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw ) 
{ 
  int i ;
  u32 fdirctrl ;
  u32 tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  struct _ddebug descriptor___0 ;
  long tmp___5 ;

  {
  {
#line 1310
  tmp = ixgbe_read_reg(hw, 60928U);
#line 1310
  fdirctrl = tmp;
#line 1311
  fdirctrl = fdirctrl & 4294967287U;
#line 1317
  i = 0;
  }
#line 1317
  goto ldv_51121;
  ldv_51120: 
  {
#line 1318
  tmp___0 = ixgbe_read_reg(hw, 60972U);
  }
#line 1318
  if ((tmp___0 & 3U) == 0U) {
#line 1320
    goto ldv_51119;
  } else {

  }
  {
#line 1321
  __const_udelay(42950UL);
#line 1317
  i = i + 1;
  }
  ldv_51121: ;
#line 1317
  if (i <= 9) {
#line 1319
    goto ldv_51120;
  } else {

  }
  ldv_51119: ;
#line 1323
  if (i > 9) {
    {
#line 1324
    descriptor.modname = "ixgbe";
#line 1324
    descriptor.function = "ixgbe_reinit_fdir_tables_82599";
#line 1324
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1324
    descriptor.format = "Flow Director previous command isn\'t complete, aborting table re-initialization.\n";
#line 1324
    descriptor.lineno = 1325U;
#line 1324
    descriptor.flags = 0U;
#line 1324
    tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1324
    if (tmp___1 != 0L) {
      {
#line 1324
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Director previous command isn\'t complete, aborting table re-initialization.\n");
      }
    } else {

    }
#line 1326
    return (-23);
  } else {

  }
  {
#line 1329
  ixgbe_write_reg(hw, 60984U, 0U);
#line 1330
  ixgbe_read_reg(hw, 8U);
#line 1338
  tmp___2 = ixgbe_read_reg(hw, 60972U);
#line 1338
  ixgbe_write_reg(hw, 60972U, tmp___2 | 256U);
#line 1341
  ixgbe_read_reg(hw, 8U);
#line 1342
  tmp___3 = ixgbe_read_reg(hw, 60972U);
#line 1342
  ixgbe_write_reg(hw, 60972U, tmp___3 & 4294967039U);
#line 1345
  ixgbe_read_reg(hw, 8U);
#line 1350
  ixgbe_write_reg(hw, 60968U, 0U);
#line 1351
  ixgbe_read_reg(hw, 8U);
#line 1353
  ixgbe_write_reg(hw, 60928U, fdirctrl);
#line 1354
  ixgbe_read_reg(hw, 8U);
#line 1357
  i = 0;
  }
#line 1357
  goto ldv_51126;
  ldv_51125: 
  {
#line 1358
  tmp___4 = ixgbe_read_reg(hw, 60928U);
  }
#line 1358
  if ((tmp___4 & 8U) != 0U) {
#line 1360
    goto ldv_51124;
  } else {

  }
  {
#line 1361
  usleep_range(1000UL, 2000UL);
#line 1357
  i = i + 1;
  }
  ldv_51126: ;
#line 1357
  if (i <= 9) {
#line 1359
    goto ldv_51125;
  } else {

  }
  ldv_51124: ;
#line 1363
  if (i > 9) {
    {
#line 1364
    descriptor___0.modname = "ixgbe";
#line 1364
    descriptor___0.function = "ixgbe_reinit_fdir_tables_82599";
#line 1364
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1364
    descriptor___0.format = "Flow Director Signature poll time exceeded!\n";
#line 1364
    descriptor___0.lineno = 1364U;
#line 1364
    descriptor___0.flags = 0U;
#line 1364
    tmp___5 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 1364
    if (tmp___5 != 0L) {
      {
#line 1364
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Director Signature poll time exceeded!\n");
      }
    } else {

    }
#line 1365
    return (-23);
  } else {

  }
  {
#line 1369
  ixgbe_read_reg(hw, 61008U);
#line 1370
  ixgbe_read_reg(hw, 61012U);
#line 1371
  ixgbe_read_reg(hw, 61016U);
#line 1372
  ixgbe_read_reg(hw, 61020U);
#line 1373
  ixgbe_read_reg(hw, 61004U);
  }
#line 1375
  return (0);
}
}
#line 1383 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw , u32 fdirctrl ) 
{ 
  int i ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 1388
  ixgbe_write_reg(hw, 61032U, 1034753250U);
#line 1389
  ixgbe_write_reg(hw, 61036U, 390936084U);
#line 1404
  ixgbe_write_reg(hw, 60928U, fdirctrl);
#line 1405
  ixgbe_read_reg(hw, 8U);
#line 1406
  i = 0;
  }
#line 1406
  goto ldv_51135;
  ldv_51134: 
  {
#line 1407
  tmp = ixgbe_read_reg(hw, 60928U);
  }
#line 1407
  if ((tmp & 8U) != 0U) {
#line 1409
    goto ldv_51133;
  } else {

  }
  {
#line 1410
  usleep_range(1000UL, 2000UL);
#line 1406
  i = i + 1;
  }
  ldv_51135: ;
#line 1406
  if (i <= 9) {
#line 1408
    goto ldv_51134;
  } else {

  }
  ldv_51133: ;
#line 1413
  if (i > 9) {
    {
#line 1414
    descriptor.modname = "ixgbe";
#line 1414
    descriptor.function = "ixgbe_fdir_enable_82599";
#line 1414
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1414
    descriptor.format = "Flow Director poll time exceeded!\n";
#line 1414
    descriptor.lineno = 1414U;
#line 1414
    descriptor.flags = 0U;
#line 1414
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1414
    if (tmp___0 != 0L) {
      {
#line 1414
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flow Director poll time exceeded!\n");
      }
    } else {

    }
  } else {

  }
#line 1416
  return;
}
}
#line 1423 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw , u32 fdirctrl ) 
{ 


  {
  {
#line 1431
  fdirctrl = fdirctrl | 1241907200U;
#line 1436
  ixgbe_fdir_enable_82599(hw, fdirctrl);
  }
#line 1438
  return (0);
}
}
#line 1447 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw , u32 fdirctrl ) 
{ 


  {
  {
#line 1458
  fdirctrl = fdirctrl | 1241939760U;
#line 1466
  ixgbe_fdir_enable_82599(hw, fdirctrl);
  }
#line 1468
  return (0);
}
}
#line 1505 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input , union ixgbe_atr_hash_dword common ) 
{ 
  u32 hi_hash_dword ;
  u32 lo_hash_dword ;
  u32 flow_vm_vlan ;
  u32 sig_hash ;
  u32 bucket_hash ;
  u32 common_hash ;
  __u32 tmp ;
  __u32 tmp___0 ;
  u32 n ;
  u32 n___0 ;
  u32 n___1 ;
  u32 n___2 ;
  u32 n___3 ;
  u32 n___4 ;
  u32 n___5 ;
  u32 n___6 ;
  u32 n___7 ;
  u32 n___8 ;
  u32 n___9 ;
  u32 n___10 ;
  u32 n___11 ;
  u32 n___12 ;
  u32 n___13 ;
  u32 n___14 ;

  {
  {
#line 1509
  sig_hash = 0U;
#line 1509
  bucket_hash = 0U;
#line 1509
  common_hash = 0U;
#line 1512
  tmp = __fswab32(input.dword);
#line 1512
  flow_vm_vlan = tmp;
#line 1515
  tmp___0 = __fswab32(common.dword);
#line 1515
  hi_hash_dword = tmp___0;
#line 1518
  lo_hash_dword = (hi_hash_dword << 16) | (hi_hash_dword >> (8UL * sizeof(hi_hash_dword) - 16UL));
#line 1521
  hi_hash_dword = hi_hash_dword ^ (flow_vm_vlan ^ (flow_vm_vlan >> 16));
#line 1524
  n = 0U;
  }
#line 1524
  if ((353178624 >> (int )n) & 1) {
#line 1524
    common_hash = common_hash ^ (lo_hash_dword >> (int )n);
  } else
#line 1524
  if ((1034753250 >> (int )n) & 1) {
#line 1524
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n);
  } else
#line 1524
  if ((390936084 >> (int )n) & 1) {
#line 1524
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n));
  } else {

  }
#line 1524
  if ((353178624 >> (int )(n + 16U)) & 1) {
#line 1524
    common_hash = common_hash ^ (hi_hash_dword >> (int )n);
  } else
#line 1524
  if ((1034753250 >> (int )(n + 16U)) & 1) {
#line 1524
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n);
  } else
#line 1524
  if ((390936084 >> (int )(n + 16U)) & 1) {
#line 1524
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n));
  } else {

  }
#line 1531
  lo_hash_dword = lo_hash_dword ^ (flow_vm_vlan ^ (flow_vm_vlan << 16));
#line 1534
  n___0 = 1U;
#line 1534
  if ((353178624 >> (int )n___0) & 1) {
#line 1534
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___0);
  } else
#line 1534
  if ((1034753250 >> (int )n___0) & 1) {
#line 1534
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___0);
  } else
#line 1534
  if ((390936084 >> (int )n___0) & 1) {
#line 1534
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___0));
  } else {

  }
#line 1534
  if ((353178624 >> (int )(n___0 + 16U)) & 1) {
#line 1534
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___0);
  } else
#line 1534
  if ((1034753250 >> (int )(n___0 + 16U)) & 1) {
#line 1534
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___0);
  } else
#line 1534
  if ((390936084 >> (int )(n___0 + 16U)) & 1) {
#line 1534
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___0));
  } else {

  }
#line 1535
  n___1 = 2U;
#line 1535
  if ((353178624 >> (int )n___1) & 1) {
#line 1535
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___1);
  } else
#line 1535
  if ((1034753250 >> (int )n___1) & 1) {
#line 1535
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___1);
  } else
#line 1535
  if ((390936084 >> (int )n___1) & 1) {
#line 1535
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___1));
  } else {

  }
#line 1535
  if ((353178624 >> (int )(n___1 + 16U)) & 1) {
#line 1535
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___1);
  } else
#line 1535
  if ((1034753250 >> (int )(n___1 + 16U)) & 1) {
#line 1535
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___1);
  } else
#line 1535
  if ((390936084 >> (int )(n___1 + 16U)) & 1) {
#line 1535
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___1));
  } else {

  }
#line 1536
  n___2 = 3U;
#line 1536
  if ((353178624 >> (int )n___2) & 1) {
#line 1536
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___2);
  } else
#line 1536
  if ((1034753250 >> (int )n___2) & 1) {
#line 1536
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___2);
  } else
#line 1536
  if ((390936084 >> (int )n___2) & 1) {
#line 1536
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___2));
  } else {

  }
#line 1536
  if ((353178624 >> (int )(n___2 + 16U)) & 1) {
#line 1536
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___2);
  } else
#line 1536
  if ((1034753250 >> (int )(n___2 + 16U)) & 1) {
#line 1536
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___2);
  } else
#line 1536
  if ((390936084 >> (int )(n___2 + 16U)) & 1) {
#line 1536
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___2));
  } else {

  }
#line 1537
  n___3 = 4U;
#line 1537
  if ((353178624 >> (int )n___3) & 1) {
#line 1537
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___3);
  } else
#line 1537
  if ((1034753250 >> (int )n___3) & 1) {
#line 1537
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___3);
  } else
#line 1537
  if ((390936084 >> (int )n___3) & 1) {
#line 1537
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___3));
  } else {

  }
#line 1537
  if ((353178624 >> (int )(n___3 + 16U)) & 1) {
#line 1537
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___3);
  } else
#line 1537
  if ((1034753250 >> (int )(n___3 + 16U)) & 1) {
#line 1537
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___3);
  } else
#line 1537
  if ((390936084 >> (int )(n___3 + 16U)) & 1) {
#line 1537
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___3));
  } else {

  }
#line 1538
  n___4 = 5U;
#line 1538
  if ((353178624 >> (int )n___4) & 1) {
#line 1538
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___4);
  } else
#line 1538
  if ((1034753250 >> (int )n___4) & 1) {
#line 1538
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___4);
  } else
#line 1538
  if ((390936084 >> (int )n___4) & 1) {
#line 1538
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___4));
  } else {

  }
#line 1538
  if ((353178624 >> (int )(n___4 + 16U)) & 1) {
#line 1538
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___4);
  } else
#line 1538
  if ((1034753250 >> (int )(n___4 + 16U)) & 1) {
#line 1538
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___4);
  } else
#line 1538
  if ((390936084 >> (int )(n___4 + 16U)) & 1) {
#line 1538
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___4));
  } else {

  }
#line 1539
  n___5 = 6U;
#line 1539
  if ((353178624 >> (int )n___5) & 1) {
#line 1539
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___5);
  } else
#line 1539
  if ((1034753250 >> (int )n___5) & 1) {
#line 1539
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___5);
  } else
#line 1539
  if ((390936084 >> (int )n___5) & 1) {
#line 1539
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___5));
  } else {

  }
#line 1539
  if ((353178624 >> (int )(n___5 + 16U)) & 1) {
#line 1539
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___5);
  } else
#line 1539
  if ((1034753250 >> (int )(n___5 + 16U)) & 1) {
#line 1539
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___5);
  } else
#line 1539
  if ((390936084 >> (int )(n___5 + 16U)) & 1) {
#line 1539
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___5));
  } else {

  }
#line 1540
  n___6 = 7U;
#line 1540
  if ((353178624 >> (int )n___6) & 1) {
#line 1540
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___6);
  } else
#line 1540
  if ((1034753250 >> (int )n___6) & 1) {
#line 1540
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___6);
  } else
#line 1540
  if ((390936084 >> (int )n___6) & 1) {
#line 1540
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___6));
  } else {

  }
#line 1540
  if ((353178624 >> (int )(n___6 + 16U)) & 1) {
#line 1540
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___6);
  } else
#line 1540
  if ((1034753250 >> (int )(n___6 + 16U)) & 1) {
#line 1540
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___6);
  } else
#line 1540
  if ((390936084 >> (int )(n___6 + 16U)) & 1) {
#line 1540
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___6));
  } else {

  }
#line 1541
  n___7 = 8U;
#line 1541
  if ((353178624 >> (int )n___7) & 1) {
#line 1541
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___7);
  } else
#line 1541
  if ((1034753250 >> (int )n___7) & 1) {
#line 1541
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___7);
  } else
#line 1541
  if ((390936084 >> (int )n___7) & 1) {
#line 1541
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___7));
  } else {

  }
#line 1541
  if ((353178624 >> (int )(n___7 + 16U)) & 1) {
#line 1541
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___7);
  } else
#line 1541
  if ((1034753250 >> (int )(n___7 + 16U)) & 1) {
#line 1541
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___7);
  } else
#line 1541
  if ((390936084 >> (int )(n___7 + 16U)) & 1) {
#line 1541
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___7));
  } else {

  }
#line 1542
  n___8 = 9U;
#line 1542
  if ((353178624 >> (int )n___8) & 1) {
#line 1542
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___8);
  } else
#line 1542
  if ((1034753250 >> (int )n___8) & 1) {
#line 1542
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___8);
  } else
#line 1542
  if ((390936084 >> (int )n___8) & 1) {
#line 1542
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___8));
  } else {

  }
#line 1542
  if ((353178624 >> (int )(n___8 + 16U)) & 1) {
#line 1542
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___8);
  } else
#line 1542
  if ((1034753250 >> (int )(n___8 + 16U)) & 1) {
#line 1542
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___8);
  } else
#line 1542
  if ((390936084 >> (int )(n___8 + 16U)) & 1) {
#line 1542
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___8));
  } else {

  }
#line 1543
  n___9 = 10U;
#line 1543
  if ((353178624 >> (int )n___9) & 1) {
#line 1543
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___9);
  } else
#line 1543
  if ((1034753250 >> (int )n___9) & 1) {
#line 1543
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___9);
  } else
#line 1543
  if ((390936084 >> (int )n___9) & 1) {
#line 1543
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___9));
  } else {

  }
#line 1543
  if ((353178624 >> (int )(n___9 + 16U)) & 1) {
#line 1543
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___9);
  } else
#line 1543
  if ((1034753250 >> (int )(n___9 + 16U)) & 1) {
#line 1543
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___9);
  } else
#line 1543
  if ((390936084 >> (int )(n___9 + 16U)) & 1) {
#line 1543
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___9));
  } else {

  }
#line 1544
  n___10 = 11U;
#line 1544
  if ((353178624 >> (int )n___10) & 1) {
#line 1544
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___10);
  } else
#line 1544
  if ((1034753250 >> (int )n___10) & 1) {
#line 1544
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___10);
  } else
#line 1544
  if ((390936084 >> (int )n___10) & 1) {
#line 1544
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___10));
  } else {

  }
#line 1544
  if ((353178624 >> (int )(n___10 + 16U)) & 1) {
#line 1544
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___10);
  } else
#line 1544
  if ((1034753250 >> (int )(n___10 + 16U)) & 1) {
#line 1544
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___10);
  } else
#line 1544
  if ((390936084 >> (int )(n___10 + 16U)) & 1) {
#line 1544
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___10));
  } else {

  }
#line 1545
  n___11 = 12U;
#line 1545
  if ((353178624 >> (int )n___11) & 1) {
#line 1545
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___11);
  } else
#line 1545
  if ((1034753250 >> (int )n___11) & 1) {
#line 1545
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___11);
  } else
#line 1545
  if ((390936084 >> (int )n___11) & 1) {
#line 1545
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___11));
  } else {

  }
#line 1545
  if ((353178624 >> (int )(n___11 + 16U)) & 1) {
#line 1545
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___11);
  } else
#line 1545
  if ((1034753250 >> (int )(n___11 + 16U)) & 1) {
#line 1545
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___11);
  } else
#line 1545
  if ((390936084 >> (int )(n___11 + 16U)) & 1) {
#line 1545
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___11));
  } else {

  }
#line 1546
  n___12 = 13U;
#line 1546
  if ((353178624 >> (int )n___12) & 1) {
#line 1546
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___12);
  } else
#line 1546
  if ((1034753250 >> (int )n___12) & 1) {
#line 1546
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___12);
  } else
#line 1546
  if ((390936084 >> (int )n___12) & 1) {
#line 1546
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___12));
  } else {

  }
#line 1546
  if ((353178624 >> (int )(n___12 + 16U)) & 1) {
#line 1546
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___12);
  } else
#line 1546
  if ((1034753250 >> (int )(n___12 + 16U)) & 1) {
#line 1546
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___12);
  } else
#line 1546
  if ((390936084 >> (int )(n___12 + 16U)) & 1) {
#line 1546
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___12));
  } else {

  }
#line 1547
  n___13 = 14U;
#line 1547
  if ((353178624 >> (int )n___13) & 1) {
#line 1547
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___13);
  } else
#line 1547
  if ((1034753250 >> (int )n___13) & 1) {
#line 1547
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___13);
  } else
#line 1547
  if ((390936084 >> (int )n___13) & 1) {
#line 1547
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___13));
  } else {

  }
#line 1547
  if ((353178624 >> (int )(n___13 + 16U)) & 1) {
#line 1547
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___13);
  } else
#line 1547
  if ((1034753250 >> (int )(n___13 + 16U)) & 1) {
#line 1547
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___13);
  } else
#line 1547
  if ((390936084 >> (int )(n___13 + 16U)) & 1) {
#line 1547
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___13));
  } else {

  }
#line 1548
  n___14 = 15U;
#line 1548
  if ((353178624 >> (int )n___14) & 1) {
#line 1548
    common_hash = common_hash ^ (lo_hash_dword >> (int )n___14);
  } else
#line 1548
  if ((1034753250 >> (int )n___14) & 1) {
#line 1548
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___14);
  } else
#line 1548
  if ((390936084 >> (int )n___14) & 1) {
#line 1548
    sig_hash = sig_hash ^ (lo_hash_dword << (int )(16U - n___14));
  } else {

  }
#line 1548
  if ((353178624 >> (int )(n___14 + 16U)) & 1) {
#line 1548
    common_hash = common_hash ^ (hi_hash_dword >> (int )n___14);
  } else
#line 1548
  if ((1034753250 >> (int )(n___14 + 16U)) & 1) {
#line 1548
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___14);
  } else
#line 1548
  if ((390936084 >> (int )(n___14 + 16U)) & 1) {
#line 1548
    sig_hash = sig_hash ^ (hi_hash_dword << (int )(16U - n___14));
  } else {

  }
#line 1551
  bucket_hash = bucket_hash ^ common_hash;
#line 1552
  bucket_hash = bucket_hash & 32767U;
#line 1554
  sig_hash = sig_hash ^ (common_hash << 16);
#line 1555
  sig_hash = sig_hash & 2147418112U;
#line 1558
  return (sig_hash ^ bucket_hash);
}
}
#line 1568 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_hash_dword input ,
                                          union ixgbe_atr_hash_dword common , u8 queue ) 
{ 
  u64 fdirhashcmd ;
  u32 fdircmd ;
  struct _ddebug descriptor ;
  long tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;

  {
  {
#line 1581
  if ((int )input.formatted.flow_type == 2) {
#line 1581
    goto case_2;
  } else {

  }
#line 1582
  if ((int )input.formatted.flow_type == 1) {
#line 1582
    goto case_1;
  } else {

  }
#line 1583
  if ((int )input.formatted.flow_type == 3) {
#line 1583
    goto case_3;
  } else {

  }
#line 1584
  if ((int )input.formatted.flow_type == 6) {
#line 1584
    goto case_6;
  } else {

  }
#line 1585
  if ((int )input.formatted.flow_type == 5) {
#line 1585
    goto case_5;
  } else {

  }
#line 1586
  if ((int )input.formatted.flow_type == 7) {
#line 1586
    goto case_7;
  } else {

  }
#line 1588
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_1: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
  case_6: /* CIL Label */ ;
  case_5: /* CIL Label */ ;
  case_7: /* CIL Label */ ;
#line 1587
  goto ldv_51186;
  switch_default: /* CIL Label */ 
  {
#line 1589
  descriptor.modname = "ixgbe";
#line 1589
  descriptor.function = "ixgbe_fdir_add_signature_filter_82599";
#line 1589
  descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1589
  descriptor.format = " Error on flow type input\n";
#line 1589
  descriptor.lineno = 1589U;
#line 1589
  descriptor.flags = 0U;
#line 1589
  tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
  }
#line 1589
  if (tmp != 0L) {
    {
#line 1589
    __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on flow type input\n");
    }
  } else {

  }
#line 1590
  return (-4);
  switch_break: /* CIL Label */ ;
  }
  ldv_51186: 
  {
#line 1594
  fdircmd = 34825U;
#line 1596
  fdircmd = fdircmd | (u32 )((int )input.formatted.flow_type << 5);
#line 1597
  fdircmd = fdircmd | ((unsigned int )queue << 16);
#line 1603
  fdirhashcmd = (unsigned long long )fdircmd << 32;
#line 1604
  tmp___0 = ixgbe_atr_compute_sig_hash_82599(input, common);
#line 1604
  fdirhashcmd = fdirhashcmd | (u64 )tmp___0;
#line 1605
  ixgbe_write_reg64(hw, 60968U, fdirhashcmd);
#line 1607
  descriptor___0.modname = "ixgbe";
#line 1607
  descriptor___0.function = "ixgbe_fdir_add_signature_filter_82599";
#line 1607
  descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1607
  descriptor___0.format = "Tx Queue=%x hash=%x\n";
#line 1607
  descriptor___0.lineno = 1607U;
#line 1607
  descriptor___0.flags = 0U;
#line 1607
  tmp___1 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
  }
#line 1607
  if (tmp___1 != 0L) {
    {
#line 1607
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Tx Queue=%x hash=%x\n", (int )queue, (unsigned int )fdirhashcmd);
    }
  } else {

  }
#line 1609
  return (0);
}
}
#line 1632 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input , union ixgbe_atr_input *input_mask ) 
{ 
  u32 hi_hash_dword ;
  u32 lo_hash_dword ;
  u32 flow_vm_vlan ;
  u32 bucket_hash ;
  __u32 tmp ;
  __u32 tmp___0 ;
  u32 n ;
  u32 n___0 ;
  u32 n___1 ;
  u32 n___2 ;
  u32 n___3 ;
  u32 n___4 ;
  u32 n___5 ;
  u32 n___6 ;
  u32 n___7 ;
  u32 n___8 ;
  u32 n___9 ;
  u32 n___10 ;
  u32 n___11 ;
  u32 n___12 ;
  u32 n___13 ;
  u32 n___14 ;

  {
  {
#line 1637
  bucket_hash = 0U;
#line 1640
  input->dword_stream[0] = input->dword_stream[0] & input_mask->dword_stream[0];
#line 1641
  input->dword_stream[1] = input->dword_stream[1] & input_mask->dword_stream[1];
#line 1642
  input->dword_stream[2] = input->dword_stream[2] & input_mask->dword_stream[2];
#line 1643
  input->dword_stream[3] = input->dword_stream[3] & input_mask->dword_stream[3];
#line 1644
  input->dword_stream[4] = input->dword_stream[4] & input_mask->dword_stream[4];
#line 1645
  input->dword_stream[5] = input->dword_stream[5] & input_mask->dword_stream[5];
#line 1646
  input->dword_stream[6] = input->dword_stream[6] & input_mask->dword_stream[6];
#line 1647
  input->dword_stream[7] = input->dword_stream[7] & input_mask->dword_stream[7];
#line 1648
  input->dword_stream[8] = input->dword_stream[8] & input_mask->dword_stream[8];
#line 1649
  input->dword_stream[9] = input->dword_stream[9] & input_mask->dword_stream[9];
#line 1650
  input->dword_stream[10] = input->dword_stream[10] & input_mask->dword_stream[10];
#line 1653
  tmp = __fswab32(input->dword_stream[0]);
#line 1653
  flow_vm_vlan = tmp;
#line 1656
  tmp___0 = __fswab32(((((((((input->dword_stream[1] ^ input->dword_stream[2]) ^ input->dword_stream[3]) ^ input->dword_stream[4]) ^ input->dword_stream[5]) ^ input->dword_stream[6]) ^ input->dword_stream[7]) ^ input->dword_stream[8]) ^ input->dword_stream[9]) ^ input->dword_stream[10]);
#line 1656
  hi_hash_dword = tmp___0;
#line 1668
  lo_hash_dword = (hi_hash_dword << 16) | (hi_hash_dword >> (8UL * sizeof(hi_hash_dword) - 16UL));
#line 1671
  hi_hash_dword = hi_hash_dword ^ (flow_vm_vlan ^ (flow_vm_vlan >> 16));
#line 1674
  n = 0U;
  }
#line 1674
  if ((1034753250 >> (int )n) & 1) {
#line 1674
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n);
  } else {

  }
#line 1674
  if ((1034753250 >> (int )(n + 16U)) & 1) {
#line 1674
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n);
  } else {

  }
#line 1681
  lo_hash_dword = lo_hash_dword ^ (flow_vm_vlan ^ (flow_vm_vlan << 16));
#line 1684
  n___0 = 1U;
#line 1684
  if ((1034753250 >> (int )n___0) & 1) {
#line 1684
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___0);
  } else {

  }
#line 1684
  if ((1034753250 >> (int )(n___0 + 16U)) & 1) {
#line 1684
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___0);
  } else {

  }
#line 1685
  n___1 = 2U;
#line 1685
  if ((1034753250 >> (int )n___1) & 1) {
#line 1685
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___1);
  } else {

  }
#line 1685
  if ((1034753250 >> (int )(n___1 + 16U)) & 1) {
#line 1685
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___1);
  } else {

  }
#line 1686
  n___2 = 3U;
#line 1686
  if ((1034753250 >> (int )n___2) & 1) {
#line 1686
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___2);
  } else {

  }
#line 1686
  if ((1034753250 >> (int )(n___2 + 16U)) & 1) {
#line 1686
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___2);
  } else {

  }
#line 1687
  n___3 = 4U;
#line 1687
  if ((1034753250 >> (int )n___3) & 1) {
#line 1687
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___3);
  } else {

  }
#line 1687
  if ((1034753250 >> (int )(n___3 + 16U)) & 1) {
#line 1687
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___3);
  } else {

  }
#line 1688
  n___4 = 5U;
#line 1688
  if ((1034753250 >> (int )n___4) & 1) {
#line 1688
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___4);
  } else {

  }
#line 1688
  if ((1034753250 >> (int )(n___4 + 16U)) & 1) {
#line 1688
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___4);
  } else {

  }
#line 1689
  n___5 = 6U;
#line 1689
  if ((1034753250 >> (int )n___5) & 1) {
#line 1689
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___5);
  } else {

  }
#line 1689
  if ((1034753250 >> (int )(n___5 + 16U)) & 1) {
#line 1689
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___5);
  } else {

  }
#line 1690
  n___6 = 7U;
#line 1690
  if ((1034753250 >> (int )n___6) & 1) {
#line 1690
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___6);
  } else {

  }
#line 1690
  if ((1034753250 >> (int )(n___6 + 16U)) & 1) {
#line 1690
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___6);
  } else {

  }
#line 1691
  n___7 = 8U;
#line 1691
  if ((1034753250 >> (int )n___7) & 1) {
#line 1691
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___7);
  } else {

  }
#line 1691
  if ((1034753250 >> (int )(n___7 + 16U)) & 1) {
#line 1691
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___7);
  } else {

  }
#line 1692
  n___8 = 9U;
#line 1692
  if ((1034753250 >> (int )n___8) & 1) {
#line 1692
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___8);
  } else {

  }
#line 1692
  if ((1034753250 >> (int )(n___8 + 16U)) & 1) {
#line 1692
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___8);
  } else {

  }
#line 1693
  n___9 = 10U;
#line 1693
  if ((1034753250 >> (int )n___9) & 1) {
#line 1693
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___9);
  } else {

  }
#line 1693
  if ((1034753250 >> (int )(n___9 + 16U)) & 1) {
#line 1693
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___9);
  } else {

  }
#line 1694
  n___10 = 11U;
#line 1694
  if ((1034753250 >> (int )n___10) & 1) {
#line 1694
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___10);
  } else {

  }
#line 1694
  if ((1034753250 >> (int )(n___10 + 16U)) & 1) {
#line 1694
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___10);
  } else {

  }
#line 1695
  n___11 = 12U;
#line 1695
  if ((1034753250 >> (int )n___11) & 1) {
#line 1695
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___11);
  } else {

  }
#line 1695
  if ((1034753250 >> (int )(n___11 + 16U)) & 1) {
#line 1695
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___11);
  } else {

  }
#line 1696
  n___12 = 13U;
#line 1696
  if ((1034753250 >> (int )n___12) & 1) {
#line 1696
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___12);
  } else {

  }
#line 1696
  if ((1034753250 >> (int )(n___12 + 16U)) & 1) {
#line 1696
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___12);
  } else {

  }
#line 1697
  n___13 = 14U;
#line 1697
  if ((1034753250 >> (int )n___13) & 1) {
#line 1697
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___13);
  } else {

  }
#line 1697
  if ((1034753250 >> (int )(n___13 + 16U)) & 1) {
#line 1697
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___13);
  } else {

  }
#line 1698
  n___14 = 15U;
#line 1698
  if ((1034753250 >> (int )n___14) & 1) {
#line 1698
    bucket_hash = bucket_hash ^ (lo_hash_dword >> (int )n___14);
  } else {

  }
#line 1698
  if ((1034753250 >> (int )(n___14 + 16U)) & 1) {
#line 1698
    bucket_hash = bucket_hash ^ (hi_hash_dword >> (int )n___14);
  } else {

  }
#line 1704
  input->formatted.bkt_hash = (unsigned int )((__be16 )bucket_hash) & 8191U;
#line 1705
  return;
}
}
#line 1716 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask ) 
{ 
  u32 mask ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  {
#line 1718
  tmp = __fswab16((int )input_mask->formatted.dst_port);
#line 1718
  mask = (u32 )tmp;
#line 1719
  mask = mask << 16;
#line 1720
  tmp___0 = __fswab16((int )input_mask->formatted.src_port);
#line 1720
  mask = mask | (u32 )tmp___0;
#line 1721
  mask = ((mask & 1431655765U) << 1) | ((mask & 2863311530U) >> 1);
#line 1722
  mask = ((mask & 858993459U) << 2) | ((mask & 3435973836U) >> 2);
#line 1723
  mask = ((mask & 252645135U) << 4) | ((mask & 4042322160U) >> 4);
  }
#line 1724
  return (((mask & 16711935U) << 8) | ((mask & 4278255360U) >> 8));
}
}
#line 1744 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input_mask ) 
{ 
  u32 fdirm ;
  u32 fdirtcpm ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  __u16 tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___4 ;
  long tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;

  {
#line 1748
  fdirm = 32U;
#line 1762
  if ((unsigned int )input_mask->formatted.bkt_hash != 0U) {
    {
#line 1763
    descriptor.modname = "ixgbe";
#line 1763
    descriptor.function = "ixgbe_fdir_set_input_mask_82599";
#line 1763
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1763
    descriptor.format = " bucket hash should always be 0 in mask\n";
#line 1763
    descriptor.lineno = 1763U;
#line 1763
    descriptor.flags = 0U;
#line 1763
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1763
    if (tmp != 0L) {
      {
#line 1763
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           " bucket hash should always be 0 in mask\n");
      }
    } else {

    }
  } else {

  }
  {
#line 1767
  if (((int )input_mask->formatted.vm_pool & 127) == 0) {
#line 1767
    goto case_0;
  } else {

  }
#line 1769
  if (((int )input_mask->formatted.vm_pool & 127) == 127) {
#line 1769
    goto case_127;
  } else {

  }
#line 1771
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1768
  fdirm = fdirm | 4U;
  case_127: /* CIL Label */ ;
#line 1770
  goto ldv_51229;
  switch_default: /* CIL Label */ 
  {
#line 1772
  descriptor___0.modname = "ixgbe";
#line 1772
  descriptor___0.function = "ixgbe_fdir_set_input_mask_82599";
#line 1772
  descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1772
  descriptor___0.format = " Error on vm pool mask\n";
#line 1772
  descriptor___0.lineno = 1772U;
#line 1772
  descriptor___0.flags = 0U;
#line 1772
  tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
  }
#line 1772
  if (tmp___0 != 0L) {
    {
#line 1772
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on vm pool mask\n");
    }
  } else {

  }
#line 1773
  return (-4);
  switch_break: /* CIL Label */ ;
  }
  ldv_51229: ;
  {
#line 1777
  if (((int )input_mask->formatted.flow_type & 3) == 0) {
#line 1777
    goto case_0___0;
  } else {

  }
#line 1784
  if (((int )input_mask->formatted.flow_type & 3) == 3) {
#line 1784
    goto case_3;
  } else {

  }
#line 1786
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 1778
  fdirm = fdirm | 8U;
#line 1779
  if (*((unsigned int *)input_mask + 9UL) != 0U) {
    {
#line 1781
    descriptor___1.modname = "ixgbe";
#line 1781
    descriptor___1.function = "ixgbe_fdir_set_input_mask_82599";
#line 1781
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1781
    descriptor___1.format = " Error on src/dst port mask\n";
#line 1781
    descriptor___1.lineno = 1781U;
#line 1781
    descriptor___1.flags = 0U;
#line 1781
    tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 1781
    if (tmp___1 != 0L) {
      {
#line 1781
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           " Error on src/dst port mask\n");
      }
    } else {

    }
#line 1782
    return (-4);
  } else {

  }
  case_3: /* CIL Label */ ;
#line 1785
  goto ldv_51235;
  switch_default___0: /* CIL Label */ 
  {
#line 1787
  descriptor___2.modname = "ixgbe";
#line 1787
  descriptor___2.function = "ixgbe_fdir_set_input_mask_82599";
#line 1787
  descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1787
  descriptor___2.format = " Error on flow type mask\n";
#line 1787
  descriptor___2.lineno = 1787U;
#line 1787
  descriptor___2.flags = 0U;
#line 1787
  tmp___2 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
  }
#line 1787
  if (tmp___2 != 0L) {
    {
#line 1787
    __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on flow type mask\n");
    }
  } else {

  }
#line 1788
  return (-4);
  switch_break___0: /* CIL Label */ ;
  }
  ldv_51235: 
  {
#line 1791
  tmp___3 = __fswab16((int )input_mask->formatted.vlan_id);
  }
  {
#line 1792
  if (((int )tmp___3 & 61439) == 0) {
#line 1792
    goto case_0___1;
  } else {

  }
#line 1795
  if (((int )tmp___3 & 61439) == 4095) {
#line 1795
    goto case_4095;
  } else {

  }
#line 1799
  if (((int )tmp___3 & 61439) == 57344) {
#line 1799
    goto case_57344;
  } else {

  }
#line 1802
  if (((int )tmp___3 & 61439) == 61439) {
#line 1802
    goto case_61439;
  } else {

  }
#line 1805
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 1794
  fdirm = fdirm | 1U;
  case_4095: /* CIL Label */ 
#line 1797
  fdirm = fdirm | 2U;
#line 1798
  goto ldv_51240;
  case_57344: /* CIL Label */ 
#line 1801
  fdirm = fdirm | 1U;
  case_61439: /* CIL Label */ ;
#line 1804
  goto ldv_51240;
  switch_default___1: /* CIL Label */ 
  {
#line 1806
  descriptor___3.modname = "ixgbe";
#line 1806
  descriptor___3.function = "ixgbe_fdir_set_input_mask_82599";
#line 1806
  descriptor___3.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1806
  descriptor___3.format = " Error on VLAN mask\n";
#line 1806
  descriptor___3.lineno = 1806U;
#line 1806
  descriptor___3.flags = 0U;
#line 1806
  tmp___4 = __builtin_expect((long )descriptor___3.flags & 1L, 0L);
  }
#line 1806
  if (tmp___4 != 0L) {
    {
#line 1806
    __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on VLAN mask\n");
    }
  } else {

  }
#line 1807
  return (-4);
  switch_break___1: /* CIL Label */ ;
  }
  ldv_51240: ;
  {
#line 1811
  if ((int )input_mask->formatted.flex_bytes == 0) {
#line 1811
    goto case_0___2;
  } else {

  }
#line 1814
  if ((int )input_mask->formatted.flex_bytes == 65535) {
#line 1814
    goto case_65535;
  } else {

  }
#line 1816
  goto switch_default___2;
  case_0___2: /* CIL Label */ 
#line 1813
  fdirm = fdirm | 16U;
  case_65535: /* CIL Label */ ;
#line 1815
  goto ldv_51247;
  switch_default___2: /* CIL Label */ 
  {
#line 1817
  descriptor___4.modname = "ixgbe";
#line 1817
  descriptor___4.function = "ixgbe_fdir_set_input_mask_82599";
#line 1817
  descriptor___4.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 1817
  descriptor___4.format = " Error on flexible byte mask\n";
#line 1817
  descriptor___4.lineno = 1817U;
#line 1817
  descriptor___4.flags = 0U;
#line 1817
  tmp___5 = __builtin_expect((long )descriptor___4.flags & 1L, 0L);
  }
#line 1817
  if (tmp___5 != 0L) {
    {
#line 1817
    __dynamic_netdev_dbg(& descriptor___4, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         " Error on flexible byte mask\n");
    }
  } else {

  }
#line 1818
  return (-4);
  switch_break___2: /* CIL Label */ ;
  }
  ldv_51247: 
  {
#line 1822
  ixgbe_write_reg(hw, 61040U, fdirm);
#line 1825
  fdirtcpm = ixgbe_get_fdirtcpm_82599(input_mask);
#line 1828
  ixgbe_write_reg(hw, 60996U, ~ fdirtcpm);
#line 1829
  ixgbe_write_reg(hw, 61000U, ~ fdirtcpm);
#line 1832
  tmp___6 = __fswab32(~ input_mask->formatted.src_ip[0]);
#line 1832
  tmp___7 = __fswab32(~ input_mask->formatted.src_ip[0]);
#line 1832
  tmp___8 = __fswab32(~ input_mask->formatted.src_ip[0]);
#line 1832
  tmp___9 = __fswab32(~ input_mask->formatted.src_ip[0]);
#line 1832
  ixgbe_write_reg(hw, 60992U, (((tmp___6 >> 24) | ((tmp___7 & 16711680U) >> 8)) | ((tmp___8 & 65280U) << 8)) | (tmp___9 << 24));
#line 1834
  tmp___10 = __fswab32(~ input_mask->formatted.dst_ip[0]);
#line 1834
  tmp___11 = __fswab32(~ input_mask->formatted.dst_ip[0]);
#line 1834
  tmp___12 = __fswab32(~ input_mask->formatted.dst_ip[0]);
#line 1834
  tmp___13 = __fswab32(~ input_mask->formatted.dst_ip[0]);
#line 1834
  ixgbe_write_reg(hw, 60988U, (((tmp___10 >> 24) | ((tmp___11 & 16711680U) >> 8)) | ((tmp___12 & 65280U) << 8)) | (tmp___13 << 24));
  }
#line 1837
  return (0);
}
}
#line 1840 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input ,
                                          u16 soft_id , u8 queue ) 
{ 
  u32 fdirport ;
  u32 fdirvlan ;
  u32 fdirhash ;
  u32 fdircmd ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;
  __u32 tmp___15 ;
  __u32 tmp___16 ;
  __u32 tmp___17 ;
  __u32 tmp___18 ;
  __u16 tmp___19 ;
  __u16 tmp___20 ;
  __u16 tmp___21 ;
  __u16 tmp___22 ;

  {
  {
#line 1847
  tmp = __fswab32(input->formatted.src_ip[0]);
#line 1847
  tmp___0 = __fswab32(input->formatted.src_ip[0]);
#line 1847
  tmp___1 = __fswab32(input->formatted.src_ip[0]);
#line 1847
  tmp___2 = __fswab32(input->formatted.src_ip[0]);
#line 1847
  ixgbe_write_reg(hw, 60940U, (((tmp >> 24) | ((tmp___0 & 16711680U) >> 8)) | ((tmp___1 & 65280U) << 8)) | (tmp___2 << 24));
#line 1849
  tmp___3 = __fswab32(input->formatted.src_ip[1]);
#line 1849
  tmp___4 = __fswab32(input->formatted.src_ip[1]);
#line 1849
  tmp___5 = __fswab32(input->formatted.src_ip[1]);
#line 1849
  tmp___6 = __fswab32(input->formatted.src_ip[1]);
#line 1849
  ixgbe_write_reg(hw, 60944U, (((tmp___3 >> 24) | ((tmp___4 & 16711680U) >> 8)) | ((tmp___5 & 65280U) << 8)) | (tmp___6 << 24));
#line 1851
  tmp___7 = __fswab32(input->formatted.src_ip[2]);
#line 1851
  tmp___8 = __fswab32(input->formatted.src_ip[2]);
#line 1851
  tmp___9 = __fswab32(input->formatted.src_ip[2]);
#line 1851
  tmp___10 = __fswab32(input->formatted.src_ip[2]);
#line 1851
  ixgbe_write_reg(hw, 60948U, (((tmp___7 >> 24) | ((tmp___8 & 16711680U) >> 8)) | ((tmp___9 & 65280U) << 8)) | (tmp___10 << 24));
#line 1855
  tmp___11 = __fswab32(input->formatted.src_ip[0]);
#line 1855
  tmp___12 = __fswab32(input->formatted.src_ip[0]);
#line 1855
  tmp___13 = __fswab32(input->formatted.src_ip[0]);
#line 1855
  tmp___14 = __fswab32(input->formatted.src_ip[0]);
#line 1855
  ixgbe_write_reg(hw, 60952U, (((tmp___11 >> 24) | ((tmp___12 & 16711680U) >> 8)) | ((tmp___13 & 65280U) << 8)) | (tmp___14 << 24));
#line 1858
  tmp___15 = __fswab32(input->formatted.dst_ip[0]);
#line 1858
  tmp___16 = __fswab32(input->formatted.dst_ip[0]);
#line 1858
  tmp___17 = __fswab32(input->formatted.dst_ip[0]);
#line 1858
  tmp___18 = __fswab32(input->formatted.dst_ip[0]);
#line 1858
  ixgbe_write_reg(hw, 60956U, (((tmp___15 >> 24) | ((tmp___16 & 16711680U) >> 8)) | ((tmp___17 & 65280U) << 8)) | (tmp___18 << 24));
#line 1861
  tmp___19 = __fswab16((int )input->formatted.dst_port);
#line 1861
  fdirport = (u32 )tmp___19;
#line 1862
  fdirport = fdirport << 16;
#line 1863
  tmp___20 = __fswab16((int )input->formatted.src_port);
#line 1863
  fdirport = fdirport | (u32 )tmp___20;
#line 1864
  ixgbe_write_reg(hw, 60960U, fdirport);
#line 1867
  tmp___21 = __fswab16((int )((unsigned short )((int )((short )((int )input->formatted.flex_bytes >> 8)) | (int )((short )((int )input->formatted.flex_bytes << 8)))));
#line 1867
  fdirvlan = (u32 )tmp___21;
#line 1868
  fdirvlan = fdirvlan << 16;
#line 1869
  tmp___22 = __fswab16((int )input->formatted.vlan_id);
#line 1869
  fdirvlan = fdirvlan | (u32 )tmp___22;
#line 1870
  ixgbe_write_reg(hw, 60964U, fdirvlan);
#line 1873
  fdirhash = (u32 )input->formatted.bkt_hash;
#line 1874
  fdirhash = fdirhash | (u32 )((int )soft_id << 16);
#line 1875
  ixgbe_write_reg(hw, 60968U, fdirhash);
#line 1881
  ixgbe_read_reg(hw, 8U);
#line 1884
  fdircmd = 34825U;
  }
#line 1886
  if ((unsigned int )queue == 127U) {
#line 1887
    fdircmd = fdircmd | 512U;
  } else {

  }
  {
#line 1888
  fdircmd = fdircmd | (u32 )((int )input->formatted.flow_type << 5);
#line 1889
  fdircmd = fdircmd | ((unsigned int )queue << 16);
#line 1890
  fdircmd = fdircmd | ((unsigned int )input->formatted.vm_pool << 24);
#line 1892
  ixgbe_write_reg(hw, 60972U, fdircmd);
  }
#line 1894
  return (0);
}
}
#line 1897 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw , union ixgbe_atr_input *input ,
                                          u16 soft_id ) 
{ 
  u32 fdirhash ;
  u32 fdircmd ;
  u32 retry_count ;
  s32 err ;

  {
  {
#line 1902
  fdircmd = 0U;
#line 1904
  err = 0;
#line 1907
  fdirhash = (u32 )input->formatted.bkt_hash;
#line 1908
  fdirhash = fdirhash | (u32 )((int )soft_id << 16);
#line 1909
  ixgbe_write_reg(hw, 60968U, fdirhash);
#line 1912
  ixgbe_read_reg(hw, 8U);
#line 1915
  ixgbe_write_reg(hw, 60972U, 3U);
#line 1917
  retry_count = 10U;
  }
#line 1917
  goto ldv_51271;
  ldv_51270: 
  {
#line 1919
  __const_udelay(42950UL);
#line 1921
  fdircmd = ixgbe_read_reg(hw, 60972U);
  }
#line 1922
  if ((fdircmd & 3U) == 0U) {
#line 1923
    goto ldv_51269;
  } else {

  }
#line 1917
  retry_count = retry_count - 1U;
  ldv_51271: ;
#line 1917
  if (retry_count != 0U) {
#line 1919
    goto ldv_51270;
  } else {

  }
  ldv_51269: ;
#line 1926
  if (retry_count == 0U) {
#line 1927
    err = -23;
  } else {

  }
#line 1930
  if ((fdircmd & 4U) != 0U) {
    {
#line 1931
    ixgbe_write_reg(hw, 60968U, fdirhash);
#line 1932
    ixgbe_read_reg(hw, 8U);
#line 1933
    ixgbe_write_reg(hw, 60972U, 2U);
    }
  } else {

  }
#line 1937
  return (err);
}
}
#line 1948 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw , u32 reg , u8 *val ) 
{ 
  u32 core_ctl ;

  {
  {
#line 1952
  ixgbe_write_reg(hw, 85760U, (reg << 8) | 65536U);
#line 1954
  ixgbe_read_reg(hw, 8U);
#line 1955
  __const_udelay(42950UL);
#line 1956
  core_ctl = ixgbe_read_reg(hw, 85760U);
#line 1957
  *val = (unsigned char )core_ctl;
  }
#line 1959
  return (0);
}
}
#line 1970 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw , u32 reg , u8 val ) 
{ 
  u32 core_ctl ;

  {
  {
#line 1974
  core_ctl = (reg << 8) | (u32 )val;
#line 1975
  ixgbe_write_reg(hw, 85760U, core_ctl);
#line 1976
  ixgbe_read_reg(hw, 8U);
#line 1977
  __const_udelay(42950UL);
  }
#line 1979
  return (0);
}
}
#line 1990 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;

  {
  {
#line 1992
  ret_val = 0;
#line 1994
  ret_val = ixgbe_start_hw_generic(hw);
  }
#line 1995
  if (ret_val != 0) {
#line 1996
    goto out;
  } else {

  }
  {
#line 1998
  ret_val = ixgbe_start_hw_gen2(hw);
  }
#line 1999
  if (ret_val != 0) {
#line 2000
    goto out;
  } else {

  }
#line 2003
  hw->mac.autotry_restart = 1;
#line 2004
  hw->mac.rx_pb_size = 512U;
#line 2006
  if (ret_val == 0) {
    {
#line 2007
    ret_val = ixgbe_verify_fw_version_82599(hw);
    }
  } else {

  }
  out: ;
#line 2009
  return (ret_val);
}
}
#line 2020 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  enum ixgbe_media_type tmp ;

  {
  {
#line 2022
  status = -17;
#line 2025
  status = ixgbe_identify_phy_generic(hw);
  }
#line 2026
  if (status != 0) {
    {
#line 2028
    tmp = (*(hw->mac.ops.get_media_type))(hw);
    }
#line 2028
    if ((unsigned int )tmp == 5U) {
#line 2029
      goto out;
    } else {
      {
#line 2031
      status = ixgbe_identify_module_generic(hw);
      }
    }
  } else {

  }
#line 2035
  if ((unsigned int )hw->phy.type == 0U) {
#line 2036
    hw->phy.type = 1;
#line 2037
    status = 0;
  } else {

  }
#line 2041
  if ((unsigned int )hw->phy.type == 20U) {
#line 2042
    status = -19;
  } else {

  }
  out: ;
#line 2045
  return (status);
}
}
#line 2054 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static u32 ixgbe_get_supported_physical_layer_82599(struct ixgbe_hw *hw ) 
{ 
  u32 physical_layer ;
  u32 autoc ;
  u32 tmp ;
  u32 autoc2 ;
  u32 tmp___0 ;
  u32 pma_pmd_10g_serial ;
  u32 pma_pmd_10g_parallel ;
  u32 pma_pmd_1g ;
  u16 ext_ability ;
  u8 comp_codes_10g ;
  u8 comp_codes_1g ;

  {
  {
#line 2056
  physical_layer = 0U;
#line 2057
  tmp = ixgbe_read_reg(hw, 17056U);
#line 2057
  autoc = tmp;
#line 2058
  tmp___0 = ixgbe_read_reg(hw, 17064U);
#line 2058
  autoc2 = tmp___0;
#line 2059
  pma_pmd_10g_serial = autoc2 & 196608U;
#line 2060
  pma_pmd_10g_parallel = autoc & 384U;
#line 2061
  pma_pmd_1g = autoc & 512U;
#line 2062
  ext_ability = 0U;
#line 2063
  comp_codes_10g = 0U;
#line 2064
  comp_codes_1g = 0U;
#line 2066
  (*(hw->phy.ops.identify))(hw);
  }
  {
#line 2069
  if ((unsigned int )hw->phy.type == 2U) {
#line 2069
    goto case_2;
  } else {

  }
#line 2070
  if ((unsigned int )hw->phy.type == 4U) {
#line 2070
    goto case_4;
  } else {

  }
#line 2080
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_4: /* CIL Label */ 
  {
#line 2071
  (*(hw->phy.ops.read_reg))(hw, 11U, 1U, & ext_ability);
  }
#line 2073
  if (((int )ext_ability & 4) != 0) {
#line 2074
    physical_layer = physical_layer | 1U;
  } else {

  }
#line 2075
  if (((int )ext_ability & 32) != 0) {
#line 2076
    physical_layer = physical_layer | 2U;
  } else {

  }
#line 2077
  if (((int )ext_ability & 128) != 0) {
#line 2078
    physical_layer = physical_layer | 4U;
  } else {

  }
#line 2079
  goto out;
  switch_default: /* CIL Label */ ;
#line 2081
  goto ldv_51310;
  switch_break: /* CIL Label */ ;
  }
  ldv_51310: ;
  {
#line 2085
  if ((autoc & 57344U) == 16384U) {
#line 2085
    goto case_16384;
  } else {

  }
#line 2086
  if ((autoc & 57344U) == 0U) {
#line 2086
    goto case_0;
  } else {

  }
#line 2095
  if ((autoc & 57344U) == 8192U) {
#line 2095
    goto case_8192;
  } else {

  }
#line 2104
  if ((autoc & 57344U) == 24576U) {
#line 2104
    goto case_24576;
  } else {

  }
#line 2111
  if ((autoc & 57344U) == 32768U) {
#line 2111
    goto case_32768;
  } else {

  }
#line 2112
  if ((autoc & 57344U) == 49152U) {
#line 2112
    goto case_49152;
  } else {

  }
#line 2121
  goto switch_default___0;
  case_16384: /* CIL Label */ ;
  case_0: /* CIL Label */ ;
#line 2087
  if (pma_pmd_1g == 512U) {
#line 2088
    physical_layer = 1536U;
#line 2090
    goto out;
  } else {
#line 2093
    goto sfp_check;
  }
  case_8192: /* CIL Label */ ;
#line 2096
  if (pma_pmd_10g_parallel == 256U) {
#line 2097
    physical_layer = 256U;
  } else
#line 2098
  if (pma_pmd_10g_parallel == 128U) {
#line 2099
    physical_layer = 128U;
  } else
#line 2100
  if (pma_pmd_10g_parallel == 0U) {
#line 2101
    physical_layer = 4096U;
  } else {

  }
#line 2102
  goto out;
  case_24576: /* CIL Label */ ;
#line 2105
  if (pma_pmd_10g_serial == 0U) {
#line 2106
    physical_layer = 2048U;
#line 2107
    goto out;
  } else
#line 2108
  if (pma_pmd_10g_serial == 131072U) {
#line 2109
    goto sfp_check;
  } else {

  }
#line 2110
  goto ldv_51316;
  case_32768: /* CIL Label */ ;
  case_49152: /* CIL Label */ ;
#line 2113
  if ((autoc & 1073741824U) != 0U) {
#line 2114
    physical_layer = physical_layer | 512U;
  } else {

  }
#line 2115
  if ((int )autoc < 0) {
#line 2116
    physical_layer = physical_layer | 128U;
  } else {

  }
#line 2117
  if ((autoc & 65536U) != 0U) {
#line 2118
    physical_layer = physical_layer | 2048U;
  } else {

  }
#line 2119
  goto out;
  switch_default___0: /* CIL Label */ ;
#line 2122
  goto out;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_51316: ;
  sfp_check: 
  {
#line 2130
  (*(hw->phy.ops.identify_sfp))(hw);
  }
#line 2131
  if ((unsigned int )hw->phy.sfp_type == 65534U) {
#line 2132
    goto out;
  } else {

  }
  {
#line 2135
  if ((unsigned int )hw->phy.type == 8U) {
#line 2135
    goto case_8;
  } else {

  }
#line 2136
  if ((unsigned int )hw->phy.type == 9U) {
#line 2136
    goto case_9;
  } else {

  }
#line 2137
  if ((unsigned int )hw->phy.type == 16U) {
#line 2137
    goto case_16;
  } else {

  }
#line 2140
  if ((unsigned int )hw->phy.type == 13U) {
#line 2140
    goto case_13;
  } else {

  }
#line 2141
  if ((unsigned int )hw->phy.type == 10U) {
#line 2141
    goto case_10;
  } else {

  }
#line 2142
  if ((unsigned int )hw->phy.type == 17U) {
#line 2142
    goto case_17;
  } else {

  }
#line 2145
  if ((unsigned int )hw->phy.type == 11U) {
#line 2145
    goto case_11;
  } else {

  }
#line 2146
  if ((unsigned int )hw->phy.type == 12U) {
#line 2146
    goto case_12;
  } else {

  }
#line 2147
  if ((unsigned int )hw->phy.type == 15U) {
#line 2147
    goto case_15;
  } else {

  }
#line 2148
  if ((unsigned int )hw->phy.type == 14U) {
#line 2148
    goto case_14;
  } else {

  }
#line 2160
  if ((unsigned int )hw->phy.type == 18U) {
#line 2160
    goto case_18;
  } else {

  }
#line 2161
  if ((unsigned int )hw->phy.type == 19U) {
#line 2161
    goto case_19;
  } else {

  }
#line 2169
  goto switch_default___1;
  case_8: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_16: /* CIL Label */ 
#line 2138
  physical_layer = 8U;
#line 2139
  goto ldv_51323;
  case_13: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_17: /* CIL Label */ 
#line 2143
  physical_layer = 8192U;
#line 2144
  goto ldv_51323;
  case_11: /* CIL Label */ ;
  case_12: /* CIL Label */ ;
  case_15: /* CIL Label */ ;
  case_14: /* CIL Label */ 
  {
#line 2149
  (*(hw->phy.ops.read_i2c_eeprom))(hw, 6, & comp_codes_1g);
#line 2151
  (*(hw->phy.ops.read_i2c_eeprom))(hw, 3, & comp_codes_10g);
  }
#line 2153
  if (((int )comp_codes_10g & 16) != 0) {
#line 2154
    physical_layer = 64U;
  } else
#line 2155
  if (((int )comp_codes_10g & 32) != 0) {
#line 2156
    physical_layer = 16U;
  } else
#line 2157
  if (((int )comp_codes_1g & 8) != 0) {
#line 2158
    physical_layer = 2U;
  } else {

  }
#line 2159
  goto ldv_51323;
  case_18: /* CIL Label */ ;
  case_19: /* CIL Label */ 
  {
#line 2162
  (*(hw->phy.ops.read_i2c_eeprom))(hw, 131, & comp_codes_10g);
  }
#line 2164
  if (((int )comp_codes_10g & 16) != 0) {
#line 2165
    physical_layer = 64U;
  } else
#line 2166
  if (((int )comp_codes_10g & 32) != 0) {
#line 2167
    physical_layer = 16U;
  } else {

  }
#line 2168
  goto ldv_51323;
  switch_default___1: /* CIL Label */ ;
#line 2170
  goto ldv_51323;
  switch_break___1: /* CIL Label */ ;
  }
  ldv_51323: ;
  out: ;
#line 2174
  return (physical_layer);
}
}
#line 2184 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw , u32 regval ) 
{ 


  {
  {
#line 2192
  (*(hw->mac.ops.disable_rx_buff))(hw);
#line 2194
  ixgbe_write_reg(hw, 12288U, regval);
#line 2196
  (*(hw->mac.ops.enable_rx_buff))(hw);
  }
#line 2198
  return (0);
}
}
#line 2211 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 fw_offset ;
  u16 fw_ptp_cfg_offset ;
  u16 offset ;
  u16 fw_version ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 2213
  status = -24;
#line 2216
  fw_version = 0U;
#line 2219
  if ((unsigned int )hw->phy.media_type != 1U) {
#line 2220
    status = 0;
#line 2221
    goto fw_version_out;
  } else {

  }
  {
#line 2225
  offset = 15U;
#line 2226
  tmp = (*(hw->eeprom.ops.read))(hw, (int )offset, & fw_offset);
  }
#line 2226
  if (tmp != 0) {
#line 2227
    goto fw_version_err;
  } else {

  }
#line 2229
  if ((unsigned int )fw_offset - 1U > 65533U) {
#line 2230
    goto fw_version_out;
  } else {

  }
  {
#line 2233
  offset = (unsigned int )fw_offset + 4U;
#line 2234
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )offset, & fw_ptp_cfg_offset);
  }
#line 2234
  if (tmp___0 != 0) {
#line 2235
    goto fw_version_err;
  } else {

  }
#line 2237
  if ((unsigned int )fw_ptp_cfg_offset - 1U > 65533U) {
#line 2238
    goto fw_version_out;
  } else {

  }
  {
#line 2241
  offset = (unsigned int )fw_ptp_cfg_offset + 7U;
#line 2242
  tmp___1 = (*(hw->eeprom.ops.read))(hw, (int )offset, & fw_version);
  }
#line 2242
  if (tmp___1 != 0) {
#line 2243
    goto fw_version_err;
  } else {

  }
#line 2245
  if ((unsigned int )fw_version > 5U) {
#line 2246
    status = 0;
  } else {

  }
  fw_version_out: ;
#line 2249
  return (status);
  fw_version_err: 
  {
#line 2252
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )offset);
  }
#line 2253
  return (-24);
}
}
#line 2263 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw ) 
{ 
  bool lesm_enabled ;
  u16 fw_offset ;
  u16 fw_lesm_param_offset ;
  u16 fw_lesm_state ;
  s32 status ;

  {
  {
#line 2265
  lesm_enabled = 0;
#line 2270
  status = (*(hw->eeprom.ops.read))(hw, 15, & fw_offset);
  }
#line 2272
  if ((status != 0 || (unsigned int )fw_offset == 0U) || (unsigned int )fw_offset == 65535U) {
#line 2274
    goto out;
  } else {

  }
  {
#line 2277
  status = (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )fw_offset + 2U), & fw_lesm_param_offset);
  }
#line 2281
  if ((status != 0 || (unsigned int )fw_lesm_param_offset == 0U) || (unsigned int )fw_lesm_param_offset == 65535U) {
#line 2283
    goto out;
  } else {

  }
  {
#line 2286
  status = (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )fw_lesm_param_offset + 1U),
                                    & fw_lesm_state);
  }
#line 2290
  if (status == 0 && (int )((short )fw_lesm_state) < 0) {
#line 2292
    lesm_enabled = 1;
  } else {

  }
  out: ;
#line 2295
  return (lesm_enabled);
}
}
#line 2309 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                          u16 *data ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  s32 ret_val ;

  {
#line 2312
  eeprom = & hw->eeprom;
#line 2313
  ret_val = -4;
#line 2319
  if ((unsigned int )eeprom->type == 1U && (int )offset + ((int )words + -1) <= 16383) {
    {
#line 2321
    ret_val = ixgbe_read_eerd_buffer_generic(hw, (int )offset, (int )words, data);
    }
  } else {
    {
#line 2324
    ret_val = ixgbe_read_eeprom_buffer_bit_bang_generic(hw, (int )offset, (int )words,
                                                        data);
    }
  }
#line 2328
  return (ret_val);
}
}
#line 2341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  s32 ret_val ;

  {
#line 2344
  eeprom = & hw->eeprom;
#line 2345
  ret_val = -4;
#line 2351
  if ((unsigned int )eeprom->type == 1U && (unsigned int )offset <= 16383U) {
    {
#line 2353
    ret_val = ixgbe_read_eerd_generic(hw, (int )offset, data);
    }
  } else {
    {
#line 2355
    ret_val = ixgbe_read_eeprom_bit_bang_generic(hw, (int )offset, data);
    }
  }
#line 2357
  return (ret_val);
}
}
#line 2369 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u32 anlp1_reg ;
  u32 i ;
  u32 autoc_reg ;
  u32 autoc2_reg ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  {
#line 2372
  anlp1_reg = 0U;
#line 2376
  autoc2_reg = ixgbe_read_reg(hw, 17064U);
  }
#line 2377
  if ((autoc2_reg & 1879048192U) != 0U) {
    {
#line 2378
    autoc2_reg = autoc2_reg & 2415919103U;
#line 2379
    ixgbe_write_reg(hw, 17064U, autoc2_reg);
#line 2380
    ixgbe_read_reg(hw, 8U);
    }
  } else {

  }
  {
#line 2383
  autoc_reg = hw->mac.cached_autoc;
#line 2384
  autoc_reg = autoc_reg | 4096U;
#line 2387
  ixgbe_write_reg(hw, 17056U, autoc_reg ^ 16384U);
#line 2390
  i = 0U;
  }
#line 2390
  goto ldv_51382;
  ldv_51381: 
  {
#line 2391
  usleep_range(4000UL, 8000UL);
#line 2392
  anlp1_reg = ixgbe_read_reg(hw, 17072U);
  }
#line 2393
  if ((anlp1_reg & 983040U) != 0U) {
#line 2394
    goto ldv_51380;
  } else {

  }
#line 2390
  i = i + 1U;
  ldv_51382: ;
#line 2390
  if (i <= 9U) {
#line 2392
    goto ldv_51381;
  } else {

  }
  ldv_51380: ;
#line 2397
  if ((anlp1_reg & 983040U) == 0U) {
    {
#line 2398
    descriptor.modname = "ixgbe";
#line 2398
    descriptor.function = "ixgbe_reset_pipeline_82599";
#line 2398
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 2398
    descriptor.format = "auto negotiation not completed\n";
#line 2398
    descriptor.lineno = 2398U;
#line 2398
    descriptor.flags = 0U;
#line 2398
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 2398
    if (tmp != 0L) {
      {
#line 2398
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "auto negotiation not completed\n");
      }
    } else {

    }
#line 2399
    ret_val = -15;
#line 2400
    goto reset_pipeline_out;
  } else {

  }
#line 2403
  ret_val = 0;
  reset_pipeline_out: 
  {
#line 2407
  ixgbe_write_reg(hw, 17056U, autoc_reg);
#line 2408
  ixgbe_read_reg(hw, 8U);
  }
#line 2410
  return (ret_val);
}
}
#line 2422 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                     u8 *data ) 
{ 
  u32 esdp ;
  s32 status ;
  s32 timeout ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2427
  timeout = 200;
#line 2429
  if ((int )hw->phy.qsfp_shared_i2c_bus) {
    {
#line 2431
    esdp = ixgbe_read_reg(hw, 32U);
#line 2432
    esdp = esdp | 1U;
#line 2433
    ixgbe_write_reg(hw, 32U, esdp);
#line 2434
    ixgbe_read_reg(hw, 8U);
    }
#line 2436
    goto ldv_51397;
    ldv_51396: 
    {
#line 2437
    esdp = ixgbe_read_reg(hw, 32U);
    }
#line 2438
    if ((esdp & 2U) != 0U) {
#line 2439
      goto ldv_51395;
    } else {

    }
    {
#line 2441
    usleep_range(5000UL, 10000UL);
#line 2442
    timeout = timeout - 1;
    }
    ldv_51397: ;
#line 2436
    if (timeout != 0) {
#line 2438
      goto ldv_51396;
    } else {

    }
    ldv_51395: ;
#line 2445
    if (timeout == 0) {
      {
#line 2446
      descriptor.modname = "ixgbe";
#line 2446
      descriptor.function = "ixgbe_read_i2c_byte_82599";
#line 2446
      descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 2446
      descriptor.format = "Driver can\'t access resource, acquiring I2C bus timeout.\n";
#line 2446
      descriptor.lineno = 2446U;
#line 2446
      descriptor.flags = 0U;
#line 2446
      tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
      }
#line 2446
      if (tmp != 0L) {
        {
#line 2446
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Driver can\'t access resource, acquiring I2C bus timeout.\n");
        }
      } else {

      }
#line 2447
      status = -18;
#line 2448
      goto release_i2c_access;
    } else {

    }
  } else {

  }
  {
#line 2452
  status = ixgbe_read_i2c_byte_generic(hw, (int )byte_offset, (int )dev_addr, data);
  }
  release_i2c_access: ;
#line 2455
  if ((int )hw->phy.qsfp_shared_i2c_bus) {
    {
#line 2457
    esdp = ixgbe_read_reg(hw, 32U);
#line 2458
    esdp = esdp & 4294967294U;
#line 2459
    ixgbe_write_reg(hw, 32U, esdp);
#line 2460
    ixgbe_read_reg(hw, 8U);
    }
  } else {

  }
#line 2463
  return (status);
}
}
#line 2475 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                      u8 data ) 
{ 
  u32 esdp ;
  s32 status ;
  s32 timeout ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 2480
  timeout = 200;
#line 2482
  if ((int )hw->phy.qsfp_shared_i2c_bus) {
    {
#line 2484
    esdp = ixgbe_read_reg(hw, 32U);
#line 2485
    esdp = esdp | 1U;
#line 2486
    ixgbe_write_reg(hw, 32U, esdp);
#line 2487
    ixgbe_read_reg(hw, 8U);
    }
#line 2489
    goto ldv_51412;
    ldv_51411: 
    {
#line 2490
    esdp = ixgbe_read_reg(hw, 32U);
    }
#line 2491
    if ((esdp & 2U) != 0U) {
#line 2492
      goto ldv_51410;
    } else {

    }
    {
#line 2494
    usleep_range(5000UL, 10000UL);
#line 2495
    timeout = timeout - 1;
    }
    ldv_51412: ;
#line 2489
    if (timeout != 0) {
#line 2491
      goto ldv_51411;
    } else {

    }
    ldv_51410: ;
#line 2498
    if (timeout == 0) {
      {
#line 2499
      descriptor.modname = "ixgbe";
#line 2499
      descriptor.function = "ixgbe_write_i2c_byte_82599";
#line 2499
      descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c";
#line 2499
      descriptor.format = "Driver can\'t access resource, acquiring I2C bus timeout.\n";
#line 2499
      descriptor.lineno = 2499U;
#line 2499
      descriptor.flags = 0U;
#line 2499
      tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
      }
#line 2499
      if (tmp != 0L) {
        {
#line 2499
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Driver can\'t access resource, acquiring I2C bus timeout.\n");
        }
      } else {

      }
#line 2500
      status = -18;
#line 2501
      goto release_i2c_access;
    } else {

    }
  } else {

  }
  {
#line 2505
  status = ixgbe_write_i2c_byte_generic(hw, (int )byte_offset, (int )dev_addr, (int )data);
  }
  release_i2c_access: ;
#line 2508
  if ((int )hw->phy.qsfp_shared_i2c_bus) {
    {
#line 2510
    esdp = ixgbe_read_reg(hw, 32U);
#line 2511
    esdp = esdp & 4294967294U;
#line 2512
    ixgbe_write_reg(hw, 32U, esdp);
#line 2513
    ixgbe_read_reg(hw, 8U);
    }
  } else {

  }
#line 2516
  return (status);
}
}
#line 2519 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_mac_operations mac_ops_82599  = 
#line 2519
     {& ixgbe_init_hw_generic, & ixgbe_reset_hw_82599, & ixgbe_start_hw_82599, & ixgbe_clear_hw_cntrs_generic,
    & ixgbe_get_media_type_82599, & ixgbe_get_supported_physical_layer_82599, & ixgbe_get_mac_addr_generic,
    & ixgbe_get_san_mac_addr_generic, & ixgbe_get_device_caps_generic, & ixgbe_get_wwn_prefix_generic,
    & ixgbe_stop_adapter_generic, & ixgbe_get_bus_info_generic, & ixgbe_set_lan_id_multi_port_pcie,
    & ixgbe_read_analog_reg8_82599, & ixgbe_write_analog_reg8_82599, & ixgbe_setup_sfp_modules_82599,
    & ixgbe_disable_rx_buff_generic, & ixgbe_enable_rx_buff_generic, & ixgbe_enable_rx_dma_82599,
    & ixgbe_acquire_swfw_sync, & ixgbe_release_swfw_sync, 0, 0, 0, & ixgbe_stop_mac_link_on_d3_82599,
    & ixgbe_setup_mac_link_82599, & ixgbe_check_mac_link_generic, & ixgbe_get_link_capabilities_82599,
    & ixgbe_set_rxpba_generic, & ixgbe_led_on_generic, & ixgbe_led_off_generic, & ixgbe_blink_led_start_generic,
    & ixgbe_blink_led_stop_generic, & ixgbe_set_rar_generic, & ixgbe_clear_rar_generic,
    & ixgbe_set_vmdq_generic, & ixgbe_set_vmdq_san_mac_generic, & ixgbe_clear_vmdq_generic,
    & ixgbe_init_rx_addrs_generic, & ixgbe_update_mc_addr_list_generic, & ixgbe_enable_mc_generic,
    & ixgbe_disable_mc_generic, & ixgbe_clear_vfta_generic, & ixgbe_set_vfta_generic,
    & ixgbe_init_uta_tables_generic, & ixgbe_set_mac_anti_spoofing, & ixgbe_set_vlan_anti_spoofing,
    & ixgbe_fc_enable_generic, & ixgbe_set_fw_drv_ver_generic, & ixgbe_get_thermal_sensor_data_generic,
    & ixgbe_init_thermal_sensor_thresh_generic, & ixgbe_mng_enabled};
#line 2571 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_eeprom_operations eeprom_ops_82599  = 
#line 2571
     {& ixgbe_init_eeprom_params_generic, & ixgbe_read_eeprom_82599, & ixgbe_read_eeprom_buffer_82599,
    & ixgbe_write_eeprom_generic, & ixgbe_write_eeprom_buffer_bit_bang_generic, & ixgbe_validate_eeprom_checksum_generic,
    & ixgbe_update_eeprom_checksum_generic, & ixgbe_calc_eeprom_checksum_generic};
#line 2582 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
static struct ixgbe_phy_operations phy_ops_82599  = 
#line 2582
     {& ixgbe_identify_phy_82599, & ixgbe_identify_module_generic, & ixgbe_init_phy_ops_82599,
    & ixgbe_reset_phy_generic, & ixgbe_read_phy_reg_generic, & ixgbe_write_phy_reg_generic,
    0, 0, & ixgbe_setup_phy_link_generic, & ixgbe_setup_phy_link_speed_generic, 0,
    0, & ixgbe_read_i2c_byte_generic, & ixgbe_write_i2c_byte_generic, & ixgbe_read_i2c_sff8472_generic,
    & ixgbe_read_i2c_eeprom_generic, & ixgbe_write_i2c_eeprom_generic, & ixgbe_tn_check_overtemp};
#line 2599 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c"
struct ixgbe_info ixgbe_82599_info  =    {2, & ixgbe_get_invariants_82599, & mac_ops_82599, & eeprom_ops_82599, & phy_ops_82599,
    & mbx_ops_generic};
#line 183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 184
  ixgbe_reset_phy_generic(arg1);
  }
#line 185
  return;
}
}
#line 188 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_12(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 189
  ixgbe_blink_led_stop_generic(arg1, arg2);
  }
#line 190
  return;
}
}
#line 193 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 194
  ixgbe_setup_sfp_modules_82599(arg1);
  }
#line 195
  return;
}
}
#line 198 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 199
  ixgbe_stop_mac_link_on_d3_82599(arg1);
  }
#line 200
  return;
}
}
#line 203 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 204
  ixgbe_update_eeprom_checksum_generic(arg1);
  }
#line 205
  return;
}
}
#line 208 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 209
  ixgbe_calc_eeprom_checksum_generic(arg1);
  }
#line 210
  return;
}
}
#line 213 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_150(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 214
  ixgbe_validate_eeprom_checksum_generic(arg1, arg2);
  }
#line 215
  return;
}
}
#line 218 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_156(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char arg3 ) 
{ 


  {
  {
#line 219
  ixgbe_write_analog_reg8_82599(arg1, arg2, (int )arg3);
  }
#line 220
  return;
}
}
#line 223 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_3(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 224
  ixgbe_acquire_swfw_sync(arg1, (int )arg2);
  }
#line 225
  return;
}
}
#line 228 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_53(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    _Bool *arg3 ) 
{ 


  {
  {
#line 229
  ixgbe_get_link_capabilities_82599(arg1, arg2, arg3);
  }
#line 230
  return;
}
}
#line 233 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 234
  ixgbe_get_thermal_sensor_data_generic(arg1);
  }
#line 235
  return;
}
}
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 239
  ixgbe_init_phy_ops_82599(arg1);
  }
#line 240
  return;
}
}
#line 243 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 244
  ixgbe_init_eeprom_params_generic(arg1);
  }
#line 245
  return;
}
}
#line 248 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 249
  ixgbe_init_thermal_sensor_thresh_generic(arg1);
  }
#line 250
  return;
}
}
#line 253 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 254
  ixgbe_mng_enabled(arg1);
  }
#line 255
  return;
}
}
#line 258 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_86(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 259
  ixgbe_read_analog_reg8_82599(arg1, arg2, arg3);
  }
#line 260
  return;
}
}
#line 263 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_10_9(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 264
  ixgbe_blink_led_start_generic(arg1, arg2);
  }
#line 265
  return;
}
}
#line 268 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 269
  ixgbe_reset_phy_generic(arg1);
  }
#line 270
  return;
}
}
#line 273 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_12(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 274
  ixgbe_blink_led_stop_generic(arg1, arg2);
  }
#line 275
  return;
}
}
#line 278 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 279
  ixgbe_setup_sfp_modules_82599(arg1);
  }
#line 280
  return;
}
}
#line 283 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 284
  ixgbe_stop_mac_link_on_d3_82599(arg1);
  }
#line 285
  return;
}
}
#line 288 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 289
  ixgbe_update_eeprom_checksum_generic(arg1);
  }
#line 290
  return;
}
}
#line 293 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_150(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 294
  ixgbe_validate_eeprom_checksum_generic(arg1, arg2);
  }
#line 295
  return;
}
}
#line 298 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_156(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char arg3 ) 
{ 


  {
  {
#line 299
  ixgbe_write_analog_reg8_82599(arg1, arg2, (int )arg3);
  }
#line 300
  return;
}
}
#line 303 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_3(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 304
  ixgbe_acquire_swfw_sync(arg1, (int )arg2);
  }
#line 305
  return;
}
}
#line 308 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_41(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 309
  ixgbe_enable_rx_dma_82599(arg1, arg2);
  }
#line 310
  return;
}
}
#line 313 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 314
  ixgbe_get_invariants_82599(arg1);
  }
#line 315
  return;
}
}
#line 318 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 319
  ixgbe_get_thermal_sensor_data_generic(arg1);
  }
#line 320
  return;
}
}
#line 323 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 324
  ixgbe_init_phy_ops_82599(arg1);
  }
#line 325
  return;
}
}
#line 328 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 329
  ixgbe_init_eeprom_params_generic(arg1);
  }
#line 330
  return;
}
}
#line 333 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 334
  ixgbe_init_thermal_sensor_thresh_generic(arg1);
  }
#line 335
  return;
}
}
#line 338 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 339
  ixgbe_mng_enabled(arg1);
  }
#line 340
  return;
}
}
#line 343 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_86(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 344
  ixgbe_read_analog_reg8_82599(arg1, arg2, arg3);
  }
#line 345
  return;
}
}
#line 348 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_11_9(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 349
  ixgbe_blink_led_start_generic(arg1, arg2);
  }
#line 350
  return;
}
}
#line 353 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 354
  ixgbe_reset_phy_generic(arg1);
  }
#line 355
  return;
}
}
#line 358 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_12(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 359
  ixgbe_blink_led_stop_generic(arg1, arg2);
  }
#line 360
  return;
}
}
#line 363 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 364
  ixgbe_setup_sfp_modules_82599(arg1);
  }
#line 365
  return;
}
}
#line 368 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 369
  ixgbe_stop_mac_link_on_d3_82599(arg1);
  }
#line 370
  return;
}
}
#line 373 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 374
  ixgbe_update_eeprom_checksum_generic(arg1);
  }
#line 375
  return;
}
}
#line 378 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_150(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 379
  ixgbe_validate_eeprom_checksum_generic(arg1, arg2);
  }
#line 380
  return;
}
}
#line 383 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_156(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char arg3 ) 
{ 


  {
  {
#line 384
  ixgbe_write_analog_reg8_82599(arg1, arg2, (int )arg3);
  }
#line 385
  return;
}
}
#line 388 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_3(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 389
  ixgbe_acquire_swfw_sync(arg1, (int )arg2);
  }
#line 390
  return;
}
}
#line 393 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_41(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 394
  ixgbe_enable_rx_dma_82599(arg1, arg2);
  }
#line 395
  return;
}
}
#line 398 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_53(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    _Bool *arg3 ) 
{ 


  {
  {
#line 399
  ixgbe_get_link_capabilities_82599(arg1, arg2, arg3);
  }
#line 400
  return;
}
}
#line 403 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 404
  ixgbe_get_thermal_sensor_data_generic(arg1);
  }
#line 405
  return;
}
}
#line 408 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 409
  ixgbe_init_phy_ops_82599(arg1);
  }
#line 410
  return;
}
}
#line 413 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 414
  ixgbe_init_eeprom_params_generic(arg1);
  }
#line 415
  return;
}
}
#line 418 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 419
  ixgbe_init_thermal_sensor_thresh_generic(arg1);
  }
#line 420
  return;
}
}
#line 423 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 424
  ixgbe_mng_enabled(arg1);
  }
#line 425
  return;
}
}
#line 428 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_86(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 429
  ixgbe_read_analog_reg8_82599(arg1, arg2, arg3);
  }
#line 430
  return;
}
}
#line 433 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_12_9(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 434
  ixgbe_blink_led_start_generic(arg1, arg2);
  }
#line 435
  return;
}
}
#line 438 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 439
  ixgbe_reset_phy_generic(arg1);
  }
#line 440
  return;
}
}
#line 443 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_12(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 444
  ixgbe_blink_led_stop_generic(arg1, arg2);
  }
#line 445
  return;
}
}
#line 448 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 449
  ixgbe_setup_sfp_modules_82599(arg1);
  }
#line 450
  return;
}
}
#line 453 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 454
  ixgbe_stop_mac_link_on_d3_82599(arg1);
  }
#line 455
  return;
}
}
#line 458 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 459
  ixgbe_update_eeprom_checksum_generic(arg1);
  }
#line 460
  return;
}
}
#line 463 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_150(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 464
  ixgbe_validate_eeprom_checksum_generic(arg1, arg2);
  }
#line 465
  return;
}
}
#line 468 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_156(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char arg3 ) 
{ 


  {
  {
#line 469
  ixgbe_write_analog_reg8_82599(arg1, arg2, (int )arg3);
  }
#line 470
  return;
}
}
#line 473 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_3(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 474
  ixgbe_acquire_swfw_sync(arg1, (int )arg2);
  }
#line 475
  return;
}
}
#line 478 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_41(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 479
  ixgbe_enable_rx_dma_82599(arg1, arg2);
  }
#line 480
  return;
}
}
#line 483 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 484
  ixgbe_get_thermal_sensor_data_generic(arg1);
  }
#line 485
  return;
}
}
#line 488 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 489
  ixgbe_init_phy_ops_82599(arg1);
  }
#line 490
  return;
}
}
#line 493 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 494
  ixgbe_init_eeprom_params_generic(arg1);
  }
#line 495
  return;
}
}
#line 498 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 499
  ixgbe_init_thermal_sensor_thresh_generic(arg1);
  }
#line 500
  return;
}
}
#line 503 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 504
  ixgbe_mng_enabled(arg1);
  }
#line 505
  return;
}
}
#line 508 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_86(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 509
  ixgbe_read_analog_reg8_82599(arg1, arg2, arg3);
  }
#line 510
  return;
}
}
#line 513 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_13_9(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 514
  ixgbe_blink_led_start_generic(arg1, arg2);
  }
#line 515
  return;
}
}
#line 518 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_110(void (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 519
  ixgbe_release_swfw_sync(arg1, (int )arg2);
  }
#line 520
  return;
}
}
#line 523 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 524
  ixgbe_reset_phy_generic(arg1);
  }
#line 525
  return;
}
}
#line 528 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_12(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 529
  ixgbe_blink_led_stop_generic(arg1, arg2);
  }
#line 530
  return;
}
}
#line 533 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 534
  ixgbe_setup_sfp_modules_82599(arg1);
  }
#line 535
  return;
}
}
#line 538 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 539
  ixgbe_stop_mac_link_on_d3_82599(arg1);
  }
#line 540
  return;
}
}
#line 543 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_3(int (*arg0)(struct ixgbe_hw * ,
                                                              unsigned short  ) ,
                                                  struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 544
  ixgbe_acquire_swfw_sync(arg1, (int )arg2);
  }
#line 545
  return;
}
}
#line 548 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_41(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 549
  ixgbe_enable_rx_dma_82599(arg1, arg2);
  }
#line 550
  return;
}
}
#line 553 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 554
  ixgbe_get_thermal_sensor_data_generic(arg1);
  }
#line 555
  return;
}
}
#line 558 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 559
  ixgbe_init_thermal_sensor_thresh_generic(arg1);
  }
#line 560
  return;
}
}
#line 563 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 564
  ixgbe_mng_enabled(arg1);
  }
#line 565
  return;
}
}
#line 568 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_8_9(int (*arg0)(struct ixgbe_hw * ,
                                                              unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                  unsigned int arg2 ) 
{ 


  {
  {
#line 569
  ixgbe_blink_led_start_generic(arg1, arg2);
  }
#line 570
  return;
}
}
#line 573 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_113(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 574
  ixgbe_reset_phy_generic(arg1);
  }
#line 575
  return;
}
}
#line 578 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 579
  ixgbe_reset_hw_82599(arg1);
  }
#line 580
  return;
}
}
#line 583 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_141(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , _Bool  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    _Bool arg3 ) 
{ 


  {
  {
#line 584
  ixgbe_setup_mac_link_82599(arg1, arg2, (int )arg3);
  }
#line 585
  return;
}
}
#line 588 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_144(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 589
  ixgbe_setup_sfp_modules_82599(arg1);
  }
#line 590
  return;
}
}
#line 593 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 594
  ixgbe_start_hw_82599(arg1);
  }
#line 595
  return;
}
}
#line 598 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_147(void (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 599
  ixgbe_stop_mac_link_on_d3_82599(arg1);
  }
#line 600
  return;
}
}
#line 603 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 604
  ixgbe_update_eeprom_checksum_generic(arg1);
  }
#line 605
  return;
}
}
#line 608 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 609
  ixgbe_calc_eeprom_checksum_generic(arg1);
  }
#line 610
  return;
}
}
#line 613 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_150(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 614
  ixgbe_validate_eeprom_checksum_generic(arg1, arg2);
  }
#line 615
  return;
}
}
#line 618 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_156(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 619
  ixgbe_write_analog_reg8_82599(arg1, arg2, (int )arg3);
  }
#line 620
  return;
}
}
#line 623 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_159(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 624
  ixgbe_write_eeprom_buffer_bit_bang_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 625
  return;
}
}
#line 628 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_53(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , _Bool * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                   _Bool *arg3 ) 
{ 


  {
  {
#line 629
  ixgbe_get_link_capabilities_82599(arg1, arg2, arg3);
  }
#line 630
  return;
}
}
#line 633 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 634
  ixgbe_get_media_type_82599(arg1);
  }
#line 635
  return;
}
}
#line 638 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 639
  ixgbe_get_supported_physical_layer_82599(arg1);
  }
#line 640
  return;
}
}
#line 643 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_64(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 644
  ixgbe_get_thermal_sensor_data_generic(arg1);
  }
#line 645
  return;
}
}
#line 648 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 649
  ixgbe_init_phy_ops_82599(arg1);
  }
#line 650
  return;
}
}
#line 653 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 654
  ixgbe_init_eeprom_params_generic(arg1);
  }
#line 655
  return;
}
}
#line 658 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_74(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 659
  ixgbe_init_thermal_sensor_thresh_generic(arg1);
  }
#line 660
  return;
}
}
#line 663 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_82(_Bool (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 664
  ixgbe_mng_enabled(arg1);
  }
#line 665
  return;
}
}
#line 668 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_86(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 669
  ixgbe_read_analog_reg8_82599(arg1, arg2, arg3);
  }
#line 670
  return;
}
}
#line 673 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82599.c.aux"
void ldv_dummy_resourceless_instance_callback_9_89(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  , unsigned short  ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 674
  ixgbe_read_eeprom_buffer_82599(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 675
  return;
}
}
#line 828 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 851 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
  {
#line 853
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
  }
#line 853
  return (tmp);
}
}
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                           u16 *phy_data ) ;
#line 125
s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                            u16 phy_data ) ;
#line 145
s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw ) ;
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait_to_complete ) ;
#line 45
static s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw , u8 byte_offset , u8 *eeprom_data ) ;
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  u32 gcr ;
  u32 tmp ;
  u16 pcie_devctl2 ;

  {
  {
#line 60
  adapter = (struct ixgbe_adapter *)hw->back;
#line 61
  tmp = ixgbe_read_reg(hw, 69632U);
#line 61
  gcr = tmp;
  }
#line 65
  if ((gcr & 61440U) != 0U) {
#line 66
    goto out;
  } else {

  }
#line 72
  if ((gcr & 262144U) == 0U) {
#line 73
    gcr = gcr | 4096U;
#line 74
    goto out;
  } else {

  }
  {
#line 82
  pci_read_config_word((struct pci_dev  const  *)adapter->pdev, 200, & pcie_devctl2);
#line 84
  pcie_devctl2 = (u16 )((unsigned int )pcie_devctl2 | 5U);
#line 85
  pci_write_config_word((struct pci_dev  const  *)adapter->pdev, 200, (int )pcie_devctl2);
  }
  out: 
  {
#line 89
  gcr = gcr & 4294901759U;
#line 90
  ixgbe_write_reg(hw, 69632U, gcr);
  }
#line 91
  return;
}
}
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_get_invariants_82598(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;

  {
  {
#line 95
  mac = & hw->mac;
#line 98
  ixgbe_identify_phy_generic(hw);
#line 100
  mac->mcft_size = 128U;
#line 101
  mac->vft_size = 128U;
#line 102
  mac->num_rar_entries = 16U;
#line 103
  mac->max_rx_queues = 64U;
#line 104
  mac->max_tx_queues = 32U;
#line 105
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
  }
#line 107
  return (0);
}
}
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;
  struct ixgbe_phy_info *phy ;
  s32 ret_val ;
  u16 list_offset ;
  u16 data_offset ;
  enum ixgbe_media_type tmp ;

  {
  {
#line 121
  mac = & hw->mac;
#line 122
  phy = & hw->phy;
#line 123
  ret_val = 0;
#line 127
  (*(phy->ops.identify))(hw);
#line 130
  tmp = (*(mac->ops.get_media_type))(hw);
  }
#line 130
  if ((unsigned int )tmp == 5U) {
#line 131
    mac->ops.setup_link = & ixgbe_setup_copper_link_82598;
#line 132
    mac->ops.get_link_capabilities = & ixgbe_get_copper_link_capabilities_generic;
  } else {

  }
  {
#line 137
  if ((unsigned int )hw->phy.type == 2U) {
#line 137
    goto case_2;
  } else {

  }
#line 143
  if ((unsigned int )hw->phy.type == 7U) {
#line 143
    goto case_7;
  } else {

  }
#line 164
  goto switch_default;
  case_2: /* CIL Label */ 
#line 138
  phy->ops.setup_link = & ixgbe_setup_phy_link_tnx;
#line 139
  phy->ops.check_link = & ixgbe_check_phy_link_tnx;
#line 140
  phy->ops.get_firmware_version = & ixgbe_get_phy_firmware_version_tnx;
#line 142
  goto ldv_50863;
  case_7: /* CIL Label */ 
  {
#line 144
  phy->ops.reset = & ixgbe_reset_phy_nl;
#line 147
  ret_val = (*(phy->ops.identify_sfp))(hw);
  }
#line 148
  if (ret_val != 0) {
#line 149
    goto out;
  } else
#line 150
  if ((unsigned int )hw->phy.sfp_type == 65535U) {
#line 151
    ret_val = -19;
#line 152
    goto out;
  } else {

  }
  {
#line 156
  ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, & list_offset, & data_offset);
  }
#line 159
  if (ret_val != 0) {
#line 160
    ret_val = -19;
#line 161
    goto out;
  } else {

  }
#line 163
  goto ldv_50863;
  switch_default: /* CIL Label */ ;
#line 165
  goto ldv_50863;
  switch_break: /* CIL Label */ ;
  }
  ldv_50863: ;
  out: ;
#line 169
  return (ret_val);
}
}
#line 180 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw ) 
{ 
  u32 regval ;
  u32 i ;
  s32 ret_val ;

  {
  {
#line 184
  ret_val = 0;
#line 186
  ret_val = ixgbe_start_hw_generic(hw);
#line 189
  i = 0U;
  }
#line 189
  goto ldv_50874;
  ldv_50873: 
  {
#line 191
  regval = ixgbe_read_reg(hw, (i + 7296U) * 4U);
#line 192
  regval = regval & 4294965247U;
#line 193
  ixgbe_write_reg(hw, (i + 7296U) * 4U, regval);
#line 190
  i = i + 1U;
  }
  ldv_50874: ;
#line 189
  if (i < hw->mac.max_tx_queues && i <= 15U) {
#line 192
    goto ldv_50873;
  } else {

  }
#line 196
  i = 0U;
#line 196
  goto ldv_50877;
  ldv_50876: 
  {
#line 198
  regval = ixgbe_read_reg(hw, i <= 15U ? (i + 2176U) * 4U : (i <= 63U ? i * 64U + 4108U : (i + 67108800U) * 64U + 53260U));
#line 199
  regval = regval & 4294926335U;
#line 201
  ixgbe_write_reg(hw, i <= 15U ? (i + 2176U) * 4U : (i <= 63U ? i * 64U + 4108U : (i + 67108800U) * 64U + 53260U),
                  regval);
#line 197
  i = i + 1U;
  }
  ldv_50877: ;
#line 196
  if (i < hw->mac.max_rx_queues && i <= 15U) {
#line 199
    goto ldv_50876;
  } else {

  }
#line 204
  hw->mac.rx_pb_size = 512U;
#line 207
  if (ret_val == 0) {
    {
#line 208
    ixgbe_set_pcie_completion_timeout(hw);
    }
  } else {

  }
#line 210
  return (ret_val);
}
}
#line 221 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                             bool *autoneg ) 
{ 
  s32 status ;
  u32 autoc ;

  {
#line 225
  status = 0;
#line 226
  autoc = 0U;
#line 233
  if ((int )hw->mac.orig_link_settings_stored) {
#line 234
    autoc = hw->mac.orig_autoc;
  } else {
    {
#line 236
    autoc = ixgbe_read_reg(hw, 17056U);
    }
  }
  {
#line 239
  if ((autoc & 57344U) == 0U) {
#line 239
    goto case_0;
  } else {

  }
#line 244
  if ((autoc & 57344U) == 8192U) {
#line 244
    goto case_8192;
  } else {

  }
#line 249
  if ((autoc & 57344U) == 16384U) {
#line 249
    goto case_16384;
  } else {

  }
#line 254
  if ((autoc & 57344U) == 32768U) {
#line 254
    goto case_32768;
  } else {

  }
#line 255
  if ((autoc & 57344U) == 49152U) {
#line 255
    goto case_49152;
  } else {

  }
#line 264
  goto switch_default;
  case_0: /* CIL Label */ 
#line 240
  *speed = 32U;
#line 241
  *autoneg = 0;
#line 242
  goto ldv_50887;
  case_8192: /* CIL Label */ 
#line 245
  *speed = 128U;
#line 246
  *autoneg = 0;
#line 247
  goto ldv_50887;
  case_16384: /* CIL Label */ 
#line 250
  *speed = 32U;
#line 251
  *autoneg = 1;
#line 252
  goto ldv_50887;
  case_32768: /* CIL Label */ ;
  case_49152: /* CIL Label */ 
#line 256
  *speed = 0U;
#line 257
  if ((int )autoc < 0) {
#line 258
    *speed = *speed | 128U;
  } else {

  }
#line 259
  if ((autoc & 1073741824U) != 0U) {
#line 260
    *speed = *speed | 32U;
  } else {

  }
#line 261
  *autoneg = 1;
#line 262
  goto ldv_50887;
  switch_default: /* CIL Label */ 
#line 265
  status = -8;
#line 266
  goto ldv_50887;
  switch_break: /* CIL Label */ ;
  }
  ldv_50887: ;
#line 269
  return (status);
}
}
#line 278 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw ) 
{ 
  enum ixgbe_media_type media_type ;

  {
  {
#line 284
  if ((unsigned int )hw->phy.type == 4U) {
#line 284
    goto case_4;
  } else {

  }
#line 285
  if ((unsigned int )hw->phy.type == 2U) {
#line 285
    goto case_2;
  } else {

  }
#line 288
  goto switch_default;
  case_4: /* CIL Label */ ;
  case_2: /* CIL Label */ 
#line 286
  media_type = 5;
#line 287
  goto out;
  switch_default: /* CIL Label */ ;
#line 289
  goto ldv_50901;
  switch_break: /* CIL Label */ ;
  }
  ldv_50901: ;
  {
#line 294
  if ((int )hw->device_id == 4278) {
#line 294
    goto case_4278;
  } else {

  }
#line 295
  if ((int )hw->device_id == 5384) {
#line 295
    goto case_5384;
  } else {

  }
#line 299
  if ((int )hw->device_id == 4294) {
#line 299
    goto case_4294;
  } else {

  }
#line 300
  if ((int )hw->device_id == 4295) {
#line 300
    goto case_4295;
  } else {

  }
#line 301
  if ((int )hw->device_id == 4337) {
#line 301
    goto case_4337;
  } else {

  }
#line 302
  if ((int )hw->device_id == 4321) {
#line 302
    goto case_4321;
  } else {

  }
#line 303
  if ((int )hw->device_id == 4340) {
#line 303
    goto case_4340;
  } else {

  }
#line 304
  if ((int )hw->device_id == 4315) {
#line 304
    goto case_4315;
  } else {

  }
#line 307
  if ((int )hw->device_id == 4317) {
#line 307
    goto case_4317;
  } else {

  }
#line 308
  if ((int )hw->device_id == 4332) {
#line 308
    goto case_4332;
  } else {

  }
#line 311
  if ((int )hw->device_id == 4296) {
#line 311
    goto case_4296;
  } else {

  }
#line 312
  if ((int )hw->device_id == 5387) {
#line 312
    goto case_5387;
  } else {

  }
#line 315
  goto switch_default___0;
  case_4278: /* CIL Label */ ;
  case_5384: /* CIL Label */ 
#line 297
  media_type = 6;
#line 298
  goto ldv_50904;
  case_4294: /* CIL Label */ ;
  case_4295: /* CIL Label */ ;
  case_4337: /* CIL Label */ ;
  case_4321: /* CIL Label */ ;
  case_4340: /* CIL Label */ ;
  case_4315: /* CIL Label */ 
#line 305
  media_type = 1;
#line 306
  goto ldv_50904;
  case_4317: /* CIL Label */ ;
  case_4332: /* CIL Label */ 
#line 309
  media_type = 7;
#line 310
  goto ldv_50904;
  case_4296: /* CIL Label */ ;
  case_5387: /* CIL Label */ 
#line 313
  media_type = 5;
#line 314
  goto ldv_50904;
  switch_default___0: /* CIL Label */ 
#line 316
  media_type = 0;
#line 317
  goto ldv_50904;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_50904: ;
  out: ;
#line 320
  return (media_type);
}
}
#line 329 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;
  u32 fctrl_reg ;
  u32 rmcs_reg ;
  u32 reg ;
  u32 fcrtl ;
  u32 fcrth ;
  u32 link_speed ;
  int i ;
  bool link_up ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
#line 331
  ret_val = 0;
#line 336
  link_speed = 0U;
#line 345
  if ((hw->fc.low_water == 0U || hw->fc.high_water[0] == 0U) || (unsigned int )hw->fc.pause_time == 0U) {
    {
#line 348
    descriptor.modname = "ixgbe";
#line 348
    descriptor.function = "ixgbe_fc_enable_82598";
#line 348
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 348
    descriptor.format = "Invalid water mark configuration\n";
#line 348
    descriptor.lineno = 348U;
#line 348
    descriptor.flags = 0U;
#line 348
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 348
    if (tmp != 0L) {
      {
#line 348
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Invalid water mark configuration\n");
      }
    } else {

    }
#line 349
    ret_val = -13;
#line 350
    goto out;
  } else {

  }
  {
#line 358
  (*(hw->mac.ops.check_link))(hw, & link_speed, & link_up, 0);
  }
#line 359
  if ((int )link_up && link_speed == 32U) {
    {
#line 361
    if ((unsigned int )hw->fc.requested_mode == 3U) {
#line 361
      goto case_3;
    } else {

    }
#line 364
    if ((unsigned int )hw->fc.requested_mode == 1U) {
#line 364
      goto case_1;
    } else {

    }
#line 367
    goto switch_default;
    case_3: /* CIL Label */ 
#line 362
    hw->fc.requested_mode = 2;
#line 363
    goto ldv_50932;
    case_1: /* CIL Label */ 
#line 365
    hw->fc.requested_mode = 0;
#line 366
    goto ldv_50932;
    switch_default: /* CIL Label */ ;
#line 369
    goto ldv_50932;
    switch_break: /* CIL Label */ ;
    }
    ldv_50932: ;
  } else {

  }
  {
#line 374
  ixgbe_fc_autoneg(hw);
#line 377
  fctrl_reg = ixgbe_read_reg(hw, 20608U);
#line 378
  fctrl_reg = fctrl_reg & 4294918143U;
#line 380
  rmcs_reg = ixgbe_read_reg(hw, 15616U);
#line 381
  rmcs_reg = rmcs_reg & 4294967271U;
  }
  {
#line 394
  if ((unsigned int )hw->fc.current_mode == 0U) {
#line 394
    goto case_0;
  } else {

  }
#line 400
  if ((unsigned int )hw->fc.current_mode == 1U) {
#line 400
    goto case_1___0;
  } else {

  }
#line 411
  if ((unsigned int )hw->fc.current_mode == 2U) {
#line 411
    goto case_2;
  } else {

  }
#line 418
  if ((unsigned int )hw->fc.current_mode == 3U) {
#line 418
    goto case_3___0;
  } else {

  }
#line 423
  goto switch_default___0;
  case_0: /* CIL Label */ ;
#line 399
  goto ldv_50936;
  case_1___0: /* CIL Label */ 
#line 409
  fctrl_reg = fctrl_reg | 32768U;
#line 410
  goto ldv_50936;
  case_2: /* CIL Label */ 
#line 416
  rmcs_reg = rmcs_reg | 8U;
#line 417
  goto ldv_50936;
  case_3___0: /* CIL Label */ 
#line 420
  fctrl_reg = fctrl_reg | 32768U;
#line 421
  rmcs_reg = rmcs_reg | 8U;
#line 422
  goto ldv_50936;
  switch_default___0: /* CIL Label */ 
  {
#line 424
  descriptor___0.modname = "ixgbe";
#line 424
  descriptor___0.function = "ixgbe_fc_enable_82598";
#line 424
  descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 424
  descriptor___0.format = "Flow control param set incorrectly\n";
#line 424
  descriptor___0.lineno = 424U;
#line 424
  descriptor___0.flags = 0U;
#line 424
  tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
  }
#line 424
  if (tmp___0 != 0L) {
    {
#line 424
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Flow control param set incorrectly\n");
    }
  } else {

  }
#line 425
  ret_val = -4;
#line 426
  goto out;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_50936: 
  {
#line 431
  fctrl_reg = fctrl_reg | 8192U;
#line 432
  ixgbe_write_reg(hw, 20608U, fctrl_reg);
#line 433
  ixgbe_write_reg(hw, 15616U, rmcs_reg);
#line 435
  fcrtl = (hw->fc.low_water << 10) | 2147483648U;
#line 438
  i = 0;
  }
#line 438
  goto ldv_50943;
  ldv_50942: ;
#line 439
  if (((unsigned int )hw->fc.current_mode & 2U) != 0U && hw->fc.high_water[i] != 0U) {
    {
#line 441
    fcrth = (hw->fc.high_water[i] << 10) | 2147483648U;
#line 442
    ixgbe_write_reg(hw, (u32 )((i + 1604) * 8), fcrtl);
#line 443
    ixgbe_write_reg(hw, (u32 )((i + 1612) * 8), fcrth);
    }
  } else {
    {
#line 445
    ixgbe_write_reg(hw, (u32 )((i + 1604) * 8), 0U);
#line 446
    ixgbe_write_reg(hw, (u32 )((i + 1612) * 8), 0U);
    }
  }
#line 438
  i = i + 1;
  ldv_50943: ;
#line 438
  if (i <= 7) {
#line 440
    goto ldv_50942;
  } else {

  }
#line 452
  reg = (u32 )((int )hw->fc.pause_time * 65537);
#line 453
  i = 0;
#line 453
  goto ldv_50946;
  ldv_50945: 
  {
#line 454
  ixgbe_write_reg(hw, (u32 )((i + 3200) * 4), reg);
#line 453
  i = i + 1;
  }
  ldv_50946: ;
#line 453
  if (i <= 3) {
#line 455
    goto ldv_50945;
  } else {

  }
  {
#line 457
  ixgbe_write_reg(hw, 12960U, (unsigned int )hw->fc.pause_time / 2U);
  }
  out: ;
#line 460
  return (ret_val);
}
}
#line 470 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw , bool autoneg_wait_to_complete ) 
{ 
  u32 autoc_reg ;
  u32 links_reg ;
  u32 i ;
  s32 status ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  {
#line 476
  status = 0;
#line 479
  autoc_reg = ixgbe_read_reg(hw, 17056U);
#line 480
  autoc_reg = autoc_reg | 4096U;
#line 481
  ixgbe_write_reg(hw, 17056U, autoc_reg);
  }
#line 484
  if ((int )autoneg_wait_to_complete) {
#line 485
    if ((autoc_reg & 57344U) == 32768U || (autoc_reg & 57344U) == 49152U) {
#line 489
      links_reg = 0U;
#line 490
      i = 0U;
#line 490
      goto ldv_50958;
      ldv_50957: 
      {
#line 491
      links_reg = ixgbe_read_reg(hw, 17060U);
      }
#line 492
      if ((int )links_reg < 0) {
#line 493
        goto ldv_50956;
      } else {

      }
      {
#line 494
      msleep(100U);
#line 490
      i = i + 1U;
      }
      ldv_50958: ;
#line 490
      if (i <= 44U) {
#line 492
        goto ldv_50957;
      } else {

      }
      ldv_50956: ;
#line 496
      if ((int )links_reg >= 0) {
        {
#line 497
        status = -14;
#line 498
        descriptor.modname = "ixgbe";
#line 498
        descriptor.function = "ixgbe_start_mac_link_82598";
#line 498
        descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 498
        descriptor.format = "Autonegotiation did not complete.\n";
#line 498
        descriptor.lineno = 498U;
#line 498
        descriptor.flags = 0U;
#line 498
        tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
        }
#line 498
        if (tmp != 0L) {
          {
#line 498
          __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                               "Autonegotiation did not complete.\n");
          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 504
  msleep(50U);
  }
#line 506
  return (status);
}
}
#line 516 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw ) 
{ 
  u32 timeout ;
  u16 an_reg ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 521
  if ((unsigned int )hw->device_id != 5387U) {
#line 522
    return (0);
  } else {

  }
#line 524
  timeout = 0U;
#line 524
  goto ldv_50968;
  ldv_50967: 
  {
#line 526
  (*(hw->phy.ops.read_reg))(hw, 1U, 7U, & an_reg);
  }
#line 528
  if (((unsigned int )an_reg & 36U) == 36U) {
#line 530
    goto ldv_50966;
  } else {

  }
  {
#line 532
  msleep(100U);
#line 525
  timeout = timeout + 1U;
  }
  ldv_50968: ;
#line 524
  if (timeout <= 49U) {
#line 527
    goto ldv_50967;
  } else {

  }
  ldv_50966: ;
#line 535
  if (timeout == 50U) {
    {
#line 536
    descriptor.modname = "ixgbe";
#line 536
    descriptor.function = "ixgbe_validate_link_ready";
#line 536
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 536
    descriptor.format = "Link was indicated but link is down\n";
#line 536
    descriptor.lineno = 536U;
#line 536
    descriptor.flags = 0U;
#line 536
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 536
    if (tmp != 0L) {
      {
#line 536
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Link was indicated but link is down\n");
      }
    } else {

    }
#line 537
    return (-8);
  } else {

  }
#line 540
  return (0);
}
}
#line 552 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                      bool *link_up , bool link_up_wait_to_complete ) 
{ 
  u32 links_reg ;
  u32 i ;
  u16 link_reg ;
  u16 adapt_comp_reg ;
  s32 tmp ;

  {
#line 566
  if ((unsigned int )hw->phy.type == 7U) {
    {
#line 567
    (*(hw->phy.ops.read_reg))(hw, 51103U, 1U, & link_reg);
#line 568
    (*(hw->phy.ops.read_reg))(hw, 51103U, 1U, & link_reg);
#line 569
    (*(hw->phy.ops.read_reg))(hw, 49164U, 1U, & adapt_comp_reg);
    }
#line 571
    if ((int )link_up_wait_to_complete) {
#line 572
      i = 0U;
#line 572
      goto ldv_50983;
      ldv_50982: ;
#line 573
      if ((int )link_reg & 1 && ((int )adapt_comp_reg & 1) == 0) {
#line 575
        *link_up = 1;
#line 576
        goto ldv_50981;
      } else {
#line 578
        *link_up = 0;
      }
      {
#line 580
      msleep(100U);
#line 581
      (*(hw->phy.ops.read_reg))(hw, 51103U, 1U, & link_reg);
#line 584
      (*(hw->phy.ops.read_reg))(hw, 49164U, 1U, & adapt_comp_reg);
#line 572
      i = i + 1U;
      }
      ldv_50983: ;
#line 572
      if (i <= 89U) {
#line 574
        goto ldv_50982;
      } else {

      }
      ldv_50981: ;
    } else
#line 589
    if ((int )link_reg & 1 && ((int )adapt_comp_reg & 1) == 0) {
#line 590
      *link_up = 1;
    } else {
#line 592
      *link_up = 0;
    }
#line 595
    if (! *link_up) {
#line 596
      goto out;
    } else {

    }
  } else {

  }
  {
#line 599
  links_reg = ixgbe_read_reg(hw, 17060U);
  }
#line 600
  if ((int )link_up_wait_to_complete) {
#line 601
    i = 0U;
#line 601
    goto ldv_50987;
    ldv_50986: ;
#line 602
    if ((links_reg & 1073741824U) != 0U) {
#line 603
      *link_up = 1;
#line 604
      goto ldv_50985;
    } else {
#line 606
      *link_up = 0;
    }
    {
#line 608
    msleep(100U);
#line 609
    links_reg = ixgbe_read_reg(hw, 17060U);
#line 601
    i = i + 1U;
    }
    ldv_50987: ;
#line 601
    if (i <= 89U) {
#line 603
      goto ldv_50986;
    } else {

    }
    ldv_50985: ;
  } else
#line 612
  if ((links_reg & 1073741824U) != 0U) {
#line 613
    *link_up = 1;
  } else {
#line 615
    *link_up = 0;
  }
#line 618
  if ((links_reg & 536870912U) != 0U) {
#line 619
    *speed = 128U;
  } else {
#line 621
    *speed = 32U;
  }
#line 623
  if ((unsigned int )hw->device_id == 5387U && (int )*link_up) {
    {
#line 623
    tmp = ixgbe_validate_link_ready(hw);
    }
#line 623
    if (tmp != 0) {
#line 625
      *link_up = 0;
    } else {

    }
  } else {

  }
  out: ;
#line 628
  return (0);
}
}
#line 639 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                      bool autoneg_wait_to_complete ) 
{ 
  bool autoneg ;
  s32 status ;
  ixgbe_link_speed link_capabilities ;
  u32 curr_autoc ;
  u32 tmp ;
  u32 autoc ;
  u32 link_mode ;

  {
  {
#line 643
  autoneg = 0;
#line 644
  status = 0;
#line 645
  link_capabilities = 0U;
#line 646
  tmp = ixgbe_read_reg(hw, 17056U);
#line 646
  curr_autoc = tmp;
#line 647
  autoc = curr_autoc;
#line 648
  link_mode = autoc & 57344U;
#line 651
  ixgbe_get_link_capabilities_82598(hw, & link_capabilities, & autoneg);
#line 652
  speed = speed & link_capabilities;
  }
#line 654
  if (speed == 0U) {
#line 655
    status = -8;
  } else
#line 658
  if (link_mode == 32768U || link_mode == 49152U) {
#line 660
    autoc = autoc & 1073741823U;
#line 661
    if ((speed & 128U) != 0U) {
#line 662
      autoc = autoc | 2147483648U;
    } else {

    }
#line 663
    if ((speed & 32U) != 0U) {
#line 664
      autoc = autoc | 1073741824U;
    } else {

    }
#line 665
    if (autoc != curr_autoc) {
      {
#line 666
      ixgbe_write_reg(hw, 17056U, autoc);
      }
    } else {

    }
  } else {

  }
#line 669
  if (status == 0) {
    {
#line 675
    status = ixgbe_start_mac_link_82598(hw, (int )autoneg_wait_to_complete);
    }
  } else {

  }
#line 679
  return (status);
}
}
#line 691 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                         bool autoneg_wait_to_complete ) 
{ 
  s32 status ;

  {
  {
#line 698
  status = (*(hw->phy.ops.setup_link_speed))(hw, speed, (int )autoneg_wait_to_complete);
#line 701
  ixgbe_start_mac_link_82598(hw, (int )autoneg_wait_to_complete);
  }
#line 703
  return (status);
}
}
#line 714 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  s32 phy_status ;
  u32 ctrl ;
  u32 gheccr ;
  u32 i ;
  u32 autoc ;
  u8 analog_val ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 716
  status = 0;
#line 717
  phy_status = 0;
#line 725
  status = (*(hw->mac.ops.stop_adapter))(hw);
  }
#line 726
  if (status != 0) {
#line 727
    goto reset_hw_out;
  } else {

  }
  {
#line 734
  (*(hw->mac.ops.read_analog_reg8))(hw, 36U, & analog_val);
  }
#line 735
  if (((int )analog_val & 16) != 0) {
    {
#line 737
    (*(hw->mac.ops.read_analog_reg8))(hw, 36U, & analog_val);
#line 739
    analog_val = (unsigned int )analog_val & 239U;
#line 740
    (*(hw->mac.ops.write_analog_reg8))(hw, 36U, (int )analog_val);
#line 743
    (*(hw->mac.ops.read_analog_reg8))(hw, 11U, & analog_val);
#line 745
    analog_val = (unsigned int )analog_val & 15U;
#line 746
    (*(hw->mac.ops.write_analog_reg8))(hw, 11U, (int )analog_val);
#line 749
    (*(hw->mac.ops.read_analog_reg8))(hw, 12U, & analog_val);
#line 751
    analog_val = (unsigned int )analog_val & 15U;
#line 752
    (*(hw->mac.ops.write_analog_reg8))(hw, 12U, (int )analog_val);
#line 755
    (*(hw->mac.ops.read_analog_reg8))(hw, 13U, & analog_val);
#line 757
    analog_val = (unsigned int )analog_val & 15U;
#line 758
    (*(hw->mac.ops.write_analog_reg8))(hw, 13U, (int )analog_val);
    }
  } else {

  }
#line 763
  if (! hw->phy.reset_disable) {
    {
#line 767
    phy_status = (*(hw->phy.ops.init))(hw);
    }
#line 768
    if (phy_status == -19) {
#line 769
      goto reset_hw_out;
    } else {

    }
#line 770
    if (phy_status == -20) {
#line 771
      goto mac_reset_top;
    } else {

    }
    {
#line 773
    (*(hw->phy.ops.reset))(hw);
    }
  } else {

  }
  mac_reset_top: 
  {
#line 781
  tmp = ixgbe_read_reg(hw, 0U);
#line 781
  ctrl = tmp | 67108864U;
#line 782
  ixgbe_write_reg(hw, 0U, ctrl);
#line 783
  ixgbe_read_reg(hw, 8U);
#line 786
  i = 0U;
  }
#line 786
  goto ldv_51019;
  ldv_51018: 
  {
#line 787
  __const_udelay(4295UL);
#line 788
  ctrl = ixgbe_read_reg(hw, 0U);
  }
#line 789
  if ((ctrl & 67108864U) == 0U) {
#line 790
    goto ldv_51017;
  } else {

  }
#line 786
  i = i + 1U;
  ldv_51019: ;
#line 786
  if (i <= 9U) {
#line 788
    goto ldv_51018;
  } else {

  }
  ldv_51017: ;
#line 792
  if ((ctrl & 67108864U) != 0U) {
    {
#line 793
    status = -15;
#line 794
    descriptor.modname = "ixgbe";
#line 794
    descriptor.function = "ixgbe_reset_hw_82598";
#line 794
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 794
    descriptor.format = "Reset polling failed to complete.\n";
#line 794
    descriptor.lineno = 794U;
#line 794
    descriptor.flags = 0U;
#line 794
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 794
    if (tmp___0 != 0L) {
      {
#line 794
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Reset polling failed to complete.\n");
      }
    } else {

    }
  } else {

  }
  {
#line 797
  msleep(50U);
  }
#line 804
  if ((int )hw->mac.flags & 1) {
#line 805
    hw->mac.flags = (unsigned int )hw->mac.flags & 254U;
#line 806
    goto mac_reset_top;
  } else {

  }
  {
#line 809
  gheccr = ixgbe_read_reg(hw, 69808U);
#line 810
  gheccr = gheccr & 4292607423U;
#line 811
  ixgbe_write_reg(hw, 69808U, gheccr);
#line 818
  autoc = ixgbe_read_reg(hw, 17056U);
  }
#line 819
  if (! hw->mac.orig_link_settings_stored) {
#line 820
    hw->mac.orig_autoc = autoc;
#line 821
    hw->mac.orig_link_settings_stored = 1;
  } else
#line 822
  if (autoc != hw->mac.orig_autoc) {
    {
#line 823
    ixgbe_write_reg(hw, 17056U, hw->mac.orig_autoc);
    }
  } else {

  }
  {
#line 827
  (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.perm_addr));
#line 833
  (*(hw->mac.ops.init_rx_addrs))(hw);
  }
  reset_hw_out: ;
#line 836
  if (phy_status != 0) {
#line 837
    status = phy_status;
  } else {

  }
#line 839
  return (status);
}
}
#line 848 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) 
{ 
  u32 rar_high ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 851
  rar_entries = hw->mac.num_rar_entries;
#line 854
  if (rar >= rar_entries) {
    {
#line 855
    descriptor.modname = "ixgbe";
#line 855
    descriptor.function = "ixgbe_set_vmdq_82598";
#line 855
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 855
    descriptor.format = "RAR index %d is out of range.\n";
#line 855
    descriptor.lineno = 855U;
#line 855
    descriptor.flags = 0U;
#line 855
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 855
    if (tmp != 0L) {
      {
#line 855
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", rar);
      }
    } else {

    }
#line 856
    return (-32);
  } else {

  }
  {
#line 859
  rar_high = ixgbe_read_reg(hw, rar <= 15U ? rar * 8U + 21508U : rar * 8U + 41476U);
#line 860
  rar_high = rar_high & 4291035135U;
#line 861
  rar_high = rar_high | ((vmdq << 18) & 3932160U);
#line 862
  ixgbe_write_reg(hw, rar <= 15U ? rar * 8U + 21508U : rar * 8U + 41476U, rar_high);
  }
#line 863
  return (0);
}
}
#line 872 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw , u32 rar , u32 vmdq ) 
{ 
  u32 rar_high ;
  u32 rar_entries ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 875
  rar_entries = hw->mac.num_rar_entries;
#line 879
  if (rar >= rar_entries) {
    {
#line 880
    descriptor.modname = "ixgbe";
#line 880
    descriptor.function = "ixgbe_clear_vmdq_82598";
#line 880
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 880
    descriptor.format = "RAR index %d is out of range.\n";
#line 880
    descriptor.lineno = 880U;
#line 880
    descriptor.flags = 0U;
#line 880
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 880
    if (tmp != 0L) {
      {
#line 880
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "RAR index %d is out of range.\n", rar);
      }
    } else {

    }
#line 881
    return (-32);
  } else {

  }
  {
#line 884
  rar_high = ixgbe_read_reg(hw, rar <= 15U ? rar * 8U + 21508U : rar * 8U + 41476U);
  }
#line 885
  if ((rar_high & 3932160U) != 0U) {
    {
#line 886
    rar_high = rar_high & 4291035135U;
#line 887
    ixgbe_write_reg(hw, rar <= 15U ? rar * 8U + 21508U : rar * 8U + 41476U, rar_high);
    }
  } else {

  }
#line 890
  return (0);
}
}
#line 902 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw , u32 vlan , u32 vind , bool vlan_on ) 
{ 
  u32 regindex ;
  u32 bitindex ;
  u32 bits ;
  u32 vftabyte ;

  {
#line 910
  if (vlan > 4095U) {
#line 911
    return (-5);
  } else {

  }
  {
#line 914
  regindex = (vlan >> 5) & 127U;
#line 917
  vftabyte = (vlan >> 3) & 3U;
#line 918
  bitindex = (vlan & 7U) << 2;
#line 921
  bits = ixgbe_read_reg(hw, ((vftabyte + 81U) * 128U + regindex) * 4U);
#line 922
  bits = bits & (u32 )(~ (15 << (int )bitindex));
#line 923
  bits = bits | (vind << (int )bitindex);
#line 924
  ixgbe_write_reg(hw, ((vftabyte + 81U) * 128U + regindex) * 4U, bits);
#line 927
  bitindex = vlan & 31U;
#line 929
  bits = ixgbe_read_reg(hw, (regindex + 10240U) * 4U);
  }
#line 930
  if ((int )vlan_on) {
#line 932
    bits = bits | (u32 )(1 << (int )bitindex);
  } else {
#line 935
    bits = bits & (u32 )(~ (1 << (int )bitindex));
  }
  {
#line 936
  ixgbe_write_reg(hw, (regindex + 10240U) * 4U, bits);
  }
#line 938
  return (0);
}
}
#line 947 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw ) 
{ 
  u32 offset ;
  u32 vlanbyte ;

  {
#line 952
  offset = 0U;
#line 952
  goto ldv_51056;
  ldv_51055: 
  {
#line 953
  ixgbe_write_reg(hw, (offset + 10240U) * 4U, 0U);
#line 952
  offset = offset + 1U;
  }
  ldv_51056: ;
#line 952
  if (offset < hw->mac.vft_size) {
#line 954
    goto ldv_51055;
  } else {

  }
#line 955
  vlanbyte = 0U;
#line 955
  goto ldv_51062;
  ldv_51061: 
#line 956
  offset = 0U;
#line 956
  goto ldv_51059;
  ldv_51058: 
  {
#line 957
  ixgbe_write_reg(hw, ((vlanbyte + 81U) * 128U + offset) * 4U, 0U);
#line 956
  offset = offset + 1U;
  }
  ldv_51059: ;
#line 956
  if (offset < hw->mac.vft_size) {
#line 958
    goto ldv_51058;
  } else {

  }
#line 955
  vlanbyte = vlanbyte + 1U;
  ldv_51062: ;
#line 955
  if (vlanbyte <= 3U) {
#line 957
    goto ldv_51061;
  } else {

  }

#line 960
  return (0);
}
}
#line 971 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw , u32 reg , u8 *val ) 
{ 
  u32 atlas_ctl ;

  {
  {
#line 975
  ixgbe_write_reg(hw, 18432U, (reg << 8) | 65536U);
#line 977
  ixgbe_read_reg(hw, 8U);
#line 978
  __const_udelay(42950UL);
#line 979
  atlas_ctl = ixgbe_read_reg(hw, 18432U);
#line 980
  *val = (unsigned char )atlas_ctl;
  }
#line 982
  return (0);
}
}
#line 993 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw , u32 reg , u8 val ) 
{ 
  u32 atlas_ctl ;

  {
  {
#line 997
  atlas_ctl = (reg << 8) | (u32 )val;
#line 998
  ixgbe_write_reg(hw, 18432U, atlas_ctl);
#line 999
  ixgbe_read_reg(hw, 8U);
#line 1000
  __const_udelay(42950UL);
  }
#line 1002
  return (0);
}
}
#line 1014 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw , u8 dev_addr , u8 byte_offset ,
                                    u8 *eeprom_data ) 
{ 
  s32 status ;
  u16 sfp_addr ;
  u16 sfp_data ;
  u16 sfp_stat ;
  u16 gssr ;
  u32 i ;
  u32 tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  {
#line 1017
  status = 0;
#line 1018
  sfp_addr = 0U;
#line 1019
  sfp_data = 0U;
#line 1020
  sfp_stat = 0U;
#line 1024
  tmp = ixgbe_read_reg(hw, 8U);
  }
#line 1024
  if ((tmp & 4U) != 0U) {
#line 1025
    gssr = 4U;
  } else {
#line 1027
    gssr = 2U;
  }
  {
#line 1029
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, (int )gssr);
  }
#line 1029
  if (tmp___0 != 0) {
#line 1030
    return (-16);
  } else {

  }
#line 1032
  if ((unsigned int )hw->phy.type == 7U) {
    {
#line 1038
    sfp_addr = ((int )((u16 )dev_addr) << 8U) + (int )((u16 )byte_offset);
#line 1039
    sfp_addr = (u16 )((unsigned int )sfp_addr | 256U);
#line 1040
    (*(hw->phy.ops.write_reg_mdi))(hw, 49930U, 1U, (int )sfp_addr);
#line 1046
    i = 0U;
    }
#line 1046
    goto ldv_51090;
    ldv_51089: 
    {
#line 1047
    (*(hw->phy.ops.read_reg_mdi))(hw, 49932U, 1U, & sfp_stat);
#line 1051
    sfp_stat = (unsigned int )sfp_stat & 3U;
    }
#line 1052
    if ((unsigned int )sfp_stat != 3U) {
#line 1053
      goto ldv_51088;
    } else {

    }
    {
#line 1054
    usleep_range(10000UL, 20000UL);
#line 1046
    i = i + 1U;
    }
    ldv_51090: ;
#line 1046
    if (i <= 99U) {
#line 1048
      goto ldv_51089;
    } else {

    }
    ldv_51088: ;
#line 1057
    if ((unsigned int )sfp_stat != 1U) {
      {
#line 1058
      descriptor.modname = "ixgbe";
#line 1058
      descriptor.function = "ixgbe_read_i2c_phy_82598";
#line 1058
      descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c";
#line 1058
      descriptor.format = "EEPROM read did not pass.\n";
#line 1058
      descriptor.lineno = 1058U;
#line 1058
      descriptor.flags = 0U;
#line 1058
      tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
      }
#line 1058
      if (tmp___1 != 0L) {
        {
#line 1058
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "EEPROM read did not pass.\n");
        }
      } else {

      }
#line 1059
      status = -20;
#line 1060
      goto out;
    } else {

    }
    {
#line 1064
    (*(hw->phy.ops.read_reg_mdi))(hw, 49931U, 1U, & sfp_data);
#line 1067
    *eeprom_data = (unsigned char )((int )sfp_data >> 8);
    }
  } else {
#line 1069
    status = -3;
  }
  out: 
  {
#line 1073
  (*(hw->mac.ops.release_swfw_sync))(hw, (int )gssr);
  }
#line 1074
  return (status);
}
}
#line 1085 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw , u8 byte_offset , u8 *eeprom_data ) 
{ 
  s32 tmp ;

  {
  {
#line 1088
  tmp = ixgbe_read_i2c_phy_82598(hw, 160, (int )byte_offset, eeprom_data);
  }
#line 1088
  return (tmp);
}
}
#line 1100 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static s32 ixgbe_read_i2c_sff8472_82598(struct ixgbe_hw *hw , u8 byte_offset , u8 *sff8472_data ) 
{ 
  s32 tmp ;

  {
  {
#line 1103
  tmp = ixgbe_read_i2c_phy_82598(hw, 162, (int )byte_offset, sff8472_data);
  }
#line 1103
  return (tmp);
}
}
#line 1113 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static u32 ixgbe_get_supported_physical_layer_82598(struct ixgbe_hw *hw ) 
{ 
  u32 physical_layer ;
  u32 autoc ;
  u32 tmp ;
  u32 pma_pmd_10g ;
  u32 pma_pmd_1g ;
  u16 ext_ability ;

  {
  {
#line 1115
  physical_layer = 0U;
#line 1116
  tmp = ixgbe_read_reg(hw, 17056U);
#line 1116
  autoc = tmp;
#line 1117
  pma_pmd_10g = autoc & 384U;
#line 1118
  pma_pmd_1g = autoc & 512U;
#line 1119
  ext_ability = 0U;
#line 1121
  (*(hw->phy.ops.identify))(hw);
  }
  {
#line 1126
  if ((unsigned int )hw->phy.type == 2U) {
#line 1126
    goto case_2;
  } else {

  }
#line 1127
  if ((unsigned int )hw->phy.type == 4U) {
#line 1127
    goto case_4;
  } else {

  }
#line 1137
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_4: /* CIL Label */ 
  {
#line 1128
  (*(hw->phy.ops.read_reg))(hw, 11U, 1U, & ext_ability);
  }
#line 1130
  if (((int )ext_ability & 4) != 0) {
#line 1131
    physical_layer = physical_layer | 1U;
  } else {

  }
#line 1132
  if (((int )ext_ability & 32) != 0) {
#line 1133
    physical_layer = physical_layer | 2U;
  } else {

  }
#line 1134
  if (((int )ext_ability & 128) != 0) {
#line 1135
    physical_layer = physical_layer | 4U;
  } else {

  }
#line 1136
  goto out;
  switch_default: /* CIL Label */ ;
#line 1138
  goto ldv_51116;
  switch_break: /* CIL Label */ ;
  }
  ldv_51116: ;
  {
#line 1142
  if ((autoc & 57344U) == 16384U) {
#line 1142
    goto case_16384;
  } else {

  }
#line 1143
  if ((autoc & 57344U) == 0U) {
#line 1143
    goto case_0;
  } else {

  }
#line 1149
  if ((autoc & 57344U) == 8192U) {
#line 1149
    goto case_8192;
  } else {

  }
#line 1157
  if ((autoc & 57344U) == 32768U) {
#line 1157
    goto case_32768;
  } else {

  }
#line 1158
  if ((autoc & 57344U) == 49152U) {
#line 1158
    goto case_49152;
  } else {

  }
#line 1164
  goto switch_default___0;
  case_16384: /* CIL Label */ ;
  case_0: /* CIL Label */ ;
#line 1144
  if (pma_pmd_1g == 512U) {
#line 1145
    physical_layer = 512U;
  } else {
#line 1147
    physical_layer = 1024U;
  }
#line 1148
  goto ldv_51119;
  case_8192: /* CIL Label */ ;
#line 1150
  if (pma_pmd_10g == 256U) {
#line 1151
    physical_layer = 256U;
  } else
#line 1152
  if (pma_pmd_10g == 128U) {
#line 1153
    physical_layer = 128U;
  } else {
#line 1155
    physical_layer = 0U;
  }
#line 1156
  goto ldv_51119;
  case_32768: /* CIL Label */ ;
  case_49152: /* CIL Label */ ;
#line 1159
  if ((autoc & 1073741824U) != 0U) {
#line 1160
    physical_layer = physical_layer | 512U;
  } else {

  }
#line 1161
  if ((int )autoc < 0) {
#line 1162
    physical_layer = physical_layer | 128U;
  } else {

  }
#line 1163
  goto ldv_51119;
  switch_default___0: /* CIL Label */ ;
#line 1165
  goto ldv_51119;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_51119: ;
#line 1168
  if ((unsigned int )hw->phy.type == 7U) {
    {
#line 1169
    (*(hw->phy.ops.identify_sfp))(hw);
    }
    {
#line 1172
    if ((unsigned int )hw->phy.sfp_type == 0U) {
#line 1172
      goto case_0___0;
    } else {

    }
#line 1175
    if ((unsigned int )hw->phy.sfp_type == 1U) {
#line 1175
      goto case_1;
    } else {

    }
#line 1178
    if ((unsigned int )hw->phy.sfp_type == 2U) {
#line 1178
      goto case_2___0;
    } else {

    }
#line 1181
    goto switch_default___1;
    case_0___0: /* CIL Label */ 
#line 1173
    physical_layer = 8U;
#line 1174
    goto ldv_51125;
    case_1: /* CIL Label */ 
#line 1176
    physical_layer = 64U;
#line 1177
    goto ldv_51125;
    case_2___0: /* CIL Label */ 
#line 1179
    physical_layer = 16U;
#line 1180
    goto ldv_51125;
    switch_default___1: /* CIL Label */ 
#line 1182
    physical_layer = 0U;
#line 1183
    goto ldv_51125;
    switch_break___1: /* CIL Label */ ;
    }
    ldv_51125: ;
  } else {

  }
  {
#line 1188
  if ((int )hw->device_id == 4337) {
#line 1188
    goto case_4337;
  } else {

  }
#line 1191
  if ((int )hw->device_id == 4294) {
#line 1191
    goto case_4294;
  } else {

  }
#line 1192
  if ((int )hw->device_id == 4295) {
#line 1192
    goto case_4295;
  } else {

  }
#line 1193
  if ((int )hw->device_id == 4321) {
#line 1193
    goto case_4321;
  } else {

  }
#line 1196
  if ((int )hw->device_id == 4340) {
#line 1196
    goto case_4340;
  } else {

  }
#line 1199
  goto switch_default___2;
  case_4337: /* CIL Label */ 
#line 1189
  physical_layer = 8U;
#line 1190
  goto ldv_51130;
  case_4294: /* CIL Label */ ;
  case_4295: /* CIL Label */ ;
  case_4321: /* CIL Label */ 
#line 1194
  physical_layer = 64U;
#line 1195
  goto ldv_51130;
  case_4340: /* CIL Label */ 
#line 1197
  physical_layer = 16U;
#line 1198
  goto ldv_51130;
  switch_default___2: /* CIL Label */ ;
#line 1200
  goto ldv_51130;
  switch_break___2: /* CIL Label */ ;
  }
  ldv_51130: ;
  out: ;
#line 1204
  return (physical_layer);
}
}
#line 1215 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_bus_info *bus ;
  u16 pci_gen ;
  u16 pci_ctrl2 ;

  {
  {
#line 1217
  bus = & hw->bus;
#line 1218
  pci_gen = 0U;
#line 1219
  pci_ctrl2 = 0U;
#line 1221
  ixgbe_set_lan_id_multi_port_pcie(hw);
#line 1224
  (*(hw->eeprom.ops.read))(hw, 6, & pci_gen);
  }
#line 1225
  if ((unsigned int )pci_gen - 1U <= 65533U) {
    {
#line 1227
    (*(hw->eeprom.ops.read))(hw, (int )((unsigned int )pci_gen + 5U), & pci_ctrl2);
    }
#line 1230
    if (((unsigned int )pci_ctrl2 & 3U) == 2U && ((int )pci_ctrl2 & 8) == 0) {
#line 1234
      bus->func = 0U;
    } else {

    }
  } else {

  }
#line 1236
  return;
}
}
#line 1246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw , int num_pb , u32 headroom ,
                                  int strategy ) 
{ 
  u32 rxpktsize ;
  u8 i ;

  {
#line 1249
  rxpktsize = 65536U;
#line 1250
  i = 0U;
#line 1252
  if (num_pb == 0) {
#line 1253
    return;
  } else {

  }
  {
#line 1257
  if (strategy == 1) {
#line 1257
    goto case_1;
  } else {

  }
#line 1265
  if (strategy == 0) {
#line 1265
    goto case_0;
  } else {

  }
#line 1266
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1259
  rxpktsize = 81920U;
#line 1260
  goto ldv_51152;
  ldv_51151: 
  {
#line 1261
  ixgbe_write_reg(hw, (u32 )(((int )i + 3840) * 4), rxpktsize);
#line 1260
  i = (u8 )((int )i + 1);
  }
  ldv_51152: ;
#line 1260
  if ((unsigned int )i <= 3U) {
#line 1262
    goto ldv_51151;
  } else {

  }
#line 1263
  rxpktsize = 49152U;
  case_0: /* CIL Label */ ;
  switch_default: /* CIL Label */ ;
#line 1268
  goto ldv_51157;
  ldv_51156: 
  {
#line 1269
  ixgbe_write_reg(hw, (u32 )(((int )i + 3840) * 4), rxpktsize);
#line 1268
  i = (u8 )((int )i + 1);
  }
  ldv_51157: ;
#line 1268
  if ((unsigned int )i <= 7U) {
#line 1270
    goto ldv_51156;
  } else {

  }

#line 1270
  goto ldv_51159;
  switch_break: /* CIL Label */ ;
  }
  ldv_51159: 
#line 1274
  i = 0U;
#line 1274
  goto ldv_51161;
  ldv_51160: 
  {
#line 1275
  ixgbe_write_reg(hw, (u32 )(((int )i + 13056) * 4), 40960U);
#line 1274
  i = (u8 )((int )i + 1);
  }
  ldv_51161: ;
#line 1274
  if ((unsigned int )i <= 7U) {
#line 1276
    goto ldv_51160;
  } else {

  }

#line 1277
  return;
}
}
#line 1280 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_mac_operations mac_ops_82598  = 
#line 1280
     {& ixgbe_init_hw_generic, & ixgbe_reset_hw_82598, & ixgbe_start_hw_82598, & ixgbe_clear_hw_cntrs_generic,
    & ixgbe_get_media_type_82598, & ixgbe_get_supported_physical_layer_82598, & ixgbe_get_mac_addr_generic,
    0, 0, 0, & ixgbe_stop_adapter_generic, & ixgbe_get_bus_info_generic, & ixgbe_set_lan_id_multi_port_pcie_82598,
    & ixgbe_read_analog_reg8_82598, & ixgbe_write_analog_reg8_82598, 0, 0, 0, & ixgbe_enable_rx_dma_generic,
    & ixgbe_acquire_swfw_sync, & ixgbe_release_swfw_sync, 0, 0, 0, 0, & ixgbe_setup_mac_link_82598,
    & ixgbe_check_mac_link_82598, & ixgbe_get_link_capabilities_82598, & ixgbe_set_rxpba_82598,
    & ixgbe_led_on_generic, & ixgbe_led_off_generic, & ixgbe_blink_led_start_generic,
    & ixgbe_blink_led_stop_generic, & ixgbe_set_rar_generic, & ixgbe_clear_rar_generic,
    & ixgbe_set_vmdq_82598, 0, & ixgbe_clear_vmdq_82598, & ixgbe_init_rx_addrs_generic,
    & ixgbe_update_mc_addr_list_generic, & ixgbe_enable_mc_generic, & ixgbe_disable_mc_generic,
    & ixgbe_clear_vfta_82598, & ixgbe_set_vfta_82598, 0, 0, 0, & ixgbe_fc_enable_82598,
    (s32 (*)(struct ixgbe_hw * , u8  , u8  , u8  , u8  ))0, (s32 (*)(struct ixgbe_hw * ))0,
    (s32 (*)(struct ixgbe_hw * ))0, (bool (*)(struct ixgbe_hw * ))0};
#line 1321 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_eeprom_operations eeprom_ops_82598  = 
#line 1321
     {& ixgbe_init_eeprom_params_generic, & ixgbe_read_eerd_generic, & ixgbe_read_eerd_buffer_generic,
    & ixgbe_write_eeprom_generic, & ixgbe_write_eeprom_buffer_bit_bang_generic, & ixgbe_validate_eeprom_checksum_generic,
    & ixgbe_update_eeprom_checksum_generic, & ixgbe_calc_eeprom_checksum_generic};
#line 1332 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
static struct ixgbe_phy_operations phy_ops_82598  = 
#line 1332
     {& ixgbe_identify_phy_generic, & ixgbe_identify_module_generic, & ixgbe_init_phy_ops_82598,
    & ixgbe_reset_phy_generic, & ixgbe_read_phy_reg_generic, & ixgbe_write_phy_reg_generic,
    & ixgbe_read_phy_reg_mdi, & ixgbe_write_phy_reg_mdi, & ixgbe_setup_phy_link_generic,
    & ixgbe_setup_phy_link_speed_generic, 0, 0, 0, 0, & ixgbe_read_i2c_sff8472_82598,
    & ixgbe_read_i2c_eeprom_82598, 0, & ixgbe_tn_check_overtemp};
#line 1348 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c"
struct ixgbe_info ixgbe_82598_info  =    {1, & ixgbe_get_invariants_82598, & mac_ops_82598, & eeprom_ops_82598, & phy_ops_82598,
    0};
#line 140 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_10_107(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 141
  ixgbe_read_phy_reg_mdi(arg1, arg2, arg3, arg4);
  }
#line 142
  return;
}
}
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_10_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 146
  ixgbe_set_lan_id_multi_port_pcie_82598(arg1);
  }
#line 147
  return;
}
}
#line 150 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_10_174(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 151
  ixgbe_write_phy_reg_mdi(arg1, arg2, arg3, (int )arg4);
  }
#line 152
  return;
}
}
#line 155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_10_89(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 156
  ixgbe_read_eerd_buffer_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 157
  return;
}
}
#line 160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_107(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 161
  ixgbe_read_phy_reg_mdi(arg1, arg2, arg3, arg4);
  }
#line 162
  return;
}
}
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 166
  ixgbe_set_lan_id_multi_port_pcie_82598(arg1);
  }
#line 167
  return;
}
}
#line 170 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_174(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 171
  ixgbe_write_phy_reg_mdi(arg1, arg2, arg3, (int )arg4);
  }
#line 172
  return;
}
}
#line 175 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_25(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int *arg2 , _Bool *arg3 ,
                                                    _Bool arg4 ) 
{ 


  {
  {
#line 176
  ixgbe_check_mac_link_82598(arg1, arg2, arg3, (int )arg4);
  }
#line 177
  return;
}
}
#line 180 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 181
  ixgbe_clear_vfta_82598(arg1);
  }
#line 182
  return;
}
}
#line 185 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_34(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) 
{ 


  {
  {
#line 186
  ixgbe_clear_vmdq_82598(arg1, arg2, arg3);
  }
#line 187
  return;
}
}
#line 190 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 191
  ixgbe_fc_enable_82598(arg1);
  }
#line 192
  return;
}
}
#line 195 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_53(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    _Bool *arg3 ) 
{ 


  {
  {
#line 196
  ixgbe_get_link_capabilities_82598(arg1, arg2, arg3);
  }
#line 197
  return;
}
}
#line 200 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_11_89(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 201
  ixgbe_read_eerd_buffer_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 202
  return;
}
}
#line 205 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_12_107(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 206
  ixgbe_read_phy_reg_mdi(arg1, arg2, arg3, arg4);
  }
#line 207
  return;
}
}
#line 210 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_12_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 211
  ixgbe_set_lan_id_multi_port_pcie_82598(arg1);
  }
#line 212
  return;
}
}
#line 215 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_12_174(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 216
  ixgbe_write_phy_reg_mdi(arg1, arg2, arg3, (int )arg4);
  }
#line 217
  return;
}
}
#line 220 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_12_25(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int *arg2 , _Bool *arg3 ,
                                                    _Bool arg4 ) 
{ 


  {
  {
#line 221
  ixgbe_check_mac_link_82598(arg1, arg2, arg3, (int )arg4);
  }
#line 222
  return;
}
}
#line 225 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_12_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 226
  ixgbe_clear_vfta_82598(arg1);
  }
#line 227
  return;
}
}
#line 230 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_12_34(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) 
{ 


  {
  {
#line 231
  ixgbe_clear_vmdq_82598(arg1, arg2, arg3);
  }
#line 232
  return;
}
}
#line 235 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_12_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 236
  ixgbe_fc_enable_82598(arg1);
  }
#line 237
  return;
}
}
#line 240 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_12_89(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 241
  ixgbe_read_eerd_buffer_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 242
  return;
}
}
#line 245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_107(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 246
  ixgbe_read_phy_reg_mdi(arg1, arg2, arg3, arg4);
  }
#line 247
  return;
}
}
#line 250 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 251
  ixgbe_set_lan_id_multi_port_pcie_82598(arg1);
  }
#line 252
  return;
}
}
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_174(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 256
  ixgbe_write_phy_reg_mdi(arg1, arg2, arg3, (int )arg4);
  }
#line 257
  return;
}
}
#line 260 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_25(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int *arg2 , _Bool *arg3 ,
                                                    _Bool arg4 ) 
{ 


  {
  {
#line 261
  ixgbe_check_mac_link_82598(arg1, arg2, arg3, (int )arg4);
  }
#line 262
  return;
}
}
#line 265 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 266
  ixgbe_clear_vfta_82598(arg1);
  }
#line 267
  return;
}
}
#line 270 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_34(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) 
{ 


  {
  {
#line 271
  ixgbe_clear_vmdq_82598(arg1, arg2, arg3);
  }
#line 272
  return;
}
}
#line 275 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 276
  ixgbe_fc_enable_82598(arg1);
  }
#line 277
  return;
}
}
#line 280 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 281
  ixgbe_get_invariants_82598(arg1);
  }
#line 282
  return;
}
}
#line 285 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 286
  ixgbe_get_media_type_82598(arg1);
  }
#line 287
  return;
}
}
#line 290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 291
  ixgbe_get_supported_physical_layer_82598(arg1);
  }
#line 292
  return;
}
}
#line 295 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_13_89(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 296
  ixgbe_read_eerd_buffer_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 297
  return;
}
}
#line 300 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_107(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 301
  ixgbe_read_phy_reg_mdi(arg1, arg2, arg3, arg4);
  }
#line 302
  return;
}
}
#line 305 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 306
  ixgbe_reset_hw_82598(arg1);
  }
#line 307
  return;
}
}
#line 310 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_125(void (*arg0)(struct ixgbe_hw * ,
                                                                 int  , unsigned int  ,
                                                                 int  ) , struct ixgbe_hw *arg1 ,
                                                    int arg2 , unsigned int arg3 ,
                                                    int arg4 ) 
{ 


  {
  {
#line 311
  ixgbe_set_rxpba_82598(arg1, arg2, arg3, arg4);
  }
#line 312
  return;
}
}
#line 315 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_128(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int arg2 , unsigned int arg3 ,
                                                    _Bool arg4 ) 
{ 


  {
  {
#line 316
  ixgbe_set_vfta_82598(arg1, arg2, arg3, (int )arg4);
  }
#line 317
  return;
}
}
#line 320 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_134(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) 
{ 


  {
  {
#line 321
  ixgbe_set_vmdq_82598(arg1, arg2, arg3);
  }
#line 322
  return;
}
}
#line 325 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_141(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , _Bool  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    _Bool arg3 ) 
{ 


  {
  {
#line 326
  ixgbe_setup_mac_link_82598(arg1, arg2, (int )arg3);
  }
#line 327
  return;
}
}
#line 330 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 331
  ixgbe_start_hw_82598(arg1);
  }
#line 332
  return;
}
}
#line 335 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_156(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 336
  ixgbe_write_analog_reg8_82598(arg1, arg2, (int )arg3);
  }
#line 337
  return;
}
}
#line 340 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_174(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 341
  ixgbe_write_phy_reg_mdi(arg1, arg2, arg3, (int )arg4);
  }
#line 342
  return;
}
}
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_25(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , _Bool * ,
                                                               _Bool  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int *arg2 , _Bool *arg3 ,
                                                   _Bool arg4 ) 
{ 


  {
  {
#line 346
  ixgbe_check_mac_link_82598(arg1, arg2, arg3, (int )arg4);
  }
#line 347
  return;
}
}
#line 350 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 351
  ixgbe_clear_vfta_82598(arg1);
  }
#line 352
  return;
}
}
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_34(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  , unsigned int  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                   unsigned int arg3 ) 
{ 


  {
  {
#line 356
  ixgbe_clear_vmdq_82598(arg1, arg2, arg3);
  }
#line 357
  return;
}
}
#line 360 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 361
  ixgbe_fc_enable_82598(arg1);
  }
#line 362
  return;
}
}
#line 365 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 366
  ixgbe_get_invariants_82598(arg1);
  }
#line 367
  return;
}
}
#line 370 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 371
  ixgbe_get_media_type_82598(arg1);
  }
#line 372
  return;
}
}
#line 375 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 376
  ixgbe_get_supported_physical_layer_82598(arg1);
  }
#line 377
  return;
}
}
#line 380 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_70(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 381
  ixgbe_init_phy_ops_82598(arg1);
  }
#line 382
  return;
}
}
#line 385 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_86(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 386
  ixgbe_read_analog_reg8_82598(arg1, arg2, arg3);
  }
#line 387
  return;
}
}
#line 390 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_89(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  , unsigned short  ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 391
  ixgbe_read_eerd_buffer_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 392
  return;
}
}
#line 395 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_95(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 396
  ixgbe_read_i2c_eeprom_82598(arg1, (int )arg2, arg3);
  }
#line 397
  return;
}
}
#line 400 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_8_98(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 401
  ixgbe_read_i2c_sff8472_82598(arg1, (int )arg2, arg3);
  }
#line 402
  return;
}
}
#line 405 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_9_107(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 406
  ixgbe_read_phy_reg_mdi(arg1, arg2, arg3, arg4);
  }
#line 407
  return;
}
}
#line 410 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_9_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 411
  ixgbe_set_lan_id_multi_port_pcie_82598(arg1);
  }
#line 412
  return;
}
}
#line 415 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_82598.c.aux"
void ldv_dummy_resourceless_instance_callback_9_174(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 416
  ixgbe_write_phy_reg_mdi(arg1, arg2, arg3, (int )arg4);
  }
#line 417
  return;
}
}
#line 64 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/mdio.h"
extern int mdio45_probe(struct mdio_if_info * , int  ) ;
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h"
s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw , u16 *firmware_version ) ;
#line 147
s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw ) ;
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_start(struct ixgbe_hw *hw ) ;
#line 36
static void ixgbe_i2c_stop(struct ixgbe_hw *hw ) ;
#line 37
static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw , u8 *data ) ;
#line 38
static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw , u8 data ) ;
#line 39
static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw ) ;
#line 40
static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw , bool *data ) ;
#line 41
static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw , bool data ) ;
#line 42
static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw , u32 *i2cctl ) ;
#line 43
static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw , u32 *i2cctl ) ;
#line 44
static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw , u32 *i2cctl , bool data ) ;
#line 45
static bool ixgbe_get_i2c_data(u32 *i2cctl ) ;
#line 46
static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw ) ;
#line 47
static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id ) ;
#line 48
static s32 ixgbe_get_phy_id(struct ixgbe_hw *hw ) ;
#line 49
static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw ) ;
#line 57 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 phy_addr ;
  u16 ext_ability ;
  int tmp ;

  {
#line 59
  status = -17;
#line 61
  ext_ability = 0U;
#line 63
  if ((unsigned int )hw->phy.type == 0U) {
#line 64
    phy_addr = 0U;
#line 64
    goto ldv_50881;
    ldv_50880: 
    {
#line 65
    hw->phy.mdio.prtad = (int )phy_addr;
#line 66
    tmp = mdio45_probe(& hw->phy.mdio, (int )phy_addr);
    }
#line 66
    if (tmp == 0) {
      {
#line 67
      ixgbe_get_phy_id(hw);
#line 68
      hw->phy.type = ixgbe_get_phy_type_from_id(hw->phy.id);
      }
#line 71
      if ((unsigned int )hw->phy.type == 0U) {
        {
#line 72
        (*(hw->phy.ops.read_reg))(hw, 11U, 1U, & ext_ability);
        }
#line 76
        if (((int )ext_ability & 36) != 0) {
#line 79
          hw->phy.type = 4;
        } else {
#line 82
          hw->phy.type = 21;
        }
      } else {

      }
#line 86
      status = 0;
#line 87
      goto ldv_50879;
    } else {

    }
#line 64
    phy_addr = phy_addr + 1U;
    ldv_50881: ;
#line 64
    if (phy_addr <= 31U) {
#line 66
      goto ldv_50880;
    } else {

    }
    ldv_50879: ;
#line 91
    if (status != 0) {
#line 92
      hw->phy.mdio.prtad = 0;
    } else {

    }
  } else {
#line 94
    status = 0;
  }
#line 97
  return (status);
}
}
#line 105 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_get_phy_id(struct ixgbe_hw *hw ) 
{ 
  u32 status ;
  u16 phy_id_high ;
  u16 phy_id_low ;
  s32 tmp ;
  s32 tmp___0 ;

  {
  {
#line 108
  phy_id_high = 0U;
#line 109
  phy_id_low = 0U;
#line 111
  tmp = (*(hw->phy.ops.read_reg))(hw, 2U, 1U, & phy_id_high);
#line 111
  status = (u32 )tmp;
  }
#line 114
  if (status == 0U) {
    {
#line 115
    hw->phy.id = (unsigned int )((int )phy_id_high << 16);
#line 116
    tmp___0 = (*(hw->phy.ops.read_reg))(hw, 3U, 1U, & phy_id_low);
#line 116
    status = (u32 )tmp___0;
#line 118
    hw->phy.id = hw->phy.id | ((u32 )phy_id_low & 4294967280U);
#line 119
    hw->phy.revision = (unsigned int )phy_id_low & 15U;
    }
  } else {

  }
#line 121
  return ((s32 )status);
}
}
#line 129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id ) 
{ 
  enum ixgbe_phy_type phy_type ;

  {
  {
#line 134
  if (phy_id == 10589200U) {
#line 134
    goto case_10589200;
  } else {

  }
#line 137
  if (phy_id == 22282752U) {
#line 137
    goto case_22282752;
  } else {

  }
#line 140
  if (phy_id == 4432896U) {
#line 140
    goto case_4432896;
  } else {

  }
#line 143
  if (phy_id == 54693968U) {
#line 143
    goto case_54693968;
  } else {

  }
#line 146
  goto switch_default;
  case_10589200: /* CIL Label */ 
#line 135
  phy_type = 2;
#line 136
  goto ldv_50893;
  case_22282752: /* CIL Label */ 
#line 138
  phy_type = 3;
#line 139
  goto ldv_50893;
  case_4432896: /* CIL Label */ 
#line 141
  phy_type = 5;
#line 142
  goto ldv_50893;
  case_54693968: /* CIL Label */ 
#line 144
  phy_type = 7;
#line 145
  goto ldv_50893;
  switch_default: /* CIL Label */ 
#line 147
  phy_type = 0;
#line 148
  goto ldv_50893;
  switch_break: /* CIL Label */ ;
  }
  ldv_50893: ;
#line 151
  return (phy_type);
}
}
#line 158 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u16 ctrl ;
  s32 status ;
  s32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
#line 161
  ctrl = 0U;
#line 162
  status = 0;
#line 164
  if ((unsigned int )hw->phy.type == 0U) {
    {
#line 165
    status = ixgbe_identify_phy_generic(hw);
    }
  } else {

  }
#line 167
  if (status != 0 || (unsigned int )hw->phy.type == 1U) {
#line 168
    goto out;
  } else {

  }
#line 171
  if (! hw->phy.reset_if_overtemp) {
    {
#line 171
    tmp = (*(hw->phy.ops.check_overtemp))(hw);
    }
#line 171
    if (tmp == -26) {
#line 173
      goto out;
    } else {

    }
  } else {

  }
  {
#line 179
  (*(hw->phy.ops.write_reg))(hw, 0U, 4U, 32768);
#line 188
  i = 0U;
  }
#line 188
  goto ldv_50907;
  ldv_50906: 
  {
#line 189
  msleep(100U);
#line 190
  (*(hw->phy.ops.read_reg))(hw, 0U, 4U, & ctrl);
  }
#line 192
  if ((int )((short )ctrl) >= 0) {
    {
#line 193
    __const_udelay(8590UL);
    }
#line 194
    goto ldv_50905;
  } else {

  }
#line 188
  i = i + 1U;
  ldv_50907: ;
#line 188
  if (i <= 29U) {
#line 190
    goto ldv_50906;
  } else {

  }
  ldv_50905: ;
#line 198
  if ((int )((short )ctrl) < 0) {
    {
#line 199
    status = -15;
#line 200
    descriptor.modname = "ixgbe";
#line 200
    descriptor.function = "ixgbe_reset_phy_generic";
#line 200
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 200
    descriptor.format = "PHY reset polling failed to complete.\n";
#line 200
    descriptor.lineno = 200U;
#line 200
    descriptor.flags = 0U;
#line 200
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 200
    if (tmp___0 != 0L) {
      {
#line 200
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY reset polling failed to complete.\n");
      }
    } else {

    }
  } else {

  }
  out: ;
#line 204
  return (status);
}
}
#line 214 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                           u16 *phy_data ) 
{ 
  u32 i ;
  u32 data ;
  u32 command ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  {
#line 220
  command = ((reg_addr | (device_type << 16)) | (u32 )(hw->phy.mdio.prtad << 21)) | 1073741824U;
#line 225
  ixgbe_write_reg(hw, 16988U, command);
#line 231
  i = 0U;
  }
#line 231
  goto ldv_50921;
  ldv_50920: 
  {
#line 232
  __const_udelay(42950UL);
#line 234
  command = ixgbe_read_reg(hw, 16988U);
  }
#line 235
  if ((command & 1073741824U) == 0U) {
#line 236
    goto ldv_50919;
  } else {

  }
#line 231
  i = i + 1U;
  ldv_50921: ;
#line 231
  if (i <= 99U) {
#line 233
    goto ldv_50920;
  } else {

  }
  ldv_50919: ;
#line 240
  if ((command & 1073741824U) != 0U) {
    {
#line 241
    descriptor.modname = "ixgbe";
#line 241
    descriptor.function = "ixgbe_read_phy_reg_mdi";
#line 241
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 241
    descriptor.format = "PHY address command did not complete.\n";
#line 241
    descriptor.lineno = 241U;
#line 241
    descriptor.flags = 0U;
#line 241
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 241
    if (tmp != 0L) {
      {
#line 241
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY address command did not complete.\n");
      }
    } else {

    }
#line 242
    return (-3);
  } else {

  }
  {
#line 248
  command = ((reg_addr | (device_type << 16)) | (u32 )(hw->phy.mdio.prtad << 21)) | 1275068416U;
#line 253
  ixgbe_write_reg(hw, 16988U, command);
#line 259
  i = 0U;
  }
#line 259
  goto ldv_50926;
  ldv_50925: 
  {
#line 260
  __const_udelay(42950UL);
#line 262
  command = ixgbe_read_reg(hw, 16988U);
  }
#line 263
  if ((command & 1073741824U) == 0U) {
#line 264
    goto ldv_50924;
  } else {

  }
#line 259
  i = i + 1U;
  ldv_50926: ;
#line 259
  if (i <= 99U) {
#line 261
    goto ldv_50925;
  } else {

  }
  ldv_50924: ;
#line 267
  if ((command & 1073741824U) != 0U) {
    {
#line 268
    descriptor___0.modname = "ixgbe";
#line 268
    descriptor___0.function = "ixgbe_read_phy_reg_mdi";
#line 268
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 268
    descriptor___0.format = "PHY read command didn\'t complete\n";
#line 268
    descriptor___0.lineno = 268U;
#line 268
    descriptor___0.flags = 0U;
#line 268
    tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 268
    if (tmp___0 != 0L) {
      {
#line 268
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY read command didn\'t complete\n");
      }
    } else {

    }
#line 269
    return (-3);
  } else {

  }
  {
#line 275
  data = ixgbe_read_reg(hw, 16992U);
#line 276
  data = data >> 16;
#line 277
  *phy_data = (unsigned short )data;
  }
#line 279
  return (0);
}
}
#line 289 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                               u16 *phy_data ) 
{ 
  s32 status ;
  u16 gssr ;
  u32 tmp ;
  s32 tmp___0 ;

  {
  {
#line 295
  tmp = ixgbe_read_reg(hw, 8U);
  }
#line 295
  if ((tmp & 4U) != 0U) {
#line 296
    gssr = 4U;
  } else {
#line 298
    gssr = 2U;
  }
  {
#line 300
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, (int )gssr);
  }
#line 300
  if (tmp___0 == 0) {
    {
#line 301
    status = ixgbe_read_phy_reg_mdi(hw, reg_addr, device_type, phy_data);
#line 303
    (*(hw->mac.ops.release_swfw_sync))(hw, (int )gssr);
    }
  } else {
#line 305
    status = -16;
  }
#line 308
  return (status);
}
}
#line 319 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                            u16 phy_data ) 
{ 
  u32 i ;
  u32 command ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  {
#line 325
  ixgbe_write_reg(hw, 16992U, (unsigned int )phy_data);
#line 328
  command = ((reg_addr | (device_type << 16)) | (u32 )(hw->phy.mdio.prtad << 21)) | 1073741824U;
#line 333
  ixgbe_write_reg(hw, 16988U, command);
#line 340
  i = 0U;
  }
#line 340
  goto ldv_50946;
  ldv_50945: 
  {
#line 341
  __const_udelay(42950UL);
#line 343
  command = ixgbe_read_reg(hw, 16988U);
  }
#line 344
  if ((command & 1073741824U) == 0U) {
#line 345
    goto ldv_50944;
  } else {

  }
#line 340
  i = i + 1U;
  ldv_50946: ;
#line 340
  if (i <= 99U) {
#line 342
    goto ldv_50945;
  } else {

  }
  ldv_50944: ;
#line 348
  if ((command & 1073741824U) != 0U) {
    {
#line 349
    descriptor.modname = "ixgbe";
#line 349
    descriptor.function = "ixgbe_write_phy_reg_mdi";
#line 349
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 349
    descriptor.format = "PHY address cmd didn\'t complete\n";
#line 349
    descriptor.lineno = 349U;
#line 349
    descriptor.flags = 0U;
#line 349
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 349
    if (tmp != 0L) {
      {
#line 349
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY address cmd didn\'t complete\n");
      }
    } else {

    }
#line 350
    return (-3);
  } else {

  }
  {
#line 357
  command = ((reg_addr | (device_type << 16)) | (u32 )(hw->phy.mdio.prtad << 21)) | 1140850688U;
#line 362
  ixgbe_write_reg(hw, 16988U, command);
#line 368
  i = 0U;
  }
#line 368
  goto ldv_50951;
  ldv_50950: 
  {
#line 369
  __const_udelay(42950UL);
#line 371
  command = ixgbe_read_reg(hw, 16988U);
  }
#line 372
  if ((command & 1073741824U) == 0U) {
#line 373
    goto ldv_50949;
  } else {

  }
#line 368
  i = i + 1U;
  ldv_50951: ;
#line 368
  if (i <= 99U) {
#line 370
    goto ldv_50950;
  } else {

  }
  ldv_50949: ;
#line 376
  if ((command & 1073741824U) != 0U) {
    {
#line 377
    descriptor___0.modname = "ixgbe";
#line 377
    descriptor___0.function = "ixgbe_write_phy_reg_mdi";
#line 377
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 377
    descriptor___0.format = "PHY write cmd didn\'t complete\n";
#line 377
    descriptor___0.lineno = 377U;
#line 377
    descriptor___0.flags = 0U;
#line 377
    tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 377
    if (tmp___0 != 0L) {
      {
#line 377
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY write cmd didn\'t complete\n");
      }
    } else {

    }
#line 378
    return (-3);
  } else {

  }
#line 381
  return (0);
}
}
#line 392 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw , u32 reg_addr , u32 device_type ,
                                u16 phy_data ) 
{ 
  s32 status ;
  u16 gssr ;
  u32 tmp ;
  s32 tmp___0 ;

  {
  {
#line 398
  tmp = ixgbe_read_reg(hw, 8U);
  }
#line 398
  if ((tmp & 4U) != 0U) {
#line 399
    gssr = 4U;
  } else {
#line 401
    gssr = 2U;
  }
  {
#line 403
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, (int )gssr);
  }
#line 403
  if (tmp___0 == 0) {
    {
#line 404
    status = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type, (int )phy_data);
#line 406
    (*(hw->mac.ops.release_swfw_sync))(hw, (int )gssr);
    }
  } else {
#line 408
    status = -16;
  }
#line 411
  return (status);
}
}
#line 420 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 time_out ;
  u32 max_time_out ;
  u16 autoneg_reg ;
  bool autoneg ;
  ixgbe_link_speed speed ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  {
#line 422
  status = 0;
#line 424
  max_time_out = 10U;
#line 425
  autoneg_reg = 0U;
#line 426
  autoneg = 0;
#line 429
  ixgbe_get_copper_link_capabilities_generic(hw, & speed, & autoneg);
  }
#line 431
  if ((speed & 128U) != 0U) {
    {
#line 433
    (*(hw->phy.ops.read_reg))(hw, 32U, 7U, & autoneg_reg);
#line 437
    autoneg_reg = (unsigned int )autoneg_reg & 61439U;
    }
#line 438
    if ((hw->phy.autoneg_advertised & 128U) != 0U) {
#line 439
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 4096U);
    } else {

    }
    {
#line 441
    (*(hw->phy.ops.write_reg))(hw, 32U, 7U, (int )autoneg_reg);
    }
  } else {

  }
#line 446
  if ((speed & 32U) != 0U) {
    {
#line 448
    (*(hw->phy.ops.read_reg))(hw, 50176U, 7U, & autoneg_reg);
#line 453
    autoneg_reg = (unsigned int )autoneg_reg & 32767U;
    }
#line 454
    if ((hw->phy.autoneg_advertised & 32U) != 0U) {
#line 455
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 32768U);
    } else {

    }
    {
#line 457
    (*(hw->phy.ops.write_reg))(hw, 50176U, 7U, (int )autoneg_reg);
    }
  } else {

  }
#line 463
  if ((speed & 8U) != 0U) {
    {
#line 465
    (*(hw->phy.ops.read_reg))(hw, 16U, 7U, & autoneg_reg);
#line 469
    autoneg_reg = (unsigned int )autoneg_reg & 65151U;
    }
#line 471
    if ((hw->phy.autoneg_advertised & 8U) != 0U) {
#line 472
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 256U);
    } else {

    }
    {
#line 474
    (*(hw->phy.ops.write_reg))(hw, 16U, 7U, (int )autoneg_reg);
    }
  } else {

  }
  {
#line 480
  (*(hw->phy.ops.read_reg))(hw, 0U, 7U, & autoneg_reg);
#line 483
  autoneg_reg = (u16 )((unsigned int )autoneg_reg | 512U);
#line 485
  (*(hw->phy.ops.write_reg))(hw, 0U, 7U, (int )autoneg_reg);
#line 489
  time_out = 0U;
  }
#line 489
  goto ldv_50972;
  ldv_50971: 
  {
#line 490
  __const_udelay(42950UL);
#line 492
  status = (*(hw->phy.ops.read_reg))(hw, 1U, 7U, & autoneg_reg);
#line 496
  autoneg_reg = (unsigned int )autoneg_reg & 32U;
  }
#line 497
  if ((unsigned int )autoneg_reg == 32U) {
#line 498
    goto ldv_50970;
  } else {

  }
#line 489
  time_out = time_out + 1U;
  ldv_50972: ;
#line 489
  if (time_out < max_time_out) {
#line 491
    goto ldv_50971;
  } else {

  }
  ldv_50970: ;
#line 502
  if (time_out == max_time_out) {
    {
#line 503
    status = -8;
#line 504
    descriptor.modname = "ixgbe";
#line 504
    descriptor.function = "ixgbe_setup_phy_link_generic";
#line 504
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 504
    descriptor.format = "ixgbe_setup_phy_link_generic: time out";
#line 504
    descriptor.lineno = 504U;
#line 504
    descriptor.flags = 0U;
#line 504
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 504
    if (tmp != 0L) {
      {
#line 504
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "ixgbe_setup_phy_link_generic: time out");
      }
    } else {

    }
  } else {

  }
#line 507
  return (status);
}
}
#line 515 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                       bool autoneg_wait_to_complete ) 
{ 


  {
#line 524
  hw->phy.autoneg_advertised = 0U;
#line 526
  if ((speed & 128U) != 0U) {
#line 527
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 128U;
  } else {

  }
#line 529
  if ((speed & 32U) != 0U) {
#line 530
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 32U;
  } else {

  }
#line 532
  if ((speed & 8U) != 0U) {
#line 533
    hw->phy.autoneg_advertised = hw->phy.autoneg_advertised | 8U;
  } else {

  }
  {
#line 536
  (*(hw->phy.ops.setup_link))(hw);
  }
#line 538
  return (0);
}
}
#line 549 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw , ixgbe_link_speed *speed ,
                                               bool *autoneg ) 
{ 
  s32 status ;
  u16 speed_ability ;

  {
  {
#line 553
  status = -8;
#line 556
  *speed = 0U;
#line 557
  *autoneg = 1;
#line 559
  status = (*(hw->phy.ops.read_reg))(hw, 4U, 1U, & speed_ability);
  }
#line 562
  if (status == 0) {
#line 563
    if ((int )speed_ability & 1) {
#line 564
      *speed = *speed | 128U;
    } else {

    }
#line 565
    if (((int )speed_ability & 16) != 0) {
#line 566
      *speed = *speed | 32U;
    } else {

    }
#line 567
    if (((int )speed_ability & 32) != 0) {
#line 568
      *speed = *speed | 8U;
    } else {

    }
  } else {

  }
#line 571
  return (status);
}
}
#line 581 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw , ixgbe_link_speed *speed , bool *link_up ) 
{ 
  s32 status ;
  u32 time_out ;
  u32 max_time_out ;
  u16 phy_link ;
  u16 phy_speed ;
  u16 phy_data ;

  {
#line 584
  status = 0;
#line 586
  max_time_out = 10U;
#line 587
  phy_link = 0U;
#line 588
  phy_speed = 0U;
#line 589
  phy_data = 0U;
#line 592
  *link_up = 0;
#line 593
  *speed = 128U;
#line 600
  time_out = 0U;
#line 600
  goto ldv_51000;
  ldv_50999: 
  {
#line 601
  __const_udelay(42950UL);
#line 602
  status = (*(hw->phy.ops.read_reg))(hw, 1U, 30U, & phy_data);
#line 606
  phy_link = (unsigned int )phy_data & 8U;
#line 608
  phy_speed = (unsigned int )phy_data & 16U;
  }
#line 610
  if ((unsigned int )phy_link == 8U) {
#line 611
    *link_up = 1;
#line 612
    if ((unsigned int )phy_speed == 16U) {
#line 614
      *speed = 32U;
    } else {

    }
#line 615
    goto ldv_50998;
  } else {

  }
#line 600
  time_out = time_out + 1U;
  ldv_51000: ;
#line 600
  if (time_out < max_time_out) {
#line 602
    goto ldv_50999;
  } else {

  }
  ldv_50998: ;
#line 619
  return (status);
}
}
#line 628 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 time_out ;
  u32 max_time_out ;
  u16 autoneg_reg ;
  bool autoneg ;
  ixgbe_link_speed speed ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  {
#line 630
  status = 0;
#line 632
  max_time_out = 10U;
#line 633
  autoneg_reg = 0U;
#line 634
  autoneg = 0;
#line 637
  ixgbe_get_copper_link_capabilities_generic(hw, & speed, & autoneg);
  }
#line 639
  if ((speed & 128U) != 0U) {
    {
#line 641
    (*(hw->phy.ops.read_reg))(hw, 32U, 7U, & autoneg_reg);
#line 645
    autoneg_reg = (unsigned int )autoneg_reg & 61439U;
    }
#line 646
    if ((hw->phy.autoneg_advertised & 128U) != 0U) {
#line 647
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 4096U);
    } else {

    }
    {
#line 649
    (*(hw->phy.ops.write_reg))(hw, 32U, 7U, (int )autoneg_reg);
    }
  } else {

  }
#line 654
  if ((speed & 32U) != 0U) {
    {
#line 656
    (*(hw->phy.ops.read_reg))(hw, 23U, 7U, & autoneg_reg);
#line 660
    autoneg_reg = (unsigned int )autoneg_reg & 49151U;
    }
#line 661
    if ((hw->phy.autoneg_advertised & 32U) != 0U) {
#line 662
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 16384U);
    } else {

    }
    {
#line 664
    (*(hw->phy.ops.write_reg))(hw, 23U, 7U, (int )autoneg_reg);
    }
  } else {

  }
#line 669
  if ((speed & 8U) != 0U) {
    {
#line 671
    (*(hw->phy.ops.read_reg))(hw, 16U, 7U, & autoneg_reg);
#line 675
    autoneg_reg = (unsigned int )autoneg_reg & 65151U;
    }
#line 677
    if ((hw->phy.autoneg_advertised & 8U) != 0U) {
#line 678
      autoneg_reg = (u16 )((unsigned int )autoneg_reg | 256U);
    } else {

    }
    {
#line 680
    (*(hw->phy.ops.write_reg))(hw, 16U, 7U, (int )autoneg_reg);
    }
  } else {

  }
  {
#line 686
  (*(hw->phy.ops.read_reg))(hw, 0U, 7U, & autoneg_reg);
#line 689
  autoneg_reg = (u16 )((unsigned int )autoneg_reg | 512U);
#line 691
  (*(hw->phy.ops.write_reg))(hw, 0U, 7U, (int )autoneg_reg);
#line 695
  time_out = 0U;
  }
#line 695
  goto ldv_51012;
  ldv_51011: 
  {
#line 696
  __const_udelay(42950UL);
#line 698
  status = (*(hw->phy.ops.read_reg))(hw, 1U, 7U, & autoneg_reg);
#line 702
  autoneg_reg = (unsigned int )autoneg_reg & 32U;
  }
#line 703
  if ((unsigned int )autoneg_reg == 32U) {
#line 704
    goto ldv_51010;
  } else {

  }
#line 695
  time_out = time_out + 1U;
  ldv_51012: ;
#line 695
  if (time_out < max_time_out) {
#line 697
    goto ldv_51011;
  } else {

  }
  ldv_51010: ;
#line 707
  if (time_out == max_time_out) {
    {
#line 708
    status = -8;
#line 709
    descriptor.modname = "ixgbe";
#line 709
    descriptor.function = "ixgbe_setup_phy_link_tnx";
#line 709
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 709
    descriptor.format = "ixgbe_setup_phy_link_tnx: time out";
#line 709
    descriptor.lineno = 709U;
#line 709
    descriptor.flags = 0U;
#line 709
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 709
    if (tmp != 0L) {
      {
#line 709
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "ixgbe_setup_phy_link_tnx: time out");
      }
    } else {

    }
  } else {

  }
#line 712
  return (status);
}
}
#line 720 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw , u16 *firmware_version ) 
{ 
  s32 status ;

  {
  {
#line 723
  status = 0;
#line 725
  status = (*(hw->phy.ops.read_reg))(hw, 11U, 30U, firmware_version);
  }
#line 729
  return (status);
}
}
#line 737 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw , u16 *firmware_version ) 
{ 
  s32 status ;

  {
  {
#line 740
  status = 0;
#line 742
  status = (*(hw->phy.ops.read_reg))(hw, 32U, 30U, firmware_version);
  }
#line 746
  return (status);
}
}
#line 753 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw ) 
{ 
  u16 phy_offset ;
  u16 control ;
  u16 eword ;
  u16 edata ;
  u16 block_crc ;
  bool end_data ;
  u16 list_offset ;
  u16 data_offset ;
  u16 phy_data ;
  s32 ret_val ;
  u32 i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  u16 tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___7 ;
  long tmp___8 ;

  {
  {
#line 756
  end_data = 0;
#line 758
  phy_data = 0U;
#line 759
  ret_val = 0;
#line 762
  (*(hw->phy.ops.read_reg))(hw, 0U, 4U, & phy_data);
#line 765
  (*(hw->phy.ops.write_reg))(hw, 0U, 4U, (int )((unsigned int )phy_data | 32768U));
#line 768
  i = 0U;
  }
#line 768
  goto ldv_51041;
  ldv_51040: 
  {
#line 769
  (*(hw->phy.ops.read_reg))(hw, 0U, 4U, & phy_data);
  }
#line 771
  if ((int )((short )phy_data) >= 0) {
#line 772
    goto ldv_51039;
  } else {

  }
  {
#line 773
  usleep_range(10000UL, 20000UL);
#line 768
  i = i + 1U;
  }
  ldv_51041: ;
#line 768
  if (i <= 99U) {
#line 770
    goto ldv_51040;
  } else {

  }
  ldv_51039: ;
#line 776
  if ((int )((short )phy_data) < 0) {
    {
#line 777
    descriptor.modname = "ixgbe";
#line 777
    descriptor.function = "ixgbe_reset_phy_nl";
#line 777
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 777
    descriptor.format = "PHY reset did not complete.\n";
#line 777
    descriptor.lineno = 777U;
#line 777
    descriptor.flags = 0U;
#line 777
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 777
    if (tmp != 0L) {
      {
#line 777
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "PHY reset did not complete.\n");
      }
    } else {

    }
#line 778
    ret_val = -3;
#line 779
    goto out;
  } else {

  }
  {
#line 783
  ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, & list_offset, & data_offset);
  }
#line 785
  if (ret_val != 0) {
#line 786
    goto out;
  } else {

  }
  {
#line 788
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & block_crc);
#line 789
  data_offset = (u16 )((int )data_offset + 1);
  }
#line 790
  goto ldv_51063;
  ldv_51062: 
  {
#line 794
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & eword);
  }
#line 795
  if (ret_val != 0) {
#line 796
    goto err_eeprom;
  } else {

  }
#line 797
  control = (int )eword >> 12;
#line 799
  edata = (unsigned int )eword & 4095U;
  {
#line 801
  if ((int )control == 0) {
#line 801
    goto case_0;
  } else {

  }
#line 806
  if ((int )control == 1) {
#line 806
    goto case_1;
  } else {

  }
#line 826
  if ((int )control == 15) {
#line 826
    goto case_15;
  } else {

  }
#line 840
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 802
  data_offset = (u16 )((int )data_offset + 1);
#line 803
  descriptor___0.modname = "ixgbe";
#line 803
  descriptor___0.function = "ixgbe_reset_phy_nl";
#line 803
  descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 803
  descriptor___0.format = "DELAY: %d MS\n";
#line 803
  descriptor___0.lineno = 803U;
#line 803
  descriptor___0.flags = 0U;
#line 803
  tmp___0 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
  }
#line 803
  if (tmp___0 != 0L) {
    {
#line 803
    __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "DELAY: %d MS\n", (int )edata);
    }
  } else {

  }
  {
#line 804
  usleep_range((unsigned long )((int )edata * 1000), (unsigned long )((int )edata * 2000));
  }
#line 805
  goto ldv_51048;
  case_1: /* CIL Label */ 
  {
#line 807
  descriptor___1.modname = "ixgbe";
#line 807
  descriptor___1.function = "ixgbe_reset_phy_nl";
#line 807
  descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 807
  descriptor___1.format = "DATA:\n";
#line 807
  descriptor___1.lineno = 807U;
#line 807
  descriptor___1.flags = 0U;
#line 807
  tmp___1 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
  }
#line 807
  if (tmp___1 != 0L) {
    {
#line 807
    __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "DATA:\n");
    }
  } else {

  }
  {
#line 808
  data_offset = (u16 )((int )data_offset + 1);
#line 809
  tmp___2 = data_offset;
#line 809
  data_offset = (u16 )((int )data_offset + 1);
#line 809
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )tmp___2, & phy_offset);
  }
#line 811
  if (ret_val != 0) {
#line 812
    goto err_eeprom;
  } else {

  }
#line 813
  i = 0U;
#line 813
  goto ldv_51053;
  ldv_51052: 
  {
#line 814
  ret_val = (*(hw->eeprom.ops.read))(hw, (int )data_offset, & eword);
  }
#line 816
  if (ret_val != 0) {
#line 817
    goto err_eeprom;
  } else {

  }
  {
#line 818
  (*(hw->phy.ops.write_reg))(hw, (u32 )phy_offset, 1U, (int )eword);
#line 820
  descriptor___2.modname = "ixgbe";
#line 820
  descriptor___2.function = "ixgbe_reset_phy_nl";
#line 820
  descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 820
  descriptor___2.format = "Wrote %4.4x to %4.4x\n";
#line 820
  descriptor___2.lineno = 821U;
#line 820
  descriptor___2.flags = 0U;
#line 820
  tmp___3 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
  }
#line 820
  if (tmp___3 != 0L) {
    {
#line 820
    __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Wrote %4.4x to %4.4x\n", (int )eword, (int )phy_offset);
    }
  } else {

  }
#line 822
  data_offset = (u16 )((int )data_offset + 1);
#line 823
  phy_offset = (u16 )((int )phy_offset + 1);
#line 813
  i = i + 1U;
  ldv_51053: ;
#line 813
  if (i < (u32 )edata) {
#line 815
    goto ldv_51052;
  } else {

  }

#line 825
  goto ldv_51048;
  case_15: /* CIL Label */ 
  {
#line 827
  data_offset = (u16 )((int )data_offset + 1);
#line 828
  descriptor___3.modname = "ixgbe";
#line 828
  descriptor___3.function = "ixgbe_reset_phy_nl";
#line 828
  descriptor___3.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 828
  descriptor___3.format = "CONTROL:\n";
#line 828
  descriptor___3.lineno = 828U;
#line 828
  descriptor___3.flags = 0U;
#line 828
  tmp___4 = __builtin_expect((long )descriptor___3.flags & 1L, 0L);
  }
#line 828
  if (tmp___4 != 0L) {
    {
#line 828
    __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "CONTROL:\n");
    }
  } else {

  }
#line 829
  if ((unsigned int )edata == 4095U) {
    {
#line 830
    descriptor___4.modname = "ixgbe";
#line 830
    descriptor___4.function = "ixgbe_reset_phy_nl";
#line 830
    descriptor___4.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 830
    descriptor___4.format = "EOL\n";
#line 830
    descriptor___4.lineno = 830U;
#line 830
    descriptor___4.flags = 0U;
#line 830
    tmp___5 = __builtin_expect((long )descriptor___4.flags & 1L, 0L);
    }
#line 830
    if (tmp___5 != 0L) {
      {
#line 830
      __dynamic_netdev_dbg(& descriptor___4, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EOL\n");
      }
    } else {

    }
#line 831
    end_data = 1;
  } else
#line 832
  if ((unsigned int )edata == 0U) {
    {
#line 833
    descriptor___5.modname = "ixgbe";
#line 833
    descriptor___5.function = "ixgbe_reset_phy_nl";
#line 833
    descriptor___5.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 833
    descriptor___5.format = "SOL\n";
#line 833
    descriptor___5.lineno = 833U;
#line 833
    descriptor___5.flags = 0U;
#line 833
    tmp___6 = __builtin_expect((long )descriptor___5.flags & 1L, 0L);
    }
#line 833
    if (tmp___6 != 0L) {
      {
#line 833
      __dynamic_netdev_dbg(& descriptor___5, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "SOL\n");
      }
    } else {

    }
  } else {
    {
#line 835
    descriptor___6.modname = "ixgbe";
#line 835
    descriptor___6.function = "ixgbe_reset_phy_nl";
#line 835
    descriptor___6.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 835
    descriptor___6.format = "Bad control value\n";
#line 835
    descriptor___6.lineno = 835U;
#line 835
    descriptor___6.flags = 0U;
#line 835
    tmp___7 = __builtin_expect((long )descriptor___6.flags & 1L, 0L);
    }
#line 835
    if (tmp___7 != 0L) {
      {
#line 835
      __dynamic_netdev_dbg(& descriptor___6, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Bad control value\n");
      }
    } else {

    }
#line 836
    ret_val = -3;
#line 837
    goto out;
  }
#line 839
  goto ldv_51048;
  switch_default: /* CIL Label */ 
  {
#line 841
  descriptor___7.modname = "ixgbe";
#line 841
  descriptor___7.function = "ixgbe_reset_phy_nl";
#line 841
  descriptor___7.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 841
  descriptor___7.format = "Bad control type\n";
#line 841
  descriptor___7.lineno = 841U;
#line 841
  descriptor___7.flags = 0U;
#line 841
  tmp___8 = __builtin_expect((long )descriptor___7.flags & 1L, 0L);
  }
#line 841
  if (tmp___8 != 0L) {
    {
#line 841
    __dynamic_netdev_dbg(& descriptor___7, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                         "Bad control type\n");
    }
  } else {

  }
#line 842
  ret_val = -3;
#line 843
  goto out;
  switch_break: /* CIL Label */ ;
  }
  ldv_51048: ;
  ldv_51063: ;
#line 790
  if (! end_data) {
#line 792
    goto ldv_51062;
  } else {

  }

  out: ;
#line 848
  return (ret_val);
  err_eeprom: 
  {
#line 851
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )data_offset);
  }
#line 852
  return (-3);
}
}
#line 861 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  enum ixgbe_media_type tmp ;

  {
  {
#line 863
  status = -20;
#line 865
  tmp = (*(hw->mac.ops.get_media_type))(hw);
  }
  {
#line 866
  if ((unsigned int )tmp == 1U) {
#line 866
    goto case_1;
  } else {

  }
#line 869
  if ((unsigned int )tmp == 3U) {
#line 869
    goto case_3;
  } else {

  }
#line 872
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 867
  status = ixgbe_identify_sfp_module_generic(hw);
  }
#line 868
  goto ldv_51070;
  case_3: /* CIL Label */ 
  {
#line 870
  status = ixgbe_identify_qsfp_module_generic(hw);
  }
#line 871
  goto ldv_51070;
  switch_default: /* CIL Label */ 
#line 873
  hw->phy.sfp_type = 65534;
#line 874
  status = -20;
#line 875
  goto ldv_51070;
  switch_break: /* CIL Label */ ;
  }
  ldv_51070: ;
#line 878
  return (status);
}
}
#line 887 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  s32 status ;
  u32 vendor_oui ;
  enum ixgbe_sfp_type stored_sfp_type ;
  u8 identifier ;
  u8 comp_codes_1g ;
  u8 comp_codes_10g ;
  u8 oui_bytes[3U] ;
  u8 cable_tech ;
  u8 cable_spec ;
  u16 enforce_sfp ;
  enum ixgbe_media_type tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 889
  adapter = (struct ixgbe_adapter *)hw->back;
#line 890
  status = -17;
#line 891
  vendor_oui = 0U;
#line 892
  stored_sfp_type = hw->phy.sfp_type;
#line 893
  identifier = 0U;
#line 894
  comp_codes_1g = 0U;
#line 895
  comp_codes_10g = 0U;
#line 896
  oui_bytes[0] = 0U;
#line 896
  oui_bytes[1] = 0U;
#line 896
  oui_bytes[2] = 0U;
#line 897
  cable_tech = 0U;
#line 898
  cable_spec = 0U;
#line 899
  enforce_sfp = 0U;
#line 901
  tmp = (*(hw->mac.ops.get_media_type))(hw);
  }
#line 901
  if ((unsigned int )tmp != 1U) {
#line 902
    hw->phy.sfp_type = 65534;
#line 903
    status = -20;
#line 904
    goto out;
  } else {

  }
  {
#line 907
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 0, & identifier);
  }
#line 911
  if (status != 0) {
#line 912
    goto err_read_i2c_eeprom;
  } else {

  }
  {
#line 915
  (*(hw->mac.ops.set_lan_id))(hw);
  }
#line 917
  if ((unsigned int )identifier != 3U) {
#line 918
    hw->phy.type = 20;
#line 919
    status = -19;
  } else {
    {
#line 921
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 6, & comp_codes_1g);
    }
#line 925
    if (status != 0) {
#line 926
      goto err_read_i2c_eeprom;
    } else {

    }
    {
#line 928
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 3, & comp_codes_10g);
    }
#line 932
    if (status != 0) {
#line 933
      goto err_read_i2c_eeprom;
    } else {

    }
    {
#line 934
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 8, & cable_tech);
    }
#line 938
    if (status != 0) {
#line 939
      goto err_read_i2c_eeprom;
    } else {

    }
#line 957
    if ((unsigned int )hw->mac.type == 1U) {
#line 958
      if (((int )cable_tech & 4) != 0) {
#line 959
        hw->phy.sfp_type = 0;
      } else
#line 960
      if (((int )comp_codes_10g & 16) != 0) {
#line 961
        hw->phy.sfp_type = 1;
      } else
#line 962
      if (((int )comp_codes_10g & 32) != 0) {
#line 963
        hw->phy.sfp_type = 2;
      } else {
#line 965
        hw->phy.sfp_type = 65535;
      }
    } else
#line 966
    if ((unsigned int )hw->mac.type == 2U) {
#line 967
      if (((int )cable_tech & 4) != 0) {
#line 968
        if ((unsigned int )hw->bus.lan_id == 0U) {
#line 969
          hw->phy.sfp_type = 3;
        } else {
#line 972
          hw->phy.sfp_type = 4;
        }
      } else
#line 974
      if (((int )cable_tech & 8) != 0) {
        {
#line 975
        (*(hw->phy.ops.read_i2c_eeprom))(hw, 60, & cable_spec);
        }
#line 978
        if (((int )cable_spec & 4) != 0) {
#line 980
          if ((unsigned int )hw->bus.lan_id == 0U) {
#line 981
            hw->phy.sfp_type = 7;
          } else {
#line 984
            hw->phy.sfp_type = 8;
          }
        } else {
#line 987
          hw->phy.sfp_type = 65535;
        }
      } else
#line 990
      if (((int )comp_codes_10g & 48) != 0) {
#line 993
        if ((unsigned int )hw->bus.lan_id == 0U) {
#line 994
          hw->phy.sfp_type = 5;
        } else {
#line 997
          hw->phy.sfp_type = 6;
        }
      } else
#line 999
      if (((int )comp_codes_1g & 8) != 0) {
#line 1000
        if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1001
          hw->phy.sfp_type = 9;
        } else {
#line 1004
          hw->phy.sfp_type = 10;
        }
      } else
#line 1006
      if ((int )comp_codes_1g & 1) {
#line 1007
        if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1008
          hw->phy.sfp_type = 11;
        } else {
#line 1011
          hw->phy.sfp_type = 12;
        }
      } else
#line 1013
      if (((int )comp_codes_1g & 2) != 0) {
#line 1014
        if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1015
          hw->phy.sfp_type = 13;
        } else {
#line 1018
          hw->phy.sfp_type = 14;
        }
      } else {
#line 1021
        hw->phy.sfp_type = 65535;
      }
    } else {

    }
#line 1025
    if ((unsigned int )hw->phy.sfp_type != (unsigned int )stored_sfp_type) {
#line 1026
      hw->phy.sfp_setup_needed = 1;
    } else {

    }
#line 1029
    hw->phy.multispeed_fiber = 0;
#line 1030
    if (((int )comp_codes_1g & 1 && ((int )comp_codes_10g & 16) != 0) || (((int )comp_codes_1g & 2) != 0 && ((int )comp_codes_10g & 32) != 0)) {
#line 1034
      hw->phy.multispeed_fiber = 1;
    } else {

    }
#line 1037
    if ((unsigned int )hw->phy.type != 7U) {
      {
#line 1038
      hw->phy.id = (u32 )identifier;
#line 1039
      status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 37, (u8 *)(& oui_bytes));
      }
#line 1043
      if (status != 0) {
#line 1044
        goto err_read_i2c_eeprom;
      } else {

      }
      {
#line 1046
      status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 38, (u8 *)(& oui_bytes) + 1UL);
      }
#line 1050
      if (status != 0) {
#line 1051
        goto err_read_i2c_eeprom;
      } else {

      }
      {
#line 1053
      status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 39, (u8 *)(& oui_bytes) + 2UL);
      }
#line 1057
      if (status != 0) {
#line 1058
        goto err_read_i2c_eeprom;
      } else {

      }
#line 1060
      vendor_oui = (u32 )((((int )oui_bytes[0] << 24) | ((int )oui_bytes[1] << 16)) | ((int )oui_bytes[2] << 8));
      {
#line 1066
      if (vendor_oui == 4224512U) {
#line 1066
        goto case_4224512;
      } else {

      }
#line 1071
      if (vendor_oui == 9463040U) {
#line 1071
        goto case_9463040;
      } else {

      }
#line 1077
      if (vendor_oui == 1534464U) {
#line 1077
        goto case_1534464;
      } else {

      }
#line 1080
      if (vendor_oui == 1777920U) {
#line 1080
        goto case_1777920;
      } else {

      }
#line 1083
      goto switch_default;
      case_4224512: /* CIL Label */ ;
#line 1067
      if (((int )cable_tech & 4) != 0) {
#line 1068
        hw->phy.type = 8;
      } else {

      }
#line 1070
      goto ldv_51090;
      case_9463040: /* CIL Label */ ;
#line 1072
      if (((int )cable_tech & 8) != 0) {
#line 1073
        hw->phy.type = 13;
      } else {
#line 1075
        hw->phy.type = 12;
      }
#line 1076
      goto ldv_51090;
      case_1534464: /* CIL Label */ 
#line 1078
      hw->phy.type = 11;
#line 1079
      goto ldv_51090;
      case_1777920: /* CIL Label */ 
#line 1081
      hw->phy.type = 15;
#line 1082
      goto ldv_51090;
      switch_default: /* CIL Label */ ;
#line 1084
      if (((int )cable_tech & 4) != 0) {
#line 1085
        hw->phy.type = 9;
      } else
#line 1087
      if (((int )cable_tech & 8) != 0) {
#line 1088
        hw->phy.type = 10;
      } else {
#line 1091
        hw->phy.type = 14;
      }
#line 1092
      goto ldv_51090;
      switch_break: /* CIL Label */ ;
      }
      ldv_51090: ;
    } else {

    }
#line 1097
    if (((int )cable_tech & 12) != 0) {
#line 1099
      status = 0;
#line 1100
      goto out;
    } else {

    }
#line 1104
    if ((unsigned int )comp_codes_10g == 0U && (((((unsigned int )hw->phy.sfp_type - 9U > 1U && (unsigned int )hw->phy.sfp_type != 13U) && (unsigned int )hw->phy.sfp_type != 14U) && (unsigned int )hw->phy.sfp_type != 11U) && (unsigned int )hw->phy.sfp_type != 12U)) {
#line 1111
      hw->phy.type = 20;
#line 1112
      status = -19;
#line 1113
      goto out;
    } else {

    }
#line 1117
    if ((unsigned int )hw->mac.type == 1U) {
#line 1118
      status = 0;
#line 1119
      goto out;
    } else {

    }
    {
#line 1122
    (*(hw->mac.ops.get_device_caps))(hw, & enforce_sfp);
    }
#line 1123
    if (((int )enforce_sfp & 1) == 0 && (((((unsigned int )hw->phy.sfp_type - 9U > 1U && (unsigned int )hw->phy.sfp_type != 13U) && (unsigned int )hw->phy.sfp_type != 14U) && (unsigned int )hw->phy.sfp_type != 11U) && (unsigned int )hw->phy.sfp_type != 12U)) {
#line 1131
      if ((unsigned int )hw->phy.type == 15U) {
#line 1132
        status = 0;
      } else
#line 1134
      if ((int )hw->allow_unsupported_sfp) {
#line 1135
        if ((int )adapter->msg_enable & 1) {
          {
#line 1135
          netdev_warn((struct net_device  const  *)adapter->netdev, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics.  Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter.  Intel Corporation is not responsible for any harm caused by using untested modules.");
          }
        } else {

        }
#line 1136
        status = 0;
      } else {
        {
#line 1138
        descriptor.modname = "ixgbe";
#line 1138
        descriptor.function = "ixgbe_identify_sfp_module_generic";
#line 1138
        descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1138
        descriptor.format = "SFP+ module not supported\n";
#line 1138
        descriptor.lineno = 1139U;
#line 1138
        descriptor.flags = 0U;
#line 1138
        tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
        }
#line 1138
        if (tmp___0 != 0L) {
          {
#line 1138
          __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                               "SFP+ module not supported\n");
          }
        } else {

        }
#line 1140
        hw->phy.type = 20;
#line 1142
        status = -19;
      }
    } else {
#line 1146
      status = 0;
    }
  }
  out: ;
#line 1151
  return (status);
  err_read_i2c_eeprom: 
#line 1154
  hw->phy.sfp_type = 65534;
#line 1155
  if ((unsigned int )hw->phy.type != 7U) {
#line 1156
    hw->phy.id = 0U;
#line 1157
    hw->phy.type = 0;
  } else {

  }
#line 1159
  return (-20);
}
}
#line 1168 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_adapter *adapter ;
  s32 status ;
  u32 vendor_oui ;
  enum ixgbe_sfp_type stored_sfp_type ;
  u8 identifier ;
  u8 comp_codes_1g ;
  u8 comp_codes_10g ;
  u8 oui_bytes[3U] ;
  u16 enforce_sfp ;
  u8 connector ;
  u8 cable_length ;
  u8 device_tech ;
  bool active_cable ;
  enum ixgbe_media_type tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 1170
  adapter = (struct ixgbe_adapter *)hw->back;
#line 1171
  status = -17;
#line 1172
  vendor_oui = 0U;
#line 1173
  stored_sfp_type = hw->phy.sfp_type;
#line 1174
  identifier = 0U;
#line 1175
  comp_codes_1g = 0U;
#line 1176
  comp_codes_10g = 0U;
#line 1177
  oui_bytes[0] = 0U;
#line 1177
  oui_bytes[1] = 0U;
#line 1177
  oui_bytes[2] = 0U;
#line 1178
  enforce_sfp = 0U;
#line 1179
  connector = 0U;
#line 1180
  cable_length = 0U;
#line 1181
  device_tech = 0U;
#line 1182
  active_cable = 0;
#line 1184
  tmp = (*(hw->mac.ops.get_media_type))(hw);
  }
#line 1184
  if ((unsigned int )tmp != 3U) {
#line 1185
    hw->phy.sfp_type = 65534;
#line 1186
    status = -20;
#line 1187
    goto out;
  } else {

  }
  {
#line 1190
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 0, & identifier);
  }
#line 1193
  if (status != 0) {
#line 1194
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1196
  if ((unsigned int )identifier != 13U) {
#line 1197
    hw->phy.type = 20;
#line 1198
    status = -19;
#line 1199
    goto out;
  } else {

  }
  {
#line 1202
  hw->phy.id = (u32 )identifier;
#line 1205
  (*(hw->mac.ops.set_lan_id))(hw);
#line 1207
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 131, & comp_codes_10g);
  }
#line 1210
  if (status != 0) {
#line 1211
    goto err_read_i2c_eeprom;
  } else {

  }
  {
#line 1213
  status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 134, & comp_codes_1g);
  }
#line 1216
  if (status != 0) {
#line 1217
    goto err_read_i2c_eeprom;
  } else {

  }
#line 1219
  if (((int )comp_codes_10g & 8) != 0) {
#line 1220
    hw->phy.type = 16;
#line 1221
    if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1222
      hw->phy.sfp_type = 3;
    } else {
#line 1224
      hw->phy.sfp_type = 4;
    }
  } else
#line 1225
  if (((int )comp_codes_10g & 48) != 0) {
#line 1227
    if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1228
      hw->phy.sfp_type = 5;
    } else {
#line 1230
      hw->phy.sfp_type = 6;
    }
  } else {
#line 1232
    if ((int )comp_codes_10g & 1) {
#line 1233
      active_cable = 1;
    } else {

    }
#line 1235
    if (! active_cable) {
      {
#line 1239
      (*(hw->phy.ops.read_i2c_eeprom))(hw, 130, & connector);
#line 1243
      (*(hw->phy.ops.read_i2c_eeprom))(hw, 146, & cable_length);
#line 1247
      (*(hw->phy.ops.read_i2c_eeprom))(hw, 147, & device_tech);
      }
#line 1251
      if (((unsigned int )connector == 35U && (unsigned int )cable_length != 0U) && (unsigned int )((int )device_tech >> 4) == 0U) {
#line 1256
        active_cable = 1;
      } else {

      }
    } else {

    }
#line 1259
    if ((int )active_cable) {
#line 1260
      hw->phy.type = 17;
#line 1261
      if ((unsigned int )hw->bus.lan_id == 0U) {
#line 1262
        hw->phy.sfp_type = 7;
      } else {
#line 1265
        hw->phy.sfp_type = 8;
      }
    } else {
#line 1269
      hw->phy.type = 20;
#line 1270
      status = -19;
#line 1271
      goto out;
    }
  }
#line 1275
  if ((unsigned int )hw->phy.sfp_type != (unsigned int )stored_sfp_type) {
#line 1276
    hw->phy.sfp_setup_needed = 1;
  } else {

  }
#line 1279
  hw->phy.multispeed_fiber = 0;
#line 1280
  if (((int )comp_codes_1g & 1 && ((int )comp_codes_10g & 16) != 0) || (((int )comp_codes_1g & 2) != 0 && ((int )comp_codes_10g & 32) != 0)) {
#line 1284
    hw->phy.multispeed_fiber = 1;
  } else {

  }
#line 1287
  if (((int )comp_codes_10g & 48) != 0) {
    {
#line 1289
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 165, (u8 *)(& oui_bytes));
    }
#line 1293
    if (status != 0) {
#line 1294
      goto err_read_i2c_eeprom;
    } else {

    }
    {
#line 1296
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 166, (u8 *)(& oui_bytes) + 1UL);
    }
#line 1300
    if (status != 0) {
#line 1301
      goto err_read_i2c_eeprom;
    } else {

    }
    {
#line 1303
    status = (*(hw->phy.ops.read_i2c_eeprom))(hw, 167, (u8 *)(& oui_bytes) + 2UL);
    }
#line 1307
    if (status != 0) {
#line 1308
      goto err_read_i2c_eeprom;
    } else {

    }
#line 1310
    vendor_oui = (u32 )((((int )oui_bytes[0] << 24) | ((int )oui_bytes[1] << 16)) | ((int )oui_bytes[2] << 8));
#line 1315
    if (vendor_oui == 1777920U) {
#line 1316
      hw->phy.type = 18;
    } else {
#line 1318
      hw->phy.type = 19;
    }
    {
#line 1320
    (*(hw->mac.ops.get_device_caps))(hw, & enforce_sfp);
    }
#line 1321
    if (((int )enforce_sfp & 1) == 0) {
#line 1323
      if ((unsigned int )hw->phy.type == 18U) {
#line 1324
        status = 0;
      } else
#line 1326
      if ((int )hw->allow_unsupported_sfp) {
#line 1327
        if ((int )adapter->msg_enable & 1) {
          {
#line 1327
          netdev_warn((struct net_device  const  *)adapter->netdev, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n");
          }
        } else {

        }
#line 1328
        status = 0;
      } else {
        {
#line 1330
        descriptor.modname = "ixgbe";
#line 1330
        descriptor.function = "ixgbe_identify_qsfp_module_generic";
#line 1330
        descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1330
        descriptor.format = "QSFP module not supported\n";
#line 1330
        descriptor.lineno = 1331U;
#line 1330
        descriptor.flags = 0U;
#line 1330
        tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
        }
#line 1330
        if (tmp___0 != 0L) {
          {
#line 1330
          __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                               "QSFP module not supported\n");
          }
        } else {

        }
#line 1332
        hw->phy.type = 20;
#line 1334
        status = -19;
      }
    } else {
#line 1338
      status = 0;
    }
  } else {

  }
  out: ;
#line 1343
  return (status);
  err_read_i2c_eeprom: 
#line 1346
  hw->phy.sfp_type = 65534;
#line 1347
  hw->phy.id = 0U;
#line 1348
  hw->phy.type = 0;
#line 1350
  return (-20);
}
}
#line 1362 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw , u16 *list_offset , u16 *data_offset ) 
{ 
  u16 sfp_id ;
  u16 sfp_type ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;
  s32 tmp___3 ;
  struct _ddebug descriptor___0 ;
  long tmp___4 ;

  {
#line 1367
  sfp_type = (u16 )hw->phy.sfp_type;
#line 1369
  if ((unsigned int )hw->phy.sfp_type == 65535U) {
#line 1370
    return (-19);
  } else {

  }
#line 1372
  if ((unsigned int )hw->phy.sfp_type == 65534U) {
#line 1373
    return (-20);
  } else {

  }
#line 1375
  if ((unsigned int )hw->device_id == 4321U && (unsigned int )hw->phy.sfp_type == 0U) {
#line 1377
    return (-19);
  } else {

  }
#line 1383
  if (((unsigned int )sfp_type == 7U || (unsigned int )sfp_type == 13U) || ((unsigned int )sfp_type == 9U || (unsigned int )sfp_type == 11U)) {
#line 1387
    sfp_type = 5U;
  } else
#line 1388
  if (((unsigned int )sfp_type == 8U || (unsigned int )sfp_type == 14U) || ((unsigned int )sfp_type == 10U || (unsigned int )sfp_type == 12U)) {
#line 1392
    sfp_type = 6U;
  } else {

  }
  {
#line 1395
  tmp = (*(hw->eeprom.ops.read))(hw, 43, list_offset);
  }
#line 1395
  if (tmp != 0) {
    {
#line 1396
    netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
               "eeprom read at %d failed\n", 43);
    }
#line 1398
    return (-21);
  } else {

  }
#line 1401
  if ((unsigned int )*list_offset - 1U > 65533U) {
#line 1402
    return (-21);
  } else {

  }
  {
#line 1405
  *list_offset = (u16 )((int )*list_offset + 1);
#line 1411
  tmp___0 = (*(hw->eeprom.ops.read))(hw, (int )*list_offset, & sfp_id);
  }
#line 1411
  if (tmp___0 != 0) {
#line 1412
    goto err_phy;
  } else {

  }
#line 1414
  goto ldv_51129;
  ldv_51128: ;
#line 1415
  if ((int )sfp_id == (int )sfp_type) {
    {
#line 1416
    *list_offset = (u16 )((int )*list_offset + 1);
#line 1417
    tmp___1 = (*(hw->eeprom.ops.read))(hw, (int )*list_offset, data_offset);
    }
#line 1417
    if (tmp___1 != 0) {
#line 1418
      goto err_phy;
    } else {

    }
#line 1419
    if ((unsigned int )*data_offset - 1U > 65533U) {
      {
#line 1420
      descriptor.modname = "ixgbe";
#line 1420
      descriptor.function = "ixgbe_get_sfp_init_sequence_offsets";
#line 1420
      descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1420
      descriptor.format = "SFP+ module not supported\n";
#line 1420
      descriptor.lineno = 1420U;
#line 1420
      descriptor.flags = 0U;
#line 1420
      tmp___2 = __builtin_expect((long )descriptor.flags & 1L, 0L);
      }
#line 1420
      if (tmp___2 != 0L) {
        {
#line 1420
        __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "SFP+ module not supported\n");
        }
      } else {

      }
#line 1421
      return (-19);
    } else {
#line 1423
      goto ldv_51127;
    }
  } else {
    {
#line 1426
    *list_offset = (unsigned int )*list_offset + 2U;
#line 1427
    tmp___3 = (*(hw->eeprom.ops.read))(hw, (int )*list_offset, & sfp_id);
    }
#line 1427
    if (tmp___3 != 0) {
#line 1428
      goto err_phy;
    } else {

    }
  }
  ldv_51129: ;
#line 1414
  if ((unsigned int )sfp_id != 65535U) {
#line 1416
    goto ldv_51128;
  } else {

  }
  ldv_51127: ;
#line 1432
  if ((unsigned int )sfp_id == 65535U) {
    {
#line 1433
    descriptor___0.modname = "ixgbe";
#line 1433
    descriptor___0.function = "ixgbe_get_sfp_init_sequence_offsets";
#line 1433
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1433
    descriptor___0.format = "No matching SFP+ module found\n";
#line 1433
    descriptor___0.lineno = 1433U;
#line 1433
    descriptor___0.flags = 0U;
#line 1433
    tmp___4 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 1433
    if (tmp___4 != 0L) {
      {
#line 1433
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "No matching SFP+ module found\n");
      }
    } else {

    }
#line 1434
    return (-19);
  } else {

  }
#line 1437
  return (0);
  err_phy: 
  {
#line 1440
  netdev_err((struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
             "eeprom read at offset %d failed\n", (int )*list_offset);
  }
#line 1441
  return (-3);
}
}
#line 1452 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 *eeprom_data ) 
{ 
  s32 tmp ;

  {
  {
#line 1455
  tmp = (*(hw->phy.ops.read_i2c_byte))(hw, (int )byte_offset, 160, eeprom_data);
  }
#line 1455
  return (tmp);
}
}
#line 1468 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 *sff8472_data ) 
{ 
  s32 tmp ;

  {
  {
#line 1471
  tmp = (*(hw->phy.ops.read_i2c_byte))(hw, (int )byte_offset, 162, sff8472_data);
  }
#line 1471
  return (tmp);
}
}
#line 1484 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 eeprom_data ) 
{ 
  s32 tmp ;

  {
  {
#line 1487
  tmp = (*(hw->phy.ops.write_i2c_byte))(hw, (int )byte_offset, 160, (int )eeprom_data);
  }
#line 1487
  return (tmp);
}
}
#line 1501 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                u8 *data ) 
{ 
  s32 status ;
  u32 max_retry ;
  u32 retry ;
  u16 swfw_mask ;
  bool nack ;
  u32 tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;

  {
  {
#line 1504
  status = 0;
#line 1505
  max_retry = 10U;
#line 1506
  retry = 0U;
#line 1507
  swfw_mask = 0U;
#line 1508
  nack = 1;
#line 1509
  *data = 0U;
#line 1511
  tmp = ixgbe_read_reg(hw, 8U);
  }
#line 1511
  if ((tmp & 4U) != 0U) {
#line 1512
    swfw_mask = 4U;
  } else {
#line 1514
    swfw_mask = 2U;
  }
  ldv_51163: 
  {
#line 1517
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, (int )swfw_mask);
  }
#line 1517
  if (tmp___0 != 0) {
#line 1518
    status = -16;
#line 1519
    goto read_byte_out;
  } else {

  }
  {
#line 1522
  ixgbe_i2c_start(hw);
#line 1525
  status = ixgbe_clock_out_i2c_byte(hw, (int )dev_addr);
  }
#line 1526
  if (status != 0) {
#line 1527
    goto fail;
  } else {

  }
  {
#line 1529
  status = ixgbe_get_i2c_ack(hw);
  }
#line 1530
  if (status != 0) {
#line 1531
    goto fail;
  } else {

  }
  {
#line 1533
  status = ixgbe_clock_out_i2c_byte(hw, (int )byte_offset);
  }
#line 1534
  if (status != 0) {
#line 1535
    goto fail;
  } else {

  }
  {
#line 1537
  status = ixgbe_get_i2c_ack(hw);
  }
#line 1538
  if (status != 0) {
#line 1539
    goto fail;
  } else {

  }
  {
#line 1541
  ixgbe_i2c_start(hw);
#line 1544
  status = ixgbe_clock_out_i2c_byte(hw, (int )((unsigned int )dev_addr | 1U));
  }
#line 1545
  if (status != 0) {
#line 1546
    goto fail;
  } else {

  }
  {
#line 1548
  status = ixgbe_get_i2c_ack(hw);
  }
#line 1549
  if (status != 0) {
#line 1550
    goto fail;
  } else {

  }
  {
#line 1552
  status = ixgbe_clock_in_i2c_byte(hw, data);
  }
#line 1553
  if (status != 0) {
#line 1554
    goto fail;
  } else {

  }
  {
#line 1556
  status = ixgbe_clock_out_i2c_bit(hw, (int )nack);
  }
#line 1557
  if (status != 0) {
#line 1558
    goto fail;
  } else {

  }
  {
#line 1560
  ixgbe_i2c_stop(hw);
  }
#line 1561
  goto ldv_51159;
  fail: 
  {
#line 1564
  ixgbe_i2c_bus_clear(hw);
#line 1565
  (*(hw->mac.ops.release_swfw_sync))(hw, (int )swfw_mask);
#line 1566
  msleep(100U);
#line 1567
  retry = retry + 1U;
  }
#line 1568
  if (retry < max_retry) {
    {
#line 1569
    descriptor.modname = "ixgbe";
#line 1569
    descriptor.function = "ixgbe_read_i2c_byte_generic";
#line 1569
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1569
    descriptor.format = "I2C byte read error - Retrying.\n";
#line 1569
    descriptor.lineno = 1569U;
#line 1569
    descriptor.flags = 0U;
#line 1569
    tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1569
    if (tmp___1 != 0L) {
      {
#line 1569
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte read error - Retrying.\n");
      }
    } else {

    }
  } else {
    {
#line 1571
    descriptor___0.modname = "ixgbe";
#line 1571
    descriptor___0.function = "ixgbe_read_i2c_byte_generic";
#line 1571
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1571
    descriptor___0.format = "I2C byte read error.\n";
#line 1571
    descriptor___0.lineno = 1571U;
#line 1571
    descriptor___0.flags = 0U;
#line 1571
    tmp___2 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 1571
    if (tmp___2 != 0L) {
      {
#line 1571
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte read error.\n");
      }
    } else {

    }
  }
#line 1573
  if (retry < max_retry) {
#line 1575
    goto ldv_51163;
  } else {

  }
  ldv_51159: 
  {
#line 1575
  (*(hw->mac.ops.release_swfw_sync))(hw, (int )swfw_mask);
  }
  read_byte_out: ;
#line 1578
  return (status);
}
}
#line 1590 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw , u8 byte_offset , u8 dev_addr ,
                                 u8 data ) 
{ 
  s32 status ;
  u32 max_retry ;
  u32 retry ;
  u16 swfw_mask ;
  u32 tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;

  {
  {
#line 1593
  status = 0;
#line 1594
  max_retry = 1U;
#line 1595
  retry = 0U;
#line 1596
  swfw_mask = 0U;
#line 1598
  tmp = ixgbe_read_reg(hw, 8U);
  }
#line 1598
  if ((tmp & 4U) != 0U) {
#line 1599
    swfw_mask = 4U;
  } else {
#line 1601
    swfw_mask = 2U;
  }
  {
#line 1603
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, (int )swfw_mask);
  }
#line 1603
  if (tmp___0 != 0) {
#line 1604
    status = -16;
#line 1605
    goto write_byte_out;
  } else {

  }
  ldv_51180: 
  {
#line 1609
  ixgbe_i2c_start(hw);
#line 1611
  status = ixgbe_clock_out_i2c_byte(hw, (int )dev_addr);
  }
#line 1612
  if (status != 0) {
#line 1613
    goto fail;
  } else {

  }
  {
#line 1615
  status = ixgbe_get_i2c_ack(hw);
  }
#line 1616
  if (status != 0) {
#line 1617
    goto fail;
  } else {

  }
  {
#line 1619
  status = ixgbe_clock_out_i2c_byte(hw, (int )byte_offset);
  }
#line 1620
  if (status != 0) {
#line 1621
    goto fail;
  } else {

  }
  {
#line 1623
  status = ixgbe_get_i2c_ack(hw);
  }
#line 1624
  if (status != 0) {
#line 1625
    goto fail;
  } else {

  }
  {
#line 1627
  status = ixgbe_clock_out_i2c_byte(hw, (int )data);
  }
#line 1628
  if (status != 0) {
#line 1629
    goto fail;
  } else {

  }
  {
#line 1631
  status = ixgbe_get_i2c_ack(hw);
  }
#line 1632
  if (status != 0) {
#line 1633
    goto fail;
  } else {

  }
  {
#line 1635
  ixgbe_i2c_stop(hw);
  }
#line 1636
  goto ldv_51176;
  fail: 
  {
#line 1639
  ixgbe_i2c_bus_clear(hw);
#line 1640
  retry = retry + 1U;
  }
#line 1641
  if (retry < max_retry) {
    {
#line 1642
    descriptor.modname = "ixgbe";
#line 1642
    descriptor.function = "ixgbe_write_i2c_byte_generic";
#line 1642
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1642
    descriptor.format = "I2C byte write error - Retrying.\n";
#line 1642
    descriptor.lineno = 1642U;
#line 1642
    descriptor.flags = 0U;
#line 1642
    tmp___1 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1642
    if (tmp___1 != 0L) {
      {
#line 1642
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte write error - Retrying.\n");
      }
    } else {

    }
  } else {
    {
#line 1644
    descriptor___0.modname = "ixgbe";
#line 1644
    descriptor___0.function = "ixgbe_write_i2c_byte_generic";
#line 1644
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1644
    descriptor___0.format = "I2C byte write error.\n";
#line 1644
    descriptor___0.lineno = 1644U;
#line 1644
    descriptor___0.flags = 0U;
#line 1644
    tmp___2 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 1644
    if (tmp___2 != 0L) {
      {
#line 1644
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C byte write error.\n");
      }
    } else {

    }
  }
#line 1645
  if (retry < max_retry) {
#line 1647
    goto ldv_51180;
  } else {

  }
  ldv_51176: 
  {
#line 1647
  (*(hw->mac.ops.release_swfw_sync))(hw, (int )swfw_mask);
  }
  write_byte_out: ;
#line 1650
  return (status);
}
}
#line 1659 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_start(struct ixgbe_hw *hw ) 
{ 
  u32 i2cctl ;
  u32 tmp ;

  {
  {
#line 1661
  tmp = ixgbe_read_reg(hw, 40U);
#line 1661
  i2cctl = tmp;
#line 1664
  ixgbe_set_i2c_data(hw, & i2cctl, 1);
#line 1665
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1668
  __const_udelay(21475UL);
#line 1670
  ixgbe_set_i2c_data(hw, & i2cctl, 0);
#line 1673
  __const_udelay(17180UL);
#line 1675
  ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1678
  __const_udelay(21475UL);
  }
#line 1680
  return;
}
}
#line 1688 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_stop(struct ixgbe_hw *hw ) 
{ 
  u32 i2cctl ;
  u32 tmp ;

  {
  {
#line 1690
  tmp = ixgbe_read_reg(hw, 40U);
#line 1690
  i2cctl = tmp;
#line 1693
  ixgbe_set_i2c_data(hw, & i2cctl, 0);
#line 1694
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1697
  __const_udelay(17180UL);
#line 1699
  ixgbe_set_i2c_data(hw, & i2cctl, 1);
#line 1702
  __const_udelay(21475UL);
  }
#line 1704
  return;
}
}
#line 1712 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw , u8 *data ) 
{ 
  s32 i ;
  bool bit ;

  {
#line 1715
  bit = 0;
#line 1717
  i = 7;
#line 1717
  goto ldv_51196;
  ldv_51195: 
  {
#line 1718
  ixgbe_clock_in_i2c_bit(hw, & bit);
#line 1719
  *data = (u8 )((int )((signed char )*data) | (int )((signed char )((int )bit << i)));
#line 1717
  i = i - 1;
  }
  ldv_51196: ;
#line 1717
  if (i >= 0) {
#line 1719
    goto ldv_51195;
  } else {

  }

#line 1722
  return (0);
}
}
#line 1732 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw , u8 data ) 
{ 
  s32 status ;
  s32 i ;
  u32 i2cctl ;
  bool bit ;

  {
#line 1734
  status = 0;
#line 1737
  bit = 0;
#line 1739
  i = 7;
#line 1739
  goto ldv_51208;
  ldv_51207: 
  {
#line 1740
  bit = (((int )data >> i) & 1) != 0;
#line 1741
  status = ixgbe_clock_out_i2c_bit(hw, (int )bit);
  }
#line 1743
  if (status != 0) {
#line 1744
    goto ldv_51206;
  } else {

  }
#line 1739
  i = i - 1;
  ldv_51208: ;
#line 1739
  if (i >= 0) {
#line 1741
    goto ldv_51207;
  } else {

  }
  ldv_51206: 
  {
#line 1748
  i2cctl = ixgbe_read_reg(hw, 40U);
#line 1749
  i2cctl = i2cctl | 8U;
#line 1750
  ixgbe_write_reg(hw, 40U, i2cctl);
#line 1751
  ixgbe_read_reg(hw, 8U);
  }
#line 1753
  return (status);
}
}
#line 1762 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 i ;
  u32 i2cctl ;
  u32 tmp ;
  u32 timeout ;
  bool ack ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 1764
  status = 0;
#line 1765
  i = 0U;
#line 1766
  tmp = ixgbe_read_reg(hw, 40U);
#line 1766
  i2cctl = tmp;
#line 1767
  timeout = 10U;
#line 1768
  ack = 1;
#line 1770
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1774
  __const_udelay(17180UL);
#line 1778
  i = 0U;
  }
#line 1778
  goto ldv_51219;
  ldv_51218: 
  {
#line 1779
  i2cctl = ixgbe_read_reg(hw, 40U);
#line 1780
  ack = ixgbe_get_i2c_data(& i2cctl);
#line 1782
  __const_udelay(4295UL);
  }
#line 1783
  if (! ack) {
#line 1784
    goto ldv_51217;
  } else {

  }
#line 1778
  i = i + 1U;
  ldv_51219: ;
#line 1778
  if (i < timeout) {
#line 1780
    goto ldv_51218;
  } else {

  }
  ldv_51217: ;
#line 1787
  if ((int )ack) {
    {
#line 1788
    descriptor.modname = "ixgbe";
#line 1788
    descriptor.function = "ixgbe_get_i2c_ack";
#line 1788
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1788
    descriptor.format = "I2C ack was not received.\n";
#line 1788
    descriptor.lineno = 1788U;
#line 1788
    descriptor.flags = 0U;
#line 1788
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1788
    if (tmp___0 != 0L) {
      {
#line 1788
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C ack was not received.\n");
      }
    } else {

    }
#line 1789
    status = -18;
  } else {

  }
  {
#line 1792
  ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1795
  __const_udelay(21475UL);
  }
#line 1797
  return (status);
}
}
#line 1807 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw , bool *data ) 
{ 
  u32 i2cctl ;
  u32 tmp ;

  {
  {
#line 1809
  tmp = ixgbe_read_reg(hw, 40U);
#line 1809
  i2cctl = tmp;
#line 1811
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1814
  __const_udelay(17180UL);
#line 1816
  i2cctl = ixgbe_read_reg(hw, 40U);
#line 1817
  *data = ixgbe_get_i2c_data(& i2cctl);
#line 1819
  ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1822
  __const_udelay(21475UL);
  }
#line 1824
  return (0);
}
}
#line 1834 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw , bool data ) 
{ 
  s32 status ;
  u32 i2cctl ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  {
#line 1837
  tmp = ixgbe_read_reg(hw, 40U);
#line 1837
  i2cctl = tmp;
#line 1839
  status = ixgbe_set_i2c_data(hw, & i2cctl, (int )data);
  }
#line 1840
  if (status == 0) {
    {
#line 1841
    ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1844
    __const_udelay(17180UL);
#line 1846
    ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1851
    __const_udelay(21475UL);
    }
  } else {
    {
#line 1853
    status = -18;
#line 1854
    descriptor.modname = "ixgbe";
#line 1854
    descriptor.function = "ixgbe_clock_out_i2c_bit";
#line 1854
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1854
    descriptor.format = "I2C data was not set to %X\n";
#line 1854
    descriptor.lineno = 1854U;
#line 1854
    descriptor.flags = 0U;
#line 1854
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1854
    if (tmp___0 != 0L) {
      {
#line 1854
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "I2C data was not set to %X\n", (int )data);
      }
    } else {

    }
  }
#line 1857
  return (status);
}
}
#line 1866 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw , u32 *i2cctl ) 
{ 
  u32 i ;
  u32 timeout ;
  u32 i2cctl_r ;

  {
#line 1868
  i = 0U;
#line 1869
  timeout = 500U;
#line 1870
  i2cctl_r = 0U;
#line 1872
  i = 0U;
#line 1872
  goto ldv_51244;
  ldv_51243: 
  {
#line 1873
  *i2cctl = *i2cctl | 2U;
#line 1874
  ixgbe_write_reg(hw, 40U, *i2cctl);
#line 1875
  ixgbe_read_reg(hw, 8U);
#line 1877
  __const_udelay(4295UL);
#line 1879
  i2cctl_r = ixgbe_read_reg(hw, 40U);
  }
#line 1880
  if ((int )i2cctl_r & 1) {
#line 1881
    goto ldv_51242;
  } else {

  }
#line 1872
  i = i + 1U;
  ldv_51244: ;
#line 1872
  if (i < timeout) {
#line 1874
    goto ldv_51243;
  } else {

  }
  ldv_51242: ;
#line 1879
  return;
}
}
#line 1892 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw , u32 *i2cctl ) 
{ 


  {
  {
#line 1895
  *i2cctl = *i2cctl & 4294967293U;
#line 1897
  ixgbe_write_reg(hw, 40U, *i2cctl);
#line 1898
  ixgbe_read_reg(hw, 8U);
#line 1901
  __const_udelay(4295UL);
  }
#line 1903
  return;
}
}
#line 1912 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw , u32 *i2cctl , bool data ) 
{ 
  s32 status ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;

  {
#line 1914
  status = 0;
#line 1916
  if ((int )data) {
#line 1917
    *i2cctl = *i2cctl | 8U;
  } else {
#line 1919
    *i2cctl = *i2cctl & 4294967287U;
  }
  {
#line 1921
  ixgbe_write_reg(hw, 40U, *i2cctl);
#line 1922
  ixgbe_read_reg(hw, 8U);
#line 1925
  __const_udelay(12885UL);
#line 1928
  *i2cctl = ixgbe_read_reg(hw, 40U);
#line 1929
  tmp___0 = ixgbe_get_i2c_data(i2cctl);
  }
#line 1929
  if ((int )data != (int )tmp___0) {
    {
#line 1930
    status = -18;
#line 1931
    descriptor.modname = "ixgbe";
#line 1931
    descriptor.function = "ixgbe_set_i2c_data";
#line 1931
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c";
#line 1931
    descriptor.format = "Error - I2C data was not set to %X.\n";
#line 1931
    descriptor.lineno = 1931U;
#line 1931
    descriptor.flags = 0U;
#line 1931
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 1931
    if (tmp != 0L) {
      {
#line 1931
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Error - I2C data was not set to %X.\n", (int )data);
      }
    } else {

    }
  } else {

  }
#line 1934
  return (status);
}
}
#line 1944 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static bool ixgbe_get_i2c_data(u32 *i2cctl ) 
{ 
  bool data ;

  {
#line 1948
  if ((*i2cctl & 4U) != 0U) {
#line 1949
    data = 1;
  } else {
#line 1951
    data = 0;
  }
#line 1953
  return (data);
}
}
#line 1963 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw ) 
{ 
  u32 i2cctl ;
  u32 tmp ;
  u32 i ;

  {
  {
#line 1965
  tmp = ixgbe_read_reg(hw, 40U);
#line 1965
  i2cctl = tmp;
#line 1968
  ixgbe_i2c_start(hw);
#line 1970
  ixgbe_set_i2c_data(hw, & i2cctl, 1);
#line 1972
  i = 0U;
  }
#line 1972
  goto ldv_51267;
  ldv_51266: 
  {
#line 1973
  ixgbe_raise_i2c_clk(hw, & i2cctl);
#line 1976
  __const_udelay(17180UL);
#line 1978
  ixgbe_lower_i2c_clk(hw, & i2cctl);
#line 1981
  __const_udelay(21475UL);
#line 1972
  i = i + 1U;
  }
  ldv_51267: ;
#line 1972
  if (i <= 8U) {
#line 1974
    goto ldv_51266;
  } else {

  }
  {
#line 1984
  ixgbe_i2c_start(hw);
#line 1987
  ixgbe_i2c_stop(hw);
  }
#line 1988
  return;
}
}
#line 1996 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c"
s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 phy_data ;

  {
#line 1998
  status = 0;
#line 1999
  phy_data = 0U;
#line 2001
  if ((unsigned int )hw->device_id != 5404U) {
#line 2002
    goto out;
  } else {

  }
  {
#line 2005
  (*(hw->phy.ops.read_reg))(hw, 36869U, 1U, & phy_data);
  }
#line 2008
  if (((int )phy_data & 8) == 0) {
#line 2009
    goto out;
  } else {

  }
#line 2011
  status = -26;
  out: ;
#line 2013
  return (status);
}
}
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 62
  __list_add(new, head, head->next);
  }
#line 63
  return;
}
}
#line 916 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
static void *ldv_dev_get_drvdata_6___0(struct device  const  *dev ) ;
#line 1407 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static void *pci_get_drvdata___0(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  {
#line 1409
  tmp = ldv_dev_get_drvdata_6___0((struct device  const  *)(& pdev->dev));
  }
#line 1409
  return (tmp);
}
}
#line 1598
extern int pci_enable_sriov(struct pci_dev * , int  ) ;
#line 1599
extern void pci_disable_sriov(struct pci_dev * ) ;
#line 1601
extern int pci_num_vf(struct pci_dev * ) ;
#line 1602
extern int pci_vfs_assigned(struct pci_dev * ) ;
#line 200 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
__inline static void eth_zero_addr(u8 *addr ) 
{ 


  {
  {
#line 202
  memset((void *)addr, 0, 6UL);
  }
#line 203
  return;
}
}
#line 266 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 269
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 272
  return (fold == 0U);
}
}
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h"
s32 ixgbe_read_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) ;
#line 110
s32 ixgbe_write_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) ;
#line 111
s32 ixgbe_check_for_msg(struct ixgbe_hw *hw , u16 mbx_id ) ;
#line 112
s32 ixgbe_check_for_ack(struct ixgbe_hw *hw , u16 mbx_id ) ;
#line 113
s32 ixgbe_check_for_rst(struct ixgbe_hw *hw , u16 mbx_id ) ;
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h"
__inline static void ixgbe_set_vmvir(struct ixgbe_adapter *adapter , u16 vid , u16 qos ,
                                     u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vmvir ;

  {
  {
#line 58
  hw = & adapter->hw;
#line 59
  vmvir = (u32 )(((int )vid | ((int )qos << 13)) | 1073741824);
#line 61
  ixgbe_write_reg(hw, (vf + 8192U) * 4U, vmvir);
  }
#line 62
  return;
}
}
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int num_vf_macvlans ;
  int i ;
  struct vf_macvlans *mv_list ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 49
  hw = & adapter->hw;
#line 53
  adapter->flags = adapter->flags | 8388608U;
#line 54
  if (((int )adapter->msg_enable & 2) != 0) {
    {
#line 54
    netdev_info((struct net_device  const  *)adapter->netdev, "SR-IOV enabled with %d VFs\n",
                adapter->num_vfs);
    }
  } else {

  }
#line 57
  adapter->flags = adapter->flags | 16384U;
#line 58
  if ((unsigned int )adapter->ring_feature[1].limit == 0U) {
#line 59
    adapter->ring_feature[1].limit = 1U;
  } else {

  }
  {
#line 60
  adapter->ring_feature[1].offset = (u16 )adapter->num_vfs;
#line 62
  num_vf_macvlans = (int )((hw->mac.num_rar_entries - adapter->num_vfs) - 16U);
#line 65
  tmp = kcalloc((size_t )num_vf_macvlans, 32UL, 208U);
#line 65
  mv_list = (struct vf_macvlans *)tmp;
#line 65
  adapter->mv_list = mv_list;
  }
#line 68
  if ((unsigned long )mv_list != (unsigned long )((struct vf_macvlans *)0)) {
    {
#line 70
    INIT_LIST_HEAD(& adapter->vf_mvs.l);
#line 71
    i = 0;
    }
#line 71
    goto ldv_51608;
    ldv_51607: 
    {
#line 72
    mv_list->vf = -1;
#line 73
    mv_list->free = 1;
#line 74
    mv_list->rar_entry = (int )((hw->mac.num_rar_entries - ((unsigned int )i + adapter->num_vfs)) - 1U);
#line 76
    list_add(& mv_list->l, & adapter->vf_mvs.l);
#line 77
    mv_list = mv_list + 1;
#line 71
    i = i + 1;
    }
    ldv_51608: ;
#line 71
    if (i < num_vf_macvlans) {
#line 73
      goto ldv_51607;
    } else {

    }

  } else {

  }
  {
#line 82
  ixgbe_write_reg(hw, 33312U, 1U);
#line 83
  adapter->flags2 = adapter->flags2 | 2048U;
#line 88
  tmp___0 = kcalloc((size_t )adapter->num_vfs, 88UL, 208U);
#line 88
  adapter->vfinfo = (struct vf_data_storage *)tmp___0;
  }
#line 91
  if ((unsigned long )adapter->vfinfo != (unsigned long )((struct vf_data_storage *)0)) {
#line 93
    if ((unsigned int )adapter->hw.mac.type == 2U && adapter->num_vfs <= 15U) {
#line 95
      adapter->dcb_cfg.num_tcs.pg_tcs = 8U;
#line 96
      adapter->dcb_cfg.num_tcs.pfc_tcs = 8U;
    } else
#line 97
    if (adapter->num_vfs <= 31U) {
#line 98
      adapter->dcb_cfg.num_tcs.pg_tcs = 4U;
#line 99
      adapter->dcb_cfg.num_tcs.pfc_tcs = 4U;
    } else {
#line 101
      adapter->dcb_cfg.num_tcs.pg_tcs = 1U;
#line 102
      adapter->dcb_cfg.num_tcs.pfc_tcs = 1U;
    }
#line 106
    adapter->ring_feature[2].limit = 1U;
#line 109
    adapter->flags2 = adapter->flags2 & 4294967292U;
#line 113
    i = 0;
#line 113
    goto ldv_51611;
    ldv_51610: 
#line 114
    (adapter->vfinfo + (unsigned long )i)->spoofchk_enabled = 1U;
#line 113
    i = i + 1;
    ldv_51611: ;
#line 113
    if ((unsigned int )i < adapter->num_vfs) {
#line 115
      goto ldv_51610;
    } else {

    }

#line 115
    return (0);
  } else {

  }
#line 118
  return (-12);
}
}
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_enable_sriov(struct ixgbe_adapter *adapter ) 
{ 
  int pre_existing_vfs ;
  int err ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  int tmp ;

  {
  {
#line 126
  pre_existing_vfs = 0;
#line 128
  pre_existing_vfs = pci_num_vf(adapter->pdev);
  }
#line 129
  if (pre_existing_vfs == 0 && adapter->num_vfs == 0U) {
#line 130
    return;
  } else {

  }
#line 138
  if (pre_existing_vfs != 0) {
    {
#line 139
    adapter->num_vfs = (unsigned int )pre_existing_vfs;
#line 140
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Virtual Functions already enabled for this device - Please reload all VF drivers to avoid spoofed packet errors\n");
    }
  } else {
    {
#line 151
    __min1 = adapter->num_vfs;
#line 151
    __min2 = 63U;
#line 151
    adapter->num_vfs = __min1 < __min2 ? __min1 : __min2;
#line 153
    err = pci_enable_sriov(adapter->pdev, (int )adapter->num_vfs);
    }
#line 154
    if (err != 0) {
#line 155
      if (((int )adapter->msg_enable & 2) != 0) {
        {
#line 155
        netdev_err((struct net_device  const  *)adapter->netdev, "Failed to enable PCI sriov: %d\n",
                   err);
        }
      } else {

      }
#line 156
      adapter->num_vfs = 0U;
#line 157
      return;
    } else {

    }
  }
  {
#line 161
  tmp = __ixgbe_enable_sriov(adapter);
  }
#line 161
  if (tmp == 0) {
#line 162
    return;
  } else {

  }
#line 167
  if (((int )adapter->msg_enable & 2) != 0) {
    {
#line 168
    netdev_err((struct net_device  const  *)adapter->netdev, "Unable to allocate memory for VF Data Storage - SRIOV disabled\n");
    }
  } else {

  }
  {
#line 169
  ixgbe_disable_sriov(adapter);
  }
#line 170
  return;
}
}
#line 173 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_disable_sriov(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 gpie ;
  u32 vmdctl ;
  int rss ;
  int tmp ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___0 ;
  int __min1___0 ;
  int __min2___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 175
  hw = & adapter->hw;
#line 181
  adapter->num_vfs = 0U;
#line 184
  kfree((void const   *)adapter->vfinfo);
#line 185
  adapter->vfinfo = (struct vf_data_storage *)0;
#line 188
  kfree((void const   *)adapter->mv_list);
#line 189
  adapter->mv_list = (struct vf_macvlans *)0;
  }
#line 192
  if ((adapter->flags & 8388608U) == 0U) {
#line 193
    return (0);
  } else {

  }
  {
#line 201
  tmp = pci_vfs_assigned(adapter->pdev);
  }
#line 201
  if (tmp != 0) {
    {
#line 202
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unloading driver while VFs are assigned - VFs will not be deallocated\n");
    }
#line 203
    return (-1);
  } else {

  }
  {
#line 206
  pci_disable_sriov(adapter->pdev);
#line 210
  ixgbe_write_reg(hw, 69712U, 0U);
#line 211
  gpie = ixgbe_read_reg(hw, 2200U);
#line 212
  gpie = gpie & 4294918143U;
#line 213
  ixgbe_write_reg(hw, 2200U, gpie);
#line 216
  vmdctl = ixgbe_read_reg(hw, 20912U);
#line 217
  vmdctl = vmdctl & 4294959231U;
#line 218
  ixgbe_write_reg(hw, 20912U, vmdctl);
#line 219
  ixgbe_read_reg(hw, 8U);
  }
#line 222
  if ((unsigned int )adapter->ring_feature[1].limit == 1U) {
    {
#line 223
    adapter->flags = adapter->flags & 4294950911U;
#line 224
    adapter->flags = adapter->flags & 4286578687U;
#line 225
    __min1 = 16;
#line 225
    tmp___0 = cpumask_weight(cpu_online_mask);
#line 225
    __min2 = (int )tmp___0;
#line 225
    rss = __min1 < __min2 ? __min1 : __min2;
    }
  } else {
    {
#line 227
    __min1___0 = 4;
#line 227
    tmp___1 = cpumask_weight(cpu_online_mask);
#line 227
    __min2___0 = (int )tmp___1;
#line 227
    rss = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
    }
  }
  {
#line 230
  adapter->ring_feature[1].offset = 0U;
#line 231
  adapter->ring_feature[2].limit = (u16 )rss;
#line 234
  msleep(100U);
  }
#line 235
  return (0);
}
}
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_pci_sriov_enable(struct pci_dev *dev , int num_vfs ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  int i ;
  int pre_existing_vfs ;
  int tmp___0 ;

  {
  {
#line 241
  tmp = pci_get_drvdata___0(dev);
#line 241
  adapter = (struct ixgbe_adapter *)tmp;
#line 242
  err = 0;
#line 244
  tmp___0 = pci_num_vf(dev);
#line 244
  pre_existing_vfs = tmp___0;
  }
#line 246
  if (pre_existing_vfs != 0 && pre_existing_vfs != num_vfs) {
    {
#line 247
    err = ixgbe_disable_sriov(adapter);
    }
  } else
#line 248
  if (pre_existing_vfs != 0 && pre_existing_vfs == num_vfs) {
#line 249
    goto out;
  } else {

  }
#line 251
  if (err != 0) {
#line 252
    goto err_out;
  } else {

  }
#line 260
  if (num_vfs > 63) {
#line 261
    err = -1;
#line 262
    goto err_out;
  } else {

  }
  {
#line 265
  adapter->num_vfs = (unsigned int )num_vfs;
#line 267
  err = __ixgbe_enable_sriov(adapter);
  }
#line 268
  if (err != 0) {
#line 269
    goto err_out;
  } else {

  }
#line 271
  i = 0;
#line 271
  goto ldv_51645;
  ldv_51644: 
  {
#line 272
  ixgbe_vf_configuration(dev, (unsigned int )(i | 268435456));
#line 271
  i = i + 1;
  }
  ldv_51645: ;
#line 271
  if ((unsigned int )i < adapter->num_vfs) {
#line 273
    goto ldv_51644;
  } else {

  }
  {
#line 274
  err = pci_enable_sriov(dev, num_vfs);
  }
#line 275
  if (err != 0) {
    {
#line 276
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Failed to enable PCI sriov: %d\n",
             err);
    }
#line 277
    goto err_out;
  } else {

  }
  {
#line 279
  ixgbe_sriov_reinit(adapter);
  }
  out: ;
#line 282
  return (num_vfs);
  err_out: ;
#line 285
  return (err);
#line 287
  return (0);
}
}
#line 290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_pci_sriov_disable(struct pci_dev *dev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  u32 current_flags ;

  {
  {
#line 292
  tmp = pci_get_drvdata___0(dev);
#line 292
  adapter = (struct ixgbe_adapter *)tmp;
#line 295
  current_flags = adapter->flags;
#line 298
  err = ixgbe_disable_sriov(adapter);
  }
#line 302
  if (err == 0 && current_flags != adapter->flags) {
    {
#line 303
    ixgbe_sriov_reinit(adapter);
    }
  } else {

  }
#line 306
  return (err);
}
}
#line 309 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_pci_sriov_configure(struct pci_dev *dev , int num_vfs ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 311
  if (num_vfs == 0) {
    {
#line 312
    tmp = ixgbe_pci_sriov_disable(dev);
    }
#line 312
    return (tmp);
  } else {
    {
#line 314
    tmp___0 = ixgbe_pci_sriov_enable(dev, num_vfs);
    }
#line 314
    return (tmp___0);
  }
}
}
#line 317 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_multicasts(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  int entries ;
  u16 *hash_list ;
  struct vf_data_storage *vfinfo ;
  struct ixgbe_hw *hw ;
  int i ;
  u32 vector_bit ;
  u32 vector_reg ;
  u32 mta_reg ;
  int _min1 ;
  int _min2 ;

  {
#line 320
  entries = (int )((*msgbuf & 16711680U) >> 16);
#line 322
  hash_list = (u16 *)msgbuf + 1U;
#line 323
  vfinfo = adapter->vfinfo + (unsigned long )vf;
#line 324
  hw = & adapter->hw;
#line 331
  _min1 = entries;
#line 331
  _min2 = 30;
#line 331
  entries = _min1 < _min2 ? _min1 : _min2;
#line 338
  vfinfo->num_vf_mc_hashes = (u16 )entries;
#line 344
  i = 0;
#line 344
  goto ldv_51674;
  ldv_51673: 
#line 345
  vfinfo->vf_mc_hashes[i] = *(hash_list + (unsigned long )i);
#line 344
  i = i + 1;
  ldv_51674: ;
#line 344
  if (i < entries) {
#line 346
    goto ldv_51673;
  } else {

  }
#line 348
  i = 0;
#line 348
  goto ldv_51677;
  ldv_51676: 
  {
#line 349
  vector_reg = (u32 )((int )vfinfo->vf_mc_hashes[i] >> 5) & 127U;
#line 350
  vector_bit = (u32 )vfinfo->vf_mc_hashes[i] & 31U;
#line 351
  mta_reg = ixgbe_read_reg(hw, (vector_reg + 5248U) * 4U);
#line 352
  mta_reg = mta_reg | (u32 )(1 << (int )vector_bit);
#line 353
  ixgbe_write_reg(hw, (vector_reg + 5248U) * 4U, mta_reg);
#line 348
  i = i + 1;
  }
  ldv_51677: ;
#line 348
  if (i < (int )vfinfo->num_vf_mc_hashes) {
#line 350
    goto ldv_51676;
  } else {

  }

#line 356
  return (0);
}
}
#line 359 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_restore_vf_macvlans(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct list_head *pos ;
  struct vf_macvlans *entry ;
  struct list_head  const  *__mptr ;

  {
#line 361
  hw = & adapter->hw;
#line 365
  pos = adapter->vf_mvs.l.next;
#line 365
  goto ldv_51688;
  ldv_51687: 
#line 366
  __mptr = (struct list_head  const  *)pos;
#line 366
  entry = (struct vf_macvlans *)__mptr;
#line 367
  if (! entry->free) {
    {
#line 368
    (*(hw->mac.ops.set_rar))(hw, (u32 )entry->rar_entry, (u8 *)(& entry->vf_macvlan),
                             (u32 )entry->vf, 2147483648U);
    }
  } else {

  }
#line 365
  pos = pos->next;
  ldv_51688: ;
#line 365
  if ((unsigned long )pos != (unsigned long )(& adapter->vf_mvs.l)) {
#line 367
    goto ldv_51687;
  } else {

  }

#line 372
  return;
}
}
#line 374 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct vf_data_storage *vfinfo ;
  int i ;
  int j ;
  u32 vector_bit ;
  u32 vector_reg ;
  u32 mta_reg ;

  {
#line 376
  hw = & adapter->hw;
#line 383
  i = 0;
#line 383
  goto ldv_51704;
  ldv_51703: 
#line 384
  vfinfo = adapter->vfinfo + (unsigned long )i;
#line 385
  j = 0;
#line 385
  goto ldv_51701;
  ldv_51700: 
  {
#line 386
  hw->addr_ctrl.mta_in_use = hw->addr_ctrl.mta_in_use + 1U;
#line 387
  vector_reg = (u32 )((int )vfinfo->vf_mc_hashes[j] >> 5) & 127U;
#line 388
  vector_bit = (u32 )vfinfo->vf_mc_hashes[j] & 31U;
#line 389
  mta_reg = ixgbe_read_reg(hw, (vector_reg + 5248U) * 4U);
#line 390
  mta_reg = mta_reg | (u32 )(1 << (int )vector_bit);
#line 391
  ixgbe_write_reg(hw, (vector_reg + 5248U) * 4U, mta_reg);
#line 385
  j = j + 1;
  }
  ldv_51701: ;
#line 385
  if (j < (int )vfinfo->num_vf_mc_hashes) {
#line 387
    goto ldv_51700;
  } else {

  }
#line 383
  i = i + 1;
  ldv_51704: ;
#line 383
  if ((unsigned int )i < adapter->num_vfs) {
#line 385
    goto ldv_51703;
  } else {

  }
  {
#line 396
  ixgbe_restore_vf_macvlans(adapter);
  }
#line 397
  return;
}
}
#line 399 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter , int add , int vid , u32 vf ) 
{ 
  s32 tmp ;

  {
#line 403
  if ((vid | add) == 0) {
#line 404
    return (0);
  } else {

  }
  {
#line 406
  tmp = (*(adapter->hw.mac.ops.set_vfta))(& adapter->hw, (u32 )vid, vf, add != 0);
  }
#line 406
  return (tmp);
}
}
#line 409 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  int max_frame ;
  u32 max_frs ;
  struct net_device *dev ;
  int pf_max_frame ;
  u32 reg_offset ;
  u32 vf_shift ;
  u32 vfre ;
  s32 err ;

  {
#line 411
  hw = & adapter->hw;
#line 412
  max_frame = (int )*(msgbuf + 1UL);
#line 422
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 423
    dev = adapter->netdev;
#line 424
    pf_max_frame = (int )(dev->mtu + 14U);
#line 426
    err = 0;
    {
#line 435
    if ((adapter->vfinfo + (unsigned long )vf)->vf_api == 2U) {
#line 435
      goto case_2;
    } else {

    }
#line 443
    goto switch_default;
    case_2: /* CIL Label */ ;
#line 441
    if (pf_max_frame > 1514) {
#line 442
      goto ldv_51727;
    } else {

    }
    switch_default: /* CIL Label */ ;
#line 449
    if (pf_max_frame > 1514 || max_frame > 1518) {
#line 451
      err = -22;
    } else {

    }
#line 452
    goto ldv_51727;
    switch_break: /* CIL Label */ ;
    }
    ldv_51727: 
    {
#line 456
    vf_shift = vf & 31U;
#line 457
    reg_offset = vf / 32U;
#line 460
    vfre = ixgbe_read_reg(hw, (reg_offset + 5240U) * 4U);
    }
#line 461
    if (err != 0) {
#line 462
      vfre = vfre & (u32 )(~ (1 << (int )vf_shift));
    } else {
#line 464
      vfre = vfre | (u32 )(1 << (int )vf_shift);
    }
    {
#line 465
    ixgbe_write_reg(hw, (reg_offset + 5240U) * 4U, vfre);
    }
#line 467
    if (err != 0) {
#line 468
      if ((int )adapter->msg_enable & 1) {
        {
#line 468
        netdev_err((struct net_device  const  *)adapter->netdev, "VF max_frame %d out of range\n",
                   max_frame);
        }
      } else {

      }
#line 469
      return (err);
    } else {

    }
  } else {

  }
#line 474
  if (max_frame > 9728) {
#line 475
    if ((int )adapter->msg_enable & 1) {
      {
#line 475
      netdev_err((struct net_device  const  *)adapter->netdev, "VF max_frame %d out of range\n",
                 max_frame);
      }
    } else {

    }
#line 476
    return (-22);
  } else {

  }
  {
#line 480
  max_frs = ixgbe_read_reg(hw, 17000U);
#line 481
  max_frs = max_frs & 4294901760U;
#line 482
  max_frs = max_frs >> 16;
  }
#line 484
  if (max_frs < (u32 )max_frame) {
    {
#line 485
    max_frs = (u32 )(max_frame << 16);
#line 486
    ixgbe_write_reg(hw, 17000U, max_frs);
    }
  } else {

  }
#line 489
  if (((int )adapter->msg_enable & 8192) != 0) {
    {
#line 489
    netdev_info((struct net_device  const  *)adapter->netdev, "VF requests change max MTU to %d\n",
                max_frame);
    }
  } else {

  }
#line 491
  return (0);
}
}
#line 494 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_set_vmolr(struct ixgbe_hw *hw , u32 vf , bool aupe ) 
{ 
  u32 vmolr ;
  u32 tmp ;

  {
  {
#line 496
  tmp = ixgbe_read_reg(hw, (vf + 15360U) * 4U);
#line 496
  vmolr = tmp;
#line 497
  vmolr = vmolr | 167772160U;
  }
#line 499
  if ((int )aupe) {
#line 500
    vmolr = vmolr | 16777216U;
  } else {
#line 502
    vmolr = vmolr & 4278190079U;
  }
  {
#line 503
  ixgbe_write_reg(hw, (vf + 15360U) * 4U, vmolr);
  }
#line 504
  return;
}
}
#line 506 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_clear_vmvir(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;

  {
  {
#line 508
  hw = & adapter->hw;
#line 510
  ixgbe_write_reg(hw, (vf + 8192U) * 4U, 0U);
  }
#line 511
  return;
}
}
#line 512 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
__inline static void ixgbe_vf_reset_event(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  struct vf_data_storage *vfinfo ;
  int rar_entry ;
  u8 num_tcs ;
  int tmp ;

  {
  {
#line 514
  hw = & adapter->hw;
#line 515
  vfinfo = adapter->vfinfo + (unsigned long )vf;
#line 516
  rar_entry = (int )((hw->mac.num_rar_entries - vf) - 1U);
#line 517
  tmp = netdev_get_num_tc(adapter->netdev);
#line 517
  num_tcs = (u8 )tmp;
#line 520
  ixgbe_set_vf_vlan(adapter, 1, (int )vfinfo->pf_vlan, vf);
#line 523
  ixgbe_set_vmolr(hw, vf, (unsigned int )vfinfo->pf_vlan == 0U);
  }
#line 526
  if ((unsigned int )vfinfo->pf_vlan == 0U && ((unsigned int )vfinfo->pf_qos == 0U && (unsigned int )num_tcs == 0U)) {
    {
#line 527
    ixgbe_clear_vmvir(adapter, vf);
    }
  } else {
#line 529
    if ((unsigned int )vfinfo->pf_qos != 0U || (unsigned int )num_tcs == 0U) {
      {
#line 530
      ixgbe_set_vmvir(adapter, (int )vfinfo->pf_vlan, (int )vfinfo->pf_qos, vf);
      }
    } else {
      {
#line 533
      ixgbe_set_vmvir(adapter, (int )vfinfo->pf_vlan, (int )adapter->default_up, vf);
      }
    }
#line 536
    if ((unsigned int )vfinfo->spoofchk_enabled != 0U) {
      {
#line 537
      (*(hw->mac.ops.set_vlan_anti_spoofing))(hw, 1, (int )vf);
      }
    } else {

    }
  }
  {
#line 541
  (adapter->vfinfo + (unsigned long )vf)->num_vf_mc_hashes = 0U;
#line 544
  ixgbe_set_rx_mode(adapter->netdev);
#line 546
  (*(hw->mac.ops.clear_rar))(hw, (u32 )rar_entry);
#line 549
  (adapter->vfinfo + (unsigned long )vf)->vf_api = 0U;
  }
#line 550
  return;
}
}
#line 552 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_mac(struct ixgbe_adapter *adapter , int vf , unsigned char *mac_addr ) 
{ 
  struct ixgbe_hw *hw ;
  int rar_entry ;

  {
  {
#line 555
  hw = & adapter->hw;
#line 556
  rar_entry = (int )(hw->mac.num_rar_entries + (u32 )(~ vf));
#line 558
  memcpy((void *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses), (void const   *)mac_addr,
         6UL);
#line 559
  (*(hw->mac.ops.set_rar))(hw, (u32 )rar_entry, mac_addr, (u32 )vf, 2147483648U);
  }
#line 561
  return (0);
}
}
#line 564 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_macvlan(struct ixgbe_adapter *adapter , int vf , int index ,
                                unsigned char *mac_addr ) 
{ 
  struct ixgbe_hw *hw ;
  struct list_head *pos ;
  struct vf_macvlans *entry ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 567
  hw = & adapter->hw;
#line 571
  if (index <= 1) {
#line 572
    pos = adapter->vf_mvs.l.next;
#line 572
    goto ldv_51767;
    ldv_51766: 
#line 573
    __mptr = (struct list_head  const  *)pos;
#line 573
    entry = (struct vf_macvlans *)__mptr;
#line 574
    if (entry->vf == vf) {
      {
#line 575
      entry->vf = -1;
#line 576
      entry->free = 1;
#line 577
      entry->is_macvlan = 0;
#line 578
      (*(hw->mac.ops.clear_rar))(hw, (u32 )entry->rar_entry);
      }
    } else {

    }
#line 572
    pos = pos->next;
    ldv_51767: ;
#line 572
    if ((unsigned long )pos != (unsigned long )(& adapter->vf_mvs.l)) {
#line 574
      goto ldv_51766;
    } else {

    }

  } else {

  }
#line 587
  if (index == 0) {
#line 588
    return (0);
  } else {

  }
#line 590
  entry = (struct vf_macvlans *)0;
#line 592
  pos = adapter->vf_mvs.l.next;
#line 592
  goto ldv_51773;
  ldv_51772: 
#line 593
  __mptr___0 = (struct list_head  const  *)pos;
#line 593
  entry = (struct vf_macvlans *)__mptr___0;
#line 594
  if ((int )entry->free) {
#line 595
    goto ldv_51771;
  } else {

  }
#line 592
  pos = pos->next;
  ldv_51773: ;
#line 592
  if ((unsigned long )pos != (unsigned long )(& adapter->vf_mvs.l)) {
#line 594
    goto ldv_51772;
  } else {

  }
  ldv_51771: ;
#line 606
  if ((unsigned long )entry == (unsigned long )((struct vf_macvlans *)0) || ! entry->free) {
#line 607
    return (-28);
  } else {

  }
  {
#line 609
  entry->free = 0;
#line 610
  entry->is_macvlan = 1;
#line 611
  entry->vf = vf;
#line 612
  memcpy((void *)(& entry->vf_macvlan), (void const   *)mac_addr, 6UL);
#line 614
  (*(hw->mac.ops.set_rar))(hw, (u32 )entry->rar_entry, mac_addr, (u32 )vf, 2147483648U);
  }
#line 616
  return (0);
}
}
#line 619 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_vf_configuration(struct pci_dev *pdev , unsigned int event_mask ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  unsigned int vfn ;
  bool enable ;

  {
  {
#line 621
  tmp = pci_get_drvdata___0(pdev);
#line 621
  adapter = (struct ixgbe_adapter *)tmp;
#line 622
  vfn = event_mask & 63U;
#line 624
  enable = (event_mask & 268435456U) != 0U;
  }
#line 626
  if ((int )enable) {
    {
#line 627
    eth_zero_addr((u8 *)(& (adapter->vfinfo + (unsigned long )vfn)->vf_mac_addresses));
    }
  } else {

  }
#line 629
  return (0);
}
}
#line 632 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  struct ixgbe_ring_feature *vmdq ;
  struct ixgbe_hw *hw ;
  unsigned char *vf_mac ;
  u32 reg ;
  u32 reg_offset ;
  u32 vf_shift ;
  u32 msgbuf[4U] ;
  u8 *addr ;
  u32 q_per_pool ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  struct net_device *dev ;
  int pf_max_frame ;
  bool tmp___1 ;
  int tmp___2 ;

  {
#line 634
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 635
  hw = & adapter->hw;
#line 636
  vf_mac = (unsigned char *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses);
#line 638
  msgbuf[0] = 0U;
#line 638
  msgbuf[1] = 0U;
#line 638
  msgbuf[2] = 0U;
#line 638
  msgbuf[3] = 0U;
#line 639
  addr = (u8 *)(& msgbuf) + 1U;
#line 640
  q_per_pool = (u32 )(- ((int )vmdq->mask) & (int )vmdq->mask);
#line 643
  if (((int )adapter->msg_enable & 2) != 0) {
    {
#line 643
    netdev_info((struct net_device  const  *)adapter->netdev, "VF Reset msg received from vf %d\n",
                vf);
    }
  } else {

  }
  {
#line 646
  ixgbe_vf_reset_event(adapter, vf);
#line 649
  tmp = is_zero_ether_addr((u8 const   *)vf_mac);
  }
#line 649
  if (tmp) {
#line 649
    tmp___0 = 0;
  } else {
#line 649
    tmp___0 = 1;
  }
#line 649
  if (tmp___0) {
    {
#line 650
    ixgbe_set_vf_mac(adapter, (int )vf, vf_mac);
    }
  } else {

  }
  {
#line 652
  vf_shift = vf & 31U;
#line 653
  reg_offset = vf / 32U;
#line 656
  reg = ixgbe_read_reg(hw, (reg_offset + 8260U) * 4U);
#line 657
  reg = reg | (u32 )(1 << (int )vf_shift);
#line 658
  ixgbe_write_reg(hw, (reg_offset + 8260U) * 4U, reg);
#line 661
  i = (int )(vf * q_per_pool);
  }
#line 661
  goto ldv_51796;
  ldv_51795: 
  {
#line 663
  ixgbe_read_reg(hw, 8U);
#line 666
  reg = 65537U;
#line 667
  reg = reg | (u32 )(i << 8);
#line 668
  ixgbe_write_reg(hw, 12036U, reg);
#line 661
  i = i + 1;
  }
  ldv_51796: ;
#line 661
  if ((u32 )i < (vf + 1U) * q_per_pool) {
#line 663
    goto ldv_51795;
  } else {

  }
  {
#line 672
  reg = ixgbe_read_reg(hw, (reg_offset + 5240U) * 4U);
#line 673
  reg = reg | (u32 )(1 << (int )vf_shift);
  }
#line 678
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 679
    dev = adapter->netdev;
#line 680
    pf_max_frame = (int )(dev->mtu + 14U);
#line 688
    if (pf_max_frame > 1514) {
#line 689
      reg = reg & (u32 )(~ (1 << (int )vf_shift));
    } else {

    }
  } else {

  }
  {
#line 691
  ixgbe_write_reg(hw, (reg_offset + 5240U) * 4U, reg);
#line 694
  (adapter->vfinfo + (unsigned long )vf)->clear_to_send = 1;
#line 697
  reg = ixgbe_read_reg(hw, (reg_offset + 8676U) * 4U);
#line 698
  reg = reg | (u32 )(1 << (int )vf_shift);
#line 699
  ixgbe_write_reg(hw, (reg_offset + 8676U) * 4U, reg);
#line 705
  i = 0;
  }
#line 705
  goto ldv_51801;
  ldv_51800: 
  {
#line 706
  ixgbe_write_reg(hw, (q_per_pool * vf + (u32 )i) * 64U + 24636U, 0U);
#line 707
  ixgbe_write_reg(hw, (q_per_pool * vf + (u32 )i) * 64U + 24632U, 0U);
#line 705
  i = i + 1;
  }
  ldv_51801: ;
#line 705
  if ((u32 )i < q_per_pool) {
#line 707
    goto ldv_51800;
  } else {

  }
  {
#line 711
  msgbuf[0] = 1U;
#line 712
  tmp___1 = is_zero_ether_addr((u8 const   *)vf_mac);
  }
#line 712
  if (tmp___1) {
#line 712
    tmp___2 = 0;
  } else {
#line 712
    tmp___2 = 1;
  }
#line 712
  if (tmp___2) {
    {
#line 713
    msgbuf[0] = msgbuf[0] | 2147483648U;
#line 714
    memcpy((void *)addr, (void const   *)vf_mac, 6UL);
    }
  } else {
    {
#line 716
    msgbuf[0] = msgbuf[0] | 1073741824U;
#line 717
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VF %d has no MAC address assigned, you may have to assign one manually\n",
             vf);
    }
  }
  {
#line 726
  msgbuf[3] = (u32 )hw->mac.mc_filter_type;
#line 727
  ixgbe_write_mbx(hw, (u32 *)(& msgbuf), 4, (int )((u16 )vf));
  }
#line 729
  return (0);
}
}
#line 732 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_mac_addr(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  u8 *new_mac ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 735
  new_mac = (u8 *)msgbuf + 1U;
#line 737
  tmp = is_valid_ether_addr((u8 const   *)new_mac);
  }
#line 737
  if (tmp) {
#line 737
    tmp___0 = 0;
  } else {
#line 737
    tmp___0 = 1;
  }
#line 737
  if (tmp___0) {
#line 738
    if ((int )adapter->msg_enable & 1) {
      {
#line 738
      netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d attempted to set invalid mac\n",
                  vf);
      }
    } else {

    }
#line 739
    return (-1);
  } else {

  }
#line 742
  if ((int )(adapter->vfinfo + (unsigned long )vf)->pf_set_mac) {
    {
#line 742
    tmp___1 = ether_addr_equal((u8 const   *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses),
                               (u8 const   *)new_mac);
    }
#line 742
    if (tmp___1) {
#line 742
      tmp___2 = 0;
    } else {
#line 742
      tmp___2 = 1;
    }
#line 742
    if (tmp___2) {
#line 744
      if ((int )adapter->msg_enable & 1) {
        {
#line 747
        netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d attempted to override administratively set MAC address\nReload the VF driver to resume operations\n",
                    vf);
        }
      } else {

      }
#line 748
      return (-1);
    } else {

    }
  } else {

  }
  {
#line 751
  tmp___3 = ixgbe_set_vf_mac(adapter, (int )vf, new_mac);
  }
#line 751
  return (tmp___3 < 0);
}
}
#line 754 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_find_vlvf_entry(struct ixgbe_hw *hw , u32 vlan ) 
{ 
  u32 vlvf ;
  s32 regindex ;

  {
#line 760
  if (vlan == 0U) {
#line 761
    return (0);
  } else {

  }
#line 764
  regindex = 1;
#line 764
  goto ldv_51817;
  ldv_51816: 
  {
#line 765
  vlvf = ixgbe_read_reg(hw, (u32 )((regindex + 15424) * 4));
  }
#line 766
  if ((vlvf & 4095U) == vlan) {
#line 767
    goto ldv_51815;
  } else {

  }
#line 764
  regindex = regindex + 1;
  ldv_51817: ;
#line 764
  if (regindex <= 63) {
#line 766
    goto ldv_51816;
  } else {

  }
  ldv_51815: ;
#line 771
  if (regindex > 63) {
#line 772
    regindex = -1;
  } else {

  }
#line 774
  return (regindex);
}
}
#line 777 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  int add ;
  int vid ;
  int err ;
  s32 reg_ndx ;
  u32 vlvf ;
  u32 bits ;
  u8 tcs ;
  int tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  int tmp___3 ;

  {
  {
#line 780
  hw = & adapter->hw;
#line 781
  add = (int )((*msgbuf & 16711680U) >> 16);
#line 782
  vid = (int )*(msgbuf + 1UL) & 4095;
#line 787
  tmp = netdev_get_num_tc(adapter->netdev);
#line 787
  tcs = (u8 )tmp;
  }
#line 789
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan != 0U || (unsigned int )tcs != 0U) {
#line 790
    if ((int )adapter->msg_enable & 1) {
      {
#line 793
      netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d attempted to override administratively set VLAN configuration\nReload the VF driver to resume operations\n",
                  vf);
      }
    } else {

    }
#line 794
    return (-1);
  } else {

  }
#line 797
  if (add != 0) {
#line 798
    (adapter->vfinfo + (unsigned long )vf)->vlan_count = (u16 )((int )(adapter->vfinfo + (unsigned long )vf)->vlan_count + 1);
  } else
#line 799
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->vlan_count != 0U) {
#line 800
    (adapter->vfinfo + (unsigned long )vf)->vlan_count = (u16 )((int )(adapter->vfinfo + (unsigned long )vf)->vlan_count - 1);
  } else {

  }
#line 805
  if (add != 0 && ((adapter->netdev)->flags & 256U) != 0U) {
    {
#line 806
    err = ixgbe_set_vf_vlan(adapter, add, vid, (u32 )adapter->ring_feature[1].offset);
    }
  } else {

  }
  {
#line 808
  err = ixgbe_set_vf_vlan(adapter, add, vid, vf);
  }
#line 809
  if (err == 0 && (unsigned int )(adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled != 0U) {
    {
#line 810
    (*(hw->mac.ops.set_vlan_anti_spoofing))(hw, 1, (int )vf);
    }
  } else {

  }
#line 815
  if (add == 0 && ((adapter->netdev)->flags & 256U) != 0U) {
    {
#line 816
    reg_ndx = ixgbe_find_vlvf_entry(hw, (u32 )vid);
    }
#line 817
    if (reg_ndx < 0) {
#line 818
      goto out;
    } else {

    }
    {
#line 819
    vlvf = ixgbe_read_reg(hw, (u32 )((reg_ndx + 15424) * 4));
    }
#line 823
    if ((int )adapter->ring_feature[1].offset <= 31) {
      {
#line 824
      bits = ixgbe_read_reg(hw, (u32 )((reg_ndx + 7744) * 8));
#line 825
      bits = bits & (u32 )(~ (1 << (int )adapter->ring_feature[1].offset));
#line 826
      tmp___0 = ixgbe_read_reg(hw, (u32 )((reg_ndx + 7744) * 8 + 1));
#line 826
      bits = bits | tmp___0;
      }
    } else {
      {
#line 829
      bits = ixgbe_read_reg(hw, (u32 )((reg_ndx + 7744) * 8 + 1));
#line 831
      bits = bits & (u32 )(~ (1 << ((int )adapter->ring_feature[1].offset + -32)));
#line 832
      tmp___1 = ixgbe_read_reg(hw, (u32 )((reg_ndx + 7744) * 8));
#line 832
      bits = bits | tmp___1;
      }
    }
#line 839
    if ((vlvf & 4095U) == (u32 )vid) {
      {
#line 839
      tmp___3 = variable_test_bit((long )vid, (unsigned long const volatile   *)(& adapter->active_vlans));
      }
#line 839
      if (tmp___3 == 0) {
#line 839
        if (bits == 0U) {
          {
#line 841
          ixgbe_set_vf_vlan(adapter, add, vid, (u32 )adapter->ring_feature[1].offset);
          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  out: ;
#line 846
  return (err);
}
}
#line 849 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_set_vf_macvlan_msg(struct ixgbe_adapter *adapter , u32 *msgbuf ,
                                    u32 vf ) 
{ 
  u8 *new_mac ;
  int index ;
  int err ;
  bool tmp ;
  int tmp___0 ;

  {
#line 852
  new_mac = (u8 *)msgbuf + 1U;
#line 853
  index = (int )((*msgbuf & 16711680U) >> 16);
#line 857
  if ((int )(adapter->vfinfo + (unsigned long )vf)->pf_set_mac && index > 0) {
#line 858
    if ((int )adapter->msg_enable & 1) {
      {
#line 860
      netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d requested MACVLAN filter but is administratively denied\n",
                  vf);
      }
    } else {

    }
#line 861
    return (-1);
  } else {

  }
#line 865
  if (index != 0) {
    {
#line 866
    tmp = is_valid_ether_addr((u8 const   *)new_mac);
    }
#line 866
    if (tmp) {
#line 866
      tmp___0 = 0;
    } else {
#line 866
      tmp___0 = 1;
    }
#line 866
    if (tmp___0) {
#line 867
      if ((int )adapter->msg_enable & 1) {
        {
#line 867
        netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d attempted to set invalid mac\n",
                    vf);
        }
      } else {

      }
#line 868
      return (-1);
    } else {

    }
#line 875
    if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled != 0U) {
      {
#line 876
      ixgbe_ndo_set_vf_spoofchk(adapter->netdev, (int )vf, 0);
      }
    } else {

    }
  } else {

  }
  {
#line 879
  err = ixgbe_set_vf_macvlan(adapter, (int )vf, index, new_mac);
  }
#line 880
  if (err == -28) {
#line 881
    if ((int )adapter->msg_enable & 1) {
      {
#line 883
      netdev_warn((struct net_device  const  *)adapter->netdev, "VF %d has requested a MACVLAN filter but there is no space for it\n",
                  vf);
      }
    } else {

    }
  } else {

  }
#line 885
  return (err < 0);
}
}
#line 888 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_negotiate_vf_api(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  int api ;

  {
#line 891
  api = (int )*(msgbuf + 1UL);
  {
#line 894
  if (api == 0) {
#line 894
    goto case_0;
  } else {

  }
#line 895
  if (api == 2) {
#line 895
    goto case_2;
  } else {

  }
#line 898
  goto switch_default;
  case_0: /* CIL Label */ ;
  case_2: /* CIL Label */ 
#line 896
  (adapter->vfinfo + (unsigned long )vf)->vf_api = (unsigned int )api;
#line 897
  return (0);
  switch_default: /* CIL Label */ ;
#line 899
  goto ldv_51849;
  switch_break: /* CIL Label */ ;
  }
  ldv_51849: ;
#line 902
  if ((int )adapter->msg_enable & 1) {
    {
#line 902
    netdev_info((struct net_device  const  *)adapter->netdev, "VF %d requested invalid api version %u\n",
                vf, api);
    }
  } else {

  }
#line 904
  return (-1);
}
}
#line 907 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_get_vf_queues(struct ixgbe_adapter *adapter , u32 *msgbuf , u32 vf ) 
{ 
  struct net_device *dev ;
  struct ixgbe_ring_feature *vmdq ;
  unsigned int default_tc ;
  u8 num_tcs ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 910
  dev = adapter->netdev;
#line 911
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 912
  default_tc = 0U;
#line 913
  tmp = netdev_get_num_tc(dev);
#line 913
  num_tcs = (u8 )tmp;
  }
  {
#line 917
  if ((adapter->vfinfo + (unsigned long )vf)->vf_api == 1U) {
#line 917
    goto case_1;
  } else {

  }
#line 918
  if ((adapter->vfinfo + (unsigned long )vf)->vf_api == 2U) {
#line 918
    goto case_2;
  } else {

  }
#line 920
  goto switch_default;
  case_1: /* CIL Label */ ;
  case_2: /* CIL Label */ ;
#line 919
  goto ldv_51861;
  switch_default: /* CIL Label */ ;
#line 921
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  ldv_51861: 
#line 925
  *(msgbuf + 1UL) = (u32 )(- ((int )vmdq->mask) & (int )vmdq->mask);
#line 926
  *(msgbuf + 2UL) = (u32 )(- ((int )vmdq->mask) & (int )vmdq->mask);
#line 929
  if ((unsigned int )num_tcs > 1U) {
    {
#line 930
    tmp___0 = netdev_get_prio_tc_map((struct net_device  const  *)dev, (u32 )adapter->default_up);
#line 930
    default_tc = (unsigned int )tmp___0;
    }
  } else {

  }
#line 933
  if ((unsigned int )num_tcs != 0U) {
#line 934
    *(msgbuf + 3UL) = (u32 )num_tcs;
  } else
#line 935
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan != 0U || (unsigned int )(adapter->vfinfo + (unsigned long )vf)->pf_qos != 0U) {
#line 936
    *(msgbuf + 3UL) = 1U;
  } else {
#line 938
    *(msgbuf + 3UL) = 0U;
  }
#line 941
  *(msgbuf + 4UL) = default_tc;
#line 943
  return (0);
}
}
#line 946 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  u32 mbx_size ;
  u32 msgbuf[16U] ;
  struct ixgbe_hw *hw ;
  s32 retval ;
  int tmp ;

  {
  {
#line 948
  mbx_size = 16U;
#line 950
  hw = & adapter->hw;
#line 953
  retval = ixgbe_read_mbx(hw, (u32 *)(& msgbuf), (int )((u16 )mbx_size), (int )((u16 )vf));
  }
#line 955
  if (retval != 0) {
    {
#line 956
    printk("\vixgbe: Error receiving message from VF\n");
    }
#line 957
    return (retval);
  } else {

  }
#line 961
  if ((msgbuf[0] & 3221225472U) != 0U) {
#line 962
    return (retval);
  } else {

  }
  {
#line 965
  ixgbe_read_reg(hw, 8U);
  }
#line 967
  if (msgbuf[0] == 1U) {
    {
#line 968
    tmp = ixgbe_vf_reset_msg(adapter, vf);
    }
#line 968
    return (tmp);
  } else {

  }
#line 974
  if (! (adapter->vfinfo + (unsigned long )vf)->clear_to_send) {
    {
#line 975
    msgbuf[0] = msgbuf[0] | 1073741824U;
#line 976
    ixgbe_write_mbx(hw, (u32 *)(& msgbuf), 1, (int )((u16 )vf));
    }
#line 977
    return (retval);
  } else {

  }
  {
#line 981
  if ((msgbuf[0] & 65535U) == 2U) {
#line 981
    goto case_2;
  } else {

  }
#line 984
  if ((msgbuf[0] & 65535U) == 3U) {
#line 984
    goto case_3;
  } else {

  }
#line 987
  if ((msgbuf[0] & 65535U) == 4U) {
#line 987
    goto case_4;
  } else {

  }
#line 990
  if ((msgbuf[0] & 65535U) == 5U) {
#line 990
    goto case_5;
  } else {

  }
#line 993
  if ((msgbuf[0] & 65535U) == 6U) {
#line 993
    goto case_6;
  } else {

  }
#line 996
  if ((msgbuf[0] & 65535U) == 8U) {
#line 996
    goto case_8;
  } else {

  }
#line 999
  if ((msgbuf[0] & 65535U) == 9U) {
#line 999
    goto case_9;
  } else {

  }
#line 1002
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 982
  retval = ixgbe_set_vf_mac_addr(adapter, (u32 *)(& msgbuf), vf);
  }
#line 983
  goto ldv_51872;
  case_3: /* CIL Label */ 
  {
#line 985
  retval = ixgbe_set_vf_multicasts(adapter, (u32 *)(& msgbuf), vf);
  }
#line 986
  goto ldv_51872;
  case_4: /* CIL Label */ 
  {
#line 988
  retval = ixgbe_set_vf_vlan_msg(adapter, (u32 *)(& msgbuf), vf);
  }
#line 989
  goto ldv_51872;
  case_5: /* CIL Label */ 
  {
#line 991
  retval = ixgbe_set_vf_lpe(adapter, (u32 *)(& msgbuf), vf);
  }
#line 992
  goto ldv_51872;
  case_6: /* CIL Label */ 
  {
#line 994
  retval = ixgbe_set_vf_macvlan_msg(adapter, (u32 *)(& msgbuf), vf);
  }
#line 995
  goto ldv_51872;
  case_8: /* CIL Label */ 
  {
#line 997
  retval = ixgbe_negotiate_vf_api(adapter, (u32 *)(& msgbuf), vf);
  }
#line 998
  goto ldv_51872;
  case_9: /* CIL Label */ 
  {
#line 1000
  retval = ixgbe_get_vf_queues(adapter, (u32 *)(& msgbuf), vf);
  }
#line 1001
  goto ldv_51872;
  switch_default: /* CIL Label */ ;
#line 1003
  if ((int )adapter->msg_enable & 1) {
    {
#line 1003
    netdev_err((struct net_device  const  *)adapter->netdev, "Unhandled Msg %8.8x\n",
               msgbuf[0]);
    }
  } else {

  }
#line 1004
  retval = -100;
#line 1005
  goto ldv_51872;
  switch_break: /* CIL Label */ ;
  }
  ldv_51872: ;
#line 1009
  if (retval != 0) {
#line 1010
    msgbuf[0] = msgbuf[0] | 1073741824U;
  } else {
#line 1012
    msgbuf[0] = msgbuf[0] | 2147483648U;
  }
  {
#line 1014
  msgbuf[0] = msgbuf[0] | 536870912U;
#line 1016
  ixgbe_write_mbx(hw, (u32 *)(& msgbuf), (int )((u16 )mbx_size), (int )((u16 )vf));
  }
#line 1018
  return (retval);
}
}
#line 1021 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_rcv_ack_from_vf(struct ixgbe_adapter *adapter , u32 vf ) 
{ 
  struct ixgbe_hw *hw ;
  u32 msg ;

  {
#line 1023
  hw = & adapter->hw;
#line 1024
  msg = 1073741824U;
#line 1027
  if (! (adapter->vfinfo + (unsigned long )vf)->clear_to_send) {
    {
#line 1028
    ixgbe_write_mbx(hw, & msg, 1, (int )((u16 )vf));
    }
  } else {

  }
#line 1029
  return;
}
}
#line 1031 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_msg_task(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 vf ;
  s32 tmp ;
  s32 tmp___0 ;
  s32 tmp___1 ;

  {
#line 1033
  hw = & adapter->hw;
#line 1036
  vf = 0U;
#line 1036
  goto ldv_51892;
  ldv_51891: 
  {
#line 1038
  tmp = ixgbe_check_for_rst(hw, (int )((u16 )vf));
  }
#line 1038
  if (tmp == 0) {
    {
#line 1039
    ixgbe_vf_reset_event(adapter, vf);
    }
  } else {

  }
  {
#line 1042
  tmp___0 = ixgbe_check_for_msg(hw, (int )((u16 )vf));
  }
#line 1042
  if (tmp___0 == 0) {
    {
#line 1043
    ixgbe_rcv_msg_from_vf(adapter, vf);
    }
  } else {

  }
  {
#line 1046
  tmp___1 = ixgbe_check_for_ack(hw, (int )((u16 )vf));
  }
#line 1046
  if (tmp___1 == 0) {
    {
#line 1047
    ixgbe_rcv_ack_from_vf(adapter, vf);
    }
  } else {

  }
#line 1036
  vf = vf + 1U;
  ldv_51892: ;
#line 1036
  if (vf < adapter->num_vfs) {
#line 1038
    goto ldv_51891;
  } else {

  }

#line 1043
  return;
}
}
#line 1051 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;

  {
  {
#line 1053
  hw = & adapter->hw;
#line 1056
  ixgbe_write_reg(hw, 33040U, 0U);
#line 1057
  ixgbe_write_reg(hw, 33044U, 0U);
#line 1059
  ixgbe_write_reg(hw, 20960U, 0U);
#line 1060
  ixgbe_write_reg(hw, 20964U, 0U);
  }
#line 1061
  return;
}
}
#line 1063 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 ping ;
  int i ;

  {
#line 1065
  hw = & adapter->hw;
#line 1069
  i = 0;
#line 1069
  goto ldv_51905;
  ldv_51904: 
#line 1070
  ping = 256U;
#line 1071
  if ((int )(adapter->vfinfo + (unsigned long )i)->clear_to_send) {
#line 1072
    ping = ping | 536870912U;
  } else {

  }
  {
#line 1073
  ixgbe_write_mbx(hw, & ping, 1, (int )((u16 )i));
#line 1069
  i = i + 1;
  }
  ldv_51905: ;
#line 1069
  if ((unsigned int )i < adapter->num_vfs) {
#line 1071
    goto ldv_51904;
  } else {

  }

#line 1076
  return;
}
}
#line 1077 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1079
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1079
  adapter = (struct ixgbe_adapter *)tmp;
#line 1080
  tmp___0 = is_valid_ether_addr((u8 const   *)mac);
  }
#line 1080
  if (tmp___0) {
#line 1080
    tmp___1 = 0;
  } else {
#line 1080
    tmp___1 = 1;
  }
#line 1080
  if (tmp___1 || (unsigned int )vf >= adapter->num_vfs) {
#line 1081
    return (-22);
  } else {

  }
  {
#line 1082
  (adapter->vfinfo + (unsigned long )vf)->pf_set_mac = 1;
#line 1083
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "setting MAC %pM on VF %d\n",
            mac, vf);
#line 1084
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Reload the VF driver to make this change effective.");
#line 1086
  tmp___2 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 1086
  if (tmp___2 != 0) {
    {
#line 1087
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "The VF MAC address has been set, but the PF device is not up.\n");
#line 1089
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Bring the PF device up before attempting to use the VF device.\n");
    }
  } else {

  }
  {
#line 1092
  tmp___3 = ixgbe_set_vf_mac(adapter, vf, mac);
  }
#line 1092
  return (tmp___3);
}
}
#line 1095 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) 
{ 
  int err ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  int tmp___0 ;

  {
  {
#line 1097
  err = 0;
#line 1098
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1098
  adapter = (struct ixgbe_adapter *)tmp;
#line 1099
  hw = & adapter->hw;
  }
#line 1101
  if (((unsigned int )vf >= adapter->num_vfs || (unsigned int )vlan > 4095U) || (unsigned int )qos > 7U) {
#line 1102
    return (-22);
  } else {

  }
#line 1103
  if ((unsigned int )vlan != 0U || (unsigned int )qos != 0U) {
#line 1104
    if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan != 0U) {
      {
#line 1105
      err = ixgbe_set_vf_vlan(adapter, 0, (int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan,
                              (u32 )vf);
      }
    } else {

    }
#line 1108
    if (err != 0) {
#line 1109
      goto out;
    } else {

    }
    {
#line 1110
    err = ixgbe_set_vf_vlan(adapter, 1, (int )vlan, (u32 )vf);
    }
#line 1111
    if (err != 0) {
#line 1112
      goto out;
    } else {

    }
    {
#line 1113
    ixgbe_set_vmvir(adapter, (int )vlan, (int )qos, (u32 )vf);
#line 1114
    ixgbe_set_vmolr(hw, (u32 )vf, 0);
    }
#line 1115
    if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled != 0U) {
      {
#line 1116
      (*(hw->mac.ops.set_vlan_anti_spoofing))(hw, 1, vf);
      }
    } else {

    }
    {
#line 1117
    (adapter->vfinfo + (unsigned long )vf)->vlan_count = (u16 )((int )(adapter->vfinfo + (unsigned long )vf)->vlan_count + 1);
#line 1118
    (adapter->vfinfo + (unsigned long )vf)->pf_vlan = vlan;
#line 1119
    (adapter->vfinfo + (unsigned long )vf)->pf_qos = (u16 )qos;
#line 1120
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Setting VLAN %d, QOS 0x%x on VF %d\n",
              (int )vlan, (int )qos, vf);
#line 1122
    tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 1122
    if (tmp___0 != 0) {
      {
#line 1123
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "The VF VLAN has been set, but the PF device is not up.\n");
#line 1126
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Bring the PF device up before attempting to use the VF device.\n");
      }
    } else {

    }
  } else {
    {
#line 1131
    err = ixgbe_set_vf_vlan(adapter, 0, (int )(adapter->vfinfo + (unsigned long )vf)->pf_vlan,
                            (u32 )vf);
#line 1133
    ixgbe_clear_vmvir(adapter, (u32 )vf);
#line 1134
    ixgbe_set_vmolr(hw, (u32 )vf, 1);
#line 1135
    (*(hw->mac.ops.set_vlan_anti_spoofing))(hw, 0, vf);
    }
#line 1136
    if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->vlan_count != 0U) {
#line 1137
      (adapter->vfinfo + (unsigned long )vf)->vlan_count = (u16 )((int )(adapter->vfinfo + (unsigned long )vf)->vlan_count - 1);
    } else {

    }
#line 1138
    (adapter->vfinfo + (unsigned long )vf)->pf_vlan = 0U;
#line 1139
    (adapter->vfinfo + (unsigned long )vf)->pf_qos = 0U;
  }
  out: ;
#line 1142
  return (err);
}
}
#line 1145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static int ixgbe_link_mbps(struct ixgbe_adapter *adapter ) 
{ 


  {
  {
#line 1148
  if (adapter->link_speed == 8U) {
#line 1148
    goto case_8;
  } else {

  }
#line 1150
  if (adapter->link_speed == 32U) {
#line 1150
    goto case_32;
  } else {

  }
#line 1152
  if (adapter->link_speed == 128U) {
#line 1152
    goto case_128;
  } else {

  }
#line 1154
  goto switch_default;
  case_8: /* CIL Label */ ;
#line 1149
  return (100);
  case_32: /* CIL Label */ ;
#line 1151
  return (1000);
  case_128: /* CIL Label */ ;
#line 1153
  return (10000);
  switch_default: /* CIL Label */ ;
#line 1155
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
static void ixgbe_set_vf_rate_limit(struct ixgbe_adapter *adapter , int vf ) 
{ 
  struct ixgbe_ring_feature *vmdq ;
  struct ixgbe_hw *hw ;
  u32 bcnrc_val ;
  u16 queue ;
  u16 queues_per_pool ;
  u16 tx_rate ;
  unsigned int reg_idx ;

  {
#line 1161
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 1162
  hw = & adapter->hw;
#line 1163
  bcnrc_val = 0U;
#line 1165
  tx_rate = (adapter->vfinfo + (unsigned long )vf)->tx_rate;
#line 1167
  if ((unsigned int )tx_rate != 0U) {
#line 1169
    bcnrc_val = (u32 )adapter->vf_rate_link_speed;
#line 1172
    bcnrc_val = bcnrc_val << 14;
#line 1173
    bcnrc_val = bcnrc_val / (u32 )tx_rate;
#line 1176
    bcnrc_val = bcnrc_val & 268435455U;
#line 1180
    bcnrc_val = bcnrc_val | 2147483648U;
  } else {

  }
  {
#line 1189
  if ((unsigned int )hw->mac.type == 2U) {
#line 1189
    goto case_2;
  } else {

  }
#line 1192
  if ((unsigned int )hw->mac.type == 3U) {
#line 1192
    goto case_3;
  } else {

  }
#line 1195
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1190
  ixgbe_write_reg(hw, 18816U, 4U);
  }
#line 1191
  goto ldv_51941;
  case_3: /* CIL Label */ 
  {
#line 1193
  ixgbe_write_reg(hw, 18816U, 20U);
  }
#line 1194
  goto ldv_51941;
  switch_default: /* CIL Label */ ;
#line 1196
  goto ldv_51941;
  switch_break: /* CIL Label */ ;
  }
  ldv_51941: 
#line 1200
  queues_per_pool = (u16 )((int )((short )(- ((int )vmdq->mask))) & (int )((short )vmdq->mask));
#line 1203
  queue = 0U;
#line 1203
  goto ldv_51946;
  ldv_51945: 
  {
#line 1204
  reg_idx = (unsigned int )(vf * (int )queues_per_pool + (int )queue);
#line 1206
  ixgbe_write_reg(hw, 18692U, reg_idx);
#line 1207
  ixgbe_write_reg(hw, 18820U, bcnrc_val);
#line 1203
  queue = (u16 )((int )queue + 1);
  }
  ldv_51946: ;
#line 1203
  if ((int )queue < (int )queues_per_pool) {
#line 1205
    goto ldv_51945;
  } else {

  }

#line 1210
  return;
}
}
#line 1211 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  int tmp ;

  {
#line 1216
  if (adapter->vf_rate_link_speed == 0) {
#line 1217
    return;
  } else {

  }
  {
#line 1219
  tmp = ixgbe_link_mbps(adapter);
  }
#line 1219
  if (tmp != adapter->vf_rate_link_speed) {
    {
#line 1220
    adapter->vf_rate_link_speed = 0;
#line 1221
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Link speed has been changed. VF Transmit rate is disabled\n");
    }
  } else {

  }
#line 1225
  i = 0;
#line 1225
  goto ldv_51953;
  ldv_51952: ;
#line 1226
  if (adapter->vf_rate_link_speed == 0) {
#line 1227
    (adapter->vfinfo + (unsigned long )i)->tx_rate = 0U;
  } else {

  }
  {
#line 1229
  ixgbe_set_vf_rate_limit(adapter, i);
#line 1225
  i = i + 1;
  }
  ldv_51953: ;
#line 1225
  if ((unsigned int )i < adapter->num_vfs) {
#line 1227
    goto ldv_51952;
  } else {

  }

#line 1232
  return;
}
}
#line 1233 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_bw(struct net_device *netdev , int vf , int tx_rate ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int link_speed ;

  {
  {
#line 1235
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1235
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 1239
  if ((unsigned int )vf >= adapter->num_vfs) {
#line 1240
    return (-22);
  } else {

  }
#line 1243
  if (! adapter->link_up) {
#line 1244
    return (-22);
  } else {

  }
  {
#line 1247
  link_speed = ixgbe_link_mbps(adapter);
  }
#line 1248
  if (link_speed != 10000) {
#line 1249
    return (-22);
  } else {

  }
#line 1252
  if (tx_rate != 0 && (tx_rate <= 10 || tx_rate > link_speed)) {
#line 1253
    return (-22);
  } else {

  }
  {
#line 1256
  adapter->vf_rate_link_speed = link_speed;
#line 1257
  (adapter->vfinfo + (unsigned long )vf)->tx_rate = (u16 )tx_rate;
#line 1260
  ixgbe_set_vf_rate_limit(adapter, vf);
  }
#line 1262
  return (0);
}
}
#line 1265 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev , int vf , bool setting ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int vf_target_reg ;
  int vf_target_shift ;
  struct ixgbe_hw *hw ;
  u32 regval ;

  {
  {
#line 1267
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1267
  adapter = (struct ixgbe_adapter *)tmp;
#line 1268
  vf_target_reg = vf >> 3;
#line 1269
  vf_target_shift = vf % 8;
#line 1270
  hw = & adapter->hw;
#line 1273
  (adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled = (u8 )setting;
#line 1275
  regval = ixgbe_read_reg(hw, (u32 )((vf_target_reg + 8320) * 4));
#line 1276
  regval = regval & (u32 )(~ (1 << vf_target_shift));
#line 1277
  regval = regval | (u32 )((int )setting << vf_target_shift);
#line 1278
  ixgbe_write_reg(hw, (u32 )((vf_target_reg + 8320) * 4), regval);
  }
#line 1280
  if ((unsigned int )(adapter->vfinfo + (unsigned long )vf)->vlan_count != 0U) {
    {
#line 1281
    vf_target_shift = vf_target_shift + 8;
#line 1282
    regval = ixgbe_read_reg(hw, (u32 )((vf_target_reg + 8320) * 4));
#line 1283
    regval = regval & (u32 )(~ (1 << vf_target_shift));
#line 1284
    regval = regval | (u32 )((int )setting << vf_target_shift);
#line 1285
    ixgbe_write_reg(hw, (u32 )((vf_target_reg + 8320) * 4), regval);
    }
  } else {

  }
#line 1288
  return (0);
}
}
#line 1291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c"
int ixgbe_ndo_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *ivi ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 1294
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1294
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 1295
  if ((unsigned int )vf >= adapter->num_vfs) {
#line 1296
    return (-22);
  } else {

  }
  {
#line 1297
  ivi->vf = (__u32 )vf;
#line 1298
  memcpy((void *)(& ivi->mac), (void const   *)(& (adapter->vfinfo + (unsigned long )vf)->vf_mac_addresses),
         6UL);
#line 1299
  ivi->tx_rate = (__u32 )(adapter->vfinfo + (unsigned long )vf)->tx_rate;
#line 1300
  ivi->vlan = (__u32 )(adapter->vfinfo + (unsigned long )vf)->pf_vlan;
#line 1301
  ivi->qos = (__u32 )(adapter->vfinfo + (unsigned long )vf)->pf_qos;
#line 1302
  ivi->spoofchk = (__u32 )(adapter->vfinfo + (unsigned long )vf)->spoofchk_enabled;
  }
#line 1303
  return (0);
}
}
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_sriov.c.aux"
static void *ldv_dev_get_drvdata_6___0(struct device  const  *dev ) 
{ 
  void *tmp ;

  {
  {
#line 117
  tmp = ldv_dev_get_drvdata(dev);
  }
#line 117
  return (tmp);
}
}
#line 8 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/delay.h"
extern void __udelay(unsigned long  ) ;
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_read_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;

  {
#line 44
  mbx = & hw->mbx;
#line 45
  ret_val = -100;
#line 48
  if ((int )size > (int )mbx->size) {
#line 49
    size = mbx->size;
  } else {

  }
#line 51
  if ((unsigned long )mbx->ops.read != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                 u32 * , u16  , u16  ))0)) {
    {
#line 52
    ret_val = (*(mbx->ops.read))(hw, msg, (int )size, (int )mbx_id);
    }
  } else {

  }
#line 54
  return (ret_val);
}
}
#line 66 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_write_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;

  {
#line 68
  mbx = & hw->mbx;
#line 69
  ret_val = 0;
#line 71
  if ((int )size > (int )mbx->size) {
#line 72
    ret_val = -100;
  } else
#line 74
  if ((unsigned long )mbx->ops.write != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                  u32 * , u16  , u16  ))0)) {
    {
#line 75
    ret_val = (*(mbx->ops.write))(hw, msg, (int )size, (int )mbx_id);
    }
  } else {

  }
#line 77
  return (ret_val);
}
}
#line 87 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_msg(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;

  {
#line 89
  mbx = & hw->mbx;
#line 90
  ret_val = -100;
#line 92
  if ((unsigned long )mbx->ops.check_for_msg != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          u16  ))0)) {
    {
#line 93
    ret_val = (*(mbx->ops.check_for_msg))(hw, (int )mbx_id);
    }
  } else {

  }
#line 95
  return (ret_val);
}
}
#line 105 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_ack(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;

  {
#line 107
  mbx = & hw->mbx;
#line 108
  ret_val = -100;
#line 110
  if ((unsigned long )mbx->ops.check_for_ack != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          u16  ))0)) {
    {
#line 111
    ret_val = (*(mbx->ops.check_for_ack))(hw, (int )mbx_id);
    }
  } else {

  }
#line 113
  return (ret_val);
}
}
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
s32 ixgbe_check_for_rst(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;

  {
#line 125
  mbx = & hw->mbx;
#line 126
  ret_val = -100;
#line 128
  if ((unsigned long )mbx->ops.check_for_rst != (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                          u16  ))0)) {
    {
#line 129
    ret_val = (*(mbx->ops.check_for_rst))(hw, (int )mbx_id);
    }
  } else {

  }
#line 131
  return (ret_val);
}
}
#line 141 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_poll_for_msg(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  int countdown ;
  s32 tmp ;

  {
#line 143
  mbx = & hw->mbx;
#line 144
  countdown = (int )mbx->timeout;
#line 146
  if (countdown == 0 || (unsigned long )mbx->ops.check_for_msg == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                            u16  ))0)) {
#line 147
    goto out;
  } else {

  }
#line 149
  goto ldv_50796;
  ldv_50795: 
#line 150
  countdown = countdown - 1;
#line 151
  if (countdown == 0) {
#line 152
    goto ldv_50794;
  } else {

  }
  {
#line 153
  __udelay((unsigned long )mbx->usec_delay);
  }
  ldv_50796: ;
#line 149
  if (countdown != 0) {
    {
#line 149
    tmp = (*(mbx->ops.check_for_msg))(hw, (int )mbx_id);
    }
#line 149
    if (tmp != 0) {
#line 151
      goto ldv_50795;
    } else {
#line 154
      goto ldv_50794;
    }
  } else {

  }
  ldv_50794: ;
  out: ;
#line 157
  return (countdown != 0 ? 0 : -100);
}
}
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_poll_for_ack(struct ixgbe_hw *hw , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  int countdown ;
  s32 tmp ;

  {
#line 169
  mbx = & hw->mbx;
#line 170
  countdown = (int )mbx->timeout;
#line 172
  if (countdown == 0 || (unsigned long )mbx->ops.check_for_ack == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                                            u16  ))0)) {
#line 173
    goto out;
  } else {

  }
#line 175
  goto ldv_50806;
  ldv_50805: 
#line 176
  countdown = countdown - 1;
#line 177
  if (countdown == 0) {
#line 178
    goto ldv_50804;
  } else {

  }
  {
#line 179
  __udelay((unsigned long )mbx->usec_delay);
  }
  ldv_50806: ;
#line 175
  if (countdown != 0) {
    {
#line 175
    tmp = (*(mbx->ops.check_for_ack))(hw, (int )mbx_id);
    }
#line 175
    if (tmp != 0) {
#line 177
      goto ldv_50805;
    } else {
#line 180
      goto ldv_50804;
    }
  } else {

  }
  ldv_50804: ;
  out: ;
#line 183
  return (countdown != 0 ? 0 : -100);
}
}
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_read_posted_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;

  {
#line 199
  mbx = & hw->mbx;
#line 200
  ret_val = -100;
#line 202
  if ((unsigned long )mbx->ops.read == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                 u32 * , u16  , u16  ))0)) {
#line 203
    goto out;
  } else {

  }
  {
#line 205
  ret_val = ixgbe_poll_for_msg(hw, (int )mbx_id);
  }
#line 208
  if (ret_val == 0) {
    {
#line 209
    ret_val = (*(mbx->ops.read))(hw, msg, (int )size, (int )mbx_id);
    }
  } else {

  }
  out: ;
#line 211
  return (ret_val);
}
}
#line 224 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_write_posted_mbx(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 mbx_id ) 
{ 
  struct ixgbe_mbx_info *mbx ;
  s32 ret_val ;

  {
#line 227
  mbx = & hw->mbx;
#line 228
  ret_val = -100;
#line 231
  if ((unsigned long )mbx->ops.write == (unsigned long )((s32 (*)(struct ixgbe_hw * ,
                                                                  u32 * , u16  , u16  ))0) || mbx->timeout == 0U) {
#line 232
    goto out;
  } else {

  }
  {
#line 235
  ret_val = (*(mbx->ops.write))(hw, msg, (int )size, (int )mbx_id);
  }
#line 238
  if (ret_val == 0) {
    {
#line 239
    ret_val = ixgbe_poll_for_ack(hw, (int )mbx_id);
    }
  } else {

  }
  out: ;
#line 241
  return (ret_val);
}
}
#line 244 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_bit_pf(struct ixgbe_hw *hw , u32 mask , s32 index ) 
{ 
  u32 mbvficr ;
  u32 tmp ;
  s32 ret_val ;

  {
  {
#line 246
  tmp = ixgbe_read_reg(hw, (u32 )((index + 452) * 4));
#line 246
  mbvficr = tmp;
#line 247
  ret_val = -100;
  }
#line 249
  if ((mbvficr & mask) != 0U) {
    {
#line 250
    ret_val = 0;
#line 251
    ixgbe_write_reg(hw, (u32 )((index + 452) * 4), mask);
    }
  } else {

  }
#line 254
  return (ret_val);
}
}
#line 264 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_msg_pf(struct ixgbe_hw *hw , u16 vf_number ) 
{ 
  s32 ret_val ;
  s32 index ;
  u32 vf_bit ;
  s32 tmp ;

  {
  {
#line 266
  ret_val = -100;
#line 267
  index = (int )vf_number >> 4;
#line 268
  vf_bit = (u32 )vf_number & 15U;
#line 270
  tmp = ixgbe_check_for_bit_pf(hw, (u32 )(1 << (int )vf_bit), index);
  }
#line 270
  if (tmp == 0) {
#line 272
    ret_val = 0;
#line 273
    hw->mbx.stats.reqs = hw->mbx.stats.reqs + 1U;
  } else {

  }
#line 276
  return (ret_val);
}
}
#line 286 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_ack_pf(struct ixgbe_hw *hw , u16 vf_number ) 
{ 
  s32 ret_val ;
  s32 index ;
  u32 vf_bit ;
  s32 tmp ;

  {
  {
#line 288
  ret_val = -100;
#line 289
  index = (int )vf_number >> 4;
#line 290
  vf_bit = (u32 )vf_number & 15U;
#line 292
  tmp = ixgbe_check_for_bit_pf(hw, (u32 )(65536 << (int )vf_bit), index);
  }
#line 292
  if (tmp == 0) {
#line 294
    ret_val = 0;
#line 295
    hw->mbx.stats.acks = hw->mbx.stats.acks + 1U;
  } else {

  }
#line 298
  return (ret_val);
}
}
#line 308 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw , u16 vf_number ) 
{ 
  u32 reg_offset ;
  u32 vf_shift ;
  u32 vflre ;
  s32 ret_val ;

  {
#line 310
  reg_offset = (unsigned int )vf_number > 31U;
#line 311
  vf_shift = (u32 )vf_number & 31U;
#line 312
  vflre = 0U;
#line 313
  ret_val = -100;
  {
#line 316
  if ((unsigned int )hw->mac.type == 2U) {
#line 316
    goto case_2;
  } else {

  }
#line 319
  if ((unsigned int )hw->mac.type == 3U) {
#line 319
    goto case_3;
  } else {

  }
#line 322
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 317
  vflre = ixgbe_read_reg(hw, (int )reg_offset & 1 ? 448U : 1536U);
  }
#line 318
  goto ldv_50855;
  case_3: /* CIL Label */ 
  {
#line 320
  vflre = ixgbe_read_reg(hw, (reg_offset + 448U) * 4U);
  }
#line 321
  goto ldv_50855;
  switch_default: /* CIL Label */ ;
#line 323
  goto ldv_50855;
  switch_break: /* CIL Label */ ;
  }
  ldv_50855: ;
#line 326
  if ((vflre & (u32 )(1 << (int )vf_shift)) != 0U) {
    {
#line 327
    ret_val = 0;
#line 328
    ixgbe_write_reg(hw, (reg_offset + 448U) * 4U, (u32 )(1 << (int )vf_shift));
#line 329
    hw->mbx.stats.rsts = hw->mbx.stats.rsts + 1U;
    }
  } else {

  }
#line 332
  return (ret_val);
}
}
#line 342 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw , u16 vf_number ) 
{ 
  s32 ret_val ;
  u32 p2v_mailbox ;

  {
  {
#line 344
  ret_val = -100;
#line 348
  ixgbe_write_reg(hw, (u32 )(((int )vf_number + 4800) * 4), 8U);
#line 351
  p2v_mailbox = ixgbe_read_reg(hw, (u32 )(((int )vf_number + 4800) * 4));
  }
#line 352
  if ((p2v_mailbox & 8U) != 0U) {
#line 353
    ret_val = 0;
  } else {

  }
#line 355
  return (ret_val);
}
}
#line 367 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_write_mbx_pf(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 vf_number ) 
{ 
  s32 ret_val ;
  u16 i ;

  {
  {
#line 374
  ret_val = ixgbe_obtain_mbx_lock_pf(hw, (int )vf_number);
  }
#line 375
  if (ret_val != 0) {
#line 376
    goto out_no_write;
  } else {

  }
  {
#line 379
  ixgbe_check_for_msg_pf(hw, (int )vf_number);
#line 380
  ixgbe_check_for_ack_pf(hw, (int )vf_number);
#line 383
  i = 0U;
  }
#line 383
  goto ldv_50874;
  ldv_50873: 
  {
#line 384
  ixgbe_write_reg(hw, (u32 )(((int )vf_number + 1216) * 64 + ((int )i << 2)), *(msg + (unsigned long )i));
#line 383
  i = (u16 )((int )i + 1);
  }
  ldv_50874: ;
#line 383
  if ((int )i < (int )size) {
#line 385
    goto ldv_50873;
  } else {

  }
  {
#line 387
  ixgbe_write_reg(hw, (u32 )(((int )vf_number + 4800) * 4), 1U);
#line 390
  hw->mbx.stats.msgs_tx = hw->mbx.stats.msgs_tx + 1U;
  }
  out_no_write: ;
#line 393
  return (ret_val);
}
}
#line 408 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
static s32 ixgbe_read_mbx_pf(struct ixgbe_hw *hw , u32 *msg , u16 size , u16 vf_number ) 
{ 
  s32 ret_val ;
  u16 i ;

  {
  {
#line 415
  ret_val = ixgbe_obtain_mbx_lock_pf(hw, (int )vf_number);
  }
#line 416
  if (ret_val != 0) {
#line 417
    goto out_no_read;
  } else {

  }
#line 420
  i = 0U;
#line 420
  goto ldv_50886;
  ldv_50885: 
  {
#line 421
  *(msg + (unsigned long )i) = ixgbe_read_reg(hw, (u32 )(((int )vf_number + 1216) * 64 + ((int )i << 2)));
#line 420
  i = (u16 )((int )i + 1);
  }
  ldv_50886: ;
#line 420
  if ((int )i < (int )size) {
#line 422
    goto ldv_50885;
  } else {

  }
  {
#line 424
  ixgbe_write_reg(hw, (u32 )(((int )vf_number + 4800) * 4), 2U);
#line 427
  hw->mbx.stats.msgs_rx = hw->mbx.stats.msgs_rx + 1U;
  }
  out_no_read: ;
#line 430
  return (ret_val);
}
}
#line 440 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mbx_info *mbx ;

  {
#line 442
  mbx = & hw->mbx;
#line 444
  if ((unsigned int )hw->mac.type - 2U > 1U) {
#line 446
    return;
  } else {

  }
#line 448
  mbx->timeout = 0U;
#line 449
  mbx->usec_delay = 0U;
#line 451
  mbx->stats.msgs_tx = 0U;
#line 452
  mbx->stats.msgs_rx = 0U;
#line 453
  mbx->stats.reqs = 0U;
#line 454
  mbx->stats.acks = 0U;
#line 455
  mbx->stats.rsts = 0U;
#line 457
  mbx->size = 16U;
#line 458
  return;
}
}
#line 461 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c"
struct ixgbe_mbx_operations mbx_ops_generic  = 
#line 461
     {0, & ixgbe_read_mbx_pf, & ixgbe_write_mbx_pf, & ixgbe_read_posted_mbx, & ixgbe_write_posted_mbx,
    & ixgbe_check_for_msg_pf, & ixgbe_check_for_ack_pf, & ixgbe_check_for_rst_pf};
#line 126 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_10_101(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 127
  ixgbe_read_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 128
  return;
}
}
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_10_153(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 132
  ixgbe_write_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 133
  return;
}
}
#line 136 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_10_16(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 137
  ixgbe_check_for_ack_pf(arg1, (int )arg2);
  }
#line 138
  return;
}
}
#line 141 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_10_168(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 142
  ixgbe_write_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 143
  return;
}
}
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_10_19(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 147
  ixgbe_check_for_msg_pf(arg1, (int )arg2);
  }
#line 148
  return;
}
}
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_10_22(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 152
  ixgbe_check_for_rst_pf(arg1, (int )arg2);
  }
#line 153
  return;
}
}
#line 156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_10_83(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 157
  ixgbe_read_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 158
  return;
}
}
#line 161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_11_101(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 162
  ixgbe_read_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 163
  return;
}
}
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_11_153(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 167
  ixgbe_write_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 168
  return;
}
}
#line 171 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_11_16(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 172
  ixgbe_check_for_ack_pf(arg1, (int )arg2);
  }
#line 173
  return;
}
}
#line 176 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_11_168(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 177
  ixgbe_write_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 178
  return;
}
}
#line 181 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_11_19(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 182
  ixgbe_check_for_msg_pf(arg1, (int )arg2);
  }
#line 183
  return;
}
}
#line 186 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_11_22(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 187
  ixgbe_check_for_rst_pf(arg1, (int )arg2);
  }
#line 188
  return;
}
}
#line 191 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_11_83(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 192
  ixgbe_read_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 193
  return;
}
}
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_12_101(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 197
  ixgbe_read_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 198
  return;
}
}
#line 201 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_12_153(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 202
  ixgbe_write_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 203
  return;
}
}
#line 206 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_12_16(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 207
  ixgbe_check_for_ack_pf(arg1, (int )arg2);
  }
#line 208
  return;
}
}
#line 211 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_12_168(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 212
  ixgbe_write_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 213
  return;
}
}
#line 216 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_12_19(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 217
  ixgbe_check_for_msg_pf(arg1, (int )arg2);
  }
#line 218
  return;
}
}
#line 221 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_12_22(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 222
  ixgbe_check_for_rst_pf(arg1, (int )arg2);
  }
#line 223
  return;
}
}
#line 226 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_12_83(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 227
  ixgbe_read_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 228
  return;
}
}
#line 231 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_13_101(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 232
  ixgbe_read_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 233
  return;
}
}
#line 236 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_13_153(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 237
  ixgbe_write_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 238
  return;
}
}
#line 241 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_13_16(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 242
  ixgbe_check_for_ack_pf(arg1, (int )arg2);
  }
#line 243
  return;
}
}
#line 246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_13_168(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                     unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 247
  ixgbe_write_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 248
  return;
}
}
#line 251 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_13_19(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 252
  ixgbe_check_for_msg_pf(arg1, (int )arg2);
  }
#line 253
  return;
}
}
#line 256 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_13_22(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 257
  ixgbe_check_for_rst_pf(arg1, (int )arg2);
  }
#line 258
  return;
}
}
#line 261 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_13_83(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 262
  ixgbe_read_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 263
  return;
}
}
#line 266 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_8_101(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 267
  ixgbe_read_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 268
  return;
}
}
#line 271 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_8_153(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 272
  ixgbe_write_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 273
  return;
}
}
#line 276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_8_16(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 277
  ixgbe_check_for_ack_pf(arg1, (int )arg2);
  }
#line 278
  return;
}
}
#line 281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_8_168(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 282
  ixgbe_write_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 283
  return;
}
}
#line 286 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_8_19(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 287
  ixgbe_check_for_msg_pf(arg1, (int )arg2);
  }
#line 288
  return;
}
}
#line 291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_8_22(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 292
  ixgbe_check_for_rst_pf(arg1, (int )arg2);
  }
#line 293
  return;
}
}
#line 296 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_8_83(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , unsigned short  ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                   unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 297
  ixgbe_read_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 298
  return;
}
}
#line 301 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_9_101(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 302
  ixgbe_read_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 303
  return;
}
}
#line 306 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_9_153(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 307
  ixgbe_write_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 308
  return;
}
}
#line 311 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_9_16(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 312
  ixgbe_check_for_ack_pf(arg1, (int )arg2);
  }
#line 313
  return;
}
}
#line 316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_9_168(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , unsigned short  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 317
  ixgbe_write_posted_mbx(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 318
  return;
}
}
#line 321 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_9_19(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 322
  ixgbe_check_for_msg_pf(arg1, (int )arg2);
  }
#line 323
  return;
}
}
#line 326 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_9_22(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 327
  ixgbe_check_for_rst_pf(arg1, (int )arg2);
  }
#line 328
  return;
}
}
#line 331 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_mbx.c.aux"
void ldv_dummy_resourceless_instance_callback_9_83(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , unsigned short  ,
                                                               unsigned short  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                   unsigned short arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 332
  ixgbe_read_mbx_pf(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 333
  return;
}
}
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw ) ;
#line 43
static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw ) ;
#line 44
static s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw , u16 mask ) ;
#line 45
static void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw , u16 mask ) ;
#line 46
static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw ) ;
#line 47
static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw ) ;
#line 49 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw ) 
{ 


  {
#line 51
  return (5);
}
}
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_mac_info *mac ;

  {
  {
#line 56
  mac = & hw->mac;
#line 59
  ixgbe_identify_phy_generic(hw);
#line 61
  mac->mcft_size = 128U;
#line 62
  mac->vft_size = 128U;
#line 63
  mac->num_rar_entries = 128U;
#line 64
  mac->max_rx_queues = 128U;
#line 65
  mac->max_tx_queues = 128U;
#line 66
  mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
  }
#line 68
  return (0);
}
}
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw , ixgbe_link_speed speed ,
                                     bool autoneg_wait_to_complete ) 
{ 
  s32 tmp ;

  {
  {
#line 81
  tmp = (*(hw->phy.ops.setup_link_speed))(hw, speed, (int )autoneg_wait_to_complete);
  }
#line 81
  return (tmp);
}
}
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 ctrl ;
  u32 i ;
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 99
  status = (*(hw->mac.ops.stop_adapter))(hw);
  }
#line 100
  if (status != 0) {
#line 101
    goto reset_hw_out;
  } else {

  }
  {
#line 104
  ixgbe_clear_tx_pending(hw);
  }
  mac_reset_top: 
  {
#line 107
  ctrl = 67108864U;
#line 108
  tmp = ixgbe_read_reg(hw, 0U);
#line 108
  ctrl = ctrl | tmp;
#line 109
  ixgbe_write_reg(hw, 0U, ctrl);
#line 110
  ixgbe_read_reg(hw, 8U);
#line 113
  i = 0U;
  }
#line 113
  goto ldv_50871;
  ldv_50870: 
  {
#line 114
  __const_udelay(4295UL);
#line 115
  ctrl = ixgbe_read_reg(hw, 0U);
  }
#line 116
  if ((ctrl & 67108872U) == 0U) {
#line 117
    goto ldv_50869;
  } else {

  }
#line 113
  i = i + 1U;
  ldv_50871: ;
#line 113
  if (i <= 9U) {
#line 115
    goto ldv_50870;
  } else {

  }
  ldv_50869: ;
#line 120
  if ((ctrl & 67108872U) != 0U) {
    {
#line 121
    status = -15;
#line 122
    descriptor.modname = "ixgbe";
#line 122
    descriptor.function = "ixgbe_reset_hw_X540";
#line 122
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 122
    descriptor.format = "Reset polling failed to complete.\n";
#line 122
    descriptor.lineno = 122U;
#line 122
    descriptor.flags = 0U;
#line 122
    tmp___0 = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 122
    if (tmp___0 != 0L) {
      {
#line 122
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Reset polling failed to complete.\n");
      }
    } else {

    }
  } else {

  }
  {
#line 124
  msleep(100U);
  }
#line 131
  if ((int )hw->mac.flags & 1) {
#line 132
    hw->mac.flags = (unsigned int )hw->mac.flags & 254U;
#line 133
    goto mac_reset_top;
  } else {

  }
  {
#line 137
  ixgbe_write_reg(hw, 15360U, 393216U);
#line 140
  (*(hw->mac.ops.get_mac_addr))(hw, (u8 *)(& hw->mac.perm_addr));
#line 147
  hw->mac.num_rar_entries = 128U;
#line 148
  (*(hw->mac.ops.init_rx_addrs))(hw);
#line 151
  (*(hw->mac.ops.get_san_mac_addr))(hw, (u8 *)(& hw->mac.san_addr));
#line 154
  tmp___1 = is_valid_ether_addr((u8 const   *)(& hw->mac.san_addr));
  }
#line 154
  if ((int )tmp___1) {
    {
#line 155
    (*(hw->mac.ops.set_rar))(hw, hw->mac.num_rar_entries - 1U, (u8 *)(& hw->mac.san_addr),
                             0U, 2147483648U);
#line 159
    hw->mac.san_mac_rar_index = (unsigned int )((u8 )hw->mac.num_rar_entries) - 1U;
#line 162
    hw->mac.num_rar_entries = hw->mac.num_rar_entries - 1U;
    }
  } else {

  }
  {
#line 166
  (*(hw->mac.ops.get_wwn_prefix))(hw, & hw->mac.wwnn_prefix, & hw->mac.wwpn_prefix);
  }
  reset_hw_out: ;
#line 170
  return (status);
}
}
#line 181 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw ) 
{ 
  s32 ret_val ;

  {
  {
#line 183
  ret_val = 0;
#line 185
  ret_val = ixgbe_start_hw_generic(hw);
  }
#line 186
  if (ret_val != 0) {
#line 187
    goto out;
  } else {

  }
  {
#line 189
  ret_val = ixgbe_start_hw_gen2(hw);
#line 190
  hw->mac.rx_pb_size = 384U;
  }
  out: ;
#line 192
  return (ret_val);
}
}
#line 201 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static u32 ixgbe_get_supported_physical_layer_X540(struct ixgbe_hw *hw ) 
{ 
  u32 physical_layer ;
  u16 ext_ability ;

  {
  {
#line 203
  physical_layer = 0U;
#line 204
  ext_ability = 0U;
#line 206
  (*(hw->phy.ops.identify))(hw);
#line 208
  (*(hw->phy.ops.read_reg))(hw, 11U, 1U, & ext_ability);
  }
#line 210
  if (((int )ext_ability & 4) != 0) {
#line 211
    physical_layer = physical_layer | 1U;
  } else {

  }
#line 212
  if (((int )ext_ability & 32) != 0) {
#line 213
    physical_layer = physical_layer | 2U;
  } else {

  }
#line 214
  if (((int )ext_ability & 128) != 0) {
#line 215
    physical_layer = physical_layer | 4U;
  } else {

  }
#line 217
  return (physical_layer);
}
}
#line 227 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw ) 
{ 
  struct ixgbe_eeprom_info *eeprom ;
  u32 eec ;
  u16 eeprom_size ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 229
  eeprom = & hw->eeprom;
#line 233
  if ((unsigned int )eeprom->type == 0U) {
    {
#line 234
    eeprom->semaphore_delay = 10U;
#line 235
    eeprom->type = 2;
#line 237
    eec = ixgbe_read_reg(hw, 65552U);
#line 238
    eeprom_size = (unsigned short )((eec & 30720U) >> 11);
#line 240
    eeprom->word_size = (u16 )(1 << ((int )eeprom_size + 6));
#line 243
    descriptor.modname = "ixgbe";
#line 243
    descriptor.function = "ixgbe_init_eeprom_params_X540";
#line 243
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 243
    descriptor.format = "Eeprom params: type = %d, size = %d\n";
#line 243
    descriptor.lineno = 244U;
#line 243
    descriptor.flags = 0U;
#line 243
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 243
    if (tmp != 0L) {
      {
#line 243
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Eeprom params: type = %d, size = %d\n", (unsigned int )eeprom->type,
                           (int )eeprom->word_size);
      }
    } else {

    }
  } else {

  }
#line 247
  return (0);
}
}
#line 258 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw , u16 offset , u16 *data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
  {
#line 260
  status = 0;
#line 262
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1);
  }
#line 262
  if (tmp == 0) {
    {
#line 264
    status = ixgbe_read_eerd_generic(hw, (int )offset, data);
    }
  } else {
#line 266
    status = -16;
  }
  {
#line 268
  (*(hw->mac.ops.release_swfw_sync))(hw, 1);
  }
#line 269
  return (status);
}
}
#line 281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                       u16 *data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
  {
#line 284
  status = 0;
#line 286
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1);
  }
#line 286
  if (tmp == 0) {
    {
#line 288
    status = ixgbe_read_eerd_buffer_generic(hw, (int )offset, (int )words, data);
    }
  } else {
#line 291
    status = -16;
  }
  {
#line 293
  (*(hw->mac.ops.release_swfw_sync))(hw, 1);
  }
#line 294
  return (status);
}
}
#line 305 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw , u16 offset , u16 data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
  {
#line 307
  status = 0;
#line 309
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1);
  }
#line 309
  if (tmp == 0) {
    {
#line 310
    status = ixgbe_write_eewr_generic(hw, (int )offset, (int )data);
    }
  } else {
#line 312
    status = -16;
  }
  {
#line 314
  (*(hw->mac.ops.release_swfw_sync))(hw, 1);
  }
#line 315
  return (status);
}
}
#line 327 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw , u16 offset , u16 words ,
                                        u16 *data ) 
{ 
  s32 status ;
  s32 tmp ;

  {
  {
#line 330
  status = 0;
#line 332
  tmp = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1);
  }
#line 332
  if (tmp == 0) {
    {
#line 334
    status = ixgbe_write_eewr_buffer_generic(hw, (int )offset, (int )words, data);
    }
  } else {
#line 337
    status = -16;
  }
  {
#line 339
  (*(hw->mac.ops.release_swfw_sync))(hw, 1);
  }
#line 340
  return (status);
}
}
#line 351 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static u16 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw ) 
{ 
  u16 i ;
  u16 j ;
  u16 checksum ;
  u16 length ;
  u16 pointer ;
  u16 word ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  s32 tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  s32 tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  s32 tmp___6 ;

  {
#line 355
  checksum = 0U;
#line 356
  length = 0U;
#line 357
  pointer = 0U;
#line 358
  word = 0U;
#line 367
  i = 0U;
#line 367
  goto ldv_50931;
  ldv_50930: 
  {
#line 368
  tmp___0 = ixgbe_read_eerd_generic(hw, (int )i, & word);
  }
#line 368
  if (tmp___0 != 0) {
    {
#line 369
    descriptor.modname = "ixgbe";
#line 369
    descriptor.function = "ixgbe_calc_eeprom_checksum_X540";
#line 369
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 369
    descriptor.format = "EEPROM read failed\n";
#line 369
    descriptor.lineno = 369U;
#line 369
    descriptor.flags = 0U;
#line 369
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 369
    if (tmp != 0L) {
      {
#line 369
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
#line 370
    goto ldv_50929;
  } else {

  }
#line 372
  checksum = (int )checksum + (int )word;
#line 367
  i = (u16 )((int )i + 1);
  ldv_50931: ;
#line 367
  if ((unsigned int )i <= 62U) {
#line 369
    goto ldv_50930;
  } else {

  }
  ldv_50929: 
#line 379
  i = 3U;
#line 379
  goto ldv_50941;
  ldv_50940: ;
#line 380
  if ((unsigned int )i - 4U <= 1U) {
#line 381
    goto ldv_50932;
  } else {

  }
  {
#line 383
  tmp___2 = ixgbe_read_eerd_generic(hw, (int )i, & pointer);
  }
#line 383
  if (tmp___2 != 0) {
    {
#line 384
    descriptor___0.modname = "ixgbe";
#line 384
    descriptor___0.function = "ixgbe_calc_eeprom_checksum_X540";
#line 384
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 384
    descriptor___0.format = "EEPROM read failed\n";
#line 384
    descriptor___0.lineno = 384U;
#line 384
    descriptor___0.flags = 0U;
#line 384
    tmp___1 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 384
    if (tmp___1 != 0L) {
      {
#line 384
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
#line 385
    goto ldv_50934;
  } else {

  }
#line 389
  if ((unsigned int )pointer - 1U > 65533U || (int )pointer >= (int )hw->eeprom.word_size) {
#line 391
    goto ldv_50932;
  } else {

  }
  {
#line 393
  tmp___4 = ixgbe_read_eerd_generic(hw, (int )pointer, & length);
  }
#line 393
  if (tmp___4 != 0) {
    {
#line 394
    descriptor___1.modname = "ixgbe";
#line 394
    descriptor___1.function = "ixgbe_calc_eeprom_checksum_X540";
#line 394
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 394
    descriptor___1.format = "EEPROM read failed\n";
#line 394
    descriptor___1.lineno = 394U;
#line 394
    descriptor___1.flags = 0U;
#line 394
    tmp___3 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 394
    if (tmp___3 != 0L) {
      {
#line 394
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
#line 395
    goto ldv_50934;
  } else {

  }
#line 399
  if ((unsigned int )length - 1U > 65533U || (int )pointer + (int )length >= (int )hw->eeprom.word_size) {
#line 401
    goto ldv_50932;
  } else {

  }
#line 403
  j = (unsigned int )pointer + 1U;
#line 403
  goto ldv_50939;
  ldv_50938: 
  {
#line 404
  tmp___6 = ixgbe_read_eerd_generic(hw, (int )j, & word);
  }
#line 404
  if (tmp___6 != 0) {
    {
#line 405
    descriptor___2.modname = "ixgbe";
#line 405
    descriptor___2.function = "ixgbe_calc_eeprom_checksum_X540";
#line 405
    descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 405
    descriptor___2.format = "EEPROM read failed\n";
#line 405
    descriptor___2.lineno = 405U;
#line 405
    descriptor___2.flags = 0U;
#line 405
    tmp___5 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
    }
#line 405
    if (tmp___5 != 0L) {
      {
#line 405
      __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
#line 406
    goto ldv_50937;
  } else {

  }
#line 408
  checksum = (int )checksum + (int )word;
#line 403
  j = (u16 )((int )j + 1);
  ldv_50939: ;
#line 403
  if ((int )j <= (int )pointer + (int )length) {
#line 405
    goto ldv_50938;
  } else {

  }
  ldv_50937: ;
  ldv_50932: 
#line 379
  i = (u16 )((int )i + 1);
  ldv_50941: ;
#line 379
  if ((unsigned int )i <= 14U) {
#line 381
    goto ldv_50940;
  } else {

  }
  ldv_50934: 
#line 412
  checksum = 47802U - (unsigned int )checksum;
#line 414
  return (checksum);
}
}
#line 425 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw , u16 *checksum_val ) 
{ 
  s32 status ;
  u16 checksum ;
  u16 read_checksum ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;

  {
  {
#line 430
  read_checksum = 0U;
#line 437
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
  }
#line 439
  if (status != 0) {
    {
#line 440
    descriptor.modname = "ixgbe";
#line 440
    descriptor.function = "ixgbe_validate_eeprom_checksum_X540";
#line 440
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 440
    descriptor.format = "EEPROM read failed\n";
#line 440
    descriptor.lineno = 440U;
#line 440
    descriptor.flags = 0U;
#line 440
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 440
    if (tmp != 0L) {
      {
#line 440
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
#line 441
    goto out;
  } else {

  }
  {
#line 444
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1);
  }
#line 444
  if (tmp___0 == 0) {
    {
#line 445
    checksum = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 451
    ixgbe_read_eerd_generic(hw, 63, & read_checksum);
    }
#line 458
    if ((int )read_checksum != (int )checksum) {
#line 459
      status = -2;
    } else {

    }
#line 462
    if ((unsigned long )checksum_val != (unsigned long )((u16 *)0U)) {
#line 463
      *checksum_val = checksum;
    } else {

    }
  } else {
#line 465
    status = -16;
  }
  {
#line 468
  (*(hw->mac.ops.release_swfw_sync))(hw, 1);
  }
  out: ;
#line 470
  return (status);
}
}
#line 481 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u16 checksum ;
  struct _ddebug descriptor ;
  long tmp ;
  s32 tmp___0 ;

  {
  {
#line 491
  status = (*(hw->eeprom.ops.read))(hw, 0, & checksum);
  }
#line 493
  if (status != 0) {
    {
#line 494
    descriptor.modname = "ixgbe";
#line 494
    descriptor.function = "ixgbe_update_eeprom_checksum_X540";
#line 494
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 494
    descriptor.format = "EEPROM read failed\n";
#line 494
    descriptor.lineno = 494U;
#line 494
    descriptor.flags = 0U;
#line 494
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 494
    if (tmp != 0L) {
      {
#line 494
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "EEPROM read failed\n");
      }
    } else {

    }
  } else {

  }
  {
#line 496
  tmp___0 = (*(hw->mac.ops.acquire_swfw_sync))(hw, 1);
  }
#line 496
  if (tmp___0 == 0) {
    {
#line 497
    checksum = (*(hw->eeprom.ops.calc_checksum))(hw);
#line 503
    status = ixgbe_write_eewr_generic(hw, 63, (int )checksum);
    }
#line 506
    if (status == 0) {
      {
#line 507
      status = ixgbe_update_flash_X540(hw);
      }
    } else {
#line 509
      status = -16;
    }
  } else {

  }
  {
#line 512
  (*(hw->mac.ops.release_swfw_sync))(hw, 1);
  }
#line 514
  return (status);
}
}
#line 524 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw ) 
{ 
  u32 flup ;
  s32 status ;
  struct _ddebug descriptor ;
  long tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;

  {
  {
#line 527
  status = -1;
#line 529
  status = ixgbe_poll_flash_update_done_X540(hw);
  }
#line 530
  if (status == -1) {
    {
#line 531
    descriptor.modname = "ixgbe";
#line 531
    descriptor.function = "ixgbe_update_flash_X540";
#line 531
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 531
    descriptor.format = "Flash update time out\n";
#line 531
    descriptor.lineno = 531U;
#line 531
    descriptor.flags = 0U;
#line 531
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 531
    if (tmp != 0L) {
      {
#line 531
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flash update time out\n");
      }
    } else {

    }
#line 532
    goto out;
  } else {

  }
  {
#line 535
  tmp___0 = ixgbe_read_reg(hw, 65552U);
#line 535
  flup = tmp___0 | 8388608U;
#line 536
  ixgbe_write_reg(hw, 65552U, flup);
#line 538
  status = ixgbe_poll_flash_update_done_X540(hw);
  }
#line 539
  if (status == 0) {
    {
#line 540
    descriptor___0.modname = "ixgbe";
#line 540
    descriptor___0.function = "ixgbe_update_flash_X540";
#line 540
    descriptor___0.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 540
    descriptor___0.format = "Flash update complete\n";
#line 540
    descriptor___0.lineno = 540U;
#line 540
    descriptor___0.flags = 0U;
#line 540
    tmp___1 = __builtin_expect((long )descriptor___0.flags & 1L, 0L);
    }
#line 540
    if (tmp___1 != 0L) {
      {
#line 540
      __dynamic_netdev_dbg(& descriptor___0, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flash update complete\n");
      }
    } else {

    }
  } else {
    {
#line 542
    descriptor___1.modname = "ixgbe";
#line 542
    descriptor___1.function = "ixgbe_update_flash_X540";
#line 542
    descriptor___1.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 542
    descriptor___1.format = "Flash update time out\n";
#line 542
    descriptor___1.lineno = 542U;
#line 542
    descriptor___1.flags = 0U;
#line 542
    tmp___2 = __builtin_expect((long )descriptor___1.flags & 1L, 0L);
    }
#line 542
    if (tmp___2 != 0L) {
      {
#line 542
      __dynamic_netdev_dbg(& descriptor___1, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Flash update time out\n");
      }
    } else {

    }
  }
#line 544
  if ((unsigned int )hw->revision_id == 0U) {
    {
#line 545
    flup = ixgbe_read_reg(hw, 65552U);
    }
#line 547
    if ((flup & 33554432U) != 0U) {
      {
#line 548
      flup = flup | 8388608U;
#line 549
      ixgbe_write_reg(hw, 65552U, flup);
      }
    } else {

    }
    {
#line 552
    status = ixgbe_poll_flash_update_done_X540(hw);
    }
#line 553
    if (status == 0) {
      {
#line 554
      descriptor___2.modname = "ixgbe";
#line 554
      descriptor___2.function = "ixgbe_update_flash_X540";
#line 554
      descriptor___2.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 554
      descriptor___2.format = "Flash update complete\n";
#line 554
      descriptor___2.lineno = 554U;
#line 554
      descriptor___2.flags = 0U;
#line 554
      tmp___3 = __builtin_expect((long )descriptor___2.flags & 1L, 0L);
      }
#line 554
      if (tmp___3 != 0L) {
        {
#line 554
        __dynamic_netdev_dbg(& descriptor___2, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Flash update complete\n");
        }
      } else {

      }
    } else {
      {
#line 556
      descriptor___3.modname = "ixgbe";
#line 556
      descriptor___3.function = "ixgbe_update_flash_X540";
#line 556
      descriptor___3.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 556
      descriptor___3.format = "Flash update time out\n";
#line 556
      descriptor___3.lineno = 556U;
#line 556
      descriptor___3.flags = 0U;
#line 556
      tmp___4 = __builtin_expect((long )descriptor___3.flags & 1L, 0L);
      }
#line 556
      if (tmp___4 != 0L) {
        {
#line 556
        __dynamic_netdev_dbg(& descriptor___3, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                             "Flash update time out\n");
        }
      } else {

      }
    }
  } else {

  }
  out: ;
#line 559
  return (status);
}
}
#line 569 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw ) 
{ 
  u32 i ;
  u32 reg ;
  s32 status ;

  {
#line 573
  status = -1;
#line 575
  i = 0U;
#line 575
  goto ldv_50979;
  ldv_50978: 
  {
#line 576
  reg = ixgbe_read_reg(hw, 65552U);
  }
#line 577
  if ((reg & 67108864U) != 0U) {
#line 578
    status = 0;
#line 579
    goto ldv_50977;
  } else {

  }
  {
#line 581
  __const_udelay(21475UL);
#line 575
  i = i + 1U;
  }
  ldv_50979: ;
#line 575
  if (i <= 19999U) {
#line 577
    goto ldv_50978;
  } else {

  }
  ldv_50977: ;
#line 583
  return (status);
}
}
#line 594 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw , u16 mask ) 
{ 
  u32 swfw_sync ;
  u32 swmask ;
  u32 fwmask ;
  u32 hwmask ;
  u32 timeout ;
  u32 i ;
  s32 tmp ;
  s32 tmp___0 ;

  {
#line 597
  swmask = (u32 )mask;
#line 598
  fwmask = (u32 )((int )mask << 5);
#line 599
  hwmask = 0U;
#line 600
  timeout = 200U;
#line 603
  if (swmask == 1U) {
#line 604
    hwmask = 16U;
  } else {

  }
#line 606
  i = 0U;
#line 606
  goto ldv_50992;
  ldv_50991: 
  {
#line 611
  tmp = ixgbe_get_swfw_sync_semaphore(hw);
  }
#line 611
  if (tmp != 0) {
#line 612
    return (-16);
  } else {

  }
  {
#line 614
  swfw_sync = ixgbe_read_reg(hw, 65888U);
  }
#line 615
  if ((swfw_sync & ((fwmask | swmask) | hwmask)) == 0U) {
    {
#line 616
    swfw_sync = swfw_sync | swmask;
#line 617
    ixgbe_write_reg(hw, 65888U, swfw_sync);
#line 618
    ixgbe_release_swfw_sync_semaphore(hw);
    }
#line 619
    goto ldv_50990;
  } else {
    {
#line 627
    ixgbe_release_swfw_sync_semaphore(hw);
#line 628
    usleep_range(5000UL, 10000UL);
    }
  }
#line 606
  i = i + 1U;
  ldv_50992: ;
#line 606
  if (i < timeout) {
#line 608
    goto ldv_50991;
  } else {

  }
  ldv_50990: ;
#line 638
  if (i >= timeout) {
    {
#line 639
    swfw_sync = ixgbe_read_reg(hw, 65888U);
    }
#line 640
    if ((swfw_sync & (fwmask | hwmask)) != 0U) {
      {
#line 641
      tmp___0 = ixgbe_get_swfw_sync_semaphore(hw);
      }
#line 641
      if (tmp___0 != 0) {
#line 642
        return (-16);
      } else {

      }
      {
#line 644
      swfw_sync = swfw_sync | swmask;
#line 645
      ixgbe_write_reg(hw, 65888U, swfw_sync);
#line 646
      ixgbe_release_swfw_sync_semaphore(hw);
      }
    } else {

    }
  } else {

  }
  {
#line 650
  usleep_range(5000UL, 10000UL);
  }
#line 651
  return (0);
}
}
#line 662 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw , u16 mask ) 
{ 
  u32 swfw_sync ;
  u32 swmask ;

  {
  {
#line 665
  swmask = (u32 )mask;
#line 667
  ixgbe_get_swfw_sync_semaphore(hw);
#line 669
  swfw_sync = ixgbe_read_reg(hw, 65888U);
#line 670
  swfw_sync = swfw_sync & ~ swmask;
#line 671
  ixgbe_write_reg(hw, 65888U, swfw_sync);
#line 673
  ixgbe_release_swfw_sync_semaphore(hw);
#line 674
  usleep_range(5000UL, 10000UL);
  }
#line 675
  return;
}
}
#line 683 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw ) 
{ 
  s32 status ;
  u32 timeout ;
  u32 i ;
  u32 swsm ;
  struct _ddebug descriptor ;
  long tmp ;

  {
#line 685
  status = -1;
#line 686
  timeout = 2000U;
#line 691
  i = 0U;
#line 691
  goto ldv_51008;
  ldv_51007: 
  {
#line 696
  swsm = ixgbe_read_reg(hw, 65856U);
  }
#line 697
  if ((swsm & 1U) == 0U) {
#line 698
    status = 0;
#line 699
    goto ldv_51006;
  } else {

  }
  {
#line 701
  __const_udelay(214750UL);
#line 691
  i = i + 1U;
  }
  ldv_51008: ;
#line 691
  if (i < timeout) {
#line 693
    goto ldv_51007;
  } else {

  }
  ldv_51006: ;
#line 705
  if (status != 0) {
#line 706
    i = 0U;
#line 706
    goto ldv_51011;
    ldv_51010: 
    {
#line 707
    swsm = ixgbe_read_reg(hw, 65888U);
    }
#line 708
    if ((int )swsm >= 0) {
#line 709
      goto ldv_51009;
    } else {

    }
    {
#line 711
    __const_udelay(214750UL);
#line 706
    i = i + 1U;
    }
    ldv_51011: ;
#line 706
    if (i < timeout) {
#line 708
      goto ldv_51010;
    } else {

    }
    ldv_51009: ;
  } else {
    {
#line 714
    descriptor.modname = "ixgbe";
#line 714
    descriptor.function = "ixgbe_get_swfw_sync_semaphore";
#line 714
    descriptor.filename = "drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c";
#line 714
    descriptor.format = "Software semaphore SMBI between device drivers not granted.\n";
#line 714
    descriptor.lineno = 715U;
#line 714
    descriptor.flags = 0U;
#line 714
    tmp = __builtin_expect((long )descriptor.flags & 1L, 0L);
    }
#line 714
    if (tmp != 0L) {
      {
#line 714
      __dynamic_netdev_dbg(& descriptor, (struct net_device  const  *)((struct ixgbe_adapter *)hw->back)->netdev,
                           "Software semaphore SMBI between device drivers not granted.\n");
      }
    } else {

    }
  }
#line 718
  return (status);
}
}
#line 727 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw ) 
{ 
  u32 swsm ;

  {
  {
#line 733
  swsm = ixgbe_read_reg(hw, 65856U);
#line 734
  swsm = swsm & 4294967294U;
#line 735
  ixgbe_write_reg(hw, 65856U, swsm);
#line 737
  swsm = ixgbe_read_reg(hw, 65888U);
#line 738
  swsm = swsm & 2147483647U;
#line 739
  ixgbe_write_reg(hw, 65888U, swsm);
#line 741
  ixgbe_read_reg(hw, 8U);
  }
#line 742
  return;
}
}
#line 752 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 macc_reg ;
  u32 ledctl_reg ;
  ixgbe_link_speed speed ;
  bool link_up ;

  {
  {
#line 764
  (*(hw->mac.ops.check_link))(hw, & speed, & link_up, 0);
  }
#line 765
  if (! link_up) {
    {
#line 766
    macc_reg = ixgbe_read_reg(hw, 17200U);
#line 767
    macc_reg = macc_reg | 458753U;
#line 768
    ixgbe_write_reg(hw, 17200U, macc_reg);
    }
  } else {

  }
  {
#line 771
  ledctl_reg = ixgbe_read_reg(hw, 512U);
#line 772
  ledctl_reg = ledctl_reg & (u32 )(~ (15 << (int )(index * 8U)));
#line 773
  ledctl_reg = ledctl_reg | (u32 )(128 << (int )(index * 8U));
#line 774
  ixgbe_write_reg(hw, 512U, ledctl_reg);
#line 775
  ixgbe_read_reg(hw, 8U);
  }
#line 777
  return (0);
}
}
#line 788 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw , u32 index ) 
{ 
  u32 macc_reg ;
  u32 ledctl_reg ;

  {
  {
#line 794
  ledctl_reg = ixgbe_read_reg(hw, 512U);
#line 795
  ledctl_reg = ledctl_reg & (u32 )(~ (15 << (int )(index * 8U)));
#line 796
  ledctl_reg = ledctl_reg | (u32 )(4 << (int )(index * 8U));
#line 797
  ledctl_reg = ledctl_reg & (u32 )(~ (128 << (int )(index * 8U)));
#line 798
  ixgbe_write_reg(hw, 512U, ledctl_reg);
#line 801
  macc_reg = ixgbe_read_reg(hw, 17200U);
#line 802
  macc_reg = macc_reg & 4294508542U;
#line 803
  ixgbe_write_reg(hw, 17200U, macc_reg);
#line 804
  ixgbe_read_reg(hw, 8U);
  }
#line 806
  return (0);
}
}
#line 808 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_mac_operations mac_ops_X540  = 
#line 808
     {& ixgbe_init_hw_generic, & ixgbe_reset_hw_X540, & ixgbe_start_hw_X540, & ixgbe_clear_hw_cntrs_generic,
    & ixgbe_get_media_type_X540, & ixgbe_get_supported_physical_layer_X540, & ixgbe_get_mac_addr_generic,
    & ixgbe_get_san_mac_addr_generic, & ixgbe_get_device_caps_generic, & ixgbe_get_wwn_prefix_generic,
    & ixgbe_stop_adapter_generic, & ixgbe_get_bus_info_generic, & ixgbe_set_lan_id_multi_port_pcie,
    (s32 (*)(struct ixgbe_hw * , u32  , u8 * ))0, (s32 (*)(struct ixgbe_hw * , u32  ,
                                                           u8  ))0, (s32 (*)(struct ixgbe_hw * ))0,
    & ixgbe_disable_rx_buff_generic, & ixgbe_enable_rx_buff_generic, & ixgbe_enable_rx_dma_generic,
    & ixgbe_acquire_swfw_sync_X540, & ixgbe_release_swfw_sync_X540, 0, 0, 0, 0, & ixgbe_setup_mac_link_X540,
    & ixgbe_check_mac_link_generic, & ixgbe_get_copper_link_capabilities_generic,
    & ixgbe_set_rxpba_generic, & ixgbe_led_on_generic, & ixgbe_led_off_generic, & ixgbe_blink_led_start_X540,
    & ixgbe_blink_led_stop_X540, & ixgbe_set_rar_generic, & ixgbe_clear_rar_generic,
    & ixgbe_set_vmdq_generic, & ixgbe_set_vmdq_san_mac_generic, & ixgbe_clear_vmdq_generic,
    & ixgbe_init_rx_addrs_generic, & ixgbe_update_mc_addr_list_generic, & ixgbe_enable_mc_generic,
    & ixgbe_disable_mc_generic, & ixgbe_clear_vfta_generic, & ixgbe_set_vfta_generic,
    & ixgbe_init_uta_tables_generic, & ixgbe_set_mac_anti_spoofing, & ixgbe_set_vlan_anti_spoofing,
    & ixgbe_fc_enable_generic, & ixgbe_set_fw_drv_ver_generic, (s32 (*)(struct ixgbe_hw * ))0,
    (s32 (*)(struct ixgbe_hw * ))0, (bool (*)(struct ixgbe_hw * ))0};
#line 860 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_eeprom_operations eeprom_ops_X540  = 
#line 860
     {& ixgbe_init_eeprom_params_X540, & ixgbe_read_eerd_X540, & ixgbe_read_eerd_buffer_X540,
    & ixgbe_write_eewr_X540, & ixgbe_write_eewr_buffer_X540, & ixgbe_validate_eeprom_checksum_X540,
    & ixgbe_update_eeprom_checksum_X540, & ixgbe_calc_eeprom_checksum_X540};
#line 871 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
static struct ixgbe_phy_operations phy_ops_X540  = 
#line 871
     {& ixgbe_identify_phy_generic, & ixgbe_identify_sfp_module_generic, (s32 (*)(struct ixgbe_hw * ))0,
    (s32 (*)(struct ixgbe_hw * ))0, & ixgbe_read_phy_reg_generic, & ixgbe_write_phy_reg_generic,
    0, 0, & ixgbe_setup_phy_link_generic, & ixgbe_setup_phy_link_speed_generic, 0,
    & ixgbe_get_phy_firmware_version_generic, & ixgbe_read_i2c_byte_generic, & ixgbe_write_i2c_byte_generic,
    & ixgbe_read_i2c_sff8472_generic, & ixgbe_read_i2c_eeprom_generic, & ixgbe_write_i2c_eeprom_generic,
    & ixgbe_tn_check_overtemp};
#line 889 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c"
struct ixgbe_info ixgbe_X540_info  =    {3, & ixgbe_get_invariants_X540, & mac_ops_X540, & eeprom_ops_X540, & phy_ops_X540,
    & mbx_ops_generic};
#line 361 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_104(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 362
  ixgbe_read_phy_reg_generic(arg1, arg2, arg3, arg4);
  }
#line 363
  return;
}
}
#line 366 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_110(void (*arg0)(struct ixgbe_hw * ,
                                                                  unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 367
  ixgbe_release_swfw_sync_X540(arg1, (int )arg2);
  }
#line 368
  return;
}
}
#line 371 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 372
  ixgbe_reset_hw_X540(arg1);
  }
#line 373
  return;
}
}
#line 376 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_115(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ,
                                                     unsigned char arg5 ) 
{ 


  {
  {
#line 377
  ixgbe_set_fw_drv_ver_generic(arg1, (int )arg2, (int )arg3, (int )arg4, (int )arg5);
  }
#line 378
  return;
}
}
#line 381 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_119(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) 
{ 


  {
  {
#line 382
  ixgbe_set_mac_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 383
  return;
}
}
#line 386 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_122(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char *arg3 , unsigned int arg4 ,
                                                     unsigned int arg5 ) 
{ 


  {
  {
#line 387
  ixgbe_set_rar_generic(arg1, arg2, arg3, arg4, arg5);
  }
#line 388
  return;
}
}
#line 391 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_125(void (*arg0)(struct ixgbe_hw * ,
                                                                  int  , unsigned int  ,
                                                                  int  ) , struct ixgbe_hw *arg1 ,
                                                     int arg2 , unsigned int arg3 ,
                                                     int arg4 ) 
{ 


  {
  {
#line 392
  ixgbe_set_rxpba_generic(arg1, arg2, arg3, arg4);
  }
#line 393
  return;
}
}
#line 396 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_128(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 _Bool  ) , struct ixgbe_hw *arg1 ,
                                                     unsigned int arg2 , unsigned int arg3 ,
                                                     _Bool arg4 ) 
{ 


  {
  {
#line 397
  ixgbe_set_vfta_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 398
  return;
}
}
#line 401 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_131(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) 
{ 


  {
  {
#line 402
  ixgbe_set_vlan_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 403
  return;
}
}
#line 406 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_134(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 ) 
{ 


  {
  {
#line 407
  ixgbe_set_vmdq_generic(arg1, arg2, arg3);
  }
#line 408
  return;
}
}
#line 411 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_137(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 412
  ixgbe_set_vmdq_san_mac_generic(arg1, arg2);
  }
#line 413
  return;
}
}
#line 416 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 417
  ixgbe_setup_phy_link_generic(arg1);
  }
#line 418
  return;
}
}
#line 421 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_141(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , _Bool  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     _Bool arg3 ) 
{ 


  {
  {
#line 422
  ixgbe_setup_mac_link_X540(arg1, arg2, (int )arg3);
  }
#line 423
  return;
}
}
#line 426 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 427
  ixgbe_start_hw_X540(arg1);
  }
#line 428
  return;
}
}
#line 431 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 432
  ixgbe_stop_adapter_generic(arg1);
  }
#line 433
  return;
}
}
#line 436 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_149(int (*arg0)(struct ixgbe_hw * ,
                                                                 struct net_device * ) ,
                                                     struct ixgbe_hw *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 437
  ixgbe_update_mc_addr_list_generic(arg1, arg2);
  }
#line 438
  return;
}
}
#line 441 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_159(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                     unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 442
  ixgbe_write_eewr_buffer_X540(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 443
  return;
}
}
#line 446 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_162(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ) 
{ 


  {
  {
#line 447
  ixgbe_write_i2c_byte_generic(arg1, (int )arg2, (int )arg3, (int )arg4);
  }
#line 448
  return;
}
}
#line 451 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_165(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 ) 
{ 


  {
  {
#line 452
  ixgbe_write_i2c_eeprom_generic(arg1, (int )arg2, (int )arg3);
  }
#line 453
  return;
}
}
#line 456 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_171(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 457
  ixgbe_write_phy_reg_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 458
  return;
}
}
#line 461 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_25(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int *arg2 , _Bool *arg3 ,
                                                    _Bool arg4 ) 
{ 


  {
  {
#line 462
  ixgbe_check_mac_link_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 463
  return;
}
}
#line 466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 467
  ixgbe_tn_check_overtemp(arg1);
  }
#line 468
  return;
}
}
#line 471 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 472
  ixgbe_clear_hw_cntrs_generic(arg1);
  }
#line 473
  return;
}
}
#line 476 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_30(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 477
  ixgbe_clear_rar_generic(arg1, arg2);
  }
#line 478
  return;
}
}
#line 481 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 482
  ixgbe_clear_vfta_generic(arg1);
  }
#line 483
  return;
}
}
#line 486 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_34(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) 
{ 


  {
  {
#line 487
  ixgbe_clear_vmdq_generic(arg1, arg2, arg3);
  }
#line 488
  return;
}
}
#line 491 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 492
  ixgbe_disable_mc_generic(arg1);
  }
#line 493
  return;
}
}
#line 496 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 497
  ixgbe_disable_rx_buff_generic(arg1);
  }
#line 498
  return;
}
}
#line 501 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 502
  ixgbe_enable_mc_generic(arg1);
  }
#line 503
  return;
}
}
#line 506 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 507
  ixgbe_enable_rx_buff_generic(arg1);
  }
#line 508
  return;
}
}
#line 511 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_41(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 512
  ixgbe_enable_rx_dma_generic(arg1, arg2);
  }
#line 513
  return;
}
}
#line 516 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 517
  ixgbe_fc_enable_generic(arg1);
  }
#line 518
  return;
}
}
#line 521 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 522
  ixgbe_get_bus_info_generic(arg1);
  }
#line 523
  return;
}
}
#line 526 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_46(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 527
  ixgbe_get_device_caps_generic(arg1, arg2);
  }
#line 528
  return;
}
}
#line 531 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_49(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 532
  ixgbe_get_phy_firmware_version_generic(arg1, arg2);
  }
#line 533
  return;
}
}
#line 536 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 537
  ixgbe_get_invariants_X540(arg1);
  }
#line 538
  return;
}
}
#line 541 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_56(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 542
  ixgbe_get_mac_addr_generic(arg1, arg2);
  }
#line 543
  return;
}
}
#line 546 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 547
  ixgbe_get_media_type_X540(arg1);
  }
#line 548
  return;
}
}
#line 551 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_60(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 552
  ixgbe_get_san_mac_addr_generic(arg1, arg2);
  }
#line 553
  return;
}
}
#line 556 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 557
  ixgbe_get_supported_physical_layer_X540(arg1);
  }
#line 558
  return;
}
}
#line 561 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_65(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                    unsigned short *arg3 ) 
{ 


  {
  {
#line 562
  ixgbe_get_wwn_prefix_generic(arg1, arg2, arg3);
  }
#line 563
  return;
}
}
#line 566 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 567
  ixgbe_identify_phy_generic(arg1);
  }
#line 568
  return;
}
}
#line 571 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 572
  ixgbe_identify_sfp_module_generic(arg1);
  }
#line 573
  return;
}
}
#line 576 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 577
  ixgbe_init_hw_generic(arg1);
  }
#line 578
  return;
}
}
#line 581 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 582
  ixgbe_init_rx_addrs_generic(arg1);
  }
#line 583
  return;
}
}
#line 586 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 587
  ixgbe_init_uta_tables_generic(arg1);
  }
#line 588
  return;
}
}
#line 591 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_76(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 592
  ixgbe_led_off_generic(arg1, arg2);
  }
#line 593
  return;
}
}
#line 596 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_79(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 597
  ixgbe_led_on_generic(arg1, arg2);
  }
#line 598
  return;
}
}
#line 601 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_92(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char *arg4 ) 
{ 


  {
  {
#line 602
  ixgbe_read_i2c_byte_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 603
  return;
}
}
#line 606 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_95(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 607
  ixgbe_read_i2c_eeprom_generic(arg1, (int )arg2, arg3);
  }
#line 608
  return;
}
}
#line 611 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_10_98(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 612
  ixgbe_read_i2c_sff8472_generic(arg1, (int )arg2, arg3);
  }
#line 613
  return;
}
}
#line 616 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_104(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 617
  ixgbe_read_phy_reg_generic(arg1, arg2, arg3, arg4);
  }
#line 618
  return;
}
}
#line 621 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_110(void (*arg0)(struct ixgbe_hw * ,
                                                                  unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 622
  ixgbe_release_swfw_sync_X540(arg1, (int )arg2);
  }
#line 623
  return;
}
}
#line 626 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 627
  ixgbe_reset_hw_X540(arg1);
  }
#line 628
  return;
}
}
#line 631 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_115(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ,
                                                     unsigned char arg5 ) 
{ 


  {
  {
#line 632
  ixgbe_set_fw_drv_ver_generic(arg1, (int )arg2, (int )arg3, (int )arg4, (int )arg5);
  }
#line 633
  return;
}
}
#line 636 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_119(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) 
{ 


  {
  {
#line 637
  ixgbe_set_mac_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 638
  return;
}
}
#line 641 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_122(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char *arg3 , unsigned int arg4 ,
                                                     unsigned int arg5 ) 
{ 


  {
  {
#line 642
  ixgbe_set_rar_generic(arg1, arg2, arg3, arg4, arg5);
  }
#line 643
  return;
}
}
#line 646 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_125(void (*arg0)(struct ixgbe_hw * ,
                                                                  int  , unsigned int  ,
                                                                  int  ) , struct ixgbe_hw *arg1 ,
                                                     int arg2 , unsigned int arg3 ,
                                                     int arg4 ) 
{ 


  {
  {
#line 647
  ixgbe_set_rxpba_generic(arg1, arg2, arg3, arg4);
  }
#line 648
  return;
}
}
#line 651 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_128(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 _Bool  ) , struct ixgbe_hw *arg1 ,
                                                     unsigned int arg2 , unsigned int arg3 ,
                                                     _Bool arg4 ) 
{ 


  {
  {
#line 652
  ixgbe_set_vfta_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 653
  return;
}
}
#line 656 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_131(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) 
{ 


  {
  {
#line 657
  ixgbe_set_vlan_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 658
  return;
}
}
#line 661 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_134(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 ) 
{ 


  {
  {
#line 662
  ixgbe_set_vmdq_generic(arg1, arg2, arg3);
  }
#line 663
  return;
}
}
#line 666 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_137(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 667
  ixgbe_set_vmdq_san_mac_generic(arg1, arg2);
  }
#line 668
  return;
}
}
#line 671 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 672
  ixgbe_setup_phy_link_generic(arg1);
  }
#line 673
  return;
}
}
#line 676 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_141(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , _Bool  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     _Bool arg3 ) 
{ 


  {
  {
#line 677
  ixgbe_setup_phy_link_speed_generic(arg1, arg2, (int )arg3);
  }
#line 678
  return;
}
}
#line 681 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 682
  ixgbe_start_hw_X540(arg1);
  }
#line 683
  return;
}
}
#line 686 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 687
  ixgbe_stop_adapter_generic(arg1);
  }
#line 688
  return;
}
}
#line 691 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_149(int (*arg0)(struct ixgbe_hw * ,
                                                                 struct net_device * ) ,
                                                     struct ixgbe_hw *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 692
  ixgbe_update_mc_addr_list_generic(arg1, arg2);
  }
#line 693
  return;
}
}
#line 696 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 697
  ixgbe_calc_eeprom_checksum_X540(arg1);
  }
#line 698
  return;
}
}
#line 701 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_159(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                     unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 702
  ixgbe_write_eewr_buffer_X540(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 703
  return;
}
}
#line 706 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_162(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ) 
{ 


  {
  {
#line 707
  ixgbe_write_i2c_byte_generic(arg1, (int )arg2, (int )arg3, (int )arg4);
  }
#line 708
  return;
}
}
#line 711 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_165(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 ) 
{ 


  {
  {
#line 712
  ixgbe_write_i2c_eeprom_generic(arg1, (int )arg2, (int )arg3);
  }
#line 713
  return;
}
}
#line 716 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_171(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 717
  ixgbe_write_phy_reg_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 718
  return;
}
}
#line 721 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 722
  ixgbe_tn_check_overtemp(arg1);
  }
#line 723
  return;
}
}
#line 726 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 727
  ixgbe_clear_hw_cntrs_generic(arg1);
  }
#line 728
  return;
}
}
#line 731 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_30(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 732
  ixgbe_clear_rar_generic(arg1, arg2);
  }
#line 733
  return;
}
}
#line 736 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 737
  ixgbe_disable_mc_generic(arg1);
  }
#line 738
  return;
}
}
#line 741 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 742
  ixgbe_disable_rx_buff_generic(arg1);
  }
#line 743
  return;
}
}
#line 746 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 747
  ixgbe_enable_mc_generic(arg1);
  }
#line 748
  return;
}
}
#line 751 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 752
  ixgbe_enable_rx_buff_generic(arg1);
  }
#line 753
  return;
}
}
#line 756 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 757
  ixgbe_get_bus_info_generic(arg1);
  }
#line 758
  return;
}
}
#line 761 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_46(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 762
  ixgbe_get_device_caps_generic(arg1, arg2);
  }
#line 763
  return;
}
}
#line 766 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_49(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 767
  ixgbe_get_phy_firmware_version_generic(arg1, arg2);
  }
#line 768
  return;
}
}
#line 771 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_56(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 772
  ixgbe_get_mac_addr_generic(arg1, arg2);
  }
#line 773
  return;
}
}
#line 776 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 777
  ixgbe_get_media_type_X540(arg1);
  }
#line 778
  return;
}
}
#line 781 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_60(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 782
  ixgbe_get_san_mac_addr_generic(arg1, arg2);
  }
#line 783
  return;
}
}
#line 786 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 787
  ixgbe_get_supported_physical_layer_X540(arg1);
  }
#line 788
  return;
}
}
#line 791 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_65(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                    unsigned short *arg3 ) 
{ 


  {
  {
#line 792
  ixgbe_get_wwn_prefix_generic(arg1, arg2, arg3);
  }
#line 793
  return;
}
}
#line 796 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 797
  ixgbe_identify_phy_generic(arg1);
  }
#line 798
  return;
}
}
#line 801 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 802
  ixgbe_identify_sfp_module_generic(arg1);
  }
#line 803
  return;
}
}
#line 806 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 807
  ixgbe_init_hw_generic(arg1);
  }
#line 808
  return;
}
}
#line 811 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 812
  ixgbe_init_rx_addrs_generic(arg1);
  }
#line 813
  return;
}
}
#line 816 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 817
  ixgbe_init_uta_tables_generic(arg1);
  }
#line 818
  return;
}
}
#line 821 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_76(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 822
  ixgbe_led_off_generic(arg1, arg2);
  }
#line 823
  return;
}
}
#line 826 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_79(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 827
  ixgbe_led_on_generic(arg1, arg2);
  }
#line 828
  return;
}
}
#line 831 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_92(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char *arg4 ) 
{ 


  {
  {
#line 832
  ixgbe_read_i2c_byte_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 833
  return;
}
}
#line 836 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_95(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 837
  ixgbe_read_i2c_eeprom_generic(arg1, (int )arg2, arg3);
  }
#line 838
  return;
}
}
#line 841 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_11_98(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 842
  ixgbe_read_i2c_sff8472_generic(arg1, (int )arg2, arg3);
  }
#line 843
  return;
}
}
#line 846 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_104(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 847
  ixgbe_read_phy_reg_generic(arg1, arg2, arg3, arg4);
  }
#line 848
  return;
}
}
#line 851 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_110(void (*arg0)(struct ixgbe_hw * ,
                                                                  unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 852
  ixgbe_release_swfw_sync_X540(arg1, (int )arg2);
  }
#line 853
  return;
}
}
#line 856 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 857
  ixgbe_reset_hw_X540(arg1);
  }
#line 858
  return;
}
}
#line 861 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_115(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ,
                                                     unsigned char arg5 ) 
{ 


  {
  {
#line 862
  ixgbe_set_fw_drv_ver_generic(arg1, (int )arg2, (int )arg3, (int )arg4, (int )arg5);
  }
#line 863
  return;
}
}
#line 866 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_119(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) 
{ 


  {
  {
#line 867
  ixgbe_set_mac_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 868
  return;
}
}
#line 871 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_122(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char *arg3 , unsigned int arg4 ,
                                                     unsigned int arg5 ) 
{ 


  {
  {
#line 872
  ixgbe_set_rar_generic(arg1, arg2, arg3, arg4, arg5);
  }
#line 873
  return;
}
}
#line 876 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_125(void (*arg0)(struct ixgbe_hw * ,
                                                                  int  , unsigned int  ,
                                                                  int  ) , struct ixgbe_hw *arg1 ,
                                                     int arg2 , unsigned int arg3 ,
                                                     int arg4 ) 
{ 


  {
  {
#line 877
  ixgbe_set_rxpba_generic(arg1, arg2, arg3, arg4);
  }
#line 878
  return;
}
}
#line 881 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_128(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 _Bool  ) , struct ixgbe_hw *arg1 ,
                                                     unsigned int arg2 , unsigned int arg3 ,
                                                     _Bool arg4 ) 
{ 


  {
  {
#line 882
  ixgbe_set_vfta_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 883
  return;
}
}
#line 886 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_131(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) 
{ 


  {
  {
#line 887
  ixgbe_set_vlan_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 888
  return;
}
}
#line 891 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_134(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 ) 
{ 


  {
  {
#line 892
  ixgbe_set_vmdq_generic(arg1, arg2, arg3);
  }
#line 893
  return;
}
}
#line 896 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_137(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 897
  ixgbe_set_vmdq_san_mac_generic(arg1, arg2);
  }
#line 898
  return;
}
}
#line 901 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 902
  ixgbe_setup_phy_link_generic(arg1);
  }
#line 903
  return;
}
}
#line 906 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_141(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , _Bool  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     _Bool arg3 ) 
{ 


  {
  {
#line 907
  ixgbe_setup_phy_link_speed_generic(arg1, arg2, (int )arg3);
  }
#line 908
  return;
}
}
#line 911 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 912
  ixgbe_start_hw_X540(arg1);
  }
#line 913
  return;
}
}
#line 916 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 917
  ixgbe_stop_adapter_generic(arg1);
  }
#line 918
  return;
}
}
#line 921 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_149(int (*arg0)(struct ixgbe_hw * ,
                                                                 struct net_device * ) ,
                                                     struct ixgbe_hw *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 922
  ixgbe_update_mc_addr_list_generic(arg1, arg2);
  }
#line 923
  return;
}
}
#line 926 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 927
  ixgbe_calc_eeprom_checksum_X540(arg1);
  }
#line 928
  return;
}
}
#line 931 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_159(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                     unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 932
  ixgbe_write_eewr_buffer_X540(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 933
  return;
}
}
#line 936 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_162(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ) 
{ 


  {
  {
#line 937
  ixgbe_write_i2c_byte_generic(arg1, (int )arg2, (int )arg3, (int )arg4);
  }
#line 938
  return;
}
}
#line 941 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_165(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 ) 
{ 


  {
  {
#line 942
  ixgbe_write_i2c_eeprom_generic(arg1, (int )arg2, (int )arg3);
  }
#line 943
  return;
}
}
#line 946 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_171(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 947
  ixgbe_write_phy_reg_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 948
  return;
}
}
#line 951 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 952
  ixgbe_tn_check_overtemp(arg1);
  }
#line 953
  return;
}
}
#line 956 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 957
  ixgbe_clear_hw_cntrs_generic(arg1);
  }
#line 958
  return;
}
}
#line 961 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_30(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 962
  ixgbe_clear_rar_generic(arg1, arg2);
  }
#line 963
  return;
}
}
#line 966 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 967
  ixgbe_disable_mc_generic(arg1);
  }
#line 968
  return;
}
}
#line 971 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 972
  ixgbe_disable_rx_buff_generic(arg1);
  }
#line 973
  return;
}
}
#line 976 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 977
  ixgbe_enable_mc_generic(arg1);
  }
#line 978
  return;
}
}
#line 981 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 982
  ixgbe_enable_rx_buff_generic(arg1);
  }
#line 983
  return;
}
}
#line 986 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 987
  ixgbe_get_bus_info_generic(arg1);
  }
#line 988
  return;
}
}
#line 991 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_46(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 992
  ixgbe_get_device_caps_generic(arg1, arg2);
  }
#line 993
  return;
}
}
#line 996 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_49(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 997
  ixgbe_get_phy_firmware_version_generic(arg1, arg2);
  }
#line 998
  return;
}
}
#line 1001 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1002
  ixgbe_get_invariants_X540(arg1);
  }
#line 1003
  return;
}
}
#line 1006 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_56(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 1007
  ixgbe_get_mac_addr_generic(arg1, arg2);
  }
#line 1008
  return;
}
}
#line 1011 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_59(enum ixgbe_media_type (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1012
  ixgbe_get_media_type_X540(arg1);
  }
#line 1013
  return;
}
}
#line 1016 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_60(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 1017
  ixgbe_get_san_mac_addr_generic(arg1, arg2);
  }
#line 1018
  return;
}
}
#line 1021 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_63(unsigned int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1022
  ixgbe_get_supported_physical_layer_X540(arg1);
  }
#line 1023
  return;
}
}
#line 1026 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_65(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                    unsigned short *arg3 ) 
{ 


  {
  {
#line 1027
  ixgbe_get_wwn_prefix_generic(arg1, arg2, arg3);
  }
#line 1028
  return;
}
}
#line 1031 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1032
  ixgbe_identify_phy_generic(arg1);
  }
#line 1033
  return;
}
}
#line 1036 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1037
  ixgbe_identify_sfp_module_generic(arg1);
  }
#line 1038
  return;
}
}
#line 1041 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1042
  ixgbe_init_hw_generic(arg1);
  }
#line 1043
  return;
}
}
#line 1046 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1047
  ixgbe_init_rx_addrs_generic(arg1);
  }
#line 1048
  return;
}
}
#line 1051 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1052
  ixgbe_init_uta_tables_generic(arg1);
  }
#line 1053
  return;
}
}
#line 1056 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_76(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 1057
  ixgbe_led_off_generic(arg1, arg2);
  }
#line 1058
  return;
}
}
#line 1061 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_79(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 1062
  ixgbe_led_on_generic(arg1, arg2);
  }
#line 1063
  return;
}
}
#line 1066 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_92(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char *arg4 ) 
{ 


  {
  {
#line 1067
  ixgbe_read_i2c_byte_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 1068
  return;
}
}
#line 1071 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_95(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 1072
  ixgbe_read_i2c_eeprom_generic(arg1, (int )arg2, arg3);
  }
#line 1073
  return;
}
}
#line 1076 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_12_98(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 1077
  ixgbe_read_i2c_sff8472_generic(arg1, (int )arg2, arg3);
  }
#line 1078
  return;
}
}
#line 1081 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_104(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 1082
  ixgbe_read_phy_reg_generic(arg1, arg2, arg3, arg4);
  }
#line 1083
  return;
}
}
#line 1086 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_110(void (*arg0)(struct ixgbe_hw * ,
                                                                  unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 1087
  ixgbe_release_swfw_sync_X540(arg1, (int )arg2);
  }
#line 1088
  return;
}
}
#line 1091 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_114(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1092
  ixgbe_reset_hw_X540(arg1);
  }
#line 1093
  return;
}
}
#line 1096 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_115(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ,
                                                     unsigned char arg5 ) 
{ 


  {
  {
#line 1097
  ixgbe_set_fw_drv_ver_generic(arg1, (int )arg2, (int )arg3, (int )arg4, (int )arg5);
  }
#line 1098
  return;
}
}
#line 1101 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_119(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) 
{ 


  {
  {
#line 1102
  ixgbe_set_mac_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 1103
  return;
}
}
#line 1106 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_122(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned char * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned char *arg3 , unsigned int arg4 ,
                                                     unsigned int arg5 ) 
{ 


  {
  {
#line 1107
  ixgbe_set_rar_generic(arg1, arg2, arg3, arg4, arg5);
  }
#line 1108
  return;
}
}
#line 1111 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_125(void (*arg0)(struct ixgbe_hw * ,
                                                                  int  , unsigned int  ,
                                                                  int  ) , struct ixgbe_hw *arg1 ,
                                                     int arg2 , unsigned int arg3 ,
                                                     int arg4 ) 
{ 


  {
  {
#line 1112
  ixgbe_set_rxpba_generic(arg1, arg2, arg3, arg4);
  }
#line 1113
  return;
}
}
#line 1116 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_128(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 _Bool  ) , struct ixgbe_hw *arg1 ,
                                                     unsigned int arg2 , unsigned int arg3 ,
                                                     _Bool arg4 ) 
{ 


  {
  {
#line 1117
  ixgbe_set_vfta_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 1118
  return;
}
}
#line 1121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_131(void (*arg0)(struct ixgbe_hw * ,
                                                                  _Bool  , int  ) ,
                                                     struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                     int arg3 ) 
{ 


  {
  {
#line 1122
  ixgbe_set_vlan_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 1123
  return;
}
}
#line 1126 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_134(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 ) 
{ 


  {
  {
#line 1127
  ixgbe_set_vmdq_generic(arg1, arg2, arg3);
  }
#line 1128
  return;
}
}
#line 1131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_137(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 1132
  ixgbe_set_vmdq_san_mac_generic(arg1, arg2);
  }
#line 1133
  return;
}
}
#line 1136 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1137
  ixgbe_setup_phy_link_generic(arg1);
  }
#line 1138
  return;
}
}
#line 1141 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_141(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , _Bool  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     _Bool arg3 ) 
{ 


  {
  {
#line 1142
  ixgbe_setup_phy_link_speed_generic(arg1, arg2, (int )arg3);
  }
#line 1143
  return;
}
}
#line 1146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_145(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1147
  ixgbe_start_hw_X540(arg1);
  }
#line 1148
  return;
}
}
#line 1151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                     struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1152
  ixgbe_stop_adapter_generic(arg1);
  }
#line 1153
  return;
}
}
#line 1156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_149(int (*arg0)(struct ixgbe_hw * ,
                                                                 struct net_device * ) ,
                                                     struct ixgbe_hw *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 1157
  ixgbe_update_mc_addr_list_generic(arg1, arg2);
  }
#line 1158
  return;
}
}
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1162
  ixgbe_calc_eeprom_checksum_X540(arg1);
  }
#line 1163
  return;
}
}
#line 1166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_159(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ,
                                                                 unsigned short  ,
                                                                 unsigned short * ) ,
                                                     struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                     unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 1167
  ixgbe_write_eewr_buffer_X540(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 1168
  return;
}
}
#line 1171 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_162(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 , unsigned char arg4 ) 
{ 


  {
  {
#line 1172
  ixgbe_write_i2c_byte_generic(arg1, (int )arg2, (int )arg3, (int )arg4);
  }
#line 1173
  return;
}
}
#line 1176 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_165(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                     unsigned char arg3 ) 
{ 


  {
  {
#line 1177
  ixgbe_write_i2c_eeprom_generic(arg1, (int )arg2, (int )arg3);
  }
#line 1178
  return;
}
}
#line 1181 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_171(int (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned int  , unsigned int  ,
                                                                 unsigned short  ) ,
                                                     struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                     unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 1182
  ixgbe_write_phy_reg_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 1183
  return;
}
}
#line 1186 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1187
  ixgbe_tn_check_overtemp(arg1);
  }
#line 1188
  return;
}
}
#line 1191 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1192
  ixgbe_clear_hw_cntrs_generic(arg1);
  }
#line 1193
  return;
}
}
#line 1196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_30(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 1197
  ixgbe_clear_rar_generic(arg1, arg2);
  }
#line 1198
  return;
}
}
#line 1201 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1202
  ixgbe_disable_mc_generic(arg1);
  }
#line 1203
  return;
}
}
#line 1206 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1207
  ixgbe_disable_rx_buff_generic(arg1);
  }
#line 1208
  return;
}
}
#line 1211 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1212
  ixgbe_enable_mc_generic(arg1);
  }
#line 1213
  return;
}
}
#line 1216 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1217
  ixgbe_enable_rx_buff_generic(arg1);
  }
#line 1218
  return;
}
}
#line 1221 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1222
  ixgbe_get_bus_info_generic(arg1);
  }
#line 1223
  return;
}
}
#line 1226 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_46(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 1227
  ixgbe_get_device_caps_generic(arg1, arg2);
  }
#line 1228
  return;
}
}
#line 1231 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_49(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 1232
  ixgbe_get_phy_firmware_version_generic(arg1, arg2);
  }
#line 1233
  return;
}
}
#line 1236 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_53(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int * , _Bool * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                    _Bool *arg3 ) 
{ 


  {
  {
#line 1237
  ixgbe_get_copper_link_capabilities_generic(arg1, arg2, arg3);
  }
#line 1238
  return;
}
}
#line 1241 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_56(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 1242
  ixgbe_get_mac_addr_generic(arg1, arg2);
  }
#line 1243
  return;
}
}
#line 1246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_60(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 1247
  ixgbe_get_san_mac_addr_generic(arg1, arg2);
  }
#line 1248
  return;
}
}
#line 1251 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_65(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                    unsigned short *arg3 ) 
{ 


  {
  {
#line 1252
  ixgbe_get_wwn_prefix_generic(arg1, arg2, arg3);
  }
#line 1253
  return;
}
}
#line 1256 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1257
  ixgbe_identify_phy_generic(arg1);
  }
#line 1258
  return;
}
}
#line 1261 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1262
  ixgbe_identify_sfp_module_generic(arg1);
  }
#line 1263
  return;
}
}
#line 1266 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1267
  ixgbe_init_hw_generic(arg1);
  }
#line 1268
  return;
}
}
#line 1271 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1272
  ixgbe_init_rx_addrs_generic(arg1);
  }
#line 1273
  return;
}
}
#line 1276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1277
  ixgbe_init_uta_tables_generic(arg1);
  }
#line 1278
  return;
}
}
#line 1281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_76(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 1282
  ixgbe_led_off_generic(arg1, arg2);
  }
#line 1283
  return;
}
}
#line 1286 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_79(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 1287
  ixgbe_led_on_generic(arg1, arg2);
  }
#line 1288
  return;
}
}
#line 1291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_92(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char *arg4 ) 
{ 


  {
  {
#line 1292
  ixgbe_read_i2c_byte_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 1293
  return;
}
}
#line 1296 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_95(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 1297
  ixgbe_read_i2c_eeprom_generic(arg1, (int )arg2, arg3);
  }
#line 1298
  return;
}
}
#line 1301 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_13_98(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char *arg3 ) 
{ 


  {
  {
#line 1302
  ixgbe_read_i2c_sff8472_generic(arg1, (int )arg2, arg3);
  }
#line 1303
  return;
}
}
#line 1306 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_104(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 1307
  ixgbe_read_phy_reg_generic(arg1, arg2, arg3, arg4);
  }
#line 1308
  return;
}
}
#line 1311 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_115(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ,
                                                    unsigned char arg5 ) 
{ 


  {
  {
#line 1312
  ixgbe_set_fw_drv_ver_generic(arg1, (int )arg2, (int )arg3, (int )arg4, (int )arg5);
  }
#line 1313
  return;
}
}
#line 1316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_118(void (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1317
  ixgbe_set_lan_id_multi_port_pcie(arg1);
  }
#line 1318
  return;
}
}
#line 1321 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_119(void (*arg0)(struct ixgbe_hw * ,
                                                                 _Bool  , int  ) ,
                                                    struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                    int arg3 ) 
{ 


  {
  {
#line 1322
  ixgbe_set_mac_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 1323
  return;
}
}
#line 1326 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_122(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 , unsigned int arg4 ,
                                                    unsigned int arg5 ) 
{ 


  {
  {
#line 1327
  ixgbe_set_rar_generic(arg1, arg2, arg3, arg4, arg5);
  }
#line 1328
  return;
}
}
#line 1331 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_131(void (*arg0)(struct ixgbe_hw * ,
                                                                 _Bool  , int  ) ,
                                                    struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                    int arg3 ) 
{ 


  {
  {
#line 1332
  ixgbe_set_vlan_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 1333
  return;
}
}
#line 1336 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_137(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 1337
  ixgbe_set_vmdq_san_mac_generic(arg1, arg2);
  }
#line 1338
  return;
}
}
#line 1341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1342
  ixgbe_setup_phy_link_generic(arg1);
  }
#line 1343
  return;
}
}
#line 1346 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1347
  ixgbe_stop_adapter_generic(arg1);
  }
#line 1348
  return;
}
}
#line 1351 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_148(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1352
  ixgbe_update_eeprom_checksum_X540(arg1);
  }
#line 1353
  return;
}
}
#line 1356 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_149(int (*arg0)(struct ixgbe_hw * ,
                                                                struct net_device * ) ,
                                                    struct ixgbe_hw *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 1357
  ixgbe_update_mc_addr_list_generic(arg1, arg2);
  }
#line 1358
  return;
}
}
#line 1361 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_15(unsigned short (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1362
  ixgbe_calc_eeprom_checksum_X540(arg1);
  }
#line 1363
  return;
}
}
#line 1366 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_150(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 1367
  ixgbe_validate_eeprom_checksum_X540(arg1, arg2);
  }
#line 1368
  return;
}
}
#line 1371 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_159(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned short  ,
                                                                unsigned short  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ,
                                                    unsigned short arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 1372
  ixgbe_write_eewr_buffer_X540(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 1373
  return;
}
}
#line 1376 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_162(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ) 
{ 


  {
  {
#line 1377
  ixgbe_write_i2c_byte_generic(arg1, (int )arg2, (int )arg3, (int )arg4);
  }
#line 1378
  return;
}
}
#line 1381 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_165(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 1382
  ixgbe_write_i2c_eeprom_generic(arg1, (int )arg2, (int )arg3);
  }
#line 1383
  return;
}
}
#line 1386 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_171(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 1387
  ixgbe_write_phy_reg_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 1388
  return;
}
}
#line 1391 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1392
  ixgbe_tn_check_overtemp(arg1);
  }
#line 1393
  return;
}
}
#line 1396 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1397
  ixgbe_clear_hw_cntrs_generic(arg1);
  }
#line 1398
  return;
}
}
#line 1401 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_30(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1402
  ixgbe_clear_rar_generic(arg1, arg2);
  }
#line 1403
  return;
}
}
#line 1406 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1407
  ixgbe_disable_mc_generic(arg1);
  }
#line 1408
  return;
}
}
#line 1411 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1412
  ixgbe_disable_rx_buff_generic(arg1);
  }
#line 1413
  return;
}
}
#line 1416 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1417
  ixgbe_enable_mc_generic(arg1);
  }
#line 1418
  return;
}
}
#line 1421 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1422
  ixgbe_enable_rx_buff_generic(arg1);
  }
#line 1423
  return;
}
}
#line 1426 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1427
  ixgbe_get_bus_info_generic(arg1);
  }
#line 1428
  return;
}
}
#line 1431 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_46(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 1432
  ixgbe_get_device_caps_generic(arg1, arg2);
  }
#line 1433
  return;
}
}
#line 1436 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_49(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 1437
  ixgbe_get_phy_firmware_version_generic(arg1, arg2);
  }
#line 1438
  return;
}
}
#line 1441 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_53(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , _Bool * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int *arg2 ,
                                                   _Bool *arg3 ) 
{ 


  {
  {
#line 1442
  ixgbe_get_copper_link_capabilities_generic(arg1, arg2, arg3);
  }
#line 1443
  return;
}
}
#line 1446 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_56(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 1447
  ixgbe_get_mac_addr_generic(arg1, arg2);
  }
#line 1448
  return;
}
}
#line 1451 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_60(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 1452
  ixgbe_get_san_mac_addr_generic(arg1, arg2);
  }
#line 1453
  return;
}
}
#line 1456 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_65(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                   unsigned short *arg3 ) 
{ 


  {
  {
#line 1457
  ixgbe_get_wwn_prefix_generic(arg1, arg2, arg3);
  }
#line 1458
  return;
}
}
#line 1461 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1462
  ixgbe_identify_phy_generic(arg1);
  }
#line 1463
  return;
}
}
#line 1466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1467
  ixgbe_identify_sfp_module_generic(arg1);
  }
#line 1468
  return;
}
}
#line 1471 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1472
  ixgbe_init_hw_generic(arg1);
  }
#line 1473
  return;
}
}
#line 1476 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_72(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1477
  ixgbe_init_eeprom_params_X540(arg1);
  }
#line 1478
  return;
}
}
#line 1481 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1482
  ixgbe_init_rx_addrs_generic(arg1);
  }
#line 1483
  return;
}
}
#line 1486 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1487
  ixgbe_init_uta_tables_generic(arg1);
  }
#line 1488
  return;
}
}
#line 1491 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_76(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1492
  ixgbe_led_off_generic(arg1, arg2);
  }
#line 1493
  return;
}
}
#line 1496 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_79(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1497
  ixgbe_led_on_generic(arg1, arg2);
  }
#line 1498
  return;
}
}
#line 1501 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_8_92(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char  ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char arg3 , unsigned char *arg4 ) 
{ 


  {
  {
#line 1502
  ixgbe_read_i2c_byte_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 1503
  return;
}
}
#line 1506 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_104(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short * ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short *arg4 ) 
{ 


  {
  {
#line 1507
  ixgbe_read_phy_reg_generic(arg1, arg2, arg3, arg4);
  }
#line 1508
  return;
}
}
#line 1511 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_110(void (*arg0)(struct ixgbe_hw * ,
                                                                 unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 1512
  ixgbe_release_swfw_sync_X540(arg1, (int )arg2);
  }
#line 1513
  return;
}
}
#line 1516 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_115(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ,
                                                    unsigned char arg5 ) 
{ 


  {
  {
#line 1517
  ixgbe_set_fw_drv_ver_generic(arg1, (int )arg2, (int )arg3, (int )arg4, (int )arg5);
  }
#line 1518
  return;
}
}
#line 1521 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_119(void (*arg0)(struct ixgbe_hw * ,
                                                                 _Bool  , int  ) ,
                                                    struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                    int arg3 ) 
{ 


  {
  {
#line 1522
  ixgbe_set_mac_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 1523
  return;
}
}
#line 1526 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_12(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1527
  ixgbe_blink_led_stop_X540(arg1, arg2);
  }
#line 1528
  return;
}
}
#line 1531 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_122(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned char * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned char *arg3 , unsigned int arg4 ,
                                                    unsigned int arg5 ) 
{ 


  {
  {
#line 1532
  ixgbe_set_rar_generic(arg1, arg2, arg3, arg4, arg5);
  }
#line 1533
  return;
}
}
#line 1536 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_125(void (*arg0)(struct ixgbe_hw * ,
                                                                 int  , unsigned int  ,
                                                                 int  ) , struct ixgbe_hw *arg1 ,
                                                    int arg2 , unsigned int arg3 ,
                                                    int arg4 ) 
{ 


  {
  {
#line 1537
  ixgbe_set_rxpba_generic(arg1, arg2, arg3, arg4);
  }
#line 1538
  return;
}
}
#line 1541 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_128(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                _Bool  ) , struct ixgbe_hw *arg1 ,
                                                    unsigned int arg2 , unsigned int arg3 ,
                                                    _Bool arg4 ) 
{ 


  {
  {
#line 1542
  ixgbe_set_vfta_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 1543
  return;
}
}
#line 1546 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_131(void (*arg0)(struct ixgbe_hw * ,
                                                                 _Bool  , int  ) ,
                                                    struct ixgbe_hw *arg1 , _Bool arg2 ,
                                                    int arg3 ) 
{ 


  {
  {
#line 1547
  ixgbe_set_vlan_anti_spoofing(arg1, (int )arg2, arg3);
  }
#line 1548
  return;
}
}
#line 1551 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_134(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 ) 
{ 


  {
  {
#line 1552
  ixgbe_set_vmdq_generic(arg1, arg2, arg3);
  }
#line 1553
  return;
}
}
#line 1556 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_137(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 1557
  ixgbe_set_vmdq_san_mac_generic(arg1, arg2);
  }
#line 1558
  return;
}
}
#line 1561 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_140(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1562
  ixgbe_setup_phy_link_generic(arg1);
  }
#line 1563
  return;
}
}
#line 1566 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_146(int (*arg0)(struct ixgbe_hw * ) ,
                                                    struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1567
  ixgbe_stop_adapter_generic(arg1);
  }
#line 1568
  return;
}
}
#line 1571 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_149(int (*arg0)(struct ixgbe_hw * ,
                                                                struct net_device * ) ,
                                                    struct ixgbe_hw *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 1572
  ixgbe_update_mc_addr_list_generic(arg1, arg2);
  }
#line 1573
  return;
}
}
#line 1576 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_162(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ,
                                                                unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ) 
{ 


  {
  {
#line 1577
  ixgbe_write_i2c_byte_generic(arg1, (int )arg2, (int )arg3, (int )arg4);
  }
#line 1578
  return;
}
}
#line 1581 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_165(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned char  , unsigned char  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 1582
  ixgbe_write_i2c_eeprom_generic(arg1, (int )arg2, (int )arg3);
  }
#line 1583
  return;
}
}
#line 1586 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_171(int (*arg0)(struct ixgbe_hw * ,
                                                                unsigned int  , unsigned int  ,
                                                                unsigned short  ) ,
                                                    struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                    unsigned int arg3 , unsigned short arg4 ) 
{ 


  {
  {
#line 1587
  ixgbe_write_phy_reg_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 1588
  return;
}
}
#line 1591 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_25(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int * , _Bool * ,
                                                               _Bool  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int *arg2 , _Bool *arg3 ,
                                                   _Bool arg4 ) 
{ 


  {
  {
#line 1592
  ixgbe_check_mac_link_generic(arg1, arg2, arg3, (int )arg4);
  }
#line 1593
  return;
}
}
#line 1596 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_28(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1597
  ixgbe_tn_check_overtemp(arg1);
  }
#line 1598
  return;
}
}
#line 1601 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_29(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1602
  ixgbe_clear_hw_cntrs_generic(arg1);
  }
#line 1603
  return;
}
}
#line 1606 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_3(int (*arg0)(struct ixgbe_hw * ,
                                                              unsigned short  ) ,
                                                  struct ixgbe_hw *arg1 , unsigned short arg2 ) 
{ 


  {
  {
#line 1607
  ixgbe_acquire_swfw_sync_X540(arg1, (int )arg2);
  }
#line 1608
  return;
}
}
#line 1611 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_30(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1612
  ixgbe_clear_rar_generic(arg1, arg2);
  }
#line 1613
  return;
}
}
#line 1616 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_33(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1617
  ixgbe_clear_vfta_generic(arg1);
  }
#line 1618
  return;
}
}
#line 1621 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_34(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  , unsigned int  ) ,
                                                   struct ixgbe_hw *arg1 , unsigned int arg2 ,
                                                   unsigned int arg3 ) 
{ 


  {
  {
#line 1622
  ixgbe_clear_vmdq_generic(arg1, arg2, arg3);
  }
#line 1623
  return;
}
}
#line 1626 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_37(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1627
  ixgbe_disable_mc_generic(arg1);
  }
#line 1628
  return;
}
}
#line 1631 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_38(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1632
  ixgbe_disable_rx_buff_generic(arg1);
  }
#line 1633
  return;
}
}
#line 1636 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_39(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1637
  ixgbe_enable_mc_generic(arg1);
  }
#line 1638
  return;
}
}
#line 1641 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_40(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1642
  ixgbe_enable_rx_buff_generic(arg1);
  }
#line 1643
  return;
}
}
#line 1646 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_41(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1647
  ixgbe_enable_rx_dma_generic(arg1, arg2);
  }
#line 1648
  return;
}
}
#line 1651 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_44(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1652
  ixgbe_fc_enable_generic(arg1);
  }
#line 1653
  return;
}
}
#line 1656 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_45(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1657
  ixgbe_get_bus_info_generic(arg1);
  }
#line 1658
  return;
}
}
#line 1661 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_46(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 1662
  ixgbe_get_device_caps_generic(arg1, arg2);
  }
#line 1663
  return;
}
}
#line 1666 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_49(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ) 
{ 


  {
  {
#line 1667
  ixgbe_get_phy_firmware_version_generic(arg1, arg2);
  }
#line 1668
  return;
}
}
#line 1671 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_52(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1672
  ixgbe_get_invariants_X540(arg1);
  }
#line 1673
  return;
}
}
#line 1676 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_56(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 1677
  ixgbe_get_mac_addr_generic(arg1, arg2);
  }
#line 1678
  return;
}
}
#line 1681 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_60(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 1682
  ixgbe_get_san_mac_addr_generic(arg1, arg2);
  }
#line 1683
  return;
}
}
#line 1686 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_65(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned short * ,
                                                               unsigned short * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned short *arg2 ,
                                                   unsigned short *arg3 ) 
{ 


  {
  {
#line 1687
  ixgbe_get_wwn_prefix_generic(arg1, arg2, arg3);
  }
#line 1688
  return;
}
}
#line 1691 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_68(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1692
  ixgbe_identify_phy_generic(arg1);
  }
#line 1693
  return;
}
}
#line 1696 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_69(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1697
  ixgbe_identify_sfp_module_generic(arg1);
  }
#line 1698
  return;
}
}
#line 1701 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_71(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1702
  ixgbe_init_hw_generic(arg1);
  }
#line 1703
  return;
}
}
#line 1706 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_73(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1707
  ixgbe_init_rx_addrs_generic(arg1);
  }
#line 1708
  return;
}
}
#line 1711 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_75(int (*arg0)(struct ixgbe_hw * ) ,
                                                   struct ixgbe_hw *arg1 ) 
{ 


  {
  {
#line 1712
  ixgbe_init_uta_tables_generic(arg1);
  }
#line 1713
  return;
}
}
#line 1716 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_76(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1717
  ixgbe_led_off_generic(arg1, arg2);
  }
#line 1718
  return;
}
}
#line 1721 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_79(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1722
  ixgbe_led_on_generic(arg1, arg2);
  }
#line 1723
  return;
}
}
#line 1726 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_9(int (*arg0)(struct ixgbe_hw * ,
                                                              unsigned int  ) , struct ixgbe_hw *arg1 ,
                                                  unsigned int arg2 ) 
{ 


  {
  {
#line 1727
  ixgbe_blink_led_start_X540(arg1, arg2);
  }
#line 1728
  return;
}
}
#line 1731 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_92(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char  ,
                                                               unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char arg3 , unsigned char *arg4 ) 
{ 


  {
  {
#line 1732
  ixgbe_read_i2c_byte_generic(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 1733
  return;
}
}
#line 1736 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_95(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 1737
  ixgbe_read_i2c_eeprom_generic(arg1, (int )arg2, arg3);
  }
#line 1738
  return;
}
}
#line 1741 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_x540.c.aux"
void ldv_dummy_resourceless_instance_callback_9_98(int (*arg0)(struct ixgbe_hw * ,
                                                               unsigned char  , unsigned char * ) ,
                                                   struct ixgbe_hw *arg1 , unsigned char arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 1742
  ixgbe_read_i2c_sff8472_generic(arg1, (int )arg2, arg3);
  }
#line 1743
  return;
}
}
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/cpumask.h"
__inline static void cpumask_set_cpu(unsigned int cpu , struct cpumask *dstp ) 
{ 
  unsigned int tmp ;

  {
  {
#line 257
  tmp = cpumask_check(cpu);
#line 257
  set_bit((long )tmp, (unsigned long volatile   *)(& dstp->bits));
  }
#line 258
  return;
}
}
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/rcutree.h"
extern void kfree_call_rcu(struct callback_head * , void (*)(struct callback_head * ) ) ;
#line 57 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/topology.h"
extern int __cpu_to_node(int  ) ;
#line 306 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
extern void *__kmalloc_node(size_t  , gfp_t  , int  ) ;
#line 481 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
__inline static void *kmalloc_node(size_t size , gfp_t flags , int node ) 
{ 
  void *tmp___1 ;

  {
  {
#line 495
  tmp___1 = __kmalloc_node(size, flags, node);
  }
#line 495
  return (tmp___1);
}
}
#line 638
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 653 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/slab.h"
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) 
{ 
  void *tmp ;

  {
  {
#line 655
  tmp = kmalloc_node(size, flags | 32768U, node);
  }
#line 655
  return (tmp);
}
}
#line 466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
extern void napi_hash_add(struct napi_struct * ) ;
#line 475
extern void napi_hash_del(struct napi_struct * ) ;
#line 1510 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
__inline static int netdev_set_tc_queue(struct net_device *dev , u8 tc , u16 count ,
                                        u16 offset ) 
{ 


  {
#line 1512
  if ((int )tc >= (int )dev->num_tc) {
#line 1513
    return (-22);
  } else {

  }
#line 1515
  dev->tc_to_txq[(int )tc].count = count;
#line 1516
  dev->tc_to_txq[(int )tc].offset = offset;
#line 1517
  return (0);
}
}
#line 1634
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int  ) ,
                           int  ) ;
#line 1643
extern void netif_napi_del(struct napi_struct * ) ;
#line 3183
extern int netdev_printk(char const   * , struct net_device  const  * , char const   * 
                         , ...) ;
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
extern int pci_enable_msi_block(struct pci_dev * , int  ) ;
#line 1163
extern void pci_disable_msi(struct pci_dev * ) ;
#line 1165
extern int pci_enable_msix(struct pci_dev * , struct msix_entry * , int  ) ;
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_dcb_sriov(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring_feature *fcoe ;
  struct ixgbe_ring_feature *vmdq ;
  int i ;
  u16 reg_idx ;
  u8 tcs ;
  int tmp ;
  u16 queues_per_pool ;
  u8 fcoe_tc ;
  u8 tmp___0 ;

  {
  {
#line 44
  fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 46
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 49
  tmp = netdev_get_num_tc(adapter->netdev);
#line 49
  tcs = (u8 )tmp;
  }
#line 52
  if ((unsigned int )tcs <= 1U) {
#line 53
    return (0);
  } else {

  }
#line 56
  if ((adapter->flags & 8388608U) == 0U) {
#line 57
    return (0);
  } else {

  }
#line 60
  reg_idx = (int )vmdq->offset * (int )((u16 )(- ((int )vmdq->mask) & (int )vmdq->mask));
#line 61
  i = 0;
#line 61
  goto ldv_50811;
  ldv_50810: ;
#line 63
  if (((int )reg_idx & ~ ((int )vmdq->mask)) >= (int )tcs) {
#line 64
    reg_idx = (u16 )((int )((short )((int )reg_idx + ~ ((int )vmdq->mask))) & (int )((short )vmdq->mask));
  } else {

  }
#line 65
  (adapter->rx_ring[i])->reg_idx = (u8 )reg_idx;
#line 61
  i = i + 1;
#line 61
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_50811: ;
#line 61
  if (i < adapter->num_rx_queues) {
#line 63
    goto ldv_50810;
  } else {

  }
#line 68
  reg_idx = (int )vmdq->offset * (int )((u16 )(- ((int )vmdq->mask) & (int )vmdq->mask));
#line 69
  i = 0;
#line 69
  goto ldv_50814;
  ldv_50813: ;
#line 71
  if (((int )reg_idx & ~ ((int )vmdq->mask)) >= (int )tcs) {
#line 72
    reg_idx = (u16 )((int )((short )((int )reg_idx + ~ ((int )vmdq->mask))) & (int )((short )vmdq->mask));
  } else {

  }
#line 73
  (adapter->tx_ring[i])->reg_idx = (u8 )reg_idx;
#line 69
  i = i + 1;
#line 69
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_50814: ;
#line 69
  if (i < adapter->num_tx_queues) {
#line 71
    goto ldv_50813;
  } else {

  }

#line 78
  if ((adapter->flags & 2097152U) == 0U) {
#line 79
    return (1);
  } else {

  }
#line 82
  if ((int )fcoe->offset < (int )((unsigned short )tcs)) {
#line 83
    return (1);
  } else {

  }
#line 86
  if ((unsigned int )fcoe->indices != 0U) {
    {
#line 87
    queues_per_pool = (u16 )((int )((short )(- ((int )vmdq->mask))) & (int )((short )vmdq->mask));
#line 88
    tmp___0 = ixgbe_fcoe_get_tc(adapter);
#line 88
    fcoe_tc = tmp___0;
#line 90
    reg_idx = (int )((u16 )((int )vmdq->offset + (int )vmdq->indices)) * (int )queues_per_pool;
#line 91
    i = (int )fcoe->offset;
    }
#line 91
    goto ldv_50819;
    ldv_50818: 
#line 92
    reg_idx = (int )((u16 )((int )((short )((int )reg_idx + ~ ((int )vmdq->mask))) & (int )((short )vmdq->mask))) + (int )((u16 )fcoe_tc);
#line 93
    (adapter->rx_ring[i])->reg_idx = (u8 )reg_idx;
#line 94
    reg_idx = (u16 )((int )reg_idx + 1);
#line 91
    i = i + 1;
    ldv_50819: ;
#line 91
    if (i < adapter->num_rx_queues) {
#line 93
      goto ldv_50818;
    } else {

    }
#line 97
    reg_idx = (int )((u16 )((int )vmdq->offset + (int )vmdq->indices)) * (int )queues_per_pool;
#line 98
    i = (int )fcoe->offset;
#line 98
    goto ldv_50822;
    ldv_50821: 
#line 99
    reg_idx = (int )((u16 )((int )((short )((int )reg_idx + ~ ((int )vmdq->mask))) & (int )((short )vmdq->mask))) + (int )((u16 )fcoe_tc);
#line 100
    (adapter->tx_ring[i])->reg_idx = (u8 )reg_idx;
#line 101
    reg_idx = (u16 )((int )reg_idx + 1);
#line 98
    i = i + 1;
    ldv_50822: ;
#line 98
    if (i < adapter->num_tx_queues) {
#line 100
      goto ldv_50821;
    } else {

    }

  } else {

  }
#line 106
  return (1);
}
}
#line 110 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_get_first_reg_idx(struct ixgbe_adapter *adapter , u8 tc , unsigned int *tx ,
                                    unsigned int *rx ) 
{ 
  struct net_device *dev ;
  struct ixgbe_hw *hw ;
  u8 num_tcs ;
  int tmp ;

  {
  {
#line 113
  dev = adapter->netdev;
#line 114
  hw = & adapter->hw;
#line 115
  tmp = netdev_get_num_tc(dev);
#line 115
  num_tcs = (u8 )tmp;
#line 117
  *tx = 0U;
#line 118
  *rx = 0U;
  }
  {
#line 121
  if ((unsigned int )hw->mac.type == 1U) {
#line 121
    goto case_1;
  } else {

  }
#line 126
  if ((unsigned int )hw->mac.type == 2U) {
#line 126
    goto case_2;
  } else {

  }
#line 127
  if ((unsigned int )hw->mac.type == 3U) {
#line 127
    goto case_3;
  } else {

  }
#line 153
  goto switch_default;
  case_1: /* CIL Label */ 
#line 123
  *tx = (unsigned int )((int )tc << 2);
#line 124
  *rx = (unsigned int )((int )tc << 3);
#line 125
  goto ldv_50834;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
#line 128
  if ((unsigned int )num_tcs > 4U) {
#line 134
    *rx = (unsigned int )((int )tc << 4);
#line 135
    if ((unsigned int )tc <= 2U) {
#line 136
      *tx = (unsigned int )((int )tc << 5);
    } else
#line 137
    if ((unsigned int )tc <= 4U) {
#line 138
      *tx = (unsigned int )(((int )tc + 2) << 4);
    } else {
#line 140
      *tx = (unsigned int )(((int )tc + 8) << 3);
    }
  } else {
#line 147
    *rx = (unsigned int )((int )tc << 5);
#line 148
    if ((unsigned int )tc <= 1U) {
#line 149
      *tx = (unsigned int )((int )tc << 6);
    } else {
#line 151
      *tx = (unsigned int )(((int )tc + 4) << 4);
    }
  }
  switch_default: /* CIL Label */ ;
#line 154
  goto ldv_50834;
  switch_break: /* CIL Label */ ;
  }
  ldv_50834: ;
#line 157
  return;
}
}
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_dcb(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *dev ;
  unsigned int tx_idx ;
  unsigned int rx_idx ;
  int tc ;
  int offset ;
  int rss_i ;
  int i ;
  u8 num_tcs ;
  int tmp ;

  {
  {
#line 167
  dev = adapter->netdev;
#line 170
  tmp = netdev_get_num_tc(dev);
#line 170
  num_tcs = (u8 )tmp;
  }
#line 173
  if ((unsigned int )num_tcs <= 1U) {
#line 174
    return (0);
  } else {

  }
#line 176
  rss_i = (int )adapter->ring_feature[2].indices;
#line 178
  tc = 0;
#line 178
  offset = 0;
#line 178
  goto ldv_50853;
  ldv_50852: 
  {
#line 179
  ixgbe_get_first_reg_idx(adapter, (int )((u8 )tc), & tx_idx, & rx_idx);
#line 180
  i = 0;
  }
#line 180
  goto ldv_50850;
  ldv_50849: 
#line 181
  (adapter->tx_ring[offset + i])->reg_idx = (u8 )tx_idx;
#line 182
  (adapter->rx_ring[offset + i])->reg_idx = (u8 )rx_idx;
#line 183
  (adapter->tx_ring[offset + i])->dcb_tc = (u8 )tc;
#line 184
  (adapter->rx_ring[offset + i])->dcb_tc = (u8 )tc;
#line 180
  i = i + 1;
#line 180
  tx_idx = tx_idx + 1U;
#line 180
  rx_idx = rx_idx + 1U;
  ldv_50850: ;
#line 180
  if (i < rss_i) {
#line 182
    goto ldv_50849;
  } else {

  }
#line 178
  tc = tc + 1;
#line 178
  offset = offset + rss_i;
  ldv_50853: ;
#line 178
  if (tc < (int )num_tcs) {
#line 180
    goto ldv_50852;
  } else {

  }

#line 188
  return (1);
}
}
#line 200 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_sriov(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring_feature *fcoe ;
  struct ixgbe_ring_feature *vmdq ;
  struct ixgbe_ring_feature *rss ;
  int i ;
  u16 reg_idx ;

  {
#line 203
  fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 205
  vmdq = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 1UL;
#line 206
  rss = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 2UL;
#line 211
  if ((adapter->flags & 16384U) == 0U) {
#line 212
    return (0);
  } else {

  }
#line 215
  reg_idx = (int )vmdq->offset * (int )((u16 )(- ((int )vmdq->mask) & (int )vmdq->mask));
#line 216
  i = 0;
#line 216
  goto ldv_50865;
  ldv_50864: ;
#line 219
  if ((unsigned int )fcoe->offset != 0U && i > (int )fcoe->offset) {
#line 220
    goto ldv_50863;
  } else {

  }
#line 223
  if (((int )reg_idx & ~ ((int )vmdq->mask)) >= (int )rss->indices) {
#line 224
    reg_idx = (u16 )((int )((short )((int )reg_idx + ~ ((int )vmdq->mask))) & (int )((short )vmdq->mask));
  } else {

  }
#line 225
  (adapter->rx_ring[i])->reg_idx = (u8 )reg_idx;
#line 216
  i = i + 1;
#line 216
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_50865: ;
#line 216
  if (i < adapter->num_rx_queues) {
#line 218
    goto ldv_50864;
  } else {

  }
  ldv_50863: ;
#line 230
  goto ldv_50867;
  ldv_50866: 
#line 231
  (adapter->rx_ring[i])->reg_idx = (u8 )reg_idx;
#line 230
  i = i + 1;
#line 230
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_50867: ;
#line 230
  if (i < adapter->num_rx_queues) {
#line 232
    goto ldv_50866;
  } else {

  }
#line 234
  reg_idx = (int )vmdq->offset * (int )((u16 )(- ((int )vmdq->mask) & (int )vmdq->mask));
#line 235
  i = 0;
#line 235
  goto ldv_50871;
  ldv_50870: ;
#line 238
  if ((unsigned int )fcoe->offset != 0U && i > (int )fcoe->offset) {
#line 239
    goto ldv_50869;
  } else {

  }
#line 242
  if (((int )reg_idx & (int )rss->mask) >= (int )rss->indices) {
#line 243
    reg_idx = (u16 )((int )((short )((int )reg_idx + ~ ((int )vmdq->mask))) & (int )((short )vmdq->mask));
  } else {

  }
#line 244
  (adapter->tx_ring[i])->reg_idx = (u8 )reg_idx;
#line 235
  i = i + 1;
#line 235
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_50871: ;
#line 235
  if (i < adapter->num_tx_queues) {
#line 237
    goto ldv_50870;
  } else {

  }
  ldv_50869: ;
#line 249
  goto ldv_50873;
  ldv_50872: 
#line 250
  (adapter->tx_ring[i])->reg_idx = (u8 )reg_idx;
#line 249
  i = i + 1;
#line 249
  reg_idx = (u16 )((int )reg_idx + 1);
  ldv_50873: ;
#line 249
  if (i < adapter->num_tx_queues) {
#line 251
    goto ldv_50872;
  } else {

  }

#line 254
  return (1);
}
}
#line 264 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_cache_ring_rss(struct ixgbe_adapter *adapter ) 
{ 
  int i ;

  {
#line 268
  i = 0;
#line 268
  goto ldv_50880;
  ldv_50879: 
#line 269
  (adapter->rx_ring[i])->reg_idx = (u8 )i;
#line 268
  i = i + 1;
  ldv_50880: ;
#line 268
  if (i < adapter->num_rx_queues) {
#line 270
    goto ldv_50879;
  } else {

  }
#line 270
  i = 0;
#line 270
  goto ldv_50883;
  ldv_50882: 
#line 271
  (adapter->tx_ring[i])->reg_idx = (u8 )i;
#line 270
  i = i + 1;
  ldv_50883: ;
#line 270
  if (i < adapter->num_tx_queues) {
#line 272
    goto ldv_50882;
  } else {

  }

#line 273
  return (1);
}
}
#line 287 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_cache_ring_register(struct ixgbe_adapter *adapter ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 290
  (adapter->rx_ring[0])->reg_idx = 0U;
#line 291
  (adapter->tx_ring[0])->reg_idx = 0U;
#line 294
  tmp = ixgbe_cache_ring_dcb_sriov(adapter);
  }
#line 294
  if ((int )tmp) {
#line 295
    return;
  } else {

  }
  {
#line 297
  tmp___0 = ixgbe_cache_ring_dcb(adapter);
  }
#line 297
  if ((int )tmp___0) {
#line 298
    return;
  } else {

  }
  {
#line 301
  tmp___1 = ixgbe_cache_ring_sriov(adapter);
  }
#line 301
  if ((int )tmp___1) {
#line 302
    return;
  } else {

  }
  {
#line 304
  ixgbe_cache_ring_rss(adapter);
  }
#line 305
  return;
}
}
#line 323 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter ) 
{ 
  int i ;
  u16 vmdq_i ;
  u16 vmdq_m ;
  u16 fcoe_i ;
  u8 tcs ;
  int tmp ;
  u16 __min1 ;
  u16 __min2 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  struct ixgbe_ring_feature *fcoe ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  u8 tmp___0 ;

  {
  {
#line 326
  vmdq_i = adapter->ring_feature[1].limit;
#line 327
  vmdq_m = 0U;
#line 329
  fcoe_i = 0U;
#line 331
  tmp = netdev_get_num_tc(adapter->netdev);
#line 331
  tcs = (u8 )tmp;
  }
#line 334
  if ((unsigned int )tcs <= 1U) {
#line 335
    return (0);
  } else {

  }
#line 338
  if ((adapter->flags & 8388608U) == 0U) {
#line 339
    return (0);
  } else {

  }
#line 342
  vmdq_i = (int )vmdq_i + (int )adapter->ring_feature[1].offset;
#line 345
  if ((unsigned int )tcs > 4U) {
#line 346
    __min1 = vmdq_i;
#line 346
    __min2 = 16U;
#line 346
    vmdq_i = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 347
    vmdq_m = 120U;
  } else {
#line 350
    __min1___0 = vmdq_i;
#line 350
    __min2___0 = 32U;
#line 350
    vmdq_i = (u16 )((int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0);
#line 351
    vmdq_m = 124U;
  }
#line 356
  fcoe_i = (int )((u16 )(128 / (- ((int )vmdq_m) & (int )vmdq_m))) - (int )vmdq_i;
#line 360
  vmdq_i = (int )vmdq_i - (int )adapter->ring_feature[1].offset;
#line 363
  adapter->ring_feature[1].indices = vmdq_i;
#line 364
  adapter->ring_feature[1].mask = vmdq_m;
#line 370
  adapter->ring_feature[2].indices = 1U;
#line 371
  adapter->ring_feature[2].mask = 0U;
#line 374
  adapter->flags = adapter->flags & 4294705151U;
#line 376
  adapter->num_rx_pools = (int )vmdq_i;
#line 377
  adapter->num_rx_queues_per_pool = (int )tcs;
#line 379
  adapter->num_tx_queues = (int )vmdq_i * (int )tcs;
#line 380
  adapter->num_rx_queues = (int )vmdq_i * (int )tcs;
#line 383
  if ((adapter->flags & 2097152U) != 0U) {
#line 386
    fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 389
    __min1___1 = fcoe_i;
#line 389
    __min2___1 = fcoe->limit;
#line 389
    fcoe_i = (u16 )((int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1);
#line 391
    if ((unsigned int )fcoe_i != 0U) {
#line 393
      fcoe->indices = fcoe_i;
#line 394
      fcoe->offset = (int )vmdq_i * (int )((u16 )tcs);
#line 397
      adapter->num_tx_queues = adapter->num_tx_queues + (int )fcoe_i;
#line 398
      adapter->num_rx_queues = adapter->num_rx_queues + (int )fcoe_i;
    } else
#line 399
    if ((unsigned int )tcs > 1U) {
      {
#line 401
      fcoe->indices = 1U;
#line 402
      tmp___0 = ixgbe_fcoe_get_tc(adapter);
#line 402
      fcoe->offset = (u16 )tmp___0;
      }
    } else {
#line 404
      adapter->flags = adapter->flags & 4292870143U;
#line 406
      fcoe->indices = 0U;
#line 407
      fcoe->offset = 0U;
    }
  } else {

  }
#line 413
  i = 0;
#line 413
  goto ldv_50907;
  ldv_50906: 
  {
#line 414
  netdev_set_tc_queue(adapter->netdev, (int )((u8 )i), 1, (int )((u16 )i));
#line 413
  i = i + 1;
  }
  ldv_50907: ;
#line 413
  if (i < (int )tcs) {
#line 415
    goto ldv_50906;
  } else {

  }

#line 416
  return (1);
}
}
#line 419 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *dev ;
  struct ixgbe_ring_feature *f ;
  int rss_i ;
  int rss_m ;
  int i ;
  int tcs ;
  u16 __min1 ;
  u16 __min2 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  int __min1___2 ;
  int __min2___2 ;
  u8 tc ;
  u8 tmp ;
  u16 __min1___3 ;
  u16 __min2___3 ;

  {
  {
#line 421
  dev = adapter->netdev;
#line 427
  tcs = netdev_get_num_tc(dev);
  }
#line 430
  if (tcs <= 1) {
#line 431
    return (0);
  } else {

  }
#line 434
  rss_i = (int )(dev->num_tx_queues / (unsigned int )tcs);
#line 435
  if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 437
    __min1 = (u16 )rss_i;
#line 437
    __min2 = 4U;
#line 437
    rss_i = (int )__min1 < (int )__min2 ? __min1 : __min2;
#line 438
    rss_m = 3;
  } else
#line 439
  if (tcs > 4) {
#line 441
    __min1___0 = (u16 )rss_i;
#line 441
    __min2___0 = 8U;
#line 441
    rss_i = (int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0;
#line 442
    rss_m = 7;
  } else {
#line 445
    __min1___1 = (u16 )rss_i;
#line 445
    __min2___1 = 16U;
#line 445
    rss_i = (int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1;
#line 446
    rss_m = 15;
  }
#line 450
  f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 2UL;
#line 451
  __min1___2 = rss_i;
#line 451
  __min2___2 = (int )f->limit;
#line 451
  rss_i = __min1___2 < __min2___2 ? __min1___2 : __min2___2;
#line 452
  f->indices = (u16 )rss_i;
#line 453
  f->mask = (u16 )rss_m;
#line 456
  adapter->flags = adapter->flags & 4294705151U;
#line 464
  if ((adapter->flags & 2097152U) != 0U) {
    {
#line 465
    tmp = ixgbe_fcoe_get_tc(adapter);
#line 465
    tc = tmp;
#line 467
    f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 468
    __min1___3 = (u16 )rss_i;
#line 468
    __min2___3 = f->limit;
#line 468
    f->indices = (u16 )((int )__min1___3 < (int )__min2___3 ? __min1___3 : __min2___3);
#line 469
    f->offset = (int )((u16 )rss_i) * (int )((u16 )tc);
    }
  } else {

  }
#line 473
  i = 0;
#line 473
  goto ldv_50935;
  ldv_50934: 
  {
#line 474
  netdev_set_tc_queue(dev, (int )((u8 )i), (int )((u16 )rss_i), (int )((u16 )rss_i) * (int )((u16 )i));
#line 473
  i = i + 1;
  }
  ldv_50935: ;
#line 473
  if (i < tcs) {
#line 475
    goto ldv_50934;
  } else {

  }
#line 476
  adapter->num_tx_queues = rss_i * tcs;
#line 477
  adapter->num_rx_queues = rss_i * tcs;
#line 479
  return (1);
}
}
#line 492 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter ) 
{ 
  u16 vmdq_i ;
  u16 vmdq_m ;
  u16 rss_i ;
  u16 rss_m ;
  u16 fcoe_i ;
  bool pools ;
  unsigned long tmp ;
  u16 __min1 ;
  u16 __min2 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  struct ixgbe_ring_feature *fcoe ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  u16 __min1___2 ;
  u16 __min2___2 ;
  unsigned int tmp___0 ;
  u16 __min1___3 ;
  u16 __min2___3 ;

  {
  {
#line 494
  vmdq_i = adapter->ring_feature[1].limit;
#line 495
  vmdq_m = 0U;
#line 496
  rss_i = adapter->ring_feature[2].limit;
#line 497
  rss_m = 0U;
#line 499
  fcoe_i = 0U;
#line 501
  tmp = find_first_zero_bit((unsigned long const   *)(& adapter->fwd_bitmask), 32UL);
#line 501
  pools = tmp > 1UL;
  }
#line 504
  if ((adapter->flags & 8388608U) == 0U) {
#line 505
    return (0);
  } else {

  }
#line 508
  vmdq_i = (int )vmdq_i + (int )adapter->ring_feature[1].offset;
#line 511
  __min1 = 64U;
#line 511
  __min2 = vmdq_i;
#line 511
  vmdq_i = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 514
  if (((unsigned int )vmdq_i > 32U || (unsigned int )rss_i <= 3U) || ((unsigned int )vmdq_i > 16U && (int )pools)) {
#line 515
    vmdq_m = 126U;
#line 516
    rss_m = 1U;
#line 517
    __min1___0 = rss_i;
#line 517
    __min2___0 = 2U;
#line 517
    rss_i = (u16 )((int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0);
  } else {
#line 520
    vmdq_m = 124U;
#line 521
    rss_m = 3U;
#line 522
    rss_i = 4U;
  }
#line 527
  fcoe_i = 128U - (unsigned int )((int )vmdq_i * (int )((u16 )(- ((int )vmdq_m) & (int )vmdq_m)));
#line 531
  vmdq_i = (int )vmdq_i - (int )adapter->ring_feature[1].offset;
#line 534
  adapter->ring_feature[1].indices = vmdq_i;
#line 535
  adapter->ring_feature[1].mask = vmdq_m;
#line 538
  adapter->ring_feature[2].indices = rss_i;
#line 539
  adapter->ring_feature[2].mask = rss_m;
#line 541
  adapter->num_rx_pools = (int )vmdq_i;
#line 542
  adapter->num_rx_queues_per_pool = (int )rss_i;
#line 544
  adapter->num_rx_queues = (int )vmdq_i * (int )rss_i;
#line 545
  adapter->num_tx_queues = (int )vmdq_i * (int )rss_i;
#line 548
  adapter->flags = adapter->flags & 4294705151U;
#line 556
  if ((adapter->flags & 2097152U) != 0U) {
#line 559
    fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 562
    __min1___1 = fcoe_i;
#line 562
    __min2___1 = fcoe->limit;
#line 562
    fcoe_i = (u16 )((int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1);
#line 564
    if ((unsigned int )vmdq_i > 1U && (unsigned int )fcoe_i != 0U) {
#line 566
      fcoe->indices = fcoe_i;
#line 567
      fcoe->offset = (int )vmdq_i * (int )rss_i;
    } else {
      {
#line 570
      __min1___2 = (int )fcoe_i + (int )rss_i;
#line 570
      tmp___0 = cpumask_weight(cpu_online_mask);
#line 570
      __min2___2 = (u16 )tmp___0;
#line 570
      fcoe_i = (u16 )((int )__min1___2 < (int )__min2___2 ? __min1___2 : __min2___2);
      }
#line 573
      if ((adapter->flags & 8U) == 0U) {
#line 574
        fcoe_i = rss_i;
      } else {

      }
#line 577
      __min1___3 = fcoe_i;
#line 577
      __min2___3 = fcoe->limit;
#line 577
      fcoe->indices = (u16 )((int )__min1___3 < (int )__min2___3 ? __min1___3 : __min2___3);
#line 578
      fcoe->offset = (int )fcoe_i - (int )fcoe->indices;
#line 580
      fcoe_i = (int )fcoe_i - (int )rss_i;
    }
#line 584
    adapter->num_tx_queues = adapter->num_tx_queues + (int )fcoe_i;
#line 585
    adapter->num_rx_queues = adapter->num_rx_queues + (int )fcoe_i;
  } else {

  }
#line 589
  return (1);
}
}
#line 600 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static bool ixgbe_set_rss_queues(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring_feature *f ;
  u16 rss_i ;
  u16 tmp ;
  struct net_device *dev ;
  u16 fcoe_i ;
  u16 __min1 ;
  u16 __min2 ;
  unsigned int tmp___0 ;
  u16 __min1___0 ;
  u16 __min2___0 ;
  u16 __min1___1 ;
  u16 __min2___1 ;
  u16 __max1 ;
  u16 __max2 ;

  {
#line 606
  f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 2UL;
#line 607
  rss_i = f->limit;
#line 609
  f->indices = rss_i;
#line 610
  f->mask = 15U;
#line 613
  adapter->flags = adapter->flags & 4294705151U;
#line 620
  if ((unsigned int )rss_i > 1U && adapter->atr_sample_rate != 0U) {
#line 621
    f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 3UL;
#line 623
    tmp = f->limit;
#line 623
    f->indices = tmp;
#line 623
    rss_i = tmp;
#line 625
    if ((adapter->flags & 524288U) == 0U) {
#line 626
      adapter->flags = adapter->flags | 262144U;
    } else {

    }
  } else {

  }
#line 638
  if ((adapter->flags & 2097152U) != 0U) {
    {
#line 639
    dev = adapter->netdev;
#line 642
    f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 645
    __min1 = (int )f->limit + (int )rss_i;
#line 645
    tmp___0 = cpumask_weight(cpu_online_mask);
#line 645
    __min2 = (u16 )tmp___0;
#line 645
    fcoe_i = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 646
    __min1___0 = fcoe_i;
#line 646
    __min2___0 = (u16 )dev->num_tx_queues;
#line 646
    fcoe_i = (u16 )((int )__min1___0 < (int )__min2___0 ? __min1___0 : __min2___0);
    }
#line 649
    if ((adapter->flags & 8U) == 0U) {
#line 650
      fcoe_i = rss_i;
    } else {

    }
#line 653
    __min1___1 = fcoe_i;
#line 653
    __min2___1 = f->limit;
#line 653
    f->indices = (u16 )((int )__min1___1 < (int )__min2___1 ? __min1___1 : __min2___1);
#line 654
    f->offset = (int )fcoe_i - (int )f->indices;
#line 655
    __max1 = fcoe_i;
#line 655
    __max2 = rss_i;
#line 655
    rss_i = (u16 )((int )__max1 > (int )__max2 ? __max1 : __max2);
  } else {

  }
#line 659
  adapter->num_rx_queues = (int )rss_i;
#line 660
  adapter->num_tx_queues = (int )rss_i;
#line 662
  return (1);
}
}
#line 676 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_set_num_queues(struct ixgbe_adapter *adapter ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 679
  adapter->num_rx_queues = 1;
#line 680
  adapter->num_tx_queues = 1;
#line 681
  adapter->num_rx_pools = adapter->num_rx_queues;
#line 682
  adapter->num_rx_queues_per_pool = 1;
#line 685
  tmp = ixgbe_set_dcb_sriov_queues(adapter);
  }
#line 685
  if ((int )tmp) {
#line 686
    return;
  } else {

  }
  {
#line 688
  tmp___0 = ixgbe_set_dcb_queues(adapter);
  }
#line 688
  if ((int )tmp___0) {
#line 689
    return;
  } else {

  }
  {
#line 692
  tmp___1 = ixgbe_set_sriov_queues(adapter);
  }
#line 692
  if ((int )tmp___1) {
#line 693
    return;
  } else {

  }
  {
#line 695
  ixgbe_set_rss_queues(adapter);
  }
#line 696
  return;
}
}
#line 698 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_acquire_msix_vectors(struct ixgbe_adapter *adapter , int vectors ) 
{ 
  int err ;
  int vector_threshold ;
  int _min1 ;
  int _min2 ;

  {
#line 707
  vector_threshold = 2;
#line 715
  goto ldv_50992;
  ldv_50991: 
  {
#line 716
  err = pci_enable_msix(adapter->pdev, adapter->msix_entries, vectors);
  }
#line 718
  if (err == 0) {
#line 719
    goto ldv_50990;
  } else
#line 720
  if (err < 0) {
#line 721
    vectors = 0;
  } else {
#line 723
    vectors = err;
  }
  ldv_50992: ;
#line 715
  if (vectors >= vector_threshold) {
#line 717
    goto ldv_50991;
  } else {

  }
  ldv_50990: ;
#line 726
  if (vectors < vector_threshold) {
#line 731
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 732
      netdev_printk("\017", (struct net_device  const  *)adapter->netdev, "Unable to allocate MSI-X interrupts\n");
      }
    } else {

    }
    {
#line 733
    adapter->flags = adapter->flags & 4294967287U;
#line 734
    kfree((void const   *)adapter->msix_entries);
#line 735
    adapter->msix_entries = (struct msix_entry *)0;
    }
  } else {
#line 737
    adapter->flags = adapter->flags | 8U;
#line 743
    vectors = vectors + -1;
#line 744
    _min1 = vectors;
#line 744
    _min2 = adapter->max_q_vectors;
#line 744
    adapter->num_q_vectors = _min1 < _min2 ? _min1 : _min2;
  }
#line 747
  return;
}
}
#line 748 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_add_ring(struct ixgbe_ring *ring , struct ixgbe_ring_container *head ) 
{ 


  {
#line 751
  ring->next = head->ring;
#line 752
  head->ring = ring;
#line 753
  head->count = (u8 )((int )head->count + 1);
#line 754
  return;
}
}
#line 768 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter , int v_count , int v_idx ,
                                int txr_count , int txr_idx , int rxr_count , int rxr_idx ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  struct ixgbe_ring *ring ;
  int node ;
  int cpu ;
  int ring_count ;
  int size ;
  u8 tcs ;
  int tmp ;
  u16 rss_i ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct ixgbe_ring_feature *f ;

  {
  {
#line 775
  node = -1;
#line 776
  cpu = -1;
#line 778
  tmp = netdev_get_num_tc(adapter->netdev);
#line 778
  tcs = (u8 )tmp;
#line 780
  ring_count = txr_count + rxr_count;
#line 781
  size = (int )((unsigned int )((unsigned long )ring_count + 1UL) * 4096U);
  }
#line 785
  if ((unsigned int )tcs <= 1U && (adapter->flags & 8388608U) == 0U) {
#line 786
    rss_i = adapter->ring_feature[2].indices;
#line 787
    if ((unsigned int )rss_i > 1U && adapter->atr_sample_rate != 0U) {
      {
#line 788
      tmp___0 = cpumask_check((unsigned int )v_idx);
#line 788
      tmp___1 = variable_test_bit((long )tmp___0, (unsigned long const volatile   *)(& cpu_online_mask->bits));
      }
#line 788
      if (tmp___1 != 0) {
        {
#line 789
        cpu = v_idx;
#line 790
        node = __cpu_to_node(cpu);
        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 796
  tmp___2 = kzalloc_node((size_t )size, 208U, node);
#line 796
  q_vector = (struct ixgbe_q_vector *)tmp___2;
  }
#line 797
  if ((unsigned long )q_vector == (unsigned long )((struct ixgbe_q_vector *)0)) {
    {
#line 798
    tmp___3 = kzalloc((size_t )size, 208U);
#line 798
    q_vector = (struct ixgbe_q_vector *)tmp___3;
    }
  } else {

  }
#line 799
  if ((unsigned long )q_vector == (unsigned long )((struct ixgbe_q_vector *)0)) {
#line 800
    return (-12);
  } else {

  }
#line 803
  if (cpu != -1) {
    {
#line 804
    cpumask_set_cpu((unsigned int )cpu, & q_vector->affinity_mask);
    }
  } else {

  }
  {
#line 805
  q_vector->numa_node = node;
#line 809
  q_vector->cpu = -1;
#line 813
  netif_napi_add(adapter->netdev, & q_vector->napi, & ixgbe_poll, 64);
#line 815
  napi_hash_add(& q_vector->napi);
#line 818
  adapter->q_vector[v_idx] = q_vector;
#line 819
  q_vector->adapter = adapter;
#line 820
  q_vector->v_idx = (u16 )v_idx;
#line 823
  q_vector->tx.work_limit = adapter->tx_work_limit;
#line 826
  ring = (struct ixgbe_ring *)(& q_vector->ring);
  }
#line 829
  if (txr_count != 0 && rxr_count == 0) {
#line 831
    if ((unsigned int )adapter->tx_itr_setting == 1U) {
#line 832
      q_vector->itr = 400U;
    } else {
#line 834
      q_vector->itr = adapter->tx_itr_setting;
    }
  } else
#line 837
  if ((unsigned int )adapter->rx_itr_setting == 1U) {
#line 838
    q_vector->itr = 200U;
  } else {
#line 840
    q_vector->itr = adapter->rx_itr_setting;
  }
#line 843
  goto ldv_51018;
  ldv_51017: 
  {
#line 845
  ring->dev = & (adapter->pdev)->dev;
#line 846
  ring->netdev = adapter->netdev;
#line 849
  ring->q_vector = q_vector;
#line 852
  ixgbe_add_ring(ring, & q_vector->tx);
#line 855
  ring->count = (u16 )adapter->tx_ring_count;
  }
#line 856
  if (adapter->num_rx_pools > 1) {
#line 857
    ring->queue_index = (u8 )(txr_idx % adapter->num_rx_queues_per_pool);
  } else {
#line 860
    ring->queue_index = (u8 )txr_idx;
  }
#line 863
  adapter->tx_ring[txr_idx] = ring;
#line 866
  txr_count = txr_count - 1;
#line 867
  txr_idx = txr_idx + v_count;
#line 870
  ring = ring + 1;
  ldv_51018: ;
#line 843
  if (txr_count != 0) {
#line 845
    goto ldv_51017;
  } else {

  }

#line 873
  goto ldv_51022;
  ldv_51021: 
  {
#line 875
  ring->dev = & (adapter->pdev)->dev;
#line 876
  ring->netdev = adapter->netdev;
#line 879
  ring->q_vector = q_vector;
#line 882
  ixgbe_add_ring(ring, & q_vector->rx);
  }
#line 888
  if ((unsigned int )adapter->hw.mac.type == 2U) {
    {
#line 889
    set_bit(5L, (unsigned long volatile   *)(& ring->state));
    }
  } else {

  }
#line 892
  if (((adapter->netdev)->features & 536870912ULL) != 0ULL) {
#line 894
    f = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 895
    if (rxr_idx >= (int )f->offset && rxr_idx < (int )f->offset + (int )f->indices) {
      {
#line 897
      set_bit(6L, (unsigned long volatile   *)(& ring->state));
      }
    } else {

    }
  } else {

  }
#line 902
  ring->count = (u16 )adapter->rx_ring_count;
#line 903
  if (adapter->num_rx_pools > 1) {
#line 904
    ring->queue_index = (u8 )(rxr_idx % adapter->num_rx_queues_per_pool);
  } else {
#line 907
    ring->queue_index = (u8 )rxr_idx;
  }
#line 910
  adapter->rx_ring[rxr_idx] = ring;
#line 913
  rxr_count = rxr_count - 1;
#line 914
  rxr_idx = rxr_idx + v_count;
#line 917
  ring = ring + 1;
  ldv_51022: ;
#line 873
  if (rxr_count != 0) {
#line 875
    goto ldv_51021;
  } else {

  }

#line 920
  return (0);
}
}
#line 951
extern void __compiletime_assert_951(void) ;
#line 932 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_free_q_vector(struct ixgbe_adapter *adapter , int v_idx ) 
{ 
  struct ixgbe_q_vector *q_vector ;
  struct ixgbe_ring *ring ;
  bool __cond ;

  {
#line 934
  q_vector = adapter->q_vector[v_idx];
#line 937
  ring = q_vector->tx.ring;
#line 937
  goto ldv_51031;
  ldv_51030: 
#line 938
  adapter->tx_ring[(int )ring->queue_index] = (struct ixgbe_ring *)0;
#line 937
  ring = ring->next;
  ldv_51031: ;
#line 937
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 939
    goto ldv_51030;
  } else {

  }
#line 940
  ring = q_vector->rx.ring;
#line 940
  goto ldv_51034;
  ldv_51033: 
#line 941
  adapter->rx_ring[(int )ring->queue_index] = (struct ixgbe_ring *)0;
#line 940
  ring = ring->next;
  ldv_51034: ;
#line 940
  if ((unsigned long )ring != (unsigned long )((struct ixgbe_ring *)0)) {
#line 942
    goto ldv_51033;
  } else {

  }
  {
#line 943
  adapter->q_vector[v_idx] = (struct ixgbe_q_vector *)0;
#line 944
  napi_hash_del(& q_vector->napi);
#line 945
  netif_napi_del(& q_vector->napi);
#line 951
  __cond = 0;
  }
#line 951
  if ((int )__cond) {
    {
#line 951
    __compiletime_assert_951();
    }
  } else {

  }
  {
#line 951
  kfree_call_rcu(& q_vector->rcu, (void (*)(struct callback_head * ))1280);
  }
#line 952
  return;
}
}
#line 961 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static int ixgbe_alloc_q_vectors(struct ixgbe_adapter *adapter ) 
{ 
  int q_vectors ;
  int rxr_remaining ;
  int txr_remaining ;
  int rxr_idx ;
  int txr_idx ;
  int v_idx ;
  int err ;
  int rqpv ;
  int tqpv ;
  int tmp ;

  {
#line 963
  q_vectors = adapter->num_q_vectors;
#line 964
  rxr_remaining = adapter->num_rx_queues;
#line 965
  txr_remaining = adapter->num_tx_queues;
#line 966
  rxr_idx = 0;
#line 966
  txr_idx = 0;
#line 966
  v_idx = 0;
#line 970
  if ((adapter->flags & 8U) == 0U) {
#line 971
    q_vectors = 1;
  } else {

  }
#line 973
  if (q_vectors >= rxr_remaining + txr_remaining) {
#line 974
    goto ldv_51053;
    ldv_51052: 
    {
#line 975
    err = ixgbe_alloc_q_vector(adapter, q_vectors, v_idx, 0, 0, 1, rxr_idx);
    }
#line 978
    if (err != 0) {
#line 979
      goto err_out;
    } else {

    }
#line 982
    rxr_remaining = rxr_remaining - 1;
#line 983
    rxr_idx = rxr_idx + 1;
#line 974
    v_idx = v_idx + 1;
    ldv_51053: ;
#line 974
    if (rxr_remaining != 0) {
#line 976
      goto ldv_51052;
    } else {

    }

  } else {

  }
#line 987
  goto ldv_51058;
  ldv_51057: 
  {
#line 988
  rqpv = ((rxr_remaining + (q_vectors - v_idx)) + -1) / (q_vectors - v_idx);
#line 989
  tqpv = ((txr_remaining + (q_vectors - v_idx)) + -1) / (q_vectors - v_idx);
#line 990
  err = ixgbe_alloc_q_vector(adapter, q_vectors, v_idx, tqpv, txr_idx, rqpv, rxr_idx);
  }
#line 994
  if (err != 0) {
#line 995
    goto err_out;
  } else {

  }
#line 998
  rxr_remaining = rxr_remaining - rqpv;
#line 999
  txr_remaining = txr_remaining - tqpv;
#line 1000
  rxr_idx = rxr_idx + 1;
#line 1001
  txr_idx = txr_idx + 1;
#line 987
  v_idx = v_idx + 1;
  ldv_51058: ;
#line 987
  if (v_idx < q_vectors) {
#line 989
    goto ldv_51057;
  } else {

  }

#line 1004
  return (0);
  err_out: 
#line 1007
  adapter->num_tx_queues = 0;
#line 1008
  adapter->num_rx_queues = 0;
#line 1009
  adapter->num_q_vectors = 0;
#line 1011
  goto ldv_51061;
  ldv_51060: 
  {
#line 1012
  ixgbe_free_q_vector(adapter, v_idx);
  }
  ldv_51061: 
#line 1011
  tmp = v_idx;
#line 1011
  v_idx = v_idx - 1;
#line 1011
  if (tmp != 0) {
#line 1013
    goto ldv_51060;
  } else {

  }

#line 1014
  return (-12);
}
}
#line 1025 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_free_q_vectors(struct ixgbe_adapter *adapter ) 
{ 
  int v_idx ;
  int tmp ;

  {
#line 1027
  v_idx = adapter->num_q_vectors;
#line 1029
  adapter->num_tx_queues = 0;
#line 1030
  adapter->num_rx_queues = 0;
#line 1031
  adapter->num_q_vectors = 0;
#line 1033
  goto ldv_51068;
  ldv_51067: 
  {
#line 1034
  ixgbe_free_q_vector(adapter, v_idx);
  }
  ldv_51068: 
#line 1033
  tmp = v_idx;
#line 1033
  v_idx = v_idx - 1;
#line 1033
  if (tmp != 0) {
#line 1035
    goto ldv_51067;
  } else {

  }

#line 1040
  return;
}
}
#line 1037 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_reset_interrupt_capability(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 1039
  if ((adapter->flags & 8U) != 0U) {
    {
#line 1040
    adapter->flags = adapter->flags & 4294967287U;
#line 1041
    pci_disable_msix(adapter->pdev);
#line 1042
    kfree((void const   *)adapter->msix_entries);
#line 1043
    adapter->msix_entries = (struct msix_entry *)0;
    }
  } else
#line 1044
  if ((adapter->flags & 2U) != 0U) {
    {
#line 1045
    adapter->flags = adapter->flags & 4294967293U;
#line 1046
    pci_disable_msi(adapter->pdev);
    }
  } else {

  }
#line 1048
  return;
}
}
#line 1057 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
static void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int vector ;
  int v_budget ;
  int err ;
  int _max1 ;
  int _max2 ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp ;
  int __min1___0 ;
  int __min2___0 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1059
  hw = & adapter->hw;
#line 1069
  _max1 = adapter->num_rx_queues;
#line 1069
  _max2 = adapter->num_tx_queues;
#line 1069
  v_budget = _max1 > _max2 ? _max1 : _max2;
#line 1070
  __min1 = v_budget;
#line 1070
  tmp = cpumask_weight(cpu_online_mask);
#line 1070
  __min2 = (int )tmp;
#line 1070
  v_budget = __min1 < __min2 ? __min1 : __min2;
#line 1071
  v_budget = v_budget + 1;
#line 1080
  __min1___0 = v_budget;
#line 1080
  __min2___0 = (int )hw->mac.max_msix_vectors;
#line 1080
  v_budget = __min1___0 < __min2___0 ? __min1___0 : __min2___0;
#line 1084
  tmp___0 = kcalloc((size_t )v_budget, 8UL, 208U);
#line 1084
  adapter->msix_entries = (struct msix_entry *)tmp___0;
  }
#line 1086
  if ((unsigned long )adapter->msix_entries != (unsigned long )((struct msix_entry *)0)) {
#line 1087
    vector = 0;
#line 1087
    goto ldv_51090;
    ldv_51089: 
#line 1088
    (adapter->msix_entries + (unsigned long )vector)->entry = (u16 )vector;
#line 1087
    vector = vector + 1;
    ldv_51090: ;
#line 1087
    if (vector < v_budget) {
#line 1089
      goto ldv_51089;
    } else {

    }
    {
#line 1090
    ixgbe_acquire_msix_vectors(adapter, v_budget);
    }
#line 1092
    if ((adapter->flags & 8U) != 0U) {
#line 1093
      return;
    } else {

    }
  } else {

  }
  {
#line 1097
  tmp___1 = netdev_get_num_tc(adapter->netdev);
  }
#line 1097
  if (tmp___1 > 1) {
#line 1098
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 1098
      netdev_err((struct net_device  const  *)adapter->netdev, "num TCs exceeds number of queues - disabling DCB\n");
      }
    } else {

    }
    {
#line 1099
    netdev_reset_tc(adapter->netdev);
    }
#line 1101
    if ((unsigned int )adapter->hw.mac.type == 1U) {
#line 1102
      adapter->hw.fc.requested_mode = adapter->last_lfc_mode;
    } else {

    }
#line 1104
    adapter->flags = adapter->flags & 4294963199U;
#line 1105
    adapter->temp_dcb_cfg.pfc_mode_enable = 0;
#line 1106
    adapter->dcb_cfg.pfc_mode_enable = 0;
  } else {

  }
  {
#line 1108
  adapter->dcb_cfg.num_tcs.pg_tcs = 1U;
#line 1109
  adapter->dcb_cfg.num_tcs.pfc_tcs = 1U;
#line 1112
  ixgbe_disable_sriov(adapter);
#line 1115
  adapter->ring_feature[2].limit = 1U;
#line 1117
  ixgbe_set_num_queues(adapter);
#line 1118
  adapter->num_q_vectors = 1;
#line 1120
  err = pci_enable_msi_block(adapter->pdev, 1);
  }
#line 1121
  if (err != 0) {
#line 1122
    if (((int )adapter->msg_enable & 8192) != 0) {
      {
#line 1124
      netdev_printk("\017", (struct net_device  const  *)adapter->netdev, "Unable to allocate MSI interrupt, falling back to legacy.  Error: %d\n",
                    err);
      }
    } else {

    }
#line 1125
    return;
  } else {

  }
#line 1127
  adapter->flags = adapter->flags | 2U;
#line 1128
  return;
}
}
#line 1140 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter ) 
{ 
  int err ;

  {
  {
#line 1145
  ixgbe_set_num_queues(adapter);
#line 1148
  ixgbe_set_interrupt_capability(adapter);
#line 1150
  err = ixgbe_alloc_q_vectors(adapter);
  }
#line 1151
  if (err != 0) {
    {
#line 1152
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Unable to allocate memory for queue vectors\n");
    }
#line 1153
    goto err_alloc_q_vectors;
  } else {

  }
  {
#line 1156
  ixgbe_cache_ring_register(adapter);
#line 1158
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Multiqueue %s: Rx Queue count = %u, Tx Queue count = %u\n",
            adapter->num_rx_queues > 1 ? (char *)"Enabled" : (char *)"Disabled", adapter->num_rx_queues,
            adapter->num_tx_queues);
#line 1162
  set_bit(2L, (unsigned long volatile   *)(& adapter->state));
  }
#line 1164
  return (0);
  err_alloc_q_vectors: 
  {
#line 1167
  ixgbe_reset_interrupt_capability(adapter);
  }
#line 1168
  return (err);
}
}
#line 1178 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter ) 
{ 


  {
  {
#line 1180
  adapter->num_tx_queues = 0;
#line 1181
  adapter->num_rx_queues = 0;
#line 1183
  ixgbe_free_q_vectors(adapter);
#line 1184
  ixgbe_reset_interrupt_capability(adapter);
  }
#line 1185
  return;
}
}
#line 1187 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c"
void ixgbe_tx_ctxtdesc(struct ixgbe_ring *tx_ring , u32 vlan_macip_lens , u32 fcoe_sof_eof ,
                       u32 type_tucmd , u32 mss_l4len_idx ) 
{ 
  struct ixgbe_adv_tx_context_desc *context_desc ;
  u16 i ;

  {
#line 1191
  i = tx_ring->next_to_use;
#line 1193
  context_desc = (struct ixgbe_adv_tx_context_desc *)tx_ring->desc + (unsigned long )i;
#line 1195
  i = (u16 )((int )i + 1);
#line 1196
  tx_ring->next_to_use = (int )i < (int )tx_ring->count ? i : 0U;
#line 1199
  type_tucmd = type_tucmd | 538968064U;
#line 1201
  context_desc->vlan_macip_lens = vlan_macip_lens;
#line 1202
  context_desc->seqnum_seed = fcoe_sof_eof;
#line 1203
  context_desc->type_tucmd_mlhl = type_tucmd;
#line 1204
  context_desc->mss_l4len_idx = mss_l4len_idx;
#line 1205
  return;
}
}
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/err.h"
long ldv_is_err(void const   *ptr ) ;
#line 230 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernel.h"
extern void might_fault(void) ;
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/err.h"
__inline static long IS_ERR(void const   *ptr ) ;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/math64.h"
__inline static u64 div_u64_rem(u64 dividend , u32 divisor , u32 *remainder ) 
{ 


  {
#line 20
  *remainder = (u32 )(dividend % (u64 )divisor);
#line 21
  return (dividend / (u64 )divisor);
}
}
#line 97 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/math64.h"
__inline static u64 div_u64(u64 dividend , u32 divisor ) 
{ 
  u32 remainder ;
  u64 tmp ;

  {
  {
#line 100
  tmp = div_u64_rem(dividend, divisor, & remainder);
  }
#line 100
  return (tmp);
}
}
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock_api_smp.h"
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 356 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 358
  _raw_spin_unlock_irqrestore(& lock->__annonCompField19.rlock, flags);
  }
#line 359
  return;
}
}
#line 375 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ktime.h"
__inline static ktime_t ns_to_ktime(u64 ns ) 
{ 
  ktime_t ktime_zero ;
  ktime_t __constr_expr_0 ;

  {
#line 377
  ktime_zero.tv64 = 0LL;
#line 379
  __constr_expr_0.tv64 = (long long )((unsigned long long )ktime_zero.tv64 + ns);
#line 379
  return (__constr_expr_0);
}
}
#line 99 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/clocksource.h"
extern void timecounter_init(struct timecounter * , struct cyclecounter  const  * ,
                             u64  ) ;
#line 111
extern u64 timecounter_read(struct timecounter * ) ;
#line 127
extern u64 timecounter_cyc2time(struct timecounter * , cycle_t  ) ;
#line 328 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/hrtimer.h"
extern ktime_t ktime_get_real(void) ;
#line 645 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 647
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 667
extern void __copy_from_user_overflow(void) ;
#line 672
extern void __copy_to_user_overflow(void) ;
#line 688 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 690
  sz = -1;
#line 692
  might_fault();
#line 712
  tmp = __builtin_expect(sz < 0, 1L);
  }
#line 712
  if (tmp != 0L) {
    {
#line 713
    n = _copy_from_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 712
    tmp___0 = __builtin_expect((unsigned long )sz >= n, 1L);
    }
#line 712
    if (tmp___0 != 0L) {
      {
#line 713
      n = _copy_from_user(to, from, (unsigned int )n);
      }
    } else {
      {
#line 717
      __copy_from_user_overflow();
      }
    }
  }
#line 719
  return (n);
}
}
#line 723 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 725
  sz = -1;
#line 727
  might_fault();
#line 730
  tmp = __builtin_expect(sz < 0, 1L);
  }
#line 730
  if (tmp != 0L) {
    {
#line 731
    n = _copy_to_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 730
    tmp___0 = __builtin_expect((unsigned long )sz >= n, 1L);
    }
#line 730
    if (tmp___0 != 0L) {
      {
#line 731
      n = _copy_to_user(to, from, (unsigned int )n);
      }
    } else {
      {
#line 735
      __copy_to_user_overflow();
      }
    }
  }
#line 737
  return (n);
}
}
#line 822 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 824
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
  }
#line 824
  return (& ((struct skb_shared_info *)tmp)->hwtstamps);
}
}
#line 104 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/ptp_clock_kernel.h"
extern struct ptp_clock *ptp_clock_register(struct ptp_clock_info * , struct device * ) ;
#line 113
extern int ptp_clock_unregister(struct ptp_clock * ) ;
#line 148
extern void ptp_clock_event(struct ptp_clock * , struct ptp_clock_event * ) ;
#line 117 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_setup_sdp(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  int shift ;
  u32 esdp ;
  u32 tsauxc ;
  u32 clktiml ;
  u32 clktimh ;
  u32 trgttiml ;
  u32 trgttimh ;
  u32 rem ;
  u64 ns ;
  u64 clock_edge ;
  u32 tmp ;
  u32 tmp___0 ;

  {
#line 119
  hw = & adapter->hw;
#line 120
  shift = (int )adapter->cc.shift;
#line 122
  ns = 0ULL;
#line 122
  clock_edge = 0ULL;
#line 124
  if ((adapter->flags2 & 1024U) != 0U && (unsigned int )hw->mac.type == 3U) {
    {
#line 128
    ixgbe_write_reg(hw, 35872U, 0U);
#line 129
    ixgbe_read_reg(hw, 8U);
#line 131
    esdp = ixgbe_read_reg(hw, 32U);
#line 137
    esdp = esdp | 65792U;
#line 144
    tsauxc = 76U;
#line 149
    clktiml = (unsigned int )(1000000000ULL << shift);
#line 150
    clktimh = (unsigned int )((1000000000ULL << shift) >> 32);
#line 157
    tmp = ixgbe_read_reg(hw, 35852U);
#line 157
    clock_edge = clock_edge | (unsigned long long )tmp;
#line 158
    tmp___0 = ixgbe_read_reg(hw, 35856U);
#line 158
    clock_edge = clock_edge | ((unsigned long long )tmp___0 << 32);
#line 159
    ns = timecounter_cyc2time(& adapter->tc, clock_edge);
#line 161
    div_u64_rem(ns, 1000000000U, & rem);
#line 162
    clock_edge = clock_edge + ((1000000000ULL - (unsigned long long )rem) << shift);
#line 165
    trgttiml = (unsigned int )clock_edge;
#line 166
    trgttimh = (unsigned int )(clock_edge >> 32);
#line 168
    ixgbe_write_reg(hw, 35892U, clktiml);
#line 169
    ixgbe_write_reg(hw, 35896U, clktimh);
#line 170
    ixgbe_write_reg(hw, 35876U, trgttiml);
#line 171
    ixgbe_write_reg(hw, 35880U, trgttimh);
#line 173
    ixgbe_write_reg(hw, 32U, esdp);
#line 174
    ixgbe_write_reg(hw, 35872U, tsauxc);
    }
  } else {
    {
#line 176
    ixgbe_write_reg(hw, 35872U, 0U);
    }
  }
  {
#line 179
  ixgbe_read_reg(hw, 8U);
  }
#line 180
  return;
}
}
#line 190 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static cycle_t ixgbe_ptp_read(struct cyclecounter  const  *cc ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct cyclecounter  const  *__mptr ;
  struct ixgbe_hw *hw ;
  u64 stamp ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  {
#line 193
  __mptr = cc;
#line 193
  adapter = (struct ixgbe_adapter *)__mptr + 0xfffffffffffeffd8UL;
#line 194
  hw = & adapter->hw;
#line 195
  stamp = 0ULL;
#line 197
  tmp = ixgbe_read_reg(hw, 35852U);
#line 197
  stamp = stamp | (unsigned long long )tmp;
#line 198
  tmp___0 = ixgbe_read_reg(hw, 35856U);
#line 198
  stamp = stamp | ((unsigned long long )tmp___0 << 32);
  }
#line 200
  return (stamp);
}
}
#line 211 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_adjfreq(struct ptp_clock_info *ptp , s32 ppb ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;
  struct ixgbe_hw *hw ;
  u64 freq ;
  u32 diff ;
  u32 incval ;
  int neg_adj ;
  u64 tmp ;

  {
#line 214
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 214
  adapter = (struct ixgbe_adapter *)__mptr + 0xffffffffffff00e8UL;
#line 215
  hw = & adapter->hw;
#line 218
  neg_adj = 0;
#line 220
  if (ppb < 0) {
#line 221
    neg_adj = 1;
#line 222
    ppb = - ppb;
  } else {

  }
  {
#line 225
  __asm__  volatile   ("mfence": : : "memory");
#line 226
  incval = *((u32 volatile   *)(& adapter->base_incval));
#line 228
  freq = (u64 )incval;
#line 229
  freq = freq * (u64 )ppb;
#line 230
  tmp = div_u64(freq, 1000000000U);
#line 230
  diff = (u32 )tmp;
#line 232
  incval = neg_adj != 0 ? incval - diff : incval + diff;
  }
  {
#line 235
  if ((unsigned int )hw->mac.type == 3U) {
#line 235
    goto case_3;
  } else {

  }
#line 238
  if ((unsigned int )hw->mac.type == 2U) {
#line 238
    goto case_2;
  } else {

  }
#line 243
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 236
  ixgbe_write_reg(hw, 35860U, incval);
  }
#line 237
  goto ldv_50792;
  case_2: /* CIL Label */ 
  {
#line 239
  ixgbe_write_reg(hw, 35860U, incval | 16777216U);
  }
#line 242
  goto ldv_50792;
  switch_default: /* CIL Label */ ;
#line 244
  goto ldv_50792;
  switch_break: /* CIL Label */ ;
  }
  ldv_50792: ;
#line 247
  return (0);
}
}
#line 257 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_adjtime(struct ptp_clock_info *ptp , s64 delta ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;
  unsigned long flags ;
  u64 now ;
  raw_spinlock_t *tmp ;

  {
  {
#line 260
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 260
  adapter = (struct ixgbe_adapter *)__mptr + 0xffffffffffff00e8UL;
#line 264
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 264
  flags = _raw_spin_lock_irqsave(tmp);
#line 266
  now = timecounter_read(& adapter->tc);
#line 267
  now = now + (unsigned long long )delta;
#line 270
  timecounter_init(& adapter->tc, (struct cyclecounter  const  *)(& adapter->cc),
                   now);
#line 274
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 276
  ixgbe_ptp_setup_sdp(adapter);
  }
#line 278
  return (0);
}
}
#line 289 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_gettime(struct ptp_clock_info *ptp , struct timespec *ts ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;
  u64 ns ;
  u32 remainder ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  u64 tmp___0 ;

  {
  {
#line 292
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 292
  adapter = (struct ixgbe_adapter *)__mptr + 0xffffffffffff00e8UL;
#line 297
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 297
  flags = _raw_spin_lock_irqsave(tmp);
#line 298
  ns = timecounter_read(& adapter->tc);
#line 299
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 301
  tmp___0 = div_u64_rem(ns, 1000000000U, & remainder);
#line 301
  ts->tv_sec = (__kernel_time_t )tmp___0;
#line 302
  ts->tv_nsec = (long )remainder;
  }
#line 304
  return (0);
}
}
#line 315 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_settime(struct ptp_clock_info *ptp , struct timespec  const  *ts ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;
  u64 ns ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  {
#line 319
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 319
  adapter = (struct ixgbe_adapter *)__mptr + 0xffffffffffff00e8UL;
#line 323
  ns = (unsigned long long )ts->tv_sec * 1000000000ULL;
#line 324
  ns = ns + (unsigned long long )ts->tv_nsec;
#line 327
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 327
  flags = _raw_spin_lock_irqsave(tmp);
#line 328
  timecounter_init(& adapter->tc, (struct cyclecounter  const  *)(& adapter->cc),
                   ns);
#line 329
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 331
  ixgbe_ptp_setup_sdp(adapter);
  }
#line 332
  return (0);
}
}
#line 344 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static int ixgbe_ptp_enable(struct ptp_clock_info *ptp , struct ptp_clock_request *rq ,
                            int on ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ptp_clock_info  const  *__mptr ;

  {
#line 348
  __mptr = (struct ptp_clock_info  const  *)ptp;
#line 348
  adapter = (struct ixgbe_adapter *)__mptr + 0xffffffffffff00e8UL;
#line 356
  if ((unsigned int )rq->type == 2U) {
    {
#line 358
    if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 358
      goto case_3;
    } else {

    }
#line 366
    goto switch_default;
    case_3: /* CIL Label */ ;
#line 359
    if (on != 0) {
#line 360
      adapter->flags2 = adapter->flags2 | 1024U;
    } else {
#line 362
      adapter->flags2 = adapter->flags2 & 4294966271U;
    }
    {
#line 364
    ixgbe_ptp_setup_sdp(adapter);
    }
#line 365
    return (0);
    switch_default: /* CIL Label */ ;
#line 367
    goto ldv_50842;
    switch_break: /* CIL Label */ ;
    }
    ldv_50842: ;
  } else {

  }
#line 371
  return (-524);
}
}
#line 382 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter , u32 eicr ) 
{ 
  struct ixgbe_hw *hw ;
  struct ptp_clock_event event ;

  {
#line 384
  hw = & adapter->hw;
#line 387
  event.type = 2;
#line 393
  if ((unsigned long )adapter->ptp_clock == (unsigned long )((struct ptp_clock *)0)) {
#line 394
    return;
  } else {

  }
  {
#line 397
  if ((unsigned int )hw->mac.type == 3U) {
#line 397
    goto case_3;
  } else {

  }
#line 400
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 398
  ptp_clock_event(adapter->ptp_clock, & event);
  }
#line 399
  goto ldv_50850;
  switch_default: /* CIL Label */ ;
#line 401
  goto ldv_50850;
  switch_break: /* CIL Label */ ;
  }
  ldv_50850: ;
#line 404
  return;
}
}
#line 413 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter ) 
{ 
  bool timeout ;
  struct timespec ts ;

  {
#line 415
  timeout = (bool )((long )((adapter->last_overflow_check - (unsigned long )jiffies) + 7500UL) < 0L);
#line 419
  if ((int )timeout) {
    {
#line 420
    ixgbe_ptp_gettime(& adapter->ptp_caps, & ts);
#line 421
    adapter->last_overflow_check = jiffies;
    }
  } else {

  }
#line 423
  return;
}
}
#line 434 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct ixgbe_ring *rx_ring ;
  u32 tsyncrxctl ;
  u32 tmp ;
  unsigned long rx_event ;
  int n ;

  {
  {
#line 436
  hw = & adapter->hw;
#line 438
  tmp = ixgbe_read_reg(hw, 20872U);
#line 438
  tsyncrxctl = tmp;
  }
#line 445
  if ((tsyncrxctl & 1U) == 0U) {
#line 446
    adapter->last_rx_ptp_check = jiffies;
#line 447
    return;
  } else {

  }
#line 451
  rx_event = adapter->last_rx_ptp_check;
#line 452
  n = 0;
#line 452
  goto ldv_50878;
  ldv_50877: 
#line 453
  rx_ring = adapter->rx_ring[n];
#line 454
  if ((long )(rx_event - rx_ring->last_rx_timestamp) < 0L) {
#line 455
    rx_event = rx_ring->last_rx_timestamp;
  } else {

  }
#line 452
  n = n + 1;
  ldv_50878: ;
#line 452
  if (n < adapter->num_rx_queues) {
#line 454
    goto ldv_50877;
  } else {

  }

#line 459
  if ((long )((rx_event - (unsigned long )jiffies) + 1250UL) < 0L) {
    {
#line 460
    ixgbe_read_reg(hw, 20900U);
#line 461
    adapter->last_rx_ptp_check = jiffies;
    }
#line 463
    if ((int )adapter->msg_enable & 1) {
      {
#line 463
      netdev_warn((struct net_device  const  *)adapter->netdev, "clearing RX Timestamp hang");
      }
    } else {

    }
  } else {

  }
#line 465
  return;
}
}
#line 475 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_tx_hwtstamp(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  struct skb_shared_hwtstamps shhwtstamps ;
  u64 regval ;
  u64 ns ;
  unsigned long flags ;
  u32 tmp ;
  u32 tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
  {
#line 477
  hw = & adapter->hw;
#line 479
  regval = 0ULL;
#line 482
  tmp = ixgbe_read_reg(hw, 35844U);
#line 482
  regval = regval | (unsigned long long )tmp;
#line 483
  tmp___0 = ixgbe_read_reg(hw, 35848U);
#line 483
  regval = regval | ((unsigned long long )tmp___0 << 32);
#line 485
  tmp___1 = spinlock_check(& adapter->tmreg_lock);
#line 485
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 486
  ns = timecounter_cyc2time(& adapter->tc, regval);
#line 487
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 489
  memset((void *)(& shhwtstamps), 0, 16UL);
#line 490
  shhwtstamps.hwtstamp = ns_to_ktime(ns);
#line 491
  skb_tstamp_tx(adapter->ptp_tx_skb, & shhwtstamps);
#line 493
  dev_kfree_skb_any(adapter->ptp_tx_skb);
#line 494
  adapter->ptp_tx_skb = (struct sk_buff *)0;
  }
#line 495
  return;
}
}
#line 505 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
static void ixgbe_ptp_tx_hwtstamp_work(struct work_struct *work ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct ixgbe_hw *hw ;
  bool timeout ;
  u32 tsynctxctl ;

  {
#line 507
  __mptr = (struct work_struct  const  *)work;
#line 507
  adapter = (struct ixgbe_adapter *)__mptr + 0xffffffffffff0090UL;
#line 509
  hw = & adapter->hw;
#line 510
  timeout = (bool )((long )((adapter->ptp_tx_start - (unsigned long )jiffies) + 3750UL) < 0L);
#line 515
  if ((unsigned long )adapter->ptp_tx_skb == (unsigned long )((struct sk_buff *)0)) {
#line 516
    return;
  } else {

  }
#line 518
  if ((int )timeout) {
    {
#line 519
    dev_kfree_skb_any(adapter->ptp_tx_skb);
#line 520
    adapter->ptp_tx_skb = (struct sk_buff *)0;
    }
#line 521
    if ((int )adapter->msg_enable & 1) {
      {
#line 521
      netdev_warn((struct net_device  const  *)adapter->netdev, "clearing Tx Timestamp hang");
      }
    } else {

    }
#line 522
    return;
  } else {

  }
  {
#line 525
  tsynctxctl = ixgbe_read_reg(hw, 35840U);
  }
#line 526
  if ((int )tsynctxctl & 1) {
    {
#line 527
    ixgbe_ptp_tx_hwtstamp(adapter);
    }
  } else {
    {
#line 530
    schedule_work(& adapter->ptp_tx_work);
    }
  }
#line 531
  return;
}
}
#line 542 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void __ixgbe_ptp_rx_hwtstamp(struct ixgbe_q_vector *q_vector , struct sk_buff *skb ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  struct skb_shared_hwtstamps *shhwtstamps ;
  u64 regval ;
  u64 ns ;
  u32 tsyncrxctl ;
  unsigned long flags ;
  u32 tmp ;
  u32 tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
#line 548
  regval = 0ULL;
#line 553
  if ((unsigned long )q_vector == (unsigned long )((struct ixgbe_q_vector *)0) || (unsigned long )q_vector->adapter == (unsigned long )((struct ixgbe_adapter *)0)) {
#line 554
    return;
  } else {

  }
  {
#line 556
  adapter = q_vector->adapter;
#line 557
  hw = & adapter->hw;
#line 563
  tsyncrxctl = ixgbe_read_reg(hw, 20872U);
  }
#line 564
  if ((tsyncrxctl & 1U) == 0U) {
#line 565
    return;
  } else {

  }
  {
#line 567
  tmp = ixgbe_read_reg(hw, 20968U);
#line 567
  regval = regval | (unsigned long long )tmp;
#line 568
  tmp___0 = ixgbe_read_reg(hw, 20900U);
#line 568
  regval = regval | ((unsigned long long )tmp___0 << 32);
#line 571
  tmp___1 = spinlock_check(& adapter->tmreg_lock);
#line 571
  flags = _raw_spin_lock_irqsave(tmp___1);
#line 572
  ns = timecounter_cyc2time(& adapter->tc, regval);
#line 573
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 575
  shhwtstamps = skb_hwtstamps(skb);
#line 576
  shhwtstamps->hwtstamp = ns_to_ktime(ns);
  }
#line 577
  return;
}
}
#line 602 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
int ixgbe_ptp_hwtstamp_ioctl(struct ixgbe_adapter *adapter , struct ifreq *ifr , int cmd ) 
{ 
  struct ixgbe_hw *hw ;
  struct hwtstamp_config config ;
  u32 tsync_tx_ctl ;
  u32 tsync_rx_ctl ;
  u32 tsync_rx_mtrl ;
  bool is_l2 ;
  u32 regval ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 605
  hw = & adapter->hw;
#line 607
  tsync_tx_ctl = 16U;
#line 608
  tsync_rx_ctl = 16U;
#line 609
  tsync_rx_mtrl = 20905984U;
#line 610
  is_l2 = 0;
#line 613
  tmp = copy_from_user((void *)(& config), (void const   *)ifr->ifr_ifru.ifru_data,
                       12UL);
  }
#line 613
  if (tmp != 0UL) {
#line 614
    return (-14);
  } else {

  }
#line 617
  if (config.flags != 0) {
#line 618
    return (-22);
  } else {

  }
  {
#line 621
  if (config.tx_type == 0) {
#line 621
    goto case_0;
  } else {

  }
#line 623
  if (config.tx_type == 1) {
#line 623
    goto case_1;
  } else {

  }
#line 625
  goto switch_default;
  case_0: /* CIL Label */ 
#line 622
  tsync_tx_ctl = 0U;
  case_1: /* CIL Label */ ;
#line 624
  goto ldv_50940;
  switch_default: /* CIL Label */ ;
#line 626
  return (-34);
  switch_break: /* CIL Label */ ;
  }
  ldv_50940: ;
  {
#line 630
  if (config.rx_filter == 0) {
#line 630
    goto case_0___0;
  } else {

  }
#line 634
  if (config.rx_filter == 4) {
#line 634
    goto case_4;
  } else {

  }
#line 638
  if (config.rx_filter == 5) {
#line 638
    goto case_5;
  } else {

  }
#line 642
  if (config.rx_filter == 12) {
#line 642
    goto case_12;
  } else {

  }
#line 643
  if (config.rx_filter == 9) {
#line 643
    goto case_9;
  } else {

  }
#line 644
  if (config.rx_filter == 6) {
#line 644
    goto case_6;
  } else {

  }
#line 645
  if (config.rx_filter == 13) {
#line 645
    goto case_13;
  } else {

  }
#line 646
  if (config.rx_filter == 10) {
#line 646
    goto case_10;
  } else {

  }
#line 647
  if (config.rx_filter == 7) {
#line 647
    goto case_7;
  } else {

  }
#line 648
  if (config.rx_filter == 14) {
#line 648
    goto case_14;
  } else {

  }
#line 649
  if (config.rx_filter == 11) {
#line 649
    goto case_11;
  } else {

  }
#line 650
  if (config.rx_filter == 8) {
#line 650
    goto case_8;
  } else {

  }
#line 655
  if (config.rx_filter == 3) {
#line 655
    goto case_3;
  } else {

  }
#line 656
  if (config.rx_filter == 1) {
#line 656
    goto case_1___0;
  } else {

  }
#line 657
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 631
  tsync_rx_ctl = 0U;
#line 632
  tsync_rx_mtrl = 0U;
#line 633
  goto ldv_50943;
  case_4: /* CIL Label */ 
#line 635
  tsync_rx_ctl = tsync_rx_ctl | 2U;
#line 636
  tsync_rx_mtrl = tsync_rx_mtrl;
#line 637
  goto ldv_50943;
  case_5: /* CIL Label */ 
#line 639
  tsync_rx_ctl = tsync_rx_ctl | 2U;
#line 640
  tsync_rx_mtrl = tsync_rx_mtrl | 1U;
#line 641
  goto ldv_50943;
  case_12: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_6: /* CIL Label */ ;
  case_13: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_7: /* CIL Label */ ;
  case_14: /* CIL Label */ ;
  case_11: /* CIL Label */ ;
  case_8: /* CIL Label */ 
#line 651
  tsync_rx_ctl = tsync_rx_ctl | 10U;
#line 652
  is_l2 = 1;
#line 653
  config.rx_filter = 12;
#line 654
  goto ldv_50943;
  case_3: /* CIL Label */ ;
  case_1___0: /* CIL Label */ ;
  switch_default___0: /* CIL Label */ 
#line 664
  config.rx_filter = 0;
#line 665
  return (-34);
  switch_break___0: /* CIL Label */ ;
  }
  ldv_50943: ;
#line 668
  if ((unsigned int )hw->mac.type == 1U) {
#line 669
    if ((tsync_rx_ctl | tsync_tx_ctl) != 0U) {
#line 670
      return (-34);
    } else {

    }
#line 671
    return (0);
  } else {

  }
#line 675
  if ((int )is_l2) {
    {
#line 676
    ixgbe_write_reg(hw, 20788U, 3221260535U);
    }
  } else {
    {
#line 681
    ixgbe_write_reg(hw, 20788U, 0U);
    }
  }
  {
#line 685
  regval = ixgbe_read_reg(hw, 35840U);
#line 686
  regval = regval & 4294967279U;
#line 687
  regval = regval | tsync_tx_ctl;
#line 688
  ixgbe_write_reg(hw, 35840U, regval);
#line 691
  regval = ixgbe_read_reg(hw, 20872U);
#line 692
  regval = regval & 4294967265U;
#line 693
  regval = regval | tsync_rx_ctl;
#line 694
  ixgbe_write_reg(hw, 20872U, regval);
#line 697
  ixgbe_write_reg(hw, 20768U, tsync_rx_mtrl);
#line 699
  ixgbe_read_reg(hw, 8U);
#line 702
  regval = ixgbe_read_reg(hw, 35848U);
#line 703
  regval = ixgbe_read_reg(hw, 20900U);
#line 705
  tmp___0 = copy_to_user(ifr->ifr_ifru.ifru_data, (void const   *)(& config), 12UL);
  }
#line 705
  return (tmp___0 != 0UL ? -14 : 0);
}
}
#line 719 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  u32 incval ;
  u32 shift ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
#line 721
  hw = & adapter->hw;
#line 722
  incval = 0U;
#line 723
  shift = 0U;
  {
#line 741
  if (adapter->link_speed == 8U) {
#line 741
    goto case_8;
  } else {

  }
#line 745
  if (adapter->link_speed == 32U) {
#line 745
    goto case_32;
  } else {

  }
#line 749
  if (adapter->link_speed == 128U) {
#line 749
    goto case_128;
  } else {

  }
#line 750
  goto switch_default;
  case_8: /* CIL Label */ 
#line 742
  incval = 1342177280U;
#line 743
  shift = 21U;
#line 744
  goto ldv_50966;
  case_32: /* CIL Label */ 
#line 746
  incval = 1073741824U;
#line 747
  shift = 24U;
#line 748
  goto ldv_50966;
  case_128: /* CIL Label */ ;
  switch_default: /* CIL Label */ 
#line 751
  incval = 1717986918U;
#line 752
  shift = 28U;
#line 753
  goto ldv_50966;
  switch_break: /* CIL Label */ ;
  }
  ldv_50966: ;
  {
#line 763
  if ((unsigned int )hw->mac.type == 3U) {
#line 763
    goto case_3;
  } else {

  }
#line 766
  if ((unsigned int )hw->mac.type == 2U) {
#line 766
    goto case_2;
  } else {

  }
#line 773
  goto switch_default___0;
  case_3: /* CIL Label */ 
  {
#line 764
  ixgbe_write_reg(hw, 35860U, incval);
  }
#line 765
  goto ldv_50971;
  case_2: /* CIL Label */ 
  {
#line 767
  incval = incval >> 7;
#line 768
  shift = shift - 7U;
#line 769
  ixgbe_write_reg(hw, 35860U, incval | 16777216U);
  }
#line 772
  goto ldv_50971;
  switch_default___0: /* CIL Label */ ;
#line 775
  return;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_50971: 
  {
#line 779
  *((u32 volatile   *)(& adapter->base_incval)) = incval;
#line 780
  __asm__  volatile   ("mfence": : : "memory");
#line 783
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 783
  flags = _raw_spin_lock_irqsave(tmp);
#line 785
  memset((void *)(& adapter->cc), 0, 24UL);
#line 786
  adapter->cc.read = & ixgbe_ptp_read;
#line 787
  adapter->cc.mask = 0xffffffffffffffffULL;
#line 788
  adapter->cc.shift = shift;
#line 789
  adapter->cc.mult = 1U;
#line 791
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
  }
#line 792
  return;
}
}
#line 802 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_reset(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_hw *hw ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  ktime_t tmp___0 ;

  {
  {
#line 804
  hw = & adapter->hw;
#line 808
  ixgbe_write_reg(hw, 35852U, 0U);
#line 809
  ixgbe_write_reg(hw, 35856U, 0U);
#line 810
  ixgbe_read_reg(hw, 8U);
#line 812
  ixgbe_ptp_start_cyclecounter(adapter);
#line 814
  tmp = spinlock_check(& adapter->tmreg_lock);
#line 814
  flags = _raw_spin_lock_irqsave(tmp);
#line 817
  tmp___0 = ktime_get_real();
#line 817
  timecounter_init(& adapter->tc, (struct cyclecounter  const  *)(& adapter->cc),
                   (u64 )tmp___0.tv64);
#line 820
  spin_unlock_irqrestore(& adapter->tmreg_lock, flags);
#line 826
  ixgbe_ptp_setup_sdp(adapter);
  }
#line 827
  return;
}
}
#line 837 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_init(struct ixgbe_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  long tmp ;

  {
#line 839
  netdev = adapter->netdev;
  {
#line 842
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 842
    goto case_3;
  } else {

  }
#line 856
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 856
    goto case_2;
  } else {

  }
#line 870
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 843
  snprintf((char *)(& adapter->ptp_caps.name), 16UL, "%s", (char *)(& netdev->name));
#line 844
  adapter->ptp_caps.owner = & __this_module;
#line 845
  adapter->ptp_caps.max_adj = 250000000;
#line 846
  adapter->ptp_caps.n_alarm = 0;
#line 847
  adapter->ptp_caps.n_ext_ts = 0;
#line 848
  adapter->ptp_caps.n_per_out = 0;
#line 849
  adapter->ptp_caps.pps = 1;
#line 850
  adapter->ptp_caps.adjfreq = & ixgbe_ptp_adjfreq;
#line 851
  adapter->ptp_caps.adjtime = & ixgbe_ptp_adjtime;
#line 852
  adapter->ptp_caps.gettime = & ixgbe_ptp_gettime;
#line 853
  adapter->ptp_caps.settime = & ixgbe_ptp_settime;
#line 854
  adapter->ptp_caps.enable = & ixgbe_ptp_enable;
  }
#line 855
  goto ldv_50990;
  case_2: /* CIL Label */ 
  {
#line 857
  snprintf((char *)(& adapter->ptp_caps.name), 16UL, "%s", (char *)(& netdev->name));
#line 858
  adapter->ptp_caps.owner = & __this_module;
#line 859
  adapter->ptp_caps.max_adj = 250000000;
#line 860
  adapter->ptp_caps.n_alarm = 0;
#line 861
  adapter->ptp_caps.n_ext_ts = 0;
#line 862
  adapter->ptp_caps.n_per_out = 0;
#line 863
  adapter->ptp_caps.pps = 0;
#line 864
  adapter->ptp_caps.adjfreq = & ixgbe_ptp_adjfreq;
#line 865
  adapter->ptp_caps.adjtime = & ixgbe_ptp_adjtime;
#line 866
  adapter->ptp_caps.gettime = & ixgbe_ptp_gettime;
#line 867
  adapter->ptp_caps.settime = & ixgbe_ptp_settime;
#line 868
  adapter->ptp_caps.enable = & ixgbe_ptp_enable;
  }
#line 869
  goto ldv_50990;
  switch_default: /* CIL Label */ 
#line 871
  adapter->ptp_clock = (struct ptp_clock *)0;
#line 872
  return;
  switch_break: /* CIL Label */ ;
  }
  ldv_50990: 
  {
#line 875
  spinlock_check(& adapter->tmreg_lock);
#line 875
  __raw_spin_lock_init(& adapter->tmreg_lock.__annonCompField19.rlock, "&(&adapter->tmreg_lock)->rlock",
                       & __key);
#line 876
  __init_work(& adapter->ptp_tx_work, 0);
#line 876
  __constr_expr_0.counter = 137438953408L;
#line 876
  adapter->ptp_tx_work.data = __constr_expr_0;
#line 876
  lockdep_init_map(& adapter->ptp_tx_work.lockdep_map, "(&adapter->ptp_tx_work)",
                   & __key___0, 0);
#line 876
  INIT_LIST_HEAD(& adapter->ptp_tx_work.entry);
#line 876
  adapter->ptp_tx_work.func = & ixgbe_ptp_tx_hwtstamp_work;
#line 878
  adapter->ptp_clock = ptp_clock_register(& adapter->ptp_caps, & (adapter->pdev)->dev);
#line 880
  tmp = IS_ERR((void const   *)adapter->ptp_clock);
  }
#line 880
  if (tmp != 0L) {
    {
#line 881
    adapter->ptp_clock = (struct ptp_clock *)0;
#line 882
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ptp_clock_register failed\n");
    }
  } else {
    {
#line 884
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "registered PHC device on %s\n",
              (char *)(& netdev->name));
    }
  }
  {
#line 886
  ixgbe_ptp_reset(adapter);
#line 889
  set_bit(6L, (unsigned long volatile   *)(& adapter->state));
  }
#line 891
  return;
}
}
#line 900 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c"
void ixgbe_ptp_stop(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;

  {
  {
#line 903
  tmp = test_and_set_bit(6L, (unsigned long volatile   *)(& adapter->state));
  }
#line 903
  if (tmp == 0) {
#line 904
    return;
  } else {

  }
  {
#line 907
  adapter->flags2 = adapter->flags2 & 4294966271U;
#line 908
  ixgbe_ptp_setup_sdp(adapter);
#line 910
  cancel_work_sync(& adapter->ptp_tx_work);
  }
#line 911
  if ((unsigned long )adapter->ptp_tx_skb != (unsigned long )((struct sk_buff *)0)) {
    {
#line 912
    dev_kfree_skb_any(adapter->ptp_tx_skb);
#line 913
    adapter->ptp_tx_skb = (struct sk_buff *)0;
    }
  } else {

  }
#line 916
  if ((unsigned long )adapter->ptp_clock != (unsigned long )((struct ptp_clock *)0)) {
    {
#line 917
    ptp_clock_unregister(adapter->ptp_clock);
#line 918
    adapter->ptp_clock = (struct ptp_clock *)0;
#line 919
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "removed PHC on %s\n",
              (char *)(& (adapter->netdev)->name));
    }
  } else {

  }
#line 921
  return;
}
}
#line 96 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_ptp.c.aux"
__inline static long IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 99
  tmp = ldv_is_err(ptr);
  }
#line 99
  return (tmp);
}
}
#line 143 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h"
void ixgbe_dcb_unpack_pfc(struct ixgbe_dcb_config *cfg , u8 *pfc_en ) ;
#line 144
void ixgbe_dcb_unpack_refill(struct ixgbe_dcb_config *cfg , int direction , u16 *refill ) ;
#line 145
void ixgbe_dcb_unpack_max(struct ixgbe_dcb_config *cfg , u16 *max ) ;
#line 146
void ixgbe_dcb_unpack_bwgid(struct ixgbe_dcb_config *cfg , int direction , u8 *bwgid ) ;
#line 147
void ixgbe_dcb_unpack_prio(struct ixgbe_dcb_config *cfg , int direction , u8 *ptype ) ;
#line 148
void ixgbe_dcb_unpack_map(struct ixgbe_dcb_config *cfg , int direction , u8 *map ) ;
#line 157
s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw , u16 *refill , u16 *max , u8 *bwg_id ,
                            u8 *prio_type , u8 *prio_tc ) ;
#line 162
void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw , u8 *map ) ;
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h"
s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw , u8 pfc_en ) ;
#line 77
s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                      u8 *prio_type ) ;
#line 82
s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) ;
#line 88
s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) ;
#line 94
s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw , u8 pfc_en , u16 *refill , u16 *max ,
                              u8 *bwg_id , u8 *prio_type ) ;
#line 97 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h"
s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw , u8 pfc_en , u8 *prio_tc ) ;
#line 100
s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                      u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) ;
#line 107
s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) ;
#line 113
s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) ;
#line 120
s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw , u8 pfc_en , u16 *refill , u16 *max ,
                              u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) ;
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
static s32 ixgbe_ieee_credits(__u8 *bw , __u16 *refill , __u16 *max , int max_frame ) 
{ 
  int min_percent ;
  int min_credit ;
  int multiplier ;
  int i ;
  int val ;
  int _min1 ;
  int _min2 ;

  {
#line 46
  min_percent = 100;
#line 50
  min_credit = (max_frame / 2 + 63) / 64;
#line 53
  i = 0;
#line 53
  goto ldv_50823;
  ldv_50822: ;
#line 54
  if ((int )*(bw + (unsigned long )i) < min_percent && (unsigned int )*(bw + (unsigned long )i) != 0U) {
#line 55
    min_percent = (int )*(bw + (unsigned long )i);
  } else {

  }
#line 53
  i = i + 1;
  ldv_50823: ;
#line 53
  if (i <= 7) {
#line 55
    goto ldv_50822;
  } else {

  }
#line 58
  multiplier = min_credit / min_percent + 1;
#line 61
  i = 0;
#line 61
  goto ldv_50830;
  ldv_50829: 
#line 62
  _min1 = (int )*(bw + (unsigned long )i) * multiplier;
#line 62
  _min2 = 511;
#line 62
  val = _min1 < _min2 ? _min1 : _min2;
#line 64
  if (val < min_credit) {
#line 65
    val = min_credit;
  } else {

  }
#line 66
  *(refill + (unsigned long )i) = (__u16 )val;
#line 68
  *(max + (unsigned long )i) = (unsigned int )*(bw + (unsigned long )i) != 0U ? (__u16 )(((int )*(bw + (unsigned long )i) * 4095) / 100) : (__u16 )min_credit;
#line 61
  i = i + 1;
  ldv_50830: ;
#line 61
  if (i <= 7) {
#line 63
    goto ldv_50829;
  } else {

  }

#line 70
  return (0);
}
}
#line 82 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw , struct ixgbe_dcb_config *dcb_config ,
                                   int max_frame , u8 direction ) 
{ 
  struct tc_bw_alloc *p ;
  int min_credit ;
  int min_multiplier ;
  int min_percent ;
  s32 ret_val ;
  u32 credit_refill ;
  u32 credit_max ;
  u16 link_percentage ;
  u8 bw_percent ;
  u8 i ;
  int _min1 ;
  int _min2 ;

  {
#line 89
  min_percent = 100;
#line 90
  ret_val = 0;
#line 92
  credit_refill = 0U;
#line 93
  credit_max = 0U;
#line 94
  link_percentage = 0U;
#line 95
  bw_percent = 0U;
#line 98
  if ((unsigned long )dcb_config == (unsigned long )((struct ixgbe_dcb_config *)0)) {
#line 99
    ret_val = -1;
#line 100
    goto out;
  } else {

  }
#line 103
  min_credit = (max_frame / 2 + 63) / 64;
#line 107
  i = 0U;
#line 107
  goto ldv_50850;
  ldv_50849: 
#line 108
  p = (struct tc_bw_alloc *)(& dcb_config->tc_config[(int )i].path) + (unsigned long )direction;
#line 109
  bw_percent = dcb_config->bw_percentage[(int )direction][(int )p->bwg_id];
#line 110
  link_percentage = (u16 )p->bwg_percent;
#line 112
  link_percentage = (u16 )(((int )link_percentage * (int )bw_percent) / 100);
#line 114
  if ((unsigned int )link_percentage != 0U && (int )link_percentage < min_percent) {
#line 115
    min_percent = (int )link_percentage;
  } else {

  }
#line 107
  i = (u8 )((int )i + 1);
  ldv_50850: ;
#line 107
  if ((unsigned int )i <= 7U) {
#line 109
    goto ldv_50849;
  } else {

  }
#line 126
  min_multiplier = min_credit / min_percent + 1;
#line 129
  i = 0U;
#line 129
  goto ldv_50856;
  ldv_50855: 
#line 130
  p = (struct tc_bw_alloc *)(& dcb_config->tc_config[(int )i].path) + (unsigned long )direction;
#line 131
  bw_percent = dcb_config->bw_percentage[(int )direction][(int )p->bwg_id];
#line 133
  link_percentage = (u16 )p->bwg_percent;
#line 135
  link_percentage = (u16 )(((int )link_percentage * (int )bw_percent) / 100);
#line 136
  if ((unsigned int )p->bwg_percent != 0U && (unsigned int )link_percentage == 0U) {
#line 137
    link_percentage = 1U;
  } else {

  }
#line 140
  p->link_percent = (unsigned char )link_percentage;
#line 143
  _min1 = (int )link_percentage * min_multiplier;
#line 143
  _min2 = 511;
#line 143
  credit_refill = (u32 )(_min1 < _min2 ? _min1 : _min2);
#line 145
  p->data_credits_refill = (unsigned short )credit_refill;
#line 148
  credit_max = (u32 )(((int )link_percentage * 4095) / 100);
#line 155
  if (credit_max != 0U && credit_max < (u32 )min_credit) {
#line 156
    credit_max = (u32 )min_credit;
  } else {

  }
#line 158
  if ((unsigned int )direction == 0U) {
#line 165
    if (((unsigned int )hw->mac.type == 1U && credit_max != 0U) && credit_max <= 512U) {
#line 168
      credit_max = 513U;
    } else {

    }
#line 170
    dcb_config->tc_config[(int )i].desc_credits_max = (unsigned short )credit_max;
  } else {

  }
#line 174
  p->data_credits_max = (unsigned short )credit_max;
#line 129
  i = (u8 )((int )i + 1);
  ldv_50856: ;
#line 129
  if ((unsigned int )i <= 7U) {
#line 131
    goto ldv_50855;
  } else {

  }

  out: ;
#line 178
  return (ret_val);
}
}
#line 181 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_pfc(struct ixgbe_dcb_config *cfg , u8 *pfc_en ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 183
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 186
  *pfc_en = 0U;
#line 186
  tc = 0;
#line 186
  goto ldv_50865;
  ldv_50864: ;
#line 187
  if ((unsigned int )(tc_config + (unsigned long )tc)->dcb_pfc != 0U) {
#line 188
    *pfc_en = (u8 )((int )((signed char )*pfc_en) | (int )((signed char )(1 << tc)));
  } else {

  }
#line 186
  tc = tc + 1;
  ldv_50865: ;
#line 186
  if (tc <= 7) {
#line 188
    goto ldv_50864;
  } else {

  }

#line 193
  return;
}
}
#line 192 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_refill(struct ixgbe_dcb_config *cfg , int direction , u16 *refill ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 195
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 198
  tc = 0;
#line 198
  goto ldv_50875;
  ldv_50874: 
#line 199
  *(refill + (unsigned long )tc) = (tc_config + (unsigned long )tc)->path[direction].data_credits_refill;
#line 198
  tc = tc + 1;
  ldv_50875: ;
#line 198
  if (tc <= 7) {
#line 200
    goto ldv_50874;
  } else {

  }

#line 205
  return;
}
}
#line 202 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_max(struct ixgbe_dcb_config *cfg , u16 *max ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 204
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 207
  tc = 0;
#line 207
  goto ldv_50884;
  ldv_50883: 
#line 208
  *(max + (unsigned long )tc) = (tc_config + (unsigned long )tc)->desc_credits_max;
#line 207
  tc = tc + 1;
  ldv_50884: ;
#line 207
  if (tc <= 7) {
#line 209
    goto ldv_50883;
  } else {

  }

#line 214
  return;
}
}
#line 211 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_bwgid(struct ixgbe_dcb_config *cfg , int direction , u8 *bwgid ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 214
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 217
  tc = 0;
#line 217
  goto ldv_50894;
  ldv_50893: 
#line 218
  *(bwgid + (unsigned long )tc) = (tc_config + (unsigned long )tc)->path[direction].bwg_id;
#line 217
  tc = tc + 1;
  ldv_50894: ;
#line 217
  if (tc <= 7) {
#line 219
    goto ldv_50893;
  } else {

  }

#line 224
  return;
}
}
#line 221 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_prio(struct ixgbe_dcb_config *cfg , int direction , u8 *ptype ) 
{ 
  struct tc_configuration *tc_config ;
  int tc ;

  {
#line 224
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 227
  tc = 0;
#line 227
  goto ldv_50904;
  ldv_50903: 
#line 228
  *(ptype + (unsigned long )tc) = (u8 )(tc_config + (unsigned long )tc)->path[direction].prio_type;
#line 227
  tc = tc + 1;
  ldv_50904: ;
#line 227
  if (tc <= 7) {
#line 229
    goto ldv_50903;
  } else {

  }

#line 234
  return;
}
}
#line 231 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *cfg , int direction , u8 up___0 ) 
{ 
  struct tc_configuration *tc_config ;
  u8 prio_mask ;
  u8 tc ;

  {
#line 233
  tc_config = (struct tc_configuration *)(& cfg->tc_config);
#line 234
  prio_mask = (u8 )(1 << (int )up___0);
#line 235
  tc = cfg->num_tcs.pg_tcs;
#line 238
  if ((unsigned int )tc == 0U) {
#line 239
    goto out;
  } else {

  }
#line 246
  tc = (u8 )((int )tc - 1);
#line 246
  goto ldv_50917;
  ldv_50916: ;
#line 247
  if ((unsigned int )((int )prio_mask & (int )(tc_config + (unsigned long )tc)->path[direction].up_to_tc_bitmap) != 0U) {
#line 248
    goto ldv_50915;
  } else {

  }
#line 246
  tc = (u8 )((int )tc - 1);
  ldv_50917: ;
#line 246
  if ((unsigned int )tc != 0U) {
#line 248
    goto ldv_50916;
  } else {

  }
  ldv_50915: ;
  out: ;
#line 251
  return (tc);
}
}
#line 254 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_unpack_map(struct ixgbe_dcb_config *cfg , int direction , u8 *map ) 
{ 
  u8 up___0 ;

  {
#line 258
  up___0 = 0U;
#line 258
  goto ldv_50925;
  ldv_50924: 
  {
#line 259
  *(map + (unsigned long )up___0) = ixgbe_dcb_get_tc_from_up(cfg, direction, (int )up___0);
#line 258
  up___0 = (u8 )((int )up___0 + 1);
  }
  ldv_50925: ;
#line 258
  if ((unsigned int )up___0 <= 7U) {
#line 260
    goto ldv_50924;
  } else {

  }

#line 265
  return;
}
}
#line 269 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw , struct ixgbe_dcb_config *dcb_config ) 
{ 
  s32 ret ;
  u8 pfc_en ;
  u8 ptype[8U] ;
  u8 bwgid[8U] ;
  u8 prio_tc[8U] ;
  u16 refill[8U] ;
  u16 max[8U] ;

  {
  {
#line 272
  ret = 0;
#line 281
  ixgbe_dcb_unpack_pfc(dcb_config, & pfc_en);
#line 282
  ixgbe_dcb_unpack_refill(dcb_config, 0, (u16 *)(& refill));
#line 283
  ixgbe_dcb_unpack_max(dcb_config, (u16 *)(& max));
#line 284
  ixgbe_dcb_unpack_bwgid(dcb_config, 0, (u8 *)(& bwgid));
#line 285
  ixgbe_dcb_unpack_prio(dcb_config, 0, (u8 *)(& ptype));
#line 286
  ixgbe_dcb_unpack_map(dcb_config, 0, (u8 *)(& prio_tc));
  }
  {
#line 289
  if ((unsigned int )hw->mac.type == 1U) {
#line 289
    goto case_1;
  } else {

  }
#line 293
  if ((unsigned int )hw->mac.type == 2U) {
#line 293
    goto case_2;
  } else {

  }
#line 294
  if ((unsigned int )hw->mac.type == 3U) {
#line 294
    goto case_3;
  } else {

  }
#line 298
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 290
  ret = ixgbe_dcb_hw_config_82598(hw, (int )pfc_en, (u16 *)(& refill), (u16 *)(& max),
                                  (u8 *)(& bwgid), (u8 *)(& ptype));
  }
#line 292
  goto ldv_50939;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 295
  ret = ixgbe_dcb_hw_config_82599(hw, (int )pfc_en, (u16 *)(& refill), (u16 *)(& max),
                                  (u8 *)(& bwgid), (u8 *)(& ptype), (u8 *)(& prio_tc));
  }
#line 297
  goto ldv_50939;
  switch_default: /* CIL Label */ ;
#line 299
  goto ldv_50939;
  switch_break: /* CIL Label */ ;
  }
  ldv_50939: ;
#line 301
  return (ret);
}
}
#line 305 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw , u8 pfc_en , u8 *prio_tc ) 
{ 
  int ret ;

  {
#line 307
  ret = -22;
  {
#line 310
  if ((unsigned int )hw->mac.type == 1U) {
#line 310
    goto case_1;
  } else {

  }
#line 313
  if ((unsigned int )hw->mac.type == 2U) {
#line 313
    goto case_2;
  } else {

  }
#line 314
  if ((unsigned int )hw->mac.type == 3U) {
#line 314
    goto case_3;
  } else {

  }
#line 317
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 311
  ret = ixgbe_dcb_config_pfc_82598(hw, (int )pfc_en);
  }
#line 312
  goto ldv_50950;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 315
  ret = ixgbe_dcb_config_pfc_82599(hw, (int )pfc_en, prio_tc);
  }
#line 316
  goto ldv_50950;
  switch_default: /* CIL Label */ ;
#line 318
  goto ldv_50950;
  switch_break: /* CIL Label */ ;
  }
  ldv_50950: ;
#line 320
  return (ret);
}
}
#line 323 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw , struct ieee_ets *ets , int max_frame ) 
{ 
  __u16 refill[8U] ;
  __u16 max[8U] ;
  __u8 prio_type[8U] ;
  int i ;
  __u8 bwg_id[8U] ;
  s32 tmp ;

  {
#line 330
  bwg_id[0] = 0U;
#line 330
  bwg_id[1] = 1U;
#line 330
  bwg_id[2] = 2U;
#line 330
  bwg_id[3] = 3U;
#line 330
  bwg_id[4] = 4U;
#line 330
  bwg_id[5] = 5U;
#line 330
  bwg_id[6] = 6U;
#line 330
  bwg_id[7] = 7U;
#line 333
  i = 0;
#line 333
  goto ldv_50969;
  ldv_50968: ;
  {
#line 335
  if ((int )ets->tc_tsa[i] == 0) {
#line 335
    goto case_0;
  } else {

  }
#line 338
  if ((int )ets->tc_tsa[i] == 2) {
#line 338
    goto case_2;
  } else {

  }
#line 341
  goto switch_default;
  case_0: /* CIL Label */ 
#line 336
  prio_type[i] = 2U;
#line 337
  goto ldv_50965;
  case_2: /* CIL Label */ 
#line 339
  prio_type[i] = 0U;
#line 340
  goto ldv_50965;
  switch_default: /* CIL Label */ ;
#line 347
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_50965: 
#line 333
  i = i + 1;
  ldv_50969: ;
#line 333
  if (i <= 7) {
#line 335
    goto ldv_50968;
  } else {

  }
  {
#line 351
  ixgbe_ieee_credits((__u8 *)(& ets->tc_tx_bw), (__u16 *)(& refill), (__u16 *)(& max),
                     max_frame);
#line 352
  tmp = ixgbe_dcb_hw_ets_config(hw, (u16 *)(& refill), (u16 *)(& max), (u8 *)(& bwg_id),
                                (u8 *)(& prio_type), (u8 *)(& ets->prio_tc));
  }
#line 352
  return (tmp);
}
}
#line 356 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw , u16 *refill , u16 *max , u8 *bwg_id ,
                            u8 *prio_type , u8 *prio_tc ) 
{ 


  {
  {
#line 361
  if ((unsigned int )hw->mac.type == 1U) {
#line 361
    goto case_1;
  } else {

  }
#line 369
  if ((unsigned int )hw->mac.type == 2U) {
#line 369
    goto case_2;
  } else {

  }
#line 370
  if ((unsigned int )hw->mac.type == 3U) {
#line 370
    goto case_3;
  } else {

  }
#line 378
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 362
  ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max, prio_type);
#line 364
  ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max, bwg_id, prio_type);
#line 366
  ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max, bwg_id, prio_type);
  }
#line 368
  goto ldv_50980;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 371
  ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max, bwg_id, prio_type, prio_tc);
#line 373
  ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max, bwg_id, prio_type);
#line 375
  ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max, bwg_id, prio_type, prio_tc);
  }
#line 377
  goto ldv_50980;
  switch_default: /* CIL Label */ ;
#line 379
  goto ldv_50980;
  switch_break: /* CIL Label */ ;
  }
  ldv_50980: ;
#line 381
  return (0);
}
}
#line 384 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
static void ixgbe_dcb_read_rtrup2tc_82599(struct ixgbe_hw *hw , u8 *map ) 
{ 
  u32 reg ;
  u32 i ;

  {
  {
#line 388
  reg = ixgbe_read_reg(hw, 12320U);
#line 389
  i = 0U;
  }
#line 389
  goto ldv_50991;
  ldv_50990: 
#line 390
  *(map + (unsigned long )i) = (unsigned int )((u8 )(reg >> (int )(i * 3U))) & 7U;
#line 389
  i = i + 1U;
  ldv_50991: ;
#line 389
  if (i <= 7U) {
#line 391
    goto ldv_50990;
  } else {

  }

#line 392
  return;
}
}
#line 395 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c"
void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw , u8 *map ) 
{ 


  {
  {
#line 398
  if ((unsigned int )hw->mac.type == 2U) {
#line 398
    goto case_2;
  } else {

  }
#line 399
  if ((unsigned int )hw->mac.type == 3U) {
#line 399
    goto case_3;
  } else {

  }
#line 402
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
  {
#line 400
  ixgbe_dcb_read_rtrup2tc_82599(hw, map);
  }
#line 401
  goto ldv_50999;
  switch_default: /* CIL Label */ ;
#line 403
  goto ldv_50999;
  switch_break: /* CIL Label */ ;
  }
  ldv_50999: ;
#line 406
  return;
}
}
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                      u8 *prio_type ) 
{ 
  u32 reg ;
  u32 credit_refill ;
  u32 credit_max ;
  u8 i ;
  u32 tmp ;

  {
  {
#line 46
  reg = 0U;
#line 47
  credit_refill = 0U;
#line 48
  credit_max = 0U;
#line 49
  i = 0U;
#line 51
  tmp = ixgbe_read_reg(hw, 20640U);
#line 51
  reg = tmp | 2147483648U;
#line 52
  ixgbe_write_reg(hw, 20640U, reg);
#line 54
  reg = ixgbe_read_reg(hw, 15616U);
#line 56
  reg = reg & 4294967231U;
#line 58
  reg = reg | 2U;
#line 60
  reg = reg | 4U;
#line 62
  ixgbe_write_reg(hw, 15616U, reg);
#line 65
  i = 0U;
  }
#line 65
  goto ldv_50791;
  ldv_50790: 
#line 66
  credit_refill = (u32 )*(refill + (unsigned long )i);
#line 67
  credit_max = (u32 )*(max + (unsigned long )i);
#line 69
  reg = credit_refill | (credit_max << 12);
#line 71
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 72
    reg = reg | 2147483648U;
  } else {

  }
  {
#line 74
  ixgbe_write_reg(hw, (u32 )(((int )i + 3848) * 4), reg);
#line 65
  i = (u8 )((int )i + 1);
  }
  ldv_50791: ;
#line 65
  if ((unsigned int )i <= 7U) {
#line 67
    goto ldv_50790;
  } else {

  }
  {
#line 77
  reg = ixgbe_read_reg(hw, 12032U);
#line 78
  reg = reg;
#line 79
  reg = reg | 16U;
#line 80
  reg = reg | 64U;
#line 81
  ixgbe_write_reg(hw, 12032U, reg);
#line 83
  reg = ixgbe_read_reg(hw, 12288U);
#line 85
  reg = reg & 4294967293U;
#line 86
  ixgbe_write_reg(hw, 12288U, reg);
  }
#line 88
  return (0);
}
}
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) 
{ 
  u32 reg ;
  u32 max_credits ;
  u8 i ;

  {
  {
#line 107
  reg = ixgbe_read_reg(hw, 32576U);
#line 110
  reg = reg & 4294967231U;
#line 111
  reg = reg | 524288U;
#line 114
  reg = reg | 262144U;
#line 116
  ixgbe_write_reg(hw, 32576U, reg);
#line 119
  i = 0U;
  }
#line 119
  goto ldv_50804;
  ldv_50803: 
#line 120
  max_credits = (u32 )*(max + (unsigned long )i);
#line 121
  reg = max_credits << 12;
#line 122
  reg = reg | (u32 )*(refill + (unsigned long )i);
#line 123
  reg = reg | ((unsigned int )*(bwg_id + (unsigned long )i) << 9);
#line 125
  if ((unsigned int )*(prio_type + (unsigned long )i) == 1U) {
#line 126
    reg = reg | 1073741824U;
  } else {

  }
#line 128
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 129
    reg = reg | 2147483648U;
  } else {

  }
  {
#line 131
  ixgbe_write_reg(hw, (u32 )((int )i * 64 + 24620), reg);
#line 119
  i = (u8 )((int )i + 1);
  }
  ldv_50804: ;
#line 119
  if ((unsigned int )i <= 7U) {
#line 121
    goto ldv_50803;
  } else {

  }

#line 134
  return (0);
}
}
#line 144 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) 
{ 
  u32 reg ;
  u8 i ;

  {
  {
#line 153
  reg = ixgbe_read_reg(hw, 52480U);
#line 155
  reg = reg & 4294967231U;
#line 157
  reg = reg | 288U;
#line 159
  ixgbe_write_reg(hw, 52480U, reg);
#line 162
  i = 0U;
  }
#line 162
  goto ldv_50816;
  ldv_50815: 
#line 163
  reg = (u32 )*(refill + (unsigned long )i);
#line 164
  reg = reg | ((unsigned int )*(max + (unsigned long )i) << 12);
#line 165
  reg = reg | ((unsigned int )*(bwg_id + (unsigned long )i) << 9);
#line 167
  if ((unsigned int )*(prio_type + (unsigned long )i) == 1U) {
#line 168
    reg = reg | 1073741824U;
  } else {

  }
#line 170
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 171
    reg = reg | 2147483648U;
  } else {

  }
  {
#line 173
  ixgbe_write_reg(hw, (u32 )(((int )i + 13128) * 4), reg);
#line 162
  i = (u8 )((int )i + 1);
  }
  ldv_50816: ;
#line 162
  if ((unsigned int )i <= 7U) {
#line 164
    goto ldv_50815;
  } else {

  }
  {
#line 177
  reg = ixgbe_read_reg(hw, 32256U);
#line 178
  reg = reg | 4U;
#line 179
  ixgbe_write_reg(hw, 32256U, reg);
  }
#line 181
  return (0);
}
}
#line 191 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw , u8 pfc_en ) 
{ 
  u32 fcrtl ;
  u32 reg ;
  u8 i ;

  {
  {
#line 197
  reg = ixgbe_read_reg(hw, 15616U);
#line 198
  reg = reg & 4294967287U;
#line 199
  reg = reg | 16U;
#line 200
  ixgbe_write_reg(hw, 15616U, reg);
#line 203
  reg = ixgbe_read_reg(hw, 20608U);
#line 204
  reg = reg & 4294918143U;
  }
#line 206
  if ((unsigned int )pfc_en != 0U) {
#line 207
    reg = reg | 16384U;
  } else {

  }
  {
#line 209
  ixgbe_write_reg(hw, 20608U, reg);
#line 211
  fcrtl = (hw->fc.low_water << 10) | 2147483648U;
#line 213
  i = 0U;
  }
#line 213
  goto ldv_50827;
  ldv_50826: ;
#line 214
  if ((((int )pfc_en >> (int )i) & 1) == 0) {
    {
#line 215
    ixgbe_write_reg(hw, (u32 )(((int )i + 1604) * 8), 0U);
#line 216
    ixgbe_write_reg(hw, (u32 )(((int )i + 1612) * 8), 0U);
    }
#line 217
    goto ldv_50825;
  } else {

  }
  {
#line 220
  reg = (hw->fc.high_water[(int )i] << 10) | 2147483648U;
#line 221
  ixgbe_write_reg(hw, (u32 )(((int )i + 1604) * 8), fcrtl);
#line 222
  ixgbe_write_reg(hw, (u32 )(((int )i + 1612) * 8), reg);
  }
  ldv_50825: 
#line 213
  i = (u8 )((int )i + 1);
  ldv_50827: ;
#line 213
  if ((unsigned int )i <= 7U) {
#line 215
    goto ldv_50826;
  } else {

  }
#line 226
  reg = (u32 )((int )hw->fc.pause_time * 65537);
#line 227
  i = 0U;
#line 227
  goto ldv_50830;
  ldv_50829: 
  {
#line 228
  ixgbe_write_reg(hw, (u32 )(((int )i + 3200) * 4), reg);
#line 227
  i = (u8 )((int )i + 1);
  }
  ldv_50830: ;
#line 227
  if ((unsigned int )i <= 3U) {
#line 229
    goto ldv_50829;
  } else {

  }
  {
#line 231
  ixgbe_write_reg(hw, 12960U, (unsigned int )hw->fc.pause_time / 2U);
  }
#line 234
  return (0);
}
}
#line 244 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
static s32 ixgbe_dcb_config_tc_stats_82598(struct ixgbe_hw *hw ) 
{ 
  u32 reg ;
  u8 i ;
  u8 j ;

  {
#line 246
  reg = 0U;
#line 247
  i = 0U;
#line 248
  j = 0U;
#line 251
  i = 0U;
#line 251
  j = 0U;
#line 251
  goto ldv_50839;
  ldv_50838: 
  {
#line 252
  reg = ixgbe_read_reg(hw, (u32 )(((int )i + 2240) * 4));
#line 253
  reg = reg | (u32 )((int )j * 16843009);
#line 254
  ixgbe_write_reg(hw, (u32 )(((int )i + 2240) * 4), reg);
#line 255
  reg = ixgbe_read_reg(hw, (u32 )(((int )i + 2241) * 4));
#line 256
  reg = reg | (u32 )((int )j * 16843009);
#line 257
  ixgbe_write_reg(hw, (u32 )(((int )i + 2241) * 4), reg);
#line 251
  i = (unsigned int )i + 2U;
#line 251
  j = (u8 )((int )j + 1);
  }
  ldv_50839: ;
#line 251
  if ((unsigned int )i <= 14U && (unsigned int )j <= 7U) {
#line 253
    goto ldv_50838;
  } else {

  }
#line 260
  i = 0U;
#line 260
  goto ldv_50842;
  ldv_50841: 
  {
#line 261
  reg = ixgbe_read_reg(hw, (u32 )((unsigned int )i <= 7U ? ((int )i + 7360) * 4 : ((int )i + 8576) * 4));
#line 262
  reg = reg | (u32 )((int )i * 16843009);
#line 263
  ixgbe_write_reg(hw, (u32 )((unsigned int )i <= 7U ? ((int )i + 7360) * 4 : ((int )i + 8576) * 4),
                  reg);
#line 260
  i = (u8 )((int )i + 1);
  }
  ldv_50842: ;
#line 260
  if ((unsigned int )i <= 7U) {
#line 262
    goto ldv_50841;
  } else {

  }

#line 266
  return (0);
}
}
#line 276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c"
s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw , u8 pfc_en , u16 *refill , u16 *max ,
                              u8 *bwg_id , u8 *prio_type ) 
{ 


  {
  {
#line 279
  ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max, prio_type);
#line 280
  ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max, bwg_id, prio_type);
#line 282
  ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max, bwg_id, prio_type);
#line 284
  ixgbe_dcb_config_pfc_82598(hw, (int )pfc_en);
#line 285
  ixgbe_dcb_config_tc_stats_82598(hw);
  }
#line 287
  return (0);
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                      u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) 
{ 
  u32 reg ;
  u32 credit_refill ;
  u32 credit_max ;
  u8 i ;

  {
  {
#line 50
  reg = 0U;
#line 51
  credit_refill = 0U;
#line 52
  credit_max = 0U;
#line 53
  i = 0U;
#line 59
  reg = 70U;
#line 60
  ixgbe_write_reg(hw, 9264U, reg);
#line 63
  reg = 0U;
#line 64
  i = 0U;
  }
#line 64
  goto ldv_50798;
  ldv_50797: 
#line 65
  reg = reg | (u32 )((int )*(prio_tc + (unsigned long )i) << (int )i * 3);
#line 64
  i = (u8 )((int )i + 1);
  ldv_50798: ;
#line 64
  if ((unsigned int )i <= 7U) {
#line 66
    goto ldv_50797;
  } else {

  }
  {
#line 66
  ixgbe_write_reg(hw, 12320U, reg);
#line 69
  i = 0U;
  }
#line 69
  goto ldv_50801;
  ldv_50800: 
#line 70
  credit_refill = (u32 )*(refill + (unsigned long )i);
#line 71
  credit_max = (u32 )*(max + (unsigned long )i);
#line 72
  reg = credit_refill | (credit_max << 12);
#line 74
  reg = reg | ((unsigned int )*(bwg_id + (unsigned long )i) << 9);
#line 76
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 77
    reg = reg | 2147483648U;
  } else {

  }
  {
#line 79
  ixgbe_write_reg(hw, (u32 )(((int )i + 2128) * 4), reg);
#line 69
  i = (u8 )((int )i + 1);
  }
  ldv_50801: ;
#line 69
  if ((unsigned int )i <= 7U) {
#line 71
    goto ldv_50800;
  } else {

  }
  {
#line 86
  reg = 6U;
#line 87
  ixgbe_write_reg(hw, 9264U, reg);
  }
#line 89
  return (0);
}
}
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type ) 
{ 
  u32 reg ;
  u32 max_credits ;
  u8 i ;

  {
#line 112
  i = 0U;
#line 112
  goto ldv_50814;
  ldv_50813: 
  {
#line 113
  ixgbe_write_reg(hw, 18692U, (u32 )i);
#line 114
  ixgbe_write_reg(hw, 18696U, 0U);
#line 112
  i = (u8 )((int )i + 1);
  }
  ldv_50814: ;
#line 112
  if ((int )((signed char )i) >= 0) {
#line 114
    goto ldv_50813;
  } else {

  }
#line 118
  i = 0U;
#line 118
  goto ldv_50817;
  ldv_50816: 
#line 119
  max_credits = (u32 )*(max + (unsigned long )i);
#line 120
  reg = max_credits << 12;
#line 121
  reg = reg | (u32 )*(refill + (unsigned long )i);
#line 122
  reg = reg | ((unsigned int )*(bwg_id + (unsigned long )i) << 9);
#line 124
  if ((unsigned int )*(prio_type + (unsigned long )i) == 1U) {
#line 125
    reg = reg | 1073741824U;
  } else {

  }
#line 127
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 128
    reg = reg | 2147483648U;
  } else {

  }
  {
#line 130
  ixgbe_write_reg(hw, (u32 )(((int )i + 4676) * 4), reg);
#line 118
  i = (u8 )((int )i + 1);
  }
  ldv_50817: ;
#line 118
  if ((unsigned int )i <= 7U) {
#line 120
    goto ldv_50816;
  } else {

  }
  {
#line 137
  reg = 17U;
#line 138
  ixgbe_write_reg(hw, 18688U, reg);
  }
#line 140
  return (0);
}
}
#line 153 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw , u16 *refill , u16 *max ,
                                           u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) 
{ 
  u32 reg ;
  u8 i ;

  {
  {
#line 167
  reg = 16777568U;
#line 170
  ixgbe_write_reg(hw, 52480U, reg);
#line 173
  reg = 0U;
#line 174
  i = 0U;
  }
#line 174
  goto ldv_50830;
  ldv_50829: 
#line 175
  reg = reg | (u32 )((int )*(prio_tc + (unsigned long )i) << (int )i * 3);
#line 174
  i = (u8 )((int )i + 1);
  ldv_50830: ;
#line 174
  if ((unsigned int )i <= 7U) {
#line 176
    goto ldv_50829;
  } else {

  }
  {
#line 176
  ixgbe_write_reg(hw, 51200U, reg);
#line 179
  i = 0U;
  }
#line 179
  goto ldv_50833;
  ldv_50832: 
#line 180
  reg = (u32 )*(refill + (unsigned long )i);
#line 181
  reg = reg | ((unsigned int )*(max + (unsigned long )i) << 12);
#line 182
  reg = reg | ((unsigned int )*(bwg_id + (unsigned long )i) << 9);
#line 184
  if ((unsigned int )*(prio_type + (unsigned long )i) == 1U) {
#line 185
    reg = reg | 1073741824U;
  } else {

  }
#line 187
  if ((unsigned int )*(prio_type + (unsigned long )i) == 2U) {
#line 188
    reg = reg | 2147483648U;
  } else {

  }
  {
#line 190
  ixgbe_write_reg(hw, (u32 )(((int )i + 13128) * 4), reg);
#line 179
  i = (u8 )((int )i + 1);
  }
  ldv_50833: ;
#line 179
  if ((unsigned int )i <= 7U) {
#line 181
    goto ldv_50832;
  } else {

  }
  {
#line 197
  reg = 16777504U;
#line 199
  ixgbe_write_reg(hw, 52480U, reg);
  }
#line 201
  return (0);
}
}
#line 212 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw , u8 pfc_en , u8 *prio_tc ) 
{ 
  u32 i ;
  u32 j ;
  u32 fcrtl ;
  u32 reg ;
  u8 max_tc ;
  int enabled ;
  u32 tmp ;

  {
  {
#line 215
  max_tc = 0U;
#line 218
  ixgbe_write_reg(hw, 15616U, 16U);
#line 221
  reg = ixgbe_read_reg(hw, 17044U);
#line 222
  reg = reg | 2U;
#line 229
  reg = reg & 4294963203U;
  }
#line 231
  if ((unsigned int )hw->mac.type == 3U) {
#line 232
    reg = reg | (u32 )((int )pfc_en << 4);
  } else {

  }
#line 234
  if ((unsigned int )pfc_en != 0U) {
#line 235
    reg = reg | 4U;
  } else {

  }
  {
#line 237
  ixgbe_write_reg(hw, 17044U, reg);
#line 239
  i = 0U;
  }
#line 239
  goto ldv_50846;
  ldv_50845: ;
#line 240
  if ((int )*(prio_tc + (unsigned long )i) > (int )max_tc) {
#line 241
    max_tc = *(prio_tc + (unsigned long )i);
  } else {

  }
#line 239
  i = i + 1U;
  ldv_50846: ;
#line 239
  if (i <= 7U) {
#line 241
    goto ldv_50845;
  } else {

  }
#line 244
  fcrtl = (hw->fc.low_water << 10) | 2147483648U;
#line 247
  i = 0U;
#line 247
  goto ldv_50853;
  ldv_50852: 
#line 248
  enabled = 0;
#line 250
  j = 0U;
#line 250
  goto ldv_50851;
  ldv_50850: ;
#line 251
  if ((u32 )*(prio_tc + (unsigned long )j) == i && ((int )pfc_en >> (int )j) & 1) {
#line 252
    enabled = 1;
#line 253
    goto ldv_50849;
  } else {

  }
#line 250
  j = j + 1U;
  ldv_50851: ;
#line 250
  if (j <= 7U) {
#line 252
    goto ldv_50850;
  } else {

  }
  ldv_50849: ;
#line 257
  if (enabled != 0) {
    {
#line 258
    reg = (hw->fc.high_water[i] << 10) | 2147483648U;
#line 259
    ixgbe_write_reg(hw, (i + 3208U) * 4U, fcrtl);
    }
  } else {
    {
#line 261
    tmp = ixgbe_read_reg(hw, (i + 3840U) * 4U);
#line 261
    reg = tmp - 32U;
#line 262
    ixgbe_write_reg(hw, (i + 3208U) * 4U, 0U);
    }
  }
  {
#line 265
  ixgbe_write_reg(hw, (i + 3224U) * 4U, reg);
#line 247
  i = i + 1U;
  }
  ldv_50853: ;
#line 247
  if (i <= (u32 )max_tc) {
#line 249
    goto ldv_50852;
  } else {

  }

#line 268
  goto ldv_50856;
  ldv_50855: 
  {
#line 269
  ixgbe_write_reg(hw, (i + 3208U) * 4U, 0U);
#line 270
  ixgbe_write_reg(hw, (i + 3224U) * 4U, 0U);
#line 268
  i = i + 1U;
  }
  ldv_50856: ;
#line 268
  if (i <= 7U) {
#line 270
    goto ldv_50855;
  } else {

  }
#line 274
  reg = (u32 )((int )hw->fc.pause_time * 65537);
#line 275
  i = 0U;
#line 275
  goto ldv_50859;
  ldv_50858: 
  {
#line 276
  ixgbe_write_reg(hw, (i + 3200U) * 4U, reg);
#line 275
  i = i + 1U;
  }
  ldv_50859: ;
#line 275
  if (i <= 3U) {
#line 277
    goto ldv_50858;
  } else {

  }
  {
#line 279
  ixgbe_write_reg(hw, 12960U, (unsigned int )hw->fc.pause_time / 2U);
  }
#line 281
  return (0);
}
}
#line 291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
static s32 ixgbe_dcb_config_tc_stats_82599(struct ixgbe_hw *hw ) 
{ 
  u32 reg ;
  u8 i ;

  {
#line 293
  reg = 0U;
#line 294
  i = 0U;
#line 302
  i = 0U;
#line 302
  goto ldv_50867;
  ldv_50866: 
  {
#line 303
  reg = (u32 )((int )((unsigned int )i / 4U) * 16843009);
#line 304
  ixgbe_write_reg(hw, (u32 )(((int )i + 2240) * 4), reg);
#line 302
  i = (u8 )((int )i + 1);
  }
  ldv_50867: ;
#line 302
  if ((unsigned int )i <= 31U) {
#line 304
    goto ldv_50866;
  } else {

  }
#line 314
  i = 0U;
#line 314
  goto ldv_50870;
  ldv_50869: ;
#line 315
  if ((unsigned int )i <= 7U) {
#line 316
    reg = 0U;
  } else
#line 317
  if ((unsigned int )i <= 15U) {
#line 318
    reg = 16843009U;
  } else
#line 319
  if ((unsigned int )i <= 19U) {
#line 320
    reg = 33686018U;
  } else
#line 321
  if ((unsigned int )i <= 23U) {
#line 322
    reg = 50529027U;
  } else
#line 323
  if ((unsigned int )i <= 25U) {
#line 324
    reg = 67372036U;
  } else
#line 325
  if ((unsigned int )i <= 27U) {
#line 326
    reg = 84215045U;
  } else
#line 327
  if ((unsigned int )i <= 29U) {
#line 328
    reg = 101058054U;
  } else {
#line 330
    reg = 117901063U;
  }
  {
#line 331
  ixgbe_write_reg(hw, (u32 )(((int )i + 8576) * 4), reg);
#line 314
  i = (u8 )((int )i + 1);
  }
  ldv_50870: ;
#line 314
  if ((unsigned int )i <= 31U) {
#line 316
    goto ldv_50869;
  } else {

  }

#line 334
  return (0);
}
}
#line 348 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c"
s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw , u8 pfc_en , u16 *refill , u16 *max ,
                              u8 *bwg_id , u8 *prio_type , u8 *prio_tc ) 
{ 


  {
  {
#line 351
  ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max, bwg_id, prio_type, prio_tc);
#line 353
  ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max, bwg_id, prio_type);
#line 355
  ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max, bwg_id, prio_type, prio_tc);
#line 357
  ixgbe_dcb_config_pfc_82599(hw, (int )pfc_en, prio_tc);
#line 358
  ixgbe_dcb_config_tc_stats_82599(hw);
  }
#line 360
  return (0);
}
}
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/net/dcbnl.h"
extern u8 dcb_getapp(struct net_device * , struct dcb_app * ) ;
#line 33
extern int dcb_ieee_setapp(struct net_device * , struct dcb_app * ) ;
#line 34
extern int dcb_ieee_delapp(struct net_device * , struct dcb_app * ) ;
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter , int tc_max ) 
{ 
  struct ixgbe_dcb_config *scfg ;
  struct ixgbe_dcb_config *dcfg ;
  struct tc_configuration *src ;
  struct tc_configuration *dst ;
  int i ;
  int j ;
  int tx ;
  int rx ;
  int changes ;
  struct dcb_app app ;
  u8 up___0 ;
  u8 tmp ;

  {
  {
#line 50
  scfg = & adapter->temp_dcb_cfg;
#line 51
  dcfg = & adapter->dcb_cfg;
#line 52
  src = (struct tc_configuration *)0;
#line 53
  dst = (struct tc_configuration *)0;
#line 55
  tx = 0;
#line 56
  rx = 1;
#line 57
  changes = 0;
#line 59
  app.selector = 0U;
#line 59
  app.priority = (unsigned char)0;
#line 59
  app.protocol = 35078U;
#line 63
  tmp = dcb_getapp(adapter->netdev, & app);
#line 63
  up___0 = tmp;
  }
#line 65
  if ((unsigned int )up___0 != 0U && (((int )up___0 >> (int )adapter->fcoe.up) & 1) == 0) {
#line 66
    changes = changes | 16;
  } else {

  }
#line 69
  i = 1;
#line 69
  goto ldv_50877;
  ldv_50876: 
#line 70
  src = (struct tc_configuration *)(& scfg->tc_config) + ((unsigned long )i + 0xffffffffffffffffUL);
#line 71
  dst = (struct tc_configuration *)(& dcfg->tc_config) + ((unsigned long )i + 0xffffffffffffffffUL);
#line 73
  if ((unsigned int )dst->path[tx].prio_type != (unsigned int )src->path[tx].prio_type) {
#line 74
    dst->path[tx].prio_type = src->path[tx].prio_type;
#line 75
    changes = changes | 8;
  } else {

  }
#line 78
  if ((int )dst->path[tx].bwg_id != (int )src->path[tx].bwg_id) {
#line 79
    dst->path[tx].bwg_id = src->path[tx].bwg_id;
#line 80
    changes = changes | 8;
  } else {

  }
#line 83
  if ((int )dst->path[tx].bwg_percent != (int )src->path[tx].bwg_percent) {
#line 84
    dst->path[tx].bwg_percent = src->path[tx].bwg_percent;
#line 85
    changes = changes | 8;
  } else {

  }
#line 88
  if ((int )dst->path[tx].up_to_tc_bitmap != (int )src->path[tx].up_to_tc_bitmap) {
#line 90
    dst->path[tx].up_to_tc_bitmap = src->path[tx].up_to_tc_bitmap;
#line 92
    changes = changes | 26;
  } else {

  }
#line 95
  if ((unsigned int )dst->path[rx].prio_type != (unsigned int )src->path[rx].prio_type) {
#line 96
    dst->path[rx].prio_type = src->path[rx].prio_type;
#line 97
    changes = changes | 4;
  } else {

  }
#line 100
  if ((int )dst->path[rx].bwg_id != (int )src->path[rx].bwg_id) {
#line 101
    dst->path[rx].bwg_id = src->path[rx].bwg_id;
#line 102
    changes = changes | 4;
  } else {

  }
#line 105
  if ((int )dst->path[rx].bwg_percent != (int )src->path[rx].bwg_percent) {
#line 106
    dst->path[rx].bwg_percent = src->path[rx].bwg_percent;
#line 107
    changes = changes | 4;
  } else {

  }
#line 110
  if ((int )dst->path[rx].up_to_tc_bitmap != (int )src->path[rx].up_to_tc_bitmap) {
#line 112
    dst->path[rx].up_to_tc_bitmap = src->path[rx].up_to_tc_bitmap;
#line 114
    changes = changes | 22;
  } else {

  }
#line 69
  i = i + 1;
  ldv_50877: ;
#line 69
  if (i < tc_max + 1) {
#line 71
    goto ldv_50876;
  } else {

  }
#line 118
  i = 11;
#line 118
  goto ldv_50880;
  ldv_50879: 
#line 119
  j = i + -11;
#line 120
  if ((int )dcfg->bw_percentage[tx][j] != (int )scfg->bw_percentage[tx][j]) {
#line 121
    dcfg->bw_percentage[tx][j] = scfg->bw_percentage[tx][j];
#line 122
    changes = changes | 8;
  } else {

  }
#line 124
  if ((int )dcfg->bw_percentage[rx][j] != (int )scfg->bw_percentage[rx][j]) {
#line 125
    dcfg->bw_percentage[rx][j] = scfg->bw_percentage[rx][j];
#line 126
    changes = changes | 4;
  } else {

  }
#line 118
  i = i + 1;
  ldv_50880: ;
#line 118
  if (i <= 18) {
#line 120
    goto ldv_50879;
  } else {

  }
#line 130
  i = 1;
#line 130
  goto ldv_50883;
  ldv_50882: 
#line 131
  j = i + -1;
#line 132
  if ((unsigned int )dcfg->tc_config[j].dcb_pfc != (unsigned int )scfg->tc_config[j].dcb_pfc) {
#line 133
    dcfg->tc_config[j].dcb_pfc = scfg->tc_config[j].dcb_pfc;
#line 134
    changes = changes | 2;
  } else {

  }
#line 130
  i = i + 1;
  ldv_50883: ;
#line 130
  if (i <= 8) {
#line 132
    goto ldv_50882;
  } else {

  }

#line 138
  if ((int )dcfg->pfc_mode_enable != (int )scfg->pfc_mode_enable) {
#line 139
    dcfg->pfc_mode_enable = scfg->pfc_mode_enable;
#line 140
    changes = changes | 2;
  } else {

  }
#line 143
  return (changes);
}
}
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_get_state(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 148
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 148
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 150
  return ((adapter->flags & 4096U) != 0U);
}
}
#line 153 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_set_state(struct net_device *netdev , u8 state ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;

  {
  {
#line 155
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 155
  adapter = (struct ixgbe_adapter *)tmp;
#line 156
  err = 0;
  }
#line 159
  if (((int )adapter->dcbx_cap & 4) == 0) {
#line 160
    return (1U);
  } else {

  }
#line 163
  if (((unsigned int )state != 0U) ^ ((adapter->flags & 4096U) == 0U)) {
#line 164
    goto out;
  } else {

  }
  {
#line 166
  err = ixgbe_setup_tc(netdev, (unsigned int )state != 0U ? (int )adapter->dcb_cfg.num_tcs.pg_tcs : 0);
  }
  out: ;
#line 169
  return (err != 0);
}
}
#line 172 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_perm_hw_addr(struct net_device *netdev , u8 *perm_addr ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int i ;
  int j ;

  {
  {
#line 175
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 175
  adapter = (struct ixgbe_adapter *)tmp;
#line 178
  memset((void *)perm_addr, 255, 32UL);
#line 180
  i = 0;
  }
#line 180
  goto ldv_50904;
  ldv_50903: 
#line 181
  *(perm_addr + (unsigned long )i) = adapter->hw.mac.perm_addr[i];
#line 180
  i = i + 1;
  ldv_50904: ;
#line 180
  if (i < (int )netdev->addr_len) {
#line 182
    goto ldv_50903;
  } else {

  }

  {
#line 184
  if ((unsigned int )adapter->hw.mac.type == 2U) {
#line 184
    goto case_2;
  } else {

  }
#line 185
  if ((unsigned int )adapter->hw.mac.type == 3U) {
#line 185
    goto case_3;
  } else {

  }
#line 189
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 186
  j = 0;
#line 186
  goto ldv_50909;
  ldv_50908: 
#line 187
  *(perm_addr + (unsigned long )i) = adapter->hw.mac.san_addr[j];
#line 186
  j = j + 1;
#line 186
  i = i + 1;
  ldv_50909: ;
#line 186
  if (j < (int )netdev->addr_len) {
#line 188
    goto ldv_50908;
  } else {

  }

#line 188
  goto ldv_50911;
  switch_default: /* CIL Label */ ;
#line 190
  goto ldv_50911;
  switch_break: /* CIL Label */ ;
  }
  ldv_50911: ;
#line 193
  return;
}
}
#line 194 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev , int tc , u8 prio ,
                                         u8 bwg_id , u8 bw_pct , u8 up_map ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 198
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 198
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 200
  if ((unsigned int )prio != 255U) {
#line 201
    adapter->temp_dcb_cfg.tc_config[tc].path[0].prio_type = (enum strict_prio_type )prio;
  } else {

  }
#line 202
  if ((unsigned int )bwg_id != 255U) {
#line 203
    adapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_id = bwg_id;
  } else {

  }
#line 204
  if ((unsigned int )bw_pct != 255U) {
#line 205
    adapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_percent = bw_pct;
  } else {

  }
#line 207
  if ((unsigned int )up_map != 255U) {
#line 208
    adapter->temp_dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap = up_map;
  } else {

  }
#line 209
  return;
}
}
#line 212 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev , int bwg_id ,
                                          u8 bw_pct ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 215
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 215
  adapter = (struct ixgbe_adapter *)tmp;
#line 217
  adapter->temp_dcb_cfg.bw_percentage[0][bwg_id] = bw_pct;
  }
#line 218
  return;
}
}
#line 220 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev , int tc , u8 prio ,
                                         u8 bwg_id , u8 bw_pct , u8 up_map ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 224
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 224
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 226
  if ((unsigned int )prio != 255U) {
#line 227
    adapter->temp_dcb_cfg.tc_config[tc].path[1].prio_type = (enum strict_prio_type )prio;
  } else {

  }
#line 228
  if ((unsigned int )bwg_id != 255U) {
#line 229
    adapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_id = bwg_id;
  } else {

  }
#line 230
  if ((unsigned int )bw_pct != 255U) {
#line 231
    adapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_percent = bw_pct;
  } else {

  }
#line 233
  if ((unsigned int )up_map != 255U) {
#line 234
    adapter->temp_dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap = up_map;
  } else {

  }
#line 235
  return;
}
}
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev , int bwg_id ,
                                          u8 bw_pct ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 241
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 241
  adapter = (struct ixgbe_adapter *)tmp;
#line 243
  adapter->temp_dcb_cfg.bw_percentage[1][bwg_id] = bw_pct;
  }
#line 244
  return;
}
}
#line 246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev , int tc , u8 *prio ,
                                         u8 *bwg_id , u8 *bw_pct , u8 *up_map ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 250
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 250
  adapter = (struct ixgbe_adapter *)tmp;
#line 252
  *prio = (u8 )adapter->dcb_cfg.tc_config[tc].path[0].prio_type;
#line 253
  *bwg_id = adapter->dcb_cfg.tc_config[tc].path[0].bwg_id;
#line 254
  *bw_pct = adapter->dcb_cfg.tc_config[tc].path[0].bwg_percent;
#line 255
  *up_map = adapter->dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap;
  }
#line 256
  return;
}
}
#line 258 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_bwg_cfg_tx(struct net_device *netdev , int bwg_id ,
                                          u8 *bw_pct ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 261
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 261
  adapter = (struct ixgbe_adapter *)tmp;
#line 263
  *bw_pct = adapter->dcb_cfg.bw_percentage[0][bwg_id];
  }
#line 264
  return;
}
}
#line 266 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev , int tc , u8 *prio ,
                                         u8 *bwg_id , u8 *bw_pct , u8 *up_map ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 270
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 270
  adapter = (struct ixgbe_adapter *)tmp;
#line 272
  *prio = (u8 )adapter->dcb_cfg.tc_config[tc].path[1].prio_type;
#line 273
  *bwg_id = adapter->dcb_cfg.tc_config[tc].path[1].bwg_id;
#line 274
  *bw_pct = adapter->dcb_cfg.tc_config[tc].path[1].bwg_percent;
#line 275
  *up_map = adapter->dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap;
  }
#line 276
  return;
}
}
#line 278 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev , int bwg_id ,
                                          u8 *bw_pct ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 281
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 281
  adapter = (struct ixgbe_adapter *)tmp;
#line 283
  *bw_pct = adapter->dcb_cfg.bw_percentage[1][bwg_id];
  }
#line 284
  return;
}
}
#line 286 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_set_pfc_cfg(struct net_device *netdev , int priority , u8 setting ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 289
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 289
  adapter = (struct ixgbe_adapter *)tmp;
#line 291
  adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc = (enum dcb_pfc_type )setting;
  }
#line 292
  if ((unsigned int )adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc != (unsigned int )adapter->dcb_cfg.tc_config[priority].dcb_pfc) {
#line 294
    adapter->temp_dcb_cfg.pfc_mode_enable = 1;
  } else {

  }
#line 295
  return;
}
}
#line 297 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_get_pfc_cfg(struct net_device *netdev , int priority , u8 *setting ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 300
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 300
  adapter = (struct ixgbe_adapter *)tmp;
#line 302
  *setting = (u8 )adapter->dcb_cfg.tc_config[priority].dcb_pfc;
  }
#line 303
  return;
}
}
#line 305 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_devreset(struct net_device *dev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 307
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 307
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 309
  goto ldv_50990;
  ldv_50989: 
  {
#line 310
  usleep_range(1000UL, 2000UL);
  }
  ldv_50990: 
  {
#line 309
  tmp___0 = test_and_set_bit(1L, (unsigned long volatile   *)(& adapter->state));
  }
#line 309
  if (tmp___0 != 0) {
#line 311
    goto ldv_50989;
  } else {

  }
  {
#line 312
  tmp___1 = netif_running((struct net_device  const  *)dev);
  }
#line 312
  if ((int )tmp___1) {
    {
#line 313
    (*((dev->netdev_ops)->ndo_stop))(dev);
    }
  } else {

  }
  {
#line 315
  ixgbe_clear_interrupt_scheme(adapter);
#line 316
  ixgbe_init_interrupt_scheme(adapter);
#line 318
  tmp___2 = netif_running((struct net_device  const  *)dev);
  }
#line 318
  if ((int )tmp___2) {
    {
#line 319
    (*((dev->netdev_ops)->ndo_open))(dev);
    }
  } else {

  }
  {
#line 321
  clear_bit(1L, (unsigned long volatile   *)(& adapter->state));
  }
#line 322
  return;
}
}
#line 324 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_set_all(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_dcb_config *dcb_cfg ;
  struct ixgbe_hw *hw ;
  int ret ;
  int i ;
  int tmp___0 ;
  u16 refill[8U] ;
  u16 max[8U] ;
  u8 bwg_id[8U] ;
  u8 prio_type[8U] ;
  u8 prio_tc[8U] ;
  int max_frame ;
  int _max1 ;
  int _max2 ;
  u8 pfc_en ;
  u8 prio_tc___0[8U] ;
  struct dcb_app app ;
  u8 up___0 ;
  u8 tmp___1 ;
  int tmp___2 ;

  {
  {
#line 326
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 326
  adapter = (struct ixgbe_adapter *)tmp;
#line 327
  dcb_cfg = & adapter->dcb_cfg;
#line 328
  hw = & adapter->hw;
#line 329
  ret = 1;
  }
#line 333
  if (((int )adapter->dcbx_cap & 4) == 0) {
#line 334
    return ((u8 )ret);
  } else {

  }
  {
#line 336
  tmp___0 = ixgbe_copy_dcb_cfg(adapter, 8);
#line 336
  adapter->dcb_set_bitmap = (u8 )((int )((signed char )adapter->dcb_set_bitmap) | (int )((signed char )tmp___0));
  }
#line 338
  if ((unsigned int )adapter->dcb_set_bitmap == 0U) {
#line 339
    return ((u8 )ret);
  } else {

  }
#line 341
  if (((int )adapter->dcb_set_bitmap & 12) != 0) {
#line 346
    max_frame = (int )((adapter->netdev)->mtu + 18U);
#line 349
    if (((adapter->netdev)->features & 536870912ULL) != 0ULL) {
#line 350
      _max1 = max_frame;
#line 350
      _max2 = 3072;
#line 350
      max_frame = _max1 > _max2 ? _max1 : _max2;
    } else {

    }
    {
#line 353
    ixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame, 0);
#line 355
    ixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame, 1);
#line 358
    ixgbe_dcb_unpack_refill(dcb_cfg, 0, (u16 *)(& refill));
#line 359
    ixgbe_dcb_unpack_max(dcb_cfg, (u16 *)(& max));
#line 360
    ixgbe_dcb_unpack_bwgid(dcb_cfg, 0, (u8 *)(& bwg_id));
#line 361
    ixgbe_dcb_unpack_prio(dcb_cfg, 0, (u8 *)(& prio_type));
#line 362
    ixgbe_dcb_unpack_map(dcb_cfg, 0, (u8 *)(& prio_tc));
#line 364
    ixgbe_dcb_hw_ets_config(hw, (u16 *)(& refill), (u16 *)(& max), (u8 *)(& bwg_id),
                            (u8 *)(& prio_type), (u8 *)(& prio_tc));
#line 367
    i = 0;
    }
#line 367
    goto ldv_51010;
    ldv_51009: 
    {
#line 368
    netdev_set_prio_tc_map(netdev, (int )((u8 )i), (int )prio_tc[i]);
#line 367
    i = i + 1;
    }
    ldv_51010: ;
#line 367
    if (i <= 7) {
#line 369
      goto ldv_51009;
    } else {

    }
#line 370
    ret = 0;
  } else {

  }
#line 373
  if (((int )adapter->dcb_set_bitmap & 2) != 0) {
#line 374
    if ((int )dcb_cfg->pfc_mode_enable) {
      {
#line 378
      ixgbe_dcb_unpack_map(dcb_cfg, 0, (u8 *)(& prio_tc___0));
#line 379
      ixgbe_dcb_unpack_pfc(dcb_cfg, & pfc_en);
#line 380
      ixgbe_dcb_hw_pfc_config(hw, (int )pfc_en, (u8 *)(& prio_tc___0));
      }
    } else {
      {
#line 382
      (*(hw->mac.ops.fc_enable))(hw);
      }
    }
    {
#line 385
    ixgbe_set_rx_drop_en(adapter);
#line 387
    ret = 2;
    }
  } else {

  }
#line 395
  if (((int )adapter->dcb_set_bitmap & 16) != 0) {
    {
#line 396
    app.selector = 0U;
#line 396
    app.priority = (unsigned char)0;
#line 396
    app.protocol = 35078U;
#line 400
    tmp___1 = dcb_getapp(netdev, & app);
#line 400
    up___0 = tmp___1;
#line 402
    tmp___2 = ffs((int )up___0);
#line 402
    adapter->fcoe.up = (unsigned int )((u8 )tmp___2) + 255U;
#line 403
    ixgbe_dcbnl_devreset(netdev);
#line 404
    ret = 0;
    }
  } else {

  }
#line 408
  adapter->dcb_set_bitmap = 0U;
#line 409
  return ((u8 )ret);
}
}
#line 412 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getcap(struct net_device *netdev , int capid , u8 *cap ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 414
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 414
  adapter = (struct ixgbe_adapter *)tmp;
  }
  {
#line 417
  if (capid == 2) {
#line 417
    goto case_2;
  } else {

  }
#line 420
  if (capid == 3) {
#line 420
    goto case_3;
  } else {

  }
#line 423
  if (capid == 4) {
#line 423
    goto case_4;
  } else {

  }
#line 426
  if (capid == 5) {
#line 426
    goto case_5;
  } else {

  }
#line 429
  if (capid == 6) {
#line 429
    goto case_6;
  } else {

  }
#line 432
  if (capid == 7) {
#line 432
    goto case_7;
  } else {

  }
#line 435
  if (capid == 8) {
#line 435
    goto case_8;
  } else {

  }
#line 438
  if (capid == 9) {
#line 438
    goto case_9;
  } else {

  }
#line 441
  goto switch_default;
  case_2: /* CIL Label */ 
#line 418
  *cap = 1U;
#line 419
  goto ldv_51023;
  case_3: /* CIL Label */ 
#line 421
  *cap = 1U;
#line 422
  goto ldv_51023;
  case_4: /* CIL Label */ 
#line 424
  *cap = 0U;
#line 425
  goto ldv_51023;
  case_5: /* CIL Label */ 
#line 427
  *cap = 128U;
#line 428
  goto ldv_51023;
  case_6: /* CIL Label */ 
#line 430
  *cap = 128U;
#line 431
  goto ldv_51023;
  case_7: /* CIL Label */ 
#line 433
  *cap = 1U;
#line 434
  goto ldv_51023;
  case_8: /* CIL Label */ 
#line 436
  *cap = 0U;
#line 437
  goto ldv_51023;
  case_9: /* CIL Label */ 
#line 439
  *cap = adapter->dcbx_cap;
#line 440
  goto ldv_51023;
  switch_default: /* CIL Label */ 
#line 442
  *cap = 0U;
#line 443
  goto ldv_51023;
  switch_break: /* CIL Label */ ;
  }
  ldv_51023: ;
#line 446
  return (0U);
}
}
#line 449 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_getnumtcs(struct net_device *netdev , int tcid , u8 *num ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 451
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 451
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 453
  if ((adapter->flags & 4096U) != 0U) {
    {
#line 455
    if (tcid == 2) {
#line 455
      goto case_2;
    } else {

    }
#line 458
    if (tcid == 3) {
#line 458
      goto case_3;
    } else {

    }
#line 461
    goto switch_default;
    case_2: /* CIL Label */ 
#line 456
    *num = adapter->dcb_cfg.num_tcs.pg_tcs;
#line 457
    goto ldv_51039;
    case_3: /* CIL Label */ 
#line 459
    *num = adapter->dcb_cfg.num_tcs.pfc_tcs;
#line 460
    goto ldv_51039;
    switch_default: /* CIL Label */ ;
#line 462
    return (-22);
    switch_break: /* CIL Label */ ;
    }
    ldv_51039: ;
  } else {
#line 466
    return (-22);
  }
#line 469
  return (0);
}
}
#line 472 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_setnumtcs(struct net_device *netdev , int tcid , u8 num ) 
{ 


  {
#line 474
  return (-22);
}
}
#line 477 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getpfcstate(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 479
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 479
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 481
  return ((u8 )adapter->dcb_cfg.pfc_mode_enable);
}
}
#line 484 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static void ixgbe_dcbnl_setpfcstate(struct net_device *netdev , u8 state ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 486
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 486
  adapter = (struct ixgbe_adapter *)tmp;
#line 488
  adapter->temp_dcb_cfg.pfc_mode_enable = (unsigned int )state != 0U;
  }
#line 489
  return;
}
}
#line 501 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getapp(struct net_device *netdev , u8 idtype , u16 id ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct dcb_app app ;
  u8 tmp___0 ;

  {
  {
#line 503
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 503
  adapter = (struct ixgbe_adapter *)tmp;
#line 504
  app.selector = idtype;
#line 504
  app.priority = (unsigned char)0;
#line 504
  app.protocol = id;
  }
#line 509
  if (((int )adapter->dcbx_cap & 4) == 0) {
#line 510
    return (0U);
  } else {

  }
  {
#line 512
  tmp___0 = dcb_getapp(netdev, & app);
  }
#line 512
  return (tmp___0);
}
}
#line 515 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_getets(struct net_device *dev , struct ieee_ets *ets ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ieee_ets *my_ets ;

  {
  {
#line 518
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 518
  adapter = (struct ixgbe_adapter *)tmp;
#line 519
  my_ets = adapter->ixgbe_ieee_ets;
#line 521
  ets->ets_cap = adapter->dcb_cfg.num_tcs.pg_tcs;
  }
#line 524
  if ((unsigned long )my_ets == (unsigned long )((struct ieee_ets *)0)) {
#line 525
    return (0);
  } else {

  }
  {
#line 527
  ets->cbs = my_ets->cbs;
#line 528
  memcpy((void *)(& ets->tc_tx_bw), (void const   *)(& my_ets->tc_tx_bw), 8UL);
#line 529
  memcpy((void *)(& ets->tc_rx_bw), (void const   *)(& my_ets->tc_rx_bw), 8UL);
#line 530
  memcpy((void *)(& ets->tc_tsa), (void const   *)(& my_ets->tc_tsa), 8UL);
#line 531
  memcpy((void *)(& ets->prio_tc), (void const   *)(& my_ets->prio_tc), 8UL);
  }
#line 532
  return (0);
}
}
#line 535 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setets(struct net_device *dev , struct ieee_ets *ets ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int max_frame ;
  int i ;
  int err ;
  __u8 max_tc ;
  __u8 map_chg ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 538
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 538
  adapter = (struct ixgbe_adapter *)tmp;
#line 539
  max_frame = (int )(dev->mtu + 18U);
#line 540
  err = 0;
#line 541
  max_tc = 0U;
#line 542
  map_chg = 0U;
  }
#line 544
  if (((int )adapter->dcbx_cap & 8) == 0) {
#line 545
    return (-22);
  } else {

  }
#line 547
  if ((unsigned long )adapter->ixgbe_ieee_ets == (unsigned long )((struct ieee_ets *)0)) {
    {
#line 548
    tmp___0 = kmalloc(59UL, 208U);
#line 548
    adapter->ixgbe_ieee_ets = (struct ieee_ets *)tmp___0;
    }
#line 550
    if ((unsigned long )adapter->ixgbe_ieee_ets == (unsigned long )((struct ieee_ets *)0)) {
#line 551
      return (-12);
    } else {

    }
#line 554
    i = 0;
#line 554
    goto ldv_51080;
    ldv_51079: 
#line 555
    (adapter->ixgbe_ieee_ets)->prio_tc[i] = 8U;
#line 554
    i = i + 1;
    ldv_51080: ;
#line 554
    if (i <= 7) {
#line 556
      goto ldv_51079;
    } else {

    }
    {
#line 558
    ixgbe_dcb_read_rtrup2tc(& adapter->hw, (u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc));
    }
  } else {

  }
#line 562
  i = 0;
#line 562
  goto ldv_51083;
  ldv_51082: ;
#line 563
  if ((int )ets->prio_tc[i] > (int )max_tc) {
#line 564
    max_tc = ets->prio_tc[i];
  } else {

  }
#line 565
  if ((int )ets->prio_tc[i] != (int )(adapter->ixgbe_ieee_ets)->prio_tc[i]) {
#line 566
    map_chg = 1U;
  } else {

  }
#line 562
  i = i + 1;
  ldv_51083: ;
#line 562
  if (i <= 7) {
#line 564
    goto ldv_51082;
  } else {

  }
  {
#line 569
  memcpy((void *)adapter->ixgbe_ieee_ets, (void const   *)ets, 59UL);
  }
#line 571
  if ((unsigned int )max_tc != 0U) {
#line 572
    max_tc = (__u8 )((int )max_tc + 1);
  } else {

  }
#line 574
  if ((int )max_tc > (int )adapter->dcb_cfg.num_tcs.pg_tcs) {
#line 575
    return (-22);
  } else {

  }
  {
#line 577
  tmp___1 = netdev_get_num_tc(dev);
  }
#line 577
  if ((int )max_tc != tmp___1) {
    {
#line 578
    err = ixgbe_setup_tc(dev, (int )max_tc);
    }
  } else
#line 579
  if ((unsigned int )map_chg != 0U) {
    {
#line 580
    ixgbe_dcbnl_devreset(dev);
    }
  } else {

  }
#line 582
  if (err != 0) {
#line 583
    goto err_out;
  } else {

  }
  {
#line 585
  err = ixgbe_dcb_hw_ets(& adapter->hw, ets, max_frame);
  }
  err_out: ;
#line 587
  return (err);
}
}
#line 590 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_getpfc(struct net_device *dev , struct ieee_pfc *pfc ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ieee_pfc *my_pfc ;
  int i ;

  {
  {
#line 593
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 593
  adapter = (struct ixgbe_adapter *)tmp;
#line 594
  my_pfc = adapter->ixgbe_ieee_pfc;
#line 597
  pfc->pfc_cap = adapter->dcb_cfg.num_tcs.pfc_tcs;
  }
#line 600
  if ((unsigned long )my_pfc == (unsigned long )((struct ieee_pfc *)0)) {
#line 601
    return (0);
  } else {

  }
#line 603
  pfc->pfc_en = my_pfc->pfc_en;
#line 604
  pfc->mbc = my_pfc->mbc;
#line 605
  pfc->delay = my_pfc->delay;
#line 607
  i = 0;
#line 607
  goto ldv_51094;
  ldv_51093: 
#line 608
  pfc->requests[i] = adapter->stats.pxoffrxc[i];
#line 609
  pfc->indications[i] = adapter->stats.pxofftxc[i];
#line 607
  i = i + 1;
  ldv_51094: ;
#line 607
  if (i <= 7) {
#line 609
    goto ldv_51093;
  } else {

  }

#line 612
  return (0);
}
}
#line 615 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setpfc(struct net_device *dev , struct ieee_pfc *pfc ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  u8 *prio_tc ;
  int err ;
  void *tmp___0 ;

  {
  {
#line 618
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 618
  adapter = (struct ixgbe_adapter *)tmp;
#line 619
  hw = & adapter->hw;
  }
#line 623
  if (((int )adapter->dcbx_cap & 8) == 0) {
#line 624
    return (-22);
  } else {

  }
#line 626
  if ((unsigned long )adapter->ixgbe_ieee_pfc == (unsigned long )((struct ieee_pfc *)0)) {
    {
#line 627
    tmp___0 = kmalloc(136UL, 208U);
#line 627
    adapter->ixgbe_ieee_pfc = (struct ieee_pfc *)tmp___0;
    }
#line 629
    if ((unsigned long )adapter->ixgbe_ieee_pfc == (unsigned long )((struct ieee_pfc *)0)) {
#line 630
      return (-12);
    } else {

    }
  } else {

  }
  {
#line 633
  prio_tc = (u8 *)(& (adapter->ixgbe_ieee_ets)->prio_tc);
#line 634
  memcpy((void *)adapter->ixgbe_ieee_pfc, (void const   *)pfc, 136UL);
  }
#line 637
  if ((unsigned int )pfc->pfc_en != 0U) {
    {
#line 638
    err = ixgbe_dcb_hw_pfc_config(hw, (int )pfc->pfc_en, prio_tc);
    }
  } else {
    {
#line 640
    err = (*(hw->mac.ops.fc_enable))(hw);
    }
  }
  {
#line 642
  ixgbe_set_rx_drop_en(adapter);
  }
#line 644
  return (err);
}
}
#line 647 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_setapp(struct net_device *dev , struct dcb_app *app ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  u8 app_mask ;
  u8 tmp___0 ;
  int vf ;
  struct vf_data_storage *vfinfo ;

  {
  {
#line 650
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 650
  adapter = (struct ixgbe_adapter *)tmp;
#line 651
  err = -22;
  }
#line 653
  if (((int )adapter->dcbx_cap & 8) == 0) {
#line 654
    return (err);
  } else {

  }
  {
#line 656
  err = dcb_ieee_setapp(dev, app);
  }
#line 657
  if (err != 0) {
#line 658
    return (err);
  } else {

  }
#line 661
  if ((unsigned int )app->selector == 1U && (unsigned int )app->protocol == 35078U) {
    {
#line 663
    tmp___0 = dcb_ieee_getapp_mask(dev, app);
#line 663
    app_mask = tmp___0;
    }
#line 665
    if (((int )app_mask >> (int )adapter->fcoe.up) & 1) {
#line 666
      return (err);
    } else {

    }
    {
#line 668
    adapter->fcoe.up = app->priority;
#line 669
    ixgbe_dcbnl_devreset(dev);
    }
  } else {

  }
#line 674
  if ((unsigned int )app->selector == 1U && (unsigned int )app->protocol == 0U) {
#line 678
    adapter->default_up = app->priority;
#line 680
    vf = 0;
#line 680
    goto ldv_51114;
    ldv_51113: 
#line 681
    vfinfo = adapter->vfinfo + (unsigned long )vf;
#line 683
    if ((unsigned int )vfinfo->pf_qos == 0U) {
      {
#line 684
      ixgbe_set_vmvir(adapter, (int )vfinfo->pf_vlan, (int )app->priority, (u32 )vf);
      }
    } else {

    }
#line 680
    vf = vf + 1;
    ldv_51114: ;
#line 680
    if ((unsigned int )vf < adapter->num_vfs) {
#line 682
      goto ldv_51113;
    } else {

    }

  } else {

  }
#line 689
  return (0);
}
}
#line 692 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static int ixgbe_dcbnl_ieee_delapp(struct net_device *dev , struct dcb_app *app ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int err ;
  u8 app_mask ;
  u8 tmp___0 ;
  int tmp___1 ;
  int vf ;
  unsigned long app_mask___0 ;
  u8 tmp___2 ;
  int qos ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  struct vf_data_storage *vfinfo ;

  {
  {
#line 695
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 695
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 698
  if (((int )adapter->dcbx_cap & 8) == 0) {
#line 699
    return (-22);
  } else {

  }
  {
#line 701
  err = dcb_ieee_delapp(dev, app);
  }
#line 704
  if ((err == 0 && (unsigned int )app->selector == 1U) && (unsigned int )app->protocol == 35078U) {
    {
#line 706
    tmp___0 = dcb_ieee_getapp_mask(dev, app);
#line 706
    app_mask = tmp___0;
    }
#line 708
    if (((int )app_mask >> (int )adapter->fcoe.up) & 1) {
#line 709
      return (err);
    } else {

    }
#line 711
    if ((unsigned int )app_mask != 0U) {
      {
#line 711
      tmp___1 = ffs((int )app_mask);
#line 711
      adapter->fcoe.up = (unsigned int )((u8 )tmp___1) + 255U;
      }
    } else {
#line 711
      adapter->fcoe.up = 3U;
    }
    {
#line 713
    ixgbe_dcbnl_devreset(dev);
    }
  } else {

  }
#line 717
  if (((unsigned int )app->selector == 1U && (unsigned int )app->protocol == 0U) && (int )adapter->default_up == (int )app->priority) {
    {
#line 720
    tmp___2 = dcb_ieee_getapp_mask(dev, app);
#line 720
    app_mask___0 = (unsigned long )tmp___2;
    }
#line 721
    if (app_mask___0 != 0UL) {
      {
#line 721
      tmp___3 = find_first_bit((unsigned long const   *)(& app_mask___0), 8UL);
#line 721
      tmp___4 = (int )tmp___3;
      }
    } else {
#line 721
      tmp___4 = 0;
    }
#line 721
    qos = tmp___4;
#line 723
    adapter->default_up = (u8 )qos;
#line 725
    vf = 0;
#line 725
    goto ldv_51128;
    ldv_51127: 
#line 726
    vfinfo = adapter->vfinfo + (unsigned long )vf;
#line 728
    if ((unsigned int )vfinfo->pf_qos == 0U) {
      {
#line 729
      ixgbe_set_vmvir(adapter, (int )vfinfo->pf_vlan, (int )((u16 )qos), (u32 )vf);
      }
    } else {

    }
#line 725
    vf = vf + 1;
    ldv_51128: ;
#line 725
    if ((unsigned int )vf < adapter->num_vfs) {
#line 727
      goto ldv_51127;
    } else {

    }

  } else {

  }
#line 734
  return (err);
}
}
#line 737 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_getdcbx(struct net_device *dev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;

  {
  {
#line 739
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 739
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 740
  return (adapter->dcbx_cap);
}
}
#line 743 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
static u8 ixgbe_dcbnl_setdcbx(struct net_device *dev , u8 mode ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ieee_ets ets ;
  struct ieee_pfc pfc ;
  int err ;
  u8 mask ;

  {
  {
#line 745
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 745
  adapter = (struct ixgbe_adapter *)tmp;
#line 746
  ets.willing = 0U;
#line 746
  ets.ets_cap = (unsigned char)0;
#line 746
  ets.cbs = (unsigned char)0;
#line 746
  ets.tc_tx_bw[0] = (unsigned char)0;
#line 746
  ets.tc_tx_bw[1] = (unsigned char)0;
#line 746
  ets.tc_tx_bw[2] = (unsigned char)0;
#line 746
  ets.tc_tx_bw[3] = (unsigned char)0;
#line 746
  ets.tc_tx_bw[4] = (unsigned char)0;
#line 746
  ets.tc_tx_bw[5] = (unsigned char)0;
#line 746
  ets.tc_tx_bw[6] = (unsigned char)0;
#line 746
  ets.tc_tx_bw[7] = (unsigned char)0;
#line 746
  ets.tc_rx_bw[0] = (unsigned char)0;
#line 746
  ets.tc_rx_bw[1] = (unsigned char)0;
#line 746
  ets.tc_rx_bw[2] = (unsigned char)0;
#line 746
  ets.tc_rx_bw[3] = (unsigned char)0;
#line 746
  ets.tc_rx_bw[4] = (unsigned char)0;
#line 746
  ets.tc_rx_bw[5] = (unsigned char)0;
#line 746
  ets.tc_rx_bw[6] = (unsigned char)0;
#line 746
  ets.tc_rx_bw[7] = (unsigned char)0;
#line 746
  ets.tc_tsa[0] = (unsigned char)0;
#line 746
  ets.tc_tsa[1] = (unsigned char)0;
#line 746
  ets.tc_tsa[2] = (unsigned char)0;
#line 746
  ets.tc_tsa[3] = (unsigned char)0;
#line 746
  ets.tc_tsa[4] = (unsigned char)0;
#line 746
  ets.tc_tsa[5] = (unsigned char)0;
#line 746
  ets.tc_tsa[6] = (unsigned char)0;
#line 746
  ets.tc_tsa[7] = (unsigned char)0;
#line 746
  ets.prio_tc[0] = (unsigned char)0;
#line 746
  ets.prio_tc[1] = (unsigned char)0;
#line 746
  ets.prio_tc[2] = (unsigned char)0;
#line 746
  ets.prio_tc[3] = (unsigned char)0;
#line 746
  ets.prio_tc[4] = (unsigned char)0;
#line 746
  ets.prio_tc[5] = (unsigned char)0;
#line 746
  ets.prio_tc[6] = (unsigned char)0;
#line 746
  ets.prio_tc[7] = (unsigned char)0;
#line 746
  ets.tc_reco_bw[0] = (unsigned char)0;
#line 746
  ets.tc_reco_bw[1] = (unsigned char)0;
#line 746
  ets.tc_reco_bw[2] = (unsigned char)0;
#line 746
  ets.tc_reco_bw[3] = (unsigned char)0;
#line 746
  ets.tc_reco_bw[4] = (unsigned char)0;
#line 746
  ets.tc_reco_bw[5] = (unsigned char)0;
#line 746
  ets.tc_reco_bw[6] = (unsigned char)0;
#line 746
  ets.tc_reco_bw[7] = (unsigned char)0;
#line 746
  ets.tc_reco_tsa[0] = (unsigned char)0;
#line 746
  ets.tc_reco_tsa[1] = (unsigned char)0;
#line 746
  ets.tc_reco_tsa[2] = (unsigned char)0;
#line 746
  ets.tc_reco_tsa[3] = (unsigned char)0;
#line 746
  ets.tc_reco_tsa[4] = (unsigned char)0;
#line 746
  ets.tc_reco_tsa[5] = (unsigned char)0;
#line 746
  ets.tc_reco_tsa[6] = (unsigned char)0;
#line 746
  ets.tc_reco_tsa[7] = (unsigned char)0;
#line 746
  ets.reco_prio_tc[0] = (unsigned char)0;
#line 746
  ets.reco_prio_tc[1] = (unsigned char)0;
#line 746
  ets.reco_prio_tc[2] = (unsigned char)0;
#line 746
  ets.reco_prio_tc[3] = (unsigned char)0;
#line 746
  ets.reco_prio_tc[4] = (unsigned char)0;
#line 746
  ets.reco_prio_tc[5] = (unsigned char)0;
#line 746
  ets.reco_prio_tc[6] = (unsigned char)0;
#line 746
  ets.reco_prio_tc[7] = (unsigned char)0;
#line 747
  pfc.pfc_cap = 0U;
#line 747
  pfc.pfc_en = (unsigned char)0;
#line 747
  pfc.mbc = (unsigned char)0;
#line 747
  pfc.delay = (unsigned short)0;
#line 747
  pfc.requests[0] = 0ULL;
#line 747
  pfc.requests[1] = 0ULL;
#line 747
  pfc.requests[2] = 0ULL;
#line 747
  pfc.requests[3] = 0ULL;
#line 747
  pfc.requests[4] = 0ULL;
#line 747
  pfc.requests[5] = 0ULL;
#line 747
  pfc.requests[6] = 0ULL;
#line 747
  pfc.requests[7] = 0ULL;
#line 747
  pfc.indications[0] = 0ULL;
#line 747
  pfc.indications[1] = 0ULL;
#line 747
  pfc.indications[2] = 0ULL;
#line 747
  pfc.indications[3] = 0ULL;
#line 747
  pfc.indications[4] = 0ULL;
#line 747
  pfc.indications[5] = 0ULL;
#line 747
  pfc.indications[6] = 0ULL;
#line 747
  pfc.indications[7] = 0ULL;
#line 748
  err = 0;
  }
#line 751
  if ((((int )mode & 2) != 0 || ((unsigned int )mode & 12U) == 12U) || ((int )mode & 1) == 0) {
#line 754
    return (1U);
  } else {

  }
#line 756
  if ((int )mode == (int )adapter->dcbx_cap) {
#line 757
    return (0U);
  } else {

  }
#line 759
  adapter->dcbx_cap = mode;
#line 762
  ets.ets_cap = 8U;
#line 763
  pfc.pfc_cap = 8U;
#line 765
  if (((int )mode & 8) != 0) {
    {
#line 766
    ixgbe_dcbnl_ieee_setets(dev, & ets);
#line 767
    ixgbe_dcbnl_ieee_setpfc(dev, & pfc);
    }
  } else
#line 768
  if (((int )mode & 4) != 0) {
    {
#line 769
    mask = 30U;
#line 771
    adapter->dcb_set_bitmap = (u8 )((int )adapter->dcb_set_bitmap | (int )mask);
#line 772
    ixgbe_dcbnl_set_all(dev);
    }
  } else {
    {
#line 777
    ixgbe_dcbnl_ieee_setets(dev, & ets);
#line 778
    ixgbe_dcbnl_ieee_setpfc(dev, & pfc);
#line 779
    err = ixgbe_setup_tc(dev, 0);
    }
  }
#line 782
  return (err != 0);
}
}
#line 785 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c"
struct dcbnl_rtnl_ops  const  dcbnl_ops  = 
#line 785
     {& ixgbe_dcbnl_ieee_getets, & ixgbe_dcbnl_ieee_setets, 0, 0, & ixgbe_dcbnl_ieee_getpfc,
    & ixgbe_dcbnl_ieee_setpfc, 0, & ixgbe_dcbnl_ieee_setapp, & ixgbe_dcbnl_ieee_delapp,
    0, 0, & ixgbe_dcbnl_get_state, & ixgbe_dcbnl_set_state, & ixgbe_dcbnl_get_perm_hw_addr,
    & ixgbe_dcbnl_set_pg_tc_cfg_tx, & ixgbe_dcbnl_set_pg_bwg_cfg_tx, & ixgbe_dcbnl_set_pg_tc_cfg_rx,
    & ixgbe_dcbnl_set_pg_bwg_cfg_rx, & ixgbe_dcbnl_get_pg_tc_cfg_tx, & ixgbe_dcbnl_get_pg_bwg_cfg_tx,
    & ixgbe_dcbnl_get_pg_tc_cfg_rx, & ixgbe_dcbnl_get_pg_bwg_cfg_rx, & ixgbe_dcbnl_set_pfc_cfg,
    & ixgbe_dcbnl_get_pfc_cfg, & ixgbe_dcbnl_set_all, & ixgbe_dcbnl_getcap, & ixgbe_dcbnl_getnumtcs,
    & ixgbe_dcbnl_setnumtcs, & ixgbe_dcbnl_getpfcstate, & ixgbe_dcbnl_setpfcstate,
    0, 0, 0, 0, 0, & ixgbe_dcbnl_getapp, 0, 0, & ixgbe_dcbnl_getdcbx, & ixgbe_dcbnl_setdcbx,
    0, 0, 0, 0};
#line 112 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_165(unsigned char (*arg0)(struct net_device * ) ,
                                                    struct net_device *arg1 ) 
{ 


  {
  {
#line 113
  ixgbe_dcbnl_set_all(arg1);
  }
#line 114
  return;
}
}
#line 117 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_166(unsigned char (*arg0)(struct net_device * ,
                                                                          unsigned char  ) ,
                                                    struct net_device *arg1 , unsigned char arg2 ) 
{ 


  {
  {
#line 118
  ixgbe_dcbnl_setdcbx(arg1, (int )arg2);
  }
#line 119
  return;
}
}
#line 122 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_169(int (*arg0)(struct net_device * ,
                                                                int  , unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 123
  ixgbe_dcbnl_setnumtcs(arg1, arg2, (int )arg3);
  }
#line 124
  return;
}
}
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_172(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 128
  ixgbe_dcbnl_set_pfc_cfg(arg1, arg2, (int )arg3);
  }
#line 129
  return;
}
}
#line 132 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_175(void (*arg0)(struct net_device * ,
                                                                 unsigned char  ) ,
                                                    struct net_device *arg1 , unsigned char arg2 ) 
{ 


  {
  {
#line 133
  ixgbe_dcbnl_setpfcstate(arg1, (int )arg2);
  }
#line 134
  return;
}
}
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_178(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 138
  ixgbe_dcbnl_set_pg_bwg_cfg_rx(arg1, arg2, (int )arg3);
  }
#line 139
  return;
}
}
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_181(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 143
  ixgbe_dcbnl_set_pg_bwg_cfg_tx(arg1, arg2, (int )arg3);
  }
#line 144
  return;
}
}
#line 147 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_184(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ,
                                                    unsigned char arg5 , unsigned char arg6 ) 
{ 


  {
  {
#line 148
  ixgbe_dcbnl_set_pg_tc_cfg_rx(arg1, arg2, (int )arg3, (int )arg4, (int )arg5, (int )arg6);
  }
#line 149
  return;
}
}
#line 152 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_187(void (*arg0)(struct net_device * ,
                                                                 int  , unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ,
                                                                 unsigned char  ) ,
                                                    struct net_device *arg1 , int arg2 ,
                                                    unsigned char arg3 , unsigned char arg4 ,
                                                    unsigned char arg5 , unsigned char arg6 ) 
{ 


  {
  {
#line 153
  ixgbe_dcbnl_set_pg_tc_cfg_tx(arg1, arg2, (int )arg3, (int )arg4, (int )arg5, (int )arg6);
  }
#line 154
  return;
}
}
#line 157 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_190(unsigned char (*arg0)(struct net_device * ,
                                                                          unsigned char  ) ,
                                                    struct net_device *arg1 , unsigned char arg2 ) 
{ 


  {
  {
#line 158
  ixgbe_dcbnl_set_state(arg1, (int )arg2);
  }
#line 159
  return;
}
}
#line 162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_38(unsigned char (*arg0)(struct net_device * ,
                                                                         unsigned char  ,
                                                                         unsigned short  ) ,
                                                   struct net_device *arg1 , unsigned char arg2 ,
                                                   unsigned short arg3 ) 
{ 


  {
  {
#line 163
  ixgbe_dcbnl_getapp(arg1, (int )arg2, (int )arg3);
  }
#line 164
  return;
}
}
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_41(unsigned char (*arg0)(struct net_device * ,
                                                                         int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 168
  ixgbe_dcbnl_getcap(arg1, arg2, arg3);
  }
#line 169
  return;
}
}
#line 172 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_44(unsigned char (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 173
  ixgbe_dcbnl_getdcbx(arg1);
  }
#line 174
  return;
}
}
#line 177 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_45(int (*arg0)(struct net_device * ,
                                                               int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 178
  ixgbe_dcbnl_getnumtcs(arg1, arg2, arg3);
  }
#line 179
  return;
}
}
#line 182 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_48(void (*arg0)(struct net_device * ,
                                                                unsigned char * ) ,
                                                   struct net_device *arg1 , unsigned char *arg2 ) 
{ 


  {
  {
#line 183
  ixgbe_dcbnl_get_perm_hw_addr(arg1, arg2);
  }
#line 184
  return;
}
}
#line 187 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_51(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 188
  ixgbe_dcbnl_get_pfc_cfg(arg1, arg2, arg3);
  }
#line 189
  return;
}
}
#line 192 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_54(unsigned char (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 193
  ixgbe_dcbnl_getpfcstate(arg1);
  }
#line 194
  return;
}
}
#line 197 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_55(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 198
  ixgbe_dcbnl_get_pg_bwg_cfg_rx(arg1, arg2, arg3);
  }
#line 199
  return;
}
}
#line 202 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_58(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 203
  ixgbe_dcbnl_get_pg_bwg_cfg_tx(arg1, arg2, arg3);
  }
#line 204
  return;
}
}
#line 207 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_61(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ,
                                                                unsigned char * ,
                                                                unsigned char * ,
                                                                unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 , unsigned char *arg4 ,
                                                   unsigned char *arg5 , unsigned char *arg6 ) 
{ 


  {
  {
#line 208
  ixgbe_dcbnl_get_pg_tc_cfg_rx(arg1, arg2, arg3, arg4, arg5, arg6);
  }
#line 209
  return;
}
}
#line 212 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_64(void (*arg0)(struct net_device * ,
                                                                int  , unsigned char * ,
                                                                unsigned char * ,
                                                                unsigned char * ,
                                                                unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 , unsigned char *arg4 ,
                                                   unsigned char *arg5 , unsigned char *arg6 ) 
{ 


  {
  {
#line 213
  ixgbe_dcbnl_get_pg_tc_cfg_tx(arg1, arg2, arg3, arg4, arg5, arg6);
  }
#line 214
  return;
}
}
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_67(unsigned char (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 218
  ixgbe_dcbnl_get_state(arg1);
  }
#line 219
  return;
}
}
#line 222 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_68(int (*arg0)(struct net_device * ,
                                                               struct dcb_app * ) ,
                                                   struct net_device *arg1 , struct dcb_app *arg2 ) 
{ 


  {
  {
#line 223
  ixgbe_dcbnl_ieee_delapp(arg1, arg2);
  }
#line 224
  return;
}
}
#line 227 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_69(int (*arg0)(struct net_device * ,
                                                               struct ieee_ets * ) ,
                                                   struct net_device *arg1 , struct ieee_ets *arg2 ) 
{ 


  {
  {
#line 228
  ixgbe_dcbnl_ieee_getets(arg1, arg2);
  }
#line 229
  return;
}
}
#line 232 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_70(int (*arg0)(struct net_device * ,
                                                               struct ieee_pfc * ) ,
                                                   struct net_device *arg1 , struct ieee_pfc *arg2 ) 
{ 


  {
  {
#line 233
  ixgbe_dcbnl_ieee_getpfc(arg1, arg2);
  }
#line 234
  return;
}
}
#line 237 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_71(int (*arg0)(struct net_device * ,
                                                               struct dcb_app * ) ,
                                                   struct net_device *arg1 , struct dcb_app *arg2 ) 
{ 


  {
  {
#line 238
  ixgbe_dcbnl_ieee_setapp(arg1, arg2);
  }
#line 239
  return;
}
}
#line 242 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_72(int (*arg0)(struct net_device * ,
                                                               struct ieee_ets * ) ,
                                                   struct net_device *arg1 , struct ieee_ets *arg2 ) 
{ 


  {
  {
#line 243
  ixgbe_dcbnl_ieee_setets(arg1, arg2);
  }
#line 244
  return;
}
}
#line 247 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_dcb_nl.c.aux"
void ldv_dummy_resourceless_instance_callback_6_73(int (*arg0)(struct net_device * ,
                                                               struct ieee_pfc * ) ,
                                                   struct net_device *arg1 , struct ieee_pfc *arg2 ) 
{ 


  {
  {
#line 248
  ixgbe_dcbnl_ieee_setpfc(arg1, arg2);
  }
#line 249
  return;
}
}
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/err.h"
long ldv_ptr_err(void const   *ptr ) ;
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 40
__inline static long IS_ERR(void const   *ptr ) ;
#line 611 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
extern void *devm_kmalloc(struct device * , size_t  , gfp_t  ) ;
#line 612 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/device.h"
__inline static void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) 
{ 
  void *tmp ;

  {
  {
#line 614
  tmp = devm_kmalloc(dev, size, gfp | 32768U);
  }
#line 614
  return (tmp);
}
}
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/hwmon.h"
extern struct device *devm_hwmon_device_register_with_groups(struct device * , char const   * ,
                                                             void * , struct attribute_group  const  ** ) ;
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_location(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  struct hwmon_attr *ixgbe_attr ;
  struct device_attribute  const  *__mptr ;
  int tmp ;

  {
  {
#line 45
  __mptr = (struct device_attribute  const  *)attr;
#line 45
  ixgbe_attr = (struct hwmon_attr *)__mptr;
#line 47
  tmp = sprintf(buf, "loc%u\n", (int )(ixgbe_attr->sensor)->location);
  }
#line 47
  return ((ssize_t )tmp);
}
}
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_temp(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  struct hwmon_attr *ixgbe_attr ;
  struct device_attribute  const  *__mptr ;
  unsigned int value ;
  int tmp ;

  {
  {
#line 55
  __mptr = (struct device_attribute  const  *)attr;
#line 55
  ixgbe_attr = (struct hwmon_attr *)__mptr;
#line 60
  (*((ixgbe_attr->hw)->mac.ops.get_thermal_sensor_data))(ixgbe_attr->hw);
#line 62
  value = (unsigned int )(ixgbe_attr->sensor)->temp;
#line 65
  value = value * 1000U;
#line 67
  tmp = sprintf(buf, "%u\n", value);
  }
#line 67
  return ((ssize_t )tmp);
}
}
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_cautionthresh(struct device *dev , struct device_attribute *attr ,
                                              char *buf ) 
{ 
  struct hwmon_attr *ixgbe_attr ;
  struct device_attribute  const  *__mptr ;
  unsigned int value ;
  int tmp ;

  {
  {
#line 74
  __mptr = (struct device_attribute  const  *)attr;
#line 74
  ixgbe_attr = (struct hwmon_attr *)__mptr;
#line 76
  value = (unsigned int )(ixgbe_attr->sensor)->caution_thresh;
#line 79
  value = value * 1000U;
#line 81
  tmp = sprintf(buf, "%u\n", value);
  }
#line 81
  return ((ssize_t )tmp);
}
}
#line 84 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static ssize_t ixgbe_hwmon_show_maxopthresh(struct device *dev , struct device_attribute *attr ,
                                            char *buf ) 
{ 
  struct hwmon_attr *ixgbe_attr ;
  struct device_attribute  const  *__mptr ;
  unsigned int value ;
  int tmp ;

  {
  {
#line 88
  __mptr = (struct device_attribute  const  *)attr;
#line 88
  ixgbe_attr = (struct hwmon_attr *)__mptr;
#line 90
  value = (unsigned int )(ixgbe_attr->sensor)->max_op_thresh;
#line 93
  value = value * 1000U;
#line 95
  tmp = sprintf(buf, "%u\n", value);
  }
#line 95
  return ((ssize_t )tmp);
}
}
#line 108 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static int ixgbe_add_hwmon_attr(struct ixgbe_adapter *adapter , unsigned int offset ,
                                int type ) 
{ 
  int rc ;
  unsigned int n_attr ;
  struct hwmon_attr *ixgbe_attr ;
  struct lock_class_key __key ;

  {
#line 114
  n_attr = (adapter->ixgbe_hwmon_buff)->n_hwmon;
#line 115
  ixgbe_attr = (struct hwmon_attr *)(& (adapter->ixgbe_hwmon_buff)->hwmon_list) + (unsigned long )n_attr;
  {
#line 118
  if (type == 0) {
#line 118
    goto case_0;
  } else {

  }
#line 123
  if (type == 1) {
#line 123
    goto case_1;
  } else {

  }
#line 128
  if (type == 2) {
#line 128
    goto case_2;
  } else {

  }
#line 133
  if (type == 3) {
#line 133
    goto case_3;
  } else {

  }
#line 138
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 119
  ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_location;
#line 120
  snprintf((char *)(& ixgbe_attr->name), 12UL, "temp%u_label", offset + 1U);
  }
#line 122
  goto ldv_51611;
  case_1: /* CIL Label */ 
  {
#line 124
  ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_temp;
#line 125
  snprintf((char *)(& ixgbe_attr->name), 12UL, "temp%u_input", offset + 1U);
  }
#line 127
  goto ldv_51611;
  case_2: /* CIL Label */ 
  {
#line 129
  ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_cautionthresh;
#line 130
  snprintf((char *)(& ixgbe_attr->name), 12UL, "temp%u_max", offset + 1U);
  }
#line 132
  goto ldv_51611;
  case_3: /* CIL Label */ 
  {
#line 134
  ixgbe_attr->dev_attr.show = & ixgbe_hwmon_show_maxopthresh;
#line 135
  snprintf((char *)(& ixgbe_attr->name), 12UL, "temp%u_crit", offset + 1U);
  }
#line 137
  goto ldv_51611;
  switch_default: /* CIL Label */ 
#line 139
  rc = -1;
#line 140
  return (rc);
  switch_break: /* CIL Label */ ;
  }
  ldv_51611: 
#line 144
  ixgbe_attr->sensor = (struct ixgbe_thermal_diode_data *)(& adapter->hw.mac.thermal_sensor_data.sensor) + (unsigned long )offset;
#line 146
  ixgbe_attr->hw = & adapter->hw;
#line 147
  ixgbe_attr->dev_attr.store = (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0;
#line 148
  ixgbe_attr->dev_attr.attr.mode = 292U;
#line 149
  ixgbe_attr->dev_attr.attr.name = (char const   *)(& ixgbe_attr->name);
#line 150
  ixgbe_attr->dev_attr.attr.key = & __key;
#line 152
  (adapter->ixgbe_hwmon_buff)->attrs[n_attr] = & ixgbe_attr->dev_attr.attr;
#line 154
  (adapter->ixgbe_hwmon_buff)->n_hwmon = (adapter->ixgbe_hwmon_buff)->n_hwmon + 1U;
#line 156
  return (0);
}
}
#line 159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
static void ixgbe_sysfs_del_adapter(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 161
  return;
}
}
#line 164 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter ) 
{ 


  {
  {
#line 166
  ixgbe_sysfs_del_adapter(adapter);
  }
#line 167
  return;
}
}
#line 170 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c"
int ixgbe_sysfs_init(struct ixgbe_adapter *adapter ) 
{ 
  struct hwmon_buff *ixgbe_hwmon ;
  struct device *hwmon_dev ;
  unsigned int i ;
  int rc ;
  s32 tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 175
  rc = 0;
#line 178
  if ((unsigned long )adapter->hw.mac.ops.init_thermal_sensor_thresh == (unsigned long )((s32 (*)(struct ixgbe_hw * ))0)) {
#line 179
    goto exit;
  } else {

  }
  {
#line 183
  tmp = (*(adapter->hw.mac.ops.init_thermal_sensor_thresh))(& adapter->hw);
  }
#line 183
  if (tmp != 0) {
#line 184
    goto exit;
  } else {

  }
  {
#line 186
  tmp___0 = devm_kzalloc(& (adapter->pdev)->dev, 1120UL, 208U);
#line 186
  ixgbe_hwmon = (struct hwmon_buff *)tmp___0;
  }
#line 188
  if ((unsigned long )ixgbe_hwmon == (unsigned long )((struct hwmon_buff *)0)) {
#line 189
    rc = -12;
#line 190
    goto exit;
  } else {

  }
#line 192
  adapter->ixgbe_hwmon_buff = ixgbe_hwmon;
#line 194
  i = 0U;
#line 194
  goto ldv_51633;
  ldv_51632: ;
#line 199
  if ((unsigned int )adapter->hw.mac.thermal_sensor_data.sensor[i].location == 0U) {
#line 200
    goto ldv_51631;
  } else {

  }
  {
#line 203
  rc = ixgbe_add_hwmon_attr(adapter, i, 2);
  }
#line 204
  if (rc != 0) {
#line 205
    goto exit;
  } else {

  }
  {
#line 206
  rc = ixgbe_add_hwmon_attr(adapter, i, 0);
  }
#line 207
  if (rc != 0) {
#line 208
    goto exit;
  } else {

  }
  {
#line 209
  rc = ixgbe_add_hwmon_attr(adapter, i, 1);
  }
#line 210
  if (rc != 0) {
#line 211
    goto exit;
  } else {

  }
  {
#line 212
  rc = ixgbe_add_hwmon_attr(adapter, i, 3);
  }
#line 213
  if (rc != 0) {
#line 214
    goto exit;
  } else {

  }
  ldv_51631: 
#line 194
  i = i + 1U;
  ldv_51633: ;
#line 194
  if (i <= 2U) {
#line 196
    goto ldv_51632;
  } else {

  }
  {
#line 217
  ixgbe_hwmon->groups[0] = (struct attribute_group  const  *)(& ixgbe_hwmon->group);
#line 218
  ixgbe_hwmon->group.attrs = (struct attribute **)(& ixgbe_hwmon->attrs);
#line 220
  hwmon_dev = devm_hwmon_device_register_with_groups(& (adapter->pdev)->dev, "ixgbe",
                                                     (void *)ixgbe_hwmon, (struct attribute_group  const  **)(& ixgbe_hwmon->groups));
#line 224
  tmp___2 = IS_ERR((void const   *)hwmon_dev);
  }
#line 224
  if (tmp___2 != 0L) {
    {
#line 225
    tmp___1 = PTR_ERR((void const   *)hwmon_dev);
#line 225
    rc = (int )tmp___1;
    }
  } else {

  }
  exit: ;
#line 227
  return (rc);
}
}
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_sysfs.c.aux"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 93
  tmp = ldv_ptr_err(ptr);
  }
#line 93
  return (tmp);
}
}
#line 399 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/kernel.h"
extern char *kasprintf(gfp_t  , char const   *  , ...) ;
#line 403
extern int sscanf(char const   * , char const   *  , ...) ;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/string.h"
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 2623 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/fs.h"
extern int simple_open(struct inode * , struct file * ) ;
#line 2651
extern ssize_t simple_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
#line 2653
extern ssize_t simple_write_to_buffer(void * , size_t  , loff_t * , void const   * ,
                                      size_t  ) ;
#line 49 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/debugfs.h"
extern struct dentry *debugfs_create_file(char const   * , umode_t  , struct dentry * ,
                                          void * , struct file_operations  const  * ) ;
#line 53
extern struct dentry *debugfs_create_dir(char const   * , struct dentry * ) ;
#line 59
extern void debugfs_remove_recursive(struct dentry * ) ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct dentry *ixgbe_dbg_root  ;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static char ixgbe_dbg_reg_ops_buf[256U]  = {      '\000'};
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_reg_ops_read(struct file *filp , char *buffer , size_t count ,
                                      loff_t *ppos ) 
{ 
  struct ixgbe_adapter *adapter ;
  char *buf ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 46
  adapter = (struct ixgbe_adapter *)filp->private_data;
#line 51
  if (*ppos != 0LL) {
#line 52
    return (0L);
  } else {

  }
  {
#line 54
  buf = kasprintf(208U, "%s: %s\n", (char *)(& (adapter->netdev)->name), (char *)(& ixgbe_dbg_reg_ops_buf));
  }
#line 57
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 58
    return (-12L);
  } else {

  }
  {
#line 60
  tmp = strlen((char const   *)buf);
  }
#line 60
  if (count < tmp) {
    {
#line 61
    kfree((void const   *)buf);
    }
#line 62
    return (-28L);
  } else {

  }
  {
#line 65
  tmp___0 = strlen((char const   *)buf);
#line 65
  tmp___1 = simple_read_from_buffer((void *)buffer, count, ppos, (void const   *)buf,
                                    tmp___0);
#line 65
  len = (int )tmp___1;
#line 67
  kfree((void const   *)buf);
  }
#line 68
  return ((ssize_t )len);
}
}
#line 78 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_reg_ops_write(struct file *filp , char const   *buffer ,
                                       size_t count , loff_t *ppos ) 
{ 
  struct ixgbe_adapter *adapter ;
  int len ;
  ssize_t tmp ;
  u32 reg ;
  u32 value ;
  int cnt ;
  u32 reg___0 ;
  u32 value___0 ;
  int cnt___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 82
  adapter = (struct ixgbe_adapter *)filp->private_data;
#line 86
  if (*ppos != 0LL) {
#line 87
    return (0L);
  } else {

  }
#line 88
  if (count > 255UL) {
#line 89
    return (-28L);
  } else {

  }
  {
#line 91
  tmp = simple_write_to_buffer((void *)(& ixgbe_dbg_reg_ops_buf), 255UL, ppos, (void const   *)buffer,
                               count);
#line 91
  len = (int )tmp;
  }
#line 96
  if (len < 0) {
#line 97
    return ((ssize_t )len);
  } else {

  }
  {
#line 99
  ixgbe_dbg_reg_ops_buf[len] = 0;
#line 101
  tmp___1 = strncmp((char const   *)(& ixgbe_dbg_reg_ops_buf), "write", 5UL);
  }
#line 101
  if (tmp___1 == 0) {
    {
#line 104
    cnt = sscanf((char const   *)(& ixgbe_dbg_reg_ops_buf) + 5U, "%x %x", & reg, & value);
    }
#line 105
    if (cnt == 2) {
      {
#line 106
      ixgbe_write_reg(& adapter->hw, reg, value);
#line 107
      value = ixgbe_read_reg(& adapter->hw, reg);
#line 108
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "write: 0x%08x = 0x%08x\n",
                reg, value);
      }
    } else {
      {
#line 110
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "write <reg> <value>\n");
      }
    }
  } else {
    {
#line 112
    tmp___0 = strncmp((char const   *)(& ixgbe_dbg_reg_ops_buf), "read", 4UL);
    }
#line 112
    if (tmp___0 == 0) {
      {
#line 115
      cnt___0 = sscanf((char const   *)(& ixgbe_dbg_reg_ops_buf) + 4U, "%x", & reg___0);
      }
#line 116
      if (cnt___0 == 1) {
        {
#line 117
        value___0 = ixgbe_read_reg(& adapter->hw, reg___0);
#line 118
        _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "read 0x%08x = 0x%08x\n",
                  reg___0, value___0);
        }
      } else {
        {
#line 120
        _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "read <reg>\n");
        }
      }
    } else {
      {
#line 123
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Unknown command %s\n",
                (char *)(& ixgbe_dbg_reg_ops_buf));
#line 124
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Available commands:\n");
#line 125
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "   read <reg>\n");
#line 126
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "   write <reg> <value>\n");
      }
    }
  }
#line 128
  return ((ssize_t )count);
}
}
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct file_operations  const  ixgbe_dbg_reg_ops_fops  = 
#line 131
     {& __this_module, 0, & ixgbe_dbg_reg_ops_read, & ixgbe_dbg_reg_ops_write, 0, 0,
    0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 138 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static char ixgbe_dbg_netdev_ops_buf[256U]  = {      '\000'};
#line 147 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_netdev_ops_read(struct file *filp , char *buffer , size_t count ,
                                         loff_t *ppos ) 
{ 
  struct ixgbe_adapter *adapter ;
  char *buf ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 151
  adapter = (struct ixgbe_adapter *)filp->private_data;
#line 156
  if (*ppos != 0LL) {
#line 157
    return (0L);
  } else {

  }
  {
#line 159
  buf = kasprintf(208U, "%s: %s\n", (char *)(& (adapter->netdev)->name), (char *)(& ixgbe_dbg_netdev_ops_buf));
  }
#line 162
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 163
    return (-12L);
  } else {

  }
  {
#line 165
  tmp = strlen((char const   *)buf);
  }
#line 165
  if (count < tmp) {
    {
#line 166
    kfree((void const   *)buf);
    }
#line 167
    return (-28L);
  } else {

  }
  {
#line 170
  tmp___0 = strlen((char const   *)buf);
#line 170
  tmp___1 = simple_read_from_buffer((void *)buffer, count, ppos, (void const   *)buf,
                                    tmp___0);
#line 170
  len = (int )tmp___1;
#line 172
  kfree((void const   *)buf);
  }
#line 173
  return ((ssize_t )len);
}
}
#line 183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static ssize_t ixgbe_dbg_netdev_ops_write(struct file *filp , char const   *buffer ,
                                          size_t count , loff_t *ppos ) 
{ 
  struct ixgbe_adapter *adapter ;
  int len ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 187
  adapter = (struct ixgbe_adapter *)filp->private_data;
#line 191
  if (*ppos != 0LL) {
#line 192
    return (0L);
  } else {

  }
#line 193
  if (count > 255UL) {
#line 194
    return (-28L);
  } else {

  }
  {
#line 196
  tmp = simple_write_to_buffer((void *)(& ixgbe_dbg_netdev_ops_buf), 255UL, ppos,
                               (void const   *)buffer, count);
#line 196
  len = (int )tmp;
  }
#line 201
  if (len < 0) {
#line 202
    return ((ssize_t )len);
  } else {

  }
  {
#line 204
  ixgbe_dbg_netdev_ops_buf[len] = 0;
#line 206
  tmp___0 = strncmp((char const   *)(& ixgbe_dbg_netdev_ops_buf), "tx_timeout", 10UL);
  }
#line 206
  if (tmp___0 == 0) {
    {
#line 207
    (*(((adapter->netdev)->netdev_ops)->ndo_tx_timeout))(adapter->netdev);
#line 208
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "tx_timeout called\n");
    }
  } else {
    {
#line 210
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Unknown command: %s\n",
              (char *)(& ixgbe_dbg_netdev_ops_buf));
#line 211
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Available commands:\n");
#line 212
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "    tx_timeout\n");
    }
  }
#line 214
  return ((ssize_t )count);
}
}
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
static struct file_operations  const  ixgbe_dbg_netdev_ops_fops  = 
#line 217
     {& __this_module, 0, & ixgbe_dbg_netdev_ops_read, & ixgbe_dbg_netdev_ops_write,
    0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0};
#line 228 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter ) 
{ 
  char const   *name ;
  char const   *tmp ;
  struct dentry *pfile ;

  {
  {
#line 230
  tmp = pci_name((struct pci_dev  const  *)adapter->pdev);
#line 230
  name = tmp;
#line 232
  adapter->ixgbe_dbg_adapter = debugfs_create_dir(name, ixgbe_dbg_root);
  }
#line 233
  if ((unsigned long )adapter->ixgbe_dbg_adapter != (unsigned long )((struct dentry *)0)) {
    {
#line 234
    pfile = debugfs_create_file("reg_ops", 384, adapter->ixgbe_dbg_adapter, (void *)adapter,
                                & ixgbe_dbg_reg_ops_fops);
    }
#line 237
    if ((unsigned long )pfile == (unsigned long )((struct dentry *)0)) {
      {
#line 238
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "debugfs reg_ops for %s failed\n",
              name);
      }
    } else {

    }
    {
#line 239
    pfile = debugfs_create_file("netdev_ops", 384, adapter->ixgbe_dbg_adapter, (void *)adapter,
                                & ixgbe_dbg_netdev_ops_fops);
    }
#line 242
    if ((unsigned long )pfile == (unsigned long )((struct dentry *)0)) {
      {
#line 243
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "debugfs netdev_ops for %s failed\n",
              name);
      }
    } else {

    }
  } else {
    {
#line 245
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "debugfs entry for %s failed\n",
            name);
    }
  }
#line 246
  return;
}
}
#line 253 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter ) 
{ 


  {
#line 255
  if ((unsigned long )adapter->ixgbe_dbg_adapter != (unsigned long )((struct dentry *)0)) {
    {
#line 256
    debugfs_remove_recursive(adapter->ixgbe_dbg_adapter);
    }
  } else {

  }
#line 257
  adapter->ixgbe_dbg_adapter = (struct dentry *)0;
#line 258
  return;
}
}
#line 263 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_init(void) 
{ 


  {
  {
#line 265
  ixgbe_dbg_root = debugfs_create_dir((char const   *)(& ixgbe_driver_name), (struct dentry *)0);
  }
#line 266
  if ((unsigned long )ixgbe_dbg_root == (unsigned long )((struct dentry *)0)) {
    {
#line 267
    printk("\vixgbe: init of debugfs failed\n");
    }
  } else {

  }
#line 268
  return;
}
}
#line 273 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c"
void ixgbe_dbg_exit(void) 
{ 


  {
  {
#line 275
  debugfs_remove_recursive(ixgbe_dbg_root);
  }
#line 276
  return;
}
}
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
void ldv_file_operations_instance_callback_0_5(long (*arg0)(struct file * , char * ,
                                                            unsigned long  , long long * ) ,
                                               struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                               long long *arg4 ) ;
#line 80
void ldv_file_operations_instance_callback_1_5(long (*arg0)(struct file * , char * ,
                                                            unsigned long  , long long * ) ,
                                               struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                               long long *arg4 ) ;
#line 81
int ldv_file_operations_instance_probe_0_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 82
int ldv_file_operations_instance_probe_1_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 83
void ldv_file_operations_instance_write_0_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 84
void ldv_file_operations_instance_write_1_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 87 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
struct ldv_thread ldv_thread_0  ;
#line 88 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
struct ldv_thread ldv_thread_1  ;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
void ldv_file_operations_file_operations_instance_0(void *arg0 ) 
{ 
  long (*ldv_0_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_0_container_file_operations ;
  char *ldv_0_ldv_param_4_1_default ;
  long long *ldv_0_ldv_param_4_3_default ;
  char *ldv_0_ldv_param_5_1_default ;
  long long *ldv_0_ldv_param_5_3_default ;
  struct file *ldv_0_resource_file ;
  struct inode *ldv_0_resource_inode ;
  int ldv_0_ret_default ;
  unsigned long ldv_0_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 109
  ldv_0_ret_default = 1;
#line 114
  tmp = ldv_xmalloc(520UL);
#line 114
  ldv_0_resource_file = (struct file *)tmp;
#line 115
  tmp___0 = ldv_xmalloc(1032UL);
#line 115
  ldv_0_resource_inode = (struct inode *)tmp___0;
#line 116
  tmp___1 = ldv_undef_int();
#line 116
  ldv_0_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 123
  goto ldv_main_0;
#line 125
  return;
  ldv_main_0: 
  {
#line 131
  tmp___3 = ldv_undef_int();
  }
#line 131
  if (tmp___3 != 0) {
    {
#line 134
    ldv_0_ret_default = ldv_file_operations_instance_probe_0_12(ldv_0_container_file_operations->open,
                                                                ldv_0_resource_inode,
                                                                ldv_0_resource_file);
#line 136
    ldv_0_ret_default = ldv_filter_err_code(ldv_0_ret_default);
#line 139
    tmp___2 = ldv_undef_int();
    }
#line 139
    if (tmp___2 != 0) {
      {
#line 141
      ldv_assume(ldv_0_ret_default == 0);
      }
#line 148
      goto ldv_call_0;
    } else {
      {
#line 152
      ldv_assume(ldv_0_ret_default != 0);
      }
#line 159
      goto ldv_main_0;
    }
  } else {
    {
#line 164
    ldv_free((void *)ldv_0_resource_file);
#line 165
    ldv_free((void *)ldv_0_resource_inode);
    }
#line 173
    return;
  }
#line 176
  return;
  ldv_call_0: 
  {
#line 182
  tmp___4 = ldv_undef_int();
  }
  {
#line 183
  if (tmp___4 == 1) {
#line 183
    goto case_1;
  } else {

  }
#line 206
  if (tmp___4 == 2) {
#line 206
    goto case_2;
  } else {

  }
#line 233
  if (tmp___4 == 3) {
#line 233
    goto case_3;
  } else {

  }
#line 245
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 185
  tmp___5 = ldv_xmalloc(1UL);
#line 185
  ldv_0_ldv_param_5_1_default = (char *)tmp___5;
#line 186
  tmp___6 = ldv_xmalloc(8UL);
#line 186
  ldv_0_ldv_param_5_3_default = (long long *)tmp___6;
#line 191
  ldv_file_operations_instance_callback_0_5(ldv_0_callback_read, ldv_0_resource_file,
                                            ldv_0_ldv_param_5_1_default, ldv_0_size_cnt_write_size,
                                            ldv_0_ldv_param_5_3_default);
#line 195
  ldv_free((void *)ldv_0_ldv_param_5_1_default);
#line 196
  ldv_free((void *)ldv_0_ldv_param_5_3_default);
  }
#line 203
  goto ldv_call_0;
  case_2: /* CIL Label */ 
  {
#line 208
  tmp___7 = ldv_xmalloc(1UL);
#line 208
  ldv_0_ldv_param_4_1_default = (char *)tmp___7;
#line 209
  tmp___8 = ldv_xmalloc(8UL);
#line 209
  ldv_0_ldv_param_4_3_default = (long long *)tmp___8;
#line 214
  ldv_assume(ldv_0_size_cnt_write_size <= 2147479552UL);
#line 216
  ldv_file_operations_instance_write_0_4((long (*)(struct file * , char * , unsigned long  ,
                                                   long long * ))ldv_0_container_file_operations->write,
                                         ldv_0_resource_file, ldv_0_ldv_param_4_1_default,
                                         ldv_0_size_cnt_write_size, ldv_0_ldv_param_4_3_default);
#line 220
  ldv_free((void *)ldv_0_ldv_param_4_1_default);
#line 221
  ldv_free((void *)ldv_0_ldv_param_4_3_default);
  }
#line 228
  goto ldv_call_0;
#line 230
  goto ldv_call_0;
  case_3: /* CIL Label */ ;
#line 242
  goto ldv_main_0;
  switch_default: /* CIL Label */ 
  {
#line 245
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 253 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
void ldv_file_operations_file_operations_instance_1(void *arg0 ) 
{ 
  long (*ldv_1_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_1_container_file_operations ;
  char *ldv_1_ldv_param_4_1_default ;
  long long *ldv_1_ldv_param_4_3_default ;
  char *ldv_1_ldv_param_5_1_default ;
  long long *ldv_1_ldv_param_5_3_default ;
  struct file *ldv_1_resource_file ;
  struct inode *ldv_1_resource_inode ;
  int ldv_1_ret_default ;
  unsigned long ldv_1_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 268
  ldv_1_ret_default = 1;
#line 273
  tmp = ldv_xmalloc(520UL);
#line 273
  ldv_1_resource_file = (struct file *)tmp;
#line 274
  tmp___0 = ldv_xmalloc(1032UL);
#line 274
  ldv_1_resource_inode = (struct inode *)tmp___0;
#line 275
  tmp___1 = ldv_undef_int();
#line 275
  ldv_1_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 282
  goto ldv_main_1;
#line 284
  return;
  ldv_main_1: 
  {
#line 290
  tmp___3 = ldv_undef_int();
  }
#line 290
  if (tmp___3 != 0) {
    {
#line 293
    ldv_1_ret_default = ldv_file_operations_instance_probe_1_12(ldv_1_container_file_operations->open,
                                                                ldv_1_resource_inode,
                                                                ldv_1_resource_file);
#line 295
    ldv_1_ret_default = ldv_filter_err_code(ldv_1_ret_default);
#line 298
    tmp___2 = ldv_undef_int();
    }
#line 298
    if (tmp___2 != 0) {
      {
#line 300
      ldv_assume(ldv_1_ret_default == 0);
      }
#line 307
      goto ldv_call_1;
    } else {
      {
#line 311
      ldv_assume(ldv_1_ret_default != 0);
      }
#line 318
      goto ldv_main_1;
    }
  } else {
    {
#line 323
    ldv_free((void *)ldv_1_resource_file);
#line 324
    ldv_free((void *)ldv_1_resource_inode);
    }
#line 332
    return;
  }
#line 335
  return;
  ldv_call_1: 
  {
#line 341
  tmp___4 = ldv_undef_int();
  }
  {
#line 342
  if (tmp___4 == 1) {
#line 342
    goto case_1;
  } else {

  }
#line 365
  if (tmp___4 == 2) {
#line 365
    goto case_2;
  } else {

  }
#line 392
  if (tmp___4 == 3) {
#line 392
    goto case_3;
  } else {

  }
#line 404
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 344
  tmp___5 = ldv_xmalloc(1UL);
#line 344
  ldv_1_ldv_param_5_1_default = (char *)tmp___5;
#line 345
  tmp___6 = ldv_xmalloc(8UL);
#line 345
  ldv_1_ldv_param_5_3_default = (long long *)tmp___6;
#line 350
  ldv_file_operations_instance_callback_1_5(ldv_1_callback_read, ldv_1_resource_file,
                                            ldv_1_ldv_param_5_1_default, ldv_1_size_cnt_write_size,
                                            ldv_1_ldv_param_5_3_default);
#line 354
  ldv_free((void *)ldv_1_ldv_param_5_1_default);
#line 355
  ldv_free((void *)ldv_1_ldv_param_5_3_default);
  }
#line 362
  goto ldv_call_1;
  case_2: /* CIL Label */ 
  {
#line 367
  tmp___7 = ldv_xmalloc(1UL);
#line 367
  ldv_1_ldv_param_4_1_default = (char *)tmp___7;
#line 368
  tmp___8 = ldv_xmalloc(8UL);
#line 368
  ldv_1_ldv_param_4_3_default = (long long *)tmp___8;
#line 373
  ldv_assume(ldv_1_size_cnt_write_size <= 2147479552UL);
#line 375
  ldv_file_operations_instance_write_1_4((long (*)(struct file * , char * , unsigned long  ,
                                                   long long * ))ldv_1_container_file_operations->write,
                                         ldv_1_resource_file, ldv_1_ldv_param_4_1_default,
                                         ldv_1_size_cnt_write_size, ldv_1_ldv_param_4_3_default);
#line 379
  ldv_free((void *)ldv_1_ldv_param_4_1_default);
#line 380
  ldv_free((void *)ldv_1_ldv_param_4_3_default);
  }
#line 387
  goto ldv_call_1;
#line 389
  goto ldv_call_1;
  case_3: /* CIL Label */ ;
#line 401
  goto ldv_main_1;
  switch_default: /* CIL Label */ 
  {
#line 404
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 412 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
void ldv_file_operations_instance_callback_0_5(long (*arg0)(struct file * , char * ,
                                                            unsigned long  , long long * ) ,
                                               struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                               long long *arg4 ) 
{ 


  {
  {
#line 413
  ixgbe_dbg_netdev_ops_read(arg1, arg2, arg3, arg4);
  }
#line 414
  return;
}
}
#line 417 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
void ldv_file_operations_instance_callback_1_5(long (*arg0)(struct file * , char * ,
                                                            unsigned long  , long long * ) ,
                                               struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                               long long *arg4 ) 
{ 


  {
  {
#line 418
  ixgbe_dbg_reg_ops_read(arg1, arg2, arg3, arg4);
  }
#line 419
  return;
}
}
#line 422 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
int ldv_file_operations_instance_probe_0_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 423
  tmp = simple_open(arg1, arg2);
  }
#line 423
  return (tmp);
}
}
#line 427 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
int ldv_file_operations_instance_probe_1_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 428
  tmp = simple_open(arg1, arg2);
  }
#line 428
  return (tmp);
}
}
#line 432 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
void ldv_file_operations_instance_write_0_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 433
  ixgbe_dbg_netdev_ops_write(arg1, (char const   *)arg2, arg3, arg4);
  }
#line 434
  return;
}
}
#line 437 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/weaver/.tmp_ixgbe_debugfs.c.aux"
void ldv_file_operations_instance_write_1_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 438
  ixgbe_dbg_reg_ops_write(arg1, (char const   *)arg2, arg3, arg4);
  }
#line 439
  return;
}
}
#line 115 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 


  {
#line 117
  __asm__  volatile   ("":);
#line 117
  return (0);

#line 117
  return (1);
}
}
#line 162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/percpu.h"
extern void *__alloc_percpu(size_t  , size_t  ) ;
#line 163
extern void free_percpu(void * ) ;
#line 95 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 98
  tmp = __builtin_expect(sg->sg_magic != 2271560481UL, 0L);
  }
#line 98
  if (tmp != 0L) {
    {
#line 98
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (98), "i" (12UL));
#line 98
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 99
  tmp___0 = __builtin_expect((long )((int )sg->page_link) & 1L, 0L);
  }
#line 99
  if (tmp___0 != 0L) {
    {
#line 99
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (99), "i" (12UL));
#line 99
    __builtin_unreachable();
    }
  } else {

  }
#line 101
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 218 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
  {
#line 220
  tmp = sg_page(sg);
#line 220
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
  }
#line 220
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 224
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 50
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 46
  tmp = get_dma_ops(dev);
#line 46
  ops = tmp;
#line 50
  i = 0;
#line 50
  s = sg;
  }
#line 50
  goto ldv_28900;
  ldv_28899: 
  {
#line 51
  tmp___0 = sg_virt(s);
#line 51
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 50
  i = i + 1;
#line 50
  s = sg_next(s);
  }
  ldv_28900: ;
#line 50
  if (i < nents) {
#line 52
    goto ldv_28899;
  } else {

  }
  {
#line 52
  tmp___1 = valid_dma_direction((int )dir);
#line 52
  tmp___2 = __builtin_expect(tmp___1 == 0, 0L);
  }
#line 52
  if (tmp___2 != 0L) {
    {
#line 52
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (52), "i" (12UL));
#line 52
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 53
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 54
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
  }
#line 56
  return (ents);
}
}
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 63
  tmp = get_dma_ops(dev);
#line 63
  ops = tmp;
#line 65
  tmp___0 = valid_dma_direction((int )dir);
#line 65
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 65
  if (tmp___1 != 0L) {
    {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (65), "i" (12UL));
#line 65
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 66
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
  }
#line 67
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
    {
#line 68
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
    }
  } else {

  }
#line 69
  return;
}
}
#line 1525 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
extern unsigned char *__pskb_pull_tail(struct sk_buff * , int  ) ;
#line 1674 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_reset_transport_header(struct sk_buff *skb ) 
{ 


  {
#line 1676
  skb->transport_header = (int )((__u16 )((long )skb->data)) - (int )((__u16 )((long )skb->head));
#line 1677
  return;
}
}
#line 1679 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_set_transport_header(struct sk_buff *skb , int const   offset ) 
{ 


  {
  {
#line 1682
  skb_reset_transport_header(skb);
#line 1683
  skb->transport_header = (int )skb->transport_header + (int )((__u16 )offset);
  }
#line 1684
  return;
}
}
#line 1691 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_reset_network_header(struct sk_buff *skb ) 
{ 


  {
#line 1693
  skb->network_header = (int )((__u16 )((long )skb->data)) - (int )((__u16 )((long )skb->head));
#line 1694
  return;
}
}
#line 1696 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static void skb_set_network_header(struct sk_buff *skb , int const   offset ) 
{ 


  {
  {
#line 1698
  skb_reset_network_header(skb);
#line 1699
  skb->network_header = (int )skb->network_header + (int )((__u16 )offset);
  }
#line 1700
  return;
}
}
#line 1702 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static unsigned char *skb_mac_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1704
  return ((unsigned char *)skb->head + (unsigned long )skb->mac_header);
}
}
#line 2290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static int __skb_linearize(struct sk_buff *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 2292
  tmp = __pskb_pull_tail(skb, (int )skb->data_len);
  }
#line 2292
  return ((unsigned long )tmp != (unsigned long )((unsigned char *)0U) ? 0 : -12);
}
}
#line 2302 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/skbuff.h"
__inline static int skb_linearize(struct sk_buff *skb ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 2304
  tmp___2 = skb_is_nonlinear((struct sk_buff  const  *)skb);
  }
#line 2304
  if ((int )tmp___2) {
    {
#line 2304
    tmp___0 = __skb_linearize(skb);
#line 2304
    tmp___1 = tmp___0;
    }
  } else {
#line 2304
    tmp___1 = 0;
  }
#line 2304
  return (tmp___1);
}
}
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/if_ether.h"
__inline static struct ethhdr *eth_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 28
  tmp = skb_mac_header(skb);
  }
#line 28
  return ((struct ethhdr *)tmp);
}
}
#line 2950 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/netdevice.h"
extern void netdev_features_change(struct net_device * ) ;
#line 820 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 834 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
  {
#line 836
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  }
#line 836
  return (tmp);
}
}
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/linux/dmapool.h"
extern struct dma_pool *dma_pool_create(char const   * , struct device * , size_t  ,
                                        size_t  , size_t  ) ;
#line 20
extern void dma_pool_destroy(struct dma_pool * ) ;
#line 22
extern void *dma_pool_alloc(struct dma_pool * , gfp_t  , dma_addr_t * ) ;
#line 25
extern void dma_pool_free(struct dma_pool * , void * , dma_addr_t  ) ;
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/include/scsi/fc_frame.h"
__inline static u32 ntoh24(u8 const   *p ) 
{ 


  {
#line 40
  return ((u32 )((((int )*p << 16) | ((int )*(p + 1UL) << 8)) | (int )*(p + 2UL)));
}
}
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
__inline static void ixgbe_fcoe_clear_ddp(struct ixgbe_fcoe_ddp *ddp ) 
{ 


  {
#line 48
  ddp->len = 0;
#line 49
  ddp->err = 1U;
#line 50
  ddp->udl = (u64 *)0ULL;
#line 51
  ddp->udp = 0ULL;
#line 52
  ddp->sgl = (struct scatterlist *)0;
#line 53
  ddp->sgc = 0U;
#line 54
  return;
}
}
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_put(struct net_device *netdev , u16 xid ) 
{ 
  int len ;
  struct ixgbe_fcoe *fcoe ;
  struct ixgbe_adapter *adapter ;
  struct ixgbe_fcoe_ddp *ddp ;
  u32 fcbuff ;
  void *tmp ;

  {
#line 69
  len = 0;
#line 75
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 76
    goto out_ddp_put;
  } else {

  }
#line 78
  if ((unsigned int )xid > 511U) {
#line 79
    goto out_ddp_put;
  } else {

  }
  {
#line 81
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 81
  adapter = (struct ixgbe_adapter *)tmp;
#line 82
  fcoe = & adapter->fcoe;
#line 83
  ddp = (struct ixgbe_fcoe_ddp *)(& fcoe->ddp) + (unsigned long )xid;
  }
#line 84
  if ((unsigned long )ddp->udl == (unsigned long )((u64 *)0ULL)) {
#line 85
    goto out_ddp_put;
  } else {

  }
#line 87
  len = ddp->len;
#line 89
  if (ddp->err != 0U) {
    {
#line 90
    spin_lock_bh(& fcoe->lock);
#line 91
    ixgbe_write_reg(& adapter->hw, 20744U, 0U);
#line 92
    ixgbe_write_reg(& adapter->hw, 20752U, (unsigned int )xid | 16384U);
#line 94
    ixgbe_write_reg(& adapter->hw, 9240U, 0U);
#line 95
    ixgbe_write_reg(& adapter->hw, 9248U, (unsigned int )xid | 16384U);
#line 99
    ixgbe_write_reg(& adapter->hw, 9248U, (unsigned int )xid | 32768U);
#line 101
    fcbuff = ixgbe_read_reg(& adapter->hw, 9240U);
#line 102
    spin_unlock_bh(& fcoe->lock);
    }
#line 103
    if ((int )fcbuff & 1) {
      {
#line 104
      __const_udelay(429500UL);
      }
    } else {

    }
  } else {

  }
#line 106
  if ((unsigned long )ddp->sgl != (unsigned long )((struct scatterlist *)0)) {
    {
#line 107
    dma_unmap_sg_attrs(& (adapter->pdev)->dev, ddp->sgl, (int )ddp->sgc, 2, (struct dma_attrs *)0);
    }
  } else {

  }
#line 109
  if ((unsigned long )ddp->pool != (unsigned long )((struct dma_pool *)0)) {
    {
#line 110
    dma_pool_free(ddp->pool, (void *)ddp->udl, ddp->udp);
#line 111
    ddp->pool = (struct dma_pool *)0;
    }
  } else {

  }
  {
#line 114
  ixgbe_fcoe_clear_ddp(ddp);
  }
  out_ddp_put: ;
#line 117
  return (len);
}
}
#line 129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_ddp_setup(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                                unsigned int sgc , int target_mode ) 
{ 
  struct ixgbe_adapter *adapter ;
  struct ixgbe_hw *hw ;
  struct ixgbe_fcoe *fcoe ;
  struct ixgbe_fcoe_ddp *ddp ;
  struct ixgbe_fcoe_ddp_pool *ddp_pool ;
  struct scatterlist *sg ;
  unsigned int i ;
  unsigned int j ;
  unsigned int dmacount ;
  unsigned int len ;
  unsigned int bufflen ;
  unsigned int firstoff ;
  unsigned int lastsize ;
  unsigned int thisoff ;
  unsigned int thislen ;
  u32 fcbuff ;
  u32 fcdmarw ;
  u32 fcfltrw ;
  u32 fcrxctl ;
  dma_addr_t addr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify___0 ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  int tmp___4 ;

  {
#line 141
  bufflen = 4096U;
#line 142
  firstoff = 0U;
#line 144
  thisoff = 0U;
#line 145
  thislen = 0U;
#line 147
  addr = 0ULL;
#line 149
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0) || (unsigned long )sgl == (unsigned long )((struct scatterlist *)0)) {
#line 150
    return (0);
  } else {

  }
  {
#line 152
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 152
  adapter = (struct ixgbe_adapter *)tmp;
  }
#line 153
  if ((unsigned int )xid > 511U) {
#line 154
    if ((int )adapter->msg_enable & 1) {
      {
#line 154
      netdev_warn((struct net_device  const  *)adapter->netdev, "xid=0x%x out-of-range\n",
                  (int )xid);
      }
    } else {

    }
#line 155
    return (0);
  } else {

  }
  {
#line 159
  tmp___0 = constant_test_bit(2L, (unsigned long const volatile   *)(& adapter->state));
  }
#line 159
  if (tmp___0 != 0) {
#line 161
    return (0);
  } else {
    {
#line 159
    tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& adapter->state));
    }
#line 159
    if (tmp___1 != 0) {
#line 161
      return (0);
    } else {

    }
  }
#line 163
  fcoe = & adapter->fcoe;
#line 164
  ddp = (struct ixgbe_fcoe_ddp *)(& fcoe->ddp) + (unsigned long )xid;
#line 165
  if ((unsigned long )ddp->sgl != (unsigned long )((struct scatterlist *)0)) {
#line 166
    if ((int )adapter->msg_enable & 1) {
      {
#line 167
      netdev_err((struct net_device  const  *)adapter->netdev, "xid 0x%x w/ non-null sgl=%p nents=%d\n",
                 (int )xid, ddp->sgl, ddp->sgc);
      }
    } else {

    }
#line 168
    return (0);
  } else {

  }
  {
#line 170
  ixgbe_fcoe_clear_ddp(ddp);
  }
#line 173
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 174
    if ((int )adapter->msg_enable & 1) {
      {
#line 174
      netdev_warn((struct net_device  const  *)adapter->netdev, "No ddp_pool resources allocated\n");
      }
    } else {

    }
#line 175
    return (0);
  } else {

  }
  {
#line 178
  __vpp_verify = (void const   *)0;
#line 178
  __asm__  ("": "=r" (__ptr): "0" (fcoe->ddp_pool));
#line 178
  __preempt_count_add(1);
#line 178
  __asm__  volatile   ("": : : "memory");
#line 178
  __vpp_verify___0 = (void const   *)0;
  }
  {
#line 178
  if (4UL == 1UL) {
#line 178
    goto case_1;
  } else {

  }
#line 178
  if (4UL == 2UL) {
#line 178
    goto case_2___0;
  } else {

  }
#line 178
  if (4UL == 4UL) {
#line 178
    goto case_4___1;
  } else {

  }
#line 178
  if (4UL == 8UL) {
#line 178
    goto case_8___2;
  } else {

  }
#line 178
  goto switch_default___3;
  case_1: /* CIL Label */ ;
  {
#line 178
  if (4UL == 1UL) {
#line 178
    goto case_1___0;
  } else {

  }
#line 178
  if (4UL == 2UL) {
#line 178
    goto case_2;
  } else {

  }
#line 178
  if (4UL == 4UL) {
#line 178
    goto case_4;
  } else {

  }
#line 178
  if (4UL == 8UL) {
#line 178
    goto case_8;
  } else {

  }
#line 178
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 178
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 178
  goto ldv_56717;
  case_2: /* CIL Label */ 
#line 178
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 178
  goto ldv_56717;
  case_4: /* CIL Label */ 
#line 178
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 178
  goto ldv_56717;
  case_8: /* CIL Label */ 
#line 178
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 178
  goto ldv_56717;
  switch_default: /* CIL Label */ 
  {
#line 178
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_56717: 
#line 178
  pscr_ret__ = pfo_ret__;
#line 178
  goto ldv_56723;
  case_2___0: /* CIL Label */ ;
  {
#line 178
  if (4UL == 1UL) {
#line 178
    goto case_1___1;
  } else {

  }
#line 178
  if (4UL == 2UL) {
#line 178
    goto case_2___1;
  } else {

  }
#line 178
  if (4UL == 4UL) {
#line 178
    goto case_4___0;
  } else {

  }
#line 178
  if (4UL == 8UL) {
#line 178
    goto case_8___0;
  } else {

  }
#line 178
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
#line 178
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 178
  goto ldv_56727;
  case_2___1: /* CIL Label */ 
#line 178
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 178
  goto ldv_56727;
  case_4___0: /* CIL Label */ 
#line 178
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 178
  goto ldv_56727;
  case_8___0: /* CIL Label */ 
#line 178
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 178
  goto ldv_56727;
  switch_default___0: /* CIL Label */ 
  {
#line 178
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  ldv_56727: 
#line 178
  pscr_ret__ = pfo_ret_____0;
#line 178
  goto ldv_56723;
  case_4___1: /* CIL Label */ ;
  {
#line 178
  if (4UL == 1UL) {
#line 178
    goto case_1___2;
  } else {

  }
#line 178
  if (4UL == 2UL) {
#line 178
    goto case_2___2;
  } else {

  }
#line 178
  if (4UL == 4UL) {
#line 178
    goto case_4___2;
  } else {

  }
#line 178
  if (4UL == 8UL) {
#line 178
    goto case_8___1;
  } else {

  }
#line 178
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
#line 178
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 178
  goto ldv_56736;
  case_2___2: /* CIL Label */ 
#line 178
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 178
  goto ldv_56736;
  case_4___2: /* CIL Label */ 
#line 178
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 178
  goto ldv_56736;
  case_8___1: /* CIL Label */ 
#line 178
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 178
  goto ldv_56736;
  switch_default___1: /* CIL Label */ 
  {
#line 178
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  ldv_56736: 
#line 178
  pscr_ret__ = pfo_ret_____1;
#line 178
  goto ldv_56723;
  case_8___2: /* CIL Label */ ;
  {
#line 178
  if (4UL == 1UL) {
#line 178
    goto case_1___3;
  } else {

  }
#line 178
  if (4UL == 2UL) {
#line 178
    goto case_2___3;
  } else {

  }
#line 178
  if (4UL == 4UL) {
#line 178
    goto case_4___3;
  } else {

  }
#line 178
  if (4UL == 8UL) {
#line 178
    goto case_8___3;
  } else {

  }
#line 178
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
#line 178
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 178
  goto ldv_56745;
  case_2___3: /* CIL Label */ 
#line 178
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 178
  goto ldv_56745;
  case_4___3: /* CIL Label */ 
#line 178
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 178
  goto ldv_56745;
  case_8___3: /* CIL Label */ 
#line 178
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 178
  goto ldv_56745;
  switch_default___2: /* CIL Label */ 
  {
#line 178
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  ldv_56745: 
#line 178
  pscr_ret__ = pfo_ret_____2;
#line 178
  goto ldv_56723;
  switch_default___3: /* CIL Label */ 
  {
#line 178
  __bad_size_call_parameter();
  }
#line 178
  goto ldv_56723;
  switch_break: /* CIL Label */ ;
  }
  ldv_56723: 
#line 178
  ddp_pool = (struct ixgbe_fcoe_ddp_pool *)(__ptr + __per_cpu_offset[pscr_ret__]);
#line 179
  if ((unsigned long )ddp_pool->pool == (unsigned long )((struct dma_pool *)0)) {
#line 180
    if ((int )adapter->msg_enable & 1) {
      {
#line 180
      netdev_warn((struct net_device  const  *)adapter->netdev, "xid=0x%x no ddp pool for fcoe\n",
                  (int )xid);
      }
    } else {

    }
#line 181
    goto out_noddp;
  } else {

  }
  {
#line 185
  tmp___2 = dma_map_sg_attrs(& (adapter->pdev)->dev, sgl, (int )sgc, 2, (struct dma_attrs *)0);
#line 185
  dmacount = (unsigned int )tmp___2;
  }
#line 186
  if (dmacount == 0U) {
#line 187
    if ((int )adapter->msg_enable & 1) {
      {
#line 187
      netdev_err((struct net_device  const  *)adapter->netdev, "xid 0x%x DMA map error\n",
                 (int )xid);
      }
    } else {

    }
#line 188
    goto out_noddp;
  } else {

  }
  {
#line 192
  tmp___3 = dma_pool_alloc(ddp_pool->pool, 32U, & ddp->udp);
#line 192
  ddp->udl = (u64 *)tmp___3;
  }
#line 193
  if ((unsigned long )ddp->udl == (unsigned long )((u64 *)0ULL)) {
#line 194
    if ((int )adapter->msg_enable & 1) {
      {
#line 194
      netdev_err((struct net_device  const  *)adapter->netdev, "failed allocated ddp context\n");
      }
    } else {

    }
#line 195
    goto out_noddp_unmap;
  } else {

  }
#line 197
  ddp->pool = ddp_pool->pool;
#line 198
  ddp->sgl = sgl;
#line 199
  ddp->sgc = sgc;
#line 201
  j = 0U;
#line 202
  i = 0U;
#line 202
  sg = sgl;
#line 202
  goto ldv_56766;
  ldv_56765: 
#line 203
  addr = sg->dma_address;
#line 204
  len = sg->dma_length;
#line 205
  goto ldv_56763;
  ldv_56762: ;
#line 207
  if (j > 255U) {
#line 208
    ddp_pool->noddp = ddp_pool->noddp + 1ULL;
#line 209
    goto out_noddp_free;
  } else {

  }
#line 213
  thisoff = (unsigned int )addr & 4095U;
#line 214
  _min1 = 4096U - thisoff;
#line 214
  _min2 = len;
#line 214
  thislen = _min1 < _min2 ? _min1 : _min2;
#line 219
  if (j != 0U && thisoff != 0U) {
#line 220
    goto out_noddp_free;
  } else {

  }
#line 226
  if ((i != dmacount - 1U || thislen != len) && thislen + thisoff != 4096U) {
#line 228
    goto out_noddp_free;
  } else {

  }
#line 230
  *(ddp->udl + (unsigned long )j) = addr - (dma_addr_t )thisoff;
#line 232
  if (j == 0U) {
#line 233
    firstoff = thisoff;
  } else {

  }
#line 234
  len = len - thislen;
#line 235
  addr = addr + (dma_addr_t )thislen;
#line 236
  j = j + 1U;
  ldv_56763: ;
#line 205
  if (len != 0U) {
#line 207
    goto ldv_56762;
  } else {

  }
  {
#line 202
  i = i + 1U;
#line 202
  sg = sg_next(sg);
  }
  ldv_56766: ;
#line 202
  if (i < dmacount) {
#line 204
    goto ldv_56765;
  } else {

  }
#line 240
  lastsize = thisoff + thislen;
#line 246
  if (lastsize == 4096U) {
#line 247
    if (j > 255U) {
#line 248
      ddp_pool->noddp_ext_buff = ddp_pool->noddp_ext_buff + 1ULL;
#line 249
      goto out_noddp_free;
    } else {

    }
#line 252
    *(ddp->udl + (unsigned long )j) = fcoe->extra_ddp_buffer_dma;
#line 253
    j = j + 1U;
#line 254
    lastsize = 1U;
  } else {

  }
  {
#line 256
  __asm__  volatile   ("": : : "memory");
#line 256
  __preempt_count_sub(1);
#line 258
  fcbuff = 0U;
#line 259
  fcbuff = fcbuff | ((j << 8) & 65535U);
#line 260
  fcbuff = fcbuff | (firstoff << 16);
  }
#line 262
  if (target_mode != 0) {
#line 263
    fcbuff = fcbuff | 128U;
  } else {

  }
  {
#line 264
  fcbuff = fcbuff | 1U;
#line 266
  fcdmarw = (u32 )xid;
#line 267
  fcdmarw = fcdmarw | 16384U;
#line 268
  fcdmarw = fcdmarw | (lastsize << 16);
#line 270
  fcfltrw = (u32 )xid;
#line 271
  fcfltrw = fcfltrw | 16384U;
#line 274
  hw = & adapter->hw;
#line 275
  spin_lock_bh(& fcoe->lock);
  }
#line 279
  if (target_mode != 0) {
    {
#line 279
    tmp___4 = constant_test_bit(1L, (unsigned long const volatile   *)(& fcoe->mode));
    }
#line 279
    if (tmp___4 == 0) {
      {
#line 280
      set_bit(1L, (unsigned long volatile   *)(& fcoe->mode));
#line 281
      fcrxctl = ixgbe_read_reg(hw, 20736U);
#line 282
      fcrxctl = fcrxctl | 8U;
#line 283
      ixgbe_write_reg(hw, 20736U, fcrxctl);
      }
    } else {

    }
  } else {

  }
  {
#line 286
  ixgbe_write_reg(hw, 9232U, (u32 )ddp->udp);
#line 287
  ixgbe_write_reg(hw, 9236U, (u32 )(ddp->udp >> 32));
#line 288
  ixgbe_write_reg(hw, 9240U, fcbuff);
#line 289
  ixgbe_write_reg(hw, 9248U, fcdmarw);
#line 291
  ixgbe_write_reg(hw, 20952U, 0U);
#line 292
  ixgbe_write_reg(hw, 20744U, 1U);
#line 293
  ixgbe_write_reg(hw, 20752U, fcfltrw);
#line 295
  spin_unlock_bh(& fcoe->lock);
  }
#line 297
  return (1);
  out_noddp_free: 
  {
#line 300
  dma_pool_free(ddp->pool, (void *)ddp->udl, ddp->udp);
#line 301
  ixgbe_fcoe_clear_ddp(ddp);
  }
  out_noddp_unmap: 
  {
#line 304
  dma_unmap_sg_attrs(& (adapter->pdev)->dev, sgl, (int )sgc, 2, (struct dma_attrs *)0);
  }
  out_noddp: 
  {
#line 306
  __asm__  volatile   ("": : : "memory");
#line 306
  __preempt_count_sub(1);
  }
#line 307
  return (0);
}
}
#line 324 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_get(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                       unsigned int sgc ) 
{ 
  int tmp ;

  {
  {
#line 327
  tmp = ixgbe_fcoe_ddp_setup(netdev, (int )xid, sgl, sgc, 0);
  }
#line 327
  return (tmp);
}
}
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp_target(struct net_device *netdev , u16 xid , struct scatterlist *sgl ,
                          unsigned int sgc ) 
{ 
  int tmp ;

  {
  {
#line 348
  tmp = ixgbe_fcoe_ddp_setup(netdev, (int )xid, sgl, sgc, 1);
  }
#line 348
  return (tmp);
}
}
#line 363 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter , union ixgbe_adv_rx_desc *rx_desc ,
                   struct sk_buff *skb ) 
{ 
  int rc ;
  struct ixgbe_fcoe *fcoe ;
  struct ixgbe_fcoe_ddp *ddp ;
  struct fc_frame_header *fh ;
  struct fcoe_crc_eof *crc ;
  __le32 fcerr ;
  __le32 tmp ;
  __le32 ddp_err ;
  u32 fctl ;
  u16 xid ;
  struct ethhdr *tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __le32 tmp___3 ;
  unsigned char *tmp___4 ;

  {
  {
#line 367
  rc = -22;
#line 372
  tmp = ixgbe_test_staterr(rx_desc, 7340032U);
#line 372
  fcerr = tmp;
  }
#line 377
  if (fcerr == 1048576U) {
#line 378
    skb->ip_summed = 0U;
  } else {
#line 380
    skb->ip_summed = 1U;
  }
  {
#line 382
  tmp___0 = eth_hdr((struct sk_buff  const  *)skb);
  }
#line 382
  if ((unsigned int )tmp___0->h_proto == 129U) {
#line 383
    fh = (struct fc_frame_header *)skb->data + 18U;
  } else {
#line 386
    fh = (struct fc_frame_header *)skb->data + 14U;
  }
  {
#line 389
  fctl = ntoh24((u8 const   *)(& fh->fh_f_ctl));
  }
#line 390
  if ((fctl & 8388608U) != 0U) {
    {
#line 391
    tmp___1 = __fswab16((int )fh->fh_ox_id);
#line 391
    xid = tmp___1;
    }
  } else {
    {
#line 393
    tmp___2 = __fswab16((int )fh->fh_rx_id);
#line 393
    xid = tmp___2;
    }
  }
#line 395
  if ((unsigned int )xid > 511U) {
#line 396
    goto ddp_out;
  } else {

  }
#line 398
  fcoe = & adapter->fcoe;
#line 399
  ddp = (struct ixgbe_fcoe_ddp *)(& fcoe->ddp) + (unsigned long )xid;
#line 400
  if ((unsigned long )ddp->udl == (unsigned long )((u64 *)0ULL)) {
#line 401
    goto ddp_out;
  } else {

  }
  {
#line 403
  ddp_err = ixgbe_test_staterr(rx_desc, 2154823680U);
  }
#line 405
  if (ddp_err != 0U) {
#line 406
    goto ddp_out;
  } else {

  }
  {
#line 408
  tmp___3 = ixgbe_test_staterr(rx_desc, 48U);
  }
  {
#line 410
  if (tmp___3 == 48U) {
#line 410
    goto case_48;
  } else {

  }
#line 416
  if (tmp___3 == 32U) {
#line 416
    goto case_32;
  } else {

  }
#line 424
  if (tmp___3 == 16U) {
#line 424
    goto case_16;
  } else {

  }
#line 431
  if (tmp___3 == 0U) {
#line 431
    goto case_0;
  } else {

  }
#line 432
  goto switch_default;
  case_48: /* CIL Label */ 
#line 412
  ddp->len = (int )rx_desc->wb.lower.hi_dword.rss;
#line 413
  rc = 0;
#line 414
  goto ldv_56796;
  case_32: /* CIL Label */ 
  {
#line 417
  dma_unmap_sg_attrs(& (adapter->pdev)->dev, ddp->sgl, (int )ddp->sgc, 2, (struct dma_attrs *)0);
#line 419
  ddp->err = ddp_err;
#line 420
  ddp->sgl = (struct scatterlist *)0;
#line 421
  ddp->sgc = 0U;
  }
  case_16: /* CIL Label */ 
#line 426
  ddp->len = (int )rx_desc->wb.lower.hi_dword.rss;
#line 427
  if (ddp->len != 0) {
#line 428
    rc = ddp->len;
  } else {

  }
#line 429
  goto ldv_56796;
  case_0: /* CIL Label */ ;
  switch_default: /* CIL Label */ ;
#line 433
  goto ldv_56796;
  switch_break: /* CIL Label */ ;
  }
  ldv_56796: ;
#line 443
  if ((unsigned int )fh->fh_r_ctl == 1U && (fctl & 524288U) != 0U) {
    {
#line 445
    skb_linearize(skb);
#line 446
    tmp___4 = skb_put(skb, 8U);
#line 446
    crc = (struct fcoe_crc_eof *)tmp___4;
#line 447
    crc->fcoe_eof = 66U;
    }
  } else {

  }
  ddp_out: ;
#line 450
  return (rc);
}
}
#line 463 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fso(struct ixgbe_ring *tx_ring , struct ixgbe_tx_buffer *first , u8 *hdr_len ) 
{ 
  struct sk_buff *skb ;
  struct fc_frame_header *fh ;
  u32 vlan_macip_lens ;
  u32 fcoe_sof_eof ;
  u32 mss_l4len_idx ;
  u8 sof ;
  u8 eof ;
  unsigned char *tmp ;
  bool tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  bool tmp___3 ;
  unsigned char *tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  bool tmp___8 ;
  unsigned char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 467
  skb = first->skb;
#line 470
  fcoe_sof_eof = 0U;
#line 474
  tmp___0 = skb_is_gso((struct sk_buff  const  *)skb);
  }
#line 474
  if ((int )tmp___0) {
    {
#line 474
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
    }
#line 474
    if ((unsigned int )((struct skb_shared_info *)tmp___1)->gso_type != 32U) {
      {
#line 475
      tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 475
      dev_err((struct device  const  *)tx_ring->dev, "Wrong gso type %d:expecting SKB_GSO_FCOE\n",
              (int )((struct skb_shared_info *)tmp)->gso_type);
      }
#line 477
      return (-22);
    } else {

    }
  } else {

  }
  {
#line 481
  skb_set_network_header(skb, (int const   )skb->mac_len);
#line 482
  skb_set_transport_header(skb, (int const   )((unsigned int )skb->mac_len + 14U));
#line 486
  tmp___2 = skb_network_header((struct sk_buff  const  *)skb);
#line 486
  sof = ((struct fcoe_hdr *)tmp___2)->fcoe_sof;
  }
  {
#line 488
  if ((int )sof == 45) {
#line 488
    goto case_45;
  } else {

  }
#line 491
  if ((int )sof == 46) {
#line 491
    goto case_46;
  } else {

  }
#line 495
  if ((int )sof == 53) {
#line 495
    goto case_53;
  } else {

  }
#line 497
  if ((int )sof == 54) {
#line 497
    goto case_54;
  } else {

  }
#line 500
  goto switch_default;
  case_45: /* CIL Label */ 
#line 489
  fcoe_sof_eof = 32768U;
#line 490
  goto ldv_56814;
  case_46: /* CIL Label */ 
#line 492
  fcoe_sof_eof = 36864U;
#line 494
  goto ldv_56814;
  case_53: /* CIL Label */ ;
#line 496
  goto ldv_56814;
  case_54: /* CIL Label */ 
#line 498
  fcoe_sof_eof = 4096U;
#line 499
  goto ldv_56814;
  switch_default: /* CIL Label */ 
  {
#line 501
  dev_warn((struct device  const  *)tx_ring->dev, "unknown sof = 0x%x\n", (int )sof);
  }
#line 502
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_56814: 
  {
#line 506
  skb_copy_bits((struct sk_buff  const  *)skb, (int )(skb->len - 4U), (void *)(& eof),
                1);
  }
  {
#line 509
  if ((int )eof == 65) {
#line 509
    goto case_65;
  } else {

  }
#line 512
  if ((int )eof == 66) {
#line 512
    goto case_66;
  } else {

  }
#line 520
  if ((int )eof == 73) {
#line 520
    goto case_73;
  } else {

  }
#line 523
  if ((int )eof == 80) {
#line 523
    goto case_80;
  } else {

  }
#line 526
  goto switch_default___0;
  case_65: /* CIL Label */ 
#line 510
  fcoe_sof_eof = fcoe_sof_eof;
#line 511
  goto ldv_56820;
  case_66: /* CIL Label */ 
  {
#line 514
  tmp___3 = skb_is_gso((struct sk_buff  const  *)skb);
  }
#line 514
  if ((int )tmp___3) {
#line 515
    fcoe_sof_eof = fcoe_sof_eof | 16384U;
  } else {
#line 518
    fcoe_sof_eof = fcoe_sof_eof | 1024U;
  }
#line 519
  goto ldv_56820;
  case_73: /* CIL Label */ 
#line 521
  fcoe_sof_eof = fcoe_sof_eof | 2048U;
#line 522
  goto ldv_56820;
  case_80: /* CIL Label */ 
#line 524
  fcoe_sof_eof = fcoe_sof_eof | 3072U;
#line 525
  goto ldv_56820;
  switch_default___0: /* CIL Label */ 
  {
#line 527
  dev_warn((struct device  const  *)tx_ring->dev, "unknown eof = 0x%x\n", (int )eof);
  }
#line 528
  return (-22);
  switch_break___0: /* CIL Label */ ;
  }
  ldv_56820: 
  {
#line 532
  tmp___4 = skb_transport_header((struct sk_buff  const  *)skb);
#line 532
  fh = (struct fc_frame_header *)tmp___4;
  }
#line 533
  if (((int )fh->fh_f_ctl[2] & 8) != 0) {
#line 534
    fcoe_sof_eof = fcoe_sof_eof | 8192U;
  } else {

  }
  {
#line 537
  *hdr_len = 8U;
#line 540
  tmp___8 = skb_is_gso((struct sk_buff  const  *)skb);
  }
#line 540
  if ((int )tmp___8) {
    {
#line 541
    tmp___5 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 541
    *hdr_len = (unsigned int )((int )*hdr_len + (int )((u8 )tmp___5)) + 24U;
#line 544
    tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 544
    tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 544
    first->gso_segs = (unsigned short )((((skb->len - (unsigned int )*hdr_len) + (unsigned int )((struct skb_shared_info *)tmp___6)->gso_size) - 1U) / (unsigned int )((struct skb_shared_info *)tmp___7)->gso_size);
#line 546
    first->bytecount = first->bytecount + (unsigned int )(((int )first->gso_segs + -1) * (int )*hdr_len);
#line 547
    first->tx_flags = first->tx_flags | 2U;
    }
  } else {

  }
  {
#line 551
  first->tx_flags = first->tx_flags | 136U;
#line 554
  tmp___9 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 554
  mss_l4len_idx = (u32 )((int )((struct skb_shared_info *)tmp___9)->gso_size << 16);
#line 557
  tmp___10 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 557
  vlan_macip_lens = (u32 )tmp___10 + 24U;
#line 559
  tmp___11 = skb_transport_offset((struct sk_buff  const  *)skb);
#line 559
  vlan_macip_lens = vlan_macip_lens | (u32 )((tmp___11 + -4) << 9);
#line 561
  vlan_macip_lens = vlan_macip_lens | (first->tx_flags & 4294901760U);
#line 564
  ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, fcoe_sof_eof, 32768U, mss_l4len_idx);
  }
#line 567
  return (0);
}
}
#line 570 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static void ixgbe_fcoe_dma_pool_free(struct ixgbe_fcoe *fcoe , unsigned int cpu ) 
{ 
  struct ixgbe_fcoe_ddp_pool *ddp_pool ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
#line 574
  __vpp_verify = (void const   *)0;
#line 574
  __asm__  ("": "=r" (__ptr): "0" (fcoe->ddp_pool));
#line 574
  ddp_pool = (struct ixgbe_fcoe_ddp_pool *)(__ptr + __per_cpu_offset[cpu]);
#line 575
  if ((unsigned long )ddp_pool->pool != (unsigned long )((struct dma_pool *)0)) {
    {
#line 576
    dma_pool_destroy(ddp_pool->pool);
    }
  } else {

  }
#line 577
  ddp_pool->pool = (struct dma_pool *)0;
#line 578
  return;
}
}
#line 580 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_dma_pool_alloc(struct ixgbe_fcoe *fcoe , struct device *dev ,
                                     unsigned int cpu ) 
{ 
  struct ixgbe_fcoe_ddp_pool *ddp_pool ;
  struct dma_pool *pool ;
  char pool_name[32U] ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;

  {
  {
#line 588
  snprintf((char *)(& pool_name), 32UL, "ixgbe_fcoe_ddp_%d", cpu);
#line 590
  pool = dma_pool_create((char const   *)(& pool_name), dev, 2048UL, 16UL, 4096UL);
  }
#line 592
  if ((unsigned long )pool == (unsigned long )((struct dma_pool *)0)) {
#line 593
    return (-12);
  } else {

  }
#line 595
  __vpp_verify = (void const   *)0;
#line 595
  __asm__  ("": "=r" (__ptr): "0" (fcoe->ddp_pool));
#line 595
  ddp_pool = (struct ixgbe_fcoe_ddp_pool *)(__ptr + __per_cpu_offset[cpu]);
#line 596
  ddp_pool->pool = pool;
#line 597
  ddp_pool->noddp = 0ULL;
#line 598
  ddp_pool->noddp_ext_buff = 0ULL;
#line 600
  return (0);
}
}
#line 611 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_ring_feature *fcoe ;
  struct ixgbe_hw *hw ;
  int i ;
  int fcoe_q ;
  int fcoe_i ;
  u32 etqf ;

  {
#line 613
  fcoe = (struct ixgbe_ring_feature *)(& adapter->ring_feature) + 4UL;
#line 614
  hw = & adapter->hw;
#line 619
  if (((adapter->netdev)->features & 134217728ULL) == 0ULL) {
#line 620
    return;
  } else {

  }
#line 623
  etqf = 2281736454U;
#line 624
  if ((adapter->flags & 8388608U) != 0U) {
#line 625
    etqf = etqf | 67108864U;
#line 626
    etqf = etqf | (u32 )((int )adapter->ring_feature[1].offset << 20);
  } else {

  }
  {
#line 628
  ixgbe_write_reg(hw, 20784U, etqf);
#line 629
  ixgbe_write_reg(hw, 60424U, 0U);
  }
#line 632
  if ((adapter->flags & 2097152U) == 0U) {
#line 633
    return;
  } else {

  }
#line 636
  i = 0;
#line 636
  goto ldv_56856;
  ldv_56855: 
  {
#line 637
  fcoe_i = (int )fcoe->offset + i % (int )fcoe->indices;
#line 638
  fcoe_i = fcoe_i & 127;
#line 639
  fcoe_q = (int )(adapter->rx_ring[fcoe_i])->reg_idx;
#line 640
  ixgbe_write_reg(hw, (u32 )((i + 15172) * 4), (u32 )fcoe_q);
#line 636
  i = i + 1;
  }
  ldv_56856: ;
#line 636
  if (i <= 7) {
#line 638
    goto ldv_56855;
  } else {

  }
  {
#line 642
  ixgbe_write_reg(hw, 60672U, 1U);
#line 645
  etqf = 2147518740U;
  }
#line 646
  if ((adapter->flags & 8388608U) != 0U) {
#line 647
    etqf = etqf | 67108864U;
#line 648
    etqf = etqf | (u32 )((int )adapter->ring_feature[1].offset << 20);
  } else {

  }
  {
#line 650
  ixgbe_write_reg(hw, 20792U, etqf);
#line 653
  fcoe_q = (int )(adapter->rx_ring[(int )fcoe->offset])->reg_idx;
#line 654
  ixgbe_write_reg(hw, 60432U, (unsigned int )(fcoe_q << 16) | 2147483648U);
#line 659
  ixgbe_write_reg(hw, 20736U, 128U);
  }
#line 660
  return;
}
}
#line 672 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_fcoe *fcoe ;
  int cpu ;
  int i ;
  unsigned int tmp ;

  {
#line 674
  fcoe = & adapter->fcoe;
#line 678
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 679
    return;
  } else {

  }
#line 681
  i = 0;
#line 681
  goto ldv_56865;
  ldv_56864: 
  {
#line 682
  ixgbe_fcoe_ddp_put(adapter->netdev, (int )((u16 )i));
#line 681
  i = i + 1;
  }
  ldv_56865: ;
#line 681
  if (i <= 511) {
#line 683
    goto ldv_56864;
  } else {

  }
#line 684
  cpu = -1;
#line 684
  goto ldv_56868;
  ldv_56867: 
  {
#line 685
  ixgbe_fcoe_dma_pool_free(fcoe, (unsigned int )cpu);
  }
  ldv_56868: 
  {
#line 684
  tmp = cpumask_next(cpu, cpu_possible_mask);
#line 684
  cpu = (int )tmp;
  }
#line 684
  if (cpu < nr_cpu_ids) {
#line 686
    goto ldv_56867;
  } else {

  }
  {
#line 687
  dma_unmap_single_attrs(& (adapter->pdev)->dev, fcoe->extra_ddp_buffer_dma, 4096UL,
                         2, (struct dma_attrs *)0);
#line 691
  kfree((void const   *)fcoe->extra_ddp_buffer);
#line 693
  fcoe->extra_ddp_buffer = (void *)0;
#line 694
  fcoe->extra_ddp_buffer_dma = 0ULL;
  }
#line 695
  return;
}
}
#line 705 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_fcoe *fcoe ;
  struct device *dev ;
  void *buffer ;
  dma_addr_t dma ;
  unsigned int cpu ;
  int tmp ;
  int err ;
  int tmp___0 ;

  {
#line 707
  fcoe = & adapter->fcoe;
#line 708
  dev = & (adapter->pdev)->dev;
#line 714
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 715
    return (0);
  } else {

  }
  {
#line 718
  buffer = kmalloc(4096UL, 32U);
  }
#line 719
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 720
    return (-12);
  } else {

  }
  {
#line 722
  dma = dma_map_single_attrs(dev, buffer, 4096UL, 2, (struct dma_attrs *)0);
#line 723
  tmp = dma_mapping_error(dev, dma);
  }
#line 723
  if (tmp != 0) {
#line 724
    if ((int )adapter->msg_enable & 1) {
      {
#line 724
      netdev_err((struct net_device  const  *)adapter->netdev, "failed to map extra DDP buffer\n");
      }
    } else {

    }
    {
#line 725
    kfree((void const   *)buffer);
    }
#line 726
    return (-12);
  } else {

  }
#line 729
  fcoe->extra_ddp_buffer = buffer;
#line 730
  fcoe->extra_ddp_buffer_dma = dma;
#line 733
  cpu = 4294967295U;
#line 733
  goto ldv_56879;
  ldv_56880: 
  {
#line 734
  tmp___0 = ixgbe_fcoe_dma_pool_alloc(fcoe, dev, cpu);
#line 734
  err = tmp___0;
  }
#line 735
  if (err == 0) {
#line 736
    goto ldv_56879;
  } else {

  }
#line 738
  if ((int )adapter->msg_enable & 1) {
    {
#line 738
    netdev_err((struct net_device  const  *)adapter->netdev, "failed to alloc DDP pool on cpu:%d\n",
               cpu);
    }
  } else {

  }
  {
#line 739
  ixgbe_free_fcoe_ddp_resources(adapter);
  }
#line 740
  return (-12);
  ldv_56879: 
  {
#line 733
  cpu = cpumask_next((int )cpu, cpu_possible_mask);
  }
#line 733
  if (cpu < (unsigned int )nr_cpu_ids) {
#line 735
    goto ldv_56880;
  } else {

  }

#line 743
  return (0);
}
}
#line 746 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_fcoe *fcoe ;
  void *tmp ;

  {
#line 748
  fcoe = & adapter->fcoe;
#line 750
  if ((adapter->flags & 1048576U) == 0U) {
#line 751
    return (-22);
  } else {

  }
  {
#line 753
  tmp = __alloc_percpu(24UL, 8UL);
#line 753
  fcoe->ddp_pool = (struct ixgbe_fcoe_ddp_pool *)tmp;
  }
#line 755
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 756
    if ((int )adapter->msg_enable & 1) {
      {
#line 756
      netdev_err((struct net_device  const  *)adapter->netdev, "failed to allocate percpu DDP resources\n");
      }
    } else {

    }
#line 757
    return (-12);
  } else {

  }
#line 760
  (adapter->netdev)->fcoe_ddp_xid = 511U;
#line 762
  return (0);
}
}
#line 765 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
static void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter ) 
{ 
  struct ixgbe_fcoe *fcoe ;

  {
#line 767
  fcoe = & adapter->fcoe;
#line 769
  (adapter->netdev)->fcoe_ddp_xid = 0U;
#line 771
  if ((unsigned long )fcoe->ddp_pool == (unsigned long )((struct ixgbe_fcoe_ddp_pool *)0)) {
#line 772
    return;
  } else {

  }
  {
#line 774
  free_percpu((void *)fcoe->ddp_pool);
#line 775
  fcoe->ddp_pool = (struct ixgbe_fcoe_ddp_pool *)0;
  }
#line 776
  return;
}
}
#line 786 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_enable(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_fcoe *fcoe ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 788
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 788
  adapter = (struct ixgbe_adapter *)tmp;
#line 789
  fcoe = & adapter->fcoe;
#line 791
  atomic_inc(& fcoe->refcnt);
  }
#line 793
  if ((adapter->flags & 1048576U) == 0U) {
#line 794
    return (-22);
  } else {

  }
#line 796
  if ((adapter->flags & 2097152U) != 0U) {
#line 797
    return (-22);
  } else {

  }
#line 799
  if ((int )adapter->msg_enable & 1) {
    {
#line 799
    netdev_info((struct net_device  const  *)adapter->netdev, "Enabling FCoE offload features.\n");
    }
  } else {

  }
#line 801
  if ((adapter->flags & 8388608U) != 0U) {
#line 802
    if (((int )adapter->msg_enable & 2) != 0) {
      {
#line 802
      netdev_warn((struct net_device  const  *)adapter->netdev, "Enabling FCoE on PF will disable legacy VFs\n");
      }
    } else {

    }
  } else {

  }
  {
#line 804
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 804
  if ((int )tmp___0) {
    {
#line 805
    (*((netdev->netdev_ops)->ndo_stop))(netdev);
    }
  } else {

  }
  {
#line 808
  ixgbe_fcoe_ddp_enable(adapter);
#line 811
  adapter->flags = adapter->flags | 2097152U;
#line 812
  netdev->features = netdev->features | 536870912ULL;
#line 813
  netdev_features_change(netdev);
#line 816
  ixgbe_clear_interrupt_scheme(adapter);
#line 817
  ixgbe_init_interrupt_scheme(adapter);
#line 819
  tmp___1 = netif_running((struct net_device  const  *)netdev);
  }
#line 819
  if ((int )tmp___1) {
    {
#line 820
    (*((netdev->netdev_ops)->ndo_open))(netdev);
    }
  } else {

  }
#line 822
  return (0);
}
}
#line 833 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_disable(struct net_device *netdev ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 835
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 835
  adapter = (struct ixgbe_adapter *)tmp;
#line 837
  tmp___0 = atomic_dec_and_test(& adapter->fcoe.refcnt);
  }
#line 837
  if (tmp___0 == 0) {
#line 838
    return (-22);
  } else {

  }
#line 840
  if ((adapter->flags & 2097152U) == 0U) {
#line 841
    return (-22);
  } else {

  }
#line 843
  if ((int )adapter->msg_enable & 1) {
    {
#line 843
    netdev_info((struct net_device  const  *)adapter->netdev, "Disabling FCoE offload features.\n");
    }
  } else {

  }
  {
#line 844
  tmp___1 = netif_running((struct net_device  const  *)netdev);
  }
#line 844
  if ((int )tmp___1) {
    {
#line 845
    (*((netdev->netdev_ops)->ndo_stop))(netdev);
    }
  } else {

  }
  {
#line 848
  ixgbe_fcoe_ddp_disable(adapter);
#line 851
  adapter->flags = adapter->flags & 4292870143U;
#line 852
  netdev->features = netdev->features & 0xffffffffdfffffffULL;
#line 854
  netdev_features_change(netdev);
#line 857
  ixgbe_clear_interrupt_scheme(adapter);
#line 858
  ixgbe_init_interrupt_scheme(adapter);
#line 860
  tmp___2 = netif_running((struct net_device  const  *)netdev);
  }
#line 860
  if ((int )tmp___2) {
    {
#line 861
    (*((netdev->netdev_ops)->ndo_open))(netdev);
    }
  } else {

  }
#line 863
  return (0);
}
}
#line 878 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_get_wwn(struct net_device *netdev , u64 *wwn , int type ) 
{ 
  int rc ;
  u16 prefix ;
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_mac_info *mac ;
  bool tmp___0 ;

  {
  {
#line 880
  rc = -22;
#line 881
  prefix = 65535U;
#line 882
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 882
  adapter = (struct ixgbe_adapter *)tmp;
#line 883
  mac = & adapter->hw.mac;
  }
  {
#line 886
  if (type == 0) {
#line 886
    goto case_0;
  } else {

  }
#line 889
  if (type == 1) {
#line 889
    goto case_1;
  } else {

  }
#line 892
  goto switch_default;
  case_0: /* CIL Label */ 
#line 887
  prefix = mac->wwnn_prefix;
#line 888
  goto ldv_56909;
  case_1: /* CIL Label */ 
#line 890
  prefix = mac->wwpn_prefix;
#line 891
  goto ldv_56909;
  switch_default: /* CIL Label */ ;
#line 893
  goto ldv_56909;
  switch_break: /* CIL Label */ ;
  }
  ldv_56909: ;
#line 896
  if ((unsigned int )prefix != 65535U) {
    {
#line 896
    tmp___0 = is_valid_ether_addr((u8 const   *)(& mac->san_addr));
    }
#line 896
    if ((int )tmp___0) {
#line 898
      *wwn = (((((((unsigned long long )prefix << 48) | ((unsigned long long )mac->san_addr[0] << 40)) | ((unsigned long long )mac->san_addr[1] << 32)) | ((unsigned long long )mac->san_addr[2] << 24)) | ((unsigned long long )mac->san_addr[3] << 16)) | ((unsigned long long )mac->san_addr[4] << 8)) | (unsigned long long )mac->san_addr[5];
#line 905
      rc = 0;
    } else {

    }
  } else {

  }
#line 907
  return (rc);
}
}
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
int ixgbe_fcoe_get_hbainfo(struct net_device *netdev , struct netdev_fcoe_hbainfo *info ) 
{ 
  struct ixgbe_adapter *adapter ;
  void *tmp ;
  struct ixgbe_hw *hw ;
  int i ;
  int pos ;
  u8 buf[8U] ;

  {
  {
#line 922
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 922
  adapter = (struct ixgbe_adapter *)tmp;
#line 923
  hw = & adapter->hw;
  }
#line 927
  if ((unsigned long )info == (unsigned long )((struct netdev_fcoe_hbainfo *)0)) {
#line 928
    return (-22);
  } else {

  }
#line 931
  if ((unsigned int )hw->mac.type - 2U > 1U) {
#line 933
    return (-22);
  } else {

  }
  {
#line 936
  snprintf((char *)(& info->manufacturer), 64UL, "Intel Corporation");
#line 942
  pos = pci_find_ext_capability(adapter->pdev, 3);
  }
#line 943
  if (pos != 0) {
#line 944
    pos = pos + 4;
#line 945
    i = 0;
#line 945
    goto ldv_56922;
    ldv_56921: 
    {
#line 946
    pci_read_config_byte((struct pci_dev  const  *)adapter->pdev, pos + i, (u8 *)(& buf) + (unsigned long )i);
#line 945
    i = i + 1;
    }
    ldv_56922: ;
#line 945
    if (i <= 7) {
#line 947
      goto ldv_56921;
    } else {

    }
    {
#line 948
    snprintf((char *)(& info->serial_number), 64UL, "%02X%02X%02X%02X%02X%02X%02X%02X",
             (int )buf[7], (int )buf[6], (int )buf[5], (int )buf[4], (int )buf[3],
             (int )buf[2], (int )buf[1], (int )buf[0]);
    }
  } else {
    {
#line 953
    snprintf((char *)(& info->serial_number), 64UL, "Unknown");
    }
  }
  {
#line 957
  snprintf((char *)(& info->hardware_version), 64UL, "Rev %d", (int )hw->revision_id);
#line 961
  snprintf((char *)(& info->driver_version), 64UL, "%s v%s", (char *)(& ixgbe_driver_name),
           (char const   *)(& ixgbe_driver_version));
#line 967
  snprintf((char *)(& info->firmware_version), 64UL, "0x%08x", ((int )adapter->eeprom_verh << 16) | (int )adapter->eeprom_verl);
  }
#line 974
  if ((unsigned int )hw->mac.type == 2U) {
    {
#line 975
    snprintf((char *)(& info->model), 256UL, "Intel 82599");
    }
  } else {
    {
#line 979
    snprintf((char *)(& info->model), 256UL, "Intel X540");
    }
  }
  {
#line 985
  snprintf((char *)(& info->model_description), 256UL, "%s", (char *)(& ixgbe_default_device_descr));
  }
#line 990
  return (0);
}
}
#line 999 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/lkbce/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c"
u8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter ) 
{ 
  int tmp ;

  {
  {
#line 1002
  tmp = netdev_get_prio_tc_map((struct net_device  const  *)adapter->netdev, (u32 )adapter->fcoe.up);
  }
#line 1002
  return ((u8 )tmp);
}
}
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 28
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 29
    return ((dev->p)->driver_data);
  } else {

  }
#line 30
  return ((void *)0);
}
}
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 41
  tmp = ldv_xzalloc(8UL);
#line 41
  dev->p = (struct device_private *)tmp;
#line 42
  (dev->p)->driver_data = data;
  }
#line 43
  return (0);
}
}
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 2200UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)master + 1U);
  }
#line 34
  return (master);
}
}
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 23
  ldv_assume(val <= 0);
  }
#line 24
  return (val);
}
}
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 45
  return (tmp);
}
}
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/mm/kzalloc.c"
extern void ldv_check_alloc_flags(gfp_t  ) ;
#line 22
extern void ldv_after_alloc(void * ) ;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/linux/mm/kzalloc.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 28
  ldv_check_alloc_flags(flags);
#line 29
  res = ldv_zalloc(size);
#line 30
  ldv_after_alloc(res);
  }
#line 32
  return (res);
}
}
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/common.h"
extern void ldv_assert(char const   * , int  ) ;
#line 45
void __builtin_trap(void) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/common.c"
void ldv_assume(int expression ) 
{ 


  {
#line 25
  if (expression == 0) {
    ldv_assume_label: ;
#line 29
    goto ldv_assume_label;
  } else {

  }
#line 31
  return;
}
}
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/common.c"
void ldv_stop(void) 
{ 


  {
  ldv_stop_label: ;
#line 36
  goto ldv_stop_label;
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/common.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 45
  return (exp);
}
}
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/common.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 56
  ldv_assert("", 0);
  }
#line 57
  return;
}
}
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 30
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 37
extern void *external_allocated_data(void) ;
#line 39
void *ldv_malloc_unknown_size(void) ;
#line 40
void *ldv_calloc_unknown_size(void) ;
#line 41
void *ldv_zalloc_unknown_size(void) ;
#line 47
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 26
extern void *calloc(size_t  , size_t  ) ;
#line 27
extern void free(void * ) ;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp___1 = ldv_undef_int();
  }
#line 32
  if (tmp___1 != 0) {
    {
#line 33
    tmp = malloc(size);
#line 33
    res = tmp;
#line 34
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    ldv_assume(tmp___0 == 0L);
    }
#line 36
    return (res);
  } else {
#line 39
    return ((void *)0);
  }
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 48
    tmp___0 = ldv_is_err((void const   *)res);
#line 48
    ldv_assume(tmp___0 == 0L);
    }
#line 49
    return (res);
  } else {
#line 52
    return ((void *)0);
  }
}
}
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = ldv_calloc(1UL, size);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 63
  free(s);
  }
#line 64
  return;
}
}
#line 66 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 68
  tmp = malloc(size);
#line 68
  res = tmp;
#line 69
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
#line 70
  ldv_assume(tmp___0 == 0L);
  }
#line 71
  return (res);
}
}
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 76
  tmp = calloc(1UL, size);
#line 76
  res = tmp;
#line 77
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 78
  tmp___0 = ldv_is_err((void const   *)res);
#line 78
  ldv_assume(tmp___0 == 0L);
  }
#line 79
  return (res);
}
}
#line 82 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = ldv_undef_int();
  }
#line 84
  if (tmp___1 != 0) {
    {
#line 85
    tmp = external_allocated_data();
#line 85
    res = tmp;
#line 86
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 87
    tmp___0 = ldv_is_err((void const   *)res);
#line 87
    ldv_assume(tmp___0 == 0L);
    }
#line 88
    return (res);
  } else {
#line 91
    return ((void *)0);
  }
}
}
#line 95 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 97
  tmp___1 = ldv_undef_int();
  }
#line 97
  if (tmp___1 != 0) {
    {
#line 98
    tmp = external_allocated_data();
#line 98
    res = tmp;
#line 99
    memset(res, 0, 8UL);
#line 100
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 101
    tmp___0 = ldv_is_err((void const   *)res);
#line 101
    ldv_assume(tmp___0 == 0L);
    }
#line 102
    return (res);
  } else {
#line 105
    return ((void *)0);
  }
}
}
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 111
  tmp = ldv_calloc_unknown_size();
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 116
  tmp = external_allocated_data();
#line 116
  res = tmp;
#line 117
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 118
  tmp___0 = ldv_is_err((void const   *)res);
#line 118
  ldv_assume(tmp___0 == 0L);
  }
#line 119
  return (res);
}
}
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.h"
void *ldv_undef_ptr(void) ;
#line 24
unsigned long ldv_undef_ulong(void) ;
#line 27
int ldv_undef_int_negative(void) ;
#line 30
int ldv_undef_int_nonpositive(void) ;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern void *__VERIFIER_nondet_pointer(void) ;
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = __VERIFIER_nondet_int();
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = __VERIFIER_nondet_pointer();
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 49
  tmp = __VERIFIER_nondet_ulong();
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 54
  tmp = ldv_undef_int();
#line 54
  ret = tmp;
#line 55
  ldv_assume(ret < 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 61
  tmp = ldv_undef_int();
#line 61
  ret = tmp;
#line 62
  ldv_assume(ret <= 0);
  }
#line 63
  return (ret);
}
}
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/thread.h"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) ;
#line 35
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) ;
#line 38
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) ;
#line 41
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) ;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/thread.c"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) 
{ 


  {
#line 29
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
    {
#line 30
    (*function)(data);
    }
  } else {

  }
#line 31
  return (0);
}
}
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/thread.c"
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) 
{ 
  int i ;

  {
#line 39
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
#line 40
    i = 0;
#line 40
    goto ldv_1179;
    ldv_1178: 
    {
#line 41
    (*function)(data);
#line 40
    i = i + 1;
    }
    ldv_1179: ;
#line 40
    if (i < ldv_thread_set->number) {
#line 42
      goto ldv_1178;
    } else {

    }

  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/thread.c"
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/job/root/verifier/thread.c"
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) 
{ 


  {
#line 56
  return (0);
}
}
#line 1 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/rsg/models/clk1.bk.c"
void ldv_assert_linux_drivers_clk1__more_at_exit(int expr ) ;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/tr/linux/drivers/clk1.c"
int ldv_counter  =    0;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/tr/linux/drivers/clk1.c"
void ldv_clk_disable(struct clk *clk ) 
{ 


  {
#line 30
  ldv_counter = 0;
#line 31
  return;
}
}
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/tr/linux/drivers/clk1.c"
int ldv_clk_enable(void) 
{ 
  int retval ;
  int tmp ;

  {
  {
#line 36
  tmp = ldv_undef_int();
#line 36
  retval = tmp;
  }
#line 37
  if (retval == 0) {
#line 39
    ldv_counter = 1;
  } else {

  }
#line 41
  return (retval);
}
}
#line 44 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/avtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/tr/linux/drivers/clk1.c"
void ldv_check_final_state(void) 
{ 


  {
  {
#line 47
  ldv_assert_linux_drivers_clk1__more_at_exit(ldv_counter == 0);
  }
#line 48
  return;
}
}
#line 2 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/sbt/bug kind funcs.c"
extern void __VERIFIER_error(void) ;
#line 3 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/7cdfae59d3ac602223400f61d8829e28/klever-core-work-dir/076166e/linux-drivers-clk1/vtg/drivers/net/ethernet/intel/ixgbe/ixgbe.ko/linux:drivers:clk1/sbt/bug kind funcs.c"
void ldv_assert_linux_drivers_clk1__more_at_exit(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error();
    }
  } else {

  }
#line 6
  return;
}
}
