/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/types.h"
typedef __u16 __be16;
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/types.h"
typedef __u32 __be32;
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/types.h"
typedef __u16 __sum16;
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef unsigned short ushort;
#line 92 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef unsigned long ulong;
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 106 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __u8 uint8_t;
#line 108 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 157 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 158 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef u64 phys_addr_t;
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 177 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 177 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 182 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 182 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 188
struct hlist_node;
#line 188 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 192 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 203 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct device;
#line 103 "/home/debian/klever/addons/aspectator-0efea3f/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.0/include/stdarg.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/export.h"
struct module;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 243 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
#line 245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_12 pgd_t;
#line 333
struct page;
#line 333 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 341
struct file;
#line 354
struct seq_file;
#line 387
struct thread_struct;
#line 389
struct mm_struct;
#line 390
struct task_struct;
#line 391
struct cpumask;
#line 392 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 327
struct arch_spinlock;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_15 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/rwlock.h"
struct __anonstruct____missing_field_name_17 {
   u32 read ;
   s32 write ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/rwlock.h"
union __anonunion_arch_rwlock_t_16 {
   s64 lock ;
   struct __anonstruct____missing_field_name_17 __annonCompField8 ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/rwlock.h"
typedef union __anonunion_arch_rwlock_t_16 arch_rwlock_t;
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dynamic_debug.h"
struct net_device;
#line 376 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/printk.h"
struct file_operations;
#line 388
struct completion;
#line 416 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernel.h"
struct pid;
#line 686 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/list.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/current.h"
struct lockdep_map;
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_18 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_18 __annonCompField9 ;
};
#line 306 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 663 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 195 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/paravirt.h"
struct static_key;
#line 162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 294 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_23 {
   u64 rip ;
   u64 rdp ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_24 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_22 {
   struct __anonstruct____missing_field_name_23 __annonCompField13 ;
   struct __anonstruct____missing_field_name_24 __annonCompField14 ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_25 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_22 __annonCompField15 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_25 __annonCompField16 ;
};
#line 346 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 367 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 372 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 377 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct bndregs_struct {
   u64 bndregs[8U] ;
};
#line 381 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct bndcsr_struct {
   u64 cfg_reg_u ;
   u64 status_reg ;
};
#line 386 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2U] ;
   u64 reserved2[5U] ;
};
#line 392 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndregs_struct bndregs ;
   struct bndcsr_struct bndcsr ;
};
#line 401 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 456
struct kmem_cache;
#line 457
struct perf_event;
#line 458 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 2 ;
   unsigned int hardirqs_off : 1 ;
   unsigned int references : 11 ;
};
#line 537 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_29 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_28 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_29 __annonCompField18 ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_28 __annonCompField19 ;
};
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_30 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_30 rwlock_t;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rwlock_types.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 177
struct timespec;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/jump_label.h"
struct jump_entry;
#line 54
struct static_key_mod;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/jump_label.h"
struct static_key {
   atomic_t enabled ;
   struct jump_entry *entries ;
   struct static_key_mod *next ;
};
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 412 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock.h"
struct rw_semaphore;
#line 413 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock.h"
struct rw_semaphore {
   long count ;
   raw_spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
#line 155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rwsem.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 259 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_35 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 259 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_35 seqlock_t;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 223 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rcupdate.h"
struct notifier_block;
#line 1039 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rcupdate.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 323 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 388
struct tvec_base;
#line 389 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ktime.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 107 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/miscdevice.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 236 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ioport.h"
struct idr_layer {
   int prefix ;
   unsigned long bitmap[4U] ;
   struct idr_layer *ary[256U] ;
   int count ;
   int layer ;
   struct callback_head callback_head ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   int cur ;
   spinlock_t lock ;
};
#line 197 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 213 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct dentry;
#line 88
struct iattr;
#line 89
struct vm_area_struct;
#line 90
struct super_block;
#line 91
struct file_system_type;
#line 92
struct kernfs_open_node;
#line 93
struct kernfs_iattrs;
#line 109
struct kernfs_root;
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kernfs_node;
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 66
struct kernfs_ops;
#line 66 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
union __anonunion_u_36 {
   struct completion *completion ;
   struct kernfs_node *removed_list ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
union __anonunion____missing_field_name_37 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   union __anonunion_u_36 u ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_37 __annonCompField21 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kernfs_dir_ops {
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   struct ida ino_ida ;
   struct kernfs_dir_ops *dir_ops ;
};
#line 137
struct vm_operations_struct;
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 376
struct sock;
#line 377
struct kobject;
#line 378
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 384 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 83 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/highuid.h"
struct user_namespace;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uidgid.h"
struct __anonstruct_kuid_t_38 {
   uid_t val ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_38 kuid_t;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uidgid.h"
struct __anonstruct_kgid_t_39 {
   gid_t val ;
};
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_39 kgid_t;
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/stat.h"
struct bin_attribute;
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep : 1 ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 462 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kobject.h"
struct kset;
#line 50
struct kobj_type;
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
   unsigned int uevent_suppress : 1 ;
};
#line 112 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 144 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 219
struct klist_node;
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_40 {
   unsigned long bits[16U] ;
};
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_40 nodemask_t;
#line 522
struct path;
#line 523
struct inode;
#line 524 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 196
struct pinctrl;
#line 197
struct pinctrl_state;
#line 194 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 301
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 308
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 316
struct wakeup_source;
#line 527 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 534
struct dev_pm_qos;
#line 534 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int async_suspend : 1 ;
   bool is_prepared : 1 ;
   bool is_suspended : 1 ;
   bool ignore_children : 1 ;
   bool early_init : 1 ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path : 1 ;
   bool syscore : 1 ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned int disable_depth : 3 ;
   unsigned int idle_notification : 1 ;
   unsigned int request_pending : 1 ;
   unsigned int deferred_resume : 1 ;
   unsigned int run_wake : 1 ;
   unsigned int runtime_auto : 1 ;
   unsigned int no_callbacks : 1 ;
   unsigned int irq_safe : 1 ;
   unsigned int use_autosuspend : 1 ;
   unsigned int timer_autosuspends : 1 ;
   unsigned int memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   struct dev_pm_qos *qos ;
};
#line 591 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
};
#line 891 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mmzone.h"
struct ctl_table;
#line 172 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 133 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_105 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_105 mm_context_t;
#line 341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/clocksource.h"
struct device_node;
#line 1276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mmzone.h"
struct llist_node;
#line 64 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 419 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/gfp.h"
struct dma_map_ops;
#line 419 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct class;
#line 18
struct subsys_private;
#line 19
struct bus_type;
#line 20
struct iommu_ops;
#line 21
struct iommu_group;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct device_attribute;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 195
struct of_device_id;
#line 195
struct acpi_device_id;
#line 195 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 321
struct class_attribute;
#line 321 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 414 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 482 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 510 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 637 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 646
struct acpi_device;
#line 647 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 653
struct dma_coherent_mem;
#line 653 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled : 1 ;
   bool offline : 1 ;
};
#line 795 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active : 1 ;
   bool autosleep_enabled : 1 ;
};
#line 1200 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 50
enum dev_pm_qos_req_type {
    DEV_PM_QOS_LATENCY = 1,
    DEV_PM_QOS_FLAGS = 2
} ;
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm_qos.h"
union __anonunion_data_133 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_133 data ;
   struct device *dev ;
};
#line 64
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2
} ;
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 83 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 88 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints latency ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *latency_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 460 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rculist.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 54
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_136 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_137 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_135 {
   struct __anonstruct____missing_field_name_136 __annonCompField34 ;
   struct __anonstruct____missing_field_name_137 __annonCompField35 ;
};
#line 61
struct uprobe;
#line 61
struct return_instance;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_135 __annonCompField36 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
struct xol_area;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 129
struct address_space;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_138 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_140 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
struct __anonstruct____missing_field_name_144 {
   unsigned int inuse : 16 ;
   unsigned int objects : 15 ;
   unsigned int frozen : 1 ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_143 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_144 __annonCompField39 ;
   int units ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
struct __anonstruct____missing_field_name_142 {
   union __anonunion____missing_field_name_143 __annonCompField40 ;
   atomic_t _count ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_141 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_142 __annonCompField41 ;
   unsigned int active ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
struct __anonstruct____missing_field_name_139 {
   union __anonunion____missing_field_name_140 __annonCompField38 ;
   union __anonunion____missing_field_name_141 __annonCompField42 ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
struct __anonstruct____missing_field_name_146 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 130
struct slab;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_145 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_146 __annonCompField44 ;
   struct list_head list ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   pgtable_t pmd_huge_pte ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
union __anonunion____missing_field_name_147 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/uprobes.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_138 __annonCompField37 ;
   struct __anonstruct____missing_field_name_139 __annonCompField43 ;
   union __anonunion____missing_field_name_145 __annonCompField45 ;
   union __anonunion____missing_field_name_147 __annonCompField46 ;
   unsigned long debug_flags ;
};
#line 186 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
struct __anonstruct_linear_149 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
union __anonunion_shared_148 {
   struct __anonstruct_linear_149 linear ;
   struct list_head nonlinear ;
};
#line 238
struct anon_vma;
#line 238
struct mempolicy;
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   union __anonunion_shared_148 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 310 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 329 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 342
struct kioctx_table;
#line 343
struct linux_binfmt;
#line 343
struct mmu_notifier_mm;
#line 343 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
};
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   nodemask_t nodes_to_scan ;
   int nid ;
};
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 71
struct file_ra_state;
#line 72
struct user_struct;
#line 73
struct writeback_control;
#line 185 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
#line 210 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   int (*migrate)(struct vm_area_struct * , nodemask_t const   * , nodemask_t const   * ,
                  unsigned long  ) ;
   int (*remap_pages)(struct vm_area_struct * , unsigned long  , unsigned long  ,
                      unsigned long  ) ;
};
#line 2071 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dmaengine.h"
typedef s32 dma_cookie_t;
#line 1156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 18
struct cred;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/socket.h"
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct iovec *msg_iov ;
   __kernel_size_t msg_iovlen ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_151 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_151 sync_serial_settings;
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_152 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_152 te1_settings;
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_153 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_153 raw_hdlc_proto;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_154 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_154 fr_proto;
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_155 {
   unsigned int dlci ;
};
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_155 fr_proto_pvc;
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_156 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_156 fr_proto_pvc_info;
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_157 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_157 cisco_proto;
#line 95 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_158 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_158 ifs_ifsu ;
};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_159 {
   char ifrn_name[16U] ;
};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_160 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_159 ifr_ifrn ;
   union __anonunion_ifr_ifru_160 ifr_ifru ;
};
#line 91 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kdev_t.h"
struct hlist_bl_node;
#line 91 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kdev_t.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_163 {
   spinlock_t lock ;
   unsigned int count ;
};
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rculist_bl.h"
union __anonunion____missing_field_name_162 {
   struct __anonstruct____missing_field_name_163 __annonCompField47 ;
};
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_162 __annonCompField48 ;
};
#line 49 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockref.h"
struct nameidata;
#line 50
struct vfsmount;
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockref.h"
struct __anonstruct____missing_field_name_165 {
   u32 hash ;
   u32 len ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockref.h"
union __anonunion____missing_field_name_164 {
   struct __anonstruct____missing_field_name_165 __annonCompField49 ;
   u64 hash_len ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_164 __annonCompField50 ;
   unsigned char const   *name ;
};
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dcache.h"
union __anonunion_d_u_166 {
   struct list_head d_child ;
   struct callback_head d_rcu ;
};
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   union __anonunion_d_u_166 d_u ;
   struct list_head d_subdirs ;
   struct hlist_node d_alias ;
};
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 469 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/path.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_head list ;
   long nr_items ;
};
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   nodemask_t active_nodes ;
};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/radix-tree.h"
struct radix_tree_node;
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 381
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 388
struct pid_namespace;
#line 388 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/fs.h"
struct export_operations;
#line 58
struct kiocb;
#line 59
struct pipe_inode_info;
#line 60
struct poll_table_struct;
#line 61
struct kstatfs;
#line 62
struct swap_info_struct;
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 176 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/percpu_counter.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8U] ;
};
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/projid.h"
struct __anonstruct_kprojid_t_168 {
   projid_t val ;
};
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_168 kprojid_t;
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 152
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
union __anonunion____missing_field_name_169 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_169 __annonCompField51 ;
   enum quota_type type ;
};
#line 178 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 200
struct quota_format_type;
#line 201 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
#line 264 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 302 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_on_meta)(struct super_block * , int  , int  ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct fs_disk_quota * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
};
#line 333 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 379 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
union __anonunion_arg_171 {
   char *buf ;
   void *data ;
};
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_170 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_171 arg ;
   int error ;
};
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_170 read_descriptor_t;
#line 348 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  * , loff_t  ,
                        unsigned long  ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 408
struct backing_dev_info;
#line 409 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct rb_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   struct mutex i_mmap_mutex ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 430
struct request_queue;
#line 431
struct hd_struct;
#line 431
struct gendisk;
#line 431 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 503
struct posix_acl;
#line 504
struct inode_operations;
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_172 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_173 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 504
struct file_lock;
#line 504
struct cdev;
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_174 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 504 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_172 __annonCompField52 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_173 __annonCompField53 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   struct file_operations  const  *i_fop ;
   struct file_lock *i_flock ;
   struct address_space i_data ;
   struct dquot *i_dquot[2U] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_174 __annonCompField54 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   atomic_t i_readcount ;
   void *i_private ;
};
#line 740 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 748 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 771 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
union __anonunion_f_u_175 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 771 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_175 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
   unsigned long f_mnt_write_state ;
};
#line 909
struct files_struct;
#line 909 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
#line 910 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 915 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock ** , int  ) ;
};
#line 928
struct net;
#line 933
struct nlm_lockowner;
#line 934 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_177 {
   struct list_head link ;
   int state ;
};
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_176 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_177 afs ;
};
#line 19 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_176 fl_u ;
};
#line 1036 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1228 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1244
struct super_operations;
#line 1244
struct xattr_handler;
#line 1244
struct mtd_info;
#line 1244 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
};
#line 1474 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1512 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct dir_context {
   int (*actor)(void * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1517 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   int (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
#line 1600 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , int  ) ;
   long (*free_cached_objects)(struct super_block * , long  , int  ) ;
};
#line 1814 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 4 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_178 {
   unsigned long sig[1U] ;
};
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_178 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_180 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_181 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_183 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_184 {
   void *_addr ;
   short _addr_lsb ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_185 {
   long _band ;
   int _fd ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_186 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_179 {
   int _pad[28U] ;
   struct __anonstruct__kill_180 _kill ;
   struct __anonstruct__timer_181 _timer ;
   struct __anonstruct__rt_182 _rt ;
   struct __anonstruct__sigchld_183 _sigchld ;
   struct __anonstruct__sigfault_184 _sigfault ;
   struct __anonstruct__sigpoll_185 _sigpoll ;
   struct __anonstruct__sigsys_186 _sigsys ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_179 _sifields ;
};
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 251 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 265 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 463 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 835 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 836
struct ctl_table_root;
#line 837
struct ctl_table_header;
#line 838
struct ctl_dir;
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct __anonstruct____missing_field_name_190 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
union __anonunion____missing_field_name_189 {
   struct __anonstruct____missing_field_name_190 __annonCompField55 ;
   struct callback_head rcu ;
};
#line 124
struct ctl_table_set;
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_189 __annonCompField56 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 193
struct assoc_array_ptr;
#line 193 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sysctl.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_191 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_192 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
struct __anonstruct____missing_field_name_194 {
   struct key_type *type ;
   char *description ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_193 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_194 __annonCompField59 ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
union __anonunion_type_data_195 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
union __anonunion_payload_197 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_196 {
   union __anonunion_payload_197 payload ;
   struct assoc_array keys ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_191 __annonCompField57 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_192 __annonCompField58 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_193 __annonCompField60 ;
   union __anonunion_type_data_195 type_data ;
   union __anonunion____missing_field_name_196 __annonCompField61 ;
};
#line 345
struct audit_context;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 78 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct futex_pi_state;
#line 124
struct robust_list_head;
#line 125
struct bio_list;
#line 126
struct fs_struct;
#line 127
struct perf_event_context;
#line 128
struct blk_plug;
#line 180
struct cfs_rq;
#line 181
struct task_group;
#line 421 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 460 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 468 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 475 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 487 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 507 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 549
struct autogroup;
#line 550
struct tty_struct;
#line 550
struct taskstats;
#line 550
struct tty_audit_buf;
#line 550 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned int is_child_subreaper : 1 ;
   unsigned int has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 730 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 774
struct reclaim_state;
#line 775 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 790 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1004
struct uts_namespace;
#line 1005 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1013 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1025 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1060 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1091
struct rt_rq;
#line 1091 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1107 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   struct hrtimer dl_timer ;
};
#line 1162
struct mem_cgroup;
#line 1162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct memcg_batch_info {
   int do_batch ;
   struct mem_cgroup *memcg ;
   unsigned long nr_pages ;
   unsigned long memsw_nr_pages ;
};
#line 1569 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned int may_oom : 1 ;
};
#line 1576
struct sched_class;
#line 1576
struct css_set;
#line 1576
struct compat_robust_list_head;
#line 1576
struct numa_group;
#line 1576
struct ftrace_ret_stack;
#line 1576 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned int brk_randomized : 1 ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned int in_execve : 1 ;
   unsigned int in_iowait : 1 ;
   unsigned int no_new_privs : 1 ;
   unsigned int sched_reset_on_fork : 1 ;
   unsigned int sched_contributes_to_load : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct task_struct *pi_top_task ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   int numa_migrate_deferred ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long *numa_faults_buffer ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_batch_info memcg_batch ;
   unsigned int memcg_kmem_skip_account ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
};
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 273 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 277 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 98 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/random.h"
enum ldv_21628 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/net.h"
typedef enum ldv_21628 socket_state;
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/net.h"
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/net.h"
struct proto_ops;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/net.h"
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/net.h"
struct proto_ops {
   int family ;
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slab.h"
struct kmem_cache_cpu {
   void **freelist ;
   unsigned long tid ;
   struct page *page ;
   struct page *partial ;
   unsigned int stat[26U] ;
};
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
#line 58
struct memcg_cache_params;
#line 58
struct kmem_cache_node;
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slub_def.h"
struct kmem_cache {
   struct kmem_cache_cpu *cpu_slab ;
   unsigned long flags ;
   unsigned long min_partial ;
   int size ;
   int object_size ;
   int offset ;
   int cpu_partial ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   int reserved ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   struct memcg_cache_params *memcg_params ;
   int max_attr_size ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1024U] ;
};
#line 497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slab.h"
struct __anonstruct____missing_field_name_214 {
   struct callback_head callback_head ;
   struct kmem_cache *memcg_caches[0U] ;
};
#line 497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slab.h"
struct __anonstruct____missing_field_name_215 {
   struct mem_cgroup *memcg ;
   struct list_head list ;
   struct kmem_cache *root_cache ;
   bool dead ;
   atomic_t nr_pages ;
   struct work_struct destroy ;
};
#line 497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slab.h"
union __anonunion____missing_field_name_213 {
   struct __anonstruct____missing_field_name_214 __annonCompField63 ;
   struct __anonstruct____missing_field_name_215 __annonCompField64 ;
};
#line 497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slab.h"
struct memcg_cache_params {
   bool is_root_cache ;
   union __anonunion____missing_field_name_213 __annonCompField65 ;
};
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/checksum_64.h"
struct in6_addr;
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/checksum.h"
struct sk_buff;
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/checksum.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dma-attrs.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 136 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 172
struct skb_frag_struct;
#line 172 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
typedef struct skb_frag_struct skb_frag_t;
#line 173 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct __anonstruct_page_217 {
   struct page *p ;
};
#line 173 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct skb_frag_struct {
   struct __anonstruct_page_217 page ;
   __u32 page_offset ;
   __u32 size ;
};
#line 206 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct skb_shared_hwtstamps {
   ktime_t hwtstamp ;
   ktime_t syststamp ;
};
#line 275 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct skb_shared_info {
   unsigned char nr_frags ;
   __u8 tx_flags ;
   unsigned short gso_size ;
   unsigned short gso_segs ;
   unsigned short gso_type ;
   struct sk_buff *frag_list ;
   struct skb_shared_hwtstamps hwtstamps ;
   __be32 ip6_frag_id ;
   atomic_t dataref ;
   void *destructor_arg ;
   skb_frag_t frags[17U] ;
};
#line 354 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 355
struct sec_path;
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct __anonstruct____missing_field_name_219 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_218 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_219 __annonCompField67 ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_220 {
   unsigned int napi_id ;
   dma_cookie_t dma_cookie ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_221 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 355 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   ktime_t tstamp ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   struct sec_path *sp ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   union __anonunion____missing_field_name_218 __annonCompField68 ;
   __u32 priority ;
   __u8 local_df : 1 ;
   __u8 cloned : 1 ;
   __u8 ip_summed : 2 ;
   __u8 nohdr : 1 ;
   __u8 nfctinfo : 3 ;
   __u8 pkt_type : 3 ;
   __u8 fclone : 2 ;
   __u8 ipvs_property : 1 ;
   __u8 peeked : 1 ;
   __u8 nf_trace : 1 ;
   __be16 protocol ;
   void (*destructor)(struct sk_buff * ) ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   int skb_iif ;
   __u32 rxhash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   __u16 tc_index ;
   __u16 tc_verd ;
   __u16 queue_mapping ;
   __u8 ndisc_nodetype : 2 ;
   __u8 pfmemalloc : 1 ;
   __u8 ooo_okay : 1 ;
   __u8 l4_rxhash : 1 ;
   __u8 wifi_acked_valid : 1 ;
   __u8 wifi_acked : 1 ;
   __u8 no_fcs : 1 ;
   __u8 head_frag : 1 ;
   __u8 encapsulation : 1 ;
   union __anonunion____missing_field_name_220 __annonCompField69 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_221 __annonCompField70 ;
   __be16 inner_protocol ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 578
struct dst_entry;
#line 646
struct rtable;
#line 722
enum pkt_hash_types {
    PKT_HASH_TYPE_NONE = 0,
    PKT_HASH_TYPE_L2 = 1,
    PKT_HASH_TYPE_L3 = 2,
    PKT_HASH_TYPE_L4 = 3
} ;
#line 2939 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/if_ether.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char reserved1[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 105 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 128 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 303 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 331 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 382 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 404 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 425 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 458 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 474 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 494 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 505 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 524 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 550 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 684 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 692 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 768 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh_indir)(struct net_device * , u32 * ) ;
   int (*set_rxfh_indir)(struct net_device * , u32 const   * ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
};
#line 249
struct prot_inuse;
#line 250 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ethtool.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct u64_stats_sync {

};
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct icmpv6_mib_device {
   atomic_long_t mibs[6U] ;
};
#line 83 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct icmpv6msg_mib_device {
   atomic_long_t mibs[512U] ;
};
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[8U] ;
};
#line 106 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[97U] ;
};
#line 112 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118
struct proc_dir_entry;
#line 118 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics[1U] ;
   struct ipstats_mib *ip_statistics[1U] ;
   struct linux_mib *net_statistics[1U] ;
   struct udp_mib *udp_statistics[1U] ;
   struct udp_mib *udplite_statistics[1U] ;
   struct icmp_mib *icmp_statistics[1U] ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6[1U] ;
   struct udp_mib *udplite_stats_in6[1U] ;
   struct ipstats_mib *ipv6_statistics[1U] ;
   struct icmpv6_mib *icmpv6_statistics[1U] ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics[1U] ;
};
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/packet.h"
struct netns_frags {
   int nqueues ;
   struct list_head lru_list ;
   spinlock_t lru_lock ;
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 180 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 181
struct ipv4_devconf;
#line 182
struct fib_rules_ops;
#line 183
struct fib_table;
#line 184 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/ipv4.h"
struct inet_peer_base;
#line 22
struct xt_table;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports sysctl_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   kgid_t sysctl_ping_group_range[2U] ;
   atomic_t dev_addr_genid ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 90
struct neighbour;
#line 90 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
};
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 34
struct rt6_info;
#line 34
struct rt6_statistics;
#line 34
struct fib6_table;
#line 34 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t rt_genid ;
};
#line 79 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 85
struct sctp_mib;
#line 86 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/ipv6.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics[1U] ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 104 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/in.h"
union __anonunion_in6_u_224 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 104 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/in.h"
struct in6_addr {
   union __anonunion_in6_u_224 in6_u ;
};
#line 324 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netfilter.h"
struct nlattr;
#line 337
struct nf_logger;
#line 338 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
   bool ulog_warn_deprecated ;
   bool ebt_ulog_warn_deprecated ;
};
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 52 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 63
struct ip_conntrack_stat;
#line 63
struct nf_ct_event_notifier;
#line 63
struct nf_exp_event_notifier;
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   unsigned int sysctl_events_retry_timeout ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 104
struct nft_af_info;
#line 105 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   u8 gencursor ;
   u8 genctr ;
};
#line 489 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/xfrm.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
};
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[6U] ;
   struct xfrm_policy_hash policy_bydst[6U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   spinlock_t xfrm_policy_sk_bundle_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
};
#line 65
struct net_generic;
#line 66
struct netns_ipvs;
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netns/xfrm.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   unsigned int proc_inum ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 395 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/net_namespace.h"
struct dsa_chip_data {
   struct device *mii_bus ;
   int sw_addr ;
   char *port_names[12U] ;
   s8 *rtable ;
};
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 61
struct dsa_switch;
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   __be16 tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 94
struct dsa_switch_driver;
#line 94
struct mii_bus;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct mii_bus *master_mii_bus ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   __be16 tag_protocol ;
   int priv_size ;
   char *(*probe)(struct mii_bus * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
};
#line 200 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   u8 (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   u8 (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/prio_heap.h"
struct xattr_handler {
   char const   *prefix ;
   int flags ;
   size_t (*list)(struct dentry * , char * , size_t  , char const   * , size_t  ,
                  int  ) ;
   int (*get)(struct dentry * , char const   * , void * , size_t  , int  ) ;
   int (*set)(struct dentry * , char const   * , void const   * , size_t  , int  ,
              int  ) ;
};
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/xattr.h"
struct simple_xattrs {
   struct list_head head ;
   spinlock_t lock ;
};
#line 98
struct percpu_ref;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_t count ;
   unsigned int *pcpu_count ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_kill ;
   struct callback_head rcu ;
};
#line 173
struct cgroupfs_root;
#line 174
struct cgroup_subsys;
#line 175
struct cgroup;
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   unsigned long flags ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cgroup.h"
struct cgroup_name {
   struct callback_head callback_head ;
   char name[] ;
};
#line 160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cgroup.h"
struct cgroup {
   unsigned long flags ;
   int id ;
   int nr_css ;
   struct list_head sibling ;
   struct list_head children ;
   struct list_head files ;
   struct cgroup *parent ;
   struct dentry *dentry ;
   u64 serial_nr ;
   struct cgroup_name *name ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroupfs_root *root ;
   struct list_head cset_links ;
   struct list_head release_list ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   struct cgroup_subsys_state dummy_css ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
   struct simple_xattrs xattrs ;
};
#line 252 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cgroup.h"
struct cgroupfs_root {
   struct super_block *sb ;
   unsigned long subsys_mask ;
   int hierarchy_id ;
   struct cgroup top_cgroup ;
   int number_of_cgroups ;
   struct list_head root_list ;
   unsigned long flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 342 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head cgrp_links ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct callback_head callback_head ;
};
#line 392 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   int (*write_string)(struct cgroup_subsys_state * , struct cftype * , char const   * ) ;
   int (*trigger)(struct cgroup_subsys_state * , unsigned int  ) ;
};
#line 479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cgroup.h"
struct cftype_set {
   struct list_head node ;
   struct cftype *cfts ;
};
#line 546
struct cgroup_taskset;
#line 557 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int subsys_id ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   char const   *name ;
   struct cgroupfs_root *root ;
   struct list_head cftsets ;
   struct cftype *base_cftypes ;
   struct cftype_set base_cftset ;
   struct module *module ;
};
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/vtime.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 60 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/hardirq.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 103 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/security.h"
struct xfrm_policy;
#line 104
struct xfrm_state;
#line 124
struct request_sock;
#line 3157
struct mnt_namespace;
#line 3158
struct ipc_namespace;
#line 3159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 171 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netlink.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 536 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 tx_rate ;
   __u32 spoofchk ;
   __u32 linkstate ;
};
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/if_link.h"
struct netpoll_info;
#line 28
struct phy_device;
#line 29
struct wireless_dev;
#line 64 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 116 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 196
struct neigh_parms;
#line 197 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct netdev_hw_addr {
   struct list_head list ;
   unsigned char addr[32U] ;
   unsigned char type ;
   bool global_use ;
   int sync_cnt ;
   int refcount ;
   int synced ;
   struct callback_head callback_head ;
};
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 222 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 251 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 302 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 337
enum gro_result {
    GRO_MERGED = 0,
    GRO_MERGED_FREE = 1,
    GRO_HELD = 2,
    GRO_NORMAL = 3,
    GRO_DROP = 4
} ;
#line 345 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
typedef enum gro_result gro_result_t;
#line 346
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 394 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 395 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 532
struct Qdisc;
#line 532 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 594 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 606 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 618 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 669 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 692 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 705 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 716 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 727 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 743 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct netdev_phys_port_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 756 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * , gfp_t  ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_tx_rate)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_port_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
};
#line 1147
enum ldv_27986 {
    NETREG_UNINITIALIZED = 0,
    NETREG_REGISTERED = 1,
    NETREG_UNREGISTERING = 2,
    NETREG_UNREGISTERED = 3,
    NETREG_RELEASED = 4,
    NETREG_DUMMY = 5
} ;
#line 1156
enum ldv_27987 {
    RTNL_LINK_INITIALIZED = 0,
    RTNL_LINK_INITIALIZING = 1
} ;
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct __anonstruct_adj_list_235 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_236 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1161
struct iw_handler_def;
#line 1161
struct iw_public_data;
#line 1161
struct forwarding_accel_ops;
#line 1161
struct vlan_info;
#line 1161
struct tipc_bearer;
#line 1161
struct in_device;
#line 1161
struct dn_dev;
#line 1161
struct inet6_dev;
#line 1161
struct cpu_rmap;
#line 1161
struct pcpu_lstats;
#line 1161
struct pcpu_sw_netstats;
#line 1161
struct pcpu_dstats;
#line 1161
struct pcpu_vstats;
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
union __anonunion____missing_field_name_237 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1161
struct garp_port;
#line 1161
struct mrp_port;
#line 1161
struct rtnl_link_ops;
#line 1161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct __anonstruct_adj_list_235 adj_list ;
   struct __anonstruct_all_adj_list_236 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct forwarding_accel_ops  const  *fwd_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   enum ldv_27986 reg_state : 8 ;
   bool dismantle ;
   enum ldv_27987 rtnl_link_state : 16 ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion____missing_field_name_237 __annonCompField74 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 1722 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 2465
enum skb_free_reason {
    SKB_REASON_CONSUMED = 0,
    SKB_REASON_DROPPED = 1
} ;
#line 13 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/io.h"
struct hotplug_slot;
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/io.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
typedef int pci_power_t;
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 180 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 237
struct pcie_link_state;
#line 238
struct pci_vpd;
#line 239
struct pci_sriov;
#line 240
struct pci_ats;
#line 241
struct pci_driver;
#line 241 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
union __anonunion____missing_field_name_241 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 241 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   u8 pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int pme_interrupt : 1 ;
   unsigned int pme_poll : 1 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   unsigned int no_d3cold : 1 ;
   unsigned int d3cold_allowed : 1 ;
   unsigned int mmio_always_on : 1 ;
   unsigned int wakeup_prepared : 1 ;
   unsigned int runtime_d3cold : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_cfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int needs_freset : 1 ;
   unsigned int state_saved : 1 ;
   unsigned int is_physfn : 1 ;
   unsigned int is_virtfn : 1 ;
   unsigned int reset_fn : 1 ;
   unsigned int is_hotplug_bridge : 1 ;
   unsigned int __aer_firmware_first_valid : 1 ;
   unsigned int __aer_firmware_first : 1 ;
   unsigned int broken_intx_masking : 1 ;
   unsigned int io_window_1k : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_241 __annonCompField75 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
};
#line 429
struct pci_ops;
#line 429
struct msi_chip;
#line 429 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_chip *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
#line 534 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 555 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 569 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 579 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 609 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/elf.h"
struct kernel_param;
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 58
struct kparam_array;
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_246 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 58 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s16 level ;
   union __anonunion____missing_field_name_246 __annonCompField76 ;
};
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 463
struct tracepoint;
#line 464 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/moduleparam.h"
struct tracepoint_func {
   void *func ;
   void *data ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
#line 92 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/tracepoint.h"
struct mod_arch_specific {

};
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 208
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 215 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/module.h"
struct module_ref {
   unsigned long incs ;
   unsigned long decs ;
};
#line 229
struct module_sect_attrs;
#line 229
struct module_notes_attrs;
#line 229
struct ftrace_event_call;
#line 229 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   struct module_ref *refptr ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 615 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/memcontrol.h"
struct res_counter {
   unsigned long long usage ;
   unsigned long long max_usage ;
   unsigned long long limit ;
   unsigned long long soft_limit ;
   unsigned long long failcnt ;
   spinlock_t lock ;
   struct res_counter *parent ;
};
#line 226 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/res_counter.h"
struct kioctx;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/aio.h"
typedef int kiocb_cancel_fn(struct kiocb * );
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/aio.h"
union __anonunion_ki_obj_247 {
   void *user ;
   struct task_struct *tsk ;
};
#line 31
struct eventfd_ctx;
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/aio.h"
struct kiocb {
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   kiocb_cancel_fn *ki_cancel ;
   void *private ;
   union __anonunion_ki_obj_247 ki_obj ;
   __u64 ki_user_data ;
   loff_t ki_pos ;
   size_t ki_nbytes ;
   struct list_head ki_list ;
   struct eventfd_ctx *ki_eventfd ;
};
#line 100 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/aio.h"
struct sock_filter {
   __u16 code ;
   __u8 jt ;
   __u8 jf ;
   __u32 k ;
};
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/filter.h"
union __anonunion____missing_field_name_248 {
   struct sock_filter insns[0U] ;
   struct work_struct work ;
};
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/filter.h"
struct sk_filter {
   atomic_t refcnt ;
   unsigned int len ;
   struct callback_head rcu ;
   unsigned int (*bpf_func)(struct sk_buff  const  * , struct sock_filter  const  * ) ;
   union __anonunion____missing_field_name_248 __annonCompField77 ;
};
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 108 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rtnetlink.h"
struct nla_policy {
   u16 type ;
   u16 len ;
};
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/rtnetlink.h"
struct rtnl_link_ops {
   struct list_head list ;
   char const   *kind ;
   size_t priv_size ;
   void (*setup)(struct net_device * ) ;
   int maxtype ;
   struct nla_policy  const  *policy ;
   int (*validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*newlink)(struct net * , struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   int (*changelink)(struct net_device * , struct nlattr ** , struct nlattr ** ) ;
   void (*dellink)(struct net_device * , struct list_head * ) ;
   size_t (*get_size)(struct net_device  const  * ) ;
   int (*fill_info)(struct sk_buff * , struct net_device  const  * ) ;
   size_t (*get_xstats_size)(struct net_device  const  * ) ;
   int (*fill_xstats)(struct sk_buff * , struct net_device  const  * ) ;
   unsigned int (*get_num_tx_queues)(void) ;
   unsigned int (*get_num_rx_queues)(void) ;
   int slave_maxtype ;
   struct nla_policy  const  *slave_policy ;
   int (*slave_validate)(struct nlattr ** , struct nlattr ** ) ;
   int (*slave_changelink)(struct net_device * , struct net_device * , struct nlattr ** ,
                           struct nlattr ** ) ;
   size_t (*get_slave_size)(struct net_device  const  * , struct net_device  const  * ) ;
   int (*fill_slave_info)(struct sk_buff * , struct net_device  const  * , struct net_device  const  * ) ;
};
#line 167
struct neigh_table;
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/rtnetlink.h"
struct neigh_parms {
   struct net *net ;
   struct net_device *dev ;
   struct neigh_parms *next ;
   int (*neigh_setup)(struct neighbour * ) ;
   void (*neigh_cleanup)(struct neighbour * ) ;
   struct neigh_table *tbl ;
   void *sysctl_table ;
   int dead ;
   atomic_t refcnt ;
   struct callback_head callback_head ;
   int reachable_time ;
   int data[12U] ;
   unsigned long data_state[1U] ;
};
#line 111 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/neighbour.h"
struct neigh_statistics {
   unsigned long allocs ;
   unsigned long destroys ;
   unsigned long hash_grows ;
   unsigned long res_failed ;
   unsigned long lookups ;
   unsigned long hits ;
   unsigned long rcv_probes_mcast ;
   unsigned long rcv_probes_ucast ;
   unsigned long periodic_gc_runs ;
   unsigned long forced_gc_runs ;
   unsigned long unres_discards ;
};
#line 130
struct neigh_ops;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/neighbour.h"
struct neighbour {
   struct neighbour *next ;
   struct neigh_table *tbl ;
   struct neigh_parms *parms ;
   unsigned long confirmed ;
   unsigned long updated ;
   rwlock_t lock ;
   atomic_t refcnt ;
   struct sk_buff_head arp_queue ;
   unsigned int arp_queue_len_bytes ;
   struct timer_list timer ;
   unsigned long used ;
   atomic_t probes ;
   __u8 flags ;
   __u8 nud_state ;
   __u8 type ;
   __u8 dead ;
   seqlock_t ha_lock ;
   unsigned char ha[32U] ;
   struct hh_cache hh ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   struct neigh_ops  const  *ops ;
   struct callback_head rcu ;
   struct net_device *dev ;
   u8 primary_key[0U] ;
};
#line 159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/neighbour.h"
struct neigh_ops {
   int family ;
   void (*solicit)(struct neighbour * , struct sk_buff * ) ;
   void (*error_report)(struct neighbour * , struct sk_buff * ) ;
   int (*output)(struct neighbour * , struct sk_buff * ) ;
   int (*connected_output)(struct neighbour * , struct sk_buff * ) ;
};
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/neighbour.h"
struct pneigh_entry {
   struct pneigh_entry *next ;
   struct net *net ;
   struct net_device *dev ;
   u8 flags ;
   u8 key[0U] ;
};
#line 177 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/neighbour.h"
struct neigh_hash_table {
   struct neighbour **hash_buckets ;
   unsigned int hash_shift ;
   __u32 hash_rnd[4U] ;
   struct callback_head rcu ;
};
#line 190 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/neighbour.h"
struct neigh_table {
   struct neigh_table *next ;
   int family ;
   int entry_size ;
   int key_len ;
   __u32 (*hash)(void const   * , struct net_device  const  * , __u32 * ) ;
   int (*constructor)(struct neighbour * ) ;
   int (*pconstructor)(struct pneigh_entry * ) ;
   void (*pdestructor)(struct pneigh_entry * ) ;
   void (*proxy_redo)(struct sk_buff * ) ;
   char *id ;
   struct neigh_parms parms ;
   int gc_interval ;
   int gc_thresh1 ;
   int gc_thresh2 ;
   int gc_thresh3 ;
   unsigned long last_flush ;
   struct delayed_work gc_work ;
   struct timer_list proxy_timer ;
   struct sk_buff_head proxy_queue ;
   atomic_t entries ;
   rwlock_t lock ;
   unsigned long last_rand ;
   struct neigh_statistics *stats ;
   struct neigh_hash_table *nht ;
   struct pneigh_entry **phash_buckets ;
};
#line 462
struct dn_route;
#line 462 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/neighbour.h"
union __anonunion____missing_field_name_253 {
   struct dst_entry *next ;
   struct rtable *rt_next ;
   struct rt6_info *rt6_next ;
   struct dn_route *dn_next ;
};
#line 462 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/neighbour.h"
struct dst_entry {
   struct callback_head callback_head ;
   struct dst_entry *child ;
   struct net_device *dev ;
   struct dst_ops *ops ;
   unsigned long _metrics ;
   unsigned long expires ;
   struct dst_entry *path ;
   struct dst_entry *from ;
   struct xfrm_state *xfrm ;
   int (*input)(struct sk_buff * ) ;
   int (*output)(struct sk_buff * ) ;
   unsigned short flags ;
   unsigned short pending_confirm ;
   short error ;
   short obsolete ;
   unsigned short header_len ;
   unsigned short trailer_len ;
   __u32 tclassid ;
   long __pad_to_align_refcnt[2U] ;
   atomic_t __refcnt ;
   int __use ;
   unsigned long lastuse ;
   union __anonunion____missing_field_name_253 __annonCompField78 ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
struct __anonstruct_socket_lock_t_254 {
   spinlock_t slock ;
   int owned ;
   wait_queue_head_t wq ;
   struct lockdep_map dep_map ;
};
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
typedef struct __anonstruct_socket_lock_t_254 socket_lock_t;
#line 123
struct proto;
#line 129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
typedef __u32 __portpair;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
typedef __u64 __addrpair;
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
struct __anonstruct____missing_field_name_256 {
   __be32 skc_daddr ;
   __be32 skc_rcv_saddr ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_255 {
   __addrpair skc_addrpair ;
   struct __anonstruct____missing_field_name_256 __annonCompField79 ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_257 {
   unsigned int skc_hash ;
   __u16 skc_u16hashes[2U] ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
struct __anonstruct____missing_field_name_259 {
   __be16 skc_dport ;
   __u16 skc_num ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_258 {
   __portpair skc_portpair ;
   struct __anonstruct____missing_field_name_259 __annonCompField82 ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_260 {
   struct hlist_node skc_bind_node ;
   struct hlist_nulls_node skc_portaddr_node ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
union __anonunion____missing_field_name_261 {
   struct hlist_node skc_node ;
   struct hlist_nulls_node skc_nulls_node ;
};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
struct sock_common {
   union __anonunion____missing_field_name_255 __annonCompField80 ;
   union __anonunion____missing_field_name_257 __annonCompField81 ;
   union __anonunion____missing_field_name_258 __annonCompField83 ;
   unsigned short skc_family ;
   unsigned char volatile   skc_state ;
   unsigned char skc_reuse : 4 ;
   unsigned char skc_reuseport : 4 ;
   int skc_bound_dev_if ;
   union __anonunion____missing_field_name_260 __annonCompField84 ;
   struct proto *skc_prot ;
   struct net *skc_net ;
   struct in6_addr skc_v6_daddr ;
   struct in6_addr skc_v6_rcv_saddr ;
   int skc_dontcopy_begin[0U] ;
   union __anonunion____missing_field_name_261 __annonCompField85 ;
   int skc_tx_queue_mapping ;
   atomic_t skc_refcnt ;
   int skc_dontcopy_end[0U] ;
};
#line 216
struct cg_proto;
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
struct __anonstruct_sk_backlog_262 {
   atomic_t rmem_alloc ;
   int len ;
   struct sk_buff *head ;
   struct sk_buff *tail ;
};
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
struct sock {
   struct sock_common __sk_common ;
   socket_lock_t sk_lock ;
   struct sk_buff_head sk_receive_queue ;
   struct __anonstruct_sk_backlog_262 sk_backlog ;
   int sk_forward_alloc ;
   __u32 sk_rxhash ;
   unsigned int sk_napi_id ;
   unsigned int sk_ll_usec ;
   atomic_t sk_drops ;
   int sk_rcvbuf ;
   struct sk_filter *sk_filter ;
   struct socket_wq *sk_wq ;
   struct xfrm_policy *sk_policy[2U] ;
   unsigned long sk_flags ;
   struct dst_entry *sk_rx_dst ;
   struct dst_entry *sk_dst_cache ;
   spinlock_t sk_dst_lock ;
   atomic_t sk_wmem_alloc ;
   atomic_t sk_omem_alloc ;
   int sk_sndbuf ;
   struct sk_buff_head sk_write_queue ;
   unsigned int sk_shutdown : 2 ;
   unsigned int sk_no_check : 2 ;
   unsigned int sk_userlocks : 4 ;
   unsigned int sk_protocol : 8 ;
   unsigned int sk_type : 16 ;
   int sk_wmem_queued ;
   gfp_t sk_allocation ;
   u32 sk_pacing_rate ;
   u32 sk_max_pacing_rate ;
   netdev_features_t sk_route_caps ;
   netdev_features_t sk_route_nocaps ;
   int sk_gso_type ;
   unsigned int sk_gso_max_size ;
   u16 sk_gso_max_segs ;
   int sk_rcvlowat ;
   unsigned long sk_lingertime ;
   struct sk_buff_head sk_error_queue ;
   struct proto *sk_prot_creator ;
   rwlock_t sk_callback_lock ;
   int sk_err ;
   int sk_err_soft ;
   unsigned short sk_ack_backlog ;
   unsigned short sk_max_ack_backlog ;
   __u32 sk_priority ;
   __u32 sk_cgrp_prioidx ;
   struct pid *sk_peer_pid ;
   struct cred  const  *sk_peer_cred ;
   long sk_rcvtimeo ;
   long sk_sndtimeo ;
   void *sk_protinfo ;
   struct timer_list sk_timer ;
   ktime_t sk_stamp ;
   struct socket *sk_socket ;
   void *sk_user_data ;
   struct page_frag sk_frag ;
   struct sk_buff *sk_send_head ;
   __s32 sk_peek_off ;
   int sk_write_pending ;
   void *sk_security ;
   __u32 sk_mark ;
   u32 sk_classid ;
   struct cg_proto *sk_cgrp ;
   void (*sk_state_change)(struct sock * ) ;
   void (*sk_data_ready)(struct sock * , int  ) ;
   void (*sk_write_space)(struct sock * ) ;
   void (*sk_error_report)(struct sock * ) ;
   int (*sk_backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*sk_destruct)(struct sock * ) ;
};
#line 901
struct request_sock_ops;
#line 902
struct timewait_sock_ops;
#line 903
struct inet_hashinfo;
#line 904
struct raw_hashinfo;
#line 919
struct udp_table;
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
union __anonunion_h_263 {
   struct inet_hashinfo *hashinfo ;
   struct udp_table *udp_table ;
   struct raw_hashinfo *raw_hash ;
};
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
struct proto {
   void (*close)(struct sock * , long  ) ;
   int (*connect)(struct sock * , struct sockaddr * , int  ) ;
   int (*disconnect)(struct sock * , int  ) ;
   struct sock *(*accept)(struct sock * , int  , int * ) ;
   int (*ioctl)(struct sock * , int  , unsigned long  ) ;
   int (*init)(struct sock * ) ;
   void (*destroy)(struct sock * ) ;
   void (*shutdown)(struct sock * , int  ) ;
   int (*setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct sock * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct sock * , int  , int  , char * , int * ) ;
   int (*compat_ioctl)(struct sock * , unsigned int  , unsigned long  ) ;
   int (*sendmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct kiocb * , struct sock * , struct msghdr * , size_t  , int  ,
                  int  , int * ) ;
   int (*sendpage)(struct sock * , struct page * , int  , size_t  , int  ) ;
   int (*bind)(struct sock * , struct sockaddr * , int  ) ;
   int (*backlog_rcv)(struct sock * , struct sk_buff * ) ;
   void (*release_cb)(struct sock * ) ;
   void (*mtu_reduced)(struct sock * ) ;
   void (*hash)(struct sock * ) ;
   void (*unhash)(struct sock * ) ;
   void (*rehash)(struct sock * ) ;
   int (*get_port)(struct sock * , unsigned short  ) ;
   void (*clear_sk)(struct sock * , int  ) ;
   unsigned int inuse_idx ;
   bool (*stream_memory_free)(struct sock  const  * ) ;
   void (*enter_memory_pressure)(struct sock * ) ;
   atomic_long_t *memory_allocated ;
   struct percpu_counter *sockets_allocated ;
   int *memory_pressure ;
   long *sysctl_mem ;
   int *sysctl_wmem ;
   int *sysctl_rmem ;
   int max_header ;
   bool no_autobind ;
   struct kmem_cache *slab ;
   unsigned int obj_size ;
   int slab_flags ;
   struct percpu_counter *orphan_count ;
   struct request_sock_ops *rsk_prot ;
   struct timewait_sock_ops *twsk_prot ;
   union __anonunion_h_263 h ;
   struct module *owner ;
   char name[32U] ;
   struct list_head node ;
   int (*init_cgroup)(struct mem_cgroup * , struct cgroup_subsys * ) ;
   void (*destroy_cgroup)(struct mem_cgroup * ) ;
   struct cg_proto *(*proto_cgroup)(struct mem_cgroup * ) ;
};
#line 1044 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/sock.h"
struct cg_proto {
   struct res_counter memory_allocated ;
   struct percpu_counter sockets_allocated ;
   int memory_pressure ;
   long sysctl_mem[3U] ;
   unsigned long flags ;
   struct mem_cgroup *memcg ;
};
#line 8 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/unaligned/packed_struct.h"
struct __una_u32 {
   u32 x ;
};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/jhash.h"
struct request_sock_ops {
   int family ;
   int obj_size ;
   struct kmem_cache *slab ;
   char *slab_name ;
   int (*rtx_syn_ack)(struct sock * , struct request_sock * ) ;
   void (*send_ack)(struct sock * , struct sk_buff * , struct request_sock * ) ;
   void (*send_reset)(struct sock * , struct sk_buff * ) ;
   void (*destructor)(struct request_sock * ) ;
   void (*syn_ack_timeout)(struct sock * , struct request_sock * ) ;
};
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/request_sock.h"
struct request_sock {
   struct sock_common __req_common ;
   struct request_sock *dl_next ;
   u16 mss ;
   u8 num_retrans ;
   u8 cookie_ts : 1 ;
   u8 num_timeout : 7 ;
   u32 window_clamp ;
   u32 rcv_wnd ;
   u32 ts_recent ;
   unsigned long expires ;
   struct request_sock_ops  const  *rsk_ops ;
   struct sock *sk ;
   u32 secid ;
   u32 peer_secid ;
};
#line 372 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inet_connection_sock.h"
struct timewait_sock_ops {
   struct kmem_cache *twsk_slab ;
   char *twsk_slab_name ;
   unsigned int twsk_obj_size ;
   int (*twsk_unique)(struct sock * , struct sock * , void * ) ;
   void (*twsk_destructor)(struct sock * ) ;
};
#line 618 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/interrupt.h"
struct iphdr {
   __u8 ihl : 4 ;
   __u8 version : 4 ;
   __u8 tos ;
   __be16 tot_len ;
   __be16 id ;
   __be16 frag_off ;
   __u8 ttl ;
   __u8 protocol ;
   __sum16 check ;
   __be32 saddr ;
   __be32 daddr ;
};
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ipv6.h"
struct ipv6_opt_hdr {
   __u8 nexthdr ;
   __u8 hdrlen ;
};
#line 102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ipv6.h"
struct ipv6hdr {
   __u8 priority : 4 ;
   __u8 version : 4 ;
   __u8 flow_lbl[3U] ;
   __be16 payload_len ;
   __u8 nexthdr ;
   __u8 hop_limit ;
   struct in6_addr saddr ;
   struct in6_addr daddr ;
};
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ipv6.h"
struct ipv6_devconf {
   __s32 forwarding ;
   __s32 hop_limit ;
   __s32 mtu6 ;
   __s32 accept_ra ;
   __s32 accept_redirects ;
   __s32 autoconf ;
   __s32 dad_transmits ;
   __s32 rtr_solicits ;
   __s32 rtr_solicit_interval ;
   __s32 rtr_solicit_delay ;
   __s32 force_mld_version ;
   __s32 mldv1_unsolicited_report_interval ;
   __s32 mldv2_unsolicited_report_interval ;
   __s32 use_tempaddr ;
   __s32 temp_valid_lft ;
   __s32 temp_prefered_lft ;
   __s32 regen_max_retry ;
   __s32 max_desync_factor ;
   __s32 max_addresses ;
   __s32 accept_ra_defrtr ;
   __s32 accept_ra_pinfo ;
   __s32 accept_ra_rtr_pref ;
   __s32 rtr_probe_interval ;
   __s32 accept_ra_rt_info_max_plen ;
   __s32 proxy_ndp ;
   __s32 accept_source_route ;
   __s32 optimistic_dad ;
   __s32 mc_forwarding ;
   __s32 disable_ipv6 ;
   __s32 accept_dad ;
   __s32 force_tllao ;
   __s32 ndisc_notify ;
   __s32 suppress_frag_ndisc ;
   void *sysctl ;
};
#line 101 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/if_inet6.h"
struct ip6_sf_list {
   struct ip6_sf_list *sf_next ;
   struct in6_addr sf_addr ;
   unsigned long sf_count[2U] ;
   unsigned char sf_gsresp ;
   unsigned char sf_oldin ;
   unsigned char sf_crcount ;
};
#line 110 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/if_inet6.h"
struct ifmcaddr6 {
   struct in6_addr mca_addr ;
   struct inet6_dev *idev ;
   struct ifmcaddr6 *next ;
   struct ip6_sf_list *mca_sources ;
   struct ip6_sf_list *mca_tomb ;
   unsigned int mca_sfmode ;
   unsigned char mca_crcount ;
   unsigned long mca_sfcount[2U] ;
   struct timer_list mca_timer ;
   unsigned int mca_flags ;
   int mca_users ;
   atomic_t mca_refcnt ;
   spinlock_t mca_lock ;
   unsigned long mca_cstamp ;
   unsigned long mca_tstamp ;
};
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/if_inet6.h"
struct ifacaddr6 {
   struct in6_addr aca_addr ;
   struct inet6_dev *aca_idev ;
   struct rt6_info *aca_rt ;
   struct ifacaddr6 *aca_next ;
   int aca_users ;
   atomic_t aca_refcnt ;
   spinlock_t aca_lock ;
   unsigned long aca_cstamp ;
   unsigned long aca_tstamp ;
};
#line 154 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/if_inet6.h"
struct ipv6_devstat {
   struct proc_dir_entry *proc_dir_entry ;
   struct ipstats_mib *ipv6[1U] ;
   struct icmpv6_mib_device *icmpv6dev ;
   struct icmpv6msg_mib_device *icmpv6msgdev ;
};
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/if_inet6.h"
struct inet6_dev {
   struct net_device *dev ;
   struct list_head addr_list ;
   struct ifmcaddr6 *mc_list ;
   struct ifmcaddr6 *mc_tomb ;
   spinlock_t mc_lock ;
   unsigned char mc_qrv ;
   unsigned char mc_gq_running ;
   unsigned char mc_ifc_count ;
   unsigned char mc_dad_count ;
   unsigned long mc_v1_seen ;
   unsigned long mc_qi ;
   unsigned long mc_qri ;
   unsigned long mc_maxdelay ;
   struct timer_list mc_gq_timer ;
   struct timer_list mc_ifc_timer ;
   struct timer_list mc_dad_timer ;
   struct ifacaddr6 *ac_list ;
   rwlock_t lock ;
   atomic_t refcnt ;
   __u32 if_flags ;
   int dead ;
   u8 rndid[8U] ;
   struct timer_list regen_timer ;
   struct list_head tempaddr_list ;
   struct in6_addr token ;
   struct neigh_parms *nd_parms ;
   struct ipv6_devconf cnf ;
   struct ipv6_devstat stats ;
   struct timer_list rs_timer ;
   __u8 rs_probes ;
   unsigned long tstamp ;
   struct callback_head rcu ;
};
#line 852 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/ipv6.h"
union __anonunion____missing_field_name_277 {
   __be32 a4 ;
   __be32 a6[4U] ;
};
#line 852 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/ipv6.h"
struct inetpeer_addr_base {
   union __anonunion____missing_field_name_277 __annonCompField86 ;
};
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inetpeer.h"
struct inetpeer_addr {
   struct inetpeer_addr_base addr ;
   __u16 family ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inetpeer.h"
union __anonunion____missing_field_name_278 {
   struct list_head gc_list ;
   struct callback_head gc_rcu ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inetpeer.h"
struct __anonstruct____missing_field_name_280 {
   atomic_t rid ;
   atomic_t ip_id_count ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inetpeer.h"
union __anonunion____missing_field_name_279 {
   struct __anonstruct____missing_field_name_280 __annonCompField88 ;
   struct callback_head rcu ;
   struct inet_peer *gc_next ;
};
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inetpeer.h"
struct inet_peer {
   struct inet_peer *avl_left ;
   struct inet_peer *avl_right ;
   struct inetpeer_addr daddr ;
   __u32 avl_height ;
   u32 metrics[15U] ;
   u32 rate_tokens ;
   unsigned long rate_last ;
   union __anonunion____missing_field_name_278 __annonCompField87 ;
   union __anonunion____missing_field_name_279 __annonCompField89 ;
   __u32 dtime ;
   atomic_t refcnt ;
};
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inetpeer.h"
struct inet_peer_base {
   struct inet_peer *root ;
   seqlock_t lock ;
   u32 flush_seq ;
   int total ;
};
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/route.h"
struct rtable {
   struct dst_entry dst ;
   int rt_genid ;
   unsigned int rt_flags ;
   __u16 rt_type ;
   __u8 rt_is_input ;
   __u8 rt_uses_gateway ;
   int rt_iif ;
   __be32 rt_gateway ;
   u32 rt_pmtu ;
   struct list_head rt_uncached ;
};
#line 316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/route.h"
struct inet_ehash_bucket {
   struct hlist_nulls_head chain ;
};
#line 95 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inet_hashtables.h"
struct inet_bind_hashbucket {
   spinlock_t lock ;
   struct hlist_head chain ;
};
#line 103 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inet_hashtables.h"
struct inet_listen_hashbucket {
   spinlock_t lock ;
   struct hlist_nulls_head head ;
};
#line 115 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/inet_hashtables.h"
struct inet_hashinfo {
   struct inet_ehash_bucket *ehash ;
   spinlock_t *ehash_locks ;
   unsigned int ehash_mask ;
   unsigned int ehash_locks_mask ;
   struct inet_bind_hashbucket *bhash ;
   unsigned int bhash_size ;
   struct kmem_cache *bind_bucket_cachep ;
   struct inet_listen_hashbucket listening_hash[32U] ;
   atomic_t bsockets ;
};
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/if_vlan.h"
struct vlan_ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_vlan_proto ;
   __be16 h_vlan_TCI ;
   __be16 h_vlan_encapsulated_proto ;
};
#line 479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/if_vlan.h"
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
#line 73 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/firmware.h"
struct be_eq_entry {
   u32 evt ;
};
#line 273 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_wrb {
   u32 frag_pa_hi ;
   u32 frag_pa_lo ;
   u32 rsvd0 ;
   u32 frag_len ;
};
#line 306 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_hdr_wrb {
   u32 dw[4U] ;
};
#line 333 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_tx_compl {
   u32 dw[4U] ;
};
#line 337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_rx_d {
   u32 fragpa_hi ;
   u32 fragpa_lo ;
};
#line 414 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_eth_rx_compl {
   u32 dw[4U] ;
};
#line 472 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_comp {
   unsigned long offset ;
   int optype ;
   int size ;
   int img_type ;
};
#line 479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct image_hdr {
   u32 imageid ;
   u32 imageoffset ;
   u32 imagelength ;
   u32 image_checksum ;
   u8 image_version[32U] ;
};
#line 498 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_file_hdr_g3 {
   u8 sign[52U] ;
   u8 ufi_version[4U] ;
   u32 file_len ;
   u32 cksum ;
   u32 antidote ;
   u32 num_imgs ;
   u8 build[24U] ;
   u8 asic_type_rev ;
   u8 rsvd[31U] ;
};
#line 510 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_hdr {
   u32 format_rev ;
   u32 cksum ;
   u32 antidote ;
   u32 num_images ;
   u8 id_string[128U] ;
   u32 rsvd[4U] ;
};
#line 519 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_hdr_g2 {
   u32 format_rev ;
   u32 cksum ;
   u32 antidote ;
   u32 build_num ;
   u8 id_string[128U] ;
   u32 rsvd[8U] ;
};
#line 528 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_entry {
   u32 type ;
   u32 offset ;
   u32 pad_size ;
   u32 image_size ;
   u32 cksum ;
   u32 entry_point ;
   u32 rsvd0 ;
   u32 rsvd1 ;
   u8 ver_data[32U] ;
};
#line 540 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_info {
   u8 cookie[32U] ;
   struct flash_section_hdr fsec_hdr ;
   struct flash_section_entry fsec_entry[32U] ;
};
#line 546 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct flash_section_info_g2 {
   u8 cookie[32U] ;
   struct flash_section_hdr_g2 fsec_hdr ;
   struct flash_section_entry fsec_entry[32U] ;
};
#line 552
struct ocrdma_dev;
#line 81 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_dma_mem {
   void *va ;
   dma_addr_t dma ;
   u32 size ;
};
#line 129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_queue_info {
   struct be_dma_mem dma_mem ;
   u16 len ;
   u16 entry_size ;
   u16 id ;
   u16 tail ;
   u16 head ;
   bool created ;
   atomic_t used ;
};
#line 185
struct be_adapter;
#line 185 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_eq_obj {
   struct be_queue_info q ;
   char desc[32U] ;
   bool enable_aic ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 eqd ;
   u32 cur_eqd ;
   u8 idx ;
   u8 msix_idx ;
   u16 tx_budget ;
   u16 spurious_intr ;
   struct napi_struct napi ;
   struct be_adapter *adapter ;
   unsigned int state ;
   spinlock_t lock ;
};
#line 216 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_aic_obj {
   bool enable ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 prev_eqd ;
   u32 et_eqd ;
   ulong jiffies ;
   u64 rx_pkts_prev ;
   u64 tx_reqs_prev ;
};
#line 233 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_mcc_obj {
   struct be_queue_info q ;
   struct be_queue_info cq ;
   bool rearm_cq ;
};
#line 239 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_stats {
   u64 tx_bytes ;
   u64 tx_pkts ;
   u64 tx_reqs ;
   u64 tx_wrbs ;
   u64 tx_compl ;
   ulong tx_jiffies ;
   u32 tx_stops ;
   u32 tx_drv_drops ;
   struct u64_stats_sync sync ;
   struct u64_stats_sync sync_compl ;
};
#line 252 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_tx_obj {
   u32 db_offset ;
   struct be_queue_info q ;
   struct be_queue_info cq ;
   struct sk_buff *sent_skb_list[2048U] ;
   struct be_tx_stats stats ;
};
#line 261 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_page_info {
   struct page *page ;
   dma_addr_t bus ;
   u16 page_offset ;
   bool last_page_user ;
};
#line 269 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_stats {
   u64 rx_bytes ;
   u64 rx_pkts ;
   u32 rx_drops_no_skbs ;
   u32 rx_drops_no_frags ;
   u32 rx_post_fail ;
   u32 rx_compl ;
   u32 rx_mcast_pkts ;
   u32 rx_compl_err ;
   struct u64_stats_sync sync ;
};
#line 281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_compl_info {
   u32 rss_hash ;
   u16 vlan_tag ;
   u16 pkt_size ;
   u16 port ;
   u8 vlanf ;
   u8 num_rcvd ;
   u8 err ;
   u8 ipf ;
   u8 tcpf ;
   u8 udpf ;
   u8 ip_csum ;
   u8 l4_csum ;
   u8 ipv6 ;
   u8 vtm ;
   u8 pkt_type ;
   u8 ip_frag ;
};
#line 300 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_rx_obj {
   struct be_adapter *adapter ;
   struct be_queue_info q ;
   struct be_queue_info cq ;
   struct be_rx_compl_info rxcp ;
   struct be_rx_page_info page_info_tbl[1024U] ;
   struct be_rx_stats stats ;
   u8 rss_id ;
   bool rx_post_starved ;
};
#line 311 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_drv_stats {
   u32 be_on_die_temperature ;
   u32 eth_red_drops ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rx_drops_too_many_frags ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rx_roce_bytes_lsd ;
   u32 rx_roce_bytes_msd ;
   u32 rx_roce_frames ;
   u32 roce_drops_payload_len ;
   u32 roce_drops_crc ;
};
#line 352 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_vf_cfg {
   unsigned char mac_addr[6U] ;
   int if_handle ;
   int pmac_id ;
   u16 vlan_tag ;
   u32 tx_rate ;
};
#line 368 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct phy_info {
   u8 transceiver ;
   u8 autoneg ;
   u8 fc_autoneg ;
   u8 port_type ;
   u16 phy_type ;
   u16 interface_type ;
   u32 misc_params ;
   u16 auto_speeds_supported ;
   u16 fixed_speeds_supported ;
   int link_speed ;
   u32 dac_cable_len ;
   u32 advertising ;
   u32 supported ;
};
#line 395 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_resources {
   u16 max_vfs ;
   u16 max_mcast_mac ;
   u16 max_tx_qs ;
   u16 max_rss_qs ;
   u16 max_rx_qs ;
   u16 max_uc_mac ;
   u16 max_vlans ;
   u16 max_evt_qs ;
   u32 if_cap_flags ;
};
#line 407 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct __anonstruct_roce_db_285 {
   u32 size ;
   u32 total_size ;
   u64 io_addr ;
};
#line 407 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_adapter {
   struct pci_dev *pdev ;
   struct net_device *netdev ;
   u8 *csr ;
   u8 *db ;
   struct mutex mbox_lock ;
   struct be_dma_mem mbox_mem ;
   struct be_dma_mem mbox_mem_alloced ;
   struct be_mcc_obj mcc_obj ;
   spinlock_t mcc_lock ;
   spinlock_t mcc_cq_lock ;
   u16 cfg_num_qs ;
   u16 num_evt_qs ;
   u16 num_msix_vec ;
   struct be_eq_obj eq_obj[32U] ;
   struct msix_entry msix_entries[32U] ;
   bool isr_registered ;
   u16 num_tx_qs ;
   struct be_tx_obj tx_obj[32U] ;
   u16 num_rx_qs ;
   struct be_rx_obj rx_obj[32U] ;
   u32 big_page_size ;
   struct be_drv_stats drv_stats ;
   struct be_aic_obj aic_obj[32U] ;
   u16 vlans_added ;
   u8 vlan_tag[4096U] ;
   u8 vlan_prio_bmap ;
   u16 recommended_prio ;
   struct be_dma_mem rx_filter ;
   struct be_dma_mem stats_cmd ;
   struct delayed_work work ;
   u16 work_counter ;
   struct delayed_work func_recovery_work ;
   u32 flags ;
   u32 cmd_privileges ;
   char fw_ver[32U] ;
   char fw_on_flash[32U] ;
   int if_handle ;
   u32 *pmac_id ;
   u32 beacon_state ;
   bool eeh_error ;
   bool fw_timeout ;
   bool hw_error ;
   u32 port_num ;
   bool promiscuous ;
   u32 function_mode ;
   u32 function_caps ;
   u32 rx_fc ;
   u32 tx_fc ;
   bool stats_cmd_sent ;
   struct __anonstruct_roce_db_285 roce_db ;
   u32 num_msix_roce_vec ;
   struct ocrdma_dev *ocrdma_dev ;
   struct list_head entry ;
   u32 flash_status ;
   struct completion et_cmd_compl ;
   struct be_resources res ;
   u16 num_vfs ;
   u8 virtfn ;
   struct be_vf_cfg *vf_cfg ;
   bool be3_native ;
   u32 sli_family ;
   u8 hba_port_num ;
   u16 pvid ;
   struct phy_info phy ;
   u8 wol_cap ;
   bool wol_en ;
   u32 uc_macs ;
   u16 asic_rev ;
   u16 qnq_vid ;
   u32 msg_enable ;
   int be_get_temp_freq ;
   u8 pf_number ;
   u64 rss_flags ;
};
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 port_number ;
   u8 domain ;
   u32 timeout ;
   u32 request_length ;
   u8 version ;
   u8 rsvd[3U] ;
};
#line 252 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd[2U] ;
   u8 status ;
   u8 add_status ;
   u8 rsvd1[2U] ;
   u32 response_length ;
   u32 actual_resp_len ;
};
#line 600 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v0 {
   u32 rx_bytes_lsd ;
   u32 rx_bytes_msd ;
   u32 rx_total_frames ;
   u32 rx_unicast_frames ;
   u32 rx_multicast_frames ;
   u32 rx_broadcast_frames ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_vlan_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_64_byte_packets ;
   u32 rx_65_127_byte_packets ;
   u32 rx_128_256_byte_packets ;
   u32 rx_256_511_byte_packets ;
   u32 rx_512_1023_byte_packets ;
   u32 rx_1024_1518_byte_packets ;
   u32 rx_1519_2047_byte_packets ;
   u32 rx_2048_4095_byte_packets ;
   u32 rx_4096_8191_byte_packets ;
   u32 rx_8192_9216_byte_packets ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rx_non_rss_packets ;
   u32 rx_ipv4_packets ;
   u32 rx_ipv6_packets ;
   u32 rx_ipv4_bytes_lsd ;
   u32 rx_ipv4_bytes_msd ;
   u32 rx_ipv6_bytes_lsd ;
   u32 rx_ipv6_bytes_msd ;
   u32 rx_chute1_packets ;
   u32 rx_chute2_packets ;
   u32 rx_chute3_packets ;
   u32 rx_management_packets ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 tx_bytes_lsd ;
   u32 tx_bytes_msd ;
   u32 tx_unicastframes ;
   u32 tx_multicastframes ;
   u32 tx_broadcastframes ;
   u32 tx_pauseframes ;
   u32 tx_controlframes ;
   u32 tx_64_byte_packets ;
   u32 tx_65_127_byte_packets ;
   u32 tx_128_256_byte_packets ;
   u32 tx_256_511_byte_packets ;
   u32 tx_512_1023_byte_packets ;
   u32 tx_1024_1518_byte_packets ;
   u32 tx_1519_2047_byte_packets ;
   u32 tx_2048_4095_byte_packets ;
   u32 tx_4096_8191_byte_packets ;
   u32 tx_8192_9216_byte_packets ;
   u32 rx_fifo_overflow ;
   u32 rx_input_fifo_overflow ;
};
#line 670 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v0 {
   struct be_port_rxf_stats_v0 port[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 management_rx_port_packets ;
   u32 management_rx_port_bytes ;
   u32 management_rx_port_pause_frames ;
   u32 management_rx_port_errors ;
   u32 management_tx_port_packets ;
   u32 management_tx_port_bytes ;
   u32 management_tx_port_pause ;
   u32 management_rx_port_rxfifo_overflow ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd0[7U] ;
   u32 port0_jabber_events ;
   u32 port1_jabber_events ;
   u32 rsvd1[6U] ;
};
#line 694 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v0 {
   u32 rx_drops_no_fragments[44U] ;
   u32 rsvd[4U] ;
};
#line 699 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_pmem_stats {
   u32 eth_red_drops ;
   u32 rsvd[5U] ;
};
#line 704 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v0 {
   struct be_rxf_stats_v0 rxf ;
   u32 rsvd[48U] ;
   struct be_erx_stats_v0 erx ;
   struct be_pmem_stats pmem ;
};
#line 716 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v0 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v0 hw_stats ;
};
#line 721 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_pport_stats {
   u32 tx_packets_lo ;
   u32 tx_packets_hi ;
   u32 tx_unicast_packets_lo ;
   u32 tx_unicast_packets_hi ;
   u32 tx_multicast_packets_lo ;
   u32 tx_multicast_packets_hi ;
   u32 tx_broadcast_packets_lo ;
   u32 tx_broadcast_packets_hi ;
   u32 tx_bytes_lo ;
   u32 tx_bytes_hi ;
   u32 tx_unicast_bytes_lo ;
   u32 tx_unicast_bytes_hi ;
   u32 tx_multicast_bytes_lo ;
   u32 tx_multicast_bytes_hi ;
   u32 tx_broadcast_bytes_lo ;
   u32 tx_broadcast_bytes_hi ;
   u32 tx_discards_lo ;
   u32 tx_discards_hi ;
   u32 tx_errors_lo ;
   u32 tx_errors_hi ;
   u32 tx_pause_frames_lo ;
   u32 tx_pause_frames_hi ;
   u32 tx_pause_on_frames_lo ;
   u32 tx_pause_on_frames_hi ;
   u32 tx_pause_off_frames_lo ;
   u32 tx_pause_off_frames_hi ;
   u32 tx_internal_mac_errors_lo ;
   u32 tx_internal_mac_errors_hi ;
   u32 tx_control_frames_lo ;
   u32 tx_control_frames_hi ;
   u32 tx_packets_64_bytes_lo ;
   u32 tx_packets_64_bytes_hi ;
   u32 tx_packets_65_to_127_bytes_lo ;
   u32 tx_packets_65_to_127_bytes_hi ;
   u32 tx_packets_128_to_255_bytes_lo ;
   u32 tx_packets_128_to_255_bytes_hi ;
   u32 tx_packets_256_to_511_bytes_lo ;
   u32 tx_packets_256_to_511_bytes_hi ;
   u32 tx_packets_512_to_1023_bytes_lo ;
   u32 tx_packets_512_to_1023_bytes_hi ;
   u32 tx_packets_1024_to_1518_bytes_lo ;
   u32 tx_packets_1024_to_1518_bytes_hi ;
   u32 tx_packets_1519_to_2047_bytes_lo ;
   u32 tx_packets_1519_to_2047_bytes_hi ;
   u32 tx_packets_2048_to_4095_bytes_lo ;
   u32 tx_packets_2048_to_4095_bytes_hi ;
   u32 tx_packets_4096_to_8191_bytes_lo ;
   u32 tx_packets_4096_to_8191_bytes_hi ;
   u32 tx_packets_8192_to_9216_bytes_lo ;
   u32 tx_packets_8192_to_9216_bytes_hi ;
   u32 tx_lso_packets_lo ;
   u32 tx_lso_packets_hi ;
   u32 rx_packets_lo ;
   u32 rx_packets_hi ;
   u32 rx_unicast_packets_lo ;
   u32 rx_unicast_packets_hi ;
   u32 rx_multicast_packets_lo ;
   u32 rx_multicast_packets_hi ;
   u32 rx_broadcast_packets_lo ;
   u32 rx_broadcast_packets_hi ;
   u32 rx_bytes_lo ;
   u32 rx_bytes_hi ;
   u32 rx_unicast_bytes_lo ;
   u32 rx_unicast_bytes_hi ;
   u32 rx_multicast_bytes_lo ;
   u32 rx_multicast_bytes_hi ;
   u32 rx_broadcast_bytes_lo ;
   u32 rx_broadcast_bytes_hi ;
   u32 rx_unknown_protos ;
   u32 rsvd_69 ;
   u32 rx_discards_lo ;
   u32 rx_discards_hi ;
   u32 rx_errors_lo ;
   u32 rx_errors_hi ;
   u32 rx_crc_errors_lo ;
   u32 rx_crc_errors_hi ;
   u32 rx_alignment_errors_lo ;
   u32 rx_alignment_errors_hi ;
   u32 rx_symbol_errors_lo ;
   u32 rx_symbol_errors_hi ;
   u32 rx_pause_frames_lo ;
   u32 rx_pause_frames_hi ;
   u32 rx_pause_on_frames_lo ;
   u32 rx_pause_on_frames_hi ;
   u32 rx_pause_off_frames_lo ;
   u32 rx_pause_off_frames_hi ;
   u32 rx_frames_too_long_lo ;
   u32 rx_frames_too_long_hi ;
   u32 rx_internal_mac_errors_lo ;
   u32 rx_internal_mac_errors_hi ;
   u32 rx_undersize_packets ;
   u32 rx_oversize_packets ;
   u32 rx_fragment_packets ;
   u32 rx_jabbers ;
   u32 rx_control_frames_lo ;
   u32 rx_control_frames_hi ;
   u32 rx_control_frames_unknown_opcode_lo ;
   u32 rx_control_frames_unknown_opcode_hi ;
   u32 rx_in_range_errors ;
   u32 rx_out_of_range_errors ;
   u32 rx_address_filtered ;
   u32 rx_vlan_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_invalid_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rx_ip_checksum_errors ;
   u32 rx_tcp_checksum_errors ;
   u32 rx_udp_checksum_errors ;
   u32 rx_non_rss_packets ;
   u32 rsvd_111 ;
   u32 rx_ipv4_packets_lo ;
   u32 rx_ipv4_packets_hi ;
   u32 rx_ipv6_packets_lo ;
   u32 rx_ipv6_packets_hi ;
   u32 rx_ipv4_bytes_lo ;
   u32 rx_ipv4_bytes_hi ;
   u32 rx_ipv6_bytes_lo ;
   u32 rx_ipv6_bytes_hi ;
   u32 rx_nic_packets_lo ;
   u32 rx_nic_packets_hi ;
   u32 rx_tcp_packets_lo ;
   u32 rx_tcp_packets_hi ;
   u32 rx_iscsi_packets_lo ;
   u32 rx_iscsi_packets_hi ;
   u32 rx_management_packets_lo ;
   u32 rx_management_packets_hi ;
   u32 rx_switched_unicast_packets_lo ;
   u32 rx_switched_unicast_packets_hi ;
   u32 rx_switched_multicast_packets_lo ;
   u32 rx_switched_multicast_packets_hi ;
   u32 rx_switched_broadcast_packets_lo ;
   u32 rx_switched_broadcast_packets_hi ;
   u32 num_forwards_lo ;
   u32 num_forwards_hi ;
   u32 rx_fifo_overflow ;
   u32 rx_input_fifo_overflow ;
   u32 rx_drops_too_many_frags_lo ;
   u32 rx_drops_too_many_frags_hi ;
   u32 rx_drops_invalid_queue ;
   u32 rsvd_141 ;
   u32 rx_drops_mtu_lo ;
   u32 rx_drops_mtu_hi ;
   u32 rx_packets_64_bytes_lo ;
   u32 rx_packets_64_bytes_hi ;
   u32 rx_packets_65_to_127_bytes_lo ;
   u32 rx_packets_65_to_127_bytes_hi ;
   u32 rx_packets_128_to_255_bytes_lo ;
   u32 rx_packets_128_to_255_bytes_hi ;
   u32 rx_packets_256_to_511_bytes_lo ;
   u32 rx_packets_256_to_511_bytes_hi ;
   u32 rx_packets_512_to_1023_bytes_lo ;
   u32 rx_packets_512_to_1023_bytes_hi ;
   u32 rx_packets_1024_to_1518_bytes_lo ;
   u32 rx_packets_1024_to_1518_bytes_hi ;
   u32 rx_packets_1519_to_2047_bytes_lo ;
   u32 rx_packets_1519_to_2047_bytes_hi ;
   u32 rx_packets_2048_to_4095_bytes_lo ;
   u32 rx_packets_2048_to_4095_bytes_hi ;
   u32 rx_packets_4096_to_8191_bytes_lo ;
   u32 rx_packets_4096_to_8191_bytes_hi ;
   u32 rx_packets_8192_to_9216_bytes_lo ;
   u32 rx_packets_8192_to_9216_bytes_hi ;
};
#line 902 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_pport_stats {
   struct be_cmd_resp_hdr hdr ;
   struct lancer_pport_stats pport_stats ;
};
#line 1059 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_set_eqd {
   u32 eq_id ;
   u32 phase ;
   u32 delay_multiplier ;
};
#line 1173 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct flashrom_params {
   u32 op_code ;
   u32 op_type ;
   u32 data_buf_size ;
   u32 offset ;
};
#line 1181 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_write_flashrom {
   struct be_cmd_req_hdr hdr ;
   struct flashrom_params params ;
   u8 data_buf[32768U] ;
   u8 rsvd[4U] ;
};
#line 1614 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v1 {
   u32 rsvd0[12U] ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rsvd1[10U] ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rsvd2[7U] ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 rsvd3[3U] ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rsvd4[10U] ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rsvd5[3U] ;
};
#line 1652 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v1 {
   struct be_port_rxf_stats_v1 port[4U] ;
   u32 rsvd0[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rsvd1[6U] ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd2[14U] ;
};
#line 1668 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v1 {
   u32 rx_drops_no_fragments[68U] ;
   u32 rsvd[4U] ;
};
#line 1673 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_port_rxf_stats_v2 {
   u32 rsvd0[10U] ;
   u32 roce_bytes_received_lsd ;
   u32 roce_bytes_received_msd ;
   u32 rsvd1[5U] ;
   u32 roce_frames_received ;
   u32 rx_crc_errors ;
   u32 rx_alignment_symbol_errors ;
   u32 rx_pause_frames ;
   u32 rx_priority_pause_frames ;
   u32 rx_control_frames ;
   u32 rx_in_range_errors ;
   u32 rx_out_range_errors ;
   u32 rx_frame_too_long ;
   u32 rx_address_filtered ;
   u32 rx_dropped_too_small ;
   u32 rx_dropped_too_short ;
   u32 rx_dropped_header_too_small ;
   u32 rx_dropped_tcp_length ;
   u32 rx_dropped_runt ;
   u32 rsvd2[10U] ;
   u32 rx_ip_checksum_errs ;
   u32 rx_tcp_checksum_errs ;
   u32 rx_udp_checksum_errs ;
   u32 rsvd3[7U] ;
   u32 rx_switched_unicast_packets ;
   u32 rx_switched_multicast_packets ;
   u32 rx_switched_broadcast_packets ;
   u32 rsvd4[3U] ;
   u32 tx_pauseframes ;
   u32 tx_priority_pauseframes ;
   u32 tx_controlframes ;
   u32 rsvd5[10U] ;
   u32 rxpp_fifo_overflow_drop ;
   u32 rx_input_fifo_overflow_drop ;
   u32 pmem_fifo_overflow_drop ;
   u32 jabber_events ;
   u32 rsvd6[3U] ;
   u32 rx_drops_payload_size ;
   u32 rx_drops_clipped_header ;
   u32 rx_drops_crc ;
   u32 roce_drops_payload_len ;
   u32 roce_drops_crc ;
   u32 rsvd7[19U] ;
};
#line 1719 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_rxf_stats_v2 {
   struct be_port_rxf_stats_v2 port[4U] ;
   u32 rsvd0[2U] ;
   u32 rx_drops_no_pbuf ;
   u32 rx_drops_no_txpb ;
   u32 rx_drops_no_erx_descr ;
   u32 rx_drops_no_tpre_descr ;
   u32 rsvd1[6U] ;
   u32 rx_drops_too_many_frags ;
   u32 rx_drops_invalid_ring ;
   u32 forwarded_packets ;
   u32 rx_drops_mtu ;
   u32 rsvd2[35U] ;
};
#line 1734 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v1 {
   struct be_rxf_stats_v1 rxf ;
   u32 rsvd0[48U] ;
   struct be_erx_stats_v1 erx ;
   struct be_pmem_stats pmem ;
   u32 rsvd1[18U] ;
};
#line 1747 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v1 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v1 hw_stats ;
};
#line 1752 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_erx_stats_v2 {
   u32 rx_drops_no_fragments[136U] ;
   u32 rsvd[3U] ;
};
#line 1757 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_hw_stats_v2 {
   struct be_rxf_stats_v2 rxf ;
   u32 rsvd0[48U] ;
   struct be_erx_stats_v2 erx ;
   struct be_pmem_stats pmem ;
   u32 rsvd1[18U] ;
};
#line 1770 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_stats_v2 {
   struct be_cmd_resp_hdr hdr ;
   struct be_hw_stats_v2 hw_stats ;
};
#line 2546 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
typedef int ldv_func_ret_type;
#line 2567 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
typedef int ldv_func_ret_type___0;
#line 2615 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
typedef struct net_device *ldv_func_ret_type___1;
#line 2627 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
typedef int ldv_func_ret_type___2;
#line 2648 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
typedef int ldv_func_ret_type___3;
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 418 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct mgmt_hba_attribs {
   u8 flashrom_version_string[32U] ;
   u8 manufacturer_name[32U] ;
   u32 supported_modes ;
   u32 rsvd0[3U] ;
   u8 ncsi_ver_string[12U] ;
   u32 default_extended_timeout ;
   u8 controller_model_number[32U] ;
   u8 controller_description[64U] ;
   u8 controller_serial_number[32U] ;
   u8 ip_version_string[32U] ;
   u8 firmware_version_string[32U] ;
   u8 bios_version_string[32U] ;
   u8 redboot_version_string[32U] ;
   u8 driver_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
   u32 functionalities_supported ;
   u16 max_cdblength ;
   u8 asic_revision ;
   u8 generational_guid[16U] ;
   u8 hba_port_count ;
   u16 default_link_down_timeout ;
   u8 iscsi_ver_min_max ;
   u8 multifunction_device ;
   u8 cache_valid ;
   u8 hba_status ;
   u8 max_domains_supported ;
   u8 phy_port ;
   u32 firmware_post_status ;
   u32 hba_mtu[8U] ;
   u32 rsvd1[4U] ;
};
#line 451 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct mgmt_controller_attrib {
   struct mgmt_hba_attribs hba_attribs ;
   u16 pci_vendor_id ;
   u16 pci_device_id ;
   u16 pci_sub_vendor_id ;
   u16 pci_sub_system_id ;
   u8 pci_bus_number ;
   u8 pci_device_number ;
   u8 pci_function_number ;
   u8 interface_type ;
   u64 unique_identifier ;
   u32 rsvd0[5U] ;
};
#line 870 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
struct be_sge {
   u32 pa_lo ;
   u32 pa_hi ;
   u32 len ;
};
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_payload_286 {
   u8 embedded_payload[236U] ;
   struct be_sge sgl[19U] ;
};
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_wrb {
   u32 embedded ;
   u32 payload_length ;
   u32 tag0 ;
   u32 tag1 ;
   u32 rsvd ;
   union __anonunion_payload_286 payload ;
};
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_compl {
   u32 status ;
   u32 tag0 ;
   u32 tag1 ;
   u32 flags ;
};
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_trailer {
   u32 code ;
};
#line 100 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_link_state {
   u8 physical_port ;
   u8 port_link_status ;
   u8 port_duplex ;
   u8 port_speed ;
   u8 port_fault ;
   u8 rsvd0[7U] ;
   struct be_async_event_trailer trailer ;
};
#line 115 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_qos_link_speed {
   u8 physical_port ;
   u8 rsvd[5U] ;
   u16 qos_link_speed ;
   u32 event_tag ;
   struct be_async_event_trailer trailer ;
};
#line 126 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_cos_priority {
   u8 physical_port ;
   u8 available_priority_bmap ;
   u8 reco_default_priority ;
   u8 valid ;
   u8 rsvd0 ;
   u8 event_tag ;
   struct be_async_event_trailer trailer ;
};
#line 139 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_grp5_pvid_state {
   u8 enabled ;
   u8 rsvd0 ;
   u16 tag ;
   u32 event_tag ;
   u32 rsvd1 ;
   struct be_async_event_trailer trailer ;
};
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_async_event_qnq {
   u8 valid ;
   u8 rsvd0 ;
   u16 vlan_tag ;
   u32 event_tag ;
   u8 rsvd1[4U] ;
   struct be_async_event_trailer trailer ;
};
#line 161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_mcc_mailbox {
   struct be_mcc_wrb wrb ;
   struct be_mcc_compl compl ;
};
#line 265 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct phys_addr {
   u32 lo ;
   u32 hi ;
};
#line 301 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 309 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eq_create {
   struct be_cmd_resp_hdr resp_hdr ;
   u16 eq_id ;
   u16 msix_idx ;
};
#line 322 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct mac_addr {
   u16 size_of_struct ;
   u8 addr[6U] ;
};
#line 328 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mac_query {
   struct be_cmd_req_hdr hdr ;
   u8 type ;
   u8 permanent ;
   u16 if_id ;
   u32 pmac_id ;
};
#line 336 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_mac_query {
   struct be_cmd_resp_hdr hdr ;
   struct mac_addr mac ;
};
#line 341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_pmac_add {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u8 mac_address[6U] ;
   u8 rsvd0[2U] ;
};
#line 349 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_pmac_add {
   struct be_cmd_resp_hdr hdr ;
   u32 pmac_id ;
};
#line 354 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_pmac_del {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u32 pmac_id ;
};
#line 403 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_cq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 page_size ;
   u8 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 412 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_cq_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cq_id ;
   u16 rsvd0 ;
};
#line 419 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fat {
   struct be_cmd_req_hdr hdr ;
   u32 fat_operation ;
   u32 read_log_offset ;
   u32 read_log_length ;
   u32 data_buffer_size ;
   u32 data_buffer[1U] ;
};
#line 428 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fat {
   struct be_cmd_resp_hdr hdr ;
   u32 log_size ;
   u32 read_log_length ;
   u32 rsvd[2U] ;
   u32 data_buffer[1U] ;
};
#line 466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mcc_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 cq_id ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 474 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_mcc_ext_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 cq_id ;
   u32 async_event_bitmap[1U] ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 483 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_mcc_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u16 rsvd0 ;
};
#line 489 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eth_tx_create {
   struct be_cmd_req_hdr hdr ;
   u8 num_pages ;
   u8 ulp_num ;
   u16 type ;
   u16 if_id ;
   u8 queue_size ;
   u8 rsvd0 ;
   u32 rsvd1 ;
   u16 cq_id ;
   u16 rsvd2 ;
   u32 rsvd3[13U] ;
   struct phys_addr pages[8U] ;
};
#line 508 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eth_tx_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cid ;
   u16 rid ;
   u32 db_offset ;
   u32 rsvd0[4U] ;
};
#line 516 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_eth_rx_create {
   struct be_cmd_req_hdr hdr ;
   u16 cq_id ;
   u8 frag_size ;
   u8 num_pages ;
   struct phys_addr pages[2U] ;
   u32 interface_id ;
   u16 max_frame_size ;
   u16 rsvd0 ;
   u32 rss_queue ;
};
#line 529 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_eth_rx_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u8 rss_id ;
   u8 rsvd0 ;
};
#line 544 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_q_destroy {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u16 bypass_flush ;
};
#line 566 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_create {
   struct be_cmd_req_hdr hdr ;
   u32 version ;
   u32 capability_flags ;
   u32 enable_flags ;
   u8 mac_addr[6U] ;
   u8 rsvd0 ;
   u8 pmac_invalid ;
   u32 vlan_tag ;
};
#line 588 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_if_create {
   struct be_cmd_resp_hdr hdr ;
   u32 interface_id ;
   u32 pmac_id ;
};
#line 594 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_if_destroy {
   struct be_cmd_req_hdr hdr ;
   u32 interface_id ;
};
#line 888 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct pport_stats_params {
   u16 pport_num ;
   u8 rsvd ;
   u8 reset_stats ;
};
#line 894 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_cmd_params_287 {
   struct pport_stats_params params ;
   u8 rsvd[656U] ;
};
#line 894 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_pport_stats {
   struct be_cmd_req_hdr hdr ;
   union __anonunion_cmd_params_287 cmd_params ;
};
#line 914 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_cntl_addnl_attribs {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd[8U] ;
};
#line 919 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_cntl_addnl_attribs {
   struct be_cmd_resp_hdr hdr ;
   u16 ipl_file_number ;
   u8 ipl_file_version ;
   u8 rsvd0 ;
   u8 on_die_temperature ;
   u8 rsvd1[3U] ;
};
#line 928 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_vlan_config {
   struct be_cmd_req_hdr hdr ;
   u8 interface_id ;
   u8 promiscuous ;
   u8 untagged ;
   u8 num_vlan ;
   u16 normal_vlan[64U] ;
};
#line 937 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct macaddr {
   u8 byte[6U] ;
};
#line 943 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rx_filter {
   struct be_cmd_req_hdr hdr ;
   u32 global_flags_mask ;
   u32 global_flags ;
   u32 if_flags_mask ;
   u32 if_flags ;
   u32 if_id ;
   u32 mcast_num ;
   struct macaddr mcast_mac[64U] ;
};
#line 954 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_link_status {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 977 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_link_status {
   struct be_cmd_resp_hdr hdr ;
   u8 physical_port ;
   u8 mac_duplex ;
   u8 mac_speed ;
   u8 mac_fault ;
   u8 mgmt_mac_duplex ;
   u8 mgmt_mac_speed ;
   u16 link_speed ;
   u8 logical_link_status ;
   u8 rsvd1[3U] ;
};
#line 1027 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fw_version {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[32U] ;
   u8 rsvd1[32U] ;
};
#line 1034 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fw_version {
   struct be_cmd_resp_hdr hdr ;
   u8 firmware_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
};
#line 1040 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_flow_control {
   struct be_cmd_req_hdr hdr ;
   u16 tx_flow_control ;
   u16 rx_flow_control ;
};
#line 1047 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_flow_control {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1053 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_flow_control {
   struct be_cmd_resp_hdr hdr ;
   u16 tx_flow_control ;
   u16 rx_flow_control ;
};
#line 1066 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_modify_eq_delay {
   struct be_cmd_req_hdr hdr ;
   u32 num_eq ;
   struct be_set_eqd set_eqd[32U] ;
};
#line 1077 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_query_fw_cfg {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd[31U] ;
};
#line 1090 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_query_fw_cfg {
   struct be_cmd_resp_hdr hdr ;
   u32 be_config_number ;
   u32 asic_revision ;
   u32 phys_port ;
   u32 function_mode ;
   u32 rsvd[26U] ;
   u32 function_caps ;
};
#line 1107 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_rss_config {
   struct be_cmd_req_hdr hdr ;
   u32 if_id ;
   u16 enable_rss ;
   u16 cpu_table_size_log2 ;
   u32 hash[10U] ;
   u8 cpu_table[128U] ;
   u8 flush ;
   u8 rsvd0[3U] ;
};
#line 1142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_enable_disable_beacon {
   struct be_cmd_req_hdr hdr ;
   u8 port_num ;
   u8 beacon_state ;
   u8 beacon_duration ;
   u8 status_duration ;
};
#line 1160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_beacon_state {
   struct be_cmd_req_hdr hdr ;
   u8 port_num ;
   u8 rsvd0 ;
   u16 rsvd1 ;
};
#line 1167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_beacon_state {
   struct be_cmd_resp_hdr resp_hdr ;
   u8 beacon_state ;
   u8 rsvd0[3U] ;
};
#line 1188 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_read_flash_crc {
   struct be_cmd_req_hdr hdr ;
   struct flashrom_params params ;
   u8 crc[4U] ;
   u8 rsvd[4U] ;
};
#line 1202 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_write_object {
   struct be_cmd_req_hdr hdr ;
   u8 context[4U] ;
   u32 write_offset ;
   u8 object_name[104U] ;
   u32 descriptor_count ;
   u32 buf_len ;
   u32 addr_low ;
   u32 addr_high ;
};
#line 1213 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_write_object {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd1[2U] ;
   u8 status ;
   u8 additional_status ;
   u8 rsvd2[2U] ;
   u32 resp_len ;
   u32 actual_resp_len ;
   u32 actual_write_len ;
   u8 change_status ;
   u8 rsvd3[3U] ;
};
#line 1229 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_req_read_object {
   struct be_cmd_req_hdr hdr ;
   u32 desired_read_len ;
   u32 read_offset ;
   u8 object_name[104U] ;
   u32 descriptor_count ;
   u32 buf_len ;
   u32 addr_low ;
   u32 addr_high ;
};
#line 1248 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct lancer_cmd_resp_read_object {
   u8 opcode ;
   u8 subsystem ;
   u8 rsvd1[2U] ;
   u8 status ;
   u8 additional_status ;
   u8 rsvd2[2U] ;
   u32 resp_len ;
   u32 actual_resp_len ;
   u32 actual_read_len ;
   u32 eof ;
};
#line 1261 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_acpi_wol_magic_config {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0[145U] ;
   u8 magic_mac[6U] ;
   u8 rsvd2[2U] ;
};
#line 1269 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_acpi_wol_magic_config_v1 {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[2U] ;
   u8 query_options ;
   u8 rsvd1[5U] ;
   u32 rsvd2[288U] ;
   u8 magic_mac[6U] ;
   u8 rsvd3[22U] ;
};
#line 1279 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_acpi_wol_magic_config_v1 {
   struct be_cmd_resp_hdr hdr ;
   u8 rsvd0[2U] ;
   u8 wol_settings ;
   u8 rsvd1[5U] ;
   u32 rsvd2[295U] ;
};
#line 1287 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_loopback_test {
   struct be_cmd_req_hdr hdr ;
   u32 loopback_type ;
   u32 num_pkts ;
   u64 pattern ;
   u32 src_port ;
   u32 dest_port ;
   u32 pkt_size ;
};
#line 1307 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_loopback_test {
   struct be_cmd_resp_hdr resp_hdr ;
   u32 status ;
   u32 num_txfer ;
   u32 num_rx ;
   u32 miscomp_off ;
   u32 ticks_compl ;
};
#line 1316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_lmode {
   struct be_cmd_req_hdr hdr ;
   u8 src_port ;
   u8 dest_port ;
   u8 loopback_type ;
   u8 loopback_state ;
};
#line 1329 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_ddrdma_test {
   struct be_cmd_req_hdr hdr ;
   u64 pattern ;
   u32 byte_count ;
   u32 rsvd0 ;
   u8 snd_buff[4096U] ;
   u8 rsvd1[4096U] ;
};
#line 1339 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_ddrdma_test {
   struct be_cmd_resp_hdr hdr ;
   u64 pattern ;
   u32 byte_cnt ;
   u32 snd_err ;
   u8 rsvd0[4096U] ;
   u8 rcv_buff[4096U] ;
};
#line 1348 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_seeprom_read {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[1024U] ;
};
#line 1375 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_phy_info {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd0[24U] ;
};
#line 1405 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_phy_info {
   u16 phy_type ;
   u16 interface_type ;
   u32 misc_params ;
   u16 ext_phy_details ;
   u16 rsvd ;
   u16 auto_speeds_supported ;
   u16 fixed_speeds_supported ;
   u32 future_use[2U] ;
};
#line 1421 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_qos {
   struct be_cmd_req_hdr hdr ;
   u32 valid_bits ;
   u32 max_bps_nic ;
   u32 rsvd[7U] ;
};
#line 1437 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_cntl_attribs {
   struct be_cmd_req_hdr hdr ;
};
#line 1442 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_cntl_attribs {
   struct be_cmd_resp_hdr hdr ;
   struct mgmt_controller_attrib attribs ;
};
#line 1447 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_func_cap {
   struct be_cmd_req_hdr hdr ;
   u32 valid_cap_flags ;
   u32 cap_flags ;
   u8 rsvd[212U] ;
};
#line 1458 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_set_func_cap {
   struct be_cmd_resp_hdr hdr ;
   u32 valid_cap_flags ;
   u32 cap_flags ;
   u8 rsvd[212U] ;
};
#line 1479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_priv_map {
   u8 opcode ;
   u8 subsystem ;
   u32 priv_mask ;
};
#line 1489 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_fn_privileges {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1494 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_fn_privileges {
   struct be_cmd_resp_hdr hdr ;
   u32 privilege_mask ;
};
#line 1499 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_fn_privileges {
   struct be_cmd_req_hdr hdr ;
   u32 privileges ;
   u32 privileges_lancer ;
};
#line 1505 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_mac_list {
   struct be_cmd_req_hdr hdr ;
   u8 mac_type ;
   u8 perm_override ;
   u16 iface_id ;
   u32 mac_id ;
   u32 rsvd[3U] ;
};
#line 1516 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct __anonstruct_s_mac_id_289 {
   u8 rsvd[2U] ;
   u32 mac_id ;
};
#line 1516 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
union __anonunion_mac_addr_id_288 {
   u8 macaddr[6U] ;
   struct __anonstruct_s_mac_id_289 s_mac_id ;
};
#line 1516 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct get_list_macaddr {
   u16 mac_addr_size ;
   union __anonunion_mac_addr_id_288 mac_addr_id ;
};
#line 1527 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_mac_list {
   struct be_cmd_resp_hdr hdr ;
   struct get_list_macaddr fd_macaddr ;
   struct get_list_macaddr macid_macaddr ;
   u8 true_mac_count ;
   u8 pseudo_mac_count ;
   u8 mac_list_size ;
   u8 rsvd ;
   struct get_list_macaddr macaddr_list[64U] ;
};
#line 1539 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_mac_list {
   struct be_cmd_req_hdr hdr ;
   u8 mac_count ;
   u8 rsvd1 ;
   u16 rsvd2 ;
   struct macaddr mac[64U] ;
};
#line 1565 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_hsw_config {
   struct be_cmd_req_hdr hdr ;
   u8 context[20U] ;
};
#line 1592 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_hsw_config {
   struct be_cmd_req_hdr hdr ;
   u8 context[4U] ;
};
#line 1597 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_hsw_config {
   struct be_cmd_resp_hdr hdr ;
   u8 context[16U] ;
   u32 rsvd ;
};
#line 1603 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_port_name {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0 ;
};
#line 1609 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_port_name {
   struct be_cmd_req_hdr hdr ;
   u8 port_name[4U] ;
};
#line 1775 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_mode {
   u8 mode ;
   u8 rsvd0 ;
   u16 port_mask ;
   u32 dbg_lvl ;
   u64 fun_mask ;
};
#line 1790 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct ext_fat_modules {
   u8 modules_str[32U] ;
   u32 modules_id ;
   u32 num_modes ;
   struct ext_fat_mode trace_lvl[4U] ;
};
#line 1797 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_fat_conf_params {
   u32 max_log_entries ;
   u32 log_entry_size ;
   u8 log_type ;
   u8 max_log_funs ;
   u8 max_log_ports ;
   u8 rsvd0 ;
   u32 supp_modes ;
   u32 num_modules ;
   struct ext_fat_modules module[27U] ;
};
#line 1809 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_ext_fat_caps {
   struct be_cmd_req_hdr hdr ;
   u32 parameter_type ;
};
#line 1819 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_ext_fat_caps {
   struct be_cmd_req_hdr hdr ;
   struct be_fat_conf_params set_params ;
};
#line 1824 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_res_desc_hdr {
   u8 desc_type ;
   u8 desc_len ;
};
#line 1844 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_pcie_res_desc {
   struct be_res_desc_hdr hdr ;
   u8 rsvd0 ;
   u8 flags ;
   u16 rsvd1 ;
   u8 pf_num ;
   u8 rsvd2 ;
   u32 rsvd3 ;
   u8 sriov_state ;
   u8 pf_state ;
   u8 pf_type ;
   u8 rsvd4 ;
   u16 num_vfs ;
   u16 rsvd5 ;
   u32 rsvd6[17U] ;
};
#line 1861 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_nic_res_desc {
   struct be_res_desc_hdr hdr ;
   u8 rsvd1 ;
   u8 flags ;
   u8 vf_num ;
   u8 rsvd2 ;
   u8 pf_num ;
   u8 rsvd3 ;
   u16 unicast_mac_count ;
   u8 rsvd4[6U] ;
   u16 mcc_count ;
   u16 vlan_count ;
   u16 mcast_mac_count ;
   u16 txq_count ;
   u16 rq_count ;
   u16 rssq_count ;
   u16 lro_count ;
   u16 cq_count ;
   u16 toe_conn_count ;
   u16 eq_count ;
   u32 rsvd5 ;
   u32 cap_flags ;
   u8 link_param ;
   u8 rsvd6[3U] ;
   u32 bw_min ;
   u32 bw_max ;
   u8 acpi_params ;
   u8 wol_param ;
   u16 rsvd7 ;
   u32 rsvd8[7U] ;
};
#line 1893 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_func_config {
   struct be_cmd_req_hdr hdr ;
};
#line 1897 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_func_config {
   struct be_cmd_resp_hdr hdr ;
   u32 desc_count ;
   u8 func_param[23232U] ;
};
#line 1903 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_profile_config {
   struct be_cmd_req_hdr hdr ;
   u8 rsvd ;
   u8 type ;
   u16 rsvd1 ;
};
#line 1911 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_profile_config {
   struct be_cmd_resp_hdr hdr ;
   u32 desc_count ;
   u8 func_param[23232U] ;
};
#line 1917 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_set_profile_config {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
   u32 desc_count ;
   struct be_nic_res_desc nic_desc ;
};
#line 1928 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_active_profile {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd ;
};
#line 1933 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_active_profile {
   struct be_cmd_resp_hdr hdr ;
   u16 active_profile_id ;
   u16 next_profile_id ;
};
#line 1939 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_enable_disable_vf {
   struct be_cmd_req_hdr hdr ;
   u8 enable ;
   u8 rsvd[3U] ;
};
#line 1945 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_intr_set {
   struct be_cmd_req_hdr hdr ;
   u8 intr_enabled ;
   u8 rsvd[3U] ;
};
#line 1956 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_if_desc {
   u32 if_id ;
   u32 cap_flags ;
   u32 en_flags ;
};
#line 1963 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_req_get_iface_list {
   struct be_cmd_req_hdr hdr ;
};
#line 1967 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_get_iface_list {
   struct be_cmd_req_hdr hdr ;
   u32 if_cnt ;
   struct be_if_desc if_desc ;
};
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 1356 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_cmd_resp_seeprom_read {
   struct be_cmd_req_hdr hdr ;
   u8 seeprom_data[1024U] ;
};
#line 2095 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
struct be_ethtool_stat {
   char desc[32U] ;
   int type ;
   int size ;
   int offset ;
};
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 553 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
enum be_interrupt_mode {
    BE_INTERRUPT_MODE_MSIX = 0,
    BE_INTERRUPT_MODE_INTX = 1,
    BE_INTERRUPT_MODE_MSI = 2
} ;
#line 559 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct __anonstruct_msix_284 {
   int num_vectors ;
   int start_vector ;
   u32 vector_list[32U] ;
};
#line 559 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_hw.h"
struct be_dev_info {
   u8 *db ;
   u64 unmapped_db ;
   u32 db_page_size ;
   u32 db_total_size ;
   u64 dpp_unmapped_addr ;
   u32 dpp_unmapped_len ;
   struct pci_dev *pdev ;
   struct net_device *netdev ;
   u8 mac_addr[6U] ;
   u32 dev_family ;
   enum be_interrupt_mode intr_mode ;
   struct __anonstruct_msix_284 msix ;
};
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.h"
struct ocrdma_driver {
   unsigned char name[32U] ;
   struct ocrdma_dev *(*add)(struct be_dev_info * ) ;
   void (*remove)(struct ocrdma_dev * ) ;
   void (*state_change_handler)(struct ocrdma_dev * , u32  ) ;
};
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kthread.h"
struct kthread_work;
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   wait_queue_head_t done ;
   struct kthread_worker *worker ;
};
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};
#line 152
struct spi_message;
#line 153
struct spi_transfer;
#line 210 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   struct completion xfer_completion ;
   int (*prepare_transfer_hardware)(struct spi_master * ) ;
   int (*transfer_one_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_transfer_hardware)(struct spi_master * ) ;
   int (*prepare_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_message)(struct spi_master * , struct spi_message * ) ;
   void (*set_cs)(struct spi_device * , bool  ) ;
   int (*transfer_one)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   int *cs_gpios ;
};
#line 475 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spi/spi.h"
struct spi_transfer {
   void const   *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   unsigned int cs_change : 1 ;
   unsigned int tx_nbits : 3 ;
   unsigned int rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};
#line 595 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned int is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/map.h"
typedef int ldv_map;
#line 27
struct usb_device;
#line 7 "thread.c"
struct ldv_thread;
#line 8 "thread.c"
struct ldv_thread_set {
   int number ;
   struct ldv_thread **threads ;
};
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/thread.h"
struct ldv_thread {
   int identifier ;
   void (*function)(void * ) ;
};
#line 1 "<compiler builtins>"
void __builtin_prefetch(void const   *  , ...) ;
#line 1
long __builtin_expect(long exp , long c ) ;
#line 4 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_atomic_add(int i , atomic_t *v ) ;
#line 5
void ldv_atomic_sub(int i , atomic_t *v ) ;
#line 7
void ldv_atomic_inc(atomic_t *v ) ;
#line 8
void ldv_atomic_dec(atomic_t *v ) ;
#line 17
void *ldv_dev_get_drvdata(struct device  const  *dev ) ;
#line 18
int ldv_dev_set_drvdata(struct device *dev , void *data ) ;
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/common.h"
void ldv_assume(int expression ) ;
#line 31
void ldv_stop(void) ;
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_check_return_value_probe(int retval ) ;
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/ldv/common.h"
void ldv_initialize(void) ;
#line 47
int ldv_post_init(int init_ret_val ) ;
#line 58
extern void ldv_pre_probe(void) ;
#line 67
int ldv_post_probe(int probe_ret_val ) ;
#line 70
static int ldv_ldv_post_probe_30(int ldv_func_arg1 ) ;
#line 79
int ldv_filter_err_code(int ret_val ) ;
#line 105
extern int ldv_pre_register_netdev(void) ;
#line 119
void ldv_check_final_state(void) ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/ldv/irq.h"
extern void ldv_switch_to_interrupt_context(void) ;
#line 42
extern void ldv_switch_to_process_context(void) ;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.h"
void ldv_free(void *s ) ;
#line 34
void *ldv_xmalloc(size_t size ) ;
#line 37
extern void *external_allocated_data(void) ;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/export.h"
extern struct module __this_module ;
#line 358 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 79
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 81
  return;
}
}
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 116
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 118
  return;
}
}
#line 206 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 208
  __asm__  volatile   ("":);
#line 208
  return (0);

#line 208
  return (1);
}
}
#line 310 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 312
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 481 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 483
  bitpos = -1;
#line 489
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 492
  return (bitpos + 1);
}
}
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 105 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bitops.h"
__inline static __u32 rol32(__u32 word , unsigned int shift ) 
{ 


  {
#line 107
  return ((word << shift) | (word >> (8UL * sizeof(word) - (unsigned long )shift)));
}
}
#line 132 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 388
extern int sprintf(char * , char const   *  , ...) ;
#line 403
extern int sscanf(char const   * , char const   *  , ...) ;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 26
  list->next = list;
#line 27
  list->prev = list;
#line 28
  return;
}
}
#line 88 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 13 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/getorder.h"
__inline static int __get_order(unsigned long size ) 
{ 
  int order ;

  {
  {
#line 17
  size = size - 1UL;
#line 18
  size = size >> 12;
#line 22
  order = fls64((__u64 )size);
  }
#line 24
  return (order);
}
}
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/string_64.h"
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 55
extern void *memset(void * , int  , size_t  ) ;
#line 58
extern void *memmove(void * , void const   * , size_t  ) ;
#line 60
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 113 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , int  ) ;
#line 276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , int nbits ) 
{ 
  int tmp___0 ;

  {
  {
#line 280
  tmp___0 = __bitmap_weight(src, nbits);
  }
#line 280
  return (tmp___0);
}
}
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 80
extern struct cpumask  const  * const  cpu_online_mask ;
#line 459 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 461
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), nr_cpu_ids);
  }
#line 461
  return ((unsigned int )tmp);
}
}
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/paravirt.h"
extern int ( /* missing proto */  __builtin_unreachable)() ;
#line 802 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  {
#line 804
  __edi = __edi;
#line 804
  __esi = __esi;
#line 804
  __edx = __edx;
#line 804
  __ecx = __ecx;
#line 804
  __eax = __eax;
#line 804
  tmp = __builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  }
#line 804
  if (tmp != 0L) {
    {
#line 804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
#line 804
    __builtin_unreachable();
    }
  } else {

  }
#line 804
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 804
  __ret = __eax;
#line 804
  return (__ret);
}
}
#line 155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 


  {
#line 26
  return ((int )*((int volatile   *)(& v->counter)));
}
}
#line 48
__inline static void atomic_add(int i , atomic_t *v ) ;
#line 66
__inline static void atomic_sub(int i , atomic_t *v ) ;
#line 97
__inline static void atomic_inc(atomic_t *v ) ;
#line 113
__inline static void atomic_dec(atomic_t *v ) ;
#line 279 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 8 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bottom_half.h"
extern void __local_bh_disable_ip(unsigned long  , unsigned int  ) ;
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bottom_half.h"
__inline static void local_bh_disable(void) 
{ 


  {
  {
#line 19
  __local_bh_disable_ip((unsigned long )((void *)0), 512U);
  }
#line 21
  return;
}
}
#line 23
extern void __local_bh_enable_ip(unsigned long  , unsigned int  ) ;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/bottom_half.h"
__inline static void local_bh_enable(void) 
{ 


  {
  {
#line 32
  __local_bh_enable_ip((unsigned long )((void *)0), 512U);
  }
#line 34
  return;
}
}
#line 93 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 28
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 39
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 40
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 292
  return (& lock->__annonCompField19.rlock);
}
}
#line 301 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  {
#line 303
  _raw_spin_lock(& lock->__annonCompField19.rlock);
  }
#line 304
  return;
}
}
#line 306 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
  {
#line 308
  _raw_spin_lock_bh(& lock->__annonCompField19.rlock);
  }
#line 309
  return;
}
}
#line 341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  {
#line 343
  _raw_spin_unlock(& lock->__annonCompField19.rlock);
  }
#line 344
  return;
}
}
#line 346 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
  {
#line 348
  _raw_spin_unlock_bh(& lock->__annonCompField19.rlock);
  }
#line 349
  return;
}
}
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 73 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/completion.h"
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
  {
#line 75
  x->done = 0U;
#line 76
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
  }
#line 78
  return;
}
}
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 295
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 303
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 192
extern void __init_work(struct work_struct * , int  ) ;
#line 375
extern struct workqueue_struct *system_wq ;
#line 466
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 484
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 518 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 522
  tmp = queue_delayed_work_on(8192, wq, dwork, delay);
  }
#line 522
  return (tmp);
}
}
#line 591 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 594
  tmp = queue_delayed_work(system_wq, dwork, delay);
  }
#line 594
  return (tmp);
}
}
#line 6 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mmdebug.h"
extern void dump_page(struct page * , char * ) ;
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 72
extern void pci_iounmap(struct pci_dev * , void * ) ;
#line 17 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/pci_iomap.h"
extern void *pci_iomap(struct pci_dev * , int  , unsigned long  ) ;
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 174 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/percpu.h"
extern void __bad_size_call_parameter(void) ;
#line 334 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/gfp.h"
extern struct page *alloc_pages_current(gfp_t  , unsigned int  ) ;
#line 337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/gfp.h"
__inline static struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 
  struct page *tmp ;

  {
  {
#line 339
  tmp = alloc_pages_current(gfp_mask, order);
  }
#line 339
  return (tmp);
}
}
#line 916 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
static void *ldv_dev_get_drvdata_16(struct device  const  *dev ) ;
#line 921
static int ldv_dev_set_drvdata_17(struct device *dev , void *data ) ;
#line 1029
extern int dev_err(struct device  const  * , char const   *  , ...) ;
#line 1031
extern int dev_warn(struct device  const  * , char const   *  , ...) ;
#line 1035
extern int _dev_info(struct device  const  * , char const   *  , ...) ;
#line 10 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 46 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 50 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/delay.h"
__inline static void ssleep(unsigned int seconds ) 
{ 


  {
  {
#line 52
  msleep(seconds * 1000U);
  }
#line 53
  return;
}
}
#line 337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/page-flags.h"
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
  {
#line 337
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
  }
#line 337
  return (tmp);
}
}
#line 477 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm.h"
extern bool __get_page_tail(struct page * ) ;
#line 479 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm.h"
__inline static void get_page(struct page *page ) 
{ 
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 481
  tmp___1 = PageTail((struct page  const  *)page);
#line 481
  tmp___2 = __builtin_expect(tmp___1 != 0, 0L);
  }
#line 481
  if (tmp___2 != 0L) {
    {
#line 482
    tmp = __get_page_tail(page);
#line 482
    tmp___0 = __builtin_expect((long )tmp, 1L);
    }
#line 482
    if (tmp___0 != 0L) {
#line 483
      return;
    } else {

    }
  } else {

  }
  {
#line 488
  tmp___3 = atomic_read((atomic_t const   *)(& page->__annonCompField43.__annonCompField42.__annonCompField41._count));
#line 488
  tmp___4 = __builtin_expect(tmp___3 <= 0, 0L);
  }
#line 488
  if (tmp___4 != 0L) {
    {
#line 488
    dump_page(page, (char *)0);
#line 488
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/mm.h"),
                         "i" (488), "i" (12UL));
#line 488
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 489
  atomic_inc(& page->__annonCompField43.__annonCompField42.__annonCompField41._count);
  }
#line 490
  return;
}
}
#line 535
extern void put_page(struct page * ) ;
#line 888 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 890
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 302
extern void *__kmalloc(size_t  , gfp_t  ) ;
#line 560 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slab.h"
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 562
  if (size != 0UL && n > 0xffffffffffffffffUL / size) {
#line 563
    return ((void *)0);
  } else {

  }
  {
#line 564
  tmp = __kmalloc(n * size, flags);
  }
#line 564
  return (tmp);
}
}
#line 573 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/slab.h"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 575
  tmp = kmalloc_array(n, size, flags | 32768U);
  }
#line 575
  return (tmp);
}
}
#line 63 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 65
  return ((unsigned int )dma_direction <= 2U);
}
}
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 72
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL) && *(dev->dma_mask) != 0ULL);
}
}
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 42
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
  {
#line 37
  tmp = __builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
  }
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 10 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 19
  if (tmp___1 != 0L) {
    {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
#line 19
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
  }
#line 26
  return (addr);
}
}
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 36
  if (tmp___1 != 0L) {
    {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
#line 36
    __builtin_unreachable();
    }
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
    {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
    }
  } else {

  }
  {
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
  }
#line 40
  return;
}
}
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_page(struct device *dev , struct page *page , size_t offset ,
                                        size_t size , enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 75
  tmp = get_dma_ops(dev);
#line 75
  ops = tmp;
#line 78
  tmp___0 = lowmem_page_address((struct page  const  *)page);
#line 78
  kmemcheck_mark_initialized(tmp___0 + offset, (unsigned int )size);
#line 79
  tmp___1 = valid_dma_direction((int )dir);
#line 79
  tmp___2 = __builtin_expect(tmp___1 == 0, 0L);
  }
#line 79
  if (tmp___2 != 0L) {
    {
#line 79
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (79), "i" (12UL));
#line 79
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 80
  addr = (*(ops->map_page))(dev, page, offset, size, dir, (struct dma_attrs *)0);
#line 81
  debug_dma_map_page(dev, page, offset, size, (int )dir, addr, 0);
  }
#line 83
  return (addr);
}
}
#line 86 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_page(struct device *dev , dma_addr_t addr , size_t size ,
                                    enum dma_data_direction dir ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 89
  tmp = get_dma_ops(dev);
#line 89
  ops = tmp;
#line 91
  tmp___0 = valid_dma_direction((int )dir);
#line 91
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 91
  if (tmp___1 != 0L) {
    {
#line 91
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (91), "i" (12UL));
#line 91
    __builtin_unreachable();
    }
  } else {

  }
#line 92
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
    {
#line 93
    (*(ops->unmap_page))(dev, addr, size, dir, (struct dma_attrs *)0);
    }
  } else {

  }
  {
#line 94
  debug_dma_unmap_page(dev, addr, size, (int )dir, 0);
  }
#line 95
  return;
}
}
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
  {
#line 49
  tmp = get_dma_ops(dev);
#line 49
  ops = tmp;
#line 50
  debug_dma_mapping_error(dev, dma_addr);
  }
#line 51
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
    {
#line 52
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
    }
#line 52
    return (tmp___0);
  } else {

  }
#line 54
  return (dma_addr == 0ULL);
}
}
#line 60
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 103 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
  }
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
  }
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
  {
#line 145
  tmp___0 = is_device_dma_capable(dev);
  }
#line 145
  if (tmp___0 == 0) {
#line 146
    return ((void *)0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return ((void *)0);
  } else {

  }
  {
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  }
#line 155
  return (memory);
}
}
#line 160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 166
  if (tmp___1 != 0L) {
    {
#line 166
    warn_slowpath_null("/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/dma-mapping.h",
                       166);
    }
  } else {

  }
  {
#line 166
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
    {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
    }
  } else {

  }
#line 174
  return;
}
}
#line 91 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 93
  tmp = dma_supported(dev, mask);
  }
#line 93
  if (tmp == 0) {
#line 94
    return (-5);
  } else {

  }
#line 95
  dev->coherent_dma_mask = mask;
#line 96
  return (0);
}
}
#line 106 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dma-mapping.h"
__inline static int dma_set_mask_and_coherent(struct device *dev , u64 mask ) 
{ 
  int rc ;
  int tmp ;

  {
  {
#line 108
  tmp = dma_set_mask(dev, mask);
#line 108
  rc = tmp;
  }
#line 109
  if (rc == 0) {
    {
#line 110
    dma_set_coherent_mask(dev, mask);
    }
  } else {

  }
#line 111
  return (rc);
}
}
#line 163 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flag ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 166
  tmp = dma_alloc_attrs(dev, size, dma_handle, flag | 32768U, (struct dma_attrs *)0);
#line 166
  ret = tmp;
  }
#line 168
  return (ret);
}
}
#line 187 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static unsigned int skb_frag_size(skb_frag_t const   *frag ) 
{ 


  {
#line 189
  return ((unsigned int )frag->size);
}
}
#line 192 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void skb_frag_size_set(skb_frag_t *frag , unsigned int size ) 
{ 


  {
#line 194
  frag->size = size;
#line 195
  return;
}
}
#line 197 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void skb_frag_size_add(skb_frag_t *frag , int delta ) 
{ 


  {
#line 199
  frag->size = frag->size + (__u32 )delta;
#line 200
  return;
}
}
#line 651
extern void kfree_skb(struct sk_buff * ) ;
#line 654
extern void consume_skb(struct sk_buff * ) ;
#line 685
extern struct sk_buff *skb_clone(struct sk_buff * , gfp_t  ) ;
#line 689
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
#line 697
extern int skb_pad(struct sk_buff * , int  ) ;
#line 759 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void skb_set_hash(struct sk_buff *skb , __u32 hash , enum pkt_hash_types type ) 
{ 


  {
#line 761
  skb->l4_rxhash = (unsigned int )type == 3U;
#line 762
  skb->rxhash = hash;
#line 763
  return;
}
}
#line 798 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static unsigned char *skb_end_pointer(struct sk_buff  const  *skb ) 
{ 


  {
#line 800
  return ((unsigned char *)skb->head + (unsigned long )skb->end);
}
}
#line 949 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static int skb_header_cloned(struct sk_buff  const  *skb ) 
{ 
  int dataref ;
  unsigned char *tmp ;

  {
#line 953
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 0U) {
#line 954
    return (0);
  } else {

  }
  {
#line 956
  tmp = skb_end_pointer(skb);
#line 956
  dataref = atomic_read((atomic_t const   *)(& ((struct skb_shared_info *)tmp)->dataref));
#line 957
  dataref = (dataref & 65535) - (dataref >> 16);
  }
#line 958
  return (dataref != 1);
}
}
#line 983 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static int skb_shared(struct sk_buff  const  *skb ) 
{ 
  int tmp ;

  {
  {
#line 985
  tmp = atomic_read(& skb->users);
  }
#line 985
  return (tmp != 1);
}
}
#line 1001 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static struct sk_buff *skb_share_check(struct sk_buff *skb , gfp_t pri ) 
{ 
  struct sk_buff *nskb ;
  struct sk_buff *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 1003
  if ((pri & 16U) != 0U) {
    {
#line 1003
    __might_sleep("include/linux/skbuff.h", 1003, 0);
    }
  } else {

  }
  {
#line 1004
  tmp___1 = skb_shared((struct sk_buff  const  *)skb);
  }
#line 1004
  if (tmp___1 != 0) {
    {
#line 1005
    tmp = skb_clone(skb, pri);
#line 1005
    nskb = tmp;
#line 1007
    tmp___0 = __builtin_expect((unsigned long )nskb != (unsigned long )((struct sk_buff *)0),
                               1L);
    }
#line 1007
    if (tmp___0 != 0L) {
      {
#line 1008
      consume_skb(skb);
      }
    } else {
      {
#line 1010
      kfree_skb(skb);
      }
    }
#line 1011
    skb = nskb;
  } else {

  }
#line 1013
  return (skb);
}
}
#line 1369 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
#line 1371
  return ((unsigned int )skb->data_len != 0U);
}
}
#line 1374 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static unsigned int skb_headlen(struct sk_buff  const  *skb ) 
{ 


  {
#line 1376
  return ((unsigned int )skb->len - (unsigned int )skb->data_len);
}
}
#line 1461 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void skb_reset_tail_pointer(struct sk_buff *skb ) 
{ 


  {
#line 1463
  skb->tail = (sk_buff_data_t )((long )skb->data) - (sk_buff_data_t )((long )skb->head);
#line 1464
  return;
}
}
#line 1466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void skb_set_tail_pointer(struct sk_buff *skb , int const   offset ) 
{ 


  {
  {
#line 1468
  skb_reset_tail_pointer(skb);
#line 1469
  skb->tail = skb->tail + (sk_buff_data_t )offset;
  }
#line 1470
  return;
}
}
#line 1504
extern unsigned char *skb_push(struct sk_buff * , unsigned int  ) ;
#line 1556 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static unsigned int skb_headroom(struct sk_buff  const  *skb ) 
{ 


  {
#line 1558
  return ((unsigned int )((long )skb->data) - (unsigned int )((long )skb->head));
}
}
#line 1686 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static unsigned char *skb_network_header(struct sk_buff  const  *skb ) 
{ 


  {
#line 1688
  return ((unsigned char *)skb->head + (unsigned long )skb->network_header);
}
}
#line 1834
extern int ___pskb_trim(struct sk_buff * , unsigned int  ) ;
#line 1836 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void __skb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  bool tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1838
  tmp___0 = skb_is_nonlinear((struct sk_buff  const  *)skb);
#line 1838
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1838
  if (tmp___1 != 0L) {
    {
#line 1839
    __ret_warn_on = 1;
#line 1839
    tmp = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 1839
    if (tmp != 0L) {
      {
#line 1839
      warn_slowpath_null("include/linux/skbuff.h", 1839);
      }
    } else {

    }
    {
#line 1839
    __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 1840
    return;
  } else {

  }
  {
#line 1842
  skb->len = len;
#line 1843
  skb_set_tail_pointer(skb, (int const   )len);
  }
#line 1844
  return;
}
}
#line 1848 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static int __pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;

  {
#line 1850
  if (skb->data_len != 0U) {
    {
#line 1851
    tmp = ___pskb_trim(skb, len);
    }
#line 1851
    return (tmp);
  } else {

  }
  {
#line 1852
  __skb_trim(skb, len);
  }
#line 1853
  return (0);
}
}
#line 1856 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static int pskb_trim(struct sk_buff *skb , unsigned int len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1858
  if (len < skb->len) {
    {
#line 1858
    tmp = __pskb_trim(skb, len);
#line 1858
    tmp___0 = tmp;
    }
  } else {
#line 1858
    tmp___0 = 0;
  }
#line 1858
  return (tmp___0);
}
}
#line 1933
extern struct sk_buff *__netdev_alloc_skb(struct net_device * , unsigned int  , gfp_t  ) ;
#line 1969 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                            unsigned int length ,
                                                            gfp_t gfp ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  {
#line 1972
  tmp = __netdev_alloc_skb(dev, length, gfp);
#line 1972
  skb = tmp;
  }
#line 1976
  return (skb);
}
}
#line 1979 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev ,
                                                          unsigned int length ) 
{ 
  struct sk_buff *tmp ;

  {
  {
#line 1982
  tmp = __netdev_alloc_skb_ip_align(dev, length, 32U);
  }
#line 1982
  return (tmp);
}
}
#line 2046 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static struct page *skb_frag_page(skb_frag_t const   *frag ) 
{ 


  {
#line 2048
  return ((struct page *)frag->page.p);
}
}
#line 2132 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void __skb_frag_set_page(skb_frag_t *frag , struct page *page ) 
{ 


  {
#line 2134
  frag->page.p = page;
#line 2135
  return;
}
}
#line 2145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void skb_frag_set_page(struct sk_buff *skb , int f , struct page *page ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 2148
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 2148
  __skb_frag_set_page((skb_frag_t *)(& ((struct skb_shared_info *)tmp)->frags) + (unsigned long )f,
                      page);
  }
#line 2149
  return;
}
}
#line 2164 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static dma_addr_t skb_frag_dma_map(struct device *dev , skb_frag_t const   *frag ,
                                            size_t offset , size_t size , enum dma_data_direction dir ) 
{ 
  struct page *tmp ;
  dma_addr_t tmp___0 ;

  {
  {
#line 2169
  tmp = skb_frag_page(frag);
#line 2169
  tmp___0 = dma_map_page(dev, tmp, (size_t )frag->page_offset + offset, size, dir);
  }
#line 2169
  return (tmp___0);
}
}
#line 2193 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static int __skb_cow(struct sk_buff *skb , unsigned int headroom , int cloned ) 
{ 
  int delta ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int _max1 ;
  int _max2 ;
  int _max1___0 ;
  int _max2___0 ;
  int tmp___1 ;

  {
  {
#line 2196
  delta = 0;
#line 2198
  tmp___0 = skb_headroom((struct sk_buff  const  *)skb);
  }
#line 2198
  if (headroom > tmp___0) {
    {
#line 2199
    tmp = skb_headroom((struct sk_buff  const  *)skb);
#line 2199
    delta = (int )(headroom - tmp);
    }
  } else {

  }
#line 2201
  if ((delta | cloned) != 0) {
    {
#line 2202
    _max1 = 32;
#line 2202
    _max2 = 64;
#line 2202
    _max1___0 = 32;
#line 2202
    _max2___0 = 64;
#line 2202
    tmp___1 = pskb_expand_head(skb, (delta + ((_max1 > _max2 ? _max1 : _max2) + -1)) & - (_max1___0 > _max2___0 ? _max1___0 : _max2___0),
                               0, 32U);
    }
#line 2202
    return (tmp___1);
  } else {

  }
#line 2204
  return (0);
}
}
#line 2234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static int skb_cow_head(struct sk_buff *skb , unsigned int headroom ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2236
  tmp = skb_header_cloned((struct sk_buff  const  *)skb);
#line 2236
  tmp___0 = __skb_cow(skb, headroom, tmp);
  }
#line 2236
  return (tmp___0);
}
}
#line 2250 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static int skb_padto(struct sk_buff *skb , unsigned int len ) 
{ 
  unsigned int size ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 2252
  size = skb->len;
#line 2253
  tmp = __builtin_expect(size >= len, 1L);
  }
#line 2253
  if (tmp != 0L) {
#line 2254
    return (0);
  } else {

  }
  {
#line 2255
  tmp___0 = skb_pad(skb, (int )(len - size));
  }
#line 2255
  return (tmp___0);
}
}
#line 2784 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static u16 skb_get_queue_mapping(struct sk_buff  const  *skb ) 
{ 


  {
#line 2786
  return ((u16 )skb->queue_mapping);
}
}
#line 2794 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void skb_record_rx_queue(struct sk_buff *skb , u16 rx_queue ) 
{ 


  {
#line 2796
  skb->queue_mapping = (unsigned int )rx_queue + 1U;
#line 2797
  return;
}
}
#line 2854 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static bool skb_is_gso(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 2856
  tmp = skb_end_pointer(skb);
  }
#line 2856
  return ((unsigned int )((struct skb_shared_info *)tmp)->gso_size != 0U);
}
}
#line 2860 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static bool skb_is_gso_v6(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 2862
  tmp = skb_end_pointer(skb);
  }
#line 2862
  return (((int )((struct skb_shared_info *)tmp)->gso_type & 16) != 0);
}
}
#line 2896 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/skbuff.h"
__inline static void skb_checksum_none_assert(struct sk_buff  const  *skb ) 
{ 


  {
#line 2898
  return;
}
}
#line 77 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/u64_stats_sync.h"
__inline static void u64_stats_update_begin(struct u64_stats_sync *syncp ) 
{ 


  {
#line 79
  return;
}
}
#line 122 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/u64_stats_sync.h"
__inline static unsigned int u64_stats_fetch_begin_bh(struct u64_stats_sync  const  *syncp ) 
{ 


  {
#line 130
  return (0U);
}
}
#line 134 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/u64_stats_sync.h"
__inline static bool u64_stats_fetch_retry_bh(struct u64_stats_sync  const  *syncp ,
                                              unsigned int start ) 
{ 


  {
#line 143
  return (0);
}
}
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 397 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
extern void __napi_schedule(struct napi_struct * ) ;
#line 399 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static bool napi_disable_pending(struct napi_struct *n ) 
{ 
  int tmp ;

  {
  {
#line 401
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& n->state));
  }
#line 401
  return (tmp != 0);
}
}
#line 413 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static bool napi_schedule_prep(struct napi_struct *n ) 
{ 
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 415
  tmp = napi_disable_pending(n);
  }
#line 415
  if (tmp) {
#line 415
    tmp___0 = 0;
  } else {
#line 415
    tmp___0 = 1;
  }
#line 415
  if (tmp___0) {
    {
#line 415
    tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
    }
#line 415
    if (tmp___1 == 0) {
#line 415
      tmp___2 = 1;
    } else {
#line 415
      tmp___2 = 0;
    }
  } else {
#line 415
    tmp___2 = 0;
  }
#line 415
  return ((bool )tmp___2);
}
}
#line 426 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void napi_schedule(struct napi_struct *n ) 
{ 
  bool tmp ;

  {
  {
#line 428
  tmp = napi_schedule_prep(n);
  }
#line 428
  if ((int )tmp) {
    {
#line 429
    __napi_schedule(n);
    }
  } else {

  }
#line 430
  return;
}
}
#line 449
extern void napi_complete(struct napi_struct * ) ;
#line 466
extern void napi_hash_add(struct napi_struct * ) ;
#line 475
extern void napi_hash_del(struct napi_struct * ) ;
#line 484 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void napi_disable(struct napi_struct *n ) 
{ 
  int tmp ;

  {
  {
#line 486
  __might_sleep("include/linux/netdevice.h", 486, 0);
#line 487
  set_bit(1L, (unsigned long volatile   *)(& n->state));
  }
#line 488
  goto ldv_37708;
  ldv_37707: 
  {
#line 489
  msleep(1U);
  }
  ldv_37708: 
  {
#line 488
  tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& n->state));
  }
#line 488
  if (tmp != 0) {
#line 490
    goto ldv_37707;
  } else {

  }
  {
#line 490
  clear_bit(1L, (unsigned long volatile   *)(& n->state));
  }
#line 491
  return;
}
}
#line 500 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void napi_enable(struct napi_struct *n ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  {
#line 502
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& n->state));
#line 502
  tmp___0 = __builtin_expect(tmp == 0, 0L);
  }
#line 502
  if (tmp___0 != 0L) {
    {
#line 502
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/netdevice.h"),
                         "i" (502), "i" (12UL));
#line 502
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 503
  __asm__  volatile   ("": : : "memory");
#line 504
  clear_bit(0L, (unsigned long volatile   *)(& n->state));
  }
#line 505
  return;
}
}
#line 1537 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static struct netdev_queue *netdev_get_tx_queue(struct net_device  const  *dev ,
                                                         unsigned int index ) 
{ 


  {
#line 1540
  return ((struct netdev_queue *)dev->_tx + (unsigned long )index);
}
}
#line 1603 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void *netdev_priv(struct net_device  const  *dev ) 
{ 


  {
#line 1605
  return ((void *)dev + 3200U);
}
}
#line 1634
extern void netif_napi_add(struct net_device * , struct napi_struct * , int (*)(struct napi_struct * ,
                                                                                int  ) ,
                           int  ) ;
#line 1643
extern void netif_napi_del(struct napi_struct * ) ;
#line 1877
extern void free_netdev(struct net_device * ) ;
#line 1880
static void ldv_free_netdev_24(struct net_device *ldv_func_arg1 ) ;
#line 1884
static void ldv_free_netdev_27(struct net_device *ldv_func_arg1 ) ;
#line 1896
extern int netpoll_trap(void) ;
#line 2058
extern void __netif_schedule(struct Qdisc * ) ;
#line 2074 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_start_queue(struct netdev_queue *dev_queue ) 
{ 


  {
  {
#line 2076
  clear_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
  }
#line 2077
  return;
}
}
#line 2090 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_start_all_queues(struct net_device *dev ) 
{ 
  unsigned int i ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
#line 2094
  i = 0U;
#line 2094
  goto ldv_38603;
  ldv_38602: 
  {
#line 2095
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2095
  txq = tmp;
#line 2096
  netif_tx_start_queue(txq);
#line 2094
  i = i + 1U;
  }
  ldv_38603: ;
#line 2094
  if (i < dev->num_tx_queues) {
#line 2096
    goto ldv_38602;
  } else {

  }

#line 2101
  return;
}
}
#line 2126 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_stop_queue(struct netdev_queue *dev_queue ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 2128
  __ret_warn_on = (unsigned long )dev_queue == (unsigned long )((struct netdev_queue *)0);
#line 2128
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 2128
  if (tmp != 0L) {
    {
#line 2128
    warn_slowpath_null("include/linux/netdevice.h", 2128);
    }
  } else {

  }
  {
#line 2128
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 2128
  if (tmp___0 != 0L) {
    {
#line 2129
    printk("\016netif_stop_queue() cannot be called before register_netdev()\n");
    }
#line 2130
    return;
  } else {

  }
  {
#line 2132
  set_bit(0L, (unsigned long volatile   *)(& dev_queue->state));
  }
#line 2133
  return;
}
}
#line 2157 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static bool netif_tx_queue_stopped(struct netdev_queue  const  *dev_queue ) 
{ 
  int tmp ;

  {
  {
#line 2159
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev_queue->state));
  }
#line 2159
  return (tmp != 0);
}
}
#line 2307 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static bool netif_running(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
  {
#line 2309
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& dev->state));
  }
#line 2309
  return (tmp != 0);
}
}
#line 2340 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void netif_stop_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;

  {
  {
#line 2342
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2342
  txq = tmp;
#line 2344
  tmp___0 = netpoll_trap();
  }
#line 2344
  if (tmp___0 != 0) {
#line 2345
    return;
  } else {

  }
  {
#line 2347
  netif_tx_stop_queue(txq);
  }
#line 2348
  return;
}
}
#line 2357 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static bool __netif_subqueue_stopped(struct net_device  const  *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  bool tmp___0 ;

  {
  {
#line 2360
  tmp = netdev_get_tx_queue(dev, (unsigned int )queue_index);
#line 2360
  txq = tmp;
#line 2362
  tmp___0 = netif_tx_queue_stopped((struct netdev_queue  const  *)txq);
  }
#line 2362
  return (tmp___0);
}
}
#line 2378 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void netif_wake_subqueue(struct net_device *dev , u16 queue_index ) 
{ 
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2380
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, (unsigned int )queue_index);
#line 2380
  txq = tmp;
#line 2382
  tmp___0 = netpoll_trap();
  }
#line 2382
  if (tmp___0 != 0) {
#line 2383
    return;
  } else {

  }
  {
#line 2385
  tmp___1 = test_and_set_bit(0L, (unsigned long volatile   *)(& txq->state));
  }
#line 2385
  if (tmp___1 != 0) {
    {
#line 2386
    __netif_schedule(txq->qdisc);
    }
  } else {

  }
#line 2387
  return;
}
}
#line 2422
extern int netif_set_real_num_tx_queues(struct net_device * , unsigned int  ) ;
#line 2425
extern int netif_set_real_num_rx_queues(struct net_device * , unsigned int  ) ;
#line 2464
extern int netif_get_num_default_rss_queues(void) ;
#line 2472
extern void __dev_kfree_skb_any(struct sk_buff * , enum skb_free_reason  ) ;
#line 2503 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 


  {
  {
#line 2505
  __dev_kfree_skb_any(skb, 1);
  }
#line 2506
  return;
}
}
#line 2515
extern int netif_receive_skb(struct sk_buff * ) ;
#line 2518
extern struct sk_buff *napi_get_frags(struct napi_struct * ) ;
#line 2519
extern gro_result_t napi_gro_frags(struct napi_struct * ) ;
#line 2610
extern void netif_carrier_on(struct net_device * ) ;
#line 2612
extern void netif_carrier_off(struct net_device * ) ;
#line 2680
extern void netif_device_detach(struct net_device * ) ;
#line 2682
extern void netif_device_attach(struct net_device * ) ;
#line 2733 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void __netif_tx_lock(struct netdev_queue *txq , int cpu ) 
{ 


  {
  {
#line 2735
  spin_lock(& txq->_xmit_lock);
#line 2736
  txq->xmit_lock_owner = cpu;
  }
#line 2737
  return;
}
}
#line 2753 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void __netif_tx_unlock(struct netdev_queue *txq ) 
{ 


  {
  {
#line 2755
  txq->xmit_lock_owner = -1;
#line 2756
  spin_unlock(& txq->_xmit_lock);
  }
#line 2757
  return;
}
}
#line 2840 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void netif_tx_disable(struct net_device *dev ) 
{ 
  unsigned int i ;
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct netdev_queue *txq ;
  struct netdev_queue *tmp ;

  {
  {
#line 2845
  local_bh_disable();
#line 2846
  __vpp_verify = (void const   *)0;
  }
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2___0;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4___1;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8___2;
  } else {

  }
#line 2846
  goto switch_default___3;
  case_1: /* CIL Label */ ;
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1___0;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8;
  } else {

  }
#line 2846
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 2846
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 2846
  goto ldv_39162;
  case_2: /* CIL Label */ 
#line 2846
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2846
  goto ldv_39162;
  case_4: /* CIL Label */ 
#line 2846
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2846
  goto ldv_39162;
  case_8: /* CIL Label */ 
#line 2846
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 2846
  goto ldv_39162;
  switch_default: /* CIL Label */ 
  {
#line 2846
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_39162: 
#line 2846
  pscr_ret__ = pfo_ret__;
#line 2846
  goto ldv_39168;
  case_2___0: /* CIL Label */ ;
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1___1;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2___1;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4___0;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8___0;
  } else {

  }
#line 2846
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
#line 2846
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 2846
  goto ldv_39172;
  case_2___1: /* CIL Label */ 
#line 2846
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2846
  goto ldv_39172;
  case_4___0: /* CIL Label */ 
#line 2846
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2846
  goto ldv_39172;
  case_8___0: /* CIL Label */ 
#line 2846
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 2846
  goto ldv_39172;
  switch_default___0: /* CIL Label */ 
  {
#line 2846
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  ldv_39172: 
#line 2846
  pscr_ret__ = pfo_ret_____0;
#line 2846
  goto ldv_39168;
  case_4___1: /* CIL Label */ ;
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1___2;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2___2;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4___2;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8___1;
  } else {

  }
#line 2846
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
#line 2846
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 2846
  goto ldv_39181;
  case_2___2: /* CIL Label */ 
#line 2846
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2846
  goto ldv_39181;
  case_4___2: /* CIL Label */ 
#line 2846
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2846
  goto ldv_39181;
  case_8___1: /* CIL Label */ 
#line 2846
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 2846
  goto ldv_39181;
  switch_default___1: /* CIL Label */ 
  {
#line 2846
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  ldv_39181: 
#line 2846
  pscr_ret__ = pfo_ret_____1;
#line 2846
  goto ldv_39168;
  case_8___2: /* CIL Label */ ;
  {
#line 2846
  if (4UL == 1UL) {
#line 2846
    goto case_1___3;
  } else {

  }
#line 2846
  if (4UL == 2UL) {
#line 2846
    goto case_2___3;
  } else {

  }
#line 2846
  if (4UL == 4UL) {
#line 2846
    goto case_4___3;
  } else {

  }
#line 2846
  if (4UL == 8UL) {
#line 2846
    goto case_8___3;
  } else {

  }
#line 2846
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
#line 2846
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 2846
  goto ldv_39190;
  case_2___3: /* CIL Label */ 
#line 2846
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2846
  goto ldv_39190;
  case_4___3: /* CIL Label */ 
#line 2846
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2846
  goto ldv_39190;
  case_8___3: /* CIL Label */ 
#line 2846
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 2846
  goto ldv_39190;
  switch_default___2: /* CIL Label */ 
  {
#line 2846
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  ldv_39190: 
#line 2846
  pscr_ret__ = pfo_ret_____2;
#line 2846
  goto ldv_39168;
  switch_default___3: /* CIL Label */ 
  {
#line 2846
  __bad_size_call_parameter();
  }
#line 2846
  goto ldv_39168;
  switch_break: /* CIL Label */ ;
  }
  ldv_39168: 
#line 2846
  cpu = pscr_ret__;
#line 2847
  i = 0U;
#line 2847
  goto ldv_39200;
  ldv_39199: 
  {
#line 2848
  tmp = netdev_get_tx_queue((struct net_device  const  *)dev, i);
#line 2848
  txq = tmp;
#line 2850
  __netif_tx_lock(txq, cpu);
#line 2851
  netif_tx_stop_queue(txq);
#line 2852
  __netif_tx_unlock(txq);
#line 2847
  i = i + 1U;
  }
  ldv_39200: ;
#line 2847
  if (i < dev->num_tx_queues) {
#line 2849
    goto ldv_39199;
  } else {

  }
  {
#line 2854
  local_bh_enable();
  }
#line 2855
  return;
}
}
#line 2903
extern int register_netdev(struct net_device * ) ;
#line 2906
static int ldv_register_netdev_26(struct net_device *ldv_func_arg1 ) ;
#line 2908
extern void unregister_netdev(struct net_device * ) ;
#line 2911
static void ldv_unregister_netdev_23(struct net_device *ldv_func_arg1 ) ;
#line 3130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static void netif_set_gso_max_size(struct net_device *dev , unsigned int size ) 
{ 


  {
#line 3133
  dev->gso_max_size = size;
#line 3134
  return;
}
}
#line 824 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 830
extern int pci_bus_write_config_dword(struct pci_bus * , unsigned int  , int  , u32  ) ;
#line 842 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
  {
#line 845
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
#line 845
  return (tmp);
}
}
#line 855 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev  const  *dev , int where ,
                                           u32 val ) 
{ 
  int tmp ;

  {
  {
#line 858
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
  }
#line 858
  return (tmp);
}
}
#line 902
extern int pci_enable_device(struct pci_dev * ) ;
#line 919
extern void pci_disable_device(struct pci_dev * ) ;
#line 922
extern void pci_set_master(struct pci_dev * ) ;
#line 975
extern int pci_save_state(struct pci_dev * ) ;
#line 976
extern void pci_restore_state(struct pci_dev * ) ;
#line 987
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 988
extern pci_power_t pci_choose_state(struct pci_dev * , pm_message_t  ) ;
#line 991
extern int __pci_enable_wake(struct pci_dev * , pci_power_t  , bool  , bool  ) ;
#line 1000 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
__inline static int pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool enable ) 
{ 
  int tmp ;

  {
  {
#line 1003
  tmp = __pci_enable_wake(dev, state, 0, (int )enable);
  }
#line 1003
  return (tmp);
}
}
#line 1040
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
#line 1042
extern void pci_release_regions(struct pci_dev * ) ;
#line 1085
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1089
static int ldv___pci_register_driver_28(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                        char const   *ldv_func_arg3 ) ;
#line 1098
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1101
static void ldv_pci_unregister_driver_29(struct pci_driver *ldv_func_arg1 ) ;
#line 1165
extern int pci_enable_msix(struct pci_dev * , struct msix_entry * , int  ) ;
#line 1167
extern void pci_disable_msix(struct pci_dev * ) ;
#line 1407 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  {
#line 1409
  tmp = ldv_dev_get_drvdata_16((struct device  const  *)(& pdev->dev));
  }
#line 1409
  return (tmp);
}
}
#line 1412 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
  {
#line 1414
  ldv_dev_set_drvdata_17(& pdev->dev, data);
  }
#line 1415
  return;
}
}
#line 1598
extern int pci_enable_sriov(struct pci_dev * , int  ) ;
#line 1599
extern void pci_disable_sriov(struct pci_dev * ) ;
#line 1601
extern int pci_num_vf(struct pci_dev * ) ;
#line 1602
extern int pci_vfs_assigned(struct pci_dev * ) ;
#line 1604
extern int pci_sriov_get_totalvfs(struct pci_dev * ) ;
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/etherdevice.h"
extern __be16 eth_type_trans(struct sk_buff * , struct net_device * ) ;
#line 47
extern int eth_validate_addr(struct net_device * ) ;
#line 49
extern struct net_device *alloc_etherdev_mqs(int  , unsigned int  , unsigned int  ) ;
#line 53
static struct net_device *ldv_alloc_etherdev_mqs_25(int ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                                    unsigned int ldv_func_arg3 ) ;
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/etherdevice.h"
__inline static bool is_zero_ether_addr(u8 const   *addr ) 
{ 


  {
#line 92
  return (((unsigned int )*((u32 const   *)addr) | (unsigned int )*((u16 const   *)addr + 4U)) == 0U);
}
}
#line 107 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/etherdevice.h"
__inline static bool is_multicast_ether_addr(u8 const   *addr ) 
{ 


  {
#line 109
  return (((int )*addr & 1) != 0);
}
}
#line 160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/etherdevice.h"
__inline static bool is_valid_ether_addr(u8 const   *addr ) 
{ 
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 164
  tmp = is_multicast_ether_addr(addr);
  }
#line 164
  if (tmp) {
#line 164
    tmp___0 = 0;
  } else {
#line 164
    tmp___0 = 1;
  }
#line 164
  if (tmp___0) {
    {
#line 164
    tmp___1 = is_zero_ether_addr(addr);
    }
#line 164
    if (tmp___1) {
#line 164
      tmp___2 = 0;
    } else {
#line 164
      tmp___2 = 1;
    }
#line 164
    if (tmp___2) {
#line 164
      tmp___3 = 1;
    } else {
#line 164
      tmp___3 = 0;
    }
  } else {
#line 164
    tmp___3 = 0;
  }
#line 164
  return ((bool )tmp___3);
}
}
#line 266 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/etherdevice.h"
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
#line 269
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
#line 272
  return (fold == 0U);
}
}
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/rtnetlink.h"
extern void rtnl_lock(void) ;
#line 22
extern void rtnl_unlock(void) ;
#line 87
extern int ndo_dflt_bridge_getlink(struct sk_buff * , u32  , u32  , struct net_device * ,
                                   u16  ) ;
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
extern struct nlattr *nla_find(struct nlattr  const  * , int  , int  ) ;
#line 289 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static void *nlmsg_data(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 291
  return ((void *)nlh + 16U);
}
}
#line 298 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static int nlmsg_len(struct nlmsghdr  const  *nlh ) 
{ 


  {
#line 300
  return ((int )((unsigned int )nlh->nlmsg_len - 16U));
}
}
#line 308 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static struct nlattr *nlmsg_attrdata(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  unsigned char *data ;
  void *tmp ;

  {
  {
#line 311
  tmp = nlmsg_data(nlh);
#line 311
  data = (unsigned char *)tmp;
  }
#line 312
  return ((struct nlattr *)(data + ((unsigned long )((unsigned int )hdrlen + 3U) & 4294967292UL)));
}
}
#line 320 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static int nlmsg_attrlen(struct nlmsghdr  const  *nlh , int hdrlen ) 
{ 
  int tmp ;

  {
  {
#line 322
  tmp = nlmsg_len(nlh);
  }
#line 322
  return ((int )((unsigned int )tmp - (((unsigned int )hdrlen + 3U) & 4294967292U)));
}
}
#line 384 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static struct nlattr *nlmsg_find_attr(struct nlmsghdr  const  *nlh , int hdrlen ,
                                               int attrtype ) 
{ 
  int tmp ;
  struct nlattr *tmp___0 ;
  struct nlattr *tmp___1 ;

  {
  {
#line 387
  tmp = nlmsg_attrlen(nlh, hdrlen);
#line 387
  tmp___0 = nlmsg_attrdata(nlh, hdrlen);
#line 387
  tmp___1 = nla_find((struct nlattr  const  *)tmp___0, tmp, attrtype);
  }
#line 387
  return (tmp___1);
}
}
#line 659 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static int nla_type(struct nlattr  const  *nla ) 
{ 


  {
#line 661
  return ((int )nla->nla_type & -49153);
}
}
#line 668 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static void *nla_data(struct nlattr  const  *nla ) 
{ 


  {
#line 670
  return ((void *)nla + 4U);
}
}
#line 677 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static int nla_len(struct nlattr  const  *nla ) 
{ 


  {
#line 679
  return ((int )nla->nla_len + -4);
}
}
#line 687 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static int nla_ok(struct nlattr  const  *nla , int remaining ) 
{ 


  {
#line 689
  return ((remaining > 3 && (unsigned int )((unsigned short )nla->nla_len) > 3U) && (int )nla->nla_len <= remaining);
}
}
#line 702 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr  const  *nla , int *remaining ) 
{ 
  int totlen ;

  {
#line 704
  totlen = ((int )nla->nla_len + 3) & -4;
#line 706
  *remaining = *remaining - totlen;
#line 707
  return ((struct nlattr *)nla + (unsigned long )totlen);
}
}
#line 983 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/netlink.h"
__inline static u16 nla_get_u16(struct nlattr  const  *nla ) 
{ 
  void *tmp ;

  {
  {
#line 985
  tmp = nla_data(nla);
  }
#line 985
  return (*((u16 *)tmp));
}
}
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/unaligned/packed_struct.h"
__inline static u32 __get_unaligned_cpu32(void const   *p ) 
{ 
  struct __una_u32  const  *ptr ;

  {
#line 18
  ptr = (struct __una_u32  const  *)p;
#line 19
  return ((u32 )ptr->x);
}
}
#line 70 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/jhash.h"
__inline static u32 jhash(void const   *key , u32 length , u32 initval ) 
{ 
  u32 a ;
  u32 b ;
  u32 c ;
  u8 const   *k ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  __u32 tmp___13 ;
  __u32 tmp___14 ;

  {
#line 73
  k = (u8 const   *)key;
#line 76
  c = (length + initval) + 3735928559U;
#line 76
  b = c;
#line 76
  a = b;
#line 79
  goto ldv_45714;
  ldv_45713: 
  {
#line 80
  tmp = __get_unaligned_cpu32((void const   *)k);
#line 80
  a = a + tmp;
#line 81
  tmp___0 = __get_unaligned_cpu32((void const   *)k + 4U);
#line 81
  b = b + tmp___0;
#line 82
  tmp___1 = __get_unaligned_cpu32((void const   *)k + 8U);
#line 82
  c = c + tmp___1;
#line 83
  a = a - c;
#line 83
  tmp___2 = rol32(c, 4U);
#line 83
  a = a ^ tmp___2;
#line 83
  c = c + b;
#line 83
  b = b - a;
#line 83
  tmp___3 = rol32(a, 6U);
#line 83
  b = b ^ tmp___3;
#line 83
  a = a + c;
#line 83
  c = c - b;
#line 83
  tmp___4 = rol32(b, 8U);
#line 83
  c = c ^ tmp___4;
#line 83
  b = b + a;
#line 83
  a = a - c;
#line 83
  tmp___5 = rol32(c, 16U);
#line 83
  a = a ^ tmp___5;
#line 83
  c = c + b;
#line 83
  b = b - a;
#line 83
  tmp___6 = rol32(a, 19U);
#line 83
  b = b ^ tmp___6;
#line 83
  a = a + c;
#line 83
  c = c - b;
#line 83
  tmp___7 = rol32(b, 4U);
#line 83
  c = c ^ tmp___7;
#line 83
  b = b + a;
#line 84
  length = length - 12U;
#line 85
  k = k + 12UL;
  }
  ldv_45714: ;
#line 79
  if (length > 12U) {
#line 81
    goto ldv_45713;
  } else {

  }

  {
#line 90
  if (length == 12U) {
#line 90
    goto case_12;
  } else {

  }
#line 91
  if (length == 11U) {
#line 91
    goto case_11;
  } else {

  }
#line 92
  if (length == 10U) {
#line 92
    goto case_10;
  } else {

  }
#line 93
  if (length == 9U) {
#line 93
    goto case_9;
  } else {

  }
#line 94
  if (length == 8U) {
#line 94
    goto case_8;
  } else {

  }
#line 95
  if (length == 7U) {
#line 95
    goto case_7;
  } else {

  }
#line 96
  if (length == 6U) {
#line 96
    goto case_6;
  } else {

  }
#line 97
  if (length == 5U) {
#line 97
    goto case_5;
  } else {

  }
#line 98
  if (length == 4U) {
#line 98
    goto case_4;
  } else {

  }
#line 99
  if (length == 3U) {
#line 99
    goto case_3;
  } else {

  }
#line 100
  if (length == 2U) {
#line 100
    goto case_2;
  } else {

  }
#line 101
  if (length == 1U) {
#line 101
    goto case_1;
  } else {

  }
#line 103
  if (length == 0U) {
#line 103
    goto case_0;
  } else {

  }
#line 89
  goto switch_break;
  case_12: /* CIL Label */ 
#line 90
  c = c + ((unsigned int )*(k + 11UL) << 24);
  case_11: /* CIL Label */ 
#line 91
  c = c + ((unsigned int )*(k + 10UL) << 16);
  case_10: /* CIL Label */ 
#line 92
  c = c + ((unsigned int )*(k + 9UL) << 8);
  case_9: /* CIL Label */ 
#line 93
  c = c + (u32 )*(k + 8UL);
  case_8: /* CIL Label */ 
#line 94
  b = b + ((unsigned int )*(k + 7UL) << 24);
  case_7: /* CIL Label */ 
#line 95
  b = b + ((unsigned int )*(k + 6UL) << 16);
  case_6: /* CIL Label */ 
#line 96
  b = b + ((unsigned int )*(k + 5UL) << 8);
  case_5: /* CIL Label */ 
#line 97
  b = b + (u32 )*(k + 4UL);
  case_4: /* CIL Label */ 
#line 98
  a = a + ((unsigned int )*(k + 3UL) << 24);
  case_3: /* CIL Label */ 
#line 99
  a = a + ((unsigned int )*(k + 2UL) << 16);
  case_2: /* CIL Label */ 
#line 100
  a = a + ((unsigned int )*(k + 1UL) << 8);
  case_1: /* CIL Label */ 
  {
#line 101
  a = a + (u32 )*k;
#line 102
  c = c ^ b;
#line 102
  tmp___8 = rol32(b, 14U);
#line 102
  c = c - tmp___8;
#line 102
  a = a ^ c;
#line 102
  tmp___9 = rol32(c, 11U);
#line 102
  a = a - tmp___9;
#line 102
  b = b ^ a;
#line 102
  tmp___10 = rol32(a, 25U);
#line 102
  b = b - tmp___10;
#line 102
  c = c ^ b;
#line 102
  tmp___11 = rol32(b, 16U);
#line 102
  c = c - tmp___11;
#line 102
  a = a ^ c;
#line 102
  tmp___12 = rol32(c, 4U);
#line 102
  a = a - tmp___12;
#line 102
  b = b ^ a;
#line 102
  tmp___13 = rol32(a, 14U);
#line 102
  b = b - tmp___13;
#line 102
  c = c ^ b;
#line 102
  tmp___14 = rol32(b, 24U);
#line 102
  c = c - tmp___14;
  }
  case_0: /* CIL Label */ ;
#line 104
  goto ldv_45729;
  switch_break: /* CIL Label */ ;
  }
  ldv_45729: ;
#line 107
  return (c);
}
}
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
  }
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_18(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 141
__inline static int ldv_request_irq_20(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 150
extern void free_irq(unsigned int  , void * ) ;
#line 153
static void ldv_free_irq_19(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 157
static void ldv_free_irq_21(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 161
static void ldv_free_irq_22(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ip.h"
__inline static struct iphdr *ip_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 25
  tmp = skb_network_header(skb);
  }
#line 25
  return ((struct iphdr *)tmp);
}
}
#line 67 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ipv6.h"
__inline static struct ipv6hdr *ipv6_hdr(struct sk_buff  const  *skb ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 69
  tmp = skb_network_header(skb);
  }
#line 69
  return ((struct ipv6hdr *)tmp);
}
}
#line 285 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/if_vlan.h"
__inline static struct sk_buff *vlan_insert_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                u16 vlan_tci ) 
{ 
  struct vlan_ethhdr *veth ;
  int tmp ;
  unsigned char *tmp___0 ;
  __u16 tmp___1 ;

  {
  {
#line 290
  tmp = skb_cow_head(skb, 4U);
  }
#line 290
  if (tmp < 0) {
    {
#line 291
    kfree_skb(skb);
    }
#line 292
    return ((struct sk_buff *)0);
  } else {

  }
  {
#line 294
  tmp___0 = skb_push(skb, 4U);
#line 294
  veth = (struct vlan_ethhdr *)tmp___0;
#line 297
  memmove((void *)skb->data, (void const   *)skb->data + 4U, 12UL);
#line 298
  skb->mac_header = (unsigned int )skb->mac_header + 65532U;
#line 301
  veth->h_vlan_proto = vlan_proto;
#line 304
  tmp___1 = __fswab16((int )vlan_tci);
#line 304
  veth->h_vlan_TCI = tmp___1;
  }
#line 306
  return (skb);
}
}
#line 320 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/if_vlan.h"
__inline static struct sk_buff *__vlan_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                               u16 vlan_tci ) 
{ 


  {
  {
#line 323
  skb = vlan_insert_tag(skb, (int )vlan_proto, (int )vlan_tci);
  }
#line 324
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
#line 325
    skb->protocol = vlan_proto;
  } else {

  }
#line 326
  return (skb);
}
}
#line 337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/if_vlan.h"
__inline static struct sk_buff *__vlan_hwaccel_put_tag(struct sk_buff *skb , __be16 vlan_proto ,
                                                       u16 vlan_tci ) 
{ 


  {
#line 341
  skb->vlan_proto = vlan_proto;
#line 342
  skb->vlan_tci = (__u16 )((unsigned int )vlan_tci | 4096U);
#line 343
  return (skb);
}
}
#line 42 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/firmware.h"
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
#line 49
extern void release_firmware(struct firmware  const  * ) ;
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static char *nic_name(struct pci_dev *pdev ) 
{ 


  {
  {
#line 65
  if ((int )pdev->device == 1792) {
#line 65
    goto case_1792;
  } else {

  }
#line 67
  if ((int )pdev->device == 1808) {
#line 67
    goto case_1808;
  } else {

  }
#line 69
  if ((int )pdev->device == 57888) {
#line 69
    goto case_57888;
  } else {

  }
#line 70
  if ((int )pdev->device == 57896) {
#line 70
    goto case_57896;
  } else {

  }
#line 72
  if ((int )pdev->device == 545) {
#line 72
    goto case_545;
  } else {

  }
#line 74
  if ((int )pdev->device == 1824) {
#line 74
    goto case_1824;
  } else {

  }
#line 75
  if ((int )pdev->device == 1832) {
#line 75
    goto case_1832;
  } else {

  }
#line 77
  goto switch_default;
  case_1792: /* CIL Label */ ;
#line 66
  return ((char *)"Emulex OneConnect");
  case_1808: /* CIL Label */ ;
#line 68
  return ((char *)"Emulex OneConnect(be3)");
  case_57888: /* CIL Label */ ;
  case_57896: /* CIL Label */ ;
#line 71
  return ((char *)"Emulex OneConnect(Lancer)");
  case_545: /* CIL Label */ ;
#line 73
  return ((char *)"Emulex BladeEngine3");
  case_1824: /* CIL Label */ ;
  case_1832: /* CIL Label */ ;
#line 76
  return ((char *)"Emulex OneConnect(Skyhawk)");
  switch_default: /* CIL Label */ ;
#line 78
  return ((char *)"Emulex BladeEngine2");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 140 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 MODULO(u16 val , u16 limit ) 
{ 
  long tmp ;

  {
  {
#line 142
  tmp = __builtin_expect(((int )limit & ((int )limit + -1)) != 0, 0L);
  }
#line 142
  if (tmp != 0L) {
    {
#line 142
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be.h"),
                         "i" (142), "i" (12UL));
#line 142
    __builtin_unreachable();
    }
  } else {

  }
#line 143
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_adv(u16 *index , u16 val , u16 limit ) 
{ 
  u32 tmp ;

  {
  {
#line 148
  tmp = MODULO((int )*index + (int )val, (int )limit);
#line 148
  *index = (u16 )tmp;
  }
#line 149
  return;
}
}
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_inc(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
  {
#line 153
  tmp = MODULO((int )((unsigned int )*index + 1U), (int )limit);
#line 153
  *index = (u16 )tmp;
  }
#line 154
  return;
}
}
#line 156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_head_node(struct be_queue_info *q ) 
{ 


  {
#line 158
  return (q->dma_mem.va + (unsigned long )((int )q->head * (int )q->entry_size));
}
}
#line 161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_tail_node(struct be_queue_info *q ) 
{ 


  {
#line 163
  return (q->dma_mem.va + (unsigned long )((int )q->tail * (int )q->entry_size));
}
}
#line 171 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_head_inc(struct be_queue_info *q ) 
{ 


  {
  {
#line 173
  index_inc(& q->head, (int )q->len);
  }
#line 174
  return;
}
}
#line 181 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void queue_tail_inc(struct be_queue_info *q ) 
{ 


  {
  {
#line 183
  index_inc(& q->tail, (int )q->len);
  }
#line 184
  return;
}
}
#line 530 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static u16 be_max_qs(struct be_adapter *adapter ) 
{ 
  u16 num ;
  u16 __max1 ;
  u16 __max2 ;
  u16 _min1 ;
  u16 _min2 ;
  u16 __min1 ;
  u16 __min2 ;
  unsigned int tmp ;

  {
  {
#line 533
  __max1 = adapter->res.max_rss_qs;
#line 533
  __max2 = 1U;
#line 533
  num = (u16 )((int )__max1 > (int )__max2 ? __max1 : __max2);
#line 535
  _min1 = num;
#line 535
  _min2 = adapter->res.max_evt_qs;
#line 535
  num = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 536
  __min1 = num;
#line 536
  tmp = cpumask_weight(cpu_online_mask);
#line 536
  __min2 = (u16 )tmp;
  }
#line 536
  return ((u16 )((int )__min1 < (int )__min2 ? __min1 : __min2));
}
}
#line 556
struct ethtool_ops  const  be_ethtool_ops ;
#line 604 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 amap_mask(u32 bitsize ) 
{ 


  {
#line 606
  return (bitsize != 32U ? (u32 )((1 << (int )bitsize) + -1) : 4294967295U);
}
}
#line 610 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void amap_set(void *ptr , u32 dw_offset , u32 mask , u32 offset ,
                              u32 value ) 
{ 
  u32 *dw ;

  {
#line 612
  dw = (u32 *)ptr + (unsigned long )dw_offset;
#line 613
  *dw = *dw & ~ (mask << (int )offset);
#line 614
  *dw = *dw | ((mask & value) << (int )offset);
#line 615
  return;
}
}
#line 624 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static u32 amap_get(void *ptr , u32 dw_offset , u32 mask , u32 offset ) 
{ 
  u32 *dw ;

  {
#line 626
  dw = (u32 *)ptr;
#line 627
  return (mask & (*(dw + (unsigned long )dw_offset) >> (int )offset));
}
}
#line 638 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void swap_dws(void *wrb , int len ) 
{ 


  {
#line 640
  return;
}
}
#line 651 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static u8 is_tcp_pkt(struct sk_buff *skb ) 
{ 
  u8 val ;
  struct iphdr *tmp ;
  struct ipv6hdr *tmp___0 ;
  struct iphdr *tmp___1 ;
  struct iphdr *tmp___2 ;

  {
  {
#line 653
  val = 0U;
#line 655
  tmp___2 = ip_hdr((struct sk_buff  const  *)skb);
  }
#line 655
  if ((unsigned int )*((unsigned char *)tmp___2 + 0UL) == 64U) {
    {
#line 656
    tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 656
    val = (unsigned int )tmp->protocol == 6U;
    }
  } else {
    {
#line 657
    tmp___1 = ip_hdr((struct sk_buff  const  *)skb);
    }
#line 657
    if ((unsigned int )*((unsigned char *)tmp___1 + 0UL) == 96U) {
      {
#line 658
      tmp___0 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 658
      val = (unsigned int )tmp___0->nexthdr == 6U;
      }
    } else {

    }
  }
#line 660
  return (val);
}
}
#line 663 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static u8 is_udp_pkt(struct sk_buff *skb ) 
{ 
  u8 val ;
  struct iphdr *tmp ;
  struct ipv6hdr *tmp___0 ;
  struct iphdr *tmp___1 ;
  struct iphdr *tmp___2 ;

  {
  {
#line 665
  val = 0U;
#line 667
  tmp___2 = ip_hdr((struct sk_buff  const  *)skb);
  }
#line 667
  if ((unsigned int )*((unsigned char *)tmp___2 + 0UL) == 64U) {
    {
#line 668
    tmp = ip_hdr((struct sk_buff  const  *)skb);
#line 668
    val = (unsigned int )tmp->protocol == 17U;
    }
  } else {
    {
#line 669
    tmp___1 = ip_hdr((struct sk_buff  const  *)skb);
    }
#line 669
    if ((unsigned int )*((unsigned char *)tmp___1 + 0UL) == 96U) {
      {
#line 670
      tmp___0 = ipv6_hdr((struct sk_buff  const  *)skb);
#line 670
      val = (unsigned int )tmp___0->nexthdr == 17U;
      }
    } else {

    }
  }
#line 672
  return (val);
}
}
#line 675 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool is_ipv4_pkt(struct sk_buff *skb ) 
{ 
  struct iphdr *tmp ;
  int tmp___0 ;

  {
#line 677
  if ((unsigned int )skb->protocol == 8U) {
    {
#line 677
    tmp = ip_hdr((struct sk_buff  const  *)skb);
    }
#line 677
    if ((unsigned int )*((unsigned char *)tmp + 0UL) == 64U) {
#line 677
      tmp___0 = 1;
    } else {
#line 677
      tmp___0 = 0;
    }
  } else {
#line 677
    tmp___0 = 0;
  }
#line 677
  return ((bool )tmp___0);
}
}
#line 680 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_vf_eth_addr_generate(struct be_adapter *adapter , u8 *mac ) 
{ 
  u32 addr ;

  {
  {
#line 684
  addr = jhash((void const   *)(adapter->netdev)->dev_addr, 6U, 0U);
#line 686
  *(mac + 5UL) = (unsigned char )addr;
#line 687
  *(mac + 4UL) = (unsigned char )(addr >> 8);
#line 688
  *(mac + 3UL) = (unsigned char )(addr >> 16);
#line 690
  memcpy((void *)mac, (void const   *)(adapter->netdev)->dev_addr, 3UL);
  }
#line 691
  return;
}
}
#line 693 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_multi_rxq(struct be_adapter  const  *adapter ) 
{ 


  {
#line 695
  return ((unsigned int )((unsigned short )adapter->num_rx_qs) > 1U);
}
}
#line 703 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_hw_error(struct be_adapter *adapter ) 
{ 


  {
#line 705
  return ((bool )((int )adapter->eeh_error || (int )adapter->hw_error));
}
}
#line 708 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_clear_all_error(struct be_adapter *adapter ) 
{ 


  {
#line 710
  adapter->eeh_error = 0;
#line 711
  adapter->hw_error = 0;
#line 712
  adapter->fw_timeout = 0;
#line 713
  return;
}
}
#line 733 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static int qnq_async_evt_rcvd(struct be_adapter *adapter ) 
{ 


  {
#line 735
  return ((int )adapter->flags & 2048);
}
}
#line 739 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_lock_napi(struct be_eq_obj *eqo ) 
{ 
  bool status ;
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 741
  status = 1;
#line 743
  spin_lock(& eqo->lock);
  }
#line 744
  if ((eqo->state & 3U) != 0U) {
    {
#line 745
    __ret_warn_on = (int )eqo->state & 1;
#line 745
    tmp = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 745
    if (tmp != 0L) {
      {
#line 745
      warn_slowpath_null("drivers/net/ethernet/emulex/benet/be.h", 745);
      }
    } else {

    }
    {
#line 745
    __builtin_expect(__ret_warn_on != 0, 0L);
#line 746
    eqo->state = eqo->state | 4U;
#line 747
    status = 0;
    }
  } else {
#line 749
    eqo->state = 1U;
  }
  {
#line 751
  spin_unlock(& eqo->lock);
  }
#line 752
  return (status);
}
}
#line 755 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_unlock_napi(struct be_eq_obj *eqo ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 757
  spin_lock(& eqo->lock);
#line 759
  __ret_warn_on = (eqo->state & 6U) != 0U;
#line 759
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 759
  if (tmp != 0L) {
    {
#line 759
    warn_slowpath_null("drivers/net/ethernet/emulex/benet/be.h", 759);
    }
  } else {

  }
  {
#line 759
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 760
  eqo->state = 0U;
#line 762
  spin_unlock(& eqo->lock);
  }
#line 763
  return;
}
}
#line 765 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_lock_busy_poll(struct be_eq_obj *eqo ) 
{ 
  bool status ;

  {
  {
#line 767
  status = 1;
#line 769
  spin_lock_bh(& eqo->lock);
  }
#line 770
  if ((eqo->state & 3U) != 0U) {
#line 771
    eqo->state = eqo->state | 8U;
#line 772
    status = 0;
  } else {
#line 774
    eqo->state = eqo->state | 2U;
  }
  {
#line 776
  spin_unlock_bh(& eqo->lock);
  }
#line 777
  return (status);
}
}
#line 780 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_unlock_busy_poll(struct be_eq_obj *eqo ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 782
  spin_lock_bh(& eqo->lock);
#line 784
  __ret_warn_on = (int )eqo->state & 1;
#line 784
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 784
  if (tmp != 0L) {
    {
#line 784
    warn_slowpath_null("drivers/net/ethernet/emulex/benet/be.h", 784);
    }
  } else {

  }
  {
#line 784
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 785
  eqo->state = 0U;
#line 787
  spin_unlock_bh(& eqo->lock);
  }
#line 788
  return;
}
}
#line 790 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_enable_busy_poll(struct be_eq_obj *eqo ) 
{ 
  struct lock_class_key __key ;

  {
  {
#line 792
  spinlock_check(& eqo->lock);
#line 792
  __raw_spin_lock_init(& eqo->lock.__annonCompField19.rlock, "&(&eqo->lock)->rlock",
                       & __key);
#line 793
  eqo->state = 0U;
  }
#line 794
  return;
}
}
#line 796 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void be_disable_busy_poll(struct be_eq_obj *eqo ) 
{ 
  unsigned long __ms ;
  unsigned long tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 798
  local_bh_disable();
  }
#line 803
  goto ldv_52228;
  ldv_52227: ;
#line 804
  if (1) {
    {
#line 804
    __const_udelay(4295000UL);
    }
  } else {
#line 804
    __ms = 1UL;
#line 804
    goto ldv_52225;
    ldv_52224: 
    {
#line 804
    __const_udelay(4295000UL);
    }
    ldv_52225: 
#line 804
    tmp = __ms;
#line 804
    __ms = __ms - 1UL;
#line 804
    if (tmp != 0UL) {
#line 806
      goto ldv_52224;
    } else {

    }

  }
  ldv_52228: 
  {
#line 803
  tmp___0 = be_lock_napi(eqo);
  }
#line 803
  if (tmp___0) {
#line 803
    tmp___1 = 0;
  } else {
#line 803
    tmp___1 = 1;
  }
#line 803
  if (tmp___1) {
#line 805
    goto ldv_52227;
  } else {

  }
  {
#line 806
  local_bh_enable();
  }
#line 807
  return;
}
}
#line 838
void be_cq_notify(struct be_adapter *adapter , u16 qid , bool arm , u16 num_popped ) ;
#line 840
void be_link_status_update(struct be_adapter *adapter , u8 link_status ) ;
#line 841
void be_parse_stats(struct be_adapter *adapter ) ;
#line 842
int be_load_fw(struct be_adapter *adapter , u8 *fw_file ) ;
#line 844
bool be_pause_supported(struct be_adapter *adapter ) ;
#line 847 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static int fw_major_num(char const   *fw_ver ) 
{ 
  int fw_major ;

  {
  {
#line 849
  fw_major = 0;
#line 851
  sscanf(fw_ver, "%d.", & fw_major);
  }
#line 853
  return (fw_major);
}
}
#line 856
int be_update_queues(struct be_adapter *adapter ) ;
#line 857
int be_poll(struct napi_struct *napi , int budget ) ;
#line 862
void be_roce_dev_add(struct be_adapter *adapter ) ;
#line 863
void be_roce_dev_remove(struct be_adapter *adapter ) ;
#line 868
void be_roce_dev_open(struct be_adapter *adapter ) ;
#line 869
void be_roce_dev_close(struct be_adapter *adapter ) ;
#line 909 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static struct lancer_pport_stats *pport_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct lancer_cmd_resp_pport_stats *cmd ;

  {
#line 911
  cmd = (struct lancer_cmd_resp_pport_stats *)adapter->stats_cmd.va;
#line 912
  return (& cmd->pport_stats);
}
}
#line 1102 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static bool be_is_mc(struct be_adapter *adapter ) 
{ 


  {
#line 1104
  return (*((unsigned int *)adapter + 335650UL) != 0U);
}
}
#line 1975
int be_fw_wait_ready(struct be_adapter *adapter ) ;
#line 1978
int be_cmd_pmac_add(struct be_adapter *adapter , u8 *mac_addr , u32 if_id , u32 *pmac_id ,
                    u32 domain ) ;
#line 1980
int be_cmd_pmac_del(struct be_adapter *adapter , u32 if_id , int pmac_id , u32 dom ) ;
#line 1982
int be_cmd_if_create(struct be_adapter *adapter , u32 cap_flags , u32 en_flags , u32 *if_handle ,
                     u32 domain ) ;
#line 1984
int be_cmd_if_destroy(struct be_adapter *adapter , int interface_id , u32 domain ) ;
#line 1985
int be_cmd_eq_create(struct be_adapter *adapter , struct be_eq_obj *eqo ) ;
#line 1986
int be_cmd_cq_create(struct be_adapter *adapter , struct be_queue_info *cq , struct be_queue_info *eq ,
                     bool no_delay , int coalesce_wm ) ;
#line 1989
int be_cmd_mccq_create(struct be_adapter *adapter , struct be_queue_info *mccq , struct be_queue_info *cq ) ;
#line 1991
int be_cmd_txq_create(struct be_adapter *adapter , struct be_tx_obj *txo ) ;
#line 1992
int be_cmd_rxq_create(struct be_adapter *adapter , struct be_queue_info *rxq , u16 cq_id ,
                      u16 frag_size , u32 if_id , u32 rss , u8 *rss_id ) ;
#line 1994
int be_cmd_q_destroy(struct be_adapter *adapter , struct be_queue_info *q , int queue_type ) ;
#line 1996
int be_cmd_rxq_destroy(struct be_adapter *adapter , struct be_queue_info *q ) ;
#line 1997
int be_cmd_link_status_query(struct be_adapter *adapter , u16 *link_speed , u8 *link_status ,
                             u32 dom ) ;
#line 2000
int be_cmd_get_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2001
int lancer_cmd_get_pport_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2003
int be_cmd_get_fw_ver(struct be_adapter *adapter , char *fw_ver , char *fw_on_flash ) ;
#line 2005
int be_cmd_modify_eqd(struct be_adapter *adapter , struct be_set_eqd *set_eqd , int num ) ;
#line 2006
int be_cmd_vlan_config(struct be_adapter *adapter , u32 if_id , u16 *vtag_array ,
                       u32 num , bool promiscuous ) ;
#line 2008
int be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) ;
#line 2009
int be_cmd_set_flow_control(struct be_adapter *adapter , u32 tx_fc , u32 rx_fc ) ;
#line 2010
int be_cmd_get_flow_control(struct be_adapter *adapter , u32 *tx_fc , u32 *rx_fc ) ;
#line 2011
int be_cmd_query_fw_cfg(struct be_adapter *adapter , u32 *port_num , u32 *mode , u32 *caps ,
                        u16 *asic_rev ) ;
#line 2013
int be_cmd_reset_function(struct be_adapter *adapter ) ;
#line 2014
int be_cmd_rss_config(struct be_adapter *adapter , u8 *rsstable , u32 rss_hash_opts ,
                      u16 table_size ) ;
#line 2016
int be_process_mcc(struct be_adapter *adapter ) ;
#line 2021
int be_cmd_write_flashrom(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 flash_type ,
                          u32 flash_opcode , u32 buf_size ) ;
#line 2023
int lancer_cmd_write_object(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                            u32 data_size , u32 data_offset , char const   *obj_name ,
                            u32 *data_written , u8 *change_status , u8 *addn_status ) ;
#line 2030
int be_cmd_get_flash_crc(struct be_adapter *adapter , u8 *flashed_crc , int offset ) ;
#line 2032
int be_cmd_enable_magic_wol(struct be_adapter *adapter , u8 *mac , struct be_dma_mem *nonemb_cmd ) ;
#line 2034
int be_cmd_fw_init(struct be_adapter *adapter ) ;
#line 2035
int be_cmd_fw_clean(struct be_adapter *adapter ) ;
#line 2036
void be_async_mcc_enable(struct be_adapter *adapter ) ;
#line 2037
void be_async_mcc_disable(struct be_adapter *adapter ) ;
#line 2047
int be_cmd_get_phy_info(struct be_adapter *adapter ) ;
#line 2048
int be_cmd_set_qos(struct be_adapter *adapter , u32 bps , u32 domain ) ;
#line 2049
void be_detect_error(struct be_adapter *adapter ) ;
#line 2050
int be_cmd_get_die_temperature(struct be_adapter *adapter ) ;
#line 2051
int be_cmd_get_cntl_attributes(struct be_adapter *adapter ) ;
#line 2052
int be_cmd_req_native_mode(struct be_adapter *adapter ) ;
#line 2055
int be_cmd_get_fn_privileges(struct be_adapter *adapter , u32 *privilege , u32 domain ) ;
#line 2057
int be_cmd_set_fn_privileges(struct be_adapter *adapter , u32 privileges , u32 domain ) ;
#line 2062
int be_cmd_get_active_mac(struct be_adapter *adapter , u32 curr_pmac_id , u8 *mac ,
                          u32 if_handle , bool active , u32 domain ) ;
#line 2064
int be_cmd_get_perm_mac(struct be_adapter *adapter , u8 *mac ) ;
#line 2067
int be_cmd_set_mac(struct be_adapter *adapter , u8 *mac , int if_id , u32 dom ) ;
#line 2068
int be_cmd_set_hsw_config(struct be_adapter *adapter , u16 pvid , u32 domain , u16 intf_id ,
                          u16 hsw_mode ) ;
#line 2070
int be_cmd_get_hsw_config(struct be_adapter *adapter , u16 *pvid , u32 domain , u16 intf_id ,
                          u8 *mode ) ;
#line 2072
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter ) ;
#line 2074
int be_cmd_get_fw_log_level(struct be_adapter *adapter ) ;
#line 2080
int lancer_physdev_ctrl(struct be_adapter *adapter , u32 mask ) ;
#line 2083
int lancer_test_and_set_rdy_state(struct be_adapter *adapter ) ;
#line 2084
int be_cmd_query_port_name(struct be_adapter *adapter , u8 *port_name ) ;
#line 2085
int be_cmd_get_func_config(struct be_adapter *adapter , struct be_resources *res ) ;
#line 2087
int be_cmd_get_profile_config(struct be_adapter *adapter , struct be_resources *res ,
                              u8 domain ) ;
#line 2089
int be_cmd_set_profile_config(struct be_adapter *adapter , u32 bps , u8 domain ) ;
#line 2090
int be_cmd_get_active_profile(struct be_adapter *adapter , u16 *profile_id ) ;
#line 2091
int be_cmd_get_if_id(struct be_adapter *adapter , struct be_vf_cfg *vf_cfg , int vf_num ) ;
#line 2093
int be_cmd_enable_vf(struct be_adapter *adapter , u8 domain ) ;
#line 2094
int be_cmd_intr_set(struct be_adapter *adapter , bool intr_enable ) ;
#line 38 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 39
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 40
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/net/busy_poll.h"
__inline static void skb_mark_napi_id(struct sk_buff *skb , struct napi_struct *napi ) 
{ 


  {
#line 124
  skb->__annonCompField69.napi_id = napi->napi_id;
#line 125
  return;
}
}
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
struct pci_device_id  const  __mod_pci_device_table  ;
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static unsigned int num_vfs  ;
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static ushort rx_frag_size  =    2048U;
#line 41 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct pci_device_id  const  be_dev_ids[9U]  = 
#line 41
  {      {6562U, 529U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 545U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1792U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1808U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 57888U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 57896U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1824U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1832U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static char const   * const  ue_status_low_desc[32U]  = 
#line 54
  {      "CEV",      "CTX",      "DBUF",      "ERX", 
        "Host",      "MPU",      "NDMA",      "PTC ", 
        "RDMA ",      "RXF ",      "RXIPS ",      "RXULP0 ", 
        "RXULP1 ",      "RXULP2 ",      "TIM ",      "TPOST ", 
        "TPRE ",      "TXIPS ",      "TXULP0 ",      "TXULP1 ", 
        "UC ",      "WDMA ",      "TXULP2 ",      "HOST1 ", 
        "P0_OB_LINK ",      "P1_OB_LINK ",      "HOST_GPIO ",      "MBOX ", 
        "AXGMAC0",      "AXGMAC1",      "JTAG",      "MPU_INTPEND"};
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static char const   * const  ue_status_hi_desc[32U]  = 
#line 89
  {      "LPCMEMHOST",      "MGMT_MAC",      "PCS0ONLINE",      "MPU_IRAM", 
        "PCS1ONLINE",      "PCTL0",      "PCTL1",      "PMEM", 
        "RR",      "TXPB",      "RXPP",      "XAUI", 
        "TXP",      "ARM",      "IPC",      "HOST2", 
        "HOST3",      "HOST4",      "HOST5",      "HOST6", 
        "HOST7",      "HOST8",      "HOST9",      "NETC", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown"};
#line 125 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_queue_free(struct be_adapter *adapter , struct be_queue_info *q ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 127
  mem = & q->dma_mem;
#line 128
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
    {
#line 129
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   (struct dma_attrs *)0);
#line 131
    mem->va = (void *)0;
    }
  } else {

  }
#line 133
  return;
}
}
#line 135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_queue_alloc(struct be_adapter *adapter , struct be_queue_info *q , u16 len ,
                          u16 entry_size ) 
{ 
  struct be_dma_mem *mem ;

  {
  {
#line 138
  mem = & q->dma_mem;
#line 140
  memset((void *)q, 0, 40UL);
#line 141
  q->len = len;
#line 142
  q->entry_size = entry_size;
#line 143
  mem->size = (u32 )((int )len * (int )entry_size);
#line 144
  mem->va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )mem->size, & mem->dma,
                                208U);
  }
#line 146
  if ((unsigned long )mem->va == (unsigned long )((void *)0)) {
#line 147
    return (-12);
  } else {

  }
#line 148
  return (0);
}
}
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_reg_intr_set(struct be_adapter *adapter , bool enable ) 
{ 
  u32 reg ;
  u32 enabled ;

  {
  {
#line 155
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 252, & reg);
#line 157
  enabled = reg & 536870912U;
  }
#line 159
  if (enabled == 0U && (int )enable) {
#line 160
    reg = reg | 536870912U;
  } else
#line 161
  if (enabled != 0U && ! enable) {
#line 162
    reg = reg & 3758096383U;
  } else {
#line 164
    return;
  }
  {
#line 166
  pci_write_config_dword((struct pci_dev  const  *)adapter->pdev, 252, reg);
  }
#line 167
  return;
}
}
#line 170 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_intr_set(struct be_adapter *adapter , bool enable ) 
{ 
  int status ;

  {
#line 172
  status = 0;
#line 175
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 176
    return;
  } else {

  }
#line 178
  if ((int )adapter->eeh_error) {
#line 179
    return;
  } else {

  }
  {
#line 181
  status = be_cmd_intr_set(adapter, (int )enable);
  }
#line 182
  if (status != 0) {
    {
#line 183
    be_reg_intr_set(adapter, (int )enable);
    }
  } else {

  }
#line 184
  return;
}
}
#line 186 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rxq_notify(struct be_adapter *adapter , u16 qid , u16 posted ) 
{ 
  u32 val ;

  {
  {
#line 188
  val = 0U;
#line 189
  val = val | ((u32 )qid & 1023U);
#line 190
  val = val | (u32 )((int )posted << 24);
#line 192
  __asm__  volatile   ("sfence": : : "memory");
#line 193
  iowrite32(val, (void *)adapter->db + 256U);
  }
#line 194
  return;
}
}
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_txq_notify(struct be_adapter *adapter , struct be_tx_obj *txo , u16 posted ) 
{ 
  u32 val ;

  {
  {
#line 199
  val = 0U;
#line 200
  val = val | ((u32 )txo->q.id & 2047U);
#line 201
  val = val | (u32 )(((int )posted & 16383) << 16);
#line 203
  __asm__  volatile   ("sfence": : : "memory");
#line 204
  iowrite32(val, (void *)adapter->db + (unsigned long )txo->db_offset);
  }
#line 205
  return;
}
}
#line 207 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_eq_notify(struct be_adapter *adapter , u16 qid , bool arm , bool clear_int ,
                         u16 num_popped ) 
{ 
  u32 val ;

  {
#line 210
  val = 0U;
#line 211
  val = val | ((u32 )qid & 511U);
#line 212
  val = val | (u32 )(((int )qid & 15872) << 2);
#line 215
  if ((int )adapter->eeh_error) {
#line 216
    return;
  } else {

  }
#line 218
  if ((int )arm) {
#line 219
    val = val | 536870912U;
  } else {

  }
#line 220
  if ((int )clear_int) {
#line 221
    val = val | 512U;
  } else {

  }
  {
#line 222
  val = val | 1024U;
#line 223
  val = val | (u32 )((int )num_popped << 16);
#line 224
  iowrite32(val, (void *)adapter->db + 288U);
  }
#line 225
  return;
}
}
#line 227 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
void be_cq_notify(struct be_adapter *adapter , u16 qid , bool arm , u16 num_popped ) 
{ 
  u32 val ;

  {
#line 229
  val = 0U;
#line 230
  val = val | ((u32 )qid & 1023U);
#line 231
  val = val | (u32 )(((int )qid & 31744) << 1);
#line 234
  if ((int )adapter->eeh_error) {
#line 235
    return;
  } else {

  }
#line 237
  if ((int )arm) {
#line 238
    val = val | 536870912U;
  } else {

  }
  {
#line 239
  val = val | (u32 )((int )num_popped << 16);
#line 240
  iowrite32(val, (void *)adapter->db + 288U);
  }
#line 241
  return;
}
}
#line 243 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_mac_addr_set(struct net_device *netdev , void *p ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  struct sockaddr *addr ;
  int status ;
  u8 mac[6U] ;
  u32 old_pmac_id ;
  u32 curr_pmac_id ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
  {
#line 245
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 245
  adapter = (struct be_adapter *)tmp;
#line 246
  dev = & (adapter->pdev)->dev;
#line 247
  addr = (struct sockaddr *)p;
#line 250
  old_pmac_id = *(adapter->pmac_id);
#line 250
  curr_pmac_id = 0U;
#line 252
  tmp___0 = is_valid_ether_addr((u8 const   *)(& addr->sa_data));
  }
#line 252
  if (tmp___0) {
#line 252
    tmp___1 = 0;
  } else {
#line 252
    tmp___1 = 1;
  }
#line 252
  if (tmp___1) {
#line 253
    return (-99);
  } else {

  }
  {
#line 258
  tmp___2 = ether_addr_equal((u8 const   *)(& addr->sa_data), (u8 const   *)netdev->dev_addr);
  }
#line 258
  if ((int )tmp___2) {
#line 259
    return (0);
  } else {

  }
  {
#line 267
  status = be_cmd_pmac_add(adapter, (u8 *)(& addr->sa_data), (u32 )adapter->if_handle,
                           adapter->pmac_id, 0U);
  }
#line 269
  if (status == 0) {
#line 270
    curr_pmac_id = *(adapter->pmac_id);
#line 275
    if (*(adapter->pmac_id) != old_pmac_id) {
      {
#line 276
      be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )old_pmac_id, 0U);
      }
    } else {

    }
  } else {

  }
  {
#line 283
  status = be_cmd_get_active_mac(adapter, curr_pmac_id, (u8 *)(& mac), (u32 )adapter->if_handle,
                                 1, 0U);
  }
#line 285
  if (status != 0) {
#line 286
    goto err;
  } else {

  }
  {
#line 291
  tmp___3 = ether_addr_equal((u8 const   *)(& addr->sa_data), (u8 const   *)(& mac));
  }
#line 291
  if (tmp___3) {
#line 291
    tmp___4 = 0;
  } else {
#line 291
    tmp___4 = 1;
  }
#line 291
  if (tmp___4) {
#line 292
    status = -1;
#line 293
    goto err;
  } else {

  }
  {
#line 296
  memcpy((void *)netdev->dev_addr, (void const   *)(& addr->sa_data), (size_t )netdev->addr_len);
#line 297
  _dev_info((struct device  const  *)dev, "MAC address changed to %pM\n", (u8 *)(& mac));
  }
#line 298
  return (0);
  err: 
  {
#line 300
  dev_warn((struct device  const  *)dev, "MAC address change to %pM failed\n", (char *)(& addr->sa_data));
  }
#line 301
  return (status);
}
}
#line 305 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void *hw_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct be_cmd_resp_get_stats_v0 *cmd ;
  struct be_cmd_resp_get_stats_v1 *cmd___0 ;
  struct be_cmd_resp_get_stats_v2 *cmd___1 ;

  {
#line 307
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 308
    cmd = (struct be_cmd_resp_get_stats_v0 *)adapter->stats_cmd.va;
#line 310
    return ((void *)(& cmd->hw_stats));
  } else
#line 311
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 312
    cmd___0 = (struct be_cmd_resp_get_stats_v1 *)adapter->stats_cmd.va;
#line 314
    return ((void *)(& cmd___0->hw_stats));
  } else {
#line 316
    cmd___1 = (struct be_cmd_resp_get_stats_v2 *)adapter->stats_cmd.va;
#line 318
    return ((void *)(& cmd___1->hw_stats));
  }
}
}
#line 323 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void *be_erx_stats_from_cmd(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v0 *hw_stats ;
  void *tmp ;
  struct be_hw_stats_v1 *hw_stats___0 ;
  void *tmp___0 ;
  struct be_hw_stats_v2 *hw_stats___1 ;
  void *tmp___1 ;

  {
#line 325
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
    {
#line 326
    tmp = hw_stats_from_cmd(adapter);
#line 326
    hw_stats = (struct be_hw_stats_v0 *)tmp;
    }
#line 328
    return ((void *)(& hw_stats->erx));
  } else
#line 329
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
    {
#line 330
    tmp___0 = hw_stats_from_cmd(adapter);
#line 330
    hw_stats___0 = (struct be_hw_stats_v1 *)tmp___0;
    }
#line 332
    return ((void *)(& hw_stats___0->erx));
  } else {
    {
#line 334
    tmp___1 = hw_stats_from_cmd(adapter);
#line 334
    hw_stats___1 = (struct be_hw_stats_v2 *)tmp___1;
    }
#line 336
    return ((void *)(& hw_stats___1->erx));
  }
}
}
#line 340 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_be_v0_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v0 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v0 *rxf_stats ;
  struct be_port_rxf_stats_v0 *port_stats ;
  struct be_drv_stats *drvs ;

  {
  {
#line 342
  tmp = hw_stats_from_cmd(adapter);
#line 342
  hw_stats = (struct be_hw_stats_v0 *)tmp;
#line 343
  pmem_sts = & hw_stats->pmem;
#line 344
  rxf_stats = & hw_stats->rxf;
#line 345
  port_stats = (struct be_port_rxf_stats_v0 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 347
  drvs = & adapter->drv_stats;
#line 349
  swap_dws((void *)hw_stats, 1060);
#line 350
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 351
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 352
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 353
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 354
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 355
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 356
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 357
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 358
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 359
  drvs->rxpp_fifo_overflow_drop = port_stats->rx_fifo_overflow;
#line 360
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 361
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 362
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 363
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 364
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow;
#line 365
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 367
  drvs->rx_address_filtered = port_stats->rx_address_filtered + port_stats->rx_vlan_filtered;
#line 370
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 373
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 374
  drvs->tx_controlframes = port_stats->tx_controlframes;
  }
#line 376
  if (adapter->port_num != 0U) {
#line 377
    drvs->jabber_events = rxf_stats->port1_jabber_events;
  } else {
#line 379
    drvs->jabber_events = rxf_stats->port0_jabber_events;
  }
#line 380
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 381
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 382
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 383
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 384
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 385
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 386
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
#line 387
  return;
}
}
#line 389 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_be_v1_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v1 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v1 *rxf_stats ;
  struct be_port_rxf_stats_v1 *port_stats ;
  struct be_drv_stats *drvs ;

  {
  {
#line 391
  tmp = hw_stats_from_cmd(adapter);
#line 391
  hw_stats = (struct be_hw_stats_v1 *)tmp;
#line 392
  pmem_sts = & hw_stats->pmem;
#line 393
  rxf_stats = & hw_stats->rxf;
#line 394
  port_stats = (struct be_port_rxf_stats_v1 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 396
  drvs = & adapter->drv_stats;
#line 398
  swap_dws((void *)hw_stats, 1848);
#line 399
  drvs->pmem_fifo_overflow_drop = port_stats->pmem_fifo_overflow_drop;
#line 400
  drvs->rx_priority_pause_frames = port_stats->rx_priority_pause_frames;
#line 401
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 402
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 403
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 404
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 405
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 406
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 407
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 408
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 409
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 410
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 411
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 412
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 413
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 414
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 416
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow_drop;
#line 418
  drvs->rx_address_filtered = port_stats->rx_address_filtered;
#line 419
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 421
  drvs->rxpp_fifo_overflow_drop = port_stats->rxpp_fifo_overflow_drop;
#line 422
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 423
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 424
  drvs->tx_priority_pauseframes = port_stats->tx_priority_pauseframes;
#line 425
  drvs->jabber_events = port_stats->jabber_events;
#line 426
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 427
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 428
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 429
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 430
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 431
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 432
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
  }
#line 433
  return;
}
}
#line 435 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_be_v2_stats(struct be_adapter *adapter ) 
{ 
  struct be_hw_stats_v2 *hw_stats ;
  void *tmp ;
  struct be_pmem_stats *pmem_sts ;
  struct be_rxf_stats_v2 *rxf_stats ;
  struct be_port_rxf_stats_v2 *port_stats ;
  struct be_drv_stats *drvs ;

  {
  {
#line 437
  tmp = hw_stats_from_cmd(adapter);
#line 437
  hw_stats = (struct be_hw_stats_v2 *)tmp;
#line 438
  pmem_sts = & hw_stats->pmem;
#line 439
  rxf_stats = & hw_stats->rxf;
#line 440
  port_stats = (struct be_port_rxf_stats_v2 *)(& rxf_stats->port) + (unsigned long )adapter->port_num;
#line 442
  drvs = & adapter->drv_stats;
#line 444
  swap_dws((void *)hw_stats, 2680);
#line 445
  drvs->pmem_fifo_overflow_drop = port_stats->pmem_fifo_overflow_drop;
#line 446
  drvs->rx_priority_pause_frames = port_stats->rx_priority_pause_frames;
#line 447
  drvs->rx_pause_frames = port_stats->rx_pause_frames;
#line 448
  drvs->rx_crc_errors = port_stats->rx_crc_errors;
#line 449
  drvs->rx_control_frames = port_stats->rx_control_frames;
#line 450
  drvs->rx_in_range_errors = port_stats->rx_in_range_errors;
#line 451
  drvs->rx_frame_too_long = port_stats->rx_frame_too_long;
#line 452
  drvs->rx_dropped_runt = port_stats->rx_dropped_runt;
#line 453
  drvs->rx_ip_checksum_errs = port_stats->rx_ip_checksum_errs;
#line 454
  drvs->rx_tcp_checksum_errs = port_stats->rx_tcp_checksum_errs;
#line 455
  drvs->rx_udp_checksum_errs = port_stats->rx_udp_checksum_errs;
#line 456
  drvs->rx_dropped_tcp_length = port_stats->rx_dropped_tcp_length;
#line 457
  drvs->rx_dropped_too_small = port_stats->rx_dropped_too_small;
#line 458
  drvs->rx_dropped_too_short = port_stats->rx_dropped_too_short;
#line 459
  drvs->rx_out_range_errors = port_stats->rx_out_range_errors;
#line 460
  drvs->rx_dropped_header_too_small = port_stats->rx_dropped_header_too_small;
#line 462
  drvs->rx_input_fifo_overflow_drop = port_stats->rx_input_fifo_overflow_drop;
#line 464
  drvs->rx_address_filtered = port_stats->rx_address_filtered;
#line 465
  drvs->rx_alignment_symbol_errors = port_stats->rx_alignment_symbol_errors;
#line 467
  drvs->rxpp_fifo_overflow_drop = port_stats->rxpp_fifo_overflow_drop;
#line 468
  drvs->tx_pauseframes = port_stats->tx_pauseframes;
#line 469
  drvs->tx_controlframes = port_stats->tx_controlframes;
#line 470
  drvs->tx_priority_pauseframes = port_stats->tx_priority_pauseframes;
#line 471
  drvs->jabber_events = port_stats->jabber_events;
#line 472
  drvs->rx_drops_no_pbuf = rxf_stats->rx_drops_no_pbuf;
#line 473
  drvs->rx_drops_no_erx_descr = rxf_stats->rx_drops_no_erx_descr;
#line 474
  drvs->forwarded_packets = rxf_stats->forwarded_packets;
#line 475
  drvs->rx_drops_mtu = rxf_stats->rx_drops_mtu;
#line 476
  drvs->rx_drops_no_tpre_descr = rxf_stats->rx_drops_no_tpre_descr;
#line 477
  drvs->rx_drops_too_many_frags = rxf_stats->rx_drops_too_many_frags;
#line 478
  adapter->drv_stats.eth_red_drops = pmem_sts->eth_red_drops;
  }
#line 479
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 480
    drvs->rx_roce_bytes_lsd = port_stats->roce_bytes_received_lsd;
#line 481
    drvs->rx_roce_bytes_msd = port_stats->roce_bytes_received_msd;
#line 482
    drvs->rx_roce_frames = port_stats->roce_frames_received;
#line 483
    drvs->roce_drops_crc = port_stats->roce_drops_crc;
#line 484
    drvs->roce_drops_payload_len = port_stats->roce_drops_payload_len;
  } else {

  }
#line 487
  return;
}
}
#line 489 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_lancer_stats(struct be_adapter *adapter ) 
{ 
  struct be_drv_stats *drvs ;
  struct lancer_pport_stats *pport_stats ;
  struct lancer_pport_stats *tmp ;

  {
  {
#line 492
  drvs = & adapter->drv_stats;
#line 493
  tmp = pport_stats_from_cmd(adapter);
#line 493
  pport_stats = tmp;
#line 496
  swap_dws((void *)pport_stats, 656);
#line 497
  drvs->rx_pause_frames = pport_stats->rx_pause_frames_lo;
#line 498
  drvs->rx_crc_errors = pport_stats->rx_crc_errors_lo;
#line 499
  drvs->rx_control_frames = pport_stats->rx_control_frames_lo;
#line 500
  drvs->rx_in_range_errors = pport_stats->rx_in_range_errors;
#line 501
  drvs->rx_frame_too_long = pport_stats->rx_frames_too_long_lo;
#line 502
  drvs->rx_dropped_runt = pport_stats->rx_dropped_runt;
#line 503
  drvs->rx_ip_checksum_errs = pport_stats->rx_ip_checksum_errors;
#line 504
  drvs->rx_tcp_checksum_errs = pport_stats->rx_tcp_checksum_errors;
#line 505
  drvs->rx_udp_checksum_errs = pport_stats->rx_udp_checksum_errors;
#line 506
  drvs->rx_dropped_tcp_length = pport_stats->rx_dropped_invalid_tcp_length;
#line 508
  drvs->rx_dropped_too_small = pport_stats->rx_dropped_too_small;
#line 509
  drvs->rx_dropped_too_short = pport_stats->rx_dropped_too_short;
#line 510
  drvs->rx_out_range_errors = pport_stats->rx_out_of_range_errors;
#line 511
  drvs->rx_dropped_header_too_small = pport_stats->rx_dropped_header_too_small;
#line 513
  drvs->rx_input_fifo_overflow_drop = pport_stats->rx_fifo_overflow;
#line 514
  drvs->rx_address_filtered = pport_stats->rx_address_filtered + pport_stats->rx_vlan_filtered;
#line 517
  drvs->rx_alignment_symbol_errors = pport_stats->rx_symbol_errors_lo;
#line 518
  drvs->rxpp_fifo_overflow_drop = pport_stats->rx_fifo_overflow;
#line 519
  drvs->tx_pauseframes = pport_stats->tx_pause_frames_lo;
#line 520
  drvs->tx_controlframes = pport_stats->tx_control_frames_lo;
#line 521
  drvs->jabber_events = pport_stats->rx_jabbers;
#line 522
  drvs->forwarded_packets = pport_stats->num_forwards_lo;
#line 523
  drvs->rx_drops_mtu = pport_stats->rx_drops_mtu_lo;
#line 524
  drvs->rx_drops_too_many_frags = pport_stats->rx_drops_too_many_frags_lo;
  }
#line 526
  return;
}
}
#line 528 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void accumulate_16bit_val(u32 *acc , u16 val ) 
{ 
  bool wrapped ;
  u32 newacc ;

  {
#line 532
  wrapped = (u32 )val < (*acc & 65535U);
#line 533
  newacc = (*acc & 4294901760U) + (u32 )val;
#line 535
  if ((int )wrapped) {
#line 536
    newacc = newacc + 65536U;
  } else {

  }
#line 537
  *((u32 volatile   *)acc) = newacc;
#line 538
  return;
}
}
#line 540 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void populate_erx_stats(struct be_adapter *adapter , struct be_rx_obj *rxo ,
                               u32 erx_stat ) 
{ 


  {
#line 544
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 545
    rxo->stats.rx_drops_no_frags = erx_stat;
  } else {
    {
#line 550
    accumulate_16bit_val(& rxo->stats.rx_drops_no_frags, (int )((unsigned short )erx_stat));
    }
  }
#line 552
  return;
}
}
#line 554 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
void be_parse_stats(struct be_adapter *adapter ) 
{ 
  struct be_erx_stats_v2 *erx ;
  void *tmp ;
  struct be_rx_obj *rxo ;
  int i ;
  u32 erx_stat ;

  {
  {
#line 556
  tmp = be_erx_stats_from_cmd(adapter);
#line 556
  erx = (struct be_erx_stats_v2 *)tmp;
  }
#line 561
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
    {
#line 562
    populate_lancer_stats(adapter);
    }
  } else {
#line 564
    if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
      {
#line 565
      populate_be_v0_stats(adapter);
      }
    } else
#line 566
    if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
      {
#line 568
      populate_be_v1_stats(adapter);
      }
    } else {
      {
#line 570
      populate_be_v2_stats(adapter);
      }
    }
#line 573
    i = 0;
#line 573
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 573
    goto ldv_54248;
    ldv_54247: 
    {
#line 574
    erx_stat = erx->rx_drops_no_fragments[(int )rxo->q.id];
#line 575
    populate_erx_stats(adapter, rxo, erx_stat);
#line 573
    i = i + 1;
#line 573
    rxo = rxo + 1;
    }
    ldv_54248: ;
#line 573
    if (i < (int )adapter->num_rx_qs) {
#line 575
      goto ldv_54247;
    } else {

    }

  }
#line 581
  return;
}
}
#line 580 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct rtnl_link_stats64 *be_get_stats64(struct net_device *netdev , struct rtnl_link_stats64 *stats ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_drv_stats *drvs ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u64 pkts ;
  u64 bytes ;
  unsigned int start ;
  int i ;
  struct be_rx_stats  const  *rx_stats ;
  bool tmp___0 ;
  struct be_tx_stats  const  *tx_stats ;
  bool tmp___1 ;

  {
  {
#line 583
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 583
  adapter = (struct be_adapter *)tmp;
#line 584
  drvs = & adapter->drv_stats;
#line 591
  i = 0;
#line 591
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
  }
#line 591
  goto ldv_54266;
  ldv_54265: 
#line 592
  rx_stats = (struct be_rx_stats  const  *)(& rxo->stats);
  ldv_54263: 
  {
#line 594
  start = u64_stats_fetch_begin_bh(& rx_stats->sync);
#line 595
  pkts = rxo->stats.rx_pkts;
#line 596
  bytes = rxo->stats.rx_bytes;
#line 597
  tmp___0 = u64_stats_fetch_retry_bh(& rx_stats->sync, start);
  }
#line 597
  if ((int )tmp___0) {
#line 599
    goto ldv_54263;
  } else {

  }
#line 598
  stats->rx_packets = stats->rx_packets + pkts;
#line 599
  stats->rx_bytes = stats->rx_bytes + bytes;
#line 600
  stats->multicast = stats->multicast + (__u64 )rxo->stats.rx_mcast_pkts;
#line 601
  stats->rx_dropped = stats->rx_dropped + (__u64 )(rxo->stats.rx_drops_no_skbs + rxo->stats.rx_drops_no_frags);
#line 591
  i = i + 1;
#line 591
  rxo = rxo + 1;
  ldv_54266: ;
#line 591
  if (i < (int )adapter->num_rx_qs) {
#line 593
    goto ldv_54265;
  } else {

  }
#line 605
  i = 0;
#line 605
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 605
  goto ldv_54272;
  ldv_54271: 
#line 606
  tx_stats = (struct be_tx_stats  const  *)(& txo->stats);
  ldv_54269: 
  {
#line 608
  start = u64_stats_fetch_begin_bh(& tx_stats->sync);
#line 609
  pkts = txo->stats.tx_pkts;
#line 610
  bytes = txo->stats.tx_bytes;
#line 611
  tmp___1 = u64_stats_fetch_retry_bh(& tx_stats->sync, start);
  }
#line 611
  if ((int )tmp___1) {
#line 613
    goto ldv_54269;
  } else {

  }
#line 612
  stats->tx_packets = stats->tx_packets + pkts;
#line 613
  stats->tx_bytes = stats->tx_bytes + bytes;
#line 605
  i = i + 1;
#line 605
  txo = txo + 1;
  ldv_54272: ;
#line 605
  if (i < (int )adapter->num_tx_qs) {
#line 607
    goto ldv_54271;
  } else {

  }
#line 617
  stats->rx_errors = (__u64 )(((((((((drvs->rx_crc_errors + drvs->rx_alignment_symbol_errors) + drvs->rx_in_range_errors) + drvs->rx_out_range_errors) + drvs->rx_frame_too_long) + drvs->rx_dropped_too_small) + drvs->rx_dropped_too_short) + drvs->rx_dropped_header_too_small) + drvs->rx_dropped_tcp_length) + drvs->rx_dropped_runt);
#line 629
  stats->rx_length_errors = (__u64 )((drvs->rx_in_range_errors + drvs->rx_out_range_errors) + drvs->rx_frame_too_long);
#line 633
  stats->rx_crc_errors = (__u64 )drvs->rx_crc_errors;
#line 636
  stats->rx_frame_errors = (__u64 )drvs->rx_alignment_symbol_errors;
#line 640
  stats->rx_fifo_errors = (__u64 )((drvs->rxpp_fifo_overflow_drop + drvs->rx_input_fifo_overflow_drop) + drvs->rx_drops_no_pbuf);
#line 643
  return (stats);
}
}
#line 646 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
void be_link_status_update(struct be_adapter *adapter , u8 link_status ) 
{ 
  struct net_device *netdev ;

  {
#line 648
  netdev = adapter->netdev;
#line 650
  if ((adapter->flags & 1U) == 0U) {
    {
#line 651
    netif_carrier_off(netdev);
#line 652
    adapter->flags = adapter->flags | 1U;
    }
  } else {

  }
#line 655
  if ((int )link_status & 1) {
    {
#line 656
    netif_carrier_on(netdev);
    }
  } else {
    {
#line 658
    netif_carrier_off(netdev);
    }
  }
#line 659
  return;
}
}
#line 661 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_tx_stats_update(struct be_tx_obj *txo , u32 wrb_cnt , u32 copied ,
                               u32 gso_segs , bool stopped ) 
{ 
  struct be_tx_stats *stats ;

  {
  {
#line 664
  stats = & txo->stats;
#line 666
  u64_stats_update_begin(& stats->sync);
#line 667
  stats->tx_reqs = stats->tx_reqs + 1ULL;
#line 668
  stats->tx_wrbs = stats->tx_wrbs + (u64 )wrb_cnt;
#line 669
  stats->tx_bytes = stats->tx_bytes + (u64 )copied;
#line 670
  stats->tx_pkts = stats->tx_pkts + (gso_segs != 0U ? (u64 )gso_segs : 1ULL);
  }
#line 671
  if ((int )stopped) {
#line 672
    stats->tx_stops = stats->tx_stops + 1U;
  } else {

  }
  {
#line 673
  u64_stats_update_begin(& stats->sync);
  }
#line 674
  return;
}
}
#line 677 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static u32 wrb_cnt_for_skb(struct be_adapter *adapter , struct sk_buff *skb , bool *dummy ) 
{ 
  int cnt ;
  unsigned char *tmp ;
  long tmp___0 ;

  {
  {
#line 680
  cnt = skb->len > skb->data_len;
#line 682
  tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 682
  cnt = cnt + (int )((struct skb_shared_info *)tmp)->nr_frags;
#line 685
  cnt = cnt + 1;
  }
#line 686
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (cnt & 1) == 0) {
#line 687
    *dummy = 0;
  } else {
#line 690
    cnt = cnt + 1;
#line 691
    *dummy = 1;
  }
  {
#line 693
  tmp___0 = __builtin_expect(cnt > 30, 0L);
  }
#line 693
  if (tmp___0 != 0L) {
    {
#line 693
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (693), "i" (12UL));
#line 693
    __builtin_unreachable();
    }
  } else {

  }
#line 694
  return ((u32 )cnt);
}
}
#line 697 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static void wrb_fill(struct be_eth_wrb *wrb , u64 addr , int len ) 
{ 


  {
#line 699
  wrb->frag_pa_hi = (unsigned int )(addr >> 32ULL);
#line 700
  wrb->frag_pa_lo = (u32 )addr;
#line 701
  wrb->frag_len = (u32 )len & 65535U;
#line 702
  wrb->rsvd0 = 0U;
#line 703
  return;
}
}
#line 705 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static u16 be_get_tx_vlan_tag(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 
  u8 vlan_prio ;
  u16 vlan_tag ;

  {
#line 711
  vlan_tag = (unsigned int )skb->vlan_tci & 61439U;
#line 712
  vlan_prio = (u8 )((int )vlan_tag >> 13);
#line 714
  if ((((int )adapter->vlan_prio_bmap >> (int )vlan_prio) & 1) == 0) {
#line 715
    vlan_tag = (u16 )(((int )((short )vlan_tag) & 8191) | (int )((short )adapter->recommended_prio));
  } else {

  }
#line 718
  return (vlan_tag);
}
}
#line 721 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void wrb_fill_hdr(struct be_adapter *adapter , struct be_eth_hdr_wrb *hdr ,
                         struct sk_buff *skb , u32 wrb_cnt , u32 len , bool skip_hw_vlan ) 
{ 
  u16 vlan_tag ;
  u32 tmp ;
  u32 tmp___0 ;
  unsigned char *tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  bool tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  bool tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;

  {
  {
#line 726
  memset((void *)hdr, 0, 16UL);
#line 728
  tmp = amap_mask(1U);
#line 728
  amap_set((void *)hdr, 2U, tmp, 2U, 1U);
#line 730
  tmp___9 = skb_is_gso((struct sk_buff  const  *)skb);
  }
#line 730
  if ((int )tmp___9) {
    {
#line 731
    tmp___0 = amap_mask(1U);
#line 731
    amap_set((void *)hdr, 2U, tmp___0, 9U, 1U);
#line 732
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 732
    tmp___2 = amap_mask(14U);
#line 732
    amap_set((void *)hdr, 2U, tmp___2, 18U, (u32 )((struct skb_shared_info *)tmp___1)->gso_size);
#line 734
    tmp___4 = skb_is_gso_v6((struct sk_buff  const  *)skb);
    }
#line 734
    if ((int )tmp___4 && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)) {
      {
#line 735
      tmp___3 = amap_mask(1U);
#line 735
      amap_set((void *)hdr, 2U, tmp___3, 4U, 1U);
      }
    } else {

    }
  } else
#line 736
  if ((unsigned int )*((unsigned char *)skb + 124UL) == 12U) {
    {
#line 737
    tmp___8 = is_tcp_pkt(skb);
    }
#line 737
    if ((unsigned int )tmp___8 != 0U) {
      {
#line 738
      tmp___5 = amap_mask(1U);
#line 738
      amap_set((void *)hdr, 2U, tmp___5, 8U, 1U);
      }
    } else {
      {
#line 739
      tmp___7 = is_udp_pkt(skb);
      }
#line 739
      if ((unsigned int )tmp___7 != 0U) {
        {
#line 740
        tmp___6 = amap_mask(1U);
#line 740
        amap_set((void *)hdr, 2U, tmp___6, 7U, 1U);
        }
      } else {

      }
    }
  } else {

  }
#line 743
  if (((int )skb->vlan_tci & 4096) != 0) {
    {
#line 744
    tmp___10 = amap_mask(1U);
#line 744
    amap_set((void *)hdr, 2U, tmp___10, 10U, 1U);
#line 745
    vlan_tag = be_get_tx_vlan_tag(adapter, skb);
#line 746
    tmp___11 = amap_mask(16U);
#line 746
    amap_set((void *)hdr, 3U, tmp___11, 16U, (u32 )vlan_tag);
    }
  } else {

  }
  {
#line 750
  tmp___12 = amap_mask(1U);
#line 750
  amap_set((void *)hdr, 2U, tmp___12, 0U, (u32 )(! skip_hw_vlan));
#line 751
  tmp___13 = amap_mask(1U);
#line 751
  amap_set((void *)hdr, 2U, tmp___13, 1U, 1U);
#line 752
  tmp___14 = amap_mask(5U);
#line 752
  amap_set((void *)hdr, 2U, tmp___14, 13U, wrb_cnt);
#line 753
  tmp___15 = amap_mask(16U);
#line 753
  amap_set((void *)hdr, 3U, tmp___15, 0U, len);
  }
#line 754
  return;
}
}
#line 756 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void unmap_tx_frag(struct device *dev , struct be_eth_wrb *wrb , bool unmap_single ) 
{ 
  dma_addr_t dma ;

  {
  {
#line 761
  swap_dws((void *)wrb, 16);
#line 763
  dma = ((unsigned long long )wrb->frag_pa_hi << 32) | (unsigned long long )wrb->frag_pa_lo;
  }
#line 764
  if (wrb->frag_len != 0U) {
#line 765
    if ((int )unmap_single) {
      {
#line 766
      dma_unmap_single_attrs(dev, dma, (size_t )wrb->frag_len, 1, (struct dma_attrs *)0);
      }
    } else {
      {
#line 769
      dma_unmap_page(dev, dma, (size_t )wrb->frag_len, 1);
      }
    }
  } else {

  }
#line 770
  return;
}
}
#line 773 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int make_tx_wrbs(struct be_adapter *adapter , struct be_queue_info *txq , struct sk_buff *skb ,
                        u32 wrb_cnt , bool dummy_wrb , bool skip_hw_vlan ) 
{ 
  dma_addr_t busaddr ;
  int i ;
  int copied ;
  struct device *dev ;
  struct sk_buff *first_skb ;
  struct be_eth_wrb *wrb ;
  struct be_eth_hdr_wrb *hdr ;
  bool map_single ;
  u16 map_head ;
  void *tmp ;
  int len ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  struct skb_frag_struct  const  *frag ;
  unsigned char *tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned char *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 778
  copied = 0;
#line 779
  dev = & (adapter->pdev)->dev;
#line 780
  first_skb = skb;
#line 783
  map_single = 0;
#line 786
  tmp = queue_head_node(txq);
#line 786
  hdr = (struct be_eth_hdr_wrb *)tmp;
#line 787
  queue_head_inc(txq);
#line 788
  map_head = txq->head;
  }
#line 790
  if (skb->len > skb->data_len) {
    {
#line 791
    tmp___0 = skb_headlen((struct sk_buff  const  *)skb);
#line 791
    len = (int )tmp___0;
#line 792
    busaddr = dma_map_single_attrs(dev, (void *)skb->data, (size_t )len, 1, (struct dma_attrs *)0);
#line 793
    tmp___1 = dma_mapping_error(dev, busaddr);
    }
#line 793
    if (tmp___1 != 0) {
#line 794
      goto dma_err;
    } else {

    }
    {
#line 795
    map_single = 1;
#line 796
    tmp___2 = queue_head_node(txq);
#line 796
    wrb = (struct be_eth_wrb *)tmp___2;
#line 797
    wrb_fill(wrb, busaddr, len);
#line 798
    swap_dws((void *)wrb, 16);
#line 799
    queue_head_inc(txq);
#line 800
    copied = copied + len;
    }
  } else {

  }
#line 803
  i = 0;
#line 803
  goto ldv_54340;
  ldv_54339: 
  {
#line 804
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 804
  frag = (struct skb_frag_struct  const  *)(& ((struct skb_shared_info *)tmp___3)->frags) + (unsigned long )i;
#line 806
  tmp___4 = skb_frag_size(frag);
#line 806
  busaddr = skb_frag_dma_map(dev, frag, 0UL, (size_t )tmp___4, 1);
#line 808
  tmp___5 = dma_mapping_error(dev, busaddr);
  }
#line 808
  if (tmp___5 != 0) {
#line 809
    goto dma_err;
  } else {

  }
  {
#line 810
  tmp___6 = queue_head_node(txq);
#line 810
  wrb = (struct be_eth_wrb *)tmp___6;
#line 811
  tmp___7 = skb_frag_size(frag);
#line 811
  wrb_fill(wrb, busaddr, (int )tmp___7);
#line 812
  swap_dws((void *)wrb, 16);
#line 813
  queue_head_inc(txq);
#line 814
  tmp___8 = skb_frag_size(frag);
#line 814
  copied = (int )((unsigned int )copied + tmp___8);
#line 803
  i = i + 1;
  }
  ldv_54340: 
  {
#line 803
  tmp___9 = skb_end_pointer((struct sk_buff  const  *)skb);
  }
#line 803
  if (i < (int )((struct skb_shared_info *)tmp___9)->nr_frags) {
#line 805
    goto ldv_54339;
  } else {

  }

#line 817
  if ((int )dummy_wrb) {
    {
#line 818
    tmp___10 = queue_head_node(txq);
#line 818
    wrb = (struct be_eth_wrb *)tmp___10;
#line 819
    wrb_fill(wrb, 0ULL, 0);
#line 820
    swap_dws((void *)wrb, 16);
#line 821
    queue_head_inc(txq);
    }
  } else {

  }
  {
#line 824
  wrb_fill_hdr(adapter, hdr, first_skb, wrb_cnt, (u32 )copied, (int )skip_hw_vlan);
#line 825
  swap_dws((void *)hdr, 16);
  }
#line 827
  return (copied);
  dma_err: 
#line 829
  txq->head = map_head;
#line 830
  goto ldv_54343;
  ldv_54342: 
  {
#line 831
  tmp___11 = queue_head_node(txq);
#line 831
  wrb = (struct be_eth_wrb *)tmp___11;
#line 832
  unmap_tx_frag(dev, wrb, (int )map_single);
#line 833
  map_single = 0;
#line 834
  copied = (int )((u32 )copied - wrb->frag_len);
#line 835
  queue_head_inc(txq);
  }
  ldv_54343: ;
#line 830
  if (copied != 0) {
#line 832
    goto ldv_54342;
  } else {

  }

#line 837
  return (0);
}
}
#line 840 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct sk_buff *be_insert_vlan_in_pkt(struct be_adapter *adapter , struct sk_buff *skb ,
                                             bool *skip_hw_vlan ) 
{ 
  u16 vlan_tag ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  {
#line 844
  vlan_tag = 0U;
#line 846
  skb = skb_share_check(skb, 32U);
#line 847
  tmp = __builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                         0L);
  }
#line 847
  if (tmp != 0L) {
#line 848
    return (skb);
  } else {

  }
#line 850
  if (((int )skb->vlan_tci & 4096) != 0) {
    {
#line 851
    vlan_tag = be_get_tx_vlan_tag(adapter, skb);
    }
  } else {

  }
  {
#line 853
  tmp___0 = qnq_async_evt_rcvd(adapter);
  }
#line 853
  if (tmp___0 != 0 && (unsigned int )adapter->pvid != 0U) {
#line 854
    if ((unsigned int )vlan_tag == 0U) {
#line 855
      vlan_tag = adapter->pvid;
    } else {

    }
#line 859
    if ((unsigned long )skip_hw_vlan != (unsigned long )((bool *)0)) {
#line 860
      *skip_hw_vlan = 1;
    } else {

    }
  } else {

  }
#line 863
  if ((unsigned int )vlan_tag != 0U) {
    {
#line 864
    skb = __vlan_put_tag(skb, 129, (int )vlan_tag);
#line 865
    tmp___1 = __builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
    }
#line 865
    if (tmp___1 != 0L) {
#line 866
      return (skb);
    } else {

    }
#line 867
    skb->vlan_tci = 0U;
  } else {

  }
#line 871
  if ((unsigned int )adapter->qnq_vid != 0U) {
    {
#line 872
    vlan_tag = adapter->qnq_vid;
#line 873
    skb = __vlan_put_tag(skb, 129, (int )vlan_tag);
#line 874
    tmp___2 = __builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
    }
#line 874
    if (tmp___2 != 0L) {
#line 875
      return (skb);
    } else {

    }
#line 876
    if ((unsigned long )skip_hw_vlan != (unsigned long )((bool *)0)) {
#line 877
      *skip_hw_vlan = 1;
    } else {

    }
  } else {

  }
#line 880
  return (skb);
}
}
#line 883 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static bool be_ipv6_exthdr_check(struct sk_buff *skb ) 
{ 
  struct ethhdr *eh ;
  u16 offset ;
  struct ipv6hdr *ip6h ;
  struct ipv6_opt_hdr *ehdr ;

  {
#line 885
  eh = (struct ethhdr *)skb->data;
#line 886
  offset = 14U;
#line 888
  if ((unsigned int )eh->h_proto == 56710U) {
#line 889
    ip6h = (struct ipv6hdr *)skb->data + (unsigned long )offset;
#line 891
    offset = (unsigned int )offset + 40U;
#line 892
    if ((unsigned int )ip6h->nexthdr != 6U && (unsigned int )ip6h->nexthdr != 17U) {
#line 894
      ehdr = (struct ipv6_opt_hdr *)skb->data + (unsigned long )offset;
#line 898
      if ((unsigned int )ehdr->hdrlen == 255U) {
#line 899
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
#line 902
  return (0);
}
}
#line 905 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vlan_tag_tx_chk(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 


  {
#line 907
  return ((((int )skb->vlan_tci & 4096) != 0 || (unsigned int )adapter->pvid != 0U) || (unsigned int )adapter->qnq_vid != 0U);
}
}
#line 910 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_ipv6_tx_stall_chk(struct be_adapter *adapter , struct sk_buff *skb ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
#line 913
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
    {
#line 913
    tmp = be_ipv6_exthdr_check(skb);
    }
#line 913
    if ((int )tmp) {
#line 913
      tmp___0 = 1;
    } else {
#line 913
      tmp___0 = 0;
    }
  } else {
#line 913
    tmp___0 = 0;
  }
#line 913
  return (tmp___0);
}
}
#line 916 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct sk_buff *be_lancer_xmit_workarounds(struct be_adapter *adapter , struct sk_buff *skb ,
                                                  bool *skip_hw_vlan ) 
{ 
  struct vlan_ethhdr *veh ;
  unsigned int eth_hdr_len ;
  struct iphdr *ip ;
  __u16 tmp ;
  __u16 tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 920
  veh = (struct vlan_ethhdr *)skb->data;
#line 928
  tmp = __fswab16((int )skb->protocol);
#line 928
  eth_hdr_len = (unsigned int )tmp == 33024U ? 18U : 14U;
  }
#line 930
  if (skb->len <= 60U && (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || ((int )skb->vlan_tci & 4096) != 0)) {
    {
#line 930
    tmp___1 = is_ipv4_pkt(skb);
    }
#line 930
    if ((int )tmp___1) {
      {
#line 933
      ip = ip_hdr((struct sk_buff  const  *)skb);
#line 934
      tmp___0 = __fswab16((int )ip->tot_len);
#line 934
      pskb_trim(skb, eth_hdr_len + (unsigned int )tmp___0);
      }
    } else {

    }
  } else {

  }
#line 940
  if ((adapter->function_mode & 16777216U) != 0U && (unsigned int )veh->h_vlan_proto == 129U) {
#line 942
    *skip_hw_vlan = 1;
  } else {

  }
#line 948
  if ((unsigned int )*((unsigned char *)skb + 124UL) != 12U && ((int )skb->vlan_tci & 4096) != 0) {
    {
#line 950
    skb = be_insert_vlan_in_pkt(adapter, skb, skip_hw_vlan);
#line 951
    tmp___2 = __builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                               0L);
    }
#line 951
    if (tmp___2 != 0L) {
#line 952
      goto err;
    } else {

    }
  } else {

  }
  {
#line 959
  tmp___3 = be_ipv6_tx_stall_chk(adapter, skb);
#line 959
  tmp___4 = __builtin_expect(tmp___3 != 0, 0L);
  }
#line 959
  if (tmp___4 != 0L) {
    {
#line 959
    tmp___5 = __builtin_expect((unsigned int )adapter->pvid != 0U, 0L);
    }
#line 959
    if (tmp___5 != 0L) {
#line 959
      tmp___7 = 1;
    } else {
      {
#line 959
      tmp___6 = __builtin_expect((unsigned int )adapter->qnq_vid != 0U, 0L);
      }
#line 959
      if (tmp___6 != 0L) {
#line 959
        tmp___7 = 1;
      } else {
#line 959
        tmp___7 = 0;
      }
    }
#line 959
    if (tmp___7 != 0) {
#line 959
      tmp___8 = 1;
    } else {
#line 959
      tmp___8 = 0;
    }
  } else {
#line 959
    tmp___8 = 0;
  }
#line 959
  if (tmp___8 != 0) {
    {
#line 959
    tmp___9 = qnq_async_evt_rcvd(adapter);
#line 959
    tmp___10 = __builtin_expect(tmp___9 == 0, 0L);
    }
#line 959
    if (tmp___10 != 0L) {
#line 962
      goto tx_drop;
    } else {

    }
  } else {

  }
  {
#line 970
  tmp___12 = be_ipv6_tx_stall_chk(adapter, skb);
  }
#line 970
  if (tmp___12 != 0) {
    {
#line 970
    tmp___13 = be_vlan_tag_tx_chk(adapter, skb);
    }
#line 970
    if (tmp___13 != 0) {
      {
#line 972
      skb = be_insert_vlan_in_pkt(adapter, skb, skip_hw_vlan);
#line 973
      tmp___11 = __builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                                  0L);
      }
#line 973
      if (tmp___11 != 0L) {
#line 974
        goto err;
      } else {

      }
    } else {

    }
  } else {

  }
#line 977
  return (skb);
  tx_drop: 
  {
#line 979
  dev_kfree_skb_any(skb);
  }
  err: ;
#line 981
  return ((struct sk_buff *)0);
}
}
#line 984 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct sk_buff *be_xmit_workarounds(struct be_adapter *adapter , struct sk_buff *skb ,
                                           bool *skip_hw_vlan ) 
{ 
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 992
  tmp___0 = __builtin_expect((long )((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U),
                             0L);
  }
#line 992
  if (tmp___0 != 0L) {
    {
#line 992
    tmp___1 = __builtin_expect((long )((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U),
                               0L);
    }
#line 992
    if (tmp___1 != 0L) {
#line 992
      tmp___2 = 1;
    } else {
#line 992
      tmp___2 = 0;
    }
  } else {
#line 992
    tmp___2 = 0;
  }
#line 992
  if (tmp___2 != 0) {
    {
#line 992
    tmp___3 = __builtin_expect(skb->len <= 32U, 0L);
    }
#line 992
    if (tmp___3 != 0L) {
      {
#line 993
      tmp = skb_padto(skb, 36U);
      }
#line 993
      if (tmp != 0) {
#line 994
        return ((struct sk_buff *)0);
      } else {

      }
#line 995
      skb->len = 36U;
    } else {

    }
  } else {

  }
#line 998
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
    {
#line 999
    skb = be_lancer_xmit_workarounds(adapter, skb, skip_hw_vlan);
    }
#line 1000
    if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1001
      return ((struct sk_buff *)0);
    } else {

    }
  } else {

  }
#line 1004
  return (skb);
}
}
#line 1007 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static netdev_tx_t be_xmit(struct sk_buff *skb , struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_tx_obj *txo ;
  u16 tmp___0 ;
  struct be_queue_info *txq ;
  bool dummy_wrb ;
  bool stopped ;
  u32 wrb_cnt ;
  u32 copied ;
  bool skip_hw_vlan ;
  u32 start ;
  int tmp___1 ;
  int gso_segs ;
  unsigned char *tmp___2 ;
  long tmp___3 ;
  u16 tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1009
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1009
  adapter = (struct be_adapter *)tmp;
#line 1010
  tmp___0 = skb_get_queue_mapping((struct sk_buff  const  *)skb);
#line 1010
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )tmp___0;
#line 1011
  txq = & txo->q;
#line 1012
  stopped = 0;
#line 1013
  wrb_cnt = 0U;
#line 1013
  copied = 0U;
#line 1014
  skip_hw_vlan = 0;
#line 1015
  start = (u32 )txq->head;
#line 1017
  skb = be_xmit_workarounds(adapter, skb, & skip_hw_vlan);
  }
#line 1018
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
#line 1019
    txo->stats.tx_drv_drops = txo->stats.tx_drv_drops + 1U;
#line 1020
    return (0);
  } else {

  }
  {
#line 1023
  wrb_cnt = wrb_cnt_for_skb(adapter, skb, & dummy_wrb);
#line 1025
  tmp___1 = make_tx_wrbs(adapter, txq, skb, wrb_cnt, (int )dummy_wrb, (int )skip_hw_vlan);
#line 1025
  copied = (u32 )tmp___1;
  }
#line 1027
  if (copied != 0U) {
    {
#line 1028
    tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1028
    gso_segs = (int )((struct skb_shared_info *)tmp___2)->gso_segs;
#line 1031
    tmp___3 = __builtin_expect((unsigned long )txo->sent_skb_list[start] != (unsigned long )((struct sk_buff *)0),
                               0L);
    }
#line 1031
    if (tmp___3 != 0L) {
      {
#line 1031
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_main.c"),
                           "i" (1031), "i" (12UL));
#line 1031
      __builtin_unreachable();
      }
    } else {

    }
    {
#line 1032
    txo->sent_skb_list[start] = skb;
#line 1038
    atomic_add((int )wrb_cnt, & txq->used);
#line 1039
    tmp___5 = atomic_read((atomic_t const   *)(& txq->used));
    }
#line 1039
    if (tmp___5 + 30 >= (int )txq->len) {
      {
#line 1041
      tmp___4 = skb_get_queue_mapping((struct sk_buff  const  *)skb);
#line 1041
      netif_stop_subqueue(netdev, (int )tmp___4);
#line 1042
      stopped = 1;
      }
    } else {

    }
    {
#line 1045
    be_txq_notify(adapter, txo, (int )((u16 )wrb_cnt));
#line 1047
    be_tx_stats_update(txo, wrb_cnt, copied, (u32 )gso_segs, (int )stopped);
    }
  } else {
    {
#line 1049
    txq->head = (u16 )start;
#line 1050
    txo->stats.tx_drv_drops = txo->stats.tx_drv_drops + 1U;
#line 1051
    dev_kfree_skb_any(skb);
    }
  }
#line 1053
  return (0);
}
}
#line 1056 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_change_mtu(struct net_device *netdev , int new_mtu ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 1058
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1058
  adapter = (struct be_adapter *)tmp;
  }
#line 1059
  if ((unsigned int )new_mtu - 256U > 8744U) {
    {
#line 1062
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MTU must be between %d and %d bytes\n",
              256, 9000);
    }
#line 1066
    return (-22);
  } else {

  }
  {
#line 1068
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "MTU changed from %d to %d bytes\n",
            netdev->mtu, new_mtu);
#line 1070
  netdev->mtu = (unsigned int )new_mtu;
  }
#line 1071
  return (0);
}
}
#line 1078 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vid_config(struct be_adapter *adapter ) 
{ 
  u16 vids[64U] ;
  u16 num ;
  u16 i ;
  int status ;
  u16 tmp ;

  {
#line 1081
  num = 0U;
#line 1082
  status = 0;
#line 1085
  if ((int )adapter->promiscuous) {
#line 1086
    return (0);
  } else {

  }
#line 1088
  if ((int )adapter->vlans_added > (int )adapter->res.max_vlans) {
#line 1089
    goto set_vlan_promisc;
  } else {

  }
#line 1092
  i = 0U;
#line 1092
  goto ldv_54409;
  ldv_54408: ;
#line 1093
  if ((unsigned int )adapter->vlan_tag[(int )i] != 0U) {
#line 1094
    tmp = num;
#line 1094
    num = (u16 )((int )num + 1);
#line 1094
    vids[(int )tmp] = i;
  } else {

  }
#line 1092
  i = (u16 )((int )i + 1);
  ldv_54409: ;
#line 1092
  if ((unsigned int )i <= 4095U) {
#line 1094
    goto ldv_54408;
  } else {

  }
  {
#line 1096
  status = be_cmd_vlan_config(adapter, (u32 )adapter->if_handle, (u16 *)(& vids),
                              (u32 )num, 0);
  }
#line 1099
  if (status != 0) {
#line 1101
    if (status == 22) {
#line 1102
      goto set_vlan_promisc;
    } else {

    }
    {
#line 1103
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Setting HW VLAN filtering failed.\n");
    }
  } else
#line 1106
  if ((adapter->flags & 16U) != 0U) {
    {
#line 1108
    status = be_cmd_rx_filter(adapter, 16U, 0U);
    }
#line 1110
    if (status == 0) {
      {
#line 1111
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Disabling VLAN Promiscuous mode.\n");
#line 1113
      adapter->flags = adapter->flags & 4294967279U;
      }
    } else {

    }
  } else {

  }
#line 1118
  return (status);
  set_vlan_promisc: ;
#line 1121
  if ((adapter->flags & 16U) != 0U) {
#line 1122
    return (0);
  } else {

  }
  {
#line 1124
  status = be_cmd_rx_filter(adapter, 16U, 1U);
  }
#line 1125
  if (status == 0) {
    {
#line 1126
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Enable VLAN Promiscuous mode\n");
#line 1127
    adapter->flags = adapter->flags | 16U;
    }
  } else {
    {
#line 1129
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Failed to enable VLAN Promiscuous mode.\n");
    }
  }
#line 1131
  return (status);
}
}
#line 1134 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vlan_add_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
  {
#line 1136
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1136
  adapter = (struct be_adapter *)tmp;
#line 1137
  status = 0;
  }
#line 1140
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )vid == 0U) {
#line 1141
    goto ret;
  } else {

  }
  {
#line 1143
  adapter->vlan_tag[(int )vid] = 1U;
#line 1144
  adapter->vlans_added = (u16 )((int )adapter->vlans_added + 1);
#line 1146
  status = be_vid_config(adapter);
  }
#line 1147
  if (status != 0) {
#line 1148
    adapter->vlans_added = (u16 )((int )adapter->vlans_added - 1);
#line 1149
    adapter->vlan_tag[(int )vid] = 0U;
  } else {

  }
  ret: ;
#line 1152
  return (status);
}
}
#line 1155 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vlan_rem_vid(struct net_device *netdev , __be16 proto , u16 vid ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
  {
#line 1157
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1157
  adapter = (struct be_adapter *)tmp;
#line 1158
  status = 0;
  }
#line 1161
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && (unsigned int )vid == 0U) {
#line 1162
    goto ret;
  } else {

  }
  {
#line 1164
  adapter->vlan_tag[(int )vid] = 0U;
#line 1165
  status = be_vid_config(adapter);
  }
#line 1166
  if (status == 0) {
#line 1167
    adapter->vlans_added = (u16 )((int )adapter->vlans_added - 1);
  } else {
#line 1169
    adapter->vlan_tag[(int )vid] = 1U;
  }
  ret: ;
#line 1171
  return (status);
}
}
#line 1174 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_clear_promisc(struct be_adapter *adapter ) 
{ 


  {
  {
#line 1176
  adapter->promiscuous = 0;
#line 1177
  adapter->flags = adapter->flags & 4294967279U;
#line 1179
  be_cmd_rx_filter(adapter, 256U, 0U);
  }
#line 1180
  return;
}
}
#line 1182 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_set_rx_mode(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  struct netdev_hw_addr *ha ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 1184
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1184
  adapter = (struct be_adapter *)tmp;
  }
#line 1187
  if ((netdev->flags & 256U) != 0U) {
    {
#line 1188
    be_cmd_rx_filter(adapter, 256U, 1U);
#line 1189
    adapter->promiscuous = 1;
    }
#line 1190
    goto done;
  } else {

  }
#line 1194
  if ((int )adapter->promiscuous) {
    {
#line 1195
    be_clear_promisc(adapter);
    }
#line 1196
    if ((unsigned int )adapter->vlans_added != 0U) {
      {
#line 1197
      be_vid_config(adapter);
      }
    } else {

    }
  } else {

  }
#line 1201
  if ((netdev->flags & 512U) != 0U || netdev->mc.count > (int )adapter->res.max_mcast_mac) {
    {
#line 1203
    be_cmd_rx_filter(adapter, 512U, 1U);
    }
#line 1204
    goto done;
  } else {

  }
#line 1207
  if ((u32 )netdev->uc.count != adapter->uc_macs) {
#line 1209
    i = 1;
#line 1211
    goto ldv_54439;
    ldv_54438: 
    {
#line 1212
    be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                    0U);
#line 1211
    adapter->uc_macs = adapter->uc_macs - 1U;
#line 1211
    i = i + 1;
    }
    ldv_54439: ;
#line 1211
    if (adapter->uc_macs != 0U) {
#line 1213
      goto ldv_54438;
    } else {

    }

#line 1216
    if (netdev->uc.count > (int )adapter->res.max_uc_mac) {
      {
#line 1217
      be_cmd_rx_filter(adapter, 256U, 1U);
#line 1218
      adapter->promiscuous = 1;
      }
#line 1219
      goto done;
    } else {

    }
#line 1222
    __mptr = (struct list_head  const  *)(adapter->netdev)->uc.list.next;
#line 1222
    ha = (struct netdev_hw_addr *)__mptr;
#line 1222
    goto ldv_54446;
    ldv_54445: 
    {
#line 1223
    adapter->uc_macs = adapter->uc_macs + 1U;
#line 1224
    be_cmd_pmac_add(adapter, (u8 *)(& ha->addr), (u32 )adapter->if_handle, adapter->pmac_id + (unsigned long )adapter->uc_macs,
                    0U);
#line 1222
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 1222
    ha = (struct netdev_hw_addr *)__mptr___0;
    }
    ldv_54446: ;
#line 1222
    if ((unsigned long )(& ha->list) != (unsigned long )(& (adapter->netdev)->uc.list)) {
#line 1224
      goto ldv_54445;
    } else {

    }

  } else {

  }
  {
#line 1230
  status = be_cmd_rx_filter(adapter, 4096U, 1U);
  }
#line 1233
  if (status != 0) {
    {
#line 1234
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Exhausted multicast HW filters.\n");
#line 1235
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Disabling HW multicast filtering.\n");
#line 1236
    be_cmd_rx_filter(adapter, 512U, 1U);
    }
  } else {

  }
  done: ;
#line 1239
  return;
}
}
#line 1242 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_mac(struct net_device *netdev , int vf , u8 *mac ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1244
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1244
  adapter = (struct be_adapter *)tmp;
#line 1245
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
  }
#line 1248
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1249
    return (-1);
  } else {

  }
  {
#line 1251
  tmp___0 = is_valid_ether_addr((u8 const   *)mac);
  }
#line 1251
  if (tmp___0) {
#line 1251
    tmp___1 = 0;
  } else {
#line 1251
    tmp___1 = 1;
  }
#line 1251
  if (tmp___1 || vf >= (int )adapter->num_vfs) {
#line 1252
    return (-22);
  } else {

  }
#line 1254
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 1255
    be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, vf_cfg->pmac_id, (u32 )(vf + 1));
#line 1258
    status = be_cmd_pmac_add(adapter, mac, (u32 )vf_cfg->if_handle, (u32 *)(& vf_cfg->pmac_id),
                             (u32 )(vf + 1));
    }
  } else {
    {
#line 1261
    status = be_cmd_set_mac(adapter, mac, vf_cfg->if_handle, (u32 )(vf + 1));
    }
  }
#line 1265
  if (status != 0) {
    {
#line 1266
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "MAC %pM set on VF %d Failed\n",
            mac, vf);
    }
  } else {
    {
#line 1269
    memcpy((void *)(& vf_cfg->mac_addr), (void const   *)mac, 6UL);
    }
  }
#line 1271
  return (status);
}
}
#line 1274 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_vf_config(struct net_device *netdev , int vf , struct ifla_vf_info *vi ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;

  {
  {
#line 1277
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1277
  adapter = (struct be_adapter *)tmp;
#line 1278
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
  }
#line 1280
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1281
    return (-1);
  } else {

  }
#line 1283
  if (vf >= (int )adapter->num_vfs) {
#line 1284
    return (-22);
  } else {

  }
  {
#line 1286
  vi->vf = (__u32 )vf;
#line 1287
  vi->tx_rate = vf_cfg->tx_rate;
#line 1288
  vi->vlan = (__u32 )vf_cfg->vlan_tag & 4095U;
#line 1289
  vi->qos = (__u32 )((int )vf_cfg->vlan_tag >> 13);
#line 1290
  memcpy((void *)(& vi->mac), (void const   *)(& vf_cfg->mac_addr), 6UL);
  }
#line 1292
  return (0);
}
}
#line 1295 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_vlan(struct net_device *netdev , int vf , u16 vlan , u8 qos ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_vf_cfg *vf_cfg ;
  int status ;

  {
  {
#line 1298
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1298
  adapter = (struct be_adapter *)tmp;
#line 1299
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 1300
  status = 0;
  }
#line 1302
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1303
    return (-1);
  } else {

  }
#line 1305
  if ((vf >= (int )adapter->num_vfs || (unsigned int )vlan > 4095U) || (unsigned int )qos > 7U) {
#line 1306
    return (-22);
  } else {

  }
#line 1308
  if ((unsigned int )vlan != 0U || (unsigned int )qos != 0U) {
#line 1309
    vlan = (u16 )((int )((short )vlan) | (int )((short )((int )qos << 13)));
#line 1310
    if ((int )vf_cfg->vlan_tag != (int )vlan) {
      {
#line 1311
      status = be_cmd_set_hsw_config(adapter, (int )vlan, (u32 )(vf + 1), (int )((u16 )vf_cfg->if_handle),
                                     0);
      }
    } else {

    }
  } else {
    {
#line 1315
    status = be_cmd_set_hsw_config(adapter, 65535, (u32 )(vf + 1), (int )((u16 )vf_cfg->if_handle),
                                   0);
    }
  }
#line 1319
  if (status == 0) {
#line 1320
    vf_cfg->vlan_tag = vlan;
  } else {
    {
#line 1322
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "VLAN %d config on VF %d failed\n",
              (int )vlan, vf);
    }
  }
#line 1324
  return (status);
}
}
#line 1327 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_set_vf_tx_rate(struct net_device *netdev , int vf , int rate ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
  {
#line 1330
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1330
  adapter = (struct be_adapter *)tmp;
#line 1331
  status = 0;
  }
#line 1333
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 1334
    return (-1);
  } else {

  }
#line 1336
  if (vf >= (int )adapter->num_vfs) {
#line 1337
    return (-22);
  } else {

  }
#line 1339
  if ((unsigned int )rate - 100U > 9900U) {
    {
#line 1340
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "tx rate must be between 100 and 10000 Mbps\n");
    }
#line 1342
    return (-22);
  } else {

  }
#line 1345
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
    {
#line 1346
    status = be_cmd_set_profile_config(adapter, (u32 )(rate / 10), (int )((unsigned int )((u8 )vf) + 1U));
    }
  } else {
    {
#line 1348
    status = be_cmd_set_qos(adapter, (u32 )(rate / 10), (u32 )(vf + 1));
    }
  }
#line 1350
  if (status != 0) {
    {
#line 1351
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "tx rate %d on VF %d failed\n",
            rate, vf);
    }
  } else {
#line 1354
    (adapter->vf_cfg + (unsigned long )vf)->tx_rate = (u32 )rate;
  }
#line 1355
  return (status);
}
}
#line 1358 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_aic_update(struct be_aic_obj *aic , u64 rx_pkts , u64 tx_pkts , ulong now ) 
{ 


  {
#line 1361
  aic->rx_pkts_prev = rx_pkts;
#line 1362
  aic->tx_reqs_prev = tx_pkts;
#line 1363
  aic->jiffies = now;
#line 1364
  return;
}
}
#line 1366 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_eqd_update(struct be_adapter *adapter ) 
{ 
  struct be_set_eqd set_eqd[32U] ;
  int eqd ;
  int i ;
  int num ;
  int start ;
  struct be_aic_obj *aic ;
  struct be_eq_obj *eqo ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u64 rx_pkts ;
  u64 tx_pkts ;
  ulong now ;
  u32 pps ;
  u32 delta ;
  unsigned int tmp ;
  bool tmp___0 ;
  unsigned int tmp___1 ;
  bool tmp___2 ;
  u32 __min1 ;
  u32 __min2 ;
  u32 __max1 ;
  u32 __max2 ;

  {
#line 1369
  num = 0;
#line 1378
  i = 0;
#line 1378
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 1378
  goto ldv_54521;
  ldv_54520: 
#line 1379
  aic = (struct be_aic_obj *)(& adapter->aic_obj) + (unsigned long )eqo->idx;
#line 1380
  if (! aic->enable) {
#line 1381
    if (aic->jiffies != 0UL) {
#line 1382
      aic->jiffies = 0UL;
    } else {

    }
#line 1383
    eqd = (int )aic->et_eqd;
#line 1384
    goto modify_eqd;
  } else {

  }
#line 1387
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )eqo->idx;
  ldv_54503: 
  {
#line 1389
  tmp = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& rxo->stats.sync));
#line 1389
  start = (int )tmp;
#line 1390
  rx_pkts = rxo->stats.rx_pkts;
#line 1391
  tmp___0 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& rxo->stats.sync),
                                     (unsigned int )start);
  }
#line 1391
  if ((int )tmp___0) {
#line 1393
    goto ldv_54503;
  } else {

  }
#line 1393
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )eqo->idx;
  ldv_54505: 
  {
#line 1395
  tmp___1 = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& txo->stats.sync));
#line 1395
  start = (int )tmp___1;
#line 1396
  tx_pkts = txo->stats.tx_reqs;
#line 1397
  tmp___2 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& txo->stats.sync),
                                     (unsigned int )start);
  }
#line 1397
  if ((int )tmp___2) {
#line 1399
    goto ldv_54505;
  } else {

  }
#line 1401
  now = jiffies;
#line 1402
  if (((aic->jiffies == 0UL || (long )(now - aic->jiffies) < 0L) || rx_pkts < aic->rx_pkts_prev) || tx_pkts < aic->tx_reqs_prev) {
    {
#line 1405
    be_aic_update(aic, rx_pkts, tx_pkts, now);
    }
#line 1406
    goto ldv_54513;
  } else {

  }
  {
#line 1409
  delta = jiffies_to_msecs(now - aic->jiffies);
#line 1410
  pps = (((unsigned int )rx_pkts - (unsigned int )aic->rx_pkts_prev) * 1000U) / delta + (((unsigned int )tx_pkts - (unsigned int )aic->tx_reqs_prev) * 1000U) / delta;
#line 1412
  eqd = (int )(pps / 15000U << 2);
  }
#line 1414
  if (eqd <= 7) {
#line 1415
    eqd = 0;
  } else {

  }
  {
#line 1416
  __min1 = (u32 )eqd;
#line 1416
  __min2 = aic->max_eqd;
#line 1416
  eqd = (int )(__min1 < __min2 ? __min1 : __min2);
#line 1417
  __max1 = (u32 )eqd;
#line 1417
  __max2 = aic->min_eqd;
#line 1417
  eqd = (int )(__max1 > __max2 ? __max1 : __max2);
#line 1419
  be_aic_update(aic, rx_pkts, tx_pkts, now);
  }
  modify_eqd: ;
#line 1421
  if ((u32 )eqd != aic->prev_eqd) {
#line 1422
    set_eqd[num].delay_multiplier = (u32 )((eqd * 65) / 100);
#line 1423
    set_eqd[num].eq_id = (u32 )eqo->q.id;
#line 1424
    aic->prev_eqd = (u32 )eqd;
#line 1425
    num = num + 1;
  } else {

  }
  ldv_54513: 
#line 1378
  i = i + 1;
#line 1378
  eqo = eqo + 1;
  ldv_54521: ;
#line 1378
  if (i < (int )adapter->num_evt_qs) {
#line 1380
    goto ldv_54520;
  } else {

  }

#line 1429
  if (num != 0) {
    {
#line 1430
    be_cmd_modify_eqd(adapter, (struct be_set_eqd *)(& set_eqd), num);
    }
  } else {

  }
#line 1431
  return;
}
}
#line 1433 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_stats_update(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_stats *stats ;

  {
  {
#line 1436
  stats = & rxo->stats;
#line 1438
  u64_stats_update_begin(& stats->sync);
#line 1439
  stats->rx_compl = stats->rx_compl + 1U;
#line 1440
  stats->rx_bytes = stats->rx_bytes + (u64 )rxcp->pkt_size;
#line 1441
  stats->rx_pkts = stats->rx_pkts + 1ULL;
  }
#line 1442
  if ((unsigned int )rxcp->pkt_type == 1U) {
#line 1443
    stats->rx_mcast_pkts = stats->rx_mcast_pkts + 1U;
  } else {

  }
#line 1444
  if ((unsigned int )rxcp->err != 0U) {
#line 1445
    stats->rx_compl_err = stats->rx_compl_err + 1U;
  } else {

  }
  {
#line 1446
  u64_stats_update_begin(& stats->sync);
  }
#line 1447
  return;
}
}
#line 1449 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool csum_passed(struct be_rx_compl_info *rxcp ) 
{ 


  {
#line 1453
  return ((bool )(((unsigned int )*((unsigned short *)rxcp + 7UL) != 0U && (unsigned int )rxcp->l4_csum != 0U) && *((unsigned int *)rxcp + 4UL) != 0U));
}
}
#line 1457 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct be_rx_page_info *get_rx_page_info(struct be_rx_obj *rxo ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *rx_page_info ;
  struct be_queue_info *rxq ;
  u16 frag_idx ;
  long tmp ;

  {
  {
#line 1459
  adapter = rxo->adapter;
#line 1461
  rxq = & rxo->q;
#line 1462
  frag_idx = rxq->tail;
#line 1464
  rx_page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )frag_idx;
#line 1465
  tmp = __builtin_expect((unsigned long )rx_page_info->page == (unsigned long )((struct page *)0),
                         0L);
  }
#line 1465
  if (tmp != 0L) {
    {
#line 1465
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (1465), "i" (12UL));
#line 1465
    __builtin_unreachable();
    }
  } else {

  }
#line 1467
  if ((int )rx_page_info->last_page_user) {
    {
#line 1468
    dma_unmap_page(& (adapter->pdev)->dev, rx_page_info->bus, (size_t )adapter->big_page_size,
                   2);
#line 1471
    rx_page_info->last_page_user = 0;
    }
  } else {

  }
  {
#line 1474
  queue_tail_inc(rxq);
#line 1475
  atomic_dec(& rxq->used);
  }
#line 1476
  return (rx_page_info);
}
}
#line 1480 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_compl_discard(struct be_rx_obj *rxo , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_page_info *page_info ;
  u16 i ;
  u16 num_rcvd ;

  {
#line 1484
  num_rcvd = (u16 )rxcp->num_rcvd;
#line 1486
  i = 0U;
#line 1486
  goto ldv_54546;
  ldv_54545: 
  {
#line 1487
  page_info = get_rx_page_info(rxo);
#line 1488
  put_page(page_info->page);
#line 1489
  memset((void *)page_info, 0, 24UL);
#line 1486
  i = (u16 )((int )i + 1);
  }
  ldv_54546: ;
#line 1486
  if ((int )i < (int )num_rcvd) {
#line 1488
    goto ldv_54545;
  } else {

  }

#line 1493
  return;
}
}
#line 1497 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void skb_fill_rx_data(struct be_rx_obj *rxo , struct sk_buff *skb , struct be_rx_compl_info *rxcp ) 
{ 
  struct be_rx_page_info *page_info ;
  u16 i ;
  u16 j ;
  u16 hdr_len ;
  u16 curr_frag_len ;
  u16 remaining ;
  u8 *start ;
  void *tmp ;
  u16 _min1 ;
  ushort _min2 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  long tmp___3 ;
  u16 _min1___0 ;
  ushort _min2___0 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  long tmp___8 ;

  {
  {
#line 1505
  page_info = get_rx_page_info(rxo);
#line 1506
  tmp = lowmem_page_address((struct page  const  *)page_info->page);
#line 1506
  start = (u8 *)tmp + (unsigned long )page_info->page_offset;
#line 1507
  __builtin_prefetch((void const   *)start);
#line 1510
  _min1 = rxcp->pkt_size;
#line 1510
  _min2 = rx_frag_size;
#line 1510
  curr_frag_len = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 1512
  skb->len = (unsigned int )curr_frag_len;
  }
#line 1513
  if ((unsigned int )curr_frag_len <= 64U) {
    {
#line 1514
    memcpy((void *)skb->data, (void const   *)start, (size_t )curr_frag_len);
#line 1516
    put_page(page_info->page);
#line 1517
    skb->data_len = 0U;
#line 1518
    skb->tail = skb->tail + (sk_buff_data_t )curr_frag_len;
    }
  } else {
    {
#line 1520
    hdr_len = 14U;
#line 1521
    memcpy((void *)skb->data, (void const   *)start, (size_t )hdr_len);
#line 1522
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1522
    ((struct skb_shared_info *)tmp___0)->nr_frags = 1U;
#line 1523
    skb_frag_set_page(skb, 0, page_info->page);
#line 1524
    tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1524
    ((struct skb_shared_info *)tmp___1)->frags[0].page_offset = (__u32 )((int )page_info->page_offset + (int )hdr_len);
#line 1526
    tmp___2 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1526
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___2)->frags),
                      (unsigned int )((int )curr_frag_len - (int )hdr_len));
#line 1527
    skb->data_len = (unsigned int )((int )curr_frag_len - (int )hdr_len);
#line 1528
    skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1529
    skb->tail = skb->tail + (sk_buff_data_t )hdr_len;
    }
  }
#line 1531
  page_info->page = (struct page *)0;
#line 1533
  if ((int )rxcp->pkt_size <= (int )rx_frag_size) {
    {
#line 1534
    tmp___3 = __builtin_expect((unsigned int )rxcp->num_rcvd != 1U, 0L);
    }
#line 1534
    if (tmp___3 != 0L) {
      {
#line 1534
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_main.c"),
                           "i" (1534), "i" (12UL));
#line 1534
      __builtin_unreachable();
      }
    } else {

    }
#line 1535
    return;
  } else {

  }
#line 1539
  remaining = (int )rxcp->pkt_size - (int )curr_frag_len;
#line 1540
  i = 1U;
#line 1540
  j = 0U;
#line 1540
  goto ldv_54567;
  ldv_54566: 
  {
#line 1541
  page_info = get_rx_page_info(rxo);
#line 1542
  _min1___0 = remaining;
#line 1542
  _min2___0 = rx_frag_size;
#line 1542
  curr_frag_len = (u16 )((int )_min1___0 < (int )_min2___0 ? _min1___0 : _min2___0);
  }
#line 1545
  if ((unsigned int )page_info->page_offset == 0U) {
    {
#line 1547
    j = (u16 )((int )j + 1);
#line 1548
    skb_frag_set_page(skb, (int )j, page_info->page);
#line 1549
    tmp___4 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1549
    ((struct skb_shared_info *)tmp___4)->frags[(int )j].page_offset = (__u32 )page_info->page_offset;
#line 1551
    tmp___5 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1551
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___5)->frags) + (unsigned long )j,
                      0U);
#line 1552
    tmp___6 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1552
    ((struct skb_shared_info *)tmp___6)->nr_frags = (unsigned char )((int )((struct skb_shared_info *)tmp___6)->nr_frags + 1);
    }
  } else {
    {
#line 1554
    put_page(page_info->page);
    }
  }
  {
#line 1557
  tmp___7 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1557
  skb_frag_size_add((skb_frag_t *)(& ((struct skb_shared_info *)tmp___7)->frags) + (unsigned long )j,
                    (int )curr_frag_len);
#line 1558
  skb->len = skb->len + (unsigned int )curr_frag_len;
#line 1559
  skb->data_len = skb->data_len + (unsigned int )curr_frag_len;
#line 1560
  skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1561
  remaining = (int )remaining - (int )curr_frag_len;
#line 1562
  page_info->page = (struct page *)0;
#line 1540
  i = (u16 )((int )i + 1);
  }
  ldv_54567: ;
#line 1540
  if ((int )i < (int )((unsigned short )rxcp->num_rcvd)) {
#line 1542
    goto ldv_54566;
  } else {

  }
  {
#line 1564
  tmp___8 = __builtin_expect((unsigned int )j > 17U, 0L);
  }
#line 1564
  if (tmp___8 != 0L) {
    {
#line 1564
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (1564), "i" (12UL));
#line 1564
    __builtin_unreachable();
    }
  } else {

  }
#line 1566
  return;
}
}
#line 1568 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_compl_process(struct be_rx_obj *rxo , struct napi_struct *napi ,
                                struct be_rx_compl_info *rxcp ) 
{ 
  struct be_adapter *adapter ;
  struct net_device *netdev ;
  struct sk_buff *skb ;
  long tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1571
  adapter = rxo->adapter;
#line 1572
  netdev = adapter->netdev;
#line 1575
  skb = netdev_alloc_skb_ip_align(netdev, 128U);
#line 1576
  tmp = __builtin_expect((unsigned long )skb == (unsigned long )((struct sk_buff *)0),
                         0L);
  }
#line 1576
  if (tmp != 0L) {
    {
#line 1577
    rxo->stats.rx_drops_no_skbs = rxo->stats.rx_drops_no_skbs + 1U;
#line 1578
    be_rx_compl_discard(rxo, rxcp);
    }
#line 1579
    return;
  } else {

  }
  {
#line 1582
  skb_fill_rx_data(rxo, skb, rxcp);
#line 1584
  tmp___0 = __builtin_expect((netdev->features & 4294967296ULL) != 0ULL, 1L);
  }
#line 1584
  if (tmp___0 != 0L) {
    {
#line 1584
    tmp___1 = csum_passed(rxcp);
#line 1584
    tmp___2 = __builtin_expect((long )tmp___1, 1L);
    }
#line 1584
    if (tmp___2 != 0L) {
#line 1585
      skb->ip_summed = 1U;
    } else {
      {
#line 1587
      skb_checksum_none_assert((struct sk_buff  const  *)skb);
      }
    }
  } else {
    {
#line 1587
    skb_checksum_none_assert((struct sk_buff  const  *)skb);
    }
  }
  {
#line 1589
  skb->protocol = eth_type_trans(skb, netdev);
#line 1590
  skb_record_rx_queue(skb, (int )((u16 )(((long )rxo - (long )(& adapter->rx_obj)) / 24768L)));
  }
#line 1591
  if ((netdev->features & 2147483648ULL) != 0ULL) {
    {
#line 1592
    skb_set_hash(skb, rxcp->rss_hash, 2);
    }
  } else {

  }
  {
#line 1593
  skb_mark_napi_id(skb, napi);
  }
#line 1595
  if ((unsigned int )rxcp->vlanf != 0U) {
    {
#line 1596
    __vlan_hwaccel_put_tag(skb, 129, (int )rxcp->vlan_tag);
    }
  } else {

  }
  {
#line 1598
  netif_receive_skb(skb);
  }
#line 1599
  return;
}
}
#line 1602 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_compl_process_gro(struct be_rx_obj *rxo , struct napi_struct *napi ,
                                    struct be_rx_compl_info *rxcp ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *page_info ;
  struct sk_buff *skb ;
  u16 remaining ;
  u16 curr_frag_len ;
  u16 i ;
  u16 j ;
  u16 _min1 ;
  ushort _min2 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  long tmp___2 ;
  unsigned char *tmp___3 ;

  {
  {
#line 1606
  adapter = rxo->adapter;
#line 1608
  skb = (struct sk_buff *)0;
#line 1612
  skb = napi_get_frags(napi);
  }
#line 1613
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    {
#line 1614
    be_rx_compl_discard(rxo, rxcp);
    }
#line 1615
    return;
  } else {

  }
#line 1618
  remaining = rxcp->pkt_size;
#line 1619
  i = 0U;
#line 1619
  j = 65535U;
#line 1619
  goto ldv_54593;
  ldv_54592: 
  {
#line 1620
  page_info = get_rx_page_info(rxo);
#line 1622
  _min1 = remaining;
#line 1622
  _min2 = rx_frag_size;
#line 1622
  curr_frag_len = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
  }
#line 1625
  if ((unsigned int )i == 0U || (unsigned int )page_info->page_offset == 0U) {
    {
#line 1627
    j = (u16 )((int )j + 1);
#line 1628
    skb_frag_set_page(skb, (int )j, page_info->page);
#line 1629
    tmp = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1629
    ((struct skb_shared_info *)tmp)->frags[(int )j].page_offset = (__u32 )page_info->page_offset;
#line 1631
    tmp___0 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1631
    skb_frag_size_set((skb_frag_t *)(& ((struct skb_shared_info *)tmp___0)->frags) + (unsigned long )j,
                      0U);
    }
  } else {
    {
#line 1633
    put_page(page_info->page);
    }
  }
  {
#line 1635
  tmp___1 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1635
  skb_frag_size_add((skb_frag_t *)(& ((struct skb_shared_info *)tmp___1)->frags) + (unsigned long )j,
                    (int )curr_frag_len);
#line 1636
  skb->truesize = skb->truesize + (unsigned int )rx_frag_size;
#line 1637
  remaining = (int )remaining - (int )curr_frag_len;
#line 1638
  memset((void *)page_info, 0, 24UL);
#line 1619
  i = (u16 )((int )i + 1);
  }
  ldv_54593: ;
#line 1619
  if ((int )i < (int )((unsigned short )rxcp->num_rcvd)) {
#line 1621
    goto ldv_54592;
  } else {

  }
  {
#line 1640
  tmp___2 = __builtin_expect((unsigned int )j > 17U, 0L);
  }
#line 1640
  if (tmp___2 != 0L) {
    {
#line 1640
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (1640), "i" (12UL));
#line 1640
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 1642
  tmp___3 = skb_end_pointer((struct sk_buff  const  *)skb);
#line 1642
  ((struct skb_shared_info *)tmp___3)->nr_frags = (unsigned int )((unsigned char )j) + 1U;
#line 1643
  skb->len = (unsigned int )rxcp->pkt_size;
#line 1644
  skb->data_len = (unsigned int )rxcp->pkt_size;
#line 1645
  skb->ip_summed = 1U;
#line 1646
  skb_record_rx_queue(skb, (int )((u16 )(((long )rxo - (long )(& adapter->rx_obj)) / 24768L)));
  }
#line 1647
  if (((adapter->netdev)->features & 2147483648ULL) != 0ULL) {
    {
#line 1648
    skb_set_hash(skb, rxcp->rss_hash, 2);
    }
  } else {

  }
  {
#line 1649
  skb_mark_napi_id(skb, napi);
  }
#line 1651
  if ((unsigned int )rxcp->vlanf != 0U) {
    {
#line 1652
    __vlan_hwaccel_put_tag(skb, 129, (int )rxcp->vlan_tag);
    }
  } else {

  }
  {
#line 1654
  napi_gro_frags(napi);
  }
#line 1655
  return;
}
}
#line 1657 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_parse_rx_compl_v1(struct be_eth_rx_compl *compl , struct be_rx_compl_info *rxcp ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;

  {
  {
#line 1660
  tmp = amap_mask(14U);
#line 1660
  tmp___0 = amap_get((void *)compl, 0U, tmp, 16U);
#line 1660
  rxcp->pkt_size = (u16 )tmp___0;
#line 1662
  tmp___1 = amap_mask(1U);
#line 1662
  tmp___2 = amap_get((void *)compl, 0U, tmp___1, 30U);
#line 1662
  rxcp->vlanf = (u8 )tmp___2;
#line 1663
  tmp___3 = amap_mask(1U);
#line 1663
  tmp___4 = amap_get((void *)compl, 1U, tmp___3, 0U);
#line 1663
  rxcp->err = (u8 )tmp___4;
#line 1664
  tmp___5 = amap_mask(1U);
#line 1664
  tmp___6 = amap_get((void *)compl, 1U, tmp___5, 3U);
#line 1664
  rxcp->tcpf = (u8 )tmp___6;
#line 1665
  tmp___7 = amap_mask(1U);
#line 1665
  tmp___8 = amap_get((void *)compl, 1U, tmp___7, 4U);
#line 1665
  rxcp->udpf = (u8 )tmp___8;
#line 1666
  tmp___9 = amap_mask(1U);
#line 1666
  tmp___10 = amap_get((void *)compl, 1U, tmp___9, 5U);
#line 1666
  rxcp->ip_csum = (u8 )tmp___10;
#line 1668
  tmp___11 = amap_mask(1U);
#line 1668
  tmp___12 = amap_get((void *)compl, 1U, tmp___11, 6U);
#line 1668
  rxcp->l4_csum = (u8 )tmp___12;
#line 1670
  tmp___13 = amap_mask(1U);
#line 1670
  tmp___14 = amap_get((void *)compl, 1U, tmp___13, 7U);
#line 1670
  rxcp->ipv6 = (u8 )tmp___14;
#line 1672
  tmp___15 = amap_mask(3U);
#line 1672
  tmp___16 = amap_get((void *)compl, 1U, tmp___15, 29U);
#line 1672
  rxcp->num_rcvd = (u8 )tmp___16;
#line 1674
  tmp___17 = amap_mask(2U);
#line 1674
  tmp___18 = amap_get((void *)compl, 2U, tmp___17, 1U);
#line 1674
  rxcp->pkt_type = (u8 )tmp___18;
#line 1676
  tmp___19 = amap_mask(32U);
#line 1676
  rxcp->rss_hash = amap_get((void *)compl, 3U, tmp___19, 0U);
  }
#line 1678
  if ((unsigned int )rxcp->vlanf != 0U) {
    {
#line 1679
    tmp___20 = amap_mask(1U);
#line 1679
    tmp___21 = amap_get((void *)compl, 2U, tmp___20, 3U);
#line 1679
    rxcp->vtm = (u8 )tmp___21;
#line 1681
    tmp___22 = amap_mask(16U);
#line 1681
    tmp___23 = amap_get((void *)compl, 0U, tmp___22, 0U);
#line 1681
    rxcp->vlan_tag = (u16 )tmp___23;
    }
  } else {

  }
  {
#line 1684
  tmp___24 = amap_mask(2U);
#line 1684
  tmp___25 = amap_get((void *)compl, 2U, tmp___24, 5U);
#line 1684
  rxcp->port = (u16 )tmp___25;
  }
#line 1685
  return;
}
}
#line 1687 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_parse_rx_compl_v0(struct be_eth_rx_compl *compl , struct be_rx_compl_info *rxcp ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;

  {
  {
#line 1690
  tmp = amap_mask(14U);
#line 1690
  tmp___0 = amap_get((void *)compl, 0U, tmp, 16U);
#line 1690
  rxcp->pkt_size = (u16 )tmp___0;
#line 1692
  tmp___1 = amap_mask(1U);
#line 1692
  tmp___2 = amap_get((void *)compl, 1U, tmp___1, 14U);
#line 1692
  rxcp->vlanf = (u8 )tmp___2;
#line 1693
  tmp___3 = amap_mask(1U);
#line 1693
  tmp___4 = amap_get((void *)compl, 1U, tmp___3, 0U);
#line 1693
  rxcp->err = (u8 )tmp___4;
#line 1694
  tmp___5 = amap_mask(1U);
#line 1694
  tmp___6 = amap_get((void *)compl, 1U, tmp___5, 3U);
#line 1694
  rxcp->tcpf = (u8 )tmp___6;
#line 1695
  tmp___7 = amap_mask(1U);
#line 1695
  tmp___8 = amap_get((void *)compl, 1U, tmp___7, 4U);
#line 1695
  rxcp->udpf = (u8 )tmp___8;
#line 1696
  tmp___9 = amap_mask(1U);
#line 1696
  tmp___10 = amap_get((void *)compl, 1U, tmp___9, 5U);
#line 1696
  rxcp->ip_csum = (u8 )tmp___10;
#line 1698
  tmp___11 = amap_mask(1U);
#line 1698
  tmp___12 = amap_get((void *)compl, 1U, tmp___11, 6U);
#line 1698
  rxcp->l4_csum = (u8 )tmp___12;
#line 1700
  tmp___13 = amap_mask(1U);
#line 1700
  tmp___14 = amap_get((void *)compl, 1U, tmp___13, 7U);
#line 1700
  rxcp->ipv6 = (u8 )tmp___14;
#line 1702
  tmp___15 = amap_mask(3U);
#line 1702
  tmp___16 = amap_get((void *)compl, 1U, tmp___15, 29U);
#line 1702
  rxcp->num_rcvd = (u8 )tmp___16;
#line 1704
  tmp___17 = amap_mask(2U);
#line 1704
  tmp___18 = amap_get((void *)compl, 2U, tmp___17, 1U);
#line 1704
  rxcp->pkt_type = (u8 )tmp___18;
#line 1706
  tmp___19 = amap_mask(32U);
#line 1706
  rxcp->rss_hash = amap_get((void *)compl, 3U, tmp___19, 0U);
  }
#line 1708
  if ((unsigned int )rxcp->vlanf != 0U) {
    {
#line 1709
    tmp___20 = amap_mask(1U);
#line 1709
    tmp___21 = amap_get((void *)compl, 2U, tmp___20, 3U);
#line 1709
    rxcp->vtm = (u8 )tmp___21;
#line 1711
    tmp___22 = amap_mask(16U);
#line 1711
    tmp___23 = amap_get((void *)compl, 0U, tmp___22, 0U);
#line 1711
    rxcp->vlan_tag = (u16 )tmp___23;
    }
  } else {

  }
  {
#line 1714
  tmp___24 = amap_mask(1U);
#line 1714
  tmp___25 = amap_get((void *)compl, 0U, tmp___24, 30U);
#line 1714
  rxcp->port = (u16 )tmp___25;
#line 1715
  tmp___26 = amap_mask(1U);
#line 1715
  tmp___27 = amap_get((void *)compl, 1U, tmp___26, 15U);
#line 1715
  rxcp->ip_frag = (u8 )tmp___27;
  }
#line 1716
  return;
}
}
#line 1719 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct be_rx_compl_info *be_rx_compl_get(struct be_rx_obj *rxo ) 
{ 
  struct be_eth_rx_compl *compl ;
  void *tmp ;
  struct be_rx_compl_info *rxcp ;
  struct be_adapter *adapter ;
  __u16 tmp___0 ;

  {
  {
#line 1721
  tmp = queue_tail_node(& rxo->cq);
#line 1721
  compl = (struct be_eth_rx_compl *)tmp;
#line 1722
  rxcp = & rxo->rxcp;
#line 1723
  adapter = rxo->adapter;
  }
#line 1727
  if (compl->dw[2UL] == 0U) {
#line 1728
    return ((struct be_rx_compl_info *)0);
  } else {

  }
  {
#line 1730
  __asm__  volatile   ("lfence": : : "memory");
#line 1731
  swap_dws((void *)compl, 16);
  }
#line 1733
  if ((int )adapter->be3_native) {
    {
#line 1734
    be_parse_rx_compl_v1(compl, rxcp);
    }
  } else {
    {
#line 1736
    be_parse_rx_compl_v0(compl, rxcp);
    }
  }
#line 1738
  if ((unsigned int )rxcp->ip_frag != 0U) {
#line 1739
    rxcp->l4_csum = 0U;
  } else {

  }
#line 1741
  if ((unsigned int )rxcp->vlanf != 0U) {
#line 1744
    if ((adapter->function_mode & 1024U) != 0U && (unsigned int )rxcp->vtm == 0U) {
#line 1745
      rxcp->vlanf = 0U;
    } else {

    }
#line 1747
    if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
      {
#line 1748
      tmp___0 = __fswab16((int )rxcp->vlan_tag);
#line 1748
      rxcp->vlan_tag = tmp___0;
      }
    } else {

    }
#line 1750
    if ((int )adapter->pvid == ((int )rxcp->vlan_tag & 4095) && (unsigned int )adapter->vlan_tag[(int )rxcp->vlan_tag] == 0U) {
#line 1752
      rxcp->vlanf = 0U;
    } else {

    }
  } else {

  }
  {
#line 1756
  compl->dw[2UL] = 0U;
#line 1758
  queue_tail_inc(& rxo->cq);
  }
#line 1759
  return (rxcp);
}
}
#line 1762 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static struct page *be_alloc_pages(u32 size , gfp_t gfp ) 
{ 
  u32 order ;
  int tmp___68 ;
  struct page *tmp___69 ;

  {
  {
#line 1764
  tmp___68 = __get_order((unsigned long )size);
#line 1764
  order = (u32 )tmp___68;
  }
#line 1766
  if (order != 0U) {
#line 1767
    gfp = gfp | 16384U;
  } else {

  }
  {
#line 1768
  tmp___69 = alloc_pages(gfp, order);
  }
#line 1768
  return (tmp___69);
}
}
#line 1775 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_post_rx_frags(struct be_rx_obj *rxo , gfp_t gfp ) 
{ 
  struct be_adapter *adapter ;
  struct be_rx_page_info *page_info ;
  struct be_rx_page_info *prev_page_info ;
  struct be_queue_info *rxq ;
  struct page *pagep ;
  struct device *dev ;
  struct be_eth_rx_d *rxd ;
  u64 page_dmaaddr ;
  u64 frag_dmaaddr ;
  u32 posted ;
  u32 page_offset ;
  long tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1777
  adapter = rxo->adapter;
#line 1778
  page_info = (struct be_rx_page_info *)0;
#line 1778
  prev_page_info = (struct be_rx_page_info *)0;
#line 1779
  rxq = & rxo->q;
#line 1780
  pagep = (struct page *)0;
#line 1781
  dev = & (adapter->pdev)->dev;
#line 1783
  page_dmaaddr = 0ULL;
#line 1784
  page_offset = 0U;
#line 1786
  page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )rxq->head;
#line 1787
  posted = 0U;
#line 1787
  goto ldv_54631;
  ldv_54630: ;
#line 1788
  if ((unsigned long )pagep == (unsigned long )((struct page *)0)) {
    {
#line 1789
    pagep = be_alloc_pages(adapter->big_page_size, gfp);
#line 1790
    tmp = __builtin_expect((unsigned long )pagep == (unsigned long )((struct page *)0),
                           0L);
    }
#line 1790
    if (tmp != 0L) {
#line 1791
      rxo->stats.rx_post_fail = rxo->stats.rx_post_fail + 1U;
#line 1792
      goto ldv_54629;
    } else {

    }
    {
#line 1794
    page_dmaaddr = dma_map_page(dev, pagep, 0UL, (size_t )adapter->big_page_size,
                                2);
#line 1797
    tmp___0 = dma_mapping_error(dev, page_dmaaddr);
    }
#line 1797
    if (tmp___0 != 0) {
      {
#line 1798
      put_page(pagep);
#line 1799
      pagep = (struct page *)0;
#line 1800
      rxo->stats.rx_post_fail = rxo->stats.rx_post_fail + 1U;
      }
#line 1801
      goto ldv_54629;
    } else {

    }
#line 1803
    page_info->page_offset = 0U;
  } else {
    {
#line 1805
    get_page(pagep);
#line 1806
    page_info->page_offset = (int )((u16 )page_offset) + (int )rx_frag_size;
    }
  }
  {
#line 1808
  page_offset = (u32 )page_info->page_offset;
#line 1809
  page_info->page = pagep;
#line 1810
  page_info->bus = page_dmaaddr;
#line 1811
  frag_dmaaddr = page_dmaaddr + (u64 )page_info->page_offset;
#line 1813
  tmp___1 = queue_head_node(rxq);
#line 1813
  rxd = (struct be_eth_rx_d *)tmp___1;
#line 1814
  rxd->fragpa_lo = (unsigned int )frag_dmaaddr;
#line 1815
  rxd->fragpa_hi = (unsigned int )(frag_dmaaddr >> 32ULL);
  }
#line 1818
  if ((page_offset + (u32 )rx_frag_size) + (u32 )rx_frag_size > adapter->big_page_size) {
#line 1820
    pagep = (struct page *)0;
#line 1821
    page_info->last_page_user = 1;
  } else {

  }
  {
#line 1824
  prev_page_info = page_info;
#line 1825
  queue_head_inc(rxq);
#line 1826
  page_info = (struct be_rx_page_info *)(& rxo->page_info_tbl) + (unsigned long )rxq->head;
#line 1787
  posted = posted + 1U;
  }
  ldv_54631: ;
#line 1787
  if (posted <= 63U && (unsigned long )page_info->page == (unsigned long )((struct page *)0)) {
#line 1789
    goto ldv_54630;
  } else {

  }
  ldv_54629: ;
#line 1828
  if ((unsigned long )pagep != (unsigned long )((struct page *)0)) {
#line 1829
    prev_page_info->last_page_user = 1;
  } else {

  }
#line 1831
  if (posted != 0U) {
    {
#line 1832
    atomic_add((int )posted, & rxq->used);
    }
#line 1833
    if ((int )rxo->rx_post_starved) {
#line 1834
      rxo->rx_post_starved = 0;
    } else {

    }
    {
#line 1835
    be_rxq_notify(adapter, (int )rxq->id, (int )((u16 )posted));
    }
  } else {
    {
#line 1836
    tmp___2 = atomic_read((atomic_t const   *)(& rxq->used));
    }
#line 1836
    if (tmp___2 == 0) {
#line 1838
      rxo->rx_post_starved = 1;
    } else {

    }
  }
#line 1839
  return;
}
}
#line 1842 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct be_eth_tx_compl *be_tx_compl_get(struct be_queue_info *tx_cq ) 
{ 
  struct be_eth_tx_compl *txcp ;
  void *tmp ;

  {
  {
#line 1844
  tmp = queue_tail_node(tx_cq);
#line 1844
  txcp = (struct be_eth_tx_compl *)tmp;
  }
#line 1846
  if (txcp->dw[3UL] == 0U) {
#line 1847
    return ((struct be_eth_tx_compl *)0);
  } else {

  }
  {
#line 1849
  __asm__  volatile   ("lfence": : : "memory");
#line 1850
  swap_dws((void *)txcp, 16);
#line 1852
  txcp->dw[3UL] = 0U;
#line 1854
  queue_tail_inc(tx_cq);
  }
#line 1855
  return (txcp);
}
}
#line 1858 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static u16 be_tx_compl_process(struct be_adapter *adapter , struct be_tx_obj *txo ,
                               u16 last_index ) 
{ 
  struct be_queue_info *txq ;
  struct be_eth_wrb *wrb ;
  struct sk_buff **sent_skbs ;
  struct sk_buff *sent_skb ;
  u16 cur_index ;
  u16 num_wrbs ;
  bool unmap_skb_hdr ;
  long tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1861
  txq = & txo->q;
#line 1863
  sent_skbs = (struct sk_buff **)(& txo->sent_skb_list);
#line 1865
  num_wrbs = 1U;
#line 1866
  unmap_skb_hdr = 1;
#line 1868
  sent_skb = *(sent_skbs + (unsigned long )txq->tail);
#line 1869
  tmp = __builtin_expect((unsigned long )sent_skb == (unsigned long )((struct sk_buff *)0),
                         0L);
  }
#line 1869
  if (tmp != 0L) {
    {
#line 1869
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (1869), "i" (12UL));
#line 1869
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 1870
  *(sent_skbs + (unsigned long )txq->tail) = (struct sk_buff *)0;
#line 1873
  queue_tail_inc(txq);
  }
  ldv_54648: 
  {
#line 1876
  cur_index = txq->tail;
#line 1877
  tmp___0 = queue_tail_node(txq);
#line 1877
  wrb = (struct be_eth_wrb *)tmp___0;
  }
#line 1878
  if ((int )unmap_skb_hdr) {
    {
#line 1878
    tmp___1 = skb_headlen((struct sk_buff  const  *)sent_skb);
    }
#line 1878
    if (tmp___1 != 0U) {
#line 1878
      tmp___2 = 1;
    } else {
#line 1878
      tmp___2 = 0;
    }
  } else {
#line 1878
    tmp___2 = 0;
  }
  {
#line 1878
  unmap_tx_frag(& (adapter->pdev)->dev, wrb, (int )((bool )tmp___2));
#line 1880
  unmap_skb_hdr = 0;
#line 1882
  num_wrbs = (u16 )((int )num_wrbs + 1);
#line 1883
  queue_tail_inc(txq);
  }
#line 1884
  if ((int )cur_index != (int )last_index) {
#line 1886
    goto ldv_54648;
  } else {

  }
  {
#line 1886
  kfree_skb(sent_skb);
  }
#line 1887
  return (num_wrbs);
}
}
#line 1891 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static int events_get(struct be_eq_obj *eqo ) 
{ 
  struct be_eq_entry *eqe ;
  int num ;
  void *tmp ;

  {
#line 1894
  num = 0;
  ldv_54656: 
  {
#line 1897
  tmp = queue_tail_node(& eqo->q);
#line 1897
  eqe = (struct be_eq_entry *)tmp;
  }
#line 1898
  if (eqe->evt == 0U) {
#line 1899
    goto ldv_54655;
  } else {

  }
  {
#line 1901
  __asm__  volatile   ("lfence": : : "memory");
#line 1902
  eqe->evt = 0U;
#line 1903
  num = num + 1;
#line 1904
  queue_tail_inc(& eqo->q);
  }
#line 1905
  goto ldv_54656;
  ldv_54655: ;
#line 1907
  return (num);
}
}
#line 1911 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_eq_clean(struct be_eq_obj *eqo ) 
{ 
  int num ;
  int tmp ;

  {
  {
#line 1913
  tmp = events_get(eqo);
#line 1913
  num = tmp;
#line 1915
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, (int )((u16 )num));
  }
#line 1916
  return;
}
}
#line 1918 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_cq_clean(struct be_rx_obj *rxo ) 
{ 
  struct be_rx_page_info *page_info ;
  struct be_queue_info *rxq ;
  struct be_queue_info *rx_cq ;
  struct be_rx_compl_info *rxcp ;
  struct be_adapter *adapter ;
  int flush_wait ;
  int tmp ;
  bool tmp___0 ;
  unsigned long __ms ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  u16 tmp___5 ;

  {
#line 1921
  rxq = & rxo->q;
#line 1922
  rx_cq = & rxo->cq;
#line 1924
  adapter = rxo->adapter;
#line 1925
  flush_wait = 0;
  ldv_54675: 
  {
#line 1934
  rxcp = be_rx_compl_get(rxo);
  }
#line 1935
  if ((unsigned long )rxcp == (unsigned long )((struct be_rx_compl_info *)0)) {
#line 1936
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1937
      goto ldv_54670;
    } else {

    }
#line 1939
    tmp = flush_wait;
#line 1939
    flush_wait = flush_wait + 1;
#line 1939
    if (tmp > 10) {
      {
#line 1940
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "did not receive flush compl\n");
      }
#line 1942
      goto ldv_54670;
    } else {
      {
#line 1939
      tmp___0 = be_hw_error(adapter);
      }
#line 1939
      if ((int )tmp___0) {
        {
#line 1940
        dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "did not receive flush compl\n");
        }
#line 1942
        goto ldv_54670;
      } else {

      }
    }
    {
#line 1944
    be_cq_notify(adapter, (int )rx_cq->id, 1, 0);
    }
#line 1945
    if (1) {
      {
#line 1945
      __const_udelay(4295000UL);
      }
    } else {
#line 1945
      __ms = 1UL;
#line 1945
      goto ldv_54673;
      ldv_54672: 
      {
#line 1945
      __const_udelay(4295000UL);
      }
      ldv_54673: 
#line 1945
      tmp___1 = __ms;
#line 1945
      __ms = __ms - 1UL;
#line 1945
      if (tmp___1 != 0UL) {
#line 1947
        goto ldv_54672;
      } else {

      }

    }
  } else {
    {
#line 1947
    be_rx_compl_discard(rxo, rxcp);
#line 1948
    be_cq_notify(adapter, (int )rx_cq->id, 0, 1);
    }
#line 1949
    if ((unsigned int )rxcp->num_rcvd == 0U) {
#line 1950
      goto ldv_54670;
    } else {

    }
  }
#line 1952
  goto ldv_54675;
  ldv_54670: 
  {
#line 1955
  be_cq_notify(adapter, (int )rx_cq->id, 0, 0);
  }
#line 1958
  goto ldv_54677;
  ldv_54676: 
  {
#line 1959
  page_info = get_rx_page_info(rxo);
#line 1960
  put_page(page_info->page);
#line 1961
  memset((void *)page_info, 0, 24UL);
  }
  ldv_54677: 
  {
#line 1958
  tmp___2 = atomic_read((atomic_t const   *)(& rxq->used));
  }
#line 1958
  if (tmp___2 > 0) {
#line 1960
    goto ldv_54676;
  } else {

  }
  {
#line 1963
  tmp___3 = atomic_read((atomic_t const   *)(& rxq->used));
#line 1963
  tmp___4 = __builtin_expect(tmp___3 != 0, 0L);
  }
#line 1963
  if (tmp___4 != 0L) {
    {
#line 1963
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_main.c"),
                         "i" (1963), "i" (12UL));
#line 1963
    __builtin_unreachable();
    }
  } else {

  }
#line 1964
  tmp___5 = 0U;
#line 1964
  rxq->head = tmp___5;
#line 1964
  rxq->tail = tmp___5;
#line 1965
  return;
}
}
#line 1967 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_tx_compl_clean(struct be_adapter *adapter ) 
{ 
  struct be_tx_obj *txo ;
  struct be_queue_info *txq ;
  struct be_eth_tx_compl *txcp ;
  u16 end_idx ;
  u16 cmpl ;
  u16 timeo ;
  u16 num_wrbs ;
  struct sk_buff *sent_skb ;
  bool dummy_wrb ;
  int i ;
  int pending_txqs ;
  u32 tmp ;
  u32 tmp___0 ;
  u16 tmp___1 ;
  int tmp___2 ;
  unsigned long __ms ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u32 tmp___6 ;
  int tmp___7 ;

  {
#line 1972
  cmpl = 0U;
#line 1972
  timeo = 0U;
#line 1972
  num_wrbs = 0U;
  ldv_54704: 
#line 1979
  pending_txqs = (int )adapter->num_tx_qs;
#line 1981
  i = 0;
#line 1981
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 1981
  goto ldv_54697;
  ldv_54696: 
#line 1982
  txq = & txo->q;
#line 1983
  goto ldv_54694;
  ldv_54693: 
  {
#line 1984
  tmp = amap_mask(16U);
#line 1984
  tmp___0 = amap_get((void *)txcp, 0U, tmp, 0U);
#line 1984
  end_idx = (u16 )tmp___0;
#line 1987
  tmp___1 = be_tx_compl_process(adapter, txo, (int )end_idx);
#line 1987
  num_wrbs = (int )num_wrbs + (int )tmp___1;
#line 1989
  cmpl = (u16 )((int )cmpl + 1);
  }
  ldv_54694: 
  {
#line 1983
  txcp = be_tx_compl_get(& txo->cq);
  }
#line 1983
  if ((unsigned long )txcp != (unsigned long )((struct be_eth_tx_compl *)0)) {
#line 1985
    goto ldv_54693;
  } else {

  }

#line 1991
  if ((unsigned int )cmpl != 0U) {
    {
#line 1992
    be_cq_notify(adapter, (int )txo->cq.id, 0, (int )cmpl);
#line 1993
    atomic_sub((int )num_wrbs, & txq->used);
#line 1994
    cmpl = 0U;
#line 1995
    num_wrbs = 0U;
    }
  } else {

  }
  {
#line 1997
  tmp___2 = atomic_read((atomic_t const   *)(& txq->used));
  }
#line 1997
  if (tmp___2 == 0) {
#line 1998
    pending_txqs = pending_txqs - 1;
  } else {

  }
#line 1981
  i = i + 1;
#line 1981
  txo = txo + 1;
  ldv_54697: ;
#line 1981
  if (i < (int )adapter->num_tx_qs) {
#line 1983
    goto ldv_54696;
  } else {

  }

#line 2001
  if (pending_txqs == 0) {
#line 2002
    goto ldv_54699;
  } else {
#line 2001
    timeo = (u16 )((int )timeo + 1);
#line 2001
    if ((unsigned int )timeo > 200U) {
#line 2002
      goto ldv_54699;
    } else {

    }
  }
#line 2004
  if (1) {
    {
#line 2004
    __const_udelay(4295000UL);
    }
  } else {
#line 2004
    __ms = 1UL;
#line 2004
    goto ldv_54702;
    ldv_54701: 
    {
#line 2004
    __const_udelay(4295000UL);
    }
    ldv_54702: 
#line 2004
    tmp___3 = __ms;
#line 2004
    __ms = __ms - 1UL;
#line 2004
    if (tmp___3 != 0UL) {
#line 2006
      goto ldv_54701;
    } else {

    }

  }
#line 2005
  goto ldv_54704;
  ldv_54699: 
#line 2007
  i = 0;
#line 2007
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2007
  goto ldv_54709;
  ldv_54708: 
  {
#line 2008
  txq = & txo->q;
#line 2009
  tmp___5 = atomic_read((atomic_t const   *)(& txq->used));
  }
#line 2009
  if (tmp___5 != 0) {
    {
#line 2010
    tmp___4 = atomic_read((atomic_t const   *)(& txq->used));
#line 2010
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "%d pending tx-compls\n",
            tmp___4);
    }
  } else {

  }
#line 2014
  goto ldv_54706;
  ldv_54705: 
  {
#line 2015
  sent_skb = txo->sent_skb_list[(int )txq->tail];
#line 2016
  end_idx = txq->tail;
#line 2017
  tmp___6 = wrb_cnt_for_skb(adapter, sent_skb, & dummy_wrb);
#line 2017
  num_wrbs = (u16 )tmp___6;
#line 2019
  index_adv(& end_idx, (int )((unsigned int )num_wrbs + 65535U), (int )txq->len);
#line 2020
  num_wrbs = be_tx_compl_process(adapter, txo, (int )end_idx);
#line 2021
  atomic_sub((int )num_wrbs, & txq->used);
  }
  ldv_54706: 
  {
#line 2014
  tmp___7 = atomic_read((atomic_t const   *)(& txq->used));
  }
#line 2014
  if (tmp___7 != 0) {
#line 2016
    goto ldv_54705;
  } else {

  }
#line 2007
  i = i + 1;
#line 2007
  txo = txo + 1;
  ldv_54709: ;
#line 2007
  if (i < (int )adapter->num_tx_qs) {
#line 2009
    goto ldv_54708;
  } else {

  }

#line 2014
  return;
}
}
#line 2026 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_evt_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_eq_obj *eqo ;
  int i ;

  {
#line 2031
  i = 0;
#line 2031
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2031
  goto ldv_54717;
  ldv_54716: ;
#line 2032
  if ((int )eqo->q.created) {
    {
#line 2033
    be_eq_clean(eqo);
#line 2034
    be_cmd_q_destroy(adapter, & eqo->q, 1);
#line 2035
    napi_hash_del(& eqo->napi);
#line 2036
    netif_napi_del(& eqo->napi);
    }
  } else {

  }
  {
#line 2038
  be_queue_free(adapter, & eqo->q);
#line 2031
  i = i + 1;
#line 2031
  eqo = eqo + 1;
  }
  ldv_54717: ;
#line 2031
  if (i < (int )adapter->num_evt_qs) {
#line 2033
    goto ldv_54716;
  } else {

  }

#line 2038
  return;
}
}
#line 2042 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_evt_queues_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *eq ;
  struct be_eq_obj *eqo ;
  struct be_aic_obj *aic ;
  int i ;
  int rc ;
  u16 __min1 ;
  u16 __min2 ;

  {
#line 2049
  __min1 = (unsigned int )adapter->num_msix_vec != 0U ? adapter->num_msix_vec : 1U;
#line 2049
  __min2 = adapter->cfg_num_qs;
#line 2049
  adapter->num_evt_qs = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 2052
  i = 0;
#line 2052
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2052
  goto ldv_54731;
  ldv_54730: 
  {
#line 2053
  netif_napi_add(adapter->netdev, & eqo->napi, & be_poll, 64);
#line 2055
  napi_hash_add(& eqo->napi);
#line 2056
  aic = (struct be_aic_obj *)(& adapter->aic_obj) + (unsigned long )i;
#line 2057
  eqo->adapter = adapter;
#line 2058
  eqo->tx_budget = 256U;
#line 2059
  eqo->idx = (u8 )i;
#line 2060
  aic->max_eqd = 128U;
#line 2061
  aic->enable = 1;
#line 2063
  eq = & eqo->q;
#line 2064
  rc = be_queue_alloc(adapter, eq, 1024, 4);
  }
#line 2066
  if (rc != 0) {
#line 2067
    return (rc);
  } else {

  }
  {
#line 2069
  rc = be_cmd_eq_create(adapter, eqo);
  }
#line 2070
  if (rc != 0) {
#line 2071
    return (rc);
  } else {

  }
#line 2052
  i = i + 1;
#line 2052
  eqo = eqo + 1;
  ldv_54731: ;
#line 2052
  if (i < (int )adapter->num_evt_qs) {
#line 2054
    goto ldv_54730;
  } else {

  }

#line 2073
  return (0);
}
}
#line 2076 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_mcc_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;

  {
#line 2080
  q = & adapter->mcc_obj.q;
#line 2081
  if ((int )q->created) {
    {
#line 2082
    be_cmd_q_destroy(adapter, q, 5);
    }
  } else {

  }
  {
#line 2083
  be_queue_free(adapter, q);
#line 2085
  q = & adapter->mcc_obj.cq;
  }
#line 2086
  if ((int )q->created) {
    {
#line 2087
    be_cmd_q_destroy(adapter, q, 2);
    }
  } else {

  }
  {
#line 2088
  be_queue_free(adapter, q);
  }
#line 2089
  return;
}
}
#line 2092 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_mcc_queues_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_queue_info *cq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2096
  cq = & adapter->mcc_obj.cq;
#line 2097
  tmp = be_queue_alloc(adapter, cq, 256, 16);
  }
#line 2097
  if (tmp != 0) {
#line 2099
    goto err;
  } else {

  }
  {
#line 2102
  tmp___0 = be_cmd_cq_create(adapter, cq, & ((struct be_eq_obj *)(& adapter->eq_obj))->q,
                             1, 0);
  }
#line 2102
  if (tmp___0 != 0) {
#line 2103
    goto mcc_cq_free;
  } else {

  }
  {
#line 2105
  q = & adapter->mcc_obj.q;
#line 2106
  tmp___1 = be_queue_alloc(adapter, q, 128, 256);
  }
#line 2106
  if (tmp___1 != 0) {
#line 2107
    goto mcc_cq_destroy;
  } else {

  }
  {
#line 2109
  tmp___2 = be_cmd_mccq_create(adapter, q, cq);
  }
#line 2109
  if (tmp___2 != 0) {
#line 2110
    goto mcc_q_free;
  } else {

  }
#line 2112
  return (0);
  mcc_q_free: 
  {
#line 2115
  be_queue_free(adapter, q);
  }
  mcc_cq_destroy: 
  {
#line 2117
  be_cmd_q_destroy(adapter, cq, 2);
  }
  mcc_cq_free: 
  {
#line 2119
  be_queue_free(adapter, cq);
  }
  err: ;
#line 2121
  return (-1);
}
}
#line 2124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_tx_queues_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_tx_obj *txo ;
  u8 i ;

  {
#line 2130
  i = 0U;
#line 2130
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2130
  goto ldv_54753;
  ldv_54752: 
#line 2131
  q = & txo->q;
#line 2132
  if ((int )q->created) {
    {
#line 2133
    be_cmd_q_destroy(adapter, q, 3);
    }
  } else {

  }
  {
#line 2134
  be_queue_free(adapter, q);
#line 2136
  q = & txo->cq;
  }
#line 2137
  if ((int )q->created) {
    {
#line 2138
    be_cmd_q_destroy(adapter, q, 2);
    }
  } else {

  }
  {
#line 2139
  be_queue_free(adapter, q);
#line 2130
  i = (u8 )((int )i + 1);
#line 2130
  txo = txo + 1;
  }
  ldv_54753: ;
#line 2130
  if ((int )((unsigned short )i) < (int )adapter->num_tx_qs) {
#line 2132
    goto ldv_54752;
  } else {

  }

#line 2137
  return;
}
}
#line 2143 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_tx_qs_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *cq ;
  struct be_queue_info *eq ;
  struct be_tx_obj *txo ;
  int status ;
  int i ;
  u16 _min1 ;
  u16 _min2 ;

  {
#line 2149
  _min1 = adapter->num_evt_qs;
#line 2149
  _min2 = adapter->res.max_tx_qs;
#line 2149
  adapter->num_tx_qs = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 2151
  i = 0;
#line 2151
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2151
  goto ldv_54767;
  ldv_54766: 
  {
#line 2152
  cq = & txo->cq;
#line 2153
  status = be_queue_alloc(adapter, cq, 1024, 16);
  }
#line 2155
  if (status != 0) {
#line 2156
    return (status);
  } else {

  }
  {
#line 2164
  eq = & adapter->eq_obj[i % (int )adapter->num_evt_qs].q;
#line 2165
  status = be_cmd_cq_create(adapter, cq, eq, 0, 3);
  }
#line 2166
  if (status != 0) {
#line 2167
    return (status);
  } else {

  }
  {
#line 2169
  status = be_queue_alloc(adapter, & txo->q, 2048, 16);
  }
#line 2171
  if (status != 0) {
#line 2172
    return (status);
  } else {

  }
  {
#line 2174
  status = be_cmd_txq_create(adapter, txo);
  }
#line 2175
  if (status != 0) {
#line 2176
    return (status);
  } else {

  }
#line 2151
  i = i + 1;
#line 2151
  txo = txo + 1;
  ldv_54767: ;
#line 2151
  if (i < (int )adapter->num_tx_qs) {
#line 2153
    goto ldv_54766;
  } else {

  }
  {
#line 2179
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "created %d TX queue(s)\n",
            (int )adapter->num_tx_qs);
  }
#line 2181
  return (0);
}
}
#line 2184 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_cqs_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_rx_obj *rxo ;
  int i ;

  {
#line 2190
  i = 0;
#line 2190
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2190
  goto ldv_54776;
  ldv_54775: 
#line 2191
  q = & rxo->cq;
#line 2192
  if ((int )q->created) {
    {
#line 2193
    be_cmd_q_destroy(adapter, q, 2);
    }
  } else {

  }
  {
#line 2194
  be_queue_free(adapter, q);
#line 2190
  i = i + 1;
#line 2190
  rxo = rxo + 1;
  }
  ldv_54776: ;
#line 2190
  if (i < (int )adapter->num_rx_qs) {
#line 2192
    goto ldv_54775;
  } else {

  }

#line 2197
  return;
}
}
#line 2198 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_rx_cqs_create(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *eq ;
  struct be_queue_info *cq ;
  struct be_rx_obj *rxo ;
  int rc ;
  int i ;
  int tmp___69 ;

  {
#line 2205
  adapter->num_rx_qs = adapter->num_evt_qs;
#line 2210
  if ((unsigned int )adapter->num_rx_qs > 1U) {
#line 2211
    adapter->num_rx_qs = (u16 )((int )adapter->num_rx_qs + 1);
  } else {

  }
  {
#line 2213
  tmp___69 = __get_order((unsigned long )rx_frag_size);
#line 2213
  adapter->big_page_size = (u32 )((unsigned long )(1 << tmp___69)) * 4096U;
#line 2214
  i = 0;
#line 2214
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
  }
#line 2214
  goto ldv_54787;
  ldv_54786: 
  {
#line 2215
  rxo->adapter = adapter;
#line 2216
  cq = & rxo->cq;
#line 2217
  rc = be_queue_alloc(adapter, cq, 1024, 16);
  }
#line 2219
  if (rc != 0) {
#line 2220
    return (rc);
  } else {

  }
  {
#line 2223
  eq = & adapter->eq_obj[i % (int )adapter->num_evt_qs].q;
#line 2224
  rc = be_cmd_cq_create(adapter, cq, eq, 0, 3);
  }
#line 2225
  if (rc != 0) {
#line 2226
    return (rc);
  } else {

  }
#line 2214
  i = i + 1;
#line 2214
  rxo = rxo + 1;
  ldv_54787: ;
#line 2214
  if (i < (int )adapter->num_rx_qs) {
#line 2216
    goto ldv_54786;
  } else {

  }
  {
#line 2229
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "created %d RSS queue(s) and 1 default RX queue\n",
            (int )adapter->num_rx_qs + -1);
  }
#line 2232
  return (0);
}
}
#line 2235 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static irqreturn_t be_intx(int irq , void *dev ) 
{ 
  struct be_eq_obj *eqo ;
  struct be_adapter *adapter ;
  int num_evts ;
  bool tmp ;
  u16 tmp___0 ;

  {
  {
#line 2237
  eqo = (struct be_eq_obj *)dev;
#line 2238
  adapter = eqo->adapter;
#line 2239
  num_evts = 0;
#line 2249
  tmp = napi_schedule_prep(& eqo->napi);
  }
#line 2249
  if ((int )tmp) {
    {
#line 2250
    num_evts = events_get(eqo);
#line 2251
    __napi_schedule(& eqo->napi);
    }
#line 2252
    if (num_evts != 0) {
#line 2253
      eqo->spurious_intr = 0U;
    } else {

    }
  } else {

  }
  {
#line 2255
  be_eq_notify(adapter, (int )eqo->q.id, 0, 1, (int )((u16 )num_evts));
  }
#line 2261
  if (num_evts != 0) {
#line 2262
    return (1);
  } else {
#line 2261
    tmp___0 = eqo->spurious_intr;
#line 2261
    eqo->spurious_intr = (u16 )((int )eqo->spurious_intr + 1);
#line 2261
    if ((unsigned int )tmp___0 == 0U) {
#line 2262
      return (1);
    } else {
#line 2264
      return (0);
    }
  }
}
}
#line 2267 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static irqreturn_t be_msix(int irq , void *dev ) 
{ 
  struct be_eq_obj *eqo ;

  {
  {
#line 2269
  eqo = (struct be_eq_obj *)dev;
#line 2271
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, 0);
#line 2272
  napi_schedule(& eqo->napi);
  }
#line 2273
  return (1);
}
}
#line 2276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static bool do_gro(struct be_rx_compl_info *rxcp ) 
{ 


  {
#line 2278
  return ((bool )(((unsigned int )rxcp->tcpf != 0U && (unsigned int )rxcp->err == 0U) && (unsigned int )rxcp->l4_csum != 0U));
}
}
#line 2281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_process_rx(struct be_rx_obj *rxo , struct napi_struct *napi , int budget ,
                         int polling ) 
{ 
  struct be_adapter *adapter ;
  struct be_queue_info *rx_cq ;
  struct be_rx_compl_info *rxcp ;
  u32 work_done ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
#line 2284
  adapter = rxo->adapter;
#line 2285
  rx_cq = & rxo->cq;
#line 2289
  work_done = 0U;
#line 2289
  goto ldv_54817;
  ldv_54816: 
  {
#line 2290
  rxcp = be_rx_compl_get(rxo);
  }
#line 2291
  if ((unsigned long )rxcp == (unsigned long )((struct be_rx_compl_info *)0)) {
#line 2292
    goto ldv_54814;
  } else {

  }
  {
#line 2295
  tmp = __builtin_expect((unsigned int )rxcp->num_rcvd == 0U, 0L);
  }
#line 2295
  if (tmp != 0L) {
#line 2296
    goto loop_continue;
  } else {

  }
  {
#line 2299
  tmp___0 = __builtin_expect((unsigned int )rxcp->pkt_size == 0U, 0L);
  }
#line 2299
  if (tmp___0 != 0L) {
    {
#line 2300
    be_rx_compl_discard(rxo, rxcp);
    }
#line 2301
    goto loop_continue;
  } else {

  }
  {
#line 2307
  tmp___1 = __builtin_expect((u32 )rxcp->port != adapter->port_num, 0L);
  }
#line 2307
  if (tmp___1 != 0L) {
    {
#line 2307
    tmp___2 = __builtin_expect((long )((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U),
                               0L);
    }
#line 2307
    if (tmp___2 != 0L) {
      {
#line 2309
      be_rx_compl_discard(rxo, rxcp);
      }
#line 2310
      goto loop_continue;
    } else {

    }
  } else {

  }
  {
#line 2314
  tmp___3 = do_gro(rxcp);
  }
#line 2314
  if ((int )tmp___3 && polling != 1) {
    {
#line 2315
    be_rx_compl_process_gro(rxo, napi, rxcp);
    }
  } else {
    {
#line 2317
    be_rx_compl_process(rxo, napi, rxcp);
    }
  }
  loop_continue: 
  {
#line 2320
  be_rx_stats_update(rxo, rxcp);
#line 2289
  work_done = work_done + 1U;
  }
  ldv_54817: ;
#line 2289
  if (work_done < (u32 )budget) {
#line 2291
    goto ldv_54816;
  } else {

  }
  ldv_54814: ;
#line 2323
  if (work_done != 0U) {
    {
#line 2324
    be_cq_notify(adapter, (int )rx_cq->id, 1, (int )((u16 )work_done));
#line 2329
    tmp___4 = atomic_read((atomic_t const   *)(& rxo->q.used));
    }
#line 2329
    if (tmp___4 <= 959 && ! rxo->rx_post_starved) {
      {
#line 2331
      be_post_rx_frags(rxo, 32U);
      }
    } else {

    }
  } else {

  }
#line 2334
  return ((int )work_done);
}
}
#line 2337 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static bool be_process_tx(struct be_adapter *adapter , struct be_tx_obj *txo , int budget ,
                          int idx ) 
{ 
  struct be_eth_tx_compl *txcp ;
  int num_wrbs ;
  int work_done ;
  u32 tmp ;
  u32 tmp___0 ;
  u16 tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
#line 2341
  num_wrbs = 0;
#line 2343
  work_done = 0;
#line 2343
  goto ldv_54829;
  ldv_54828: 
  {
#line 2344
  txcp = be_tx_compl_get(& txo->cq);
  }
#line 2345
  if ((unsigned long )txcp == (unsigned long )((struct be_eth_tx_compl *)0)) {
#line 2346
    goto ldv_54827;
  } else {

  }
  {
#line 2347
  tmp = amap_mask(16U);
#line 2347
  tmp___0 = amap_get((void *)txcp, 0U, tmp, 0U);
#line 2347
  tmp___1 = be_tx_compl_process(adapter, txo, (int )((u16 )tmp___0));
#line 2347
  num_wrbs = num_wrbs + (int )tmp___1;
#line 2343
  work_done = work_done + 1;
  }
  ldv_54829: ;
#line 2343
  if (work_done < budget) {
#line 2345
    goto ldv_54828;
  } else {

  }
  ldv_54827: ;
#line 2352
  if (work_done != 0) {
    {
#line 2353
    be_cq_notify(adapter, (int )txo->cq.id, 1, (int )((u16 )work_done));
#line 2354
    atomic_sub(num_wrbs, & txo->q.used);
#line 2358
    tmp___2 = __netif_subqueue_stopped((struct net_device  const  *)adapter->netdev,
                                       (int )((u16 )idx));
    }
#line 2358
    if ((int )tmp___2) {
      {
#line 2358
      tmp___3 = atomic_read((atomic_t const   *)(& txo->q.used));
      }
#line 2358
      if (tmp___3 < (int )((unsigned int )txo->q.len / 2U)) {
        {
#line 2360
        netif_wake_subqueue(adapter->netdev, (int )((u16 )idx));
        }
      } else {

      }
    } else {

    }
    {
#line 2363
    u64_stats_update_begin(& txo->stats.sync_compl);
#line 2364
    txo->stats.tx_compl = txo->stats.tx_compl + (u64 )work_done;
#line 2365
    u64_stats_update_begin(& txo->stats.sync_compl);
    }
  } else {

  }
#line 2367
  return (work_done < budget);
}
}
#line 2370 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
int be_poll(struct napi_struct *napi , int budget ) 
{ 
  struct be_eq_obj *eqo ;
  struct napi_struct  const  *__mptr ;
  struct be_adapter *adapter ;
  int max_work ;
  int work ;
  int i ;
  int num_evts ;
  struct be_rx_obj *rxo ;
  bool tx_done ;
  int _max1 ;
  int _max2 ;
  bool tmp ;

  {
  {
#line 2372
  __mptr = (struct napi_struct  const  *)napi;
#line 2372
  eqo = (struct be_eq_obj *)__mptr + 0xffffffffffffff98UL;
#line 2373
  adapter = eqo->adapter;
#line 2374
  max_work = 0;
#line 2378
  num_evts = events_get(eqo);
#line 2381
  i = (int )eqo->idx;
  }
#line 2381
  goto ldv_54845;
  ldv_54844: 
  {
#line 2382
  tx_done = be_process_tx(adapter, (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i,
                          (int )eqo->tx_budget, i);
  }
#line 2384
  if (! tx_done) {
#line 2385
    max_work = budget;
  } else {

  }
#line 2381
  i = i + (int )adapter->num_evt_qs;
  ldv_54845: ;
#line 2381
  if (i < (int )adapter->num_tx_qs) {
#line 2383
    goto ldv_54844;
  } else {

  }
  {
#line 2388
  tmp = be_lock_napi(eqo);
  }
#line 2388
  if ((int )tmp) {
#line 2393
    i = (int )eqo->idx;
#line 2393
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2393
    goto ldv_54851;
    ldv_54850: 
    {
#line 2394
    work = be_process_rx(rxo, napi, budget, 0);
#line 2395
    _max1 = work;
#line 2395
    _max2 = max_work;
#line 2395
    max_work = _max1 > _max2 ? _max1 : _max2;
#line 2393
    i = i + (int )adapter->num_evt_qs;
#line 2393
    rxo = rxo + (unsigned long )adapter->num_evt_qs;
    }
    ldv_54851: ;
#line 2393
    if (i < (int )adapter->num_rx_qs) {
#line 2395
      goto ldv_54850;
    } else {

    }
    {
#line 2397
    be_unlock_napi(eqo);
    }
  } else {
#line 2399
    max_work = budget;
  }
#line 2402
  if ((unsigned int )eqo->idx == 0U) {
    {
#line 2403
    be_process_mcc(adapter);
    }
  } else {

  }
#line 2405
  if (max_work < budget) {
    {
#line 2406
    napi_complete(napi);
#line 2407
    be_eq_notify(adapter, (int )eqo->q.id, 1, 0, (int )((u16 )num_evts));
    }
  } else {
    {
#line 2410
    be_eq_notify(adapter, (int )eqo->q.id, 0, 0, (int )((u16 )num_evts));
    }
  }
#line 2412
  return (max_work);
}
}
#line 2416 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_busy_poll(struct napi_struct *napi ) 
{ 
  struct be_eq_obj *eqo ;
  struct napi_struct  const  *__mptr ;
  struct be_adapter *adapter ;
  struct be_rx_obj *rxo ;
  int i ;
  int work ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 2418
  __mptr = (struct napi_struct  const  *)napi;
#line 2418
  eqo = (struct be_eq_obj *)__mptr + 0xffffffffffffff98UL;
#line 2419
  adapter = eqo->adapter;
#line 2421
  work = 0;
#line 2423
  tmp = be_lock_busy_poll(eqo);
  }
#line 2423
  if (tmp) {
#line 2423
    tmp___0 = 0;
  } else {
#line 2423
    tmp___0 = 1;
  }
#line 2423
  if (tmp___0) {
#line 2424
    return (-2);
  } else {

  }
#line 2426
  i = (int )eqo->idx;
#line 2426
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2426
  goto ldv_54865;
  ldv_54864: 
  {
#line 2427
  work = be_process_rx(rxo, napi, 4, 1);
  }
#line 2428
  if (work != 0) {
#line 2429
    goto ldv_54863;
  } else {

  }
#line 2426
  i = i + (int )adapter->num_evt_qs;
#line 2426
  rxo = rxo + (unsigned long )adapter->num_evt_qs;
  ldv_54865: ;
#line 2426
  if (i < (int )adapter->num_rx_qs) {
#line 2428
    goto ldv_54864;
  } else {

  }
  ldv_54863: 
  {
#line 2432
  be_unlock_busy_poll(eqo);
  }
#line 2433
  return (work);
}
}
#line 2437 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
void be_detect_error(struct be_adapter *adapter ) 
{ 
  u32 ue_lo ;
  u32 ue_hi ;
  u32 ue_lo_mask ;
  u32 ue_hi_mask ;
  u32 sliport_status ;
  u32 sliport_err1 ;
  u32 sliport_err2 ;
  u32 i ;
  bool tmp ;

  {
  {
#line 2439
  ue_lo = 0U;
#line 2439
  ue_hi = 0U;
#line 2439
  ue_lo_mask = 0U;
#line 2439
  ue_hi_mask = 0U;
#line 2440
  sliport_status = 0U;
#line 2440
  sliport_err1 = 0U;
#line 2440
  sliport_err2 = 0U;
#line 2443
  tmp = be_hw_error(adapter);
  }
#line 2443
  if ((int )tmp) {
#line 2444
    return;
  } else {

  }
#line 2446
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
    {
#line 2447
    sliport_status = ioread32((void *)adapter->db + 1028U);
    }
#line 2448
    if ((int )sliport_status < 0) {
      {
#line 2449
      sliport_err1 = ioread32((void *)adapter->db + 1036U);
#line 2451
      sliport_err2 = ioread32((void *)adapter->db + 1040U);
      }
    } else {

    }
  } else {
    {
#line 2455
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 160, & ue_lo);
#line 2457
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 164, & ue_hi);
#line 2459
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 168, & ue_lo_mask);
#line 2461
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 172, & ue_hi_mask);
#line 2464
    ue_lo = ue_lo & ~ ue_lo_mask;
#line 2465
    ue_hi = ue_hi & ~ ue_hi_mask;
    }
  }
#line 2472
  if ((int )sliport_status < 0) {
#line 2473
    adapter->hw_error = 1;
#line 2475
    if (sliport_err1 == 2U && sliport_err2 == 0U) {
      {
#line 2477
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Firmware update in progress\n");
      }
#line 2479
      return;
    } else {
      {
#line 2481
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Error detected in the card\n");
      }
    }
  } else {

  }
#line 2486
  if ((int )sliport_status < 0) {
    {
#line 2487
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ERR: sliport status 0x%x\n",
            sliport_status);
#line 2489
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ERR: sliport error1 0x%x\n",
            sliport_err1);
#line 2491
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ERR: sliport error2 0x%x\n",
            sliport_err2);
    }
  } else {

  }
#line 2495
  if (ue_lo != 0U) {
#line 2496
    i = 0U;
#line 2496
    goto ldv_54878;
    ldv_54877: ;
#line 2497
    if ((int )ue_lo & 1) {
      {
#line 2498
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "UE: %s bit set\n",
              ue_status_low_desc[i]);
      }
    } else {

    }
#line 2496
    ue_lo = ue_lo >> 1;
#line 2496
    i = i + 1U;
    ldv_54878: ;
#line 2496
    if (ue_lo != 0U) {
#line 2498
      goto ldv_54877;
    } else {

    }

  } else {

  }
#line 2503
  if (ue_hi != 0U) {
#line 2504
    i = 0U;
#line 2504
    goto ldv_54881;
    ldv_54880: ;
#line 2505
    if ((int )ue_hi & 1) {
      {
#line 2506
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "UE: %s bit set\n",
              ue_status_hi_desc[i]);
      }
    } else {

    }
#line 2504
    ue_hi = ue_hi >> 1;
#line 2504
    i = i + 1U;
    ldv_54881: ;
#line 2504
    if (ue_hi != 0U) {
#line 2506
      goto ldv_54880;
    } else {

    }

  } else {

  }
#line 2512
  return;
}
}
#line 2513 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_msix_disable(struct be_adapter *adapter ) 
{ 


  {
#line 2515
  if ((unsigned int )adapter->num_msix_vec != 0U) {
    {
#line 2516
    pci_disable_msix(adapter->pdev);
#line 2517
    adapter->num_msix_vec = 0U;
#line 2518
    adapter->num_msix_roce_vec = 0U;
    }
  } else {

  }
#line 2520
  return;
}
}
#line 2522 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_msix_enable(struct be_adapter *adapter ) 
{ 
  int i ;
  int status ;
  int num_vec ;
  struct device *dev ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp ;

  {
#line 2525
  dev = & (adapter->pdev)->dev;
#line 2531
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
    {
#line 2532
    __min1 = (int )adapter->res.max_evt_qs * 2;
#line 2532
    tmp = cpumask_weight(cpu_online_mask);
#line 2532
    __min2 = (int )(tmp * 2U);
#line 2532
    num_vec = __min1 < __min2 ? __min1 : __min2;
    }
  } else {
#line 2535
    num_vec = (int )adapter->cfg_num_qs;
  }
#line 2537
  i = 0;
#line 2537
  goto ldv_54897;
  ldv_54896: 
#line 2538
  adapter->msix_entries[i].entry = (u16 )i;
#line 2537
  i = i + 1;
  ldv_54897: ;
#line 2537
  if (i < num_vec) {
#line 2539
    goto ldv_54896;
  } else {

  }
  {
#line 2540
  status = pci_enable_msix(adapter->pdev, (struct msix_entry *)(& adapter->msix_entries),
                           num_vec);
  }
#line 2541
  if (status == 0) {
#line 2542
    goto done;
  } else
#line 2543
  if (status > 0) {
    {
#line 2544
    num_vec = status;
#line 2545
    status = pci_enable_msix(adapter->pdev, (struct msix_entry *)(& adapter->msix_entries),
                             num_vec);
    }
#line 2547
    if (status == 0) {
#line 2548
      goto done;
    } else {

    }
  } else {

  }
  {
#line 2551
  dev_warn((struct device  const  *)dev, "MSIx enable failed\n");
  }
#line 2554
  if ((unsigned int )adapter->virtfn != 0U) {
#line 2555
    return (status);
  } else {

  }
#line 2556
  return (0);
  done: ;
#line 2558
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && ((adapter->function_mode & 4U) != 0U && num_vec > 1)) {
    {
#line 2559
    adapter->num_msix_roce_vec = (u32 )(num_vec / 2);
#line 2560
    _dev_info((struct device  const  *)dev, "enabled %d MSI-x vector(s) for RoCE\n",
              adapter->num_msix_roce_vec);
    }
  } else {

  }
  {
#line 2564
  adapter->num_msix_vec = (int )((u16 )num_vec) - (int )((u16 )adapter->num_msix_roce_vec);
#line 2566
  _dev_info((struct device  const  *)dev, "enabled %d MSI-x vector(s) for NIC\n",
            (int )adapter->num_msix_vec);
  }
#line 2568
  return (0);
}
}
#line 2571 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static int be_msix_vec_get(struct be_adapter *adapter , struct be_eq_obj *eqo ) 
{ 


  {
#line 2574
  return ((int )adapter->msix_entries[(int )eqo->msix_idx].vector);
}
}
#line 2577 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_msix_register(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct be_eq_obj *eqo ;
  int status ;
  int i ;
  int vec ;
  int tmp ;

  {
#line 2579
  netdev = adapter->netdev;
#line 2583
  i = 0;
#line 2583
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2583
  goto ldv_54914;
  ldv_54913: 
  {
#line 2584
  sprintf((char *)(& eqo->desc), "%s-q%d", (char *)(& netdev->name), i);
#line 2585
  vec = be_msix_vec_get(adapter, eqo);
#line 2586
  status = ldv_request_irq_18((unsigned int )vec, & be_msix, 0UL, (char const   *)(& eqo->desc),
                              (void *)eqo);
  }
#line 2587
  if (status != 0) {
#line 2588
    goto err_msix;
  } else {

  }
#line 2583
  i = i + 1;
#line 2583
  eqo = eqo + 1;
  ldv_54914: ;
#line 2583
  if (i < (int )adapter->num_evt_qs) {
#line 2585
    goto ldv_54913;
  } else {

  }

#line 2591
  return (0);
  err_msix: 
#line 2593
  i = i - 1;
#line 2593
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2593
  goto ldv_54917;
  ldv_54916: 
  {
#line 2594
  tmp = be_msix_vec_get(adapter, eqo);
#line 2594
  ldv_free_irq_19((unsigned int )tmp, (void *)eqo);
#line 2593
  i = i - 1;
#line 2593
  eqo = eqo - 1;
  }
  ldv_54917: ;
#line 2593
  if (i >= 0) {
#line 2595
    goto ldv_54916;
  } else {

  }
  {
#line 2595
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "MSIX Request IRQ failed - err %d\n",
           status);
#line 2597
  be_msix_disable(adapter);
  }
#line 2598
  return (status);
}
}
#line 2601 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_irq_register(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;

  {
#line 2603
  netdev = adapter->netdev;
#line 2606
  if ((unsigned int )adapter->num_msix_vec != 0U) {
    {
#line 2607
    status = be_msix_register(adapter);
    }
#line 2608
    if (status == 0) {
#line 2609
      goto done;
    } else {

    }
#line 2611
    if ((unsigned int )adapter->virtfn != 0U) {
#line 2612
      return (status);
    } else {

    }
  } else {

  }
  {
#line 2616
  netdev->irq = (int )(adapter->pdev)->irq;
#line 2617
  status = ldv_request_irq_20((unsigned int )netdev->irq, & be_intx, 128UL, (char const   *)(& netdev->name),
                              (void *)(& adapter->eq_obj));
  }
#line 2619
  if (status != 0) {
    {
#line 2620
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "INTx request IRQ failed - err %d\n",
            status);
    }
#line 2622
    return (status);
  } else {

  }
  done: 
#line 2625
  adapter->isr_registered = 1;
#line 2626
  return (0);
}
}
#line 2629 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_irq_unregister(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  struct be_eq_obj *eqo ;
  int i ;
  int tmp ;

  {
#line 2631
  netdev = adapter->netdev;
#line 2635
  if (! adapter->isr_registered) {
#line 2636
    return;
  } else {

  }
#line 2639
  if ((unsigned int )adapter->num_msix_vec == 0U) {
    {
#line 2640
    ldv_free_irq_21((unsigned int )netdev->irq, (void *)(& adapter->eq_obj));
    }
#line 2641
    goto done;
  } else {

  }
#line 2645
  i = 0;
#line 2645
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2645
  goto ldv_54933;
  ldv_54932: 
  {
#line 2646
  tmp = be_msix_vec_get(adapter, eqo);
#line 2646
  ldv_free_irq_22((unsigned int )tmp, (void *)eqo);
#line 2645
  i = i + 1;
#line 2645
  eqo = eqo + 1;
  }
  ldv_54933: ;
#line 2645
  if (i < (int )adapter->num_evt_qs) {
#line 2647
    goto ldv_54932;
  } else {

  }

  done: 
#line 2649
  adapter->isr_registered = 0;
#line 2650
  return;
}
}
#line 2652 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_rx_qs_destroy(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *q ;
  struct be_rx_obj *rxo ;
  int i ;

  {
#line 2658
  i = 0;
#line 2658
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2658
  goto ldv_54942;
  ldv_54941: 
#line 2659
  q = & rxo->q;
#line 2660
  if ((int )q->created) {
    {
#line 2661
    be_cmd_rxq_destroy(adapter, q);
#line 2662
    be_rx_cq_clean(rxo);
    }
  } else {

  }
  {
#line 2664
  be_queue_free(adapter, q);
#line 2658
  i = i + 1;
#line 2658
  rxo = rxo + 1;
  }
  ldv_54942: ;
#line 2658
  if (i < (int )adapter->num_rx_qs) {
#line 2660
    goto ldv_54941;
  } else {

  }

#line 2665
  return;
}
}
#line 2668 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_close(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;
  int tmp___0 ;

  {
  {
#line 2670
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2670
  adapter = (struct be_adapter *)tmp;
#line 2674
  be_roce_dev_close(adapter);
  }
#line 2676
  if ((adapter->flags & 512U) != 0U) {
#line 2677
    i = 0;
#line 2677
    eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2677
    goto ldv_54951;
    ldv_54950: 
    {
#line 2678
    napi_disable(& eqo->napi);
#line 2679
    be_disable_busy_poll(eqo);
#line 2677
    i = i + 1;
#line 2677
    eqo = eqo + 1;
    }
    ldv_54951: ;
#line 2677
    if (i < (int )adapter->num_evt_qs) {
#line 2679
      goto ldv_54950;
    } else {

    }
#line 2681
    adapter->flags = adapter->flags & 4294966783U;
  } else {

  }
  {
#line 2684
  be_async_mcc_disable(adapter);
#line 2689
  netif_tx_disable(netdev);
#line 2690
  be_tx_compl_clean(adapter);
#line 2692
  be_rx_qs_destroy(adapter);
#line 2694
  i = 1;
  }
#line 2694
  goto ldv_54954;
  ldv_54953: 
  {
#line 2695
  be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                  0U);
#line 2694
  i = i + 1;
  }
  ldv_54954: ;
#line 2694
  if ((u32 )i < adapter->uc_macs + 1U) {
#line 2696
    goto ldv_54953;
  } else {

  }
#line 2697
  adapter->uc_macs = 0U;
#line 2699
  i = 0;
#line 2699
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
#line 2699
  goto ldv_54957;
  ldv_54956: ;
#line 2700
  if ((unsigned int )adapter->num_msix_vec != 0U) {
    {
#line 2701
    tmp___0 = be_msix_vec_get(adapter, eqo);
#line 2701
    synchronize_irq((unsigned int )tmp___0);
    }
  } else {
    {
#line 2703
    synchronize_irq((unsigned int )netdev->irq);
    }
  }
  {
#line 2704
  be_eq_clean(eqo);
#line 2699
  i = i + 1;
#line 2699
  eqo = eqo + 1;
  }
  ldv_54957: ;
#line 2699
  if (i < (int )adapter->num_evt_qs) {
#line 2701
    goto ldv_54956;
  } else {

  }
  {
#line 2707
  be_irq_unregister(adapter);
  }
#line 2709
  return (0);
}
}
#line 2712 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_rx_qs_create(struct be_adapter *adapter ) 
{ 
  struct be_rx_obj *rxo ;
  int rc ;
  int i ;
  int j ;
  u8 rsstable[128U] ;
  bool tmp ;

  {
#line 2718
  i = 0;
#line 2718
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2718
  goto ldv_54968;
  ldv_54967: 
  {
#line 2719
  rc = be_queue_alloc(adapter, & rxo->q, 1024, 8);
  }
#line 2721
  if (rc != 0) {
#line 2722
    return (rc);
  } else {

  }
#line 2718
  i = i + 1;
#line 2718
  rxo = rxo + 1;
  ldv_54968: ;
#line 2718
  if (i < (int )adapter->num_rx_qs) {
#line 2720
    goto ldv_54967;
  } else {

  }
  {
#line 2726
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + ((unsigned long )adapter->num_rx_qs + 0xffffffffffffffffUL);
#line 2727
  rc = be_cmd_rxq_create(adapter, & rxo->q, (int )rxo->cq.id, (int )rx_frag_size,
                         (u32 )adapter->if_handle, 0U, & rxo->rss_id);
  }
#line 2729
  if (rc != 0) {
#line 2730
    return (rc);
  } else {

  }
#line 2732
  i = 0;
#line 2732
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2732
  goto ldv_54971;
  ldv_54970: 
  {
#line 2733
  rc = be_cmd_rxq_create(adapter, & rxo->q, (int )rxo->cq.id, (int )rx_frag_size,
                         (u32 )adapter->if_handle, 1U, & rxo->rss_id);
  }
#line 2736
  if (rc != 0) {
#line 2737
    return (rc);
  } else {

  }
#line 2732
  i = i + 1;
#line 2732
  rxo = rxo + 1;
  ldv_54971: ;
#line 2732
  if (i < (int )adapter->num_rx_qs + -1) {
#line 2734
    goto ldv_54970;
  } else {

  }
  {
#line 2740
  tmp = be_multi_rxq((struct be_adapter  const  *)adapter);
  }
#line 2740
  if ((int )tmp) {
#line 2741
    j = 0;
#line 2741
    goto ldv_54977;
    ldv_54976: 
#line 2742
    i = 0;
#line 2742
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2742
    goto ldv_54975;
    ldv_54974: ;
#line 2743
    if (j + i > 127) {
#line 2744
      goto ldv_54973;
    } else {

    }
#line 2745
    rsstable[j + i] = rxo->rss_id;
#line 2742
    i = i + 1;
#line 2742
    rxo = rxo + 1;
    ldv_54975: ;
#line 2742
    if (i < (int )adapter->num_rx_qs + -1) {
#line 2744
      goto ldv_54974;
    } else {

    }
    ldv_54973: 
#line 2741
    j = j + ((int )adapter->num_rx_qs + -1);
    ldv_54977: ;
#line 2741
    if (j <= 127) {
#line 2743
      goto ldv_54976;
    } else {

    }
#line 2748
    adapter->rss_flags = 15ULL;
#line 2751
    if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
#line 2752
      adapter->rss_flags = adapter->rss_flags | 48ULL;
    } else {

    }
  } else {
#line 2756
    adapter->rss_flags = 0ULL;
  }
  {
#line 2759
  rc = be_cmd_rss_config(adapter, (u8 *)(& rsstable), (u32 )adapter->rss_flags, 128);
  }
#line 2761
  if (rc != 0) {
#line 2762
    adapter->rss_flags = 0ULL;
#line 2763
    return (rc);
  } else {

  }
#line 2767
  i = 0;
#line 2767
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2767
  goto ldv_54980;
  ldv_54979: 
  {
#line 2768
  be_post_rx_frags(rxo, 208U);
#line 2767
  i = i + 1;
#line 2767
  rxo = rxo + 1;
  }
  ldv_54980: ;
#line 2767
  if (i < (int )adapter->num_rx_qs) {
#line 2769
    goto ldv_54979;
  } else {

  }

#line 2769
  return (0);
}
}
#line 2772 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_open(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  u8 link_status ;
  int status ;
  int i ;

  {
  {
#line 2774
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 2774
  adapter = (struct be_adapter *)tmp;
#line 2781
  status = be_rx_qs_create(adapter);
  }
#line 2782
  if (status != 0) {
#line 2783
    goto err;
  } else {

  }
  {
#line 2785
  status = be_irq_register(adapter);
  }
#line 2786
  if (status != 0) {
#line 2787
    goto err;
  } else {

  }
#line 2789
  i = 0;
#line 2789
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 2789
  goto ldv_54994;
  ldv_54993: 
  {
#line 2790
  be_cq_notify(adapter, (int )rxo->cq.id, 1, 0);
#line 2789
  i = i + 1;
#line 2789
  rxo = rxo + 1;
  }
  ldv_54994: ;
#line 2789
  if (i < (int )adapter->num_rx_qs) {
#line 2791
    goto ldv_54993;
  } else {

  }
#line 2792
  i = 0;
#line 2792
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )i;
#line 2792
  goto ldv_54997;
  ldv_54996: 
  {
#line 2793
  be_cq_notify(adapter, (int )txo->cq.id, 1, 0);
#line 2792
  i = i + 1;
#line 2792
  txo = txo + 1;
  }
  ldv_54997: ;
#line 2792
  if (i < (int )adapter->num_tx_qs) {
#line 2794
    goto ldv_54996;
  } else {

  }
  {
#line 2795
  be_async_mcc_enable(adapter);
#line 2797
  i = 0;
#line 2797
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
  }
#line 2797
  goto ldv_55000;
  ldv_54999: 
  {
#line 2798
  napi_enable(& eqo->napi);
#line 2799
  be_enable_busy_poll(eqo);
#line 2800
  be_eq_notify(adapter, (int )eqo->q.id, 1, 0, 0);
#line 2797
  i = i + 1;
#line 2797
  eqo = eqo + 1;
  }
  ldv_55000: ;
#line 2797
  if (i < (int )adapter->num_evt_qs) {
#line 2799
    goto ldv_54999;
  } else {

  }
  {
#line 2802
  adapter->flags = adapter->flags | 512U;
#line 2804
  status = be_cmd_link_status_query(adapter, (u16 *)0U, & link_status, 0U);
  }
#line 2805
  if (status == 0) {
    {
#line 2806
    be_link_status_update(adapter, (int )link_status);
    }
  } else {

  }
  {
#line 2808
  netif_tx_start_all_queues(netdev);
#line 2809
  be_roce_dev_open(adapter);
  }
#line 2810
  return (0);
  err: 
  {
#line 2812
  be_close(adapter->netdev);
  }
#line 2813
  return (-5);
}
}
#line 2816 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_setup_wol(struct be_adapter *adapter , bool enable ) 
{ 
  struct be_dma_mem cmd ;
  int status ;
  u8 mac[6U] ;

  {
  {
#line 2819
  status = 0;
#line 2822
  memset((void *)(& mac), 0, 6UL);
#line 2824
  cmd.size = 604U;
#line 2825
  cmd.va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma,
                               208U);
  }
#line 2827
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2828
    return (-1);
  } else {

  }
#line 2830
  if ((int )enable) {
    {
#line 2831
    status = pci_write_config_dword((struct pci_dev  const  *)adapter->pdev, 68, 264U);
    }
#line 2833
    if (status != 0) {
      {
#line 2834
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Could not enable Wake-on-lan\n");
#line 2836
      dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
      }
#line 2838
      return (status);
    } else {

    }
    {
#line 2840
    status = be_cmd_enable_magic_wol(adapter, (adapter->netdev)->dev_addr, & cmd);
#line 2842
    pci_enable_wake(adapter->pdev, 3, 1);
#line 2843
    pci_enable_wake(adapter->pdev, 4, 1);
    }
  } else {
    {
#line 2845
    status = be_cmd_enable_magic_wol(adapter, (u8 *)(& mac), & cmd);
#line 2846
    pci_enable_wake(adapter->pdev, 3, 0);
#line 2847
    pci_enable_wake(adapter->pdev, 4, 0);
    }
  }
  {
#line 2850
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
  }
#line 2851
  return (status);
}
}
#line 2860 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vf_eth_addr_config(struct be_adapter *adapter ) 
{ 
  u32 vf ;
  int status ;
  u8 mac[6U] ;
  struct be_vf_cfg *vf_cfg ;

  {
  {
#line 2863
  status = 0;
#line 2867
  be_vf_eth_addr_generate(adapter, (u8 *)(& mac));
#line 2869
  vf = 0U;
#line 2869
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
  }
#line 2869
  goto ldv_55017;
  ldv_55016: ;
#line 2870
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 2871
    status = be_cmd_pmac_add(adapter, (u8 *)(& mac), (u32 )vf_cfg->if_handle, (u32 *)(& vf_cfg->pmac_id),
                             vf + 1U);
    }
  } else {
    {
#line 2875
    status = be_cmd_set_mac(adapter, (u8 *)(& mac), vf_cfg->if_handle, vf + 1U);
    }
  }
#line 2878
  if (status != 0) {
    {
#line 2879
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Mac address assignment failed for VF %d\n",
            vf);
    }
  } else {
    {
#line 2882
    memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac), 6UL);
    }
  }
#line 2884
  mac[5] = (unsigned int )mac[5] + 1U;
#line 2869
  vf = vf + 1U;
#line 2869
  vf_cfg = vf_cfg + 1;
  ldv_55017: ;
#line 2869
  if (vf < (u32 )adapter->num_vfs) {
#line 2871
    goto ldv_55016;
  } else {

  }

#line 2886
  return (status);
}
}
#line 2889 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vfs_mac_query(struct be_adapter *adapter ) 
{ 
  int status ;
  int vf ;
  u8 mac[6U] ;
  struct be_vf_cfg *vf_cfg ;

  {
#line 2895
  vf = 0;
#line 2895
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2895
  goto ldv_55027;
  ldv_55026: 
  {
#line 2896
  status = be_cmd_get_active_mac(adapter, (u32 )vf_cfg->pmac_id, (u8 *)(& mac), (u32 )vf_cfg->if_handle,
                                 0, (u32 )(vf + 1));
  }
#line 2899
  if (status != 0) {
#line 2900
    return (status);
  } else {

  }
  {
#line 2901
  memcpy((void *)(& vf_cfg->mac_addr), (void const   *)(& mac), 6UL);
#line 2895
  vf = vf + 1;
#line 2895
  vf_cfg = vf_cfg + 1;
  }
  ldv_55027: ;
#line 2895
  if (vf < (int )adapter->num_vfs) {
#line 2897
    goto ldv_55026;
  } else {

  }

#line 2903
  return (0);
}
}
#line 2906 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_vf_clear(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  u32 vf ;
  int tmp ;

  {
  {
#line 2911
  tmp = pci_vfs_assigned(adapter->pdev);
  }
#line 2911
  if (tmp != 0) {
    {
#line 2912
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VFs are assigned to VMs: not disabling VFs\n");
    }
#line 2914
    goto done;
  } else {

  }
  {
#line 2917
  pci_disable_sriov(adapter->pdev);
#line 2919
  vf = 0U;
#line 2919
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
  }
#line 2919
  goto ldv_55036;
  ldv_55035: ;
#line 2920
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 2921
    be_cmd_pmac_del(adapter, (u32 )vf_cfg->if_handle, vf_cfg->pmac_id, vf + 1U);
    }
  } else {
    {
#line 2924
    be_cmd_set_mac(adapter, (u8 *)0U, vf_cfg->if_handle, vf + 1U);
    }
  }
  {
#line 2927
  be_cmd_if_destroy(adapter, vf_cfg->if_handle, vf + 1U);
#line 2919
  vf = vf + 1U;
#line 2919
  vf_cfg = vf_cfg + 1;
  }
  ldv_55036: ;
#line 2919
  if (vf < (u32 )adapter->num_vfs) {
#line 2921
    goto ldv_55035;
  } else {

  }

  done: 
  {
#line 2930
  kfree((void const   *)adapter->vf_cfg);
#line 2931
  adapter->num_vfs = 0U;
  }
#line 2932
  return;
}
}
#line 2934 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_clear_queues(struct be_adapter *adapter ) 
{ 


  {
  {
#line 2936
  be_mcc_queues_destroy(adapter);
#line 2937
  be_rx_cqs_destroy(adapter);
#line 2938
  be_tx_queues_destroy(adapter);
#line 2939
  be_evt_queues_destroy(adapter);
  }
#line 2940
  return;
}
}
#line 2942 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_cancel_worker(struct be_adapter *adapter ) 
{ 


  {
#line 2944
  if ((adapter->flags & 8U) != 0U) {
    {
#line 2945
    cancel_delayed_work_sync(& adapter->work);
#line 2946
    adapter->flags = adapter->flags & 4294967287U;
    }
  } else {

  }
#line 2948
  return;
}
}
#line 2950 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_mac_clear(struct be_adapter *adapter ) 
{ 
  int i ;

  {
#line 2954
  if ((unsigned long )adapter->pmac_id != (unsigned long )((u32 *)0U)) {
#line 2955
    i = 0;
#line 2955
    goto ldv_55049;
    ldv_55048: 
    {
#line 2956
    be_cmd_pmac_del(adapter, (u32 )adapter->if_handle, (int )*(adapter->pmac_id + (unsigned long )i),
                    0U);
#line 2955
    i = i + 1;
    }
    ldv_55049: ;
#line 2955
    if ((u32 )i < adapter->uc_macs + 1U) {
#line 2957
      goto ldv_55048;
    } else {

    }
    {
#line 2958
    adapter->uc_macs = 0U;
#line 2960
    kfree((void const   *)adapter->pmac_id);
#line 2961
    adapter->pmac_id = (u32 *)0U;
    }
  } else {

  }
#line 2963
  return;
}
}
#line 2965 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_clear(struct be_adapter *adapter ) 
{ 


  {
  {
#line 2967
  be_cancel_worker(adapter);
  }
#line 2969
  if ((unsigned int )adapter->num_vfs != 0U) {
    {
#line 2970
    be_vf_clear(adapter);
    }
  } else {

  }
  {
#line 2973
  be_mac_clear(adapter);
#line 2975
  be_cmd_if_destroy(adapter, adapter->if_handle, 0U);
#line 2977
  be_clear_queues(adapter);
#line 2979
  be_msix_disable(adapter);
  }
#line 2980
  return (0);
}
}
#line 2983 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vfs_if_create(struct be_adapter *adapter ) 
{ 
  struct be_resources res ;
  struct be_vf_cfg *vf_cfg ;
  u32 cap_flags ;
  u32 en_flags ;
  u32 vf ;
  int status ;

  {
#line 2985
  res.max_vfs = 0U;
#line 2985
  res.max_mcast_mac = (unsigned short)0;
#line 2985
  res.max_tx_qs = (unsigned short)0;
#line 2985
  res.max_rss_qs = (unsigned short)0;
#line 2985
  res.max_rx_qs = (unsigned short)0;
#line 2985
  res.max_uc_mac = (unsigned short)0;
#line 2985
  res.max_vlans = (unsigned short)0;
#line 2985
  res.max_evt_qs = (unsigned short)0;
#line 2985
  res.if_cap_flags = 0U;
#line 2988
  status = 0;
#line 2990
  cap_flags = 4144U;
#line 2993
  vf = 0U;
#line 2993
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 2993
  goto ldv_55065;
  ldv_55064: ;
#line 2994
  if ((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) {
    {
#line 2995
    status = be_cmd_get_profile_config(adapter, & res, (int )((unsigned int )((u8 )vf) + 1U));
    }
#line 2997
    if (status == 0) {
#line 2998
      cap_flags = res.if_cap_flags;
    } else {

    }
  } else {

  }
  {
#line 3002
  en_flags = cap_flags & 4144U;
#line 3004
  status = be_cmd_if_create(adapter, cap_flags, en_flags, (u32 *)(& vf_cfg->if_handle),
                            vf + 1U);
  }
#line 3006
  if (status != 0) {
#line 3007
    goto err;
  } else {

  }
#line 2993
  vf = vf + 1U;
#line 2993
  vf_cfg = vf_cfg + 1;
  ldv_55065: ;
#line 2993
  if (vf < (u32 )adapter->num_vfs) {
#line 2995
    goto ldv_55064;
  } else {

  }

  err: ;
#line 3010
  return (status);
}
}
#line 3013 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vf_setup_init(struct be_adapter *adapter ) 
{ 
  struct be_vf_cfg *vf_cfg ;
  int vf ;
  void *tmp ;

  {
  {
#line 3018
  tmp = kcalloc((size_t )adapter->num_vfs, 24UL, 208U);
#line 3018
  adapter->vf_cfg = (struct be_vf_cfg *)tmp;
  }
#line 3020
  if ((unsigned long )adapter->vf_cfg == (unsigned long )((struct be_vf_cfg *)0)) {
#line 3021
    return (-12);
  } else {

  }
#line 3023
  vf = 0;
#line 3023
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3023
  goto ldv_55073;
  ldv_55072: 
#line 3024
  vf_cfg->if_handle = -1;
#line 3025
  vf_cfg->pmac_id = -1;
#line 3023
  vf = vf + 1;
#line 3023
  vf_cfg = vf_cfg + 1;
  ldv_55073: ;
#line 3023
  if (vf < (int )adapter->num_vfs) {
#line 3025
    goto ldv_55072;
  } else {

  }

#line 3027
  return (0);
}
}
#line 3030 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_vf_setup(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  struct be_vf_cfg *vf_cfg ;
  int status ;
  int old_vfs ;
  int vf ;
  u32 privileges ;
  u16 lnk_speed ;
  u16 __min1 ;
  u16 __min2 ;

  {
  {
#line 3032
  dev = & (adapter->pdev)->dev;
#line 3038
  old_vfs = pci_num_vf(adapter->pdev);
  }
#line 3039
  if (old_vfs != 0) {
    {
#line 3040
    _dev_info((struct device  const  *)dev, "%d VFs are already enabled\n", old_vfs);
    }
#line 3041
    if ((unsigned int )old_vfs != num_vfs) {
      {
#line 3042
      dev_warn((struct device  const  *)dev, "Ignoring num_vfs=%d setting\n", num_vfs);
      }
    } else {

    }
#line 3043
    adapter->num_vfs = (u16 )old_vfs;
  } else {
#line 3045
    if (num_vfs > (unsigned int )adapter->res.max_vfs) {
      {
#line 3046
      _dev_info((struct device  const  *)dev, "Device supports %d VFs and not %d\n",
                (int )adapter->res.max_vfs, num_vfs);
      }
    } else {

    }
#line 3048
    __min1 = (u16 )num_vfs;
#line 3048
    __min2 = adapter->res.max_vfs;
#line 3048
    adapter->num_vfs = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
#line 3049
    if ((unsigned int )adapter->num_vfs == 0U) {
#line 3050
      return (0);
    } else {

    }
  }
  {
#line 3053
  status = be_vf_setup_init(adapter);
  }
#line 3054
  if (status != 0) {
#line 3055
    goto err;
  } else {

  }
#line 3057
  if (old_vfs != 0) {
#line 3058
    vf = 0;
#line 3058
    vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3058
    goto ldv_55090;
    ldv_55089: 
    {
#line 3059
    status = be_cmd_get_if_id(adapter, vf_cfg, vf);
    }
#line 3060
    if (status != 0) {
#line 3061
      goto err;
    } else {

    }
#line 3058
    vf = vf + 1;
#line 3058
    vf_cfg = vf_cfg + 1;
    ldv_55090: ;
#line 3058
    if (vf < (int )adapter->num_vfs) {
#line 3060
      goto ldv_55089;
    } else {

    }

  } else {
    {
#line 3064
    status = be_vfs_if_create(adapter);
    }
#line 3065
    if (status != 0) {
#line 3066
      goto err;
    } else {

    }
  }
#line 3069
  if (old_vfs != 0) {
    {
#line 3070
    status = be_vfs_mac_query(adapter);
    }
#line 3071
    if (status != 0) {
#line 3072
      goto err;
    } else {

    }
  } else {
    {
#line 3074
    status = be_vf_eth_addr_config(adapter);
    }
#line 3075
    if (status != 0) {
#line 3076
      goto err;
    } else {

    }
  }
#line 3079
  vf = 0;
#line 3079
  vf_cfg = adapter->vf_cfg + (unsigned long )vf;
#line 3079
  goto ldv_55093;
  ldv_55092: 
  {
#line 3081
  status = be_cmd_get_fn_privileges(adapter, & privileges, (u32 )(vf + 1));
  }
#line 3082
  if (status == 0 && (privileges & 64U) == 0U) {
    {
#line 3083
    status = be_cmd_set_fn_privileges(adapter, privileges | 64U, (u32 )(vf + 1));
    }
#line 3087
    if (status == 0) {
      {
#line 3088
      _dev_info((struct device  const  *)dev, "VF%d has FILTMGMT privilege\n", vf);
      }
    } else {

    }
  } else {

  }
#line 3095
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && old_vfs == 0) {
    {
#line 3096
    be_cmd_set_qos(adapter, 1000U, (u32 )(vf + 1));
    }
  } else {

  }
  {
#line 3098
  status = be_cmd_link_status_query(adapter, & lnk_speed, (u8 *)0U, (u32 )(vf + 1));
  }
#line 3100
  if (status == 0) {
#line 3101
    vf_cfg->tx_rate = (u32 )lnk_speed;
  } else {

  }
#line 3103
  if (old_vfs == 0) {
    {
#line 3104
    be_cmd_enable_vf(adapter, (int )((unsigned int )((u8 )vf) + 1U));
    }
  } else {

  }
#line 3079
  vf = vf + 1;
#line 3079
  vf_cfg = vf_cfg + 1;
  ldv_55093: ;
#line 3079
  if (vf < (int )adapter->num_vfs) {
#line 3081
    goto ldv_55092;
  } else {

  }

#line 3107
  if (old_vfs == 0) {
    {
#line 3108
    status = pci_enable_sriov(adapter->pdev, (int )adapter->num_vfs);
    }
#line 3109
    if (status != 0) {
      {
#line 3110
      dev_err((struct device  const  *)dev, "SRIOV enable failed\n");
#line 3111
      adapter->num_vfs = 0U;
      }
#line 3112
      goto err;
    } else {

    }
  } else {

  }
#line 3115
  return (0);
  err: 
  {
#line 3117
  dev_err((struct device  const  *)dev, "VF setup failed\n");
#line 3118
  be_vf_clear(adapter);
  }
#line 3119
  return (status);
}
}
#line 3123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void BEx_get_resources(struct be_adapter *adapter , struct be_resources *res ) 
{ 
  struct pci_dev *pdev ;
  bool use_sriov ;
  int max_vfs ;
  int _min1 ;
  int _min2 ;
  int tmp ;
  bool tmp___0 ;

  {
  {
#line 3126
  pdev = adapter->pdev;
#line 3127
  use_sriov = 0;
#line 3130
  max_vfs = pci_sriov_get_totalvfs(pdev);
  }
#line 3132
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 3132
    if ((unsigned int )adapter->virtfn == 0U) {
#line 3132
      if (num_vfs != 0U) {
#line 3132
        goto _L;
      } else {
        {
#line 3132
        tmp = pci_num_vf(adapter->pdev);
        }
#line 3132
        if (tmp != 0) {
          _L: /* CIL Label */ 
#line 3133
          if (max_vfs > 0) {
#line 3133
            _min1 = 30;
#line 3133
            _min2 = max_vfs;
#line 3133
            res->max_vfs = (u16 )(_min1 < _min2 ? _min1 : _min2);
          } else {
#line 3133
            res->max_vfs = 0U;
          }
#line 3134
          use_sriov = (unsigned int )res->max_vfs != 0U;
        } else {

        }
      }
    } else {

    }
  } else {

  }
#line 3137
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3138
    res->max_uc_mac = 30U;
  } else {
#line 3140
    res->max_uc_mac = 2U;
  }
#line 3142
  if ((adapter->function_mode & 1024U) != 0U) {
#line 3143
    res->max_vlans = 8U;
  } else
#line 3144
  if ((adapter->function_mode & 16777216U) != 0U) {
#line 3145
    res->max_vlans = 15U;
  } else {
#line 3147
    res->max_vlans = 64U;
  }
#line 3148
  res->max_mcast_mac = 64U;
#line 3151
  if (((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) || (int )use_sriov) {
#line 3153
    res->max_tx_qs = 1U;
  } else {
    {
#line 3151
    tmp___0 = be_is_mc(adapter);
    }
#line 3151
    if ((int )tmp___0) {
#line 3153
      res->max_tx_qs = 1U;
    } else
#line 3151
    if ((unsigned int )adapter->virtfn != 0U) {
#line 3153
      res->max_tx_qs = 1U;
    } else
#line 3151
    if (adapter->port_num > 1U) {
#line 3153
      res->max_tx_qs = 1U;
    } else {
#line 3155
      res->max_tx_qs = 16U;
    }
  }
#line 3157
  if (((adapter->function_caps & 2U) != 0U && ! use_sriov) && (unsigned int )adapter->virtfn == 0U) {
#line 3159
    res->max_rss_qs = (int )adapter->be3_native ? 16U : 4U;
  } else {

  }
#line 3161
  res->max_rx_qs = (unsigned int )res->max_rss_qs + 1U;
#line 3163
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3164
    res->max_evt_qs = max_vfs > 0 ? 8U : 16U;
  } else {
#line 3167
    res->max_evt_qs = 1U;
  }
#line 3169
  res->if_cap_flags = 7100U;
#line 3170
  if ((adapter->function_caps & 2U) == 0U) {
#line 3171
    res->if_cap_flags = res->if_cap_flags & 4294967291U;
  } else {

  }
#line 3172
  return;
}
}
#line 3174 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_setup_init(struct be_adapter *adapter ) 
{ 


  {
#line 3176
  adapter->vlan_prio_bmap = 255U;
#line 3177
  adapter->phy.link_speed = -1;
#line 3178
  adapter->if_handle = -1;
#line 3179
  adapter->be3_native = 0;
#line 3180
  adapter->promiscuous = 0;
#line 3181
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3182
    adapter->cmd_privileges = 1792U;
  } else {
#line 3184
    adapter->cmd_privileges = 1U;
  }
#line 3185
  return;
}
}
#line 3187 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_resources(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  struct be_resources res ;
  int status ;

  {
#line 3189
  dev = & (adapter->pdev)->dev;
#line 3190
  res.max_vfs = 0U;
#line 3190
  res.max_mcast_mac = (unsigned short)0;
#line 3190
  res.max_tx_qs = (unsigned short)0;
#line 3190
  res.max_rss_qs = (unsigned short)0;
#line 3190
  res.max_rx_qs = (unsigned short)0;
#line 3190
  res.max_uc_mac = (unsigned short)0;
#line 3190
  res.max_vlans = (unsigned short)0;
#line 3190
  res.max_evt_qs = (unsigned short)0;
#line 3190
  res.if_cap_flags = 0U;
#line 3193
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 3194
    BEx_get_resources(adapter, & res);
#line 3195
    adapter->res = res;
    }
  } else {

  }
#line 3202
  if (((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) {
    {
#line 3203
    status = be_cmd_get_func_config(adapter, & res);
    }
#line 3204
    if (status != 0) {
#line 3205
      return (status);
    } else {

    }
#line 3208
    if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
#line 3209
      res.max_evt_qs = (u16 )((unsigned int )res.max_evt_qs / 2U);
    } else {

    }
#line 3210
    adapter->res = res;
#line 3212
    if ((unsigned int )adapter->virtfn == 0U) {
      {
#line 3213
      status = be_cmd_get_profile_config(adapter, & res, 0);
      }
#line 3214
      if (status != 0) {
#line 3215
        return (status);
      } else {

      }
#line 3216
      adapter->res.max_vfs = res.max_vfs;
    } else {

    }
    {
#line 3219
    _dev_info((struct device  const  *)dev, "Max: txqs %d, rxqs %d, rss %d, eqs %d, vfs %d\n",
              (int )adapter->res.max_tx_qs, (int )adapter->res.max_rx_qs, (int )adapter->res.max_rss_qs,
              (int )adapter->res.max_evt_qs, (int )adapter->res.max_vfs);
#line 3223
    _dev_info((struct device  const  *)dev, "Max: uc-macs %d, mc-macs %d, vlans %d\n",
              (int )adapter->res.max_uc_mac, (int )adapter->res.max_mcast_mac, (int )adapter->res.max_vlans);
    }
  } else {

  }
#line 3228
  return (0);
}
}
#line 3232 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_config(struct be_adapter *adapter ) 
{ 
  u16 profile_id ;
  int status ;
  void *tmp ;
  u16 _min1 ;
  u16 _min2 ;
  u16 tmp___0 ;

  {
  {
#line 3237
  status = be_cmd_query_fw_cfg(adapter, & adapter->port_num, & adapter->function_mode,
                               & adapter->function_caps, & adapter->asic_rev);
  }
#line 3241
  if (status != 0) {
#line 3242
    return (status);
  } else {

  }
#line 3244
  if ((unsigned int )adapter->virtfn == 0U) {
    {
#line 3245
    status = be_cmd_get_active_profile(adapter, & profile_id);
    }
#line 3246
    if (status == 0) {
      {
#line 3247
      _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Using profile 0x%x\n",
                (int )profile_id);
      }
    } else {

    }
  } else {

  }
  {
#line 3251
  status = be_get_resources(adapter);
  }
#line 3252
  if (status != 0) {
#line 3253
    return (status);
  } else {

  }
  {
#line 3256
  tmp = kcalloc((size_t )((int )adapter->res.max_uc_mac + 1), 4UL, 208U);
#line 3256
  adapter->pmac_id = (u32 *)tmp;
  }
#line 3258
  if ((unsigned long )adapter->pmac_id == (unsigned long )((u32 *)0U)) {
#line 3259
    return (-12);
  } else {

  }
  {
#line 3262
  _min1 = adapter->cfg_num_qs;
#line 3262
  tmp___0 = be_max_qs(adapter);
#line 3262
  _min2 = tmp___0;
#line 3262
  adapter->cfg_num_qs = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
  }
#line 3264
  return (0);
}
}
#line 3267 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_mac_setup(struct be_adapter *adapter ) 
{ 
  u8 mac[6U] ;
  int status ;
  bool tmp ;

  {
  {
#line 3272
  tmp = is_zero_ether_addr((u8 const   *)(adapter->netdev)->dev_addr);
  }
#line 3272
  if ((int )tmp) {
    {
#line 3273
    status = be_cmd_get_perm_mac(adapter, (u8 *)(& mac));
    }
#line 3274
    if (status != 0) {
#line 3275
      return (status);
    } else {

    }
    {
#line 3277
    memcpy((void *)(adapter->netdev)->dev_addr, (void const   *)(& mac), 6UL);
#line 3278
    memcpy((void *)(& (adapter->netdev)->perm_addr), (void const   *)(& mac), 6UL);
    }
  } else {
    {
#line 3281
    memcpy((void *)(& mac), (void const   *)(adapter->netdev)->dev_addr, 6UL);
    }
  }
#line 3285
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) || (unsigned int )adapter->virtfn == 0U) {
    {
#line 3286
    be_cmd_pmac_add(adapter, (u8 *)(& mac), (u32 )adapter->if_handle, adapter->pmac_id,
                    0U);
    }
  } else {

  }
#line 3288
  return (0);
}
}
#line 3291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_schedule_worker(struct be_adapter *adapter ) 
{ 
  unsigned long tmp ;

  {
  {
#line 3293
  tmp = msecs_to_jiffies(1000U);
#line 3293
  schedule_delayed_work(& adapter->work, tmp);
#line 3294
  adapter->flags = adapter->flags | 8U;
  }
#line 3295
  return;
}
}
#line 3297 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_setup_queues(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;

  {
  {
#line 3299
  netdev = adapter->netdev;
#line 3302
  status = be_evt_queues_create(adapter);
  }
#line 3303
  if (status != 0) {
#line 3304
    goto err;
  } else {

  }
  {
#line 3306
  status = be_tx_qs_create(adapter);
  }
#line 3307
  if (status != 0) {
#line 3308
    goto err;
  } else {

  }
  {
#line 3310
  status = be_rx_cqs_create(adapter);
  }
#line 3311
  if (status != 0) {
#line 3312
    goto err;
  } else {

  }
  {
#line 3314
  status = be_mcc_queues_create(adapter);
  }
#line 3315
  if (status != 0) {
#line 3316
    goto err;
  } else {

  }
  {
#line 3318
  status = netif_set_real_num_rx_queues(netdev, (unsigned int )adapter->num_rx_qs);
  }
#line 3319
  if (status != 0) {
#line 3320
    goto err;
  } else {

  }
  {
#line 3322
  status = netif_set_real_num_tx_queues(netdev, (unsigned int )adapter->num_tx_qs);
  }
#line 3323
  if (status != 0) {
#line 3324
    goto err;
  } else {

  }
#line 3326
  return (0);
  err: 
  {
#line 3328
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "queue_setup failed\n");
  }
#line 3329
  return (status);
}
}
#line 3332 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
int be_update_queues(struct be_adapter *adapter ) 
{ 
  struct net_device *netdev ;
  int status ;
  bool tmp ;
  bool tmp___0 ;

  {
  {
#line 3334
  netdev = adapter->netdev;
#line 3337
  tmp = netif_running((struct net_device  const  *)netdev);
  }
#line 3337
  if ((int )tmp) {
    {
#line 3338
    be_close(netdev);
    }
  } else {

  }
  {
#line 3340
  be_cancel_worker(adapter);
  }
#line 3345
  if (adapter->num_msix_roce_vec == 0U) {
    {
#line 3346
    be_msix_disable(adapter);
    }
  } else {

  }
  {
#line 3348
  be_clear_queues(adapter);
  }
#line 3350
  if ((unsigned int )adapter->num_msix_vec == 0U) {
    {
#line 3351
    status = be_msix_enable(adapter);
    }
#line 3352
    if (status != 0) {
#line 3353
      return (status);
    } else {

    }
  } else {

  }
  {
#line 3356
  status = be_setup_queues(adapter);
  }
#line 3357
  if (status != 0) {
#line 3358
    return (status);
  } else {

  }
  {
#line 3360
  be_schedule_worker(adapter);
#line 3362
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 3362
  if ((int )tmp___0) {
    {
#line 3363
    status = be_open(netdev);
    }
  } else {

  }
#line 3365
  return (status);
}
}
#line 3368 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_setup(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  u32 tx_fc ;
  u32 rx_fc ;
  u32 en_flags ;
  int status ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 3370
  dev = & (adapter->pdev)->dev;
#line 3374
  be_setup_init(adapter);
  }
#line 3376
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
    {
#line 3377
    be_cmd_req_native_mode(adapter);
    }
  } else {

  }
  {
#line 3379
  status = be_get_config(adapter);
  }
#line 3380
  if (status != 0) {
#line 3381
    goto err;
  } else {

  }
  {
#line 3383
  status = be_msix_enable(adapter);
  }
#line 3384
  if (status != 0) {
#line 3385
    goto err;
  } else {

  }
#line 3387
  en_flags = 6192U;
#line 3389
  if ((adapter->function_caps & 2U) != 0U) {
#line 3390
    en_flags = en_flags | 4U;
  } else {

  }
  {
#line 3391
  en_flags = en_flags & adapter->res.if_cap_flags;
#line 3392
  status = be_cmd_if_create(adapter, adapter->res.if_cap_flags, en_flags, (u32 *)(& adapter->if_handle),
                            0U);
  }
#line 3394
  if (status != 0) {
#line 3395
    goto err;
  } else {

  }
  {
#line 3398
  rtnl_lock();
#line 3399
  status = be_setup_queues(adapter);
#line 3400
  rtnl_unlock();
  }
#line 3401
  if (status != 0) {
#line 3402
    goto err;
  } else {

  }
  {
#line 3404
  be_cmd_get_fn_privileges(adapter, & adapter->cmd_privileges, 0U);
#line 3406
  status = be_mac_setup(adapter);
  }
#line 3407
  if (status != 0) {
#line 3408
    goto err;
  } else {

  }
  {
#line 3410
  be_cmd_get_fw_ver(adapter, (char *)(& adapter->fw_ver), (char *)(& adapter->fw_on_flash));
  }
#line 3412
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
    {
#line 3412
    tmp = fw_major_num((char const   *)(& adapter->fw_ver));
    }
#line 3412
    if (tmp <= 3) {
      {
#line 3413
      dev_err((struct device  const  *)dev, "Firmware on card is old(%s), IRQs may not work.",
              (char *)(& adapter->fw_ver));
#line 3415
      dev_err((struct device  const  *)dev, "Please upgrade firmware to version >= 4.0\n");
      }
    } else {

    }
  } else {

  }
#line 3418
  if ((unsigned int )adapter->vlans_added != 0U) {
    {
#line 3419
    be_vid_config(adapter);
    }
  } else {

  }
  {
#line 3421
  be_set_rx_mode(adapter->netdev);
#line 3423
  be_cmd_get_acpi_wol_cap(adapter);
#line 3425
  be_cmd_get_flow_control(adapter, & tx_fc, & rx_fc);
  }
#line 3427
  if (rx_fc != adapter->rx_fc || tx_fc != adapter->tx_fc) {
    {
#line 3428
    be_cmd_set_flow_control(adapter, adapter->tx_fc, adapter->rx_fc);
    }
  } else {

  }
#line 3431
  if ((unsigned int )adapter->virtfn == 0U) {
#line 3431
    if (num_vfs != 0U) {
#line 3431
      goto _L;
    } else {
      {
#line 3431
      tmp___0 = pci_num_vf(adapter->pdev);
      }
#line 3431
      if (tmp___0 != 0) {
        _L: /* CIL Label */ 
#line 3432
        if ((unsigned int )adapter->res.max_vfs != 0U) {
          {
#line 3433
          be_vf_setup(adapter);
          }
        } else {
          {
#line 3435
          dev_warn((struct device  const  *)dev, "device doesn\'t support SRIOV\n");
          }
        }
      } else {

      }
    }
  } else {

  }
  {
#line 3438
  status = be_cmd_get_phy_info(adapter);
  }
#line 3439
  if (status == 0) {
    {
#line 3439
    tmp___1 = be_pause_supported(adapter);
    }
#line 3439
    if ((int )tmp___1) {
#line 3440
      adapter->phy.fc_autoneg = 1U;
    } else {

    }
  } else {

  }
  {
#line 3442
  be_schedule_worker(adapter);
  }
#line 3443
  return (0);
  err: 
  {
#line 3445
  be_clear(adapter);
  }
#line 3446
  return (status);
}
}
#line 3450 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_netpoll(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_eq_obj *eqo ;
  int i ;

  {
  {
#line 3452
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 3452
  adapter = (struct be_adapter *)tmp;
#line 3456
  i = 0;
#line 3456
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
  }
#line 3456
  goto ldv_55157;
  ldv_55156: 
  {
#line 3457
  be_eq_notify(eqo->adapter, (int )eqo->q.id, 0, 1, 0);
#line 3458
  napi_schedule(& eqo->napi);
#line 3456
  i = i + 1;
#line 3456
  eqo = eqo + 1;
  }
  ldv_55157: ;
#line 3456
  if (i < (int )adapter->num_evt_qs) {
#line 3458
    goto ldv_55156;
  } else {

  }

#line 3461
  return;
}
}
#line 3466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static char flash_cookie[2U][16U]  = { {        '*',        '*',        '*',        ' ', 
            'S',        'E',        ' ',        'F', 
            'L',        'A',        'S',        '\000'}, 
   {        'H',        ' ',        'D',        'I', 
            'R',        'E',        'C',        'T', 
            'O',        'R',        'Y',        ' ', 
            '*',        '*',        '*',        ' '}};
#line 3468 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static bool be_flash_redboot(struct be_adapter *adapter , u8 const   *p , u32 img_start ,
                             int image_size , int hdr_size ) 
{ 
  u32 crc_offset ;
  u8 flashed_crc[4U] ;
  int status ;
  int tmp ;

  {
  {
#line 3476
  crc_offset = (((u32 )hdr_size + img_start) + (u32 )image_size) - 4U;
#line 3478
  p = p + (unsigned long )crc_offset;
#line 3480
  status = be_cmd_get_flash_crc(adapter, (u8 *)(& flashed_crc), image_size + -4);
  }
#line 3482
  if (status != 0) {
    {
#line 3483
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "could not get crc from flash, not flashing redboot\n");
    }
#line 3485
    return (0);
  } else {

  }
  {
#line 3489
  tmp = memcmp((void const   *)(& flashed_crc), (void const   *)p, 4UL);
  }
#line 3489
  if (tmp == 0) {
#line 3490
    return (0);
  } else {
#line 3492
    return (1);
  }
}
}
#line 3495 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static bool phy_flashing_required(struct be_adapter *adapter ) 
{ 


  {
#line 3497
  return (*((unsigned int *)adapter + 335706UL) == 393229U);
}
}
#line 3501 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static bool is_comp_in_ufi(struct be_adapter *adapter , struct flash_section_info *fsec ,
                           int type ) 
{ 
  int i ;
  int img_type ;
  struct flash_section_info_g2 *fsec_g2 ;

  {
#line 3504
  i = 0;
#line 3504
  img_type = 0;
#line 3505
  fsec_g2 = (struct flash_section_info_g2 *)0;
#line 3507
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 3508
    fsec_g2 = (struct flash_section_info_g2 *)fsec;
  } else {

  }
#line 3510
  i = 0;
#line 3510
  goto ldv_55182;
  ldv_55181: ;
#line 3511
  if ((unsigned long )fsec_g2 != (unsigned long )((struct flash_section_info_g2 *)0)) {
#line 3512
    img_type = (int )fsec_g2->fsec_entry[i].type;
  } else {
#line 3514
    img_type = (int )fsec->fsec_entry[i].type;
  }
#line 3516
  if (img_type == type) {
#line 3517
    return (1);
  } else {

  }
#line 3510
  i = i + 1;
  ldv_55182: ;
#line 3510
  if (i <= 31) {
#line 3512
    goto ldv_55181;
  } else {

  }

#line 3519
  return (0);
}
}
#line 3523 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct flash_section_info *get_fsec_info(struct be_adapter *adapter , int header_size ,
                                                struct firmware  const  *fw ) 
{ 
  struct flash_section_info *fsec ;
  u8 const   *p ;
  int tmp ;

  {
#line 3527
  fsec = (struct flash_section_info *)0;
#line 3528
  p = fw->data;
#line 3530
  p = p + (unsigned long )header_size;
#line 3531
  goto ldv_55192;
  ldv_55191: 
  {
#line 3532
  fsec = (struct flash_section_info *)p;
#line 3533
  tmp = memcmp((void const   *)(& flash_cookie), (void const   *)(& fsec->cookie),
               32UL);
  }
#line 3533
  if (tmp == 0) {
#line 3534
    return (fsec);
  } else {

  }
#line 3535
  p = p + 32UL;
  ldv_55192: ;
#line 3531
  if ((unsigned long )p < (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 3533
    goto ldv_55191;
  } else {

  }

#line 3537
  return ((struct flash_section_info *)0);
}
}
#line 3540 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_flash(struct be_adapter *adapter , u8 const   *img , struct be_dma_mem *flash_cmd ,
                    int optype , int img_size ) 
{ 
  u32 total_bytes ;
  u32 flash_op ;
  u32 num_bytes ;
  int status ;
  struct be_cmd_write_flashrom *req ;
  u32 __min1 ;
  u32 __min2 ;

  {
#line 3543
  total_bytes = 0U;
#line 3543
  num_bytes = 0U;
#line 3544
  status = 0;
#line 3545
  req = (struct be_cmd_write_flashrom *)flash_cmd->va;
#line 3547
  total_bytes = (u32 )img_size;
#line 3548
  goto ldv_55211;
  ldv_55210: 
#line 3549
  __min1 = 32768U;
#line 3549
  __min2 = total_bytes;
#line 3549
  num_bytes = __min1 < __min2 ? __min1 : __min2;
#line 3551
  total_bytes = total_bytes - num_bytes;
#line 3553
  if (total_bytes == 0U) {
#line 3554
    if (optype == 99) {
#line 3555
      flash_op = 9U;
    } else {
#line 3557
      flash_op = 1U;
    }
  } else
#line 3559
  if (optype == 99) {
#line 3560
    flash_op = 10U;
  } else {
#line 3562
    flash_op = 2U;
  }
  {
#line 3565
  memcpy((void *)(& req->data_buf), (void const   *)img, (size_t )num_bytes);
#line 3566
  img = img + (unsigned long )num_bytes;
#line 3567
  status = be_cmd_write_flashrom(adapter, flash_cmd, (u32 )optype, flash_op, num_bytes);
  }
#line 3569
  if (status != 0) {
#line 3570
    if (status == 2 && optype == 99) {
#line 3572
      goto ldv_55209;
    } else {

    }
    {
#line 3573
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "cmd to write to flash rom failed.\n");
    }
#line 3575
    return (status);
  } else {

  }
  ldv_55211: ;
#line 3548
  if (total_bytes != 0U) {
#line 3550
    goto ldv_55210;
  } else {

  }
  ldv_55209: ;
#line 3578
  return (0);
}
}
#line 3582 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_flash_BEx(struct be_adapter *adapter , struct firmware  const  *fw ,
                        struct be_dma_mem *flash_cmd , int num_of_images ) 
{ 
  int status ;
  int i ;
  int filehdr_size ;
  int img_hdrs_size ;
  u8 const   *p ;
  struct flash_comp  const  *pflashcomp ;
  int num_comp ;
  int redboot ;
  struct flash_section_info *fsec ;
  struct flash_comp gen3_flash_types[10U] ;
  struct flash_comp gen2_flash_types[8U] ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;

  {
#line 3588
  status = 0;
#line 3588
  filehdr_size = 0;
#line 3589
  img_hdrs_size = (int )((unsigned int )num_of_images * 48U);
#line 3590
  p = fw->data;
#line 3593
  fsec = (struct flash_section_info *)0;
#line 3595
  gen3_flash_types[0].offset = 2097152UL;
#line 3595
  gen3_flash_types[0].optype = 0;
#line 3595
  gen3_flash_types[0].size = 2097152;
#line 3595
  gen3_flash_types[0].img_type = 160;
#line 3595
  gen3_flash_types[1].offset = 262144UL;
#line 3595
  gen3_flash_types[1].optype = 1;
#line 3595
  gen3_flash_types[1].size = 1048576;
#line 3595
  gen3_flash_types[1].img_type = 224;
#line 3595
  gen3_flash_types[2].offset = 12582912UL;
#line 3595
  gen3_flash_types[2].optype = 2;
#line 3595
  gen3_flash_types[2].size = 524288;
#line 3595
  gen3_flash_types[2].img_type = 34;
#line 3595
  gen3_flash_types[3].offset = 13107200UL;
#line 3595
  gen3_flash_types[3].optype = 3;
#line 3595
  gen3_flash_types[3].size = 524288;
#line 3595
  gen3_flash_types[3].img_type = 32;
#line 3595
  gen3_flash_types[4].offset = 13631488UL;
#line 3595
  gen3_flash_types[4].optype = 8;
#line 3595
  gen3_flash_types[4].size = 524288;
#line 3595
  gen3_flash_types[4].img_type = 33;
#line 3595
  gen3_flash_types[5].offset = 4194304UL;
#line 3595
  gen3_flash_types[5].optype = 9;
#line 3595
  gen3_flash_types[5].size = 2097152;
#line 3595
  gen3_flash_types[5].img_type = 176;
#line 3595
  gen3_flash_types[6].offset = 6291456UL;
#line 3595
  gen3_flash_types[6].optype = 10;
#line 3595
  gen3_flash_types[6].size = 2097152;
#line 3595
  gen3_flash_types[6].img_type = 162;
#line 3595
  gen3_flash_types[7].offset = 8388608UL;
#line 3595
  gen3_flash_types[7].optype = 11;
#line 3595
  gen3_flash_types[7].size = 2097152;
#line 3595
  gen3_flash_types[7].img_type = 178;
#line 3595
  gen3_flash_types[8].offset = 15990784UL;
#line 3595
  gen3_flash_types[8].optype = 13;
#line 3595
  gen3_flash_types[8].size = 262144;
#line 3595
  gen3_flash_types[8].img_type = 16;
#line 3595
  gen3_flash_types[9].offset = 1310720UL;
#line 3595
  gen3_flash_types[9].optype = 99;
#line 3595
  gen3_flash_types[9].size = 262144;
#line 3595
  gen3_flash_types[9].img_type = 192;
#line 3618
  gen2_flash_types[0].offset = 1048576UL;
#line 3618
  gen2_flash_types[0].optype = 0;
#line 3618
  gen2_flash_types[0].size = 1310720;
#line 3618
  gen2_flash_types[0].img_type = 160;
#line 3618
  gen2_flash_types[1].offset = 0UL;
#line 3618
  gen2_flash_types[1].optype = 1;
#line 3618
  gen2_flash_types[1].size = 262144;
#line 3618
  gen2_flash_types[1].img_type = 224;
#line 3618
  gen2_flash_types[2].offset = 7340032UL;
#line 3618
  gen2_flash_types[2].optype = 2;
#line 3618
  gen2_flash_types[2].size = 262144;
#line 3618
  gen2_flash_types[2].img_type = 34;
#line 3618
  gen2_flash_types[3].offset = 7864320UL;
#line 3618
  gen2_flash_types[3].optype = 3;
#line 3618
  gen2_flash_types[3].size = 262144;
#line 3618
  gen2_flash_types[3].img_type = 32;
#line 3618
  gen2_flash_types[4].offset = 524288UL;
#line 3618
  gen2_flash_types[4].optype = 8;
#line 3618
  gen2_flash_types[4].size = 262144;
#line 3618
  gen2_flash_types[4].img_type = 33;
#line 3618
  gen2_flash_types[5].offset = 2359296UL;
#line 3618
  gen2_flash_types[5].optype = 9;
#line 3618
  gen2_flash_types[5].size = 1310720;
#line 3618
  gen2_flash_types[5].img_type = 176;
#line 3618
  gen2_flash_types[6].offset = 3670016UL;
#line 3618
  gen2_flash_types[6].optype = 10;
#line 3618
  gen2_flash_types[6].size = 1310720;
#line 3618
  gen2_flash_types[6].img_type = 162;
#line 3618
  gen2_flash_types[7].offset = 4980736UL;
#line 3618
  gen2_flash_types[7].optype = 11;
#line 3618
  gen2_flash_types[7].size = 1310720;
#line 3618
  gen2_flash_types[7].img_type = 178;
#line 3637
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 3638
    pflashcomp = (struct flash_comp  const  *)(& gen3_flash_types);
#line 3639
    filehdr_size = 128;
#line 3640
    num_comp = 10;
  } else {
#line 3642
    pflashcomp = (struct flash_comp  const  *)(& gen2_flash_types);
#line 3643
    filehdr_size = 96;
#line 3644
    num_comp = 8;
  }
  {
#line 3648
  fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
  }
#line 3649
  if ((unsigned long )fsec == (unsigned long )((struct flash_section_info *)0)) {
    {
#line 3650
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Invalid Cookie. UFI corrupted ?\n");
    }
#line 3652
    return (-1);
  } else {

  }
#line 3654
  i = 0;
#line 3654
  goto ldv_55235;
  ldv_55234: 
  {
#line 3655
  tmp = is_comp_in_ufi(adapter, fsec, (pflashcomp + (unsigned long )i)->img_type);
  }
#line 3655
  if (tmp) {
#line 3655
    tmp___0 = 0;
  } else {
#line 3655
    tmp___0 = 1;
  }
#line 3655
  if (tmp___0) {
#line 3656
    goto ldv_55233;
  } else {

  }
#line 3658
  if ((int )(pflashcomp + (unsigned long )i)->optype == 13) {
    {
#line 3658
    tmp___1 = memcmp((void const   *)(& adapter->fw_ver), (void const   *)"3.102.148.0",
                     11UL);
    }
#line 3658
    if (tmp___1 < 0) {
#line 3660
      goto ldv_55233;
    } else {

    }
  } else {

  }
#line 3662
  if ((int )(pflashcomp + (unsigned long )i)->optype == 99) {
    {
#line 3662
    tmp___2 = phy_flashing_required(adapter);
    }
#line 3662
    if (tmp___2) {
#line 3662
      tmp___3 = 0;
    } else {
#line 3662
      tmp___3 = 1;
    }
#line 3662
    if (tmp___3) {
#line 3664
      goto ldv_55233;
    } else {

    }
  } else {

  }
#line 3666
  if ((int )(pflashcomp + (unsigned long )i)->optype == 1) {
    {
#line 3667
    tmp___4 = be_flash_redboot(adapter, fw->data, (u32 )(pflashcomp + (unsigned long )i)->offset,
                               (pflashcomp + (unsigned long )i)->size, filehdr_size + img_hdrs_size);
#line 3667
    redboot = (int )tmp___4;
    }
#line 3670
    if (redboot == 0) {
#line 3671
      goto ldv_55233;
    } else {

    }
  } else {

  }
#line 3674
  p = fw->data;
#line 3675
  p = p + (((unsigned long )filehdr_size + (unsigned long )(pflashcomp + (unsigned long )i)->offset) + (unsigned long )img_hdrs_size);
#line 3676
  if ((unsigned long )(p + (unsigned long )(pflashcomp + (unsigned long )i)->size) > (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 3677
    return (-1);
  } else {

  }
  {
#line 3679
  status = be_flash(adapter, p, flash_cmd, (pflashcomp + (unsigned long )i)->optype,
                    (pflashcomp + (unsigned long )i)->size);
  }
#line 3681
  if (status != 0) {
    {
#line 3682
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Flashing section type %d failed.\n",
            (pflashcomp + (unsigned long )i)->img_type);
    }
#line 3685
    return (status);
  } else {

  }
  ldv_55233: 
#line 3654
  i = i + 1;
  ldv_55235: ;
#line 3654
  if (i < num_comp) {
#line 3656
    goto ldv_55234;
  } else {

  }

#line 3688
  return (0);
}
}
#line 3691 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_flash_skyhawk(struct be_adapter *adapter , struct firmware  const  *fw ,
                            struct be_dma_mem *flash_cmd , int num_of_images ) 
{ 
  int status ;
  int i ;
  int filehdr_size ;
  int img_offset ;
  int img_size ;
  int img_optype ;
  int redboot ;
  int img_hdrs_size ;
  u8 const   *p ;
  struct flash_section_info *fsec ;
  bool tmp ;

  {
  {
#line 3695
  status = 0;
#line 3695
  filehdr_size = 0;
#line 3697
  img_hdrs_size = (int )((unsigned int )num_of_images * 48U);
#line 3698
  p = fw->data;
#line 3699
  fsec = (struct flash_section_info *)0;
#line 3701
  filehdr_size = 128;
#line 3702
  fsec = get_fsec_info(adapter, filehdr_size + img_hdrs_size, fw);
  }
#line 3703
  if ((unsigned long )fsec == (unsigned long )((struct flash_section_info *)0)) {
    {
#line 3704
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Invalid Cookie. UFI corrupted ?\n");
    }
#line 3706
    return (-1);
  } else {

  }
#line 3709
  i = 0;
#line 3709
  goto ldv_55264;
  ldv_55263: 
#line 3710
  img_offset = (int )fsec->fsec_entry[i].offset;
#line 3711
  img_size = (int )fsec->fsec_entry[i].pad_size;
  {
#line 3714
  if (fsec->fsec_entry[i].type == 160U) {
#line 3714
    goto case_160;
  } else {

  }
#line 3717
  if (fsec->fsec_entry[i].type == 224U) {
#line 3717
    goto case_224;
  } else {

  }
#line 3720
  if (fsec->fsec_entry[i].type == 34U) {
#line 3720
    goto case_34;
  } else {

  }
#line 3723
  if (fsec->fsec_entry[i].type == 32U) {
#line 3723
    goto case_32;
  } else {

  }
#line 3726
  if (fsec->fsec_entry[i].type == 33U) {
#line 3726
    goto case_33;
  } else {

  }
#line 3729
  if (fsec->fsec_entry[i].type == 176U) {
#line 3729
    goto case_176;
  } else {

  }
#line 3732
  if (fsec->fsec_entry[i].type == 16U) {
#line 3732
    goto case_16;
  } else {

  }
#line 3735
  goto switch_default;
  case_160: /* CIL Label */ 
#line 3715
  img_optype = 0;
#line 3716
  goto ldv_55254;
  case_224: /* CIL Label */ 
#line 3718
  img_optype = 1;
#line 3719
  goto ldv_55254;
  case_34: /* CIL Label */ 
#line 3721
  img_optype = 2;
#line 3722
  goto ldv_55254;
  case_32: /* CIL Label */ 
#line 3724
  img_optype = 3;
#line 3725
  goto ldv_55254;
  case_33: /* CIL Label */ 
#line 3727
  img_optype = 8;
#line 3728
  goto ldv_55254;
  case_176: /* CIL Label */ 
#line 3730
  img_optype = 9;
#line 3731
  goto ldv_55254;
  case_16: /* CIL Label */ 
#line 3733
  img_optype = 13;
#line 3734
  goto ldv_55254;
  switch_default: /* CIL Label */ ;
#line 3736
  goto ldv_55262;
  switch_break: /* CIL Label */ ;
  }
  ldv_55254: ;
#line 3739
  if (img_optype == 1) {
    {
#line 3740
    tmp = be_flash_redboot(adapter, fw->data, (u32 )img_offset, img_size, filehdr_size + img_hdrs_size);
#line 3740
    redboot = (int )tmp;
    }
#line 3743
    if (redboot == 0) {
#line 3744
      goto ldv_55262;
    } else {

    }
  } else {

  }
#line 3747
  p = fw->data;
#line 3748
  p = p + (unsigned long )((filehdr_size + img_offset) + img_hdrs_size);
#line 3749
  if ((unsigned long )(p + (unsigned long )img_size) > (unsigned long )((unsigned char const   *)(fw->data + fw->size))) {
#line 3750
    return (-1);
  } else {

  }
  {
#line 3752
  status = be_flash(adapter, p, flash_cmd, img_optype, img_size);
  }
#line 3753
  if (status != 0) {
    {
#line 3754
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Flashing section type %d failed.\n",
            fsec->fsec_entry[i].type);
    }
#line 3757
    return (status);
  } else {

  }
  ldv_55262: 
#line 3709
  i = i + 1;
  ldv_55264: ;
#line 3709
  if ((u32 )i < fsec->fsec_hdr.num_images) {
#line 3711
    goto ldv_55263;
  } else {

  }

#line 3760
  return (0);
}
}
#line 3763 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int lancer_fw_download(struct be_adapter *adapter , struct firmware  const  *fw ) 
{ 
  struct be_dma_mem flash_cmd ;
  u8 const   *data_ptr ;
  u8 *dest_image_ptr ;
  size_t image_size ;
  u32 chunk_size ;
  u32 data_written ;
  u32 offset ;
  int status ;
  u8 add_status ;
  u8 change_status ;
  u32 __min1 ;
  u32 __min2 ;

  {
#line 3769
  data_ptr = (u8 const   *)0U;
#line 3770
  dest_image_ptr = (u8 *)0U;
#line 3771
  image_size = 0UL;
#line 3772
  chunk_size = 0U;
#line 3773
  data_written = 0U;
#line 3774
  offset = 0U;
#line 3775
  status = 0;
#line 3776
  add_status = 0U;
#line 3779
  if (((unsigned long )fw->size & 3UL) != 0UL) {
    {
#line 3780
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW Image not properly aligned. Length must be 4 byte aligned.\n");
#line 3783
    status = -22;
    }
#line 3784
    goto lancer_fw_exit;
  } else {

  }
  {
#line 3787
  flash_cmd.size = 32912U;
#line 3789
  flash_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size,
                                 & flash_cmd.dma, 208U, (struct dma_attrs *)0);
  }
#line 3791
  if ((unsigned long )flash_cmd.va == (unsigned long )((void *)0)) {
#line 3792
    status = -12;
#line 3793
    goto lancer_fw_exit;
  } else {

  }
#line 3796
  dest_image_ptr = (u8 *)flash_cmd.va + 144U;
#line 3798
  image_size = fw->size;
#line 3799
  data_ptr = fw->data;
#line 3801
  goto ldv_55286;
  ldv_55285: 
  {
#line 3802
  __min1 = (u32 )image_size;
#line 3802
  __min2 = 32768U;
#line 3802
  chunk_size = __min1 < __min2 ? __min1 : __min2;
#line 3805
  memcpy((void *)dest_image_ptr, (void const   *)data_ptr, (size_t )chunk_size);
#line 3807
  status = lancer_cmd_write_object(adapter, & flash_cmd, chunk_size, offset, "/prg",
                                   & data_written, & change_status, & add_status);
  }
#line 3812
  if (status != 0) {
#line 3813
    goto ldv_55284;
  } else {

  }
#line 3815
  offset = offset + data_written;
#line 3816
  data_ptr = data_ptr + (unsigned long )data_written;
#line 3817
  image_size = image_size - (size_t )data_written;
  ldv_55286: ;
#line 3801
  if (image_size != 0UL) {
#line 3803
    goto ldv_55285;
  } else {

  }
  ldv_55284: ;
#line 3820
  if (status == 0) {
    {
#line 3822
    status = lancer_cmd_write_object(adapter, & flash_cmd, 0U, offset, "/prg", & data_written,
                                     & change_status, & add_status);
    }
  } else {

  }
  {
#line 3829
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size, flash_cmd.va, flash_cmd.dma,
                 (struct dma_attrs *)0);
  }
#line 3831
  if (status != 0) {
    {
#line 3832
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load error. Status code: 0x%x Additional Status: 0x%x\n",
            status, (int )add_status);
    }
#line 3836
    goto lancer_fw_exit;
  } else {

  }
#line 3839
  if ((unsigned int )change_status == 2U) {
    {
#line 3840
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Resetting adapter to activate new FW\n");
#line 3842
    status = lancer_physdev_ctrl(adapter, 2U);
    }
#line 3844
    if (status != 0) {
      {
#line 3845
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter busy for FW reset.\nNew FW will not be active.\n");
      }
#line 3848
      goto lancer_fw_exit;
    } else {

    }
  } else
#line 3850
  if ((unsigned int )change_status != 0U) {
    {
#line 3851
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "System reboot required for new FW to be active\n");
    }
  } else {

  }
  {
#line 3856
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Firmware flashed successfully\n");
  }
  lancer_fw_exit: ;
#line 3858
  return (status);
}
}
#line 3865 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_ufi_type(struct be_adapter *adapter , struct flash_file_hdr_g3 *fhdr ) 
{ 


  {
#line 3868
  if ((unsigned long )fhdr == (unsigned long )((struct flash_file_hdr_g3 *)0)) {
#line 3869
    goto be_get_ufi_exit;
  } else {

  }
#line 3871
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (unsigned int )fhdr->build[0] == 52U) {
#line 3872
    return (4);
  } else
#line 3873
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && (unsigned int )fhdr->build[0] == 51U) {
#line 3874
    if ((unsigned int )fhdr->asic_type_rev == 16U) {
#line 3875
      return (10);
    } else {
#line 3877
      return (3);
    }
  } else
#line 3878
  if (((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) && (unsigned int )fhdr->build[0] == 50U) {
#line 3879
    return (2);
  } else {

  }
  be_get_ufi_exit: 
  {
#line 3882
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "UFI and Interface are not compatible for flashing\n");
  }
#line 3884
  return (-1);
}
}
#line 3887 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_fw_download(struct be_adapter *adapter , struct firmware  const  *fw ) 
{ 
  struct flash_file_hdr_g3 *fhdr3 ;
  struct image_hdr *img_hdr_ptr ;
  struct be_dma_mem flash_cmd ;
  u8 const   *p ;
  int status ;
  int i ;
  int num_imgs ;
  int ufi_type ;

  {
  {
#line 3890
  img_hdr_ptr = (struct image_hdr *)0;
#line 3893
  status = 0;
#line 3893
  i = 0;
#line 3893
  num_imgs = 0;
#line 3893
  ufi_type = 0;
#line 3895
  flash_cmd.size = 32804U;
#line 3896
  flash_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size,
                                 & flash_cmd.dma, 208U, (struct dma_attrs *)0);
  }
#line 3898
  if ((unsigned long )flash_cmd.va == (unsigned long )((void *)0)) {
#line 3899
    status = -12;
#line 3900
    goto be_fw_exit;
  } else {

  }
  {
#line 3903
  p = fw->data;
#line 3904
  fhdr3 = (struct flash_file_hdr_g3 *)p;
#line 3906
  ufi_type = be_get_ufi_type(adapter, fhdr3);
#line 3908
  num_imgs = (int )fhdr3->num_imgs;
#line 3909
  i = 0;
  }
#line 3909
  goto ldv_55310;
  ldv_55309: 
#line 3910
  img_hdr_ptr = (struct image_hdr *)(fw->data + ((unsigned long )i * 48UL + 128UL));
#line 3913
  if (img_hdr_ptr->imageid == 1U) {
    {
#line 3915
    if (ufi_type == 4) {
#line 3915
      goto case_4;
    } else {

    }
#line 3919
    if (ufi_type == 10) {
#line 3919
      goto case_10;
    } else {

    }
#line 3923
    if (ufi_type == 3) {
#line 3923
      goto case_3;
    } else {

    }
#line 3914
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 3916
    status = be_flash_skyhawk(adapter, fw, & flash_cmd, num_imgs);
    }
#line 3918
    goto ldv_55306;
    case_10: /* CIL Label */ 
    {
#line 3920
    status = be_flash_BEx(adapter, fw, & flash_cmd, num_imgs);
    }
#line 3922
    goto ldv_55306;
    case_3: /* CIL Label */ ;
#line 3925
    if ((unsigned int )adapter->asic_rev <= 15U) {
      {
#line 3926
      status = be_flash_BEx(adapter, fw, & flash_cmd, num_imgs);
      }
    } else {
      {
#line 3930
      status = -1;
#line 3931
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Can\'t load BE3 UFI on BE3R\n");
      }
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_55306: ;
  } else {

  }
#line 3909
  i = i + 1;
  ldv_55310: ;
#line 3909
  if (i < num_imgs) {
#line 3911
    goto ldv_55309;
  } else {

  }

#line 3938
  if (ufi_type == 2) {
    {
#line 3939
    status = be_flash_BEx(adapter, fw, & flash_cmd, 0);
    }
  } else
#line 3940
  if (ufi_type == -1) {
#line 3941
    status = -1;
  } else {

  }
  {
#line 3943
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )flash_cmd.size, flash_cmd.va, flash_cmd.dma,
                 (struct dma_attrs *)0);
  }
#line 3945
  if (status != 0) {
    {
#line 3946
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load error\n");
    }
#line 3947
    goto be_fw_exit;
  } else {

  }
  {
#line 3950
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Firmware flashed successfully\n");
  }
  be_fw_exit: ;
#line 3953
  return (status);
}
}
#line 3956 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
int be_load_fw(struct be_adapter *adapter , u8 *fw_file ) 
{ 
  struct firmware  const  *fw ;
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 3961
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
  }
#line 3961
  if (tmp) {
#line 3961
    tmp___0 = 0;
  } else {
#line 3961
    tmp___0 = 1;
  }
#line 3961
  if (tmp___0) {
    {
#line 3962
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware load not allowed (interface is down)\n");
    }
#line 3964
    return (-1);
  } else {

  }
  {
#line 3967
  status = request_firmware(& fw, (char const   *)fw_file, & (adapter->pdev)->dev);
  }
#line 3968
  if (status != 0) {
#line 3969
    goto fw_exit;
  } else {

  }
  {
#line 3971
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Flashing firmware file %s\n",
            fw_file);
  }
#line 3973
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
    {
#line 3974
    status = lancer_fw_download(adapter, fw);
    }
  } else {
    {
#line 3976
    status = be_fw_download(adapter, fw);
    }
  }
#line 3978
  if (status == 0) {
    {
#line 3979
    be_cmd_get_fw_ver(adapter, (char *)(& adapter->fw_ver), (char *)(& adapter->fw_on_flash));
    }
  } else {

  }
  fw_exit: 
  {
#line 3983
  release_firmware(fw);
  }
#line 3984
  return (status);
}
}
#line 3987 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_ndo_bridge_setlink(struct net_device *dev , struct nlmsghdr *nlh ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct nlattr *attr ;
  struct nlattr *br_spec ;
  int rem ;
  int status ;
  u16 mode ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3990
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 3990
  adapter = (struct be_adapter *)tmp;
#line 3993
  status = 0;
#line 3994
  mode = 0U;
  }
#line 3996
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 3997
    return (-95);
  } else {

  }
  {
#line 3999
  br_spec = nlmsg_find_attr((struct nlmsghdr  const  *)nlh, 16, 26);
#line 4001
  tmp___0 = nla_data((struct nlattr  const  *)br_spec);
#line 4001
  attr = (struct nlattr *)tmp___0;
#line 4001
  rem = nla_len((struct nlattr  const  *)br_spec);
  }
#line 4001
  goto ldv_55332;
  ldv_55331: 
  {
#line 4002
  tmp___1 = nla_type((struct nlattr  const  *)attr);
  }
#line 4002
  if (tmp___1 != 1) {
#line 4003
    goto ldv_55329;
  } else {

  }
  {
#line 4005
  mode = nla_get_u16((struct nlattr  const  *)attr);
  }
#line 4006
  if ((unsigned int )mode > 1U) {
#line 4007
    return (-22);
  } else {

  }
  {
#line 4009
  status = be_cmd_set_hsw_config(adapter, 0, 0U, (int )((u16 )adapter->if_handle),
                                 (unsigned int )mode == 1U ? 3 : 2);
  }
#line 4014
  if (status != 0) {
#line 4015
    goto err;
  } else {

  }
  {
#line 4017
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "enabled switch mode: %s\n",
            (unsigned int )mode == 1U ? (char *)"VEPA" : (char *)"VEB");
  }
#line 4020
  return (status);
  ldv_55329: 
  {
#line 4001
  attr = nla_next((struct nlattr  const  *)attr, & rem);
  }
  ldv_55332: 
  {
#line 4001
  tmp___2 = nla_ok((struct nlattr  const  *)attr, rem);
  }
#line 4001
  if (tmp___2 != 0) {
#line 4003
    goto ldv_55331;
  } else {

  }

  err: 
  {
#line 4023
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Failed to set switch mode %s\n",
          (unsigned int )mode == 1U ? (char *)"VEPA" : (char *)"VEB");
  }
#line 4026
  return (status);
}
}
#line 4029 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_ndo_bridge_getlink(struct sk_buff *skb , u32 pid , u32 seq , struct net_device *dev ,
                                 u32 filter_mask ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  u8 hsw_mode ;
  int tmp___0 ;

  {
  {
#line 4033
  tmp = netdev_priv((struct net_device  const  *)dev);
#line 4033
  adapter = (struct be_adapter *)tmp;
#line 4034
  status = 0;
  }
#line 4037
  if ((unsigned int )adapter->num_vfs == 0U) {
#line 4038
    return (0);
  } else {

  }
#line 4041
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 4042
    hsw_mode = 2U;
  } else {
    {
#line 4044
    status = be_cmd_get_hsw_config(adapter, (u16 *)0U, 0U, (int )((u16 )adapter->if_handle),
                                   & hsw_mode);
    }
#line 4046
    if (status != 0) {
#line 4047
      return (0);
    } else {

    }
  }
  {
#line 4050
  tmp___0 = ndo_dflt_bridge_getlink(skb, pid, seq, dev, (unsigned int )hsw_mode == 3U);
  }
#line 4050
  return (tmp___0);
}
}
#line 4055 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct net_device_ops  const  be_netdev_ops  = 
#line 4055
     {0, 0, & be_open, & be_close, & be_xmit, 0, 0, & be_set_rx_mode, & be_mac_addr_set,
    & eth_validate_addr, 0, 0, & be_change_mtu, 0, 0, & be_get_stats64, 0, & be_vlan_add_vid,
    & be_vlan_rem_vid, & be_netpoll, 0, 0, & be_busy_poll, & be_set_vf_mac, & be_set_vf_vlan,
    & be_set_vf_tx_rate, 0, & be_get_vf_config, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, & be_ndo_bridge_setlink, & be_ndo_bridge_getlink, 0,
    0, 0, 0, 0, 0, 0, 0};
#line 4080 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_netdev_init(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;

  {
  {
#line 4082
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4082
  adapter = (struct be_adapter *)tmp;
#line 4084
  netdev->hw_features = netdev->hw_features | 4296081555ULL;
#line 4087
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
  }
#line 4087
  if ((int )tmp___0) {
#line 4088
    netdev->hw_features = netdev->hw_features | 2147483648ULL;
  } else {

  }
  {
#line 4090
  netdev->features = (netdev->features | netdev->hw_features) | 768ULL;
#line 4093
  netdev->vlan_features = netdev->vlan_features | 1114131ULL;
#line 4096
  netdev->priv_flags = netdev->priv_flags | 131072U;
#line 4098
  netdev->flags = netdev->flags | 4096U;
#line 4100
  netif_set_gso_max_size(netdev, 65521U);
#line 4102
  netdev->netdev_ops = & be_netdev_ops;
#line 4104
  netdev->ethtool_ops = & be_ethtool_ops;
  }
#line 4105
  return;
}
}
#line 4107 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_unmap_pci_bars(struct be_adapter *adapter ) 
{ 


  {
#line 4109
  if ((unsigned long )adapter->csr != (unsigned long )((u8 *)0U)) {
    {
#line 4110
    pci_iounmap(adapter->pdev, (void *)adapter->csr);
    }
  } else {

  }
#line 4111
  if ((unsigned long )adapter->db != (unsigned long )((u8 *)0U)) {
    {
#line 4112
    pci_iounmap(adapter->pdev, (void *)adapter->db);
    }
  } else {

  }
#line 4113
  return;
}
}
#line 4115 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int db_bar(struct be_adapter *adapter ) 
{ 


  {
#line 4117
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || (unsigned int )adapter->virtfn != 0U) {
#line 4118
    return (0);
  } else {
#line 4120
    return (4);
  }
}
}
#line 4123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_roce_map_pci_bars(struct be_adapter *adapter ) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 4125
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
    {
#line 4126
    adapter->roce_db.size = 4096U;
#line 4127
    tmp = db_bar(adapter);
#line 4127
    adapter->roce_db.io_addr = (adapter->pdev)->resource[tmp].start;
#line 4129
    tmp___5 = db_bar(adapter);
    }
#line 4129
    if ((adapter->pdev)->resource[tmp___5].start != 0ULL) {
      {
#line 4129
      tmp___3 = db_bar(adapter);
#line 4129
      tmp___4 = db_bar(adapter);
#line 4129
      adapter->roce_db.total_size = ((u32 )(adapter->pdev)->resource[tmp___3].end - (u32 )(adapter->pdev)->resource[tmp___4].start) + 1U;
      }
    } else {
      {
#line 4129
      tmp___6 = db_bar(adapter);
#line 4129
      tmp___7 = db_bar(adapter);
      }
#line 4129
      if ((adapter->pdev)->resource[tmp___6].end != (adapter->pdev)->resource[tmp___7].start) {
        {
#line 4129
        tmp___3 = db_bar(adapter);
#line 4129
        tmp___4 = db_bar(adapter);
#line 4129
        adapter->roce_db.total_size = ((u32 )(adapter->pdev)->resource[tmp___3].end - (u32 )(adapter->pdev)->resource[tmp___4].start) + 1U;
        }
      } else {
#line 4129
        adapter->roce_db.total_size = 0U;
      }
    }
  } else {

  }
#line 4132
  return (0);
}
}
#line 4135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_map_pci_bars(struct be_adapter *adapter ) 
{ 
  u8 *addr ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 4139
  if ((((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) && (unsigned int )adapter->virtfn == 0U) {
    {
#line 4140
    tmp = pci_iomap(adapter->pdev, 2, 0UL);
#line 4140
    adapter->csr = (u8 *)tmp;
    }
#line 4141
    if ((unsigned long )adapter->csr == (unsigned long )((u8 *)0U)) {
#line 4142
      return (-12);
    } else {

    }
  } else {

  }
  {
#line 4145
  tmp___0 = db_bar(adapter);
#line 4145
  tmp___1 = pci_iomap(adapter->pdev, tmp___0, 0UL);
#line 4145
  addr = (u8 *)tmp___1;
  }
#line 4146
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 4147
    goto pci_map_err;
  } else {

  }
  {
#line 4148
  adapter->db = addr;
#line 4150
  be_roce_map_pci_bars(adapter);
  }
#line 4151
  return (0);
  pci_map_err: 
  {
#line 4154
  be_unmap_pci_bars(adapter);
  }
#line 4155
  return (-12);
}
}
#line 4158 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_ctrl_cleanup(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mem ;

  {
  {
#line 4160
  mem = & adapter->mbox_mem_alloced;
#line 4162
  be_unmap_pci_bars(adapter);
  }
#line 4164
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
    {
#line 4165
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   (struct dma_attrs *)0);
    }
  } else {

  }
#line 4168
  mem = & adapter->rx_filter;
#line 4169
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
    {
#line 4170
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )mem->size, mem->va, mem->dma,
                   (struct dma_attrs *)0);
    }
  } else {

  }
#line 4171
  return;
}
}
#line 4174 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_ctrl_init(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mbox_mem_alloc ;
  struct be_dma_mem *mbox_mem_align ;
  struct be_dma_mem *rx_filter ;
  u32 sli_intf ;
  int status ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
  {
#line 4176
  mbox_mem_alloc = & adapter->mbox_mem_alloced;
#line 4177
  mbox_mem_align = & adapter->mbox_mem;
#line 4178
  rx_filter = & adapter->rx_filter;
#line 4182
  pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 88, & sli_intf);
#line 4183
  adapter->sli_family = (sli_intf & 3840U) >> 8;
#line 4185
  adapter->virtfn = (unsigned int )((u8 )sli_intf) & 1U;
#line 4187
  status = be_map_pci_bars(adapter);
  }
#line 4188
  if (status != 0) {
#line 4189
    goto done;
  } else {

  }
  {
#line 4191
  mbox_mem_alloc->size = 288U;
#line 4192
  mbox_mem_alloc->va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )mbox_mem_alloc->size,
                                       & mbox_mem_alloc->dma, 208U, (struct dma_attrs *)0);
  }
#line 4196
  if ((unsigned long )mbox_mem_alloc->va == (unsigned long )((void *)0)) {
#line 4197
    status = -12;
#line 4198
    goto unmap_pci_bars;
  } else {

  }
  {
#line 4200
  mbox_mem_align->size = 272U;
#line 4201
  mbox_mem_align->va = (void *)(((unsigned long )mbox_mem_alloc->va + 15UL) & 0xfffffffffffffff0UL);
#line 4202
  mbox_mem_align->dma = (unsigned long long )((unsigned long )mbox_mem_alloc->dma + 15UL) & 0xfffffffffffffff0ULL;
#line 4203
  memset(mbox_mem_align->va, 0, 272UL);
#line 4205
  rx_filter->size = 424U;
#line 4206
  rx_filter->va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )rx_filter->size,
                                      & rx_filter->dma, 208U);
  }
#line 4209
  if ((unsigned long )rx_filter->va == (unsigned long )((void *)0)) {
#line 4210
    status = -12;
#line 4211
    goto free_mbox;
  } else {

  }
  {
#line 4214
  __mutex_init(& adapter->mbox_lock, "&adapter->mbox_lock", & __key);
#line 4215
  spinlock_check(& adapter->mcc_lock);
#line 4215
  __raw_spin_lock_init(& adapter->mcc_lock.__annonCompField19.rlock, "&(&adapter->mcc_lock)->rlock",
                       & __key___0);
#line 4216
  spinlock_check(& adapter->mcc_cq_lock);
#line 4216
  __raw_spin_lock_init(& adapter->mcc_cq_lock.__annonCompField19.rlock, "&(&adapter->mcc_cq_lock)->rlock",
                       & __key___1);
#line 4218
  init_completion(& adapter->et_cmd_compl);
#line 4219
  pci_save_state(adapter->pdev);
  }
#line 4220
  return (0);
  free_mbox: 
  {
#line 4223
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )mbox_mem_alloc->size, mbox_mem_alloc->va,
                 mbox_mem_alloc->dma, (struct dma_attrs *)0);
  }
  unmap_pci_bars: 
  {
#line 4227
  be_unmap_pci_bars(adapter);
  }
  done: ;
#line 4230
  return (status);
}
}
#line 4233 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_stats_cleanup(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *cmd ;

  {
#line 4235
  cmd = & adapter->stats_cmd;
#line 4237
  if ((unsigned long )cmd->va != (unsigned long )((void *)0)) {
    {
#line 4238
    dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd->size, cmd->va, cmd->dma,
                   (struct dma_attrs *)0);
    }
  } else {

  }
#line 4239
  return;
}
}
#line 4242 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_stats_init(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *cmd ;

  {
#line 4244
  cmd = & adapter->stats_cmd;
#line 4246
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 4247
    cmd->size = 672U;
  } else
#line 4248
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 4249
    cmd->size = 1076U;
  } else
#line 4250
  if ((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) {
#line 4251
    cmd->size = 1864U;
  } else {
#line 4254
    cmd->size = 2696U;
  }
  {
#line 4256
  cmd->va = dma_zalloc_coherent(& (adapter->pdev)->dev, (size_t )cmd->size, & cmd->dma,
                                208U);
  }
#line 4258
  if ((unsigned long )cmd->va == (unsigned long )((void *)0)) {
#line 4259
    return (-1);
  } else {

  }
#line 4260
  return (0);
}
}
#line 4263 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_remove(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 4265
  tmp = pci_get_drvdata(pdev);
#line 4265
  adapter = (struct be_adapter *)tmp;
  }
#line 4267
  if ((unsigned long )adapter == (unsigned long )((struct be_adapter *)0)) {
#line 4268
    return;
  } else {

  }
  {
#line 4270
  be_roce_dev_remove(adapter);
#line 4271
  be_intr_set(adapter, 0);
#line 4273
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4275
  ldv_unregister_netdev_23(adapter->netdev);
#line 4277
  be_clear(adapter);
#line 4280
  be_cmd_fw_clean(adapter);
#line 4282
  be_stats_cleanup(adapter);
#line 4284
  be_ctrl_cleanup(adapter);
#line 4286
  pci_disable_pcie_error_reporting(pdev);
#line 4288
  pci_release_regions(pdev);
#line 4289
  pci_disable_device(pdev);
#line 4291
  ldv_free_netdev_24(adapter->netdev);
  }
#line 4292
  return;
}
}
#line 4294 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_get_initial_config(struct be_adapter *adapter ) 
{ 
  int status ;
  int level ;
  int tmp ;

  {
  {
#line 4298
  status = be_cmd_get_cntl_attributes(adapter);
  }
#line 4299
  if (status != 0) {
#line 4300
    return (status);
  } else {

  }
#line 4303
  adapter->be_get_temp_freq = 64;
#line 4305
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 4306
    level = be_cmd_get_fw_log_level(adapter);
#line 4307
    adapter->msg_enable = level <= 48 ? 8192U : 0U;
    }
  } else {

  }
  {
#line 4311
  tmp = netif_get_num_default_rss_queues();
#line 4311
  adapter->cfg_num_qs = (u16 )tmp;
  }
#line 4312
  return (0);
}
}
#line 4315 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int lancer_recover_func(struct be_adapter *adapter ) 
{ 
  struct device *dev ;
  int status ;
  bool tmp ;
  bool tmp___0 ;

  {
  {
#line 4317
  dev = & (adapter->pdev)->dev;
#line 4320
  status = lancer_test_and_set_rdy_state(adapter);
  }
#line 4321
  if (status != 0) {
#line 4322
    goto err;
  } else {

  }
  {
#line 4324
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
  }
#line 4324
  if ((int )tmp) {
    {
#line 4325
    be_close(adapter->netdev);
    }
  } else {

  }
  {
#line 4327
  be_clear(adapter);
#line 4329
  be_clear_all_error(adapter);
#line 4331
  status = be_setup(adapter);
  }
#line 4332
  if (status != 0) {
#line 4333
    goto err;
  } else {

  }
  {
#line 4335
  tmp___0 = netif_running((struct net_device  const  *)adapter->netdev);
  }
#line 4335
  if ((int )tmp___0) {
    {
#line 4336
    status = be_open(adapter->netdev);
    }
#line 4337
    if (status != 0) {
#line 4338
      goto err;
    } else {

    }
  } else {

  }
  {
#line 4341
  dev_err((struct device  const  *)dev, "Adapter recovery successful\n");
  }
#line 4342
  return (0);
  err: ;
#line 4344
  if (status == -11) {
    {
#line 4345
    dev_err((struct device  const  *)dev, "Waiting for resource provisioning\n");
    }
  } else {
    {
#line 4347
    dev_err((struct device  const  *)dev, "Adapter recovery failed\n");
    }
  }
#line 4349
  return (status);
}
}
#line 4352 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_func_recovery_task(struct work_struct *work ) 
{ 
  struct be_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  int status ;
  unsigned long tmp ;

  {
  {
#line 4355
  __mptr = (struct work_struct  const  *)work;
#line 4355
  adapter = (struct be_adapter *)__mptr + 0xffffffffffeb84c0UL;
#line 4356
  status = 0;
#line 4358
  be_detect_error(adapter);
  }
#line 4360
  if ((int )adapter->hw_error && ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
    {
#line 4362
    rtnl_lock();
#line 4363
    netif_device_detach(adapter->netdev);
#line 4364
    rtnl_unlock();
#line 4366
    status = lancer_recover_func(adapter);
    }
#line 4367
    if (status == 0) {
      {
#line 4368
      netif_device_attach(adapter->netdev);
      }
    } else {

    }
  } else {

  }
#line 4374
  if (status == 0 || status == -11) {
    {
#line 4375
    tmp = msecs_to_jiffies(1000U);
#line 4375
    schedule_delayed_work(& adapter->func_recovery_work, tmp);
    }
  } else {

  }
#line 4377
  return;
}
}
#line 4379 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_worker(struct work_struct *work ) 
{ 
  struct be_adapter *adapter ;
  struct work_struct  const  *__mptr ;
  struct be_rx_obj *rxo ;
  int i ;
  bool tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 4382
  __mptr = (struct work_struct  const  *)work;
#line 4382
  adapter = (struct be_adapter *)__mptr + 0xffffffffffeb85a8UL;
#line 4388
  tmp = netif_running((struct net_device  const  *)adapter->netdev);
  }
#line 4388
  if (tmp) {
#line 4388
    tmp___0 = 0;
  } else {
#line 4388
    tmp___0 = 1;
  }
#line 4388
  if (tmp___0) {
    {
#line 4389
    local_bh_disable();
#line 4390
    be_process_mcc(adapter);
#line 4391
    local_bh_enable();
    }
#line 4392
    goto reschedule;
  } else {

  }
#line 4395
  if (! adapter->stats_cmd_sent) {
#line 4396
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
      {
#line 4397
      lancer_cmd_get_pport_stats(adapter, & adapter->stats_cmd);
      }
    } else {
      {
#line 4400
      be_cmd_get_stats(adapter, & adapter->stats_cmd);
      }
    }
  } else {

  }
#line 4403
  if ((unsigned int )adapter->virtfn == 0U) {
    {
#line 4403
    tmp___1 = MODULO((int )adapter->work_counter, (int )((u16 )adapter->be_get_temp_freq));
    }
#line 4403
    if (tmp___1 == 0U) {
      {
#line 4405
      be_cmd_get_die_temperature(adapter);
      }
    } else {

    }
  } else {

  }
#line 4407
  i = 0;
#line 4407
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 4407
  goto ldv_55421;
  ldv_55420: ;
#line 4411
  if ((int )rxo->rx_post_starved) {
    {
#line 4412
    be_post_rx_frags(rxo, 208U);
    }
  } else {

  }
#line 4407
  i = i + 1;
#line 4407
  rxo = rxo + 1;
  ldv_55421: ;
#line 4407
  if (i < (int )adapter->num_rx_qs) {
#line 4409
    goto ldv_55420;
  } else {

  }
  {
#line 4415
  be_eqd_update(adapter);
  }
  reschedule: 
  {
#line 4418
  adapter->work_counter = (u16 )((int )adapter->work_counter + 1);
#line 4419
  tmp___2 = msecs_to_jiffies(1000U);
#line 4419
  schedule_delayed_work(& adapter->work, tmp___2);
  }
#line 4420
  return;
}
}
#line 4423 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static bool be_reset_required(struct be_adapter *adapter ) 
{ 
  int tmp ;

  {
  {
#line 4425
  tmp = pci_num_vf(adapter->pdev);
  }
#line 4425
  return (tmp == 0);
}
}
#line 4428 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static char *mc_name(struct be_adapter *adapter ) 
{ 


  {
#line 4430
  if ((adapter->function_mode & 1024U) != 0U) {
#line 4431
    return ((char *)"FLEX10");
  } else
#line 4432
  if ((adapter->function_mode & 131072U) != 0U) {
#line 4433
    return ((char *)"vNIC");
  } else
#line 4434
  if ((adapter->function_mode & 16777216U) != 0U) {
#line 4435
    return ((char *)"UMC");
  } else {
#line 4437
    return ((char *)"");
  }
}
}
#line 4440 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
__inline static char *func_name(struct be_adapter *adapter ) 
{ 


  {
#line 4442
  return ((unsigned int )adapter->virtfn == 0U ? (char *)"PF" : (char *)"VF");
}
}
#line 4445 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_probe(struct pci_dev *pdev , struct pci_device_id  const  *pdev_id ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  struct net_device *netdev ;
  char port_name ;
  void *tmp ;
  bool tmp___0 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___2 ;
  u32 tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 4447
  status = 0;
#line 4452
  status = pci_enable_device(pdev);
  }
#line 4453
  if (status != 0) {
#line 4454
    goto do_none;
  } else {

  }
  {
#line 4456
  status = pci_request_regions(pdev, "be2net");
  }
#line 4457
  if (status != 0) {
#line 4458
    goto disable_dev;
  } else {

  }
  {
#line 4459
  pci_set_master(pdev);
#line 4461
  netdev = ldv_alloc_etherdev_mqs_25(1342912, 32U, 32U);
  }
#line 4462
  if ((unsigned long )netdev == (unsigned long )((struct net_device *)0)) {
#line 4463
    status = -12;
#line 4464
    goto rel_reg;
  } else {

  }
  {
#line 4466
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 4466
  adapter = (struct be_adapter *)tmp;
#line 4467
  adapter->pdev = pdev;
#line 4468
  pci_set_drvdata(pdev, (void *)adapter);
#line 4469
  adapter->netdev = netdev;
#line 4470
  netdev->dev.parent = & pdev->dev;
#line 4472
  status = dma_set_mask_and_coherent(& pdev->dev, 0xffffffffffffffffULL);
  }
#line 4473
  if (status == 0) {
#line 4474
    netdev->features = netdev->features | 32ULL;
  } else {
    {
#line 4476
    status = dma_set_mask_and_coherent(& pdev->dev, 4294967295ULL);
    }
#line 4477
    if (status != 0) {
      {
#line 4478
      dev_err((struct device  const  *)(& pdev->dev), "Could not set PCI DMA Mask\n");
      }
#line 4479
      goto free_netdev;
    } else {

    }
  }
#line 4483
  if ((unsigned int )adapter->virtfn == 0U) {
    {
#line 4484
    status = pci_enable_pcie_error_reporting(pdev);
    }
#line 4485
    if (status == 0) {
      {
#line 4486
      _dev_info((struct device  const  *)(& pdev->dev), "PCIe error reporting enabled\n");
      }
    } else {

    }
  } else {

  }
  {
#line 4489
  status = be_ctrl_init(adapter);
  }
#line 4490
  if (status != 0) {
#line 4491
    goto free_netdev;
  } else {

  }
#line 4494
  if ((unsigned int )adapter->virtfn == 0U) {
    {
#line 4495
    status = be_fw_wait_ready(adapter);
    }
#line 4496
    if (status != 0) {
#line 4497
      goto ctrl_clean;
    } else {

    }
  } else {

  }
  {
#line 4500
  tmp___0 = be_reset_required(adapter);
  }
#line 4500
  if ((int )tmp___0) {
    {
#line 4501
    status = be_cmd_reset_function(adapter);
    }
#line 4502
    if (status != 0) {
#line 4503
      goto ctrl_clean;
    } else {

    }
    {
#line 4506
    msleep(100U);
    }
  } else {

  }
  {
#line 4510
  be_intr_set(adapter, 1);
#line 4513
  status = be_cmd_fw_init(adapter);
  }
#line 4514
  if (status != 0) {
#line 4515
    goto ctrl_clean;
  } else {

  }
  {
#line 4517
  status = be_stats_init(adapter);
  }
#line 4518
  if (status != 0) {
#line 4519
    goto ctrl_clean;
  } else {

  }
  {
#line 4521
  status = be_get_initial_config(adapter);
  }
#line 4522
  if (status != 0) {
#line 4523
    goto stats_clean;
  } else {

  }
  {
#line 4525
  __init_work(& adapter->work.work, 0);
#line 4525
  __constr_expr_0.counter = 137438953408L;
#line 4525
  adapter->work.work.data = __constr_expr_0;
#line 4525
  lockdep_init_map(& adapter->work.work.lockdep_map, "(&(&adapter->work)->work)",
                   & __key, 0);
#line 4525
  INIT_LIST_HEAD(& adapter->work.work.entry);
#line 4525
  adapter->work.work.func = & be_worker;
#line 4525
  init_timer_key(& adapter->work.timer, 2U, "(&(&adapter->work)->timer)", & __key___0);
#line 4525
  adapter->work.timer.function = & delayed_work_timer_fn;
#line 4525
  adapter->work.timer.data = (unsigned long )(& adapter->work);
#line 4526
  __init_work(& adapter->func_recovery_work.work, 0);
#line 4526
  __constr_expr_1.counter = 137438953408L;
#line 4526
  adapter->func_recovery_work.work.data = __constr_expr_1;
#line 4526
  lockdep_init_map(& adapter->func_recovery_work.work.lockdep_map, "(&(&adapter->func_recovery_work)->work)",
                   & __key___1, 0);
#line 4526
  INIT_LIST_HEAD(& adapter->func_recovery_work.work.entry);
#line 4526
  adapter->func_recovery_work.work.func = & be_func_recovery_task;
#line 4526
  init_timer_key(& adapter->func_recovery_work.timer, 2U, "(&(&adapter->func_recovery_work)->timer)",
                 & __key___2);
#line 4526
  adapter->func_recovery_work.timer.function = & delayed_work_timer_fn;
#line 4526
  adapter->func_recovery_work.timer.data = (unsigned long )(& adapter->func_recovery_work);
#line 4527
  tmp___1 = 1U;
#line 4527
  adapter->tx_fc = tmp___1;
#line 4527
  adapter->rx_fc = tmp___1;
#line 4529
  status = be_setup(adapter);
  }
#line 4530
  if (status != 0) {
#line 4531
    goto stats_clean;
  } else {

  }
  {
#line 4533
  be_netdev_init(netdev);
#line 4534
  status = ldv_register_netdev_26(netdev);
  }
#line 4535
  if (status != 0) {
#line 4536
    goto unsetup;
  } else {

  }
  {
#line 4538
  be_roce_dev_add(adapter);
#line 4540
  tmp___2 = msecs_to_jiffies(1000U);
#line 4540
  schedule_delayed_work(& adapter->func_recovery_work, tmp___2);
#line 4543
  be_cmd_query_port_name(adapter, (u8 *)(& port_name));
#line 4545
  tmp___3 = mc_name(adapter);
#line 4545
  tmp___4 = func_name(adapter);
#line 4545
  tmp___5 = nic_name(pdev);
#line 4545
  _dev_info((struct device  const  *)(& pdev->dev), "%s: %s %s port %c\n", tmp___5,
            tmp___4, tmp___3, (int )port_name);
  }
#line 4548
  return (0);
  unsetup: 
  {
#line 4551
  be_clear(adapter);
  }
  stats_clean: 
  {
#line 4553
  be_stats_cleanup(adapter);
  }
  ctrl_clean: 
  {
#line 4555
  be_ctrl_cleanup(adapter);
  }
  free_netdev: 
  {
#line 4557
  ldv_free_netdev_27(netdev);
  }
  rel_reg: 
  {
#line 4559
  pci_release_regions(pdev);
  }
  disable_dev: 
  {
#line 4561
  pci_disable_device(pdev);
  }
  do_none: 
  {
#line 4563
  tmp___6 = nic_name(pdev);
#line 4563
  dev_err((struct device  const  *)(& pdev->dev), "%s initialization failed\n", tmp___6);
  }
#line 4564
  return (status);
}
}
#line 4567 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_suspend(struct pci_dev *pdev , pm_message_t state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  pci_power_t tmp___1 ;

  {
  {
#line 4569
  tmp = pci_get_drvdata(pdev);
#line 4569
  adapter = (struct be_adapter *)tmp;
#line 4570
  netdev = adapter->netdev;
  }
#line 4572
  if ((int )adapter->wol_en) {
    {
#line 4573
    be_setup_wol(adapter, 1);
    }
  } else {

  }
  {
#line 4575
  be_intr_set(adapter, 0);
#line 4576
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4578
  netif_device_detach(netdev);
#line 4579
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 4579
  if ((int )tmp___0) {
    {
#line 4580
    rtnl_lock();
#line 4581
    be_close(netdev);
#line 4582
    rtnl_unlock();
    }
  } else {

  }
  {
#line 4584
  be_clear(adapter);
#line 4586
  pci_save_state(pdev);
#line 4587
  pci_disable_device(pdev);
#line 4588
  tmp___1 = pci_choose_state(pdev, state);
#line 4588
  pci_set_power_state(pdev, tmp___1);
  }
#line 4589
  return (0);
}
}
#line 4592 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_resume(struct pci_dev *pdev ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 4594
  status = 0;
#line 4595
  tmp = pci_get_drvdata(pdev);
#line 4595
  adapter = (struct be_adapter *)tmp;
#line 4596
  netdev = adapter->netdev;
#line 4598
  netif_device_detach(netdev);
#line 4600
  status = pci_enable_device(pdev);
  }
#line 4601
  if (status != 0) {
#line 4602
    return (status);
  } else {

  }
  {
#line 4604
  pci_set_power_state(pdev, 0);
#line 4605
  pci_restore_state(pdev);
#line 4607
  status = be_fw_wait_ready(adapter);
  }
#line 4608
  if (status != 0) {
#line 4609
    return (status);
  } else {

  }
  {
#line 4611
  be_intr_set(adapter, 1);
#line 4613
  status = be_cmd_fw_init(adapter);
  }
#line 4614
  if (status != 0) {
#line 4615
    return (status);
  } else {

  }
  {
#line 4617
  be_setup(adapter);
#line 4618
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 4618
  if ((int )tmp___0) {
    {
#line 4619
    rtnl_lock();
#line 4620
    be_open(netdev);
#line 4621
    rtnl_unlock();
    }
  } else {

  }
  {
#line 4624
  tmp___1 = msecs_to_jiffies(1000U);
#line 4624
  schedule_delayed_work(& adapter->func_recovery_work, tmp___1);
#line 4626
  netif_device_attach(netdev);
  }
#line 4628
  if ((int )adapter->wol_en) {
    {
#line 4629
    be_setup_wol(adapter, 0);
    }
  } else {

  }
#line 4631
  return (0);
}
}
#line 4637 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_shutdown(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 4639
  tmp = pci_get_drvdata(pdev);
#line 4639
  adapter = (struct be_adapter *)tmp;
  }
#line 4641
  if ((unsigned long )adapter == (unsigned long )((struct be_adapter *)0)) {
#line 4642
    return;
  } else {

  }
  {
#line 4644
  cancel_delayed_work_sync(& adapter->work);
#line 4645
  cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4647
  netif_device_detach(adapter->netdev);
#line 4649
  be_cmd_reset_function(adapter);
#line 4651
  pci_disable_device(pdev);
  }
#line 4652
  return;
}
}
#line 4654 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static pci_ers_result_t be_eeh_err_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;

  {
  {
#line 4657
  tmp = pci_get_drvdata(pdev);
#line 4657
  adapter = (struct be_adapter *)tmp;
#line 4658
  netdev = adapter->netdev;
#line 4660
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEH error detected\n");
  }
#line 4662
  if (! adapter->eeh_error) {
    {
#line 4663
    adapter->eeh_error = 1;
#line 4665
    cancel_delayed_work_sync(& adapter->func_recovery_work);
#line 4667
    rtnl_lock();
#line 4668
    netif_device_detach(netdev);
#line 4669
    tmp___0 = netif_running((struct net_device  const  *)netdev);
    }
#line 4669
    if ((int )tmp___0) {
      {
#line 4670
      be_close(netdev);
      }
    } else {

    }
    {
#line 4671
    rtnl_unlock();
#line 4673
    be_clear(adapter);
    }
  } else {

  }
#line 4676
  if (state == 3U) {
#line 4677
    return (4U);
  } else {

  }
  {
#line 4679
  pci_disable_device(pdev);
  }
#line 4687
  if (pdev->devfn == 0U) {
    {
#line 4688
    ssleep(30U);
    }
  } else {

  }
#line 4690
  return (3U);
}
}
#line 4693 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static pci_ers_result_t be_eeh_reset(struct pci_dev *pdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
  {
#line 4695
  tmp = pci_get_drvdata(pdev);
#line 4695
  adapter = (struct be_adapter *)tmp;
#line 4698
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "EEH reset\n");
#line 4700
  status = pci_enable_device(pdev);
  }
#line 4701
  if (status != 0) {
#line 4702
    return (4U);
  } else {

  }
  {
#line 4704
  pci_set_master(pdev);
#line 4705
  pci_set_power_state(pdev, 0);
#line 4706
  pci_restore_state(pdev);
#line 4709
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "Waiting for FW to be ready after EEH reset\n");
#line 4711
  status = be_fw_wait_ready(adapter);
  }
#line 4712
  if (status != 0) {
#line 4713
    return (4U);
  } else {

  }
  {
#line 4715
  pci_cleanup_aer_uncorrect_error_status(pdev);
#line 4716
  be_clear_all_error(adapter);
  }
#line 4717
  return (5U);
}
}
#line 4720 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_eeh_resume(struct pci_dev *pdev ) 
{ 
  int status ;
  struct be_adapter *adapter ;
  void *tmp ;
  struct net_device *netdev ;
  bool tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 4722
  status = 0;
#line 4723
  tmp = pci_get_drvdata(pdev);
#line 4723
  adapter = (struct be_adapter *)tmp;
#line 4724
  netdev = adapter->netdev;
#line 4726
  _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "EEH resume\n");
#line 4728
  pci_save_state(pdev);
#line 4730
  status = be_cmd_reset_function(adapter);
  }
#line 4731
  if (status != 0) {
#line 4732
    goto err;
  } else {

  }
  {
#line 4735
  status = be_cmd_fw_init(adapter);
  }
#line 4736
  if (status != 0) {
#line 4737
    goto err;
  } else {

  }
  {
#line 4739
  status = be_setup(adapter);
  }
#line 4740
  if (status != 0) {
#line 4741
    goto err;
  } else {

  }
  {
#line 4743
  tmp___0 = netif_running((struct net_device  const  *)netdev);
  }
#line 4743
  if ((int )tmp___0) {
    {
#line 4744
    status = be_open(netdev);
    }
#line 4745
    if (status != 0) {
#line 4746
      goto err;
    } else {

    }
  } else {

  }
  {
#line 4749
  tmp___1 = msecs_to_jiffies(1000U);
#line 4749
  schedule_delayed_work(& adapter->func_recovery_work, tmp___1);
#line 4751
  netif_device_attach(netdev);
  }
#line 4752
  return;
  err: 
  {
#line 4754
  dev_err((struct device  const  *)(& (adapter->pdev)->dev), "EEH resume failed\n");
  }
#line 4755
  return;
}
}
#line 4757 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct pci_error_handlers  const  be_eeh_handlers  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& be_eeh_err_detected),
    0, 0, & be_eeh_reset, & be_eeh_resume};
#line 4763 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static struct pci_driver be_driver  = 
#line 4763
     {{0, 0}, "be2net", (struct pci_device_id  const  *)(& be_dev_ids), & be_probe,
    & be_remove, & be_suspend, 0, 0, & be_resume, & be_shutdown, 0, & be_eeh_handlers,
    {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0U}}, 0U, 0U, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                           {0, 0}}};
#line 4774 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static int be_init_module(void) 
{ 
  int tmp ;

  {
#line 4776
  if (((unsigned int )rx_frag_size != 8192U && (unsigned int )rx_frag_size != 4096U) && (unsigned int )rx_frag_size != 2048U) {
    {
#line 4778
    printk("\fbe2net : Module param rx_frag_size must be 2048/4096/8192. Using 2048\n");
#line 4781
    rx_frag_size = 2048U;
    }
  } else {

  }
  {
#line 4784
  tmp = ldv___pci_register_driver_28(& be_driver, & __this_module, "be2net");
  }
#line 4784
  return (tmp);
}
}
#line 4788 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_main.c"
static void be_exit_module(void) 
{ 


  {
  {
#line 4790
  ldv_pci_unregister_driver_29(& be_driver);
  }
#line 4791
  return;
}
}
#line 51 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_EMGentry_exit_be_exit_module_15_2(void (*arg0)(void) ) ;
#line 52
int ldv_EMGentry_init_be_init_module_15_9(int (*arg0)(void) ) ;
#line 53
int ldv___pci_register_driver(int arg0 , struct pci_driver *arg1 , struct module *arg2 ,
                              char *arg3 ) ;
#line 54
struct net_device *ldv_alloc_etherdev_mqs(struct net_device *arg0 , int arg1 , unsigned int arg2 ,
                                          unsigned int arg3 ) ;
#line 55
void ldv_allocate_external_0(void) ;
#line 56
void ldv_dispatch_deregister_12_1(struct net_device *arg0 ) ;
#line 57
void ldv_dispatch_deregister_13_1(struct pci_driver *arg0 ) ;
#line 58
void ldv_dispatch_deregister_dummy_factory_13_15_4(void) ;
#line 59
void ldv_dispatch_instance_deregister_5_2(struct timer_list *arg0 ) ;
#line 60
void ldv_dispatch_instance_register_5_3(struct timer_list *arg0 ) ;
#line 61
void ldv_dispatch_irq_deregister_7_1(int arg0 ) ;
#line 62
void ldv_dispatch_irq_register_10_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 63
void ldv_dispatch_irq_register_11_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 64
void ldv_dispatch_register_14_2(struct pci_driver *arg0 ) ;
#line 65
void ldv_dispatch_register_9_4(struct net_device *arg0 ) ;
#line 66
void ldv_dispatch_register_dummy_factory_13_15_5(void) ;
#line 67
void ldv_dummy_resourceless_instance_callback_2_10(int (*arg0)(struct net_device * ,
                                                               struct ethtool_eeprom * ,
                                                               unsigned char * ) ,
                                                   struct net_device *arg1 , struct ethtool_eeprom *arg2 ,
                                                   unsigned char *arg3 ) ;
#line 68
void ldv_dummy_resourceless_instance_callback_2_13(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 69
void ldv_dummy_resourceless_instance_callback_2_14(void (*arg0)(struct net_device * ,
                                                                struct ethtool_stats * ,
                                                                unsigned long long * ) ,
                                                   struct net_device *arg1 , struct ethtool_stats *arg2 ,
                                                   unsigned long long *arg3 ) ;
#line 70
void ldv_dummy_resourceless_instance_callback_2_17(unsigned int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 71
void ldv_dummy_resourceless_instance_callback_2_18(unsigned int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 72
void ldv_dummy_resourceless_instance_callback_2_19(void (*arg0)(struct net_device * ,
                                                                struct ethtool_pauseparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_pauseparam *arg2 ) ;
#line 73
void ldv_dummy_resourceless_instance_callback_2_20(void (*arg0)(struct net_device * ,
                                                                struct ethtool_regs * ,
                                                                void * ) , struct net_device *arg1 ,
                                                   struct ethtool_regs *arg2 , void *arg3 ) ;
#line 74
void ldv_dummy_resourceless_instance_callback_2_21(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 75
void ldv_dummy_resourceless_instance_callback_2_22(void (*arg0)(struct net_device * ,
                                                                struct ethtool_ringparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_ringparam *arg2 ) ;
#line 76
void ldv_dummy_resourceless_instance_callback_2_23(int (*arg0)(struct net_device * ,
                                                               struct ethtool_rxnfc * ,
                                                               unsigned int * ) ,
                                                   struct net_device *arg1 , struct ethtool_rxnfc *arg2 ,
                                                   unsigned int *arg3 ) ;
#line 77
void ldv_dummy_resourceless_instance_callback_2_26(int (*arg0)(struct net_device * ,
                                                               struct ethtool_cmd * ) ,
                                                   struct net_device *arg1 , struct ethtool_cmd *arg2 ) ;
#line 78
void ldv_dummy_resourceless_instance_callback_2_27(int (*arg0)(struct net_device * ,
                                                               int  ) , struct net_device *arg1 ,
                                                   int arg2 ) ;
#line 79
void ldv_dummy_resourceless_instance_callback_2_3(int (*arg0)(struct net_device * ,
                                                              struct ethtool_flash * ) ,
                                                  struct net_device *arg1 , struct ethtool_flash *arg2 ) ;
#line 80
void ldv_dummy_resourceless_instance_callback_2_30(void (*arg0)(struct net_device * ,
                                                                unsigned int  , unsigned char * ) ,
                                                   struct net_device *arg1 , unsigned int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 81
void ldv_dummy_resourceless_instance_callback_2_33(void (*arg0)(struct net_device * ,
                                                                struct ethtool_wolinfo * ) ,
                                                   struct net_device *arg1 , struct ethtool_wolinfo *arg2 ) ;
#line 82
void ldv_dummy_resourceless_instance_callback_2_34(int (*arg0)(struct sk_buff * ,
                                                               unsigned int  , unsigned int  ,
                                                               struct net_device * ,
                                                               unsigned int  ) , struct sk_buff *arg1 ,
                                                   unsigned int arg2 , unsigned int arg3 ,
                                                   struct net_device *arg4 , unsigned int arg5 ) ;
#line 83
void ldv_dummy_resourceless_instance_callback_2_37(int (*arg0)(struct net_device * ,
                                                               struct nlmsghdr * ) ,
                                                   struct net_device *arg1 , struct nlmsghdr *arg2 ) ;
#line 84
void ldv_dummy_resourceless_instance_callback_2_38(int (*arg0)(struct napi_struct * ) ,
                                                   struct napi_struct *arg1 ) ;
#line 85
void ldv_dummy_resourceless_instance_callback_2_39(int (*arg0)(struct net_device * ,
                                                               int  ) , struct net_device *arg1 ,
                                                   int arg2 ) ;
#line 86
void ldv_dummy_resourceless_instance_callback_2_42(struct rtnl_link_stats64 *(*arg0)(struct net_device * ,
                                                                                     struct rtnl_link_stats64 * ) ,
                                                   struct net_device *arg1 , struct rtnl_link_stats64 *arg2 ) ;
#line 87
void ldv_dummy_resourceless_instance_callback_2_43(int (*arg0)(struct net_device * ,
                                                               int  , struct ifla_vf_info * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   struct ifla_vf_info *arg3 ) ;
#line 88
void ldv_dummy_resourceless_instance_callback_2_46(void (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 89
void ldv_dummy_resourceless_instance_callback_2_47(int (*arg0)(struct net_device * ,
                                                               void * ) , struct net_device *arg1 ,
                                                   void *arg2 ) ;
#line 90
void ldv_dummy_resourceless_instance_callback_2_48(void (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 91
void ldv_dummy_resourceless_instance_callback_2_49(int (*arg0)(struct net_device * ,
                                                               int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) ;
#line 92
void ldv_dummy_resourceless_instance_callback_2_52(int (*arg0)(struct net_device * ,
                                                               int  , int  ) , struct net_device *arg1 ,
                                                   int arg2 , int arg3 ) ;
#line 93
void ldv_dummy_resourceless_instance_callback_2_55(int (*arg0)(struct net_device * ,
                                                               int  , unsigned short  ,
                                                               unsigned char  ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned short arg3 , unsigned char arg4 ) ;
#line 94
void ldv_dummy_resourceless_instance_callback_2_58(enum netdev_tx (*arg0)(struct sk_buff * ,
                                                                          struct net_device * ) ,
                                                   struct sk_buff *arg1 , struct net_device *arg2 ) ;
#line 95
void ldv_dummy_resourceless_instance_callback_2_59(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) ;
#line 96
void ldv_dummy_resourceless_instance_callback_2_60(int (*arg0)(struct net_device * ,
                                                               unsigned short  , unsigned short  ) ,
                                                   struct net_device *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 ) ;
#line 97
void ldv_dummy_resourceless_instance_callback_2_63(int (*arg0)(struct net_device * ,
                                                               unsigned short  , unsigned short  ) ,
                                                   struct net_device *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 ) ;
#line 98
void ldv_dummy_resourceless_instance_callback_2_66(void (*arg0)(struct net_device * ,
                                                                struct ethtool_test * ,
                                                                unsigned long long * ) ,
                                                   struct net_device *arg1 , struct ethtool_test *arg2 ,
                                                   unsigned long long *arg3 ) ;
#line 99
void ldv_dummy_resourceless_instance_callback_2_69(int (*arg0)(struct net_device * ,
                                                               struct ethtool_channels * ) ,
                                                   struct net_device *arg1 , struct ethtool_channels *arg2 ) ;
#line 100
void ldv_dummy_resourceless_instance_callback_2_7(void (*arg0)(struct net_device * ,
                                                               struct ethtool_channels * ) ,
                                                  struct net_device *arg1 , struct ethtool_channels *arg2 ) ;
#line 101
void ldv_dummy_resourceless_instance_callback_2_70(int (*arg0)(struct net_device * ,
                                                               struct ethtool_coalesce * ) ,
                                                   struct net_device *arg1 , struct ethtool_coalesce *arg2 ) ;
#line 102
void ldv_dummy_resourceless_instance_callback_2_71(int (*arg0)(struct net_device * ,
                                                               struct ethtool_dump * ) ,
                                                   struct net_device *arg1 , struct ethtool_dump *arg2 ) ;
#line 103
void ldv_dummy_resourceless_instance_callback_2_72(void (*arg0)(struct net_device * ,
                                                                unsigned int  ) ,
                                                   struct net_device *arg1 , unsigned int arg2 ) ;
#line 104
void ldv_dummy_resourceless_instance_callback_2_75(int (*arg0)(struct net_device * ,
                                                               struct ethtool_pauseparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_pauseparam *arg2 ) ;
#line 105
void ldv_dummy_resourceless_instance_callback_2_76(int (*arg0)(struct net_device * ,
                                                               enum ethtool_phys_id_state  ) ,
                                                   struct net_device *arg1 , enum ethtool_phys_id_state arg2 ) ;
#line 106
void ldv_dummy_resourceless_instance_callback_2_77(int (*arg0)(struct net_device * ,
                                                               struct ethtool_rxnfc * ) ,
                                                   struct net_device *arg1 , struct ethtool_rxnfc *arg2 ) ;
#line 107
void ldv_dummy_resourceless_instance_callback_2_78(int (*arg0)(struct net_device * ,
                                                               struct ethtool_wolinfo * ) ,
                                                   struct net_device *arg1 , struct ethtool_wolinfo *arg2 ) ;
#line 108
void ldv_dummy_resourceless_instance_callback_2_8(int (*arg0)(struct net_device * ,
                                                              struct ethtool_coalesce * ) ,
                                                  struct net_device *arg1 , struct ethtool_coalesce *arg2 ) ;
#line 109
void ldv_dummy_resourceless_instance_callback_2_9(void (*arg0)(struct net_device * ,
                                                               struct ethtool_drvinfo * ) ,
                                                  struct net_device *arg1 , struct ethtool_drvinfo *arg2 ) ;
#line 110
void ldv_entry_EMGentry_15(void *arg0 ) ;
#line 111
void main(void) ;
#line 112
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) ;
#line 113
void ldv_free_netdev(void *arg0 , struct net_device *arg1 ) ;
#line 114
void ldv_initialize_external_data(void) ;
#line 115
enum irqreturn ldv_interrupt_instance_handler_0_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 116
enum irqreturn ldv_interrupt_instance_handler_1_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 117
void ldv_interrupt_instance_thread_0_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 118
void ldv_interrupt_instance_thread_1_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 119
void ldv_interrupt_interrupt_instance_0(void *arg0 ) ;
#line 120
void ldv_interrupt_interrupt_instance_1(void *arg0 ) ;
#line 121
void ldv_net_dummy_resourceless_instance_2(void *arg0 ) ;
#line 122
void ldv_pci_instance_callback_3_10(unsigned int (*arg0)(struct pci_dev * , enum pci_channel_state  ) ,
                                    struct pci_dev *arg1 , enum pci_channel_state arg2 ) ;
#line 123
void ldv_pci_instance_callback_3_23(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 124
void ldv_pci_instance_callback_3_24(unsigned int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 125
int ldv_pci_instance_probe_3_17(int (*arg0)(struct pci_dev * , struct pci_device_id * ) ,
                                struct pci_dev *arg1 , struct pci_device_id *arg2 ) ;
#line 126
void ldv_pci_instance_release_3_2(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 127
void ldv_pci_instance_resume_3_5(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 128
void ldv_pci_instance_resume_early_3_6(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 129
void ldv_pci_instance_shutdown_3_3(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 130
int ldv_pci_instance_suspend_3_8(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                 struct pci_dev *arg1 , struct pm_message arg2 ) ;
#line 131
int ldv_pci_instance_suspend_late_3_7(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                      struct pci_dev *arg1 , struct pm_message arg2 ) ;
#line 132
void ldv_pci_pci_instance_3(void *arg0 ) ;
#line 133
void ldv_pci_unregister_driver(void *arg0 , struct pci_driver *arg1 ) ;
#line 134
int ldv_register_netdev(int arg0 , struct net_device *arg1 ) ;
#line 135
int ldv_register_netdev_open_9_6(int (*arg0)(struct net_device * ) , struct net_device *arg1 ) ;
#line 136
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) ;
#line 137
int ldv_switch_0(void) ;
#line 138
int ldv_switch_1(void) ;
#line 139
void ldv_switch_automaton_state_0_1(void) ;
#line 140
void ldv_switch_automaton_state_0_6(void) ;
#line 141
void ldv_switch_automaton_state_1_1(void) ;
#line 142
void ldv_switch_automaton_state_1_6(void) ;
#line 143
void ldv_switch_automaton_state_2_1(void) ;
#line 144
void ldv_switch_automaton_state_2_5(void) ;
#line 145
void ldv_switch_automaton_state_3_11(void) ;
#line 146
void ldv_switch_automaton_state_3_20(void) ;
#line 147
void ldv_switch_automaton_state_4_1(void) ;
#line 148
void ldv_switch_automaton_state_4_3(void) ;
#line 149
void ldv_switch_automaton_state_5_1(void) ;
#line 150
void ldv_switch_automaton_state_5_4(void) ;
#line 151
void ldv_timer_dummy_factory_5(void *arg0 ) ;
#line 152
void ldv_timer_instance_callback_4_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) ;
#line 153
void ldv_timer_timer_instance_4(void *arg0 ) ;
#line 154
void ldv_unregister_netdev(void *arg0 , struct net_device *arg1 ) ;
#line 155
void ldv_unregister_netdev_stop_12_2(int (*arg0)(struct net_device * ) , struct net_device *arg1 ) ;
#line 158
enum irqreturn (*ldv_0_callback_handler)(int  , void * ) ;
#line 159 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void *ldv_0_data_data  ;
#line 160 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_0_line_line  ;
#line 161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum irqreturn ldv_0_ret_val_default  ;
#line 162 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum irqreturn (*ldv_0_thread_thread)(int  , void * )  ;
#line 163
void (*ldv_15_exit_be_exit_module_default)(void) ;
#line 164
int (*ldv_15_init_be_init_module_default)(void) ;
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_15_ret_default  ;
#line 166
enum irqreturn (*ldv_1_callback_handler)(int  , void * ) ;
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void *ldv_1_data_data  ;
#line 168 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_1_line_line  ;
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum irqreturn ldv_1_ret_val_default  ;
#line 170 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum irqreturn (*ldv_1_thread_thread)(int  , void * )  ;
#line 171
int (*ldv_2_callback_flash_device)(struct net_device * , struct ethtool_flash * ) ;
#line 172
void (*ldv_2_callback_get_channels)(struct net_device * , struct ethtool_channels * ) ;
#line 173
int (*ldv_2_callback_get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
#line 174
void (*ldv_2_callback_get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
#line 175
int (*ldv_2_callback_get_eeprom)(struct net_device * , struct ethtool_eeprom * , unsigned char * ) ;
#line 176
int (*ldv_2_callback_get_eeprom_len)(struct net_device * ) ;
#line 177
void (*ldv_2_callback_get_ethtool_stats)(struct net_device * , struct ethtool_stats * ,
                                         unsigned long long * ) ;
#line 178
unsigned int (*ldv_2_callback_get_link)(struct net_device * ) ;
#line 179
unsigned int (*ldv_2_callback_get_msglevel)(struct net_device * ) ;
#line 180
void (*ldv_2_callback_get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
#line 181
void (*ldv_2_callback_get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
#line 182
int (*ldv_2_callback_get_regs_len)(struct net_device * ) ;
#line 183
void (*ldv_2_callback_get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
#line 184
int (*ldv_2_callback_get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , unsigned int * ) ;
#line 185
int (*ldv_2_callback_get_settings)(struct net_device * , struct ethtool_cmd * ) ;
#line 186
int (*ldv_2_callback_get_sset_count)(struct net_device * , int  ) ;
#line 187
void (*ldv_2_callback_get_strings)(struct net_device * , unsigned int  , unsigned char * ) ;
#line 188
void (*ldv_2_callback_get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
#line 189
int (*ldv_2_callback_ndo_bridge_getlink)(struct sk_buff * , unsigned int  , unsigned int  ,
                                         struct net_device * , unsigned int  ) ;
#line 190
int (*ldv_2_callback_ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * ) ;
#line 191
int (*ldv_2_callback_ndo_busy_poll)(struct napi_struct * ) ;
#line 192
int (*ldv_2_callback_ndo_change_mtu)(struct net_device * , int  ) ;
#line 193
struct rtnl_link_stats64 *(*ldv_2_callback_ndo_get_stats64)(struct net_device * ,
                                                            struct rtnl_link_stats64 * ) ;
#line 194
int (*ldv_2_callback_ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
#line 195
void (*ldv_2_callback_ndo_poll_controller)(struct net_device * ) ;
#line 196
int (*ldv_2_callback_ndo_set_mac_address)(struct net_device * , void * ) ;
#line 197
void (*ldv_2_callback_ndo_set_rx_mode)(struct net_device * ) ;
#line 198
int (*ldv_2_callback_ndo_set_vf_mac)(struct net_device * , int  , unsigned char * ) ;
#line 199
int (*ldv_2_callback_ndo_set_vf_tx_rate)(struct net_device * , int  , int  ) ;
#line 200
int (*ldv_2_callback_ndo_set_vf_vlan)(struct net_device * , int  , unsigned short  ,
                                      unsigned char  ) ;
#line 201
enum netdev_tx (*ldv_2_callback_ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
#line 202
int (*ldv_2_callback_ndo_validate_addr)(struct net_device * ) ;
#line 203
int (*ldv_2_callback_ndo_vlan_rx_add_vid)(struct net_device * , unsigned short  ,
                                          unsigned short  ) ;
#line 204
int (*ldv_2_callback_ndo_vlan_rx_kill_vid)(struct net_device * , unsigned short  ,
                                           unsigned short  ) ;
#line 205
void (*ldv_2_callback_self_test)(struct net_device * , struct ethtool_test * , unsigned long long * ) ;
#line 206
int (*ldv_2_callback_set_channels)(struct net_device * , struct ethtool_channels * ) ;
#line 207
int (*ldv_2_callback_set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
#line 208
int (*ldv_2_callback_set_dump)(struct net_device * , struct ethtool_dump * ) ;
#line 209
void (*ldv_2_callback_set_msglevel)(struct net_device * , unsigned int  ) ;
#line 210
int (*ldv_2_callback_set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
#line 211
int (*ldv_2_callback_set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
#line 212
int (*ldv_2_callback_set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
#line 213
int (*ldv_2_callback_set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
#line 214 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum ethtool_phys_id_state ldv_2_container_enum_ethtool_phys_id_state  ;
#line 215 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct net_device *ldv_2_container_net_device  ;
#line 216 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_channels *ldv_2_container_struct_ethtool_channels_ptr  ;
#line 217 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_cmd *ldv_2_container_struct_ethtool_cmd_ptr  ;
#line 218 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_coalesce *ldv_2_container_struct_ethtool_coalesce_ptr  ;
#line 219 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_drvinfo *ldv_2_container_struct_ethtool_drvinfo_ptr  ;
#line 220 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_dump *ldv_2_container_struct_ethtool_dump_ptr  ;
#line 221 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_eeprom *ldv_2_container_struct_ethtool_eeprom_ptr  ;
#line 222 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_flash *ldv_2_container_struct_ethtool_flash_ptr  ;
#line 223 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_pauseparam *ldv_2_container_struct_ethtool_pauseparam_ptr  ;
#line 224 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_regs *ldv_2_container_struct_ethtool_regs_ptr  ;
#line 225 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_ringparam *ldv_2_container_struct_ethtool_ringparam_ptr  ;
#line 226 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_rxnfc *ldv_2_container_struct_ethtool_rxnfc_ptr  ;
#line 227 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_stats *ldv_2_container_struct_ethtool_stats_ptr  ;
#line 228 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_test *ldv_2_container_struct_ethtool_test_ptr  ;
#line 229 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ethtool_wolinfo *ldv_2_container_struct_ethtool_wolinfo_ptr  ;
#line 230 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct ifla_vf_info *ldv_2_container_struct_ifla_vf_info_ptr  ;
#line 231 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct napi_struct *ldv_2_container_struct_napi_struct_ptr  ;
#line 232 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct nlmsghdr *ldv_2_container_struct_nlmsghdr_ptr  ;
#line 233 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct rtnl_link_stats64 *ldv_2_container_struct_rtnl_link_stats64_ptr  ;
#line 234 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct sk_buff *ldv_2_container_struct_sk_buff_ptr  ;
#line 235 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned char *ldv_2_ldv_param_10_2_default  ;
#line 236 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned long long *ldv_2_ldv_param_14_2_default  ;
#line 237 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned int *ldv_2_ldv_param_23_2_default  ;
#line 238 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_2_ldv_param_27_1_default  ;
#line 239 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned int ldv_2_ldv_param_30_1_default  ;
#line 240 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned char *ldv_2_ldv_param_30_2_default  ;
#line 241 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned int ldv_2_ldv_param_34_1_default  ;
#line 242 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned int ldv_2_ldv_param_34_2_default  ;
#line 243 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned int ldv_2_ldv_param_34_4_default  ;
#line 244 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_2_ldv_param_39_1_default  ;
#line 245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_2_ldv_param_43_1_default  ;
#line 246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_2_ldv_param_49_1_default  ;
#line 247 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned char *ldv_2_ldv_param_49_2_default  ;
#line 248 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_2_ldv_param_52_1_default  ;
#line 249 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_2_ldv_param_52_2_default  ;
#line 250 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_2_ldv_param_55_1_default  ;
#line 251 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned short ldv_2_ldv_param_55_2_default  ;
#line 252 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned char ldv_2_ldv_param_55_3_default  ;
#line 253 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned short ldv_2_ldv_param_60_1_default  ;
#line 254 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned short ldv_2_ldv_param_60_2_default  ;
#line 255 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned short ldv_2_ldv_param_63_1_default  ;
#line 256 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned short ldv_2_ldv_param_63_2_default  ;
#line 257 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned long long *ldv_2_ldv_param_66_2_default  ;
#line 258 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned int ldv_2_ldv_param_72_1_default  ;
#line 259
unsigned int (*ldv_3_callback_error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
#line 260
void (*ldv_3_callback_func_1_ptr)(struct pci_dev * ) ;
#line 261
unsigned int (*ldv_3_callback_slot_reset)(struct pci_dev * ) ;
#line 262 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct pci_driver *ldv_3_container_pci_driver  ;
#line 263 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct pci_dev *ldv_3_resource_dev  ;
#line 264 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum pci_channel_state ldv_3_resource_enum_pci_channel_state  ;
#line 265 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct pm_message ldv_3_resource_pm_message  ;
#line 266 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct pci_device_id *ldv_3_resource_struct_pci_device_id_ptr  ;
#line 267 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_3_ret_default  ;
#line 268 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct timer_list *ldv_4_container_timer_list  ;
#line 269 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct timer_list *ldv_5_container_timer_list  ;
#line 270 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_statevar_0  ;
#line 271 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_statevar_1  ;
#line 272 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_statevar_15  ;
#line 273 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_statevar_2  ;
#line 274 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_statevar_3  ;
#line 275 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_statevar_4  ;
#line 276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_statevar_5  ;
#line 279 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum irqreturn (*ldv_0_callback_handler)(int  , void * )  =    & be_intx;
#line 280 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void (*ldv_15_exit_be_exit_module_default)(void)  =    & be_exit_module;
#line 281 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_15_init_be_init_module_default)(void)  =    & be_init_module;
#line 282 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum irqreturn (*ldv_1_callback_handler)(int  , void * )  =    & be_msix;
#line 283 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_bridge_getlink)(struct sk_buff * , unsigned int  , unsigned int  ,
                                         struct net_device * , unsigned int  )  =    & be_ndo_bridge_getlink;
#line 284 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * )  =    & be_ndo_bridge_setlink;
#line 285 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_busy_poll)(struct napi_struct * )  =    & be_busy_poll;
#line 286 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_change_mtu)(struct net_device * , int  )  =    & be_change_mtu;
#line 287 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct rtnl_link_stats64 *(*ldv_2_callback_ndo_get_stats64)(struct net_device * ,
                                                            struct rtnl_link_stats64 * )  =    & be_get_stats64;
#line 288 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * )  =    & be_get_vf_config;
#line 289 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void (*ldv_2_callback_ndo_poll_controller)(struct net_device * )  =    & be_netpoll;
#line 290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_set_mac_address)(struct net_device * , void * )  =    & be_mac_addr_set;
#line 291 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void (*ldv_2_callback_ndo_set_rx_mode)(struct net_device * )  =    & be_set_rx_mode;
#line 292 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_set_vf_mac)(struct net_device * , int  , unsigned char * )  =    & be_set_vf_mac;
#line 293 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_set_vf_tx_rate)(struct net_device * , int  , int  )  =    & be_set_vf_tx_rate;
#line 294 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_set_vf_vlan)(struct net_device * , int  , unsigned short  ,
                                      unsigned char  )  =    & be_set_vf_vlan;
#line 295 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum netdev_tx (*ldv_2_callback_ndo_start_xmit)(struct sk_buff * , struct net_device * )  =    & be_xmit;
#line 296 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_validate_addr)(struct net_device * )  =    & eth_validate_addr;
#line 297 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_vlan_rx_add_vid)(struct net_device * , unsigned short  ,
                                          unsigned short  )  =    & be_vlan_add_vid;
#line 298 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int (*ldv_2_callback_ndo_vlan_rx_kill_vid)(struct net_device * , unsigned short  ,
                                           unsigned short  )  =    & be_vlan_rem_vid;
#line 299 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned int (*ldv_3_callback_error_detected)(struct pci_dev * , enum pci_channel_state  )  =    (unsigned int (*)(struct pci_dev * ,
                     enum pci_channel_state  ))(& be_eeh_err_detected);
#line 300 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void (*ldv_3_callback_func_1_ptr)(struct pci_dev * )  =    & be_eeh_resume;
#line 301 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
unsigned int (*ldv_3_callback_slot_reset)(struct pci_dev * )  =    & be_eeh_reset;
#line 305 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_EMGentry_exit_be_exit_module_15_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 306
  be_exit_module();
  }
#line 307
  return;
}
}
#line 310 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_EMGentry_init_be_init_module_15_9(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 311
  tmp = be_init_module();
  }
#line 311
  return (tmp);
}
}
#line 315 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv___pci_register_driver(int arg0 , struct pci_driver *arg1 , struct module *arg2 ,
                              char *arg3 ) 
{ 
  struct pci_driver *ldv_14_pci_driver_pci_driver ;
  int tmp ;

  {
  {
#line 322
  tmp = ldv_undef_int();
  }
#line 322
  if (tmp != 0) {
    {
#line 324
    ldv_assume(arg0 == 0);
#line 325
    ldv_14_pci_driver_pci_driver = arg1;
#line 329
    ldv_assume(ldv_statevar_3 == 20);
#line 330
    ldv_dispatch_register_14_2(ldv_14_pci_driver_pci_driver);
    }
#line 334
    return (arg0);
  } else {
    {
#line 338
    ldv_assume(arg0 != 0);
    }
#line 342
    return (arg0);
  }
#line 345
  return (arg0);
}
}
#line 350 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
struct net_device *ldv_alloc_etherdev_mqs(struct net_device *arg0 , int arg1 , unsigned int arg2 ,
                                          unsigned int arg3 ) 
{ 
  struct net_device *ldv_6_netdev_net_device ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 357
  tmp___0 = ldv_undef_int();
  }
#line 357
  if (tmp___0 != 0) {
    {
#line 359
    tmp = ldv_xmalloc(3200UL);
#line 359
    ldv_6_netdev_net_device = (struct net_device *)tmp;
    }
#line 363
    return (ldv_6_netdev_net_device);
#line 367
    return (arg0);
  } else {
#line 371
    return ((struct net_device *)0);
#line 375
    return (arg0);
  }
#line 378
  return (arg0);
}
}
#line 383 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_allocate_external_0(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;

  {
  {
#line 384
  ldv_0_data_data = external_allocated_data();
#line 385
  tmp = external_allocated_data();
#line 385
  ldv_0_thread_thread = (enum irqreturn (*)(int  , void * ))tmp;
#line 386
  ldv_1_data_data = external_allocated_data();
#line 387
  tmp___0 = external_allocated_data();
#line 387
  ldv_1_thread_thread = (enum irqreturn (*)(int  , void * ))tmp___0;
#line 388
  tmp___1 = external_allocated_data();
#line 388
  ldv_2_container_net_device = (struct net_device *)tmp___1;
#line 389
  tmp___2 = external_allocated_data();
#line 389
  ldv_2_container_struct_ethtool_channels_ptr = (struct ethtool_channels *)tmp___2;
#line 390
  tmp___3 = external_allocated_data();
#line 390
  ldv_2_container_struct_ethtool_cmd_ptr = (struct ethtool_cmd *)tmp___3;
#line 391
  tmp___4 = external_allocated_data();
#line 391
  ldv_2_container_struct_ethtool_coalesce_ptr = (struct ethtool_coalesce *)tmp___4;
#line 392
  tmp___5 = external_allocated_data();
#line 392
  ldv_2_container_struct_ethtool_drvinfo_ptr = (struct ethtool_drvinfo *)tmp___5;
#line 393
  tmp___6 = external_allocated_data();
#line 393
  ldv_2_container_struct_ethtool_dump_ptr = (struct ethtool_dump *)tmp___6;
#line 394
  tmp___7 = external_allocated_data();
#line 394
  ldv_2_container_struct_ethtool_eeprom_ptr = (struct ethtool_eeprom *)tmp___7;
#line 395
  tmp___8 = external_allocated_data();
#line 395
  ldv_2_container_struct_ethtool_flash_ptr = (struct ethtool_flash *)tmp___8;
#line 396
  tmp___9 = external_allocated_data();
#line 396
  ldv_2_container_struct_ethtool_pauseparam_ptr = (struct ethtool_pauseparam *)tmp___9;
#line 397
  tmp___10 = external_allocated_data();
#line 397
  ldv_2_container_struct_ethtool_regs_ptr = (struct ethtool_regs *)tmp___10;
#line 398
  tmp___11 = external_allocated_data();
#line 398
  ldv_2_container_struct_ethtool_ringparam_ptr = (struct ethtool_ringparam *)tmp___11;
#line 399
  tmp___12 = external_allocated_data();
#line 399
  ldv_2_container_struct_ethtool_rxnfc_ptr = (struct ethtool_rxnfc *)tmp___12;
#line 400
  tmp___13 = external_allocated_data();
#line 400
  ldv_2_container_struct_ethtool_stats_ptr = (struct ethtool_stats *)tmp___13;
#line 401
  tmp___14 = external_allocated_data();
#line 401
  ldv_2_container_struct_ethtool_test_ptr = (struct ethtool_test *)tmp___14;
#line 402
  tmp___15 = external_allocated_data();
#line 402
  ldv_2_container_struct_ethtool_wolinfo_ptr = (struct ethtool_wolinfo *)tmp___15;
#line 403
  tmp___16 = external_allocated_data();
#line 403
  ldv_2_container_struct_ifla_vf_info_ptr = (struct ifla_vf_info *)tmp___16;
#line 404
  tmp___17 = external_allocated_data();
#line 404
  ldv_2_container_struct_napi_struct_ptr = (struct napi_struct *)tmp___17;
#line 405
  tmp___18 = external_allocated_data();
#line 405
  ldv_2_container_struct_nlmsghdr_ptr = (struct nlmsghdr *)tmp___18;
#line 406
  tmp___19 = external_allocated_data();
#line 406
  ldv_2_container_struct_rtnl_link_stats64_ptr = (struct rtnl_link_stats64 *)tmp___19;
#line 407
  tmp___20 = external_allocated_data();
#line 407
  ldv_2_container_struct_sk_buff_ptr = (struct sk_buff *)tmp___20;
#line 408
  tmp___21 = external_allocated_data();
#line 408
  ldv_2_ldv_param_10_2_default = (unsigned char *)tmp___21;
#line 409
  tmp___22 = external_allocated_data();
#line 409
  ldv_2_ldv_param_14_2_default = (unsigned long long *)tmp___22;
#line 410
  tmp___23 = external_allocated_data();
#line 410
  ldv_2_ldv_param_23_2_default = (unsigned int *)tmp___23;
#line 411
  tmp___24 = external_allocated_data();
#line 411
  ldv_2_ldv_param_30_2_default = (unsigned char *)tmp___24;
#line 412
  tmp___25 = external_allocated_data();
#line 412
  ldv_2_ldv_param_49_2_default = (unsigned char *)tmp___25;
#line 413
  tmp___26 = external_allocated_data();
#line 413
  ldv_2_ldv_param_66_2_default = (unsigned long long *)tmp___26;
#line 414
  tmp___27 = external_allocated_data();
#line 414
  ldv_3_resource_dev = (struct pci_dev *)tmp___27;
#line 415
  tmp___28 = external_allocated_data();
#line 415
  ldv_4_container_timer_list = (struct timer_list *)tmp___28;
#line 416
  tmp___29 = external_allocated_data();
#line 416
  ldv_5_container_timer_list = (struct timer_list *)tmp___29;
  }
#line 417
  return;
}
}
#line 420 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_deregister_12_1(struct net_device *arg0 ) 
{ 


  {
  {
#line 423
  ldv_2_container_net_device = arg0;
#line 426
  ldv_switch_automaton_state_2_1();
  }
#line 427
  return;
}
}
#line 431 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_deregister_13_1(struct pci_driver *arg0 ) 
{ 


  {
  {
#line 434
  ldv_3_container_pci_driver = arg0;
#line 437
  ldv_switch_automaton_state_3_11();
  }
#line 438
  return;
}
}
#line 442 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_deregister_dummy_factory_13_15_4(void) 
{ 


  {
  {
#line 446
  ldv_switch_automaton_state_5_1();
  }
#line 447
  return;
}
}
#line 451 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_instance_deregister_5_2(struct timer_list *arg0 ) 
{ 


  {
  {
#line 454
  ldv_4_container_timer_list = arg0;
#line 457
  ldv_switch_automaton_state_4_1();
  }
#line 458
  return;
}
}
#line 462 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_instance_register_5_3(struct timer_list *arg0 ) 
{ 


  {
  {
#line 465
  ldv_4_container_timer_list = arg0;
#line 468
  ldv_switch_automaton_state_4_3();
  }
#line 469
  return;
}
}
#line 473 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_irq_deregister_7_1(int arg0 ) 
{ 
  int tmp ;

  {
  {
#line 475
  tmp = ldv_undef_int();
  }
#line 475
  if (tmp != 0) {
    {
#line 477
    ldv_0_line_line = arg0;
#line 480
    ldv_switch_automaton_state_0_1();
    }
  } else {
    {
#line 484
    ldv_1_line_line = arg0;
#line 487
    ldv_switch_automaton_state_1_1();
    }
  }
#line 489
  return;
}
}
#line 493 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_irq_register_10_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  int tmp ;

  {
  {
#line 495
  tmp = ldv_undef_int();
  }
#line 495
  if (tmp != 0) {
    {
#line 497
    ldv_0_line_line = arg0;
#line 498
    ldv_0_callback_handler = arg1;
#line 499
    ldv_0_thread_thread = arg2;
#line 500
    ldv_0_data_data = arg3;
#line 503
    ldv_switch_automaton_state_0_6();
    }
  } else {
    {
#line 507
    ldv_1_line_line = arg0;
#line 508
    ldv_1_callback_handler = arg1;
#line 509
    ldv_1_thread_thread = arg2;
#line 510
    ldv_1_data_data = arg3;
#line 513
    ldv_switch_automaton_state_1_6();
    }
  }
#line 515
  return;
}
}
#line 519 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_irq_register_11_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  int tmp ;

  {
  {
#line 521
  tmp = ldv_undef_int();
  }
#line 521
  if (tmp != 0) {
    {
#line 523
    ldv_0_line_line = arg0;
#line 524
    ldv_0_callback_handler = arg1;
#line 525
    ldv_0_thread_thread = arg2;
#line 526
    ldv_0_data_data = arg3;
#line 529
    ldv_switch_automaton_state_0_6();
    }
  } else {
    {
#line 533
    ldv_1_line_line = arg0;
#line 534
    ldv_1_callback_handler = arg1;
#line 535
    ldv_1_thread_thread = arg2;
#line 536
    ldv_1_data_data = arg3;
#line 539
    ldv_switch_automaton_state_1_6();
    }
  }
#line 541
  return;
}
}
#line 545 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_register_14_2(struct pci_driver *arg0 ) 
{ 


  {
  {
#line 548
  ldv_3_container_pci_driver = arg0;
#line 551
  ldv_switch_automaton_state_3_20();
  }
#line 552
  return;
}
}
#line 556 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_register_9_4(struct net_device *arg0 ) 
{ 


  {
  {
#line 559
  ldv_2_container_net_device = arg0;
#line 562
  ldv_switch_automaton_state_2_5();
  }
#line 563
  return;
}
}
#line 567 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_register_dummy_factory_13_15_5(void) 
{ 


  {
  {
#line 571
  ldv_switch_automaton_state_5_4();
  }
#line 572
  return;
}
}
#line 576 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_34(int (*arg0)(struct sk_buff * ,
                                                               unsigned int  , unsigned int  ,
                                                               struct net_device * ,
                                                               unsigned int  ) , struct sk_buff *arg1 ,
                                                   unsigned int arg2 , unsigned int arg3 ,
                                                   struct net_device *arg4 , unsigned int arg5 ) 
{ 


  {
  {
#line 577
  be_ndo_bridge_getlink(arg1, arg2, arg3, arg4, arg5);
  }
#line 578
  return;
}
}
#line 581 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_37(int (*arg0)(struct net_device * ,
                                                               struct nlmsghdr * ) ,
                                                   struct net_device *arg1 , struct nlmsghdr *arg2 ) 
{ 


  {
  {
#line 582
  be_ndo_bridge_setlink(arg1, arg2);
  }
#line 583
  return;
}
}
#line 586 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_38(int (*arg0)(struct napi_struct * ) ,
                                                   struct napi_struct *arg1 ) 
{ 


  {
  {
#line 587
  be_busy_poll(arg1);
  }
#line 588
  return;
}
}
#line 591 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_39(int (*arg0)(struct net_device * ,
                                                               int  ) , struct net_device *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 592
  be_change_mtu(arg1, arg2);
  }
#line 593
  return;
}
}
#line 596 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_42(struct rtnl_link_stats64 *(*arg0)(struct net_device * ,
                                                                                     struct rtnl_link_stats64 * ) ,
                                                   struct net_device *arg1 , struct rtnl_link_stats64 *arg2 ) 
{ 


  {
  {
#line 597
  be_get_stats64(arg1, arg2);
  }
#line 598
  return;
}
}
#line 601 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_43(int (*arg0)(struct net_device * ,
                                                               int  , struct ifla_vf_info * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   struct ifla_vf_info *arg3 ) 
{ 


  {
  {
#line 602
  be_get_vf_config(arg1, arg2, arg3);
  }
#line 603
  return;
}
}
#line 606 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_46(void (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 607
  be_netpoll(arg1);
  }
#line 608
  return;
}
}
#line 611 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_47(int (*arg0)(struct net_device * ,
                                                               void * ) , struct net_device *arg1 ,
                                                   void *arg2 ) 
{ 


  {
  {
#line 612
  be_mac_addr_set(arg1, arg2);
  }
#line 613
  return;
}
}
#line 616 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_48(void (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 617
  be_set_rx_mode(arg1);
  }
#line 618
  return;
}
}
#line 621 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_49(int (*arg0)(struct net_device * ,
                                                               int  , unsigned char * ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 622
  be_set_vf_mac(arg1, arg2, arg3);
  }
#line 623
  return;
}
}
#line 626 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_52(int (*arg0)(struct net_device * ,
                                                               int  , int  ) , struct net_device *arg1 ,
                                                   int arg2 , int arg3 ) 
{ 


  {
  {
#line 627
  be_set_vf_tx_rate(arg1, arg2, arg3);
  }
#line 628
  return;
}
}
#line 631 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_55(int (*arg0)(struct net_device * ,
                                                               int  , unsigned short  ,
                                                               unsigned char  ) ,
                                                   struct net_device *arg1 , int arg2 ,
                                                   unsigned short arg3 , unsigned char arg4 ) 
{ 


  {
  {
#line 632
  be_set_vf_vlan(arg1, arg2, (int )arg3, (int )arg4);
  }
#line 633
  return;
}
}
#line 636 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_58(enum netdev_tx (*arg0)(struct sk_buff * ,
                                                                          struct net_device * ) ,
                                                   struct sk_buff *arg1 , struct net_device *arg2 ) 
{ 


  {
  {
#line 637
  be_xmit(arg1, arg2);
  }
#line 638
  return;
}
}
#line 641 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_59(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 642
  eth_validate_addr(arg1);
  }
#line 643
  return;
}
}
#line 646 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_60(int (*arg0)(struct net_device * ,
                                                               unsigned short  , unsigned short  ) ,
                                                   struct net_device *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 ) 
{ 


  {
  {
#line 647
  be_vlan_add_vid(arg1, (int )arg2, (int )arg3);
  }
#line 648
  return;
}
}
#line 651 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_2_63(int (*arg0)(struct net_device * ,
                                                               unsigned short  , unsigned short  ) ,
                                                   struct net_device *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 ) 
{ 


  {
  {
#line 652
  be_vlan_rem_vid(arg1, (int )arg2, (int )arg3);
  }
#line 653
  return;
}
}
#line 656 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_entry_EMGentry_15(void *arg0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 662
  if (ldv_statevar_15 == 2) {
#line 662
    goto case_2;
  } else {

  }
#line 680
  if (ldv_statevar_15 == 3) {
#line 680
    goto case_3;
  } else {

  }
#line 701
  if (ldv_statevar_15 == 4) {
#line 701
    goto case_4;
  } else {

  }
#line 711
  if (ldv_statevar_15 == 5) {
#line 711
    goto case_5;
  } else {

  }
#line 721
  if (ldv_statevar_15 == 6) {
#line 721
    goto case_6;
  } else {

  }
#line 733
  if (ldv_statevar_15 == 8) {
#line 733
    goto case_8;
  } else {

  }
#line 749
  if (ldv_statevar_15 == 9) {
#line 749
    goto case_9;
  } else {

  }
#line 765
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 664
  ldv_assume(ldv_statevar_3 == 12);
#line 666
  ldv_EMGentry_exit_be_exit_module_15_2(ldv_15_exit_be_exit_module_default);
#line 670
  ldv_check_final_state();
#line 671
  ldv_stop();
#line 677
  ldv_statevar_15 = 9;
  }
#line 678
  goto ldv_56494;
  case_3: /* CIL Label */ 
  {
#line 685
  ldv_assume(ldv_statevar_3 == 12);
#line 687
  ldv_EMGentry_exit_be_exit_module_15_2(ldv_15_exit_be_exit_module_default);
#line 691
  ldv_check_final_state();
#line 692
  ldv_stop();
#line 698
  ldv_statevar_15 = 9;
  }
#line 699
  goto ldv_56494;
  case_4: /* CIL Label */ 
  {
#line 703
  ldv_assume(ldv_statevar_5 == 2);
#line 704
  ldv_dispatch_deregister_dummy_factory_13_15_4();
#line 708
  ldv_statevar_15 = 2;
  }
#line 709
  goto ldv_56494;
  case_5: /* CIL Label */ 
  {
#line 713
  ldv_assume(ldv_statevar_5 == 4);
#line 714
  ldv_dispatch_register_dummy_factory_13_15_5();
#line 718
  ldv_statevar_15 = 4;
  }
#line 719
  goto ldv_56494;
  case_6: /* CIL Label */ 
  {
#line 723
  ldv_assume(ldv_15_ret_default == 0);
#line 727
  tmp = ldv_undef_int();
  }
#line 727
  if (tmp != 0) {
#line 728
    ldv_statevar_15 = 3;
  } else {
#line 730
    ldv_statevar_15 = 5;
  }
#line 731
  goto ldv_56494;
  case_8: /* CIL Label */ 
  {
#line 735
  ldv_assume(ldv_15_ret_default != 0);
#line 739
  ldv_check_final_state();
#line 740
  ldv_stop();
#line 746
  ldv_statevar_15 = 9;
  }
#line 747
  goto ldv_56494;
  case_9: /* CIL Label */ 
  {
#line 751
  ldv_assume(ldv_statevar_3 == 20);
#line 753
  ldv_15_ret_default = ldv_EMGentry_init_be_init_module_15_9(ldv_15_init_be_init_module_default);
#line 755
  ldv_15_ret_default = ldv_post_init(ldv_15_ret_default);
#line 759
  tmp___0 = ldv_undef_int();
  }
#line 759
  if (tmp___0 != 0) {
#line 760
    ldv_statevar_15 = 6;
  } else {
#line 762
    ldv_statevar_15 = 8;
  }
#line 763
  goto ldv_56494;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  ldv_56494: ;
#line 769
  return;
}
}
#line 771 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void main(void) 
{ 
  int tmp ;

  {
  {
#line 772
  ldv_initialize();
#line 774
  ldv_initialize_external_data();
#line 776
  ldv_statevar_15 = 9;
#line 778
  ldv_statevar_0 = 6;
#line 780
  ldv_statevar_1 = 6;
#line 782
  ldv_statevar_2 = 5;
#line 785
  ldv_3_ret_default = 1;
#line 786
  ldv_statevar_3 = 20;
#line 788
  ldv_statevar_4 = 3;
#line 790
  ldv_statevar_5 = 4;
  }
  ldv_56513: 
  {
#line 792
  tmp = ldv_undef_int();
  }
  {
#line 793
  if (tmp == 0) {
#line 793
    goto case_0;
  } else {

  }
#line 796
  if (tmp == 1) {
#line 796
    goto case_1;
  } else {

  }
#line 799
  if (tmp == 2) {
#line 799
    goto case_2;
  } else {

  }
#line 802
  if (tmp == 3) {
#line 802
    goto case_3;
  } else {

  }
#line 805
  if (tmp == 4) {
#line 805
    goto case_4;
  } else {

  }
#line 808
  if (tmp == 5) {
#line 808
    goto case_5;
  } else {

  }
#line 811
  if (tmp == 6) {
#line 811
    goto case_6;
  } else {

  }
#line 814
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 794
  ldv_entry_EMGentry_15((void *)0);
  }
#line 795
  goto ldv_56505;
  case_1: /* CIL Label */ 
  {
#line 797
  ldv_interrupt_interrupt_instance_0((void *)0);
  }
#line 798
  goto ldv_56505;
  case_2: /* CIL Label */ 
  {
#line 800
  ldv_interrupt_interrupt_instance_1((void *)0);
  }
#line 801
  goto ldv_56505;
  case_3: /* CIL Label */ 
  {
#line 803
  ldv_net_dummy_resourceless_instance_2((void *)0);
  }
#line 804
  goto ldv_56505;
  case_4: /* CIL Label */ 
  {
#line 806
  ldv_pci_pci_instance_3((void *)0);
  }
#line 807
  goto ldv_56505;
  case_5: /* CIL Label */ 
  {
#line 809
  ldv_timer_timer_instance_4((void *)0);
  }
#line 810
  goto ldv_56505;
  case_6: /* CIL Label */ 
  {
#line 812
  ldv_timer_dummy_factory_5((void *)0);
  }
#line 813
  goto ldv_56505;
  switch_default: /* CIL Label */ 
  {
#line 814
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_56505: ;
#line 816
  goto ldv_56513;
}
}
#line 820 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) 
{ 
  int ldv_7_line_line ;

  {
  {
#line 826
  ldv_7_line_line = arg1;
#line 830
  ldv_assume(ldv_statevar_0 == 2 || ldv_statevar_1 == 2);
#line 831
  ldv_dispatch_irq_deregister_7_1(ldv_7_line_line);
  }
#line 835
  return;
#line 837
  return;
}
}
#line 842 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_free_netdev(void *arg0 , struct net_device *arg1 ) 
{ 
  struct net_device *ldv_8_netdev_net_device ;

  {
  {
#line 848
  ldv_8_netdev_net_device = arg1;
#line 849
  ldv_free((void *)ldv_8_netdev_net_device);
  }
#line 853
  return;
#line 855
  return;
}
}
#line 860 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_initialize_external_data(void) 
{ 


  {
  {
#line 861
  ldv_allocate_external_0();
  }
#line 862
  return;
}
}
#line 865 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum irqreturn ldv_interrupt_instance_handler_0_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 866
  tmp = be_intx(arg1, arg2);
  }
#line 866
  return (tmp);
}
}
#line 870 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
enum irqreturn ldv_interrupt_instance_handler_1_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 871
  tmp = be_msix(arg1, arg2);
  }
#line 871
  return (tmp);
}
}
#line 875 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_instance_thread_0_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 876
  (*arg0)(arg1, arg2);
  }
#line 877
  return;
}
}
#line 880 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_instance_thread_1_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 881
  (*arg0)(arg1, arg2);
  }
#line 882
  return;
}
}
#line 885 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_interrupt_instance_0(void *arg0 ) 
{ 
  int tmp ;

  {
  {
#line 891
  if (ldv_statevar_0 == 2) {
#line 891
    goto case_2;
  } else {

  }
#line 906
  if (ldv_statevar_0 == 4) {
#line 906
    goto case_4;
  } else {

  }
#line 928
  if (ldv_statevar_0 == 5) {
#line 928
    goto case_5;
  } else {

  }
#line 945
  if (ldv_statevar_0 == 6) {
#line 945
    goto case_6;
  } else {

  }
#line 953
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 893
  ldv_assume((unsigned int )ldv_0_ret_val_default != 2U);
#line 903
  ldv_statevar_0 = 6;
  }
#line 904
  goto ldv_56559;
  case_4: /* CIL Label */ 
  {
#line 908
  ldv_assume((unsigned int )ldv_0_ret_val_default == 2U);
  }
#line 912
  if ((unsigned long )ldv_0_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                  void * ))0)) {
    {
#line 914
    ldv_interrupt_instance_thread_0_3(ldv_0_thread_thread, ldv_0_line_line, ldv_0_data_data);
    }
  } else {

  }
#line 925
  ldv_statevar_0 = 6;
#line 926
  goto ldv_56559;
  case_5: /* CIL Label */ 
  {
#line 931
  ldv_switch_to_interrupt_context();
#line 933
  ldv_0_ret_val_default = ldv_interrupt_instance_handler_0_5(ldv_0_callback_handler,
                                                             ldv_0_line_line, ldv_0_data_data);
#line 935
  ldv_switch_to_process_context();
#line 939
  tmp = ldv_undef_int();
  }
#line 939
  if (tmp != 0) {
#line 940
    ldv_statevar_0 = 2;
  } else {
#line 942
    ldv_statevar_0 = 4;
  }
#line 943
  goto ldv_56559;
  case_6: /* CIL Label */ ;
#line 951
  goto ldv_56559;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  ldv_56559: ;
#line 957
  return;
}
}
#line 959 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_interrupt_instance_1(void *arg0 ) 
{ 
  int tmp ;

  {
  {
#line 965
  if (ldv_statevar_1 == 2) {
#line 965
    goto case_2;
  } else {

  }
#line 980
  if (ldv_statevar_1 == 4) {
#line 980
    goto case_4;
  } else {

  }
#line 1002
  if (ldv_statevar_1 == 5) {
#line 1002
    goto case_5;
  } else {

  }
#line 1019
  if (ldv_statevar_1 == 6) {
#line 1019
    goto case_6;
  } else {

  }
#line 1027
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 967
  ldv_assume((unsigned int )ldv_1_ret_val_default != 2U);
#line 977
  ldv_statevar_1 = 6;
  }
#line 978
  goto ldv_56568;
  case_4: /* CIL Label */ 
  {
#line 982
  ldv_assume((unsigned int )ldv_1_ret_val_default == 2U);
  }
#line 986
  if ((unsigned long )ldv_1_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                  void * ))0)) {
    {
#line 988
    ldv_interrupt_instance_thread_1_3(ldv_1_thread_thread, ldv_1_line_line, ldv_1_data_data);
    }
  } else {

  }
#line 999
  ldv_statevar_1 = 6;
#line 1000
  goto ldv_56568;
  case_5: /* CIL Label */ 
  {
#line 1005
  ldv_switch_to_interrupt_context();
#line 1007
  ldv_1_ret_val_default = ldv_interrupt_instance_handler_1_5(ldv_1_callback_handler,
                                                             ldv_1_line_line, ldv_1_data_data);
#line 1009
  ldv_switch_to_process_context();
#line 1013
  tmp = ldv_undef_int();
  }
#line 1013
  if (tmp != 0) {
#line 1014
    ldv_statevar_1 = 2;
  } else {
#line 1016
    ldv_statevar_1 = 4;
  }
#line 1017
  goto ldv_56568;
  case_6: /* CIL Label */ ;
#line 1025
  goto ldv_56568;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  ldv_56568: ;
#line 1031
  return;
}
}
#line 1033 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_net_dummy_resourceless_instance_2(void *arg0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 1039
  if (ldv_statevar_2 == 1) {
#line 1039
    goto case_1;
  } else {

  }
#line 1047
  if (ldv_statevar_2 == 2) {
#line 1047
    goto case_2;
  } else {

  }
#line 1057
  if (ldv_statevar_2 == 3) {
#line 1057
    goto case_3;
  } else {

  }
#line 1067
  if (ldv_statevar_2 == 4) {
#line 1067
    goto case_4;
  } else {

  }
#line 1077
  if (ldv_statevar_2 == 5) {
#line 1077
    goto case_5;
  } else {

  }
#line 1085
  if (ldv_statevar_2 == 7) {
#line 1085
    goto case_7;
  } else {

  }
#line 1095
  if (ldv_statevar_2 == 8) {
#line 1095
    goto case_8;
  } else {

  }
#line 1105
  if (ldv_statevar_2 == 9) {
#line 1105
    goto case_9;
  } else {

  }
#line 1115
  if (ldv_statevar_2 == 11) {
#line 1115
    goto case_11;
  } else {

  }
#line 1133
  if (ldv_statevar_2 == 13) {
#line 1133
    goto case_13;
  } else {

  }
#line 1143
  if (ldv_statevar_2 == 15) {
#line 1143
    goto case_15;
  } else {

  }
#line 1161
  if (ldv_statevar_2 == 17) {
#line 1161
    goto case_17;
  } else {

  }
#line 1171
  if (ldv_statevar_2 == 18) {
#line 1171
    goto case_18;
  } else {

  }
#line 1181
  if (ldv_statevar_2 == 19) {
#line 1181
    goto case_19;
  } else {

  }
#line 1191
  if (ldv_statevar_2 == 20) {
#line 1191
    goto case_20;
  } else {

  }
#line 1201
  if (ldv_statevar_2 == 21) {
#line 1201
    goto case_21;
  } else {

  }
#line 1211
  if (ldv_statevar_2 == 22) {
#line 1211
    goto case_22;
  } else {

  }
#line 1221
  if (ldv_statevar_2 == 24) {
#line 1221
    goto case_24;
  } else {

  }
#line 1239
  if (ldv_statevar_2 == 26) {
#line 1239
    goto case_26;
  } else {

  }
#line 1249
  if (ldv_statevar_2 == 28) {
#line 1249
    goto case_28;
  } else {

  }
#line 1265
  if (ldv_statevar_2 == 31) {
#line 1265
    goto case_31;
  } else {

  }
#line 1283
  if (ldv_statevar_2 == 33) {
#line 1283
    goto case_33;
  } else {

  }
#line 1293
  if (ldv_statevar_2 == 35) {
#line 1293
    goto case_35;
  } else {

  }
#line 1309
  if (ldv_statevar_2 == 37) {
#line 1309
    goto case_37;
  } else {

  }
#line 1319
  if (ldv_statevar_2 == 38) {
#line 1319
    goto case_38;
  } else {

  }
#line 1329
  if (ldv_statevar_2 == 40) {
#line 1329
    goto case_40;
  } else {

  }
#line 1345
  if (ldv_statevar_2 == 42) {
#line 1345
    goto case_42;
  } else {

  }
#line 1355
  if (ldv_statevar_2 == 44) {
#line 1355
    goto case_44;
  } else {

  }
#line 1371
  if (ldv_statevar_2 == 46) {
#line 1371
    goto case_46;
  } else {

  }
#line 1381
  if (ldv_statevar_2 == 47) {
#line 1381
    goto case_47;
  } else {

  }
#line 1391
  if (ldv_statevar_2 == 48) {
#line 1391
    goto case_48;
  } else {

  }
#line 1401
  if (ldv_statevar_2 == 50) {
#line 1401
    goto case_50;
  } else {

  }
#line 1419
  if (ldv_statevar_2 == 53) {
#line 1419
    goto case_53;
  } else {

  }
#line 1435
  if (ldv_statevar_2 == 56) {
#line 1435
    goto case_56;
  } else {

  }
#line 1451
  if (ldv_statevar_2 == 58) {
#line 1451
    goto case_58;
  } else {

  }
#line 1461
  if (ldv_statevar_2 == 59) {
#line 1461
    goto case_59;
  } else {

  }
#line 1471
  if (ldv_statevar_2 == 61) {
#line 1471
    goto case_61;
  } else {

  }
#line 1487
  if (ldv_statevar_2 == 64) {
#line 1487
    goto case_64;
  } else {

  }
#line 1503
  if (ldv_statevar_2 == 67) {
#line 1503
    goto case_67;
  } else {

  }
#line 1521
  if (ldv_statevar_2 == 69) {
#line 1521
    goto case_69;
  } else {

  }
#line 1531
  if (ldv_statevar_2 == 70) {
#line 1531
    goto case_70;
  } else {

  }
#line 1541
  if (ldv_statevar_2 == 71) {
#line 1541
    goto case_71;
  } else {

  }
#line 1551
  if (ldv_statevar_2 == 73) {
#line 1551
    goto case_73;
  } else {

  }
#line 1567
  if (ldv_statevar_2 == 75) {
#line 1567
    goto case_75;
  } else {

  }
#line 1577
  if (ldv_statevar_2 == 76) {
#line 1577
    goto case_76;
  } else {

  }
#line 1587
  if (ldv_statevar_2 == 77) {
#line 1587
    goto case_77;
  } else {

  }
#line 1597
  if (ldv_statevar_2 == 78) {
#line 1597
    goto case_78;
  } else {

  }
#line 1607
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 1045
  goto ldv_56577;
  case_2: /* CIL Label */ 
  {
#line 1054
  ldv_statevar_2 = ldv_switch_0();
  }
#line 1055
  goto ldv_56577;
  case_3: /* CIL Label */ 
  {
#line 1060
  ldv_dummy_resourceless_instance_callback_2_3(ldv_2_callback_flash_device, ldv_2_container_net_device,
                                               ldv_2_container_struct_ethtool_flash_ptr);
#line 1064
  ldv_statevar_2 = 2;
  }
#line 1065
  goto ldv_56577;
  case_4: /* CIL Label */ 
  {
#line 1074
  ldv_statevar_2 = ldv_switch_0();
  }
#line 1075
  goto ldv_56577;
  case_5: /* CIL Label */ ;
#line 1083
  goto ldv_56577;
  case_7: /* CIL Label */ 
  {
#line 1088
  ldv_dummy_resourceless_instance_callback_2_7(ldv_2_callback_get_channels, ldv_2_container_net_device,
                                               ldv_2_container_struct_ethtool_channels_ptr);
#line 1092
  ldv_statevar_2 = 2;
  }
#line 1093
  goto ldv_56577;
  case_8: /* CIL Label */ 
  {
#line 1098
  ldv_dummy_resourceless_instance_callback_2_8(ldv_2_callback_get_coalesce, ldv_2_container_net_device,
                                               ldv_2_container_struct_ethtool_coalesce_ptr);
#line 1102
  ldv_statevar_2 = 2;
  }
#line 1103
  goto ldv_56577;
  case_9: /* CIL Label */ 
  {
#line 1108
  ldv_dummy_resourceless_instance_callback_2_9(ldv_2_callback_get_drvinfo, ldv_2_container_net_device,
                                               ldv_2_container_struct_ethtool_drvinfo_ptr);
#line 1112
  ldv_statevar_2 = 2;
  }
#line 1113
  goto ldv_56577;
  case_11: /* CIL Label */ 
  {
#line 1117
  tmp = ldv_xmalloc(1UL);
#line 1117
  ldv_2_ldv_param_10_2_default = (unsigned char *)tmp;
#line 1122
  ldv_dummy_resourceless_instance_callback_2_10(ldv_2_callback_get_eeprom, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_eeprom_ptr,
                                                ldv_2_ldv_param_10_2_default);
#line 1126
  ldv_free((void *)ldv_2_ldv_param_10_2_default);
#line 1130
  ldv_statevar_2 = 2;
  }
#line 1131
  goto ldv_56577;
  case_13: /* CIL Label */ 
  {
#line 1136
  ldv_dummy_resourceless_instance_callback_2_13(ldv_2_callback_get_eeprom_len, ldv_2_container_net_device);
#line 1140
  ldv_statevar_2 = 2;
  }
#line 1141
  goto ldv_56577;
  case_15: /* CIL Label */ 
  {
#line 1145
  tmp___0 = ldv_xmalloc(8UL);
#line 1145
  ldv_2_ldv_param_14_2_default = (unsigned long long *)tmp___0;
#line 1150
  ldv_dummy_resourceless_instance_callback_2_14(ldv_2_callback_get_ethtool_stats,
                                                ldv_2_container_net_device, ldv_2_container_struct_ethtool_stats_ptr,
                                                ldv_2_ldv_param_14_2_default);
#line 1154
  ldv_free((void *)ldv_2_ldv_param_14_2_default);
#line 1158
  ldv_statevar_2 = 2;
  }
#line 1159
  goto ldv_56577;
  case_17: /* CIL Label */ 
  {
#line 1164
  ldv_dummy_resourceless_instance_callback_2_17(ldv_2_callback_get_link, ldv_2_container_net_device);
#line 1168
  ldv_statevar_2 = 2;
  }
#line 1169
  goto ldv_56577;
  case_18: /* CIL Label */ 
  {
#line 1174
  ldv_dummy_resourceless_instance_callback_2_18(ldv_2_callback_get_msglevel, ldv_2_container_net_device);
#line 1178
  ldv_statevar_2 = 2;
  }
#line 1179
  goto ldv_56577;
  case_19: /* CIL Label */ 
  {
#line 1184
  ldv_dummy_resourceless_instance_callback_2_19(ldv_2_callback_get_pauseparam, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_pauseparam_ptr);
#line 1188
  ldv_statevar_2 = 2;
  }
#line 1189
  goto ldv_56577;
  case_20: /* CIL Label */ 
  {
#line 1194
  ldv_dummy_resourceless_instance_callback_2_20(ldv_2_callback_get_regs, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_regs_ptr,
                                                (void *)ldv_2_container_struct_ethtool_channels_ptr);
#line 1198
  ldv_statevar_2 = 2;
  }
#line 1199
  goto ldv_56577;
  case_21: /* CIL Label */ 
  {
#line 1204
  ldv_dummy_resourceless_instance_callback_2_21(ldv_2_callback_get_regs_len, ldv_2_container_net_device);
#line 1208
  ldv_statevar_2 = 2;
  }
#line 1209
  goto ldv_56577;
  case_22: /* CIL Label */ 
  {
#line 1214
  ldv_dummy_resourceless_instance_callback_2_22(ldv_2_callback_get_ringparam, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_ringparam_ptr);
#line 1218
  ldv_statevar_2 = 2;
  }
#line 1219
  goto ldv_56577;
  case_24: /* CIL Label */ 
  {
#line 1223
  tmp___1 = ldv_xmalloc(4UL);
#line 1223
  ldv_2_ldv_param_23_2_default = (unsigned int *)tmp___1;
#line 1228
  ldv_dummy_resourceless_instance_callback_2_23(ldv_2_callback_get_rxnfc, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_rxnfc_ptr,
                                                ldv_2_ldv_param_23_2_default);
#line 1232
  ldv_free((void *)ldv_2_ldv_param_23_2_default);
#line 1236
  ldv_statevar_2 = 2;
  }
#line 1237
  goto ldv_56577;
  case_26: /* CIL Label */ 
  {
#line 1242
  ldv_dummy_resourceless_instance_callback_2_26(ldv_2_callback_get_settings, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_cmd_ptr);
#line 1246
  ldv_statevar_2 = 2;
  }
#line 1247
  goto ldv_56577;
  case_28: /* CIL Label */ 
  {
#line 1255
  ldv_dummy_resourceless_instance_callback_2_27(ldv_2_callback_get_sset_count, ldv_2_container_net_device,
                                                ldv_2_ldv_param_27_1_default);
#line 1262
  ldv_statevar_2 = 2;
  }
#line 1263
  goto ldv_56577;
  case_31: /* CIL Label */ 
  {
#line 1267
  tmp___2 = ldv_xmalloc(1UL);
#line 1267
  ldv_2_ldv_param_30_2_default = (unsigned char *)tmp___2;
#line 1272
  ldv_dummy_resourceless_instance_callback_2_30(ldv_2_callback_get_strings, ldv_2_container_net_device,
                                                ldv_2_ldv_param_30_1_default, ldv_2_ldv_param_30_2_default);
#line 1276
  ldv_free((void *)ldv_2_ldv_param_30_2_default);
#line 1280
  ldv_statevar_2 = 2;
  }
#line 1281
  goto ldv_56577;
  case_33: /* CIL Label */ 
  {
#line 1286
  ldv_dummy_resourceless_instance_callback_2_33(ldv_2_callback_get_wol, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_wolinfo_ptr);
#line 1290
  ldv_statevar_2 = 2;
  }
#line 1291
  goto ldv_56577;
  case_35: /* CIL Label */ 
  {
#line 1299
  ldv_dummy_resourceless_instance_callback_2_34(ldv_2_callback_ndo_bridge_getlink,
                                                ldv_2_container_struct_sk_buff_ptr,
                                                ldv_2_ldv_param_34_1_default, ldv_2_ldv_param_34_2_default,
                                                ldv_2_container_net_device, ldv_2_ldv_param_34_4_default);
#line 1306
  ldv_statevar_2 = 2;
  }
#line 1307
  goto ldv_56577;
  case_37: /* CIL Label */ 
  {
#line 1312
  ldv_dummy_resourceless_instance_callback_2_37(ldv_2_callback_ndo_bridge_setlink,
                                                ldv_2_container_net_device, ldv_2_container_struct_nlmsghdr_ptr);
#line 1316
  ldv_statevar_2 = 2;
  }
#line 1317
  goto ldv_56577;
  case_38: /* CIL Label */ 
  {
#line 1322
  ldv_dummy_resourceless_instance_callback_2_38(ldv_2_callback_ndo_busy_poll, ldv_2_container_struct_napi_struct_ptr);
#line 1326
  ldv_statevar_2 = 2;
  }
#line 1327
  goto ldv_56577;
  case_40: /* CIL Label */ 
  {
#line 1335
  ldv_dummy_resourceless_instance_callback_2_39(ldv_2_callback_ndo_change_mtu, ldv_2_container_net_device,
                                                ldv_2_ldv_param_39_1_default);
#line 1342
  ldv_statevar_2 = 2;
  }
#line 1343
  goto ldv_56577;
  case_42: /* CIL Label */ 
  {
#line 1348
  ldv_dummy_resourceless_instance_callback_2_42(ldv_2_callback_ndo_get_stats64, ldv_2_container_net_device,
                                                ldv_2_container_struct_rtnl_link_stats64_ptr);
#line 1352
  ldv_statevar_2 = 2;
  }
#line 1353
  goto ldv_56577;
  case_44: /* CIL Label */ 
  {
#line 1361
  ldv_dummy_resourceless_instance_callback_2_43(ldv_2_callback_ndo_get_vf_config,
                                                ldv_2_container_net_device, ldv_2_ldv_param_43_1_default,
                                                ldv_2_container_struct_ifla_vf_info_ptr);
#line 1368
  ldv_statevar_2 = 2;
  }
#line 1369
  goto ldv_56577;
  case_46: /* CIL Label */ 
  {
#line 1374
  ldv_dummy_resourceless_instance_callback_2_46(ldv_2_callback_ndo_poll_controller,
                                                ldv_2_container_net_device);
#line 1378
  ldv_statevar_2 = 2;
  }
#line 1379
  goto ldv_56577;
  case_47: /* CIL Label */ 
  {
#line 1384
  ldv_dummy_resourceless_instance_callback_2_47(ldv_2_callback_ndo_set_mac_address,
                                                ldv_2_container_net_device, (void *)ldv_2_container_struct_ethtool_channels_ptr);
#line 1388
  ldv_statevar_2 = 2;
  }
#line 1389
  goto ldv_56577;
  case_48: /* CIL Label */ 
  {
#line 1394
  ldv_dummy_resourceless_instance_callback_2_48(ldv_2_callback_ndo_set_rx_mode, ldv_2_container_net_device);
#line 1398
  ldv_statevar_2 = 2;
  }
#line 1399
  goto ldv_56577;
  case_50: /* CIL Label */ 
  {
#line 1403
  tmp___3 = ldv_xmalloc(1UL);
#line 1403
  ldv_2_ldv_param_49_2_default = (unsigned char *)tmp___3;
#line 1408
  ldv_dummy_resourceless_instance_callback_2_49(ldv_2_callback_ndo_set_vf_mac, ldv_2_container_net_device,
                                                ldv_2_ldv_param_49_1_default, ldv_2_ldv_param_49_2_default);
#line 1412
  ldv_free((void *)ldv_2_ldv_param_49_2_default);
#line 1416
  ldv_statevar_2 = 2;
  }
#line 1417
  goto ldv_56577;
  case_53: /* CIL Label */ 
  {
#line 1425
  ldv_dummy_resourceless_instance_callback_2_52(ldv_2_callback_ndo_set_vf_tx_rate,
                                                ldv_2_container_net_device, ldv_2_ldv_param_52_1_default,
                                                ldv_2_ldv_param_52_2_default);
#line 1432
  ldv_statevar_2 = 2;
  }
#line 1433
  goto ldv_56577;
  case_56: /* CIL Label */ 
  {
#line 1441
  ldv_dummy_resourceless_instance_callback_2_55(ldv_2_callback_ndo_set_vf_vlan, ldv_2_container_net_device,
                                                ldv_2_ldv_param_55_1_default, (int )ldv_2_ldv_param_55_2_default,
                                                (int )ldv_2_ldv_param_55_3_default);
#line 1448
  ldv_statevar_2 = 2;
  }
#line 1449
  goto ldv_56577;
  case_58: /* CIL Label */ 
  {
#line 1454
  ldv_dummy_resourceless_instance_callback_2_58(ldv_2_callback_ndo_start_xmit, ldv_2_container_struct_sk_buff_ptr,
                                                ldv_2_container_net_device);
#line 1458
  ldv_statevar_2 = 2;
  }
#line 1459
  goto ldv_56577;
  case_59: /* CIL Label */ 
  {
#line 1464
  ldv_dummy_resourceless_instance_callback_2_59(ldv_2_callback_ndo_validate_addr,
                                                ldv_2_container_net_device);
#line 1468
  ldv_statevar_2 = 2;
  }
#line 1469
  goto ldv_56577;
  case_61: /* CIL Label */ 
  {
#line 1477
  ldv_dummy_resourceless_instance_callback_2_60(ldv_2_callback_ndo_vlan_rx_add_vid,
                                                ldv_2_container_net_device, (int )ldv_2_ldv_param_60_1_default,
                                                (int )ldv_2_ldv_param_60_2_default);
#line 1484
  ldv_statevar_2 = 2;
  }
#line 1485
  goto ldv_56577;
  case_64: /* CIL Label */ 
  {
#line 1493
  ldv_dummy_resourceless_instance_callback_2_63(ldv_2_callback_ndo_vlan_rx_kill_vid,
                                                ldv_2_container_net_device, (int )ldv_2_ldv_param_63_1_default,
                                                (int )ldv_2_ldv_param_63_2_default);
#line 1500
  ldv_statevar_2 = 2;
  }
#line 1501
  goto ldv_56577;
  case_67: /* CIL Label */ 
  {
#line 1505
  tmp___4 = ldv_xmalloc(8UL);
#line 1505
  ldv_2_ldv_param_66_2_default = (unsigned long long *)tmp___4;
#line 1510
  ldv_dummy_resourceless_instance_callback_2_66(ldv_2_callback_self_test, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_test_ptr,
                                                ldv_2_ldv_param_66_2_default);
#line 1514
  ldv_free((void *)ldv_2_ldv_param_66_2_default);
#line 1518
  ldv_statevar_2 = 2;
  }
#line 1519
  goto ldv_56577;
  case_69: /* CIL Label */ 
  {
#line 1524
  ldv_dummy_resourceless_instance_callback_2_69(ldv_2_callback_set_channels, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_channels_ptr);
#line 1528
  ldv_statevar_2 = 2;
  }
#line 1529
  goto ldv_56577;
  case_70: /* CIL Label */ 
  {
#line 1534
  ldv_dummy_resourceless_instance_callback_2_70(ldv_2_callback_set_coalesce, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_coalesce_ptr);
#line 1538
  ldv_statevar_2 = 2;
  }
#line 1539
  goto ldv_56577;
  case_71: /* CIL Label */ 
  {
#line 1544
  ldv_dummy_resourceless_instance_callback_2_71(ldv_2_callback_set_dump, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_dump_ptr);
#line 1548
  ldv_statevar_2 = 2;
  }
#line 1549
  goto ldv_56577;
  case_73: /* CIL Label */ 
  {
#line 1557
  ldv_dummy_resourceless_instance_callback_2_72(ldv_2_callback_set_msglevel, ldv_2_container_net_device,
                                                ldv_2_ldv_param_72_1_default);
#line 1564
  ldv_statevar_2 = 2;
  }
#line 1565
  goto ldv_56577;
  case_75: /* CIL Label */ 
  {
#line 1570
  ldv_dummy_resourceless_instance_callback_2_75(ldv_2_callback_set_pauseparam, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_pauseparam_ptr);
#line 1574
  ldv_statevar_2 = 2;
  }
#line 1575
  goto ldv_56577;
  case_76: /* CIL Label */ 
  {
#line 1580
  ldv_dummy_resourceless_instance_callback_2_76(ldv_2_callback_set_phys_id, ldv_2_container_net_device,
                                                ldv_2_container_enum_ethtool_phys_id_state);
#line 1584
  ldv_statevar_2 = 2;
  }
#line 1585
  goto ldv_56577;
  case_77: /* CIL Label */ 
  {
#line 1590
  ldv_dummy_resourceless_instance_callback_2_77(ldv_2_callback_set_rxnfc, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_rxnfc_ptr);
#line 1594
  ldv_statevar_2 = 2;
  }
#line 1595
  goto ldv_56577;
  case_78: /* CIL Label */ 
  {
#line 1600
  ldv_dummy_resourceless_instance_callback_2_78(ldv_2_callback_set_wol, ldv_2_container_net_device,
                                                ldv_2_container_struct_ethtool_wolinfo_ptr);
#line 1604
  ldv_statevar_2 = 2;
  }
#line 1605
  goto ldv_56577;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  ldv_56577: ;
#line 1611
  return;
}
}
#line 1613 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_callback_3_10(unsigned int (*arg0)(struct pci_dev * , enum pci_channel_state  ) ,
                                    struct pci_dev *arg1 , enum pci_channel_state arg2 ) 
{ 


  {
  {
#line 1614
  be_eeh_err_detected(arg1, (pci_channel_state_t )arg2);
  }
#line 1615
  return;
}
}
#line 1618 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_callback_3_23(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1619
  be_eeh_resume(arg1);
  }
#line 1620
  return;
}
}
#line 1623 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_callback_3_24(unsigned int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1624
  be_eeh_reset(arg1);
  }
#line 1625
  return;
}
}
#line 1628 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_pci_instance_probe_3_17(int (*arg0)(struct pci_dev * , struct pci_device_id * ) ,
                                struct pci_dev *arg1 , struct pci_device_id *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1629
  tmp = be_probe(arg1, (struct pci_device_id  const  *)arg2);
  }
#line 1629
  return (tmp);
}
}
#line 1633 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_release_3_2(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1634
  be_remove(arg1);
  }
#line 1635
  return;
}
}
#line 1638 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_resume_3_5(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1639
  be_resume(arg1);
  }
#line 1640
  return;
}
}
#line 1643 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_resume_early_3_6(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1644
  (*arg0)(arg1);
  }
#line 1645
  return;
}
}
#line 1648 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_shutdown_3_3(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1649
  be_shutdown(arg1);
  }
#line 1650
  return;
}
}
#line 1653 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_pci_instance_suspend_3_8(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                 struct pci_dev *arg1 , struct pm_message arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1654
  tmp = be_suspend(arg1, arg2);
  }
#line 1654
  return (tmp);
}
}
#line 1658 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_pci_instance_suspend_late_3_7(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                      struct pci_dev *arg1 , struct pm_message arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1659
  tmp = (*arg0)(arg1, arg2);
  }
#line 1659
  return (tmp);
}
}
#line 1663 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_pci_instance_3(void *arg0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1669
  if (ldv_statevar_3 == 1) {
#line 1669
    goto case_1;
  } else {

  }
#line 1682
  if (ldv_statevar_3 == 2) {
#line 1682
    goto case_2;
  } else {

  }
#line 1693
  if (ldv_statevar_3 == 3) {
#line 1693
    goto case_3;
  } else {

  }
#line 1703
  if (ldv_statevar_3 == 4) {
#line 1703
    goto case_4;
  } else {

  }
#line 1713
  if (ldv_statevar_3 == 5) {
#line 1713
    goto case_5;
  } else {

  }
#line 1724
  if (ldv_statevar_3 == 6) {
#line 1724
    goto case_6;
  } else {

  }
#line 1736
  if (ldv_statevar_3 == 7) {
#line 1736
    goto case_7;
  } else {

  }
#line 1750
  if (ldv_statevar_3 == 8) {
#line 1750
    goto case_8;
  } else {

  }
#line 1763
  if (ldv_statevar_3 == 9) {
#line 1763
    goto case_9;
  } else {

  }
#line 1773
  if (ldv_statevar_3 == 10) {
#line 1773
    goto case_10;
  } else {

  }
#line 1784
  if (ldv_statevar_3 == 12) {
#line 1784
    goto case_12;
  } else {

  }
#line 1802
  if (ldv_statevar_3 == 14) {
#line 1802
    goto case_14;
  } else {

  }
#line 1819
  if (ldv_statevar_3 == 16) {
#line 1819
    goto case_16;
  } else {

  }
#line 1833
  if (ldv_statevar_3 == 17) {
#line 1833
    goto case_17;
  } else {

  }
#line 1851
  if (ldv_statevar_3 == 19) {
#line 1851
    goto case_19;
  } else {

  }
#line 1869
  if (ldv_statevar_3 == 20) {
#line 1869
    goto case_20;
  } else {

  }
#line 1877
  if (ldv_statevar_3 == 23) {
#line 1877
    goto case_23;
  } else {

  }
#line 1888
  if (ldv_statevar_3 == 24) {
#line 1888
    goto case_24;
  } else {

  }
#line 1898
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1676
  tmp = ldv_undef_int();
  }
#line 1676
  if (tmp != 0) {
#line 1677
    ldv_statevar_3 = 12;
  } else {
#line 1679
    ldv_statevar_3 = 17;
  }
#line 1680
  goto ldv_56687;
  case_2: /* CIL Label */ 
  {
#line 1684
  ldv_assume(ldv_statevar_2 == 1);
#line 1686
  ldv_pci_instance_release_3_2(ldv_3_container_pci_driver->remove, ldv_3_resource_dev);
#line 1690
  ldv_statevar_3 = 1;
  }
#line 1691
  goto ldv_56687;
  case_3: /* CIL Label */ 
  {
#line 1696
  ldv_pci_instance_shutdown_3_3(ldv_3_container_pci_driver->shutdown, ldv_3_resource_dev);
#line 1700
  ldv_statevar_3 = 2;
  }
#line 1701
  goto ldv_56687;
  case_4: /* CIL Label */ 
  {
#line 1710
  ldv_statevar_3 = ldv_switch_1();
  }
#line 1711
  goto ldv_56687;
  case_5: /* CIL Label */ 
  {
#line 1715
  ldv_assume(ldv_statevar_0 == 6 || ldv_statevar_1 == 6);
#line 1717
  ldv_pci_instance_resume_3_5(ldv_3_container_pci_driver->resume, ldv_3_resource_dev);
#line 1721
  ldv_statevar_3 = 4;
  }
#line 1722
  goto ldv_56687;
  case_6: /* CIL Label */ ;
#line 1726
  if ((unsigned long )ldv_3_container_pci_driver->resume_early != (unsigned long )((int (*)(struct pci_dev * ))0)) {
    {
#line 1728
    ldv_pci_instance_resume_early_3_6(ldv_3_container_pci_driver->resume_early, ldv_3_resource_dev);
    }
  } else {

  }
#line 1733
  ldv_statevar_3 = 5;
#line 1734
  goto ldv_56687;
  case_7: /* CIL Label */ ;
#line 1738
  if ((unsigned long )ldv_3_container_pci_driver->suspend_late != (unsigned long )((int (*)(struct pci_dev * ,
                                                                                            pm_message_t  ))0)) {
    {
#line 1740
    ldv_3_ret_default = ldv_pci_instance_suspend_late_3_7(ldv_3_container_pci_driver->suspend_late,
                                                          ldv_3_resource_dev, ldv_3_resource_pm_message);
    }
  } else {

  }
  {
#line 1743
  ldv_3_ret_default = ldv_filter_err_code(ldv_3_ret_default);
#line 1747
  ldv_statevar_3 = 6;
  }
#line 1748
  goto ldv_56687;
  case_8: /* CIL Label */ 
  {
#line 1752
  ldv_assume(ldv_statevar_0 == 2 || ldv_statevar_1 == 2);
#line 1754
  ldv_3_ret_default = ldv_pci_instance_suspend_3_8(ldv_3_container_pci_driver->suspend,
                                                   ldv_3_resource_dev, ldv_3_resource_pm_message);
#line 1756
  ldv_3_ret_default = ldv_filter_err_code(ldv_3_ret_default);
#line 1760
  ldv_statevar_3 = 7;
  }
#line 1761
  goto ldv_56687;
  case_9: /* CIL Label */ 
  {
#line 1770
  ldv_statevar_3 = ldv_switch_1();
  }
#line 1771
  goto ldv_56687;
  case_10: /* CIL Label */ 
  {
#line 1775
  ldv_assume(ldv_statevar_0 == 2 || ldv_statevar_1 == 2);
#line 1777
  ldv_pci_instance_callback_3_10(ldv_3_callback_error_detected, ldv_3_resource_dev,
                                 ldv_3_resource_enum_pci_channel_state);
#line 1781
  ldv_statevar_3 = 9;
  }
#line 1782
  goto ldv_56687;
  case_12: /* CIL Label */ 
  {
#line 1786
  ldv_free((void *)ldv_3_resource_dev);
#line 1787
  ldv_free((void *)ldv_3_resource_struct_pci_device_id_ptr);
#line 1798
  ldv_3_ret_default = 1;
#line 1799
  ldv_statevar_3 = 20;
  }
#line 1800
  goto ldv_56687;
  case_14: /* CIL Label */ 
  {
#line 1804
  ldv_assume(ldv_3_ret_default != 0);
#line 1813
  tmp___0 = ldv_undef_int();
  }
#line 1813
  if (tmp___0 != 0) {
#line 1814
    ldv_statevar_3 = 12;
  } else {
#line 1816
    ldv_statevar_3 = 17;
  }
#line 1817
  goto ldv_56687;
  case_16: /* CIL Label */ 
  {
#line 1821
  ldv_assume(ldv_3_ret_default == 0);
#line 1830
  ldv_statevar_3 = ldv_switch_1();
  }
#line 1831
  goto ldv_56687;
  case_17: /* CIL Label */ 
  {
#line 1835
  ldv_assume(ldv_statevar_2 == 5);
#line 1837
  ldv_pre_probe();
#line 1839
  ldv_3_ret_default = ldv_pci_instance_probe_3_17((int (*)(struct pci_dev * , struct pci_device_id * ))ldv_3_container_pci_driver->probe,
                                                  ldv_3_resource_dev, ldv_3_resource_struct_pci_device_id_ptr);
#line 1841
  ldv_3_ret_default = ldv_ldv_post_probe_30(ldv_3_ret_default);
#line 1845
  tmp___1 = ldv_undef_int();
  }
#line 1845
  if (tmp___1 != 0) {
#line 1846
    ldv_statevar_3 = 14;
  } else {
#line 1848
    ldv_statevar_3 = 16;
  }
#line 1849
  goto ldv_56687;
  case_19: /* CIL Label */ 
  {
#line 1853
  tmp___2 = ldv_xmalloc(2936UL);
#line 1853
  ldv_3_resource_dev = (struct pci_dev *)tmp___2;
#line 1854
  tmp___3 = ldv_xmalloc(32UL);
#line 1854
  ldv_3_resource_struct_pci_device_id_ptr = (struct pci_device_id *)tmp___3;
#line 1863
  tmp___4 = ldv_undef_int();
  }
#line 1863
  if (tmp___4 != 0) {
#line 1864
    ldv_statevar_3 = 12;
  } else {
#line 1866
    ldv_statevar_3 = 17;
  }
#line 1867
  goto ldv_56687;
  case_20: /* CIL Label */ ;
#line 1875
  goto ldv_56687;
  case_23: /* CIL Label */ 
  {
#line 1879
  ldv_assume(ldv_statevar_0 == 6 || ldv_statevar_1 == 6);
#line 1881
  ldv_pci_instance_callback_3_23(ldv_3_callback_func_1_ptr, ldv_3_resource_dev);
#line 1885
  ldv_statevar_3 = 9;
  }
#line 1886
  goto ldv_56687;
  case_24: /* CIL Label */ 
  {
#line 1891
  ldv_pci_instance_callback_3_24(ldv_3_callback_slot_reset, ldv_3_resource_dev);
#line 1895
  ldv_statevar_3 = 9;
  }
#line 1896
  goto ldv_56687;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  ldv_56687: ;
#line 1902
  return;
}
}
#line 1904 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_pci_unregister_driver(void *arg0 , struct pci_driver *arg1 ) 
{ 
  struct pci_driver *ldv_13_pci_driver_pci_driver ;

  {
  {
#line 1910
  ldv_13_pci_driver_pci_driver = arg1;
#line 1914
  ldv_assume(ldv_statevar_3 == 12);
#line 1915
  ldv_dispatch_deregister_13_1(ldv_13_pci_driver_pci_driver);
  }
#line 1919
  return;
#line 1921
  return;
}
}
#line 1926 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_register_netdev(int arg0 , struct net_device *arg1 ) 
{ 
  struct net_device *ldv_9_netdev_net_device ;
  int ldv_9_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1933
  ldv_9_ret_default = 1;
#line 1935
  ldv_9_ret_default = ldv_pre_register_netdev();
#line 1936
  ldv_9_netdev_net_device = arg1;
#line 1939
  tmp___0 = ldv_undef_int();
  }
#line 1939
  if (tmp___0 != 0) {
    {
#line 1941
    ldv_assume(ldv_9_ret_default == 0);
#line 1945
    ldv_assume(((ldv_statevar_0 == 2 || ldv_statevar_0 == 6) || ldv_statevar_1 == 6) || ldv_statevar_1 == 2);
#line 1947
    ldv_9_ret_default = ldv_register_netdev_open_9_6((ldv_9_netdev_net_device->netdev_ops)->ndo_open,
                                                     ldv_9_netdev_net_device);
#line 1950
    tmp = ldv_undef_int();
    }
#line 1950
    if (tmp != 0) {
      {
#line 1952
      ldv_assume(ldv_9_ret_default == 0);
#line 1956
      ldv_assume(ldv_statevar_2 == 5);
#line 1957
      ldv_dispatch_register_9_4(ldv_9_netdev_net_device);
      }
    } else {
      {
#line 1963
      ldv_assume(ldv_9_ret_default != 0);
      }
    }
  } else {
    {
#line 1970
    ldv_assume(ldv_9_ret_default != 0);
    }
  }
#line 1975
  return (ldv_9_ret_default);
#line 1979
  return (arg0);
#line 1981
  return (arg0);
}
}
#line 1986 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_register_netdev_open_9_6(int (*arg0)(struct net_device * ) , struct net_device *arg1 ) 
{ 
  int tmp ;

  {
  {
#line 1987
  tmp = be_open(arg1);
  }
#line 1987
  return (tmp);
}
}
#line 1991 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) 
{ 
  enum irqreturn (*ldv_11_callback_handler)(int  , void * ) ;
  void *ldv_11_data_data ;
  int ldv_11_line_line ;
  enum irqreturn (*ldv_11_thread_thread)(int  , void * ) ;
  int tmp ;

  {
  {
#line 2001
  tmp = ldv_undef_int();
  }
#line 2001
  if (tmp != 0) {
    {
#line 2003
    ldv_assume(arg0 == 0);
#line 2004
    ldv_11_line_line = (int )arg1;
#line 2005
    ldv_11_callback_handler = arg2;
#line 2006
    ldv_11_thread_thread = (enum irqreturn (*)(int  , void * ))0;
#line 2007
    ldv_11_data_data = arg5;
#line 2011
    ldv_assume(ldv_statevar_0 == 6 || ldv_statevar_1 == 6);
#line 2012
    ldv_dispatch_irq_register_11_2(ldv_11_line_line, ldv_11_callback_handler, ldv_11_thread_thread,
                                   ldv_11_data_data);
    }
#line 2016
    return (arg0);
  } else {
    {
#line 2020
    ldv_assume(arg0 != 0);
    }
#line 2024
    return (arg0);
  }
#line 2027
  return (arg0);
}
}
#line 2032 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_switch_0(void) 
{ 
  int tmp ;

  {
  {
#line 2033
  tmp = ldv_undef_int();
  }
  {
#line 2034
  if (tmp == 0) {
#line 2034
    goto case_0;
  } else {

  }
#line 2038
  if (tmp == 1) {
#line 2038
    goto case_1;
  } else {

  }
#line 2042
  if (tmp == 2) {
#line 2042
    goto case_2;
  } else {

  }
#line 2046
  if (tmp == 3) {
#line 2046
    goto case_3;
  } else {

  }
#line 2050
  if (tmp == 4) {
#line 2050
    goto case_4;
  } else {

  }
#line 2054
  if (tmp == 5) {
#line 2054
    goto case_5;
  } else {

  }
#line 2058
  if (tmp == 6) {
#line 2058
    goto case_6;
  } else {

  }
#line 2062
  if (tmp == 7) {
#line 2062
    goto case_7;
  } else {

  }
#line 2066
  if (tmp == 8) {
#line 2066
    goto case_8;
  } else {

  }
#line 2070
  if (tmp == 9) {
#line 2070
    goto case_9;
  } else {

  }
#line 2074
  if (tmp == 10) {
#line 2074
    goto case_10;
  } else {

  }
#line 2078
  if (tmp == 11) {
#line 2078
    goto case_11;
  } else {

  }
#line 2082
  if (tmp == 12) {
#line 2082
    goto case_12;
  } else {

  }
#line 2086
  if (tmp == 13) {
#line 2086
    goto case_13;
  } else {

  }
#line 2090
  if (tmp == 14) {
#line 2090
    goto case_14;
  } else {

  }
#line 2094
  if (tmp == 15) {
#line 2094
    goto case_15;
  } else {

  }
#line 2098
  if (tmp == 16) {
#line 2098
    goto case_16;
  } else {

  }
#line 2102
  if (tmp == 17) {
#line 2102
    goto case_17;
  } else {

  }
#line 2106
  if (tmp == 18) {
#line 2106
    goto case_18;
  } else {

  }
#line 2110
  if (tmp == 19) {
#line 2110
    goto case_19;
  } else {

  }
#line 2114
  if (tmp == 20) {
#line 2114
    goto case_20;
  } else {

  }
#line 2118
  if (tmp == 21) {
#line 2118
    goto case_21;
  } else {

  }
#line 2122
  if (tmp == 22) {
#line 2122
    goto case_22;
  } else {

  }
#line 2126
  if (tmp == 23) {
#line 2126
    goto case_23;
  } else {

  }
#line 2130
  if (tmp == 24) {
#line 2130
    goto case_24;
  } else {

  }
#line 2134
  if (tmp == 25) {
#line 2134
    goto case_25;
  } else {

  }
#line 2138
  if (tmp == 26) {
#line 2138
    goto case_26;
  } else {

  }
#line 2142
  if (tmp == 27) {
#line 2142
    goto case_27;
  } else {

  }
#line 2146
  if (tmp == 28) {
#line 2146
    goto case_28;
  } else {

  }
#line 2150
  if (tmp == 29) {
#line 2150
    goto case_29;
  } else {

  }
#line 2154
  if (tmp == 30) {
#line 2154
    goto case_30;
  } else {

  }
#line 2158
  if (tmp == 31) {
#line 2158
    goto case_31;
  } else {

  }
#line 2162
  if (tmp == 32) {
#line 2162
    goto case_32;
  } else {

  }
#line 2166
  if (tmp == 33) {
#line 2166
    goto case_33;
  } else {

  }
#line 2170
  if (tmp == 34) {
#line 2170
    goto case_34;
  } else {

  }
#line 2174
  if (tmp == 35) {
#line 2174
    goto case_35;
  } else {

  }
#line 2178
  if (tmp == 36) {
#line 2178
    goto case_36;
  } else {

  }
#line 2182
  if (tmp == 37) {
#line 2182
    goto case_37;
  } else {

  }
#line 2186
  if (tmp == 38) {
#line 2186
    goto case_38;
  } else {

  }
#line 2190
  if (tmp == 39) {
#line 2190
    goto case_39;
  } else {

  }
#line 2194
  if (tmp == 40) {
#line 2194
    goto case_40;
  } else {

  }
#line 2198
  if (tmp == 41) {
#line 2198
    goto case_41;
  } else {

  }
#line 2202
  if (tmp == 42) {
#line 2202
    goto case_42;
  } else {

  }
#line 2206
  if (tmp == 43) {
#line 2206
    goto case_43;
  } else {

  }
#line 2210
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 2035
  return (1);
  case_1: /* CIL Label */ ;
#line 2039
  return (3);
  case_2: /* CIL Label */ ;
#line 2043
  return (7);
  case_3: /* CIL Label */ ;
#line 2047
  return (8);
  case_4: /* CIL Label */ ;
#line 2051
  return (9);
  case_5: /* CIL Label */ ;
#line 2055
  return (11);
  case_6: /* CIL Label */ ;
#line 2059
  return (13);
  case_7: /* CIL Label */ ;
#line 2063
  return (15);
  case_8: /* CIL Label */ ;
#line 2067
  return (17);
  case_9: /* CIL Label */ ;
#line 2071
  return (18);
  case_10: /* CIL Label */ ;
#line 2075
  return (19);
  case_11: /* CIL Label */ ;
#line 2079
  return (20);
  case_12: /* CIL Label */ ;
#line 2083
  return (21);
  case_13: /* CIL Label */ ;
#line 2087
  return (22);
  case_14: /* CIL Label */ ;
#line 2091
  return (24);
  case_15: /* CIL Label */ ;
#line 2095
  return (26);
  case_16: /* CIL Label */ ;
#line 2099
  return (28);
  case_17: /* CIL Label */ ;
#line 2103
  return (31);
  case_18: /* CIL Label */ ;
#line 2107
  return (33);
  case_19: /* CIL Label */ ;
#line 2111
  return (35);
  case_20: /* CIL Label */ ;
#line 2115
  return (37);
  case_21: /* CIL Label */ ;
#line 2119
  return (38);
  case_22: /* CIL Label */ ;
#line 2123
  return (40);
  case_23: /* CIL Label */ ;
#line 2127
  return (42);
  case_24: /* CIL Label */ ;
#line 2131
  return (44);
  case_25: /* CIL Label */ ;
#line 2135
  return (46);
  case_26: /* CIL Label */ ;
#line 2139
  return (47);
  case_27: /* CIL Label */ ;
#line 2143
  return (48);
  case_28: /* CIL Label */ ;
#line 2147
  return (50);
  case_29: /* CIL Label */ ;
#line 2151
  return (53);
  case_30: /* CIL Label */ ;
#line 2155
  return (56);
  case_31: /* CIL Label */ ;
#line 2159
  return (58);
  case_32: /* CIL Label */ ;
#line 2163
  return (59);
  case_33: /* CIL Label */ ;
#line 2167
  return (61);
  case_34: /* CIL Label */ ;
#line 2171
  return (64);
  case_35: /* CIL Label */ ;
#line 2175
  return (67);
  case_36: /* CIL Label */ ;
#line 2179
  return (69);
  case_37: /* CIL Label */ ;
#line 2183
  return (70);
  case_38: /* CIL Label */ ;
#line 2187
  return (71);
  case_39: /* CIL Label */ ;
#line 2191
  return (73);
  case_40: /* CIL Label */ ;
#line 2195
  return (75);
  case_41: /* CIL Label */ ;
#line 2199
  return (76);
  case_42: /* CIL Label */ ;
#line 2203
  return (77);
  case_43: /* CIL Label */ ;
#line 2207
  return (78);
  switch_default: /* CIL Label */ 
  {
#line 2210
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2212
  return (0);
}
}
#line 2215 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
int ldv_switch_1(void) 
{ 
  int tmp ;

  {
  {
#line 2216
  tmp = ldv_undef_int();
  }
  {
#line 2217
  if (tmp == 0) {
#line 2217
    goto case_0;
  } else {

  }
#line 2221
  if (tmp == 1) {
#line 2221
    goto case_1;
  } else {

  }
#line 2225
  if (tmp == 2) {
#line 2225
    goto case_2;
  } else {

  }
#line 2229
  if (tmp == 3) {
#line 2229
    goto case_3;
  } else {

  }
#line 2233
  if (tmp == 4) {
#line 2233
    goto case_4;
  } else {

  }
#line 2237
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 2218
  return (3);
  case_1: /* CIL Label */ ;
#line 2222
  return (8);
  case_2: /* CIL Label */ ;
#line 2226
  return (10);
  case_3: /* CIL Label */ ;
#line 2230
  return (23);
  case_4: /* CIL Label */ ;
#line 2234
  return (24);
  switch_default: /* CIL Label */ 
  {
#line 2237
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2239
  return (0);
}
}
#line 2242 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_0_1(void) 
{ 


  {
#line 2245
  ldv_statevar_0 = 6;
#line 2246
  return;
}
}
#line 2249 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_0_6(void) 
{ 


  {
#line 2250
  ldv_statevar_0 = 5;
#line 2251
  return;
}
}
#line 2254 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_1_1(void) 
{ 


  {
#line 2257
  ldv_statevar_1 = 6;
#line 2258
  return;
}
}
#line 2261 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_1_6(void) 
{ 


  {
#line 2262
  ldv_statevar_1 = 5;
#line 2263
  return;
}
}
#line 2266 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_2_1(void) 
{ 


  {
#line 2269
  ldv_statevar_2 = 5;
#line 2270
  return;
}
}
#line 2273 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_2_5(void) 
{ 


  {
#line 2274
  ldv_statevar_2 = 4;
#line 2275
  return;
}
}
#line 2278 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_3_11(void) 
{ 


  {
#line 2282
  ldv_3_ret_default = 1;
#line 2283
  ldv_statevar_3 = 20;
#line 2284
  return;
}
}
#line 2287 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_3_20(void) 
{ 


  {
#line 2288
  ldv_statevar_3 = 19;
#line 2289
  return;
}
}
#line 2292 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_4_1(void) 
{ 


  {
#line 2295
  ldv_statevar_4 = 3;
#line 2296
  return;
}
}
#line 2299 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_4_3(void) 
{ 


  {
#line 2300
  ldv_statevar_4 = 2;
#line 2301
  return;
}
}
#line 2304 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_5_1(void) 
{ 


  {
#line 2307
  ldv_statevar_5 = 4;
#line 2308
  return;
}
}
#line 2311 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_switch_automaton_state_5_4(void) 
{ 


  {
#line 2312
  ldv_statevar_5 = 3;
#line 2313
  return;
}
}
#line 2316 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_timer_dummy_factory_5(void *arg0 ) 
{ 


  {
  {
#line 2322
  if (ldv_statevar_5 == 2) {
#line 2322
    goto case_2;
  } else {

  }
#line 2338
  if (ldv_statevar_5 == 3) {
#line 2338
    goto case_3;
  } else {

  }
#line 2348
  if (ldv_statevar_5 == 4) {
#line 2348
    goto case_4;
  } else {

  }
#line 2356
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 2324
  ldv_assume(ldv_statevar_4 == 2);
#line 2325
  ldv_dispatch_instance_deregister_5_2(ldv_5_container_timer_list);
#line 2335
  ldv_statevar_5 = 4;
  }
#line 2336
  goto ldv_56823;
  case_3: /* CIL Label */ 
  {
#line 2340
  ldv_assume(ldv_statevar_4 == 3);
#line 2341
  ldv_dispatch_instance_register_5_3(ldv_5_container_timer_list);
#line 2345
  ldv_statevar_5 = 2;
  }
#line 2346
  goto ldv_56823;
  case_4: /* CIL Label */ ;
#line 2354
  goto ldv_56823;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  ldv_56823: ;
#line 2360
  return;
}
}
#line 2362 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_timer_instance_callback_4_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) 
{ 


  {
  {
#line 2363
  (*arg0)(arg1);
  }
#line 2364
  return;
}
}
#line 2367 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_timer_timer_instance_4(void *arg0 ) 
{ 


  {
  {
#line 2373
  if (ldv_statevar_4 == 2) {
#line 2373
    goto case_2;
  } else {

  }
#line 2395
  if (ldv_statevar_4 == 3) {
#line 2395
    goto case_3;
  } else {

  }
#line 2403
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 2376
  ldv_switch_to_interrupt_context();
  }
#line 2377
  if ((unsigned long )ldv_4_container_timer_list->function != (unsigned long )((void (*)(unsigned long  ))0)) {
    {
#line 2379
    ldv_timer_instance_callback_4_2(ldv_4_container_timer_list->function, ldv_4_container_timer_list->data);
    }
  } else {

  }
  {
#line 2382
  ldv_switch_to_process_context();
#line 2392
  ldv_statevar_4 = 3;
  }
#line 2393
  goto ldv_56836;
  case_3: /* CIL Label */ ;
#line 2401
  goto ldv_56836;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  ldv_56836: ;
#line 2407
  return;
}
}
#line 2409 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_unregister_netdev(void *arg0 , struct net_device *arg1 ) 
{ 
  struct net_device *ldv_12_netdev_net_device ;

  {
  {
#line 2415
  ldv_12_netdev_net_device = arg1;
#line 2419
  ldv_assume(ldv_statevar_0 == 2 || ldv_statevar_1 == 2);
#line 2421
  ldv_unregister_netdev_stop_12_2((ldv_12_netdev_net_device->netdev_ops)->ndo_stop,
                                  ldv_12_netdev_net_device);
#line 2425
  ldv_assume(ldv_statevar_2 == 1);
#line 2426
  ldv_dispatch_deregister_12_1(ldv_12_netdev_net_device);
  }
#line 2430
  return;
#line 2432
  return;
}
}
#line 2437 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
void ldv_unregister_netdev_stop_12_2(int (*arg0)(struct net_device * ) , struct net_device *arg1 ) 
{ 


  {
  {
#line 2438
  be_close(arg1);
  }
#line 2439
  return;
}
}
#line 2466 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
__inline static void atomic_add(int i , atomic_t *v ) 
{ 


  {
  {
#line 2469
  ldv_atomic_add(i, v);
  }
#line 2470
  return;
}
}
#line 2472 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
__inline static void atomic_sub(int i , atomic_t *v ) 
{ 


  {
  {
#line 2475
  ldv_atomic_sub(i, v);
  }
#line 2476
  return;
}
}
#line 2484 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
  {
#line 2487
  ldv_atomic_inc(v);
  }
#line 2488
  return;
}
}
#line 2490 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
  {
#line 2493
  ldv_atomic_dec(v);
  }
#line 2494
  return;
}
}
#line 2532 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static void *ldv_dev_get_drvdata_16(struct device  const  *dev ) 
{ 
  void *tmp ;

  {
  {
#line 2535
  tmp = ldv_dev_get_drvdata(dev);
  }
#line 2535
  return (tmp);
}
}
#line 2538 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static int ldv_dev_set_drvdata_17(struct device *dev , void *data ) 
{ 
  int tmp ;

  {
  {
#line 2541
  tmp = ldv_dev_set_drvdata(dev, data);
  }
#line 2541
  return (tmp);
}
}
#line 2544 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
__inline static int ldv_request_irq_18(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2548
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2548
  ldv_func_res = tmp;
#line 2551
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 2551
  return (tmp___0);
#line 2553
  return (ldv_func_res);
}
}
#line 2556 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static void ldv_free_irq_19(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 2559
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2562
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 2563
  return;
}
}
#line 2565 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
__inline static int ldv_request_irq_20(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2569
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2569
  ldv_func_res = tmp;
#line 2572
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 2572
  return (tmp___0);
#line 2574
  return (ldv_func_res);
}
}
#line 2577 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static void ldv_free_irq_21(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 2580
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2583
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 2584
  return;
}
}
#line 2586 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static void ldv_free_irq_22(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 2589
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2592
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 2593
  return;
}
}
#line 2595 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static void ldv_unregister_netdev_23(struct net_device *ldv_func_arg1 ) 
{ 


  {
  {
#line 2598
  unregister_netdev(ldv_func_arg1);
#line 2601
  ldv_unregister_netdev((void *)0, ldv_func_arg1);
  }
#line 2602
  return;
}
}
#line 2604 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static void ldv_free_netdev_24(struct net_device *ldv_func_arg1 ) 
{ 


  {
  {
#line 2607
  free_netdev(ldv_func_arg1);
#line 2610
  ldv_free_netdev((void *)0, ldv_func_arg1);
  }
#line 2611
  return;
}
}
#line 2613 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static struct net_device *ldv_alloc_etherdev_mqs_25(int ldv_func_arg1 , unsigned int ldv_func_arg2 ,
                                                    unsigned int ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  struct net_device *tmp ;
  struct net_device *tmp___0 ;

  {
  {
#line 2617
  tmp = alloc_etherdev_mqs(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2617
  ldv_func_res = tmp;
#line 2620
  tmp___0 = ldv_alloc_etherdev_mqs(ldv_func_res, ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  }
#line 2620
  return (tmp___0);
#line 2622
  return (ldv_func_res);
}
}
#line 2625 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static int ldv_register_netdev_26(struct net_device *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2629
  tmp = register_netdev(ldv_func_arg1);
#line 2629
  ldv_func_res = tmp;
#line 2632
  tmp___0 = ldv_register_netdev(ldv_func_res, ldv_func_arg1);
  }
#line 2632
  return (tmp___0);
#line 2634
  return (ldv_func_res);
}
}
#line 2637 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static void ldv_free_netdev_27(struct net_device *ldv_func_arg1 ) 
{ 


  {
  {
#line 2640
  free_netdev(ldv_func_arg1);
#line 2643
  ldv_free_netdev((void *)0, ldv_func_arg1);
  }
#line 2644
  return;
}
}
#line 2646 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static int ldv___pci_register_driver_28(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                        char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2650
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 2650
  ldv_func_res = tmp;
#line 2653
  tmp___0 = ldv___pci_register_driver(ldv_func_res, ldv_func_arg1, ldv_func_arg2,
                                      (char *)ldv_func_arg3);
  }
#line 2653
  return (tmp___0);
#line 2655
  return (ldv_func_res);
}
}
#line 2658 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static void ldv_pci_unregister_driver_29(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
  {
#line 2661
  pci_unregister_driver(ldv_func_arg1);
#line 2664
  ldv_pci_unregister_driver((void *)0, ldv_func_arg1);
  }
#line 2665
  return;
}
}
#line 2667 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_main.c.aux"
static int ldv_ldv_post_probe_30(int ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 2671
  ldv_check_return_value_probe(ldv_func_arg1);
#line 2673
  tmp = ldv_post_probe(ldv_func_arg1);
  }
#line 2673
  return (tmp);
}
}
#line 439 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 453
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 466
  return (r + 1);
}
}
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = fls((int )n);
  }
#line 34
  return (tmp + -1);
}
}
#line 62 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 97 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) ;
#line 113
__inline static void atomic_dec(atomic_t *v ) ;
#line 141 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mutex.h"
extern int mutex_lock_interruptible_nested(struct mutex * , unsigned int  ) ;
#line 174
extern void mutex_unlock(struct mutex * ) ;
#line 91 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/completion.h"
extern void wait_for_completion(struct completion * ) ;
#line 95
extern unsigned long wait_for_completion_timeout(struct completion * , unsigned long  ) ;
#line 106
extern void complete(struct completion * ) ;
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/delay.h"
extern unsigned long msleep_interruptible(unsigned int  ) ;
#line 16 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
  {
#line 19
  tmp = dma_alloc_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                        size, dma_handle, 32U, (struct dma_attrs *)0);
  }
#line 19
  return (tmp);
}
}
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 


  {
  {
#line 26
  dma_free_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                 size, vaddr, dma_handle, (struct dma_attrs *)0);
  }
#line 27
  return;
}
}
#line 72 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.h"
int be_roce_mcc_cmd(void *netdev_handle , void *wrb_payload , int wrb_payload_size ,
                    u16 *cmd_status , u16 *ext_status ) ;
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void *queue_index_node(struct be_queue_info *q , u16 index ) 
{ 


  {
#line 168
  return (q->dma_mem.va + (unsigned long )((int )index * (int )q->entry_size));
}
}
#line 176 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static void index_dec(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
  {
#line 178
  tmp = MODULO((int )((unsigned int )*index + 65535U), (int )limit);
#line 178
  *index = (u16 )tmp;
  }
#line 179
  return;
}
}
#line 698 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_error(struct be_adapter *adapter ) 
{ 


  {
#line 700
  return ((bool )(((int )adapter->eeh_error || (int )adapter->hw_error) || (int )adapter->fw_timeout));
}
}
#line 715 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be.h"
__inline static bool be_is_wol_excluded(struct be_adapter *adapter ) 
{ 
  struct pci_dev *pdev ;

  {
#line 717
  pdev = adapter->pdev;
#line 719
  if ((unsigned int )adapter->virtfn != 0U) {
#line 720
    return (1);
  } else {

  }
  {
#line 723
  if ((int )pdev->subsystem_device == 58882) {
#line 723
    goto case_58882;
  } else {

  }
#line 724
  if ((int )pdev->subsystem_device == 58946) {
#line 724
    goto case_58946;
  } else {

  }
#line 725
  if ((int )pdev->subsystem_device == 58898) {
#line 725
    goto case_58898;
  } else {

  }
#line 726
  if ((int )pdev->subsystem_device == 58962) {
#line 726
    goto case_58962;
  } else {

  }
#line 728
  goto switch_default;
  case_58882: /* CIL Label */ ;
  case_58946: /* CIL Label */ ;
  case_58898: /* CIL Label */ ;
  case_58962: /* CIL Label */ ;
#line 727
  return (1);
  switch_default: /* CIL Label */ ;
#line 729
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1976 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
int be_cmd_mac_addr_query(struct be_adapter *adapter , u8 *mac_addr , bool permanent ,
                          u32 if_handle , u32 pmac_id ) ;
#line 2017
int be_cmd_set_beacon_state(struct be_adapter *adapter , u8 port_num , u8 bcn , u8 sts ,
                            u8 state ) ;
#line 2019
int be_cmd_get_beacon_state(struct be_adapter *adapter , u8 port_num , u32 *state ) ;
#line 2027
int lancer_cmd_read_object(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 data_size ,
                           u32 data_offset , char const   *obj_name , u32 *data_read ,
                           u32 *eof , u8 *addn_status ) ;
#line 2038
int be_cmd_loopback_test(struct be_adapter *adapter , u32 port_num , u32 loopback_type ,
                         u32 pkt_size , u32 num_pkts , u64 pattern ) ;
#line 2041
int be_cmd_ddr_dma_test(struct be_adapter *adapter , u64 pattern , u32 byte_cnt ,
                        struct be_dma_mem *cmd ) ;
#line 2043
int be_cmd_get_seeprom_data(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) ;
#line 2045
int be_cmd_set_loopback(struct be_adapter *adapter , u8 port_num , u8 loopback_type ,
                        u8 enable ) ;
#line 2053
int be_cmd_get_reg_len(struct be_adapter *adapter , u32 *log_size ) ;
#line 2054
void be_cmd_get_regs(struct be_adapter *adapter , u32 buf_len , void *buf ) ;
#line 2059
int be_cmd_get_mac_from_list(struct be_adapter *adapter , u8 *mac , bool *pmac_id_valid ,
                             u32 *pmac_id , u32 if_handle , u8 domain ) ;
#line 2065
int be_cmd_set_mac_list(struct be_adapter *adapter , u8 *mac_array , u8 mac_count ,
                        u32 domain ) ;
#line 2073
int be_cmd_set_fw_log_level(struct be_adapter *adapter , u32 level ) ;
#line 2075
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ) ;
#line 2077
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                                   struct be_fat_conf_params *configs ) ;
#line 2081
int lancer_initiate_dump(struct be_adapter *adapter ) ;
#line 2082
bool dump_present(struct be_adapter *adapter ) ;
#line 22 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_cmd_priv_map cmd_priv_map[5U]  = {      {12U, 3U, 1800U}, 
        {37U, 1U, 1794U}, 
        {36U, 1U, 1800U}, 
        {18U, 3U, 1800U}, 
        {102U, 1U, 1800U}};
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static bool be_cmd_allowed(struct be_adapter *adapter , u8 opcode , u8 subsystem ) 
{ 
  int i ;
  int num_entries ;
  u32 cmd_privileges ;

  {
#line 59
  num_entries = 5;
#line 60
  cmd_privileges = adapter->cmd_privileges;
#line 62
  i = 0;
#line 62
  goto ldv_53780;
  ldv_53779: ;
#line 63
  if ((int )opcode == (int )cmd_priv_map[i].opcode && (int )subsystem == (int )cmd_priv_map[i].subsystem) {
#line 65
    if ((cmd_privileges & cmd_priv_map[i].priv_mask) == 0U) {
#line 66
      return (0);
    } else {

    }
  } else {

  }
#line 62
  i = i + 1;
  ldv_53780: ;
#line 62
  if (i < num_entries) {
#line 64
    goto ldv_53779;
  } else {

  }

#line 68
  return (1);
}
}
#line 71 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static void *embedded_payload(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 73
  return ((void *)(& wrb->payload.embedded_payload));
}
}
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_mcc_notify(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mccq ;
  u32 val ;
  bool tmp ;

  {
  {
#line 78
  mccq = & adapter->mcc_obj.q;
#line 79
  val = 0U;
#line 81
  tmp = be_error(adapter);
  }
#line 81
  if ((int )tmp) {
#line 82
    return;
  } else {

  }
  {
#line 84
  val = val | ((u32 )mccq->id & 2047U);
#line 85
  val = val | 65536U;
#line 87
  __asm__  volatile   ("sfence": : : "memory");
#line 88
  iowrite32(val, (void *)adapter->db + 320U);
  }
#line 89
  return;
}
}
#line 94 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool be_mcc_compl_is_new(struct be_mcc_compl *compl ) 
{ 
  u32 flags ;

  {
#line 98
  if (compl->flags != 0U) {
#line 99
    flags = compl->flags;
#line 100
    if ((int )flags < 0) {
#line 101
      compl->flags = flags;
#line 102
      return (1);
    } else {

    }
  } else {

  }
#line 105
  return (0);
}
}
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static void be_mcc_compl_use(struct be_mcc_compl *compl ) 
{ 


  {
#line 111
  compl->flags = 0U;
#line 112
  return;
}
}
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_cmd_resp_hdr *be_decode_resp_hdr(u32 tag0 , u32 tag1 ) 
{ 
  unsigned long addr ;

  {
#line 118
  addr = (unsigned long )tag1;
#line 119
  addr = (addr << 32UL) | (unsigned long )tag0;
#line 120
  return ((struct be_cmd_resp_hdr *)addr);
}
}
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mcc_compl_process(struct be_adapter *adapter , struct be_mcc_compl *compl ) 
{ 
  u16 compl_status ;
  u16 extd_status ;
  struct be_cmd_resp_hdr *resp_hdr ;
  u8 opcode ;
  u8 subsystem ;
  struct be_cmd_resp_get_cntl_addnl_attribs *resp ;

  {
  {
#line 128
  opcode = 0U;
#line 128
  subsystem = 0U;
#line 132
  swap_dws((void *)compl, 4);
#line 134
  compl_status = (u16 )compl->status;
#line 137
  resp_hdr = be_decode_resp_hdr(compl->tag0, compl->tag1);
  }
#line 139
  if ((unsigned long )resp_hdr != (unsigned long )((struct be_cmd_resp_hdr *)0)) {
#line 140
    opcode = resp_hdr->opcode;
#line 141
    subsystem = resp_hdr->subsystem;
  } else {

  }
#line 144
  if ((unsigned int )opcode == 18U && (unsigned int )subsystem == 11U) {
    {
#line 146
    complete(& adapter->et_cmd_compl);
    }
#line 147
    return (0);
  } else {

  }
#line 150
  if (((unsigned int )opcode == 7U || (unsigned int )opcode == 172U) && (unsigned int )subsystem == 1U) {
    {
#line 153
    adapter->flash_status = (u32 )compl_status;
#line 154
    complete(& adapter->et_cmd_compl);
    }
  } else {

  }
#line 157
  if ((unsigned int )compl_status == 0U) {
#line 158
    if (((unsigned int )opcode == 4U || (unsigned int )opcode == 18U) && (unsigned int )subsystem == 3U) {
      {
#line 161
      be_parse_stats(adapter);
#line 162
      adapter->stats_cmd_sent = 0;
      }
    } else {

    }
#line 164
    if ((unsigned int )opcode == 121U && (unsigned int )subsystem == 1U) {
#line 166
      resp = (struct be_cmd_resp_get_cntl_addnl_attribs *)resp_hdr;
#line 168
      adapter->drv_stats.be_on_die_temperature = (u32 )resp->on_die_temperature;
    } else {

    }
  } else {
#line 172
    if ((unsigned int )opcode == 121U) {
#line 173
      adapter->be_get_temp_freq = 0;
    } else {

    }
#line 175
    if ((unsigned int )compl_status == 66U || (unsigned int )compl_status == 2U) {
#line 177
      goto done;
    } else {

    }
#line 179
    if ((unsigned int )compl_status == 5U) {
      {
#line 180
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "VF is not privileged to issue opcode %d-%d\n",
               (int )opcode, (int )subsystem);
      }
    } else {
      {
#line 184
      extd_status = (u16 )(compl->status >> 16);
#line 186
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "opcode %d-%d failed:status %d-%d\n",
              (int )opcode, (int )subsystem, (int )compl_status, (int )extd_status);
      }
#line 190
      if ((unsigned int )extd_status == 22U) {
#line 191
        return ((int )extd_status);
      } else {

      }
    }
  }
  done: ;
#line 195
  return ((int )compl_status);
}
}
#line 199 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_link_state_process(struct be_adapter *adapter , struct be_async_event_link_state *evt ) 
{ 


  {
#line 203
  adapter->phy.link_speed = -1;
#line 206
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) && ((int )evt->port_link_status & 2) == 0) {
#line 208
    return;
  } else {

  }
#line 213
  if ((int )adapter->flags & 1) {
    {
#line 214
    be_link_status_update(adapter, (int )evt->port_link_status);
    }
  } else {

  }
#line 215
  return;
}
}
#line 218 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_cos_priority_process(struct be_adapter *adapter , struct be_async_event_grp5_cos_priority *evt ) 
{ 


  {
#line 221
  if ((unsigned int )evt->valid != 0U) {
#line 222
    adapter->vlan_prio_bmap = evt->available_priority_bmap;
#line 223
    adapter->recommended_prio = (unsigned int )adapter->recommended_prio & 8191U;
#line 224
    adapter->recommended_prio = (int )((u16 )evt->reco_default_priority) << 13U;
  } else {

  }
#line 227
  return;
}
}
#line 230 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_qos_speed_process(struct be_adapter *adapter , struct be_async_event_grp5_qos_link_speed *evt ) 
{ 


  {
#line 233
  if (adapter->phy.link_speed >= 0 && (u32 )evt->physical_port == adapter->port_num) {
#line 235
    adapter->phy.link_speed = (int )evt->qos_link_speed * 10;
  } else {

  }
#line 236
  return;
}
}
#line 239 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_pvid_state_process(struct be_adapter *adapter , struct be_async_event_grp5_pvid_state *evt ) 
{ 


  {
#line 242
  if ((unsigned int )evt->enabled != 0U) {
#line 243
    adapter->pvid = (unsigned int )evt->tag & 4095U;
  } else {
#line 245
    adapter->pvid = 0U;
  }
#line 246
  return;
}
}
#line 248 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_grp5_evt_process(struct be_adapter *adapter , u32 trailer , struct be_mcc_compl *evt ) 
{ 
  u8 event_type ;

  {
#line 251
  event_type = 0U;
#line 253
  event_type = (u8 )(trailer >> 16);
  {
#line 257
  if ((int )event_type == 2) {
#line 257
    goto case_2;
  } else {

  }
#line 261
  if ((int )event_type == 1) {
#line 261
    goto case_1;
  } else {

  }
#line 265
  if ((int )event_type == 3) {
#line 265
    goto case_3;
  } else {

  }
#line 269
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 258
  be_async_grp5_cos_priority_process(adapter, (struct be_async_event_grp5_cos_priority *)evt);
  }
#line 260
  goto ldv_53836;
  case_1: /* CIL Label */ 
  {
#line 262
  be_async_grp5_qos_speed_process(adapter, (struct be_async_event_grp5_qos_link_speed *)evt);
  }
#line 264
  goto ldv_53836;
  case_3: /* CIL Label */ 
  {
#line 266
  be_async_grp5_pvid_state_process(adapter, (struct be_async_event_grp5_pvid_state *)evt);
  }
#line 268
  goto ldv_53836;
  switch_default: /* CIL Label */ 
  {
#line 270
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unknown grp5 event 0x%x!\n",
           (int )event_type);
  }
#line 272
  goto ldv_53836;
  switch_break: /* CIL Label */ ;
  }
  ldv_53836: ;
#line 275
  return;
}
}
#line 276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_async_dbg_evt_process(struct be_adapter *adapter , u32 trailer , struct be_mcc_compl *cmp ) 
{ 
  u8 event_type ;
  struct be_async_event_qnq *evt ;

  {
#line 279
  event_type = 0U;
#line 280
  evt = (struct be_async_event_qnq *)cmp;
#line 282
  event_type = (u8 )(trailer >> 16);
  {
#line 286
  if ((int )event_type == 1) {
#line 286
    goto case_1;
  } else {

  }
#line 291
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 287
  if ((unsigned int )evt->valid != 0U) {
#line 288
    adapter->qnq_vid = evt->vlan_tag;
  } else {

  }
#line 289
  adapter->flags = adapter->flags | 2048U;
#line 290
  goto ldv_53848;
  switch_default: /* CIL Label */ 
  {
#line 292
  dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Unknown debug event 0x%x!\n",
           (int )event_type);
  }
#line 294
  goto ldv_53848;
  switch_break: /* CIL Label */ ;
  }
  ldv_53848: ;
#line 297
  return;
}
}
#line 298 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool is_link_state_evt(u32 trailer ) 
{ 


  {
#line 300
  return (((trailer >> 8) & 255U) == 1U);
}
}
#line 305 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool is_grp5_evt(u32 trailer ) 
{ 


  {
#line 307
  return (((trailer >> 8) & 255U) == 5U);
}
}
#line 312 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static bool is_dbg_evt(u32 trailer ) 
{ 


  {
#line 314
  return (((trailer >> 8) & 255U) == 6U);
}
}
#line 319 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_mcc_compl *be_mcc_compl_get(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mcc_cq ;
  struct be_mcc_compl *compl ;
  void *tmp ;
  bool tmp___0 ;

  {
  {
#line 321
  mcc_cq = & adapter->mcc_obj.cq;
#line 322
  tmp = queue_tail_node(mcc_cq);
#line 322
  compl = (struct be_mcc_compl *)tmp;
#line 324
  tmp___0 = be_mcc_compl_is_new(compl);
  }
#line 324
  if ((int )tmp___0) {
    {
#line 325
    queue_tail_inc(mcc_cq);
    }
#line 326
    return (compl);
  } else {

  }
#line 328
  return ((struct be_mcc_compl *)0);
}
}
#line 331 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
void be_async_mcc_enable(struct be_adapter *adapter ) 
{ 


  {
  {
#line 333
  spin_lock_bh(& adapter->mcc_cq_lock);
#line 335
  be_cq_notify(adapter, (int )adapter->mcc_obj.cq.id, 1, 0);
#line 336
  adapter->mcc_obj.rearm_cq = 1;
#line 338
  spin_unlock_bh(& adapter->mcc_cq_lock);
  }
#line 339
  return;
}
}
#line 341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
void be_async_mcc_disable(struct be_adapter *adapter ) 
{ 


  {
  {
#line 343
  spin_lock_bh(& adapter->mcc_cq_lock);
#line 345
  adapter->mcc_obj.rearm_cq = 0;
#line 346
  be_cq_notify(adapter, (int )adapter->mcc_obj.cq.id, 0, 0);
#line 348
  spin_unlock_bh(& adapter->mcc_cq_lock);
  }
#line 349
  return;
}
}
#line 351 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_process_mcc(struct be_adapter *adapter ) 
{ 
  struct be_mcc_compl *compl ;
  int num ;
  int status ;
  struct be_mcc_obj *mcc_obj ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 354
  num = 0;
#line 354
  status = 0;
#line 355
  mcc_obj = & adapter->mcc_obj;
#line 357
  spin_lock(& adapter->mcc_cq_lock);
  }
#line 358
  goto ldv_53878;
  ldv_53877: ;
#line 359
  if ((compl->flags & 1073741824U) != 0U) {
    {
#line 361
    tmp___1 = is_link_state_evt(compl->flags);
    }
#line 361
    if ((int )tmp___1) {
      {
#line 362
      be_async_link_state_process(adapter, (struct be_async_event_link_state *)compl);
      }
    } else {
      {
#line 364
      tmp___0 = is_grp5_evt(compl->flags);
      }
#line 364
      if ((int )tmp___0) {
        {
#line 365
        be_async_grp5_evt_process(adapter, compl->flags, compl);
        }
      } else {
        {
#line 367
        tmp = is_dbg_evt(compl->flags);
        }
#line 367
        if ((int )tmp) {
          {
#line 368
          be_async_dbg_evt_process(adapter, compl->flags, compl);
          }
        } else {

        }
      }
    }
  } else
#line 370
  if ((compl->flags & 268435456U) != 0U) {
    {
#line 371
    status = be_mcc_compl_process(adapter, compl);
#line 372
    atomic_dec(& mcc_obj->q.used);
    }
  } else {

  }
  {
#line 374
  be_mcc_compl_use(compl);
#line 375
  num = num + 1;
  }
  ldv_53878: 
  {
#line 358
  compl = be_mcc_compl_get(adapter);
  }
#line 358
  if ((unsigned long )compl != (unsigned long )((struct be_mcc_compl *)0)) {
#line 360
    goto ldv_53877;
  } else {

  }

#line 378
  if (num != 0) {
    {
#line 379
    be_cq_notify(adapter, (int )mcc_obj->cq.id, (int )mcc_obj->rearm_cq, (int )((u16 )num));
    }
  } else {

  }
  {
#line 381
  spin_unlock(& adapter->mcc_cq_lock);
  }
#line 382
  return (status);
}
}
#line 386 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mcc_wait_compl(struct be_adapter *adapter ) 
{ 
  int i ;
  int status ;
  struct be_mcc_obj *mcc_obj ;
  bool tmp ;
  int tmp___0 ;

  {
#line 389
  status = 0;
#line 390
  mcc_obj = & adapter->mcc_obj;
#line 392
  i = 0;
#line 392
  goto ldv_53888;
  ldv_53887: 
  {
#line 393
  tmp = be_error(adapter);
  }
#line 393
  if ((int )tmp) {
#line 394
    return (-5);
  } else {

  }
  {
#line 396
  local_bh_disable();
#line 397
  status = be_process_mcc(adapter);
#line 398
  local_bh_enable();
#line 400
  tmp___0 = atomic_read((atomic_t const   *)(& mcc_obj->q.used));
  }
#line 400
  if (tmp___0 == 0) {
#line 401
    goto ldv_53886;
  } else {

  }
  {
#line 402
  __const_udelay(429500UL);
#line 392
  i = i + 1;
  }
  ldv_53888: ;
#line 392
  if (i <= 119999) {
#line 394
    goto ldv_53887;
  } else {

  }
  ldv_53886: ;
#line 404
  if (i == 120000) {
    {
#line 405
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW not responding\n");
#line 406
    adapter->fw_timeout = 1;
    }
#line 407
    return (-5);
  } else {

  }
#line 409
  return (status);
}
}
#line 413 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mcc_notify_wait(struct be_adapter *adapter ) 
{ 
  int status ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_obj *mcc_obj ;
  u16 index ;
  struct be_cmd_resp_hdr *resp ;
  void *tmp ;

  {
  {
#line 417
  mcc_obj = & adapter->mcc_obj;
#line 418
  index = mcc_obj->q.head;
#line 421
  index_dec(& index, (int )mcc_obj->q.len);
#line 422
  tmp = queue_index_node(& mcc_obj->q, (int )index);
#line 422
  wrb = (struct be_mcc_wrb *)tmp;
#line 424
  resp = be_decode_resp_hdr(wrb->tag0, wrb->tag1);
#line 426
  be_mcc_notify(adapter);
#line 428
  status = be_mcc_wait_compl(adapter);
  }
#line 429
  if (status == -5) {
#line 430
    goto out;
  } else {

  }
#line 432
  status = (int )resp->status;
  out: ;
#line 434
  return (status);
}
}
#line 437 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mbox_db_ready_wait(struct be_adapter *adapter , void *db ) 
{ 
  int msecs ;
  u32 ready ;
  bool tmp ;

  {
#line 439
  msecs = 0;
  ldv_53905: 
  {
#line 443
  tmp = be_error(adapter);
  }
#line 443
  if ((int )tmp) {
#line 444
    return (-5);
  } else {

  }
  {
#line 446
  ready = ioread32(db);
  }
#line 447
  if (ready == 4294967295U) {
#line 448
    return (-1);
  } else {

  }
#line 450
  ready = ready & 1U;
#line 451
  if (ready != 0U) {
#line 452
    goto ldv_53904;
  } else {

  }
#line 454
  if (msecs > 4000) {
    {
#line 455
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FW not responding\n");
#line 456
    adapter->fw_timeout = 1;
#line 457
    be_detect_error(adapter);
    }
#line 458
    return (-1);
  } else {

  }
  {
#line 461
  msleep(1U);
#line 462
  msecs = msecs + 1;
  }
#line 463
  goto ldv_53905;
  ldv_53904: ;
#line 465
  return (0);
}
}
#line 472 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mbox_notify_wait(struct be_adapter *adapter ) 
{ 
  int status ;
  u32 val ;
  void *db ;
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_mailbox *mbox ;
  struct be_mcc_compl *compl ;
  bool tmp ;

  {
  {
#line 475
  val = 0U;
#line 476
  db = (void *)adapter->db + 352U;
#line 477
  mbox_mem = & adapter->mbox_mem;
#line 478
  mbox = (struct be_mcc_mailbox *)mbox_mem->va;
#line 479
  compl = & mbox->compl;
#line 482
  status = be_mbox_db_ready_wait(adapter, db);
  }
#line 483
  if (status != 0) {
#line 484
    return (status);
  } else {

  }
  {
#line 486
  val = val | 2U;
#line 488
  val = val | ((u32 )(mbox_mem->dma >> 32ULL) & 4294967292U);
#line 489
  iowrite32(val, db);
#line 492
  status = be_mbox_db_ready_wait(adapter, db);
  }
#line 493
  if (status != 0) {
#line 494
    return (status);
  } else {

  }
  {
#line 496
  val = 0U;
#line 498
  val = val | ((unsigned int )(mbox_mem->dma >> 4) << 2);
#line 499
  iowrite32(val, db);
#line 501
  status = be_mbox_db_ready_wait(adapter, db);
  }
#line 502
  if (status != 0) {
#line 503
    return (status);
  } else {

  }
  {
#line 506
  tmp = be_mcc_compl_is_new(compl);
  }
#line 506
  if ((int )tmp) {
    {
#line 507
    status = be_mcc_compl_process(adapter, & mbox->compl);
#line 508
    be_mcc_compl_use(compl);
    }
#line 509
    if (status != 0) {
#line 510
      return (status);
    } else {

    }
  } else {
    {
#line 512
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "invalid mailbox completion\n");
    }
#line 513
    return (-1);
  }
#line 515
  return (0);
}
}
#line 518 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static u16 be_POST_stage_get(struct be_adapter *adapter ) 
{ 
  u32 sem ;

  {
#line 522
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 523
    sem = ioread32((void *)adapter->csr + 172U);
    }
  } else {
    {
#line 525
    pci_read_config_dword((struct pci_dev  const  *)adapter->pdev, 148, & sem);
    }
  }
#line 528
  return ((u16 )sem);
}
}
#line 531 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int lancer_wait_ready(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;
  int status ;
  int i ;

  {
#line 535
  status = 0;
#line 537
  i = 0;
#line 537
  goto ldv_53927;
  ldv_53926: 
  {
#line 538
  sliport_status = ioread32((void *)adapter->db + 1028U);
  }
#line 539
  if ((sliport_status & 8388608U) != 0U) {
#line 540
    goto ldv_53925;
  } else {

  }
  {
#line 542
  msleep(1000U);
#line 537
  i = i + 1;
  }
  ldv_53927: ;
#line 537
  if (i <= 29) {
#line 539
    goto ldv_53926;
  } else {

  }
  ldv_53925: ;
#line 545
  if (i == 30) {
#line 546
    status = -1;
  } else {

  }
#line 548
  return (status);
}
}
#line 551 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static bool lancer_provisioning_error(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;
  u32 sliport_err1 ;
  u32 sliport_err2 ;

  {
  {
#line 553
  sliport_status = 0U;
#line 553
  sliport_err1 = 0U;
#line 553
  sliport_err2 = 0U;
#line 554
  sliport_status = ioread32((void *)adapter->db + 1028U);
  }
#line 555
  if ((int )sliport_status < 0) {
    {
#line 556
    sliport_err1 = ioread32((void *)adapter->db + 1036U);
#line 558
    sliport_err2 = ioread32((void *)adapter->db + 1040U);
    }
#line 561
    if (sliport_err1 == 2U && sliport_err2 == 9U) {
#line 563
      return (1);
    } else {

    }
  } else {

  }
#line 565
  return (0);
}
}
#line 568 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_test_and_set_rdy_state(struct be_adapter *adapter ) 
{ 
  int status ;
  u32 sliport_status ;
  u32 err ;
  u32 reset_needed ;
  bool resource_error ;

  {
  {
#line 574
  resource_error = lancer_provisioning_error(adapter);
  }
#line 575
  if ((int )resource_error) {
#line 576
    return (-11);
  } else {

  }
  {
#line 578
  status = lancer_wait_ready(adapter);
  }
#line 579
  if (status == 0) {
    {
#line 580
    sliport_status = ioread32((void *)adapter->db + 1028U);
#line 581
    err = sliport_status & 2147483648U;
#line 582
    reset_needed = sliport_status & 16777216U;
    }
#line 583
    if (err != 0U && reset_needed != 0U) {
      {
#line 584
      iowrite32(134217728U, (void *)adapter->db + 1032U);
#line 588
      status = lancer_wait_ready(adapter);
#line 589
      sliport_status = ioread32((void *)adapter->db + 1028U);
#line 591
      sliport_status = sliport_status & 2164260864U;
      }
#line 593
      if (status != 0 || sliport_status != 0U) {
#line 594
        status = -1;
      } else {

      }
    } else
#line 595
    if ((err | reset_needed) != 0U) {
#line 596
      status = -1;
    } else {

    }
  } else {

  }
  {
#line 603
  resource_error = lancer_provisioning_error(adapter);
  }
#line 604
  if ((int )resource_error) {
#line 605
    status = -11;
  } else {

  }
#line 607
  return (status);
}
}
#line 610 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_fw_wait_ready(struct be_adapter *adapter ) 
{ 
  u16 stage ;
  int status ;
  int timeout ;
  struct device *dev ;
  unsigned long tmp ;

  {
#line 613
  timeout = 0;
#line 614
  dev = & (adapter->pdev)->dev;
#line 616
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
    {
#line 617
    status = lancer_wait_ready(adapter);
    }
#line 618
    return (status);
  } else {

  }
  ldv_53949: 
  {
#line 622
  stage = be_POST_stage_get(adapter);
  }
#line 623
  if ((unsigned int )stage == 49152U) {
#line 624
    return (0);
  } else {

  }
  {
#line 626
  _dev_info((struct device  const  *)dev, "Waiting for POST, %ds elapsed\n", timeout);
#line 628
  tmp = msleep_interruptible(2000U);
  }
#line 628
  if (tmp != 0UL) {
    {
#line 629
    dev_err((struct device  const  *)dev, "Waiting for POST aborted\n");
    }
#line 630
    return (-4);
  } else {

  }
#line 632
  timeout = timeout + 2;
#line 633
  if (timeout <= 59) {
#line 635
    goto ldv_53949;
  } else {

  }
  {
#line 635
  dev_err((struct device  const  *)dev, "POST timeout; stage=0x%x\n", (int )stage);
  }
#line 636
  return (-1);
}
}
#line 640 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 642
  return ((struct be_sge *)(& wrb->payload.sgl));
}
}
#line 645 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static void fill_wrb_tags(struct be_mcc_wrb *wrb , unsigned long addr ) 
{ 


  {
#line 648
  wrb->tag0 = (u32 )addr;
#line 649
  wrb->tag1 = (unsigned int )(addr >> 32UL);
#line 650
  return;
}
}
#line 654 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_wrb_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr , u8 subsystem ,
                                   u8 opcode , int cmd_len , struct be_mcc_wrb *wrb ,
                                   struct be_dma_mem *mem ) 
{ 
  struct be_sge *sge ;

  {
  {
#line 660
  req_hdr->opcode = opcode;
#line 661
  req_hdr->subsystem = subsystem;
#line 662
  req_hdr->request_length = (unsigned int )cmd_len - 16U;
#line 663
  req_hdr->version = 0U;
#line 664
  fill_wrb_tags(wrb, (unsigned long )req_hdr);
#line 665
  wrb->payload_length = (u32 )cmd_len;
  }
#line 666
  if ((unsigned long )mem != (unsigned long )((struct be_dma_mem *)0)) {
    {
#line 667
    wrb->embedded = wrb->embedded | 8U;
#line 669
    sge = nonembedded_sgl(wrb);
#line 670
    sge->pa_hi = (unsigned int )(mem->dma >> 32ULL);
#line 671
    sge->pa_lo = (unsigned int )mem->dma;
#line 672
    sge->len = mem->size;
    }
  } else {
#line 674
    wrb->embedded = wrb->embedded | 1U;
  }
  {
#line 675
  swap_dws((void *)wrb, 8);
  }
#line 676
  return;
}
}
#line 678 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_cmd_page_addrs_prepare(struct phys_addr *pages , u32 max_pages , struct be_dma_mem *mem ) 
{ 
  int i ;
  int buf_pages ;
  unsigned int _min1 ;
  u32 _min2 ;
  u64 dma ;

  {
#line 681
  _min1 = (unsigned int )(((((unsigned long )mem->va & 4095UL) + (unsigned long )mem->size) + 4095UL) >> 12);
#line 681
  _min2 = max_pages;
#line 681
  buf_pages = (int )(_min1 < _min2 ? _min1 : _min2);
#line 682
  dma = mem->dma;
#line 684
  i = 0;
#line 684
  goto ldv_53979;
  ldv_53978: 
#line 685
  (pages + (unsigned long )i)->lo = (unsigned int )dma;
#line 686
  (pages + (unsigned long )i)->hi = (unsigned int )(dma >> 32ULL);
#line 687
  dma = dma + 4096ULL;
#line 684
  i = i + 1;
  ldv_53979: ;
#line 684
  if (i < buf_pages) {
#line 686
    goto ldv_53978;
  } else {

  }

#line 691
  return;
}
}
#line 691 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
__inline static struct be_mcc_wrb *wrb_from_mbox(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_wrb *wrb ;

  {
  {
#line 693
  mbox_mem = & adapter->mbox_mem;
#line 694
  wrb = & ((struct be_mcc_mailbox *)mbox_mem->va)->wrb;
#line 696
  memset((void *)wrb, 0, 256UL);
  }
#line 697
  return (wrb);
}
}
#line 700 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_mcc_wrb *wrb_from_mccq(struct be_adapter *adapter ) 
{ 
  struct be_queue_info *mccq ;
  struct be_mcc_wrb *wrb ;
  int tmp ;
  void *tmp___0 ;

  {
#line 702
  mccq = & adapter->mcc_obj.q;
#line 705
  if (! mccq->created) {
#line 706
    return ((struct be_mcc_wrb *)0);
  } else {

  }
  {
#line 708
  tmp = atomic_read((atomic_t const   *)(& mccq->used));
  }
#line 708
  if (tmp >= (int )mccq->len) {
#line 709
    return ((struct be_mcc_wrb *)0);
  } else {

  }
  {
#line 711
  tmp___0 = queue_head_node(mccq);
#line 711
  wrb = (struct be_mcc_wrb *)tmp___0;
#line 712
  queue_head_inc(mccq);
#line 713
  atomic_inc(& mccq->used);
#line 714
  memset((void *)wrb, 0, 256UL);
  }
#line 715
  return (wrb);
}
}
#line 718 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static bool use_mcc(struct be_adapter *adapter ) 
{ 


  {
#line 720
  return (adapter->mcc_obj.q.created);
}
}
#line 724 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_lock(struct be_adapter *adapter ) 
{ 
  int tmp ;
  bool tmp___0 ;

  {
  {
#line 726
  tmp___0 = use_mcc(adapter);
  }
#line 726
  if ((int )tmp___0) {
    {
#line 727
    spin_lock_bh(& adapter->mcc_lock);
    }
#line 728
    return (0);
  } else {
    {
#line 730
    tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
    }
#line 730
    return (tmp);
  }
}
}
#line 735 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_cmd_unlock(struct be_adapter *adapter ) 
{ 
  bool tmp ;

  {
  {
#line 737
  tmp = use_mcc(adapter);
  }
#line 737
  if ((int )tmp) {
    {
#line 738
    spin_unlock_bh(& adapter->mcc_lock);
    }
  } else {
#line 740
    return;
  }
#line 741
  return;
}
}
#line 743 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_mcc_wrb *be_cmd_copy(struct be_adapter *adapter , struct be_mcc_wrb *wrb ) 
{ 
  struct be_mcc_wrb *dest_wrb ;
  bool tmp ;
  void *tmp___0 ;

  {
  {
#line 748
  tmp = use_mcc(adapter);
  }
#line 748
  if ((int )tmp) {
    {
#line 749
    dest_wrb = wrb_from_mccq(adapter);
    }
#line 750
    if ((unsigned long )dest_wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 751
      return ((struct be_mcc_wrb *)0);
    } else {

    }
  } else {
    {
#line 753
    dest_wrb = wrb_from_mbox(adapter);
    }
  }
  {
#line 756
  memcpy((void *)dest_wrb, (void const   *)wrb, 256UL);
  }
#line 757
  if ((int )wrb->embedded & 1) {
    {
#line 758
    tmp___0 = embedded_payload(wrb);
#line 758
    fill_wrb_tags(dest_wrb, (unsigned long )tmp___0);
    }
  } else {

  }
#line 760
  return (dest_wrb);
}
}
#line 764 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_notify_wait(struct be_adapter *adapter , struct be_mcc_wrb *wrb ) 
{ 
  struct be_mcc_wrb *dest_wrb ;
  int status ;
  bool tmp ;

  {
  {
#line 770
  status = be_cmd_lock(adapter);
  }
#line 771
  if (status != 0) {
#line 772
    return (status);
  } else {

  }
  {
#line 774
  dest_wrb = be_cmd_copy(adapter, wrb);
  }
#line 775
  if ((unsigned long )dest_wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 776
    return (-16);
  } else {

  }
  {
#line 778
  tmp = use_mcc(adapter);
  }
#line 778
  if ((int )tmp) {
    {
#line 779
    status = be_mcc_notify_wait(adapter);
    }
  } else {
    {
#line 781
    status = be_mbox_notify_wait(adapter);
    }
  }
#line 783
  if (status == 0) {
    {
#line 784
    memcpy((void *)wrb, (void const   *)dest_wrb, 256UL);
    }
  } else {

  }
  {
#line 786
  be_cmd_unlock(adapter);
  }
#line 787
  return (status);
}
}
#line 793 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_fw_init(struct be_adapter *adapter ) 
{ 
  u8 *wrb ;
  int status ;
  int tmp ;
  struct be_mcc_wrb *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;

  {
#line 798
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 799
    return (0);
  } else {

  }
  {
#line 801
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 801
  if (tmp != 0) {
#line 802
    return (-1);
  } else {

  }
  {
#line 804
  tmp___0 = wrb_from_mbox(adapter);
#line 804
  wrb = (u8 *)tmp___0;
#line 805
  tmp___1 = wrb;
#line 805
  wrb = wrb + 1;
#line 805
  *tmp___1 = 255U;
#line 806
  tmp___2 = wrb;
#line 806
  wrb = wrb + 1;
#line 806
  *tmp___2 = 18U;
#line 807
  tmp___3 = wrb;
#line 807
  wrb = wrb + 1;
#line 807
  *tmp___3 = 52U;
#line 808
  tmp___4 = wrb;
#line 808
  wrb = wrb + 1;
#line 808
  *tmp___4 = 255U;
#line 809
  tmp___5 = wrb;
#line 809
  wrb = wrb + 1;
#line 809
  *tmp___5 = 255U;
#line 810
  tmp___6 = wrb;
#line 810
  wrb = wrb + 1;
#line 810
  *tmp___6 = 86U;
#line 811
  tmp___7 = wrb;
#line 811
  wrb = wrb + 1;
#line 811
  *tmp___7 = 120U;
#line 812
  *wrb = 255U;
#line 814
  status = be_mbox_notify_wait(adapter);
#line 816
  mutex_unlock(& adapter->mbox_lock);
  }
#line 817
  return (status);
}
}
#line 823 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_fw_clean(struct be_adapter *adapter ) 
{ 
  u8 *wrb ;
  int status ;
  int tmp ;
  struct be_mcc_wrb *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;

  {
#line 828
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 829
    return (0);
  } else {

  }
  {
#line 831
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 831
  if (tmp != 0) {
#line 832
    return (-1);
  } else {

  }
  {
#line 834
  tmp___0 = wrb_from_mbox(adapter);
#line 834
  wrb = (u8 *)tmp___0;
#line 835
  tmp___1 = wrb;
#line 835
  wrb = wrb + 1;
#line 835
  *tmp___1 = 255U;
#line 836
  tmp___2 = wrb;
#line 836
  wrb = wrb + 1;
#line 836
  *tmp___2 = 170U;
#line 837
  tmp___3 = wrb;
#line 837
  wrb = wrb + 1;
#line 837
  *tmp___3 = 187U;
#line 838
  tmp___4 = wrb;
#line 838
  wrb = wrb + 1;
#line 838
  *tmp___4 = 255U;
#line 839
  tmp___5 = wrb;
#line 839
  wrb = wrb + 1;
#line 839
  *tmp___5 = 255U;
#line 840
  tmp___6 = wrb;
#line 840
  wrb = wrb + 1;
#line 840
  *tmp___6 = 204U;
#line 841
  tmp___7 = wrb;
#line 841
  wrb = wrb + 1;
#line 841
  *tmp___7 = 221U;
#line 842
  *wrb = 255U;
#line 844
  status = be_mbox_notify_wait(adapter);
#line 846
  mutex_unlock(& adapter->mbox_lock);
  }
#line 847
  return (status);
}
}
#line 850 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_eq_create(struct be_adapter *adapter , struct be_eq_obj *eqo ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eq_create *req ;
  struct be_dma_mem *q_mem ;
  int status ;
  int ver ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_eq_create *resp ;
  void *tmp___5 ;

  {
  {
#line 854
  q_mem = & eqo->q.dma_mem;
#line 855
  ver = 0;
#line 857
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 857
  if (tmp != 0) {
#line 858
    return (-1);
  } else {

  }
  {
#line 860
  wrb = wrb_from_mbox(adapter);
#line 861
  tmp___0 = embedded_payload(wrb);
#line 861
  req = (struct be_cmd_req_eq_create *)tmp___0;
#line 863
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 13, 100, wrb, (struct be_dma_mem *)0);
  }
#line 867
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U)) {
#line 868
    ver = 2;
  } else {

  }
  {
#line 870
  req->hdr.version = (u8 )ver;
#line 871
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 873
  tmp___1 = amap_mask(1U);
#line 873
  amap_set((void *)(& req->context), 0U, tmp___1, 29U, 1U);
#line 875
  tmp___2 = amap_mask(1U);
#line 875
  amap_set((void *)(& req->context), 0U, tmp___2, 31U, 0U);
#line 876
  tmp___3 = __ilog2_u32((unsigned int )eqo->q.len / 256U);
#line 876
  tmp___4 = amap_mask(3U);
#line 876
  amap_set((void *)(& req->context), 1U, tmp___4, 26U, (u32 )tmp___3);
#line 878
  swap_dws((void *)(& req->context), 16);
#line 880
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 882
  status = be_mbox_notify_wait(adapter);
  }
#line 883
  if (status == 0) {
    {
#line 884
    tmp___5 = embedded_payload(wrb);
#line 884
    resp = (struct be_cmd_resp_eq_create *)tmp___5;
#line 885
    eqo->q.id = resp->eq_id;
#line 886
    eqo->msix_idx = ver == 2 ? (u8 )resp->msix_idx : eqo->idx;
#line 888
    eqo->q.created = 1;
    }
  } else {

  }
  {
#line 891
  mutex_unlock(& adapter->mbox_lock);
  }
#line 892
  return (status);
}
}
#line 896 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_mac_addr_query(struct be_adapter *adapter , u8 *mac_addr , bool permanent ,
                          u32 if_handle , u32 pmac_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mac_query *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_mac_query *resp ;
  void *tmp___0 ;

  {
  {
#line 903
  spin_lock_bh(& adapter->mcc_lock);
#line 905
  wrb = wrb_from_mccq(adapter);
  }
#line 906
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 907
    status = -16;
#line 908
    goto err;
  } else {

  }
  {
#line 910
  tmp = embedded_payload(wrb);
#line 910
  req = (struct be_cmd_req_mac_query *)tmp;
#line 912
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 1, 24, wrb, (struct be_dma_mem *)0);
#line 914
  req->type = 1U;
  }
#line 915
  if ((int )permanent) {
#line 916
    req->permanent = 1U;
  } else {
#line 918
    req->if_id = (unsigned short )if_handle;
#line 919
    req->pmac_id = pmac_id;
#line 920
    req->permanent = 0U;
  }
  {
#line 923
  status = be_mcc_notify_wait(adapter);
  }
#line 924
  if (status == 0) {
    {
#line 925
    tmp___0 = embedded_payload(wrb);
#line 925
    resp = (struct be_cmd_resp_mac_query *)tmp___0;
#line 926
    memcpy((void *)mac_addr, (void const   *)(& resp->mac.addr), 6UL);
    }
  } else {

  }
  err: 
  {
#line 930
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 931
  return (status);
}
}
#line 935 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_pmac_add(struct be_adapter *adapter , u8 *mac_addr , u32 if_id , u32 *pmac_id ,
                    u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_pmac_add *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_pmac_add *resp ;
  void *tmp___0 ;

  {
  {
#line 942
  spin_lock_bh(& adapter->mcc_lock);
#line 944
  wrb = wrb_from_mccq(adapter);
  }
#line 945
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 946
    status = -16;
#line 947
    goto err;
  } else {

  }
  {
#line 949
  tmp = embedded_payload(wrb);
#line 949
  req = (struct be_cmd_req_pmac_add *)tmp;
#line 951
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 59, 28, wrb, (struct be_dma_mem *)0);
#line 954
  req->hdr.domain = (u8 )domain;
#line 955
  req->if_id = if_id;
#line 956
  memcpy((void *)(& req->mac_address), (void const   *)mac_addr, 6UL);
#line 958
  status = be_mcc_notify_wait(adapter);
  }
#line 959
  if (status == 0) {
    {
#line 960
    tmp___0 = embedded_payload(wrb);
#line 960
    resp = (struct be_cmd_resp_pmac_add *)tmp___0;
#line 961
    *pmac_id = resp->pmac_id;
    }
  } else {

  }
  err: 
  {
#line 965
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 967
  if (status == 5) {
#line 968
    status = -1;
  } else {

  }
#line 970
  return (status);
}
}
#line 974 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_pmac_del(struct be_adapter *adapter , u32 if_id , int pmac_id , u32 dom ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_pmac_del *req ;
  int status ;
  void *tmp ;

  {
#line 980
  if (pmac_id == -1) {
#line 981
    return (0);
  } else {

  }
  {
#line 983
  spin_lock_bh(& adapter->mcc_lock);
#line 985
  wrb = wrb_from_mccq(adapter);
  }
#line 986
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 987
    status = -16;
#line 988
    goto err;
  } else {

  }
  {
#line 990
  tmp = embedded_payload(wrb);
#line 990
  req = (struct be_cmd_req_pmac_del *)tmp;
#line 992
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 60, 24, wrb, (struct be_dma_mem *)0);
#line 995
  req->hdr.domain = (u8 )dom;
#line 996
  req->if_id = if_id;
#line 997
  req->pmac_id = (unsigned int )pmac_id;
#line 999
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 1002
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1003
  return (status);
}
}
#line 1007 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_cq_create(struct be_adapter *adapter , struct be_queue_info *cq , struct be_queue_info *eq ,
                     bool no_delay , int coalesce_wm ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_cq_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  int tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  int tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  struct be_cmd_resp_cq_create *resp ;
  void *tmp___15 ;

  {
  {
#line 1012
  q_mem = & cq->dma_mem;
#line 1016
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 1016
  if (tmp != 0) {
#line 1017
    return (-1);
  } else {

  }
  {
#line 1019
  wrb = wrb_from_mbox(adapter);
#line 1020
  tmp___0 = embedded_payload(wrb);
#line 1020
  req = (struct be_cmd_req_cq_create *)tmp___0;
#line 1021
  ctxt = (void *)(& req->context);
#line 1023
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 12, 100, wrb, (struct be_dma_mem *)0);
#line 1026
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
  }
#line 1028
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 1029
    tmp___1 = amap_mask(2U);
#line 1029
    amap_set(ctxt, 0U, tmp___1, 12U, (u32 )coalesce_wm);
#line 1031
    tmp___2 = amap_mask(1U);
#line 1031
    amap_set(ctxt, 0U, tmp___2, 14U, (u32 )no_delay);
#line 1033
    tmp___3 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 1033
    tmp___4 = amap_mask(2U);
#line 1033
    amap_set(ctxt, 0U, tmp___4, 27U, (u32 )tmp___3);
#line 1035
    tmp___5 = amap_mask(1U);
#line 1035
    amap_set(ctxt, 0U, tmp___5, 29U, 1U);
#line 1036
    tmp___6 = amap_mask(1U);
#line 1036
    amap_set(ctxt, 0U, tmp___6, 31U, 1U);
#line 1037
    tmp___7 = amap_mask(8U);
#line 1037
    amap_set(ctxt, 1U, tmp___7, 22U, (u32 )eq->id);
    }
  } else {
#line 1039
    req->hdr.version = 2U;
#line 1040
    req->page_size = 1U;
#line 1045
    if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
      {
#line 1046
      tmp___8 = amap_mask(2U);
#line 1046
      amap_set(ctxt, 0U, tmp___8, 12U, (u32 )coalesce_wm);
      }
    } else {

    }
    {
#line 1048
    tmp___9 = amap_mask(1U);
#line 1048
    amap_set(ctxt, 0U, tmp___9, 14U, (u32 )no_delay);
#line 1050
    tmp___10 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 1050
    tmp___11 = amap_mask(2U);
#line 1050
    amap_set(ctxt, 0U, tmp___11, 27U, (u32 )tmp___10);
#line 1052
    tmp___12 = amap_mask(1U);
#line 1052
    amap_set(ctxt, 0U, tmp___12, 29U, 1U);
#line 1053
    tmp___13 = amap_mask(1U);
#line 1053
    amap_set(ctxt, 0U, tmp___13, 31U, 1U);
#line 1055
    tmp___14 = amap_mask(16U);
#line 1055
    amap_set(ctxt, 1U, tmp___14, 0U, (u32 )eq->id);
    }
  }
  {
#line 1059
  swap_dws(ctxt, 16);
#line 1061
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1063
  status = be_mbox_notify_wait(adapter);
  }
#line 1064
  if (status == 0) {
    {
#line 1065
    tmp___15 = embedded_payload(wrb);
#line 1065
    resp = (struct be_cmd_resp_cq_create *)tmp___15;
#line 1066
    cq->id = resp->cq_id;
#line 1067
    cq->created = 1;
    }
  } else {

  }
  {
#line 1070
  mutex_unlock(& adapter->mbox_lock);
  }
#line 1072
  return (status);
}
}
#line 1075 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static u32 be_encoded_q_len(int q_len ) 
{ 
  u32 len_encoded ;
  int tmp ;

  {
  {
#line 1077
  tmp = fls(q_len);
#line 1077
  len_encoded = (u32 )tmp;
  }
#line 1078
  if (len_encoded == 16U) {
#line 1079
    len_encoded = 0U;
  } else {

  }
#line 1080
  return (len_encoded);
}
}
#line 1083 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_mccq_ext_create(struct be_adapter *adapter , struct be_queue_info *mccq ,
                                  struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_ext_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___10 ;

  {
  {
#line 1089
  q_mem = & mccq->dma_mem;
#line 1093
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 1093
  if (tmp != 0) {
#line 1094
    return (-1);
  } else {

  }
  {
#line 1096
  wrb = wrb_from_mbox(adapter);
#line 1097
  tmp___0 = embedded_payload(wrb);
#line 1097
  req = (struct be_cmd_req_mcc_ext_create *)tmp___0;
#line 1098
  ctxt = (void *)(& req->context);
#line 1100
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 90, 104, wrb, (struct be_dma_mem *)0);
#line 1103
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
  }
#line 1104
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 1105
    tmp___1 = amap_mask(1U);
#line 1105
    amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1106
    tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1106
    tmp___3 = amap_mask(4U);
#line 1106
    amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1108
    tmp___4 = amap_mask(10U);
#line 1108
    amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
    }
  } else {
    {
#line 1110
    req->hdr.version = 1U;
#line 1111
    req->cq_id = cq->id;
#line 1113
    tmp___5 = be_encoded_q_len((int )mccq->len);
#line 1113
    tmp___6 = amap_mask(4U);
#line 1113
    amap_set(ctxt, 0U, tmp___6, 16U, tmp___5);
#line 1115
    tmp___7 = amap_mask(1U);
#line 1115
    amap_set(ctxt, 1U, tmp___7, 31U, 1U);
#line 1116
    tmp___8 = amap_mask(16U);
#line 1116
    amap_set(ctxt, 0U, tmp___8, 0U, (u32 )cq->id);
#line 1118
    tmp___9 = amap_mask(1U);
#line 1118
    amap_set(ctxt, 2U, tmp___9, 0U, 1U);
    }
  }
  {
#line 1123
  req->async_event_bitmap[0] = 34U;
#line 1124
  req->async_event_bitmap[0] = req->async_event_bitmap[0] | 64U;
#line 1125
  swap_dws(ctxt, 16);
#line 1127
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1129
  status = be_mbox_notify_wait(adapter);
  }
#line 1130
  if (status == 0) {
    {
#line 1131
    tmp___10 = embedded_payload(wrb);
#line 1131
    resp = (struct be_cmd_resp_mcc_create *)tmp___10;
#line 1132
    mccq->id = resp->id;
#line 1133
    mccq->created = 1;
    }
  } else {

  }
  {
#line 1135
  mutex_unlock(& adapter->mbox_lock);
  }
#line 1137
  return (status);
}
}
#line 1140 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_mccq_org_create(struct be_adapter *adapter , struct be_queue_info *mccq ,
                                  struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_create *req ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___5 ;

  {
  {
#line 1146
  q_mem = & mccq->dma_mem;
#line 1150
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 1150
  if (tmp != 0) {
#line 1151
    return (-1);
  } else {

  }
  {
#line 1153
  wrb = wrb_from_mbox(adapter);
#line 1154
  tmp___0 = embedded_payload(wrb);
#line 1154
  req = (struct be_cmd_req_mcc_create *)tmp___0;
#line 1155
  ctxt = (void *)(& req->context);
#line 1157
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 21, 100, wrb, (struct be_dma_mem *)0);
#line 1160
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1162
  tmp___1 = amap_mask(1U);
#line 1162
  amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1163
  tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1163
  tmp___3 = amap_mask(4U);
#line 1163
  amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1165
  tmp___4 = amap_mask(10U);
#line 1165
  amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
#line 1167
  swap_dws(ctxt, 16);
#line 1169
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1171
  status = be_mbox_notify_wait(adapter);
  }
#line 1172
  if (status == 0) {
    {
#line 1173
    tmp___5 = embedded_payload(wrb);
#line 1173
    resp = (struct be_cmd_resp_mcc_create *)tmp___5;
#line 1174
    mccq->id = resp->id;
#line 1175
    mccq->created = 1;
    }
  } else {

  }
  {
#line 1178
  mutex_unlock(& adapter->mbox_lock);
  }
#line 1179
  return (status);
}
}
#line 1182 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_mccq_create(struct be_adapter *adapter , struct be_queue_info *mccq , struct be_queue_info *cq ) 
{ 
  int status ;

  {
  {
#line 1188
  status = be_cmd_mccq_ext_create(adapter, mccq, cq);
  }
#line 1189
  if (status != 0 && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
    {
#line 1190
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Upgrade to F/W ver 2.102.235.0 or newer to avoid conflicting priorities between NIC and FCoE traffic");
#line 1193
    status = be_cmd_mccq_org_create(adapter, mccq, cq);
    }
  } else {

  }
#line 1195
  return (status);
}
}
#line 1198 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_txq_create(struct be_adapter *adapter , struct be_tx_obj *txo ) 
{ 
  struct be_mcc_wrb wrb ;
  struct be_cmd_req_eth_tx_create *req ;
  struct be_queue_info *txq ;
  struct be_queue_info *cq ;
  struct be_dma_mem *q_mem ;
  int status ;
  int ver ;
  void *tmp ;
  u32 tmp___0 ;
  struct be_cmd_resp_eth_tx_create *resp ;
  void *tmp___1 ;

  {
  {
#line 1200
  wrb.embedded = 0U;
#line 1200
  wrb.payload_length = 0U;
#line 1200
  wrb.tag0 = 0U;
#line 1200
  wrb.tag1 = 0U;
#line 1200
  wrb.rsvd = 0U;
#line 1200
  wrb.payload.embedded_payload[0] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[1] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[2] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[3] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[4] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[5] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[6] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[7] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[8] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[9] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[10] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[11] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[12] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[13] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[14] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[15] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[16] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[17] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[18] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[19] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[20] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[21] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[22] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[23] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[24] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[25] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[26] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[27] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[28] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[29] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[30] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[31] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[32] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[33] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[34] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[35] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[36] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[37] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[38] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[39] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[40] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[41] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[42] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[43] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[44] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[45] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[46] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[47] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[48] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[49] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[50] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[51] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[52] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[53] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[54] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[55] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[56] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[57] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[58] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[59] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[60] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[61] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[62] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[63] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[64] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[65] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[66] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[67] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[68] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[69] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[70] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[71] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[72] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[73] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[74] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[75] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[76] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[77] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[78] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[79] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[80] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[81] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[82] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[83] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[84] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[85] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[86] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[87] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[88] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[89] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[90] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[91] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[92] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[93] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[94] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[95] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[96] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[97] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[98] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[99] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[100] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[101] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[102] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[103] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[104] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[105] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[106] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[107] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[108] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[109] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[110] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[111] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[112] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[113] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[114] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[115] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[116] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[117] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[118] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[119] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[120] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[121] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[122] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[123] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[124] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[125] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[126] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[127] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[128] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[129] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[130] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[131] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[132] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[133] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[134] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[135] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[136] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[137] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[138] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[139] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[140] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[141] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[142] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[143] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[144] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[145] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[146] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[147] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[148] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[149] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[150] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[151] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[152] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[153] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[154] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[155] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[156] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[157] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[158] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[159] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[160] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[161] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[162] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[163] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[164] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[165] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[166] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[167] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[168] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[169] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[170] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[171] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[172] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[173] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[174] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[175] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[176] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[177] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[178] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[179] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[180] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[181] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[182] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[183] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[184] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[185] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[186] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[187] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[188] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[189] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[190] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[191] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[192] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[193] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[194] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[195] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[196] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[197] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[198] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[199] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[200] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[201] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[202] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[203] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[204] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[205] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[206] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[207] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[208] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[209] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[210] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[211] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[212] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[213] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[214] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[215] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[216] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[217] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[218] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[219] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[220] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[221] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[222] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[223] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[224] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[225] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[226] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[227] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[228] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[229] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[230] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[231] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[232] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[233] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[234] = (unsigned char)0;
#line 1200
  wrb.payload.embedded_payload[235] = (unsigned char)0;
#line 1202
  txq = & txo->q;
#line 1203
  cq = & txo->cq;
#line 1204
  q_mem = & txq->dma_mem;
#line 1205
  ver = 0;
#line 1207
  tmp = embedded_payload(& wrb);
#line 1207
  req = (struct be_cmd_req_eth_tx_create *)tmp;
#line 1208
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 7, 148, & wrb, (struct be_dma_mem *)0);
  }
#line 1211
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 1212
    req->hdr.version = 1U;
  } else
#line 1213
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 1214
    if ((adapter->function_caps & 64U) != 0U) {
#line 1215
      req->hdr.version = 2U;
    } else {

    }
  } else {
#line 1217
    req->hdr.version = 2U;
  }
#line 1220
  if ((unsigned int )req->hdr.version != 0U) {
#line 1221
    req->if_id = (unsigned short )adapter->if_handle;
  } else {

  }
  {
#line 1222
  req->num_pages = (u8 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1223
  req->ulp_num = 1U;
#line 1224
  req->type = 2U;
#line 1225
  req->cq_id = cq->id;
#line 1226
  tmp___0 = be_encoded_q_len((int )txq->len);
#line 1226
  req->queue_size = (u8 )tmp___0;
#line 1227
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1228
  ver = (int )req->hdr.version;
#line 1230
  status = be_cmd_notify_wait(adapter, & wrb);
  }
#line 1231
  if (status == 0) {
    {
#line 1232
    tmp___1 = embedded_payload(& wrb);
#line 1232
    resp = (struct be_cmd_resp_eth_tx_create *)tmp___1;
#line 1233
    txq->id = resp->cid;
    }
#line 1234
    if (ver == 2) {
#line 1235
      txo->db_offset = resp->db_offset;
    } else {
#line 1237
      txo->db_offset = 96U;
    }
#line 1238
    txq->created = 1;
  } else {

  }
#line 1241
  return (status);
}
}
#line 1245 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_rxq_create(struct be_adapter *adapter , struct be_queue_info *rxq , u16 cq_id ,
                      u16 frag_size , u32 if_id , u32 rss , u8 *rss_id ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_eth_rx_create *req ;
  struct be_dma_mem *q_mem ;
  int status ;
  void *tmp ;
  int tmp___0 ;
  struct be_cmd_resp_eth_rx_create *resp ;
  void *tmp___1 ;

  {
  {
#line 1251
  q_mem = & rxq->dma_mem;
#line 1254
  spin_lock_bh(& adapter->mcc_lock);
#line 1256
  wrb = wrb_from_mccq(adapter);
  }
#line 1257
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1258
    status = -16;
#line 1259
    goto err;
  } else {

  }
  {
#line 1261
  tmp = embedded_payload(wrb);
#line 1261
  req = (struct be_cmd_req_eth_rx_create *)tmp;
#line 1263
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 8, 48, wrb, (struct be_dma_mem *)0);
#line 1266
  req->cq_id = cq_id;
#line 1267
  tmp___0 = fls((int )frag_size);
#line 1267
  req->frag_size = (unsigned int )((u8 )tmp___0) + 255U;
#line 1268
  req->num_pages = 2U;
#line 1269
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 2U, q_mem);
#line 1270
  req->interface_id = if_id;
#line 1271
  req->max_frame_size = 9018U;
#line 1272
  req->rss_queue = rss;
#line 1274
  status = be_mcc_notify_wait(adapter);
  }
#line 1275
  if (status == 0) {
    {
#line 1276
    tmp___1 = embedded_payload(wrb);
#line 1276
    resp = (struct be_cmd_resp_eth_rx_create *)tmp___1;
#line 1277
    rxq->id = resp->id;
#line 1278
    rxq->created = 1;
#line 1279
    *rss_id = resp->rss_id;
    }
  } else {

  }
  err: 
  {
#line 1283
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1284
  return (status);
}
}
#line 1290 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_q_destroy(struct be_adapter *adapter , struct be_queue_info *q , int queue_type ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_q_destroy *req ;
  u8 subsys ;
  u8 opcode ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 1295
  subsys = 0U;
#line 1295
  opcode = 0U;
#line 1298
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 1298
  if (tmp != 0) {
#line 1299
    return (-1);
  } else {

  }
  {
#line 1301
  wrb = wrb_from_mbox(adapter);
#line 1302
  tmp___0 = embedded_payload(wrb);
#line 1302
  req = (struct be_cmd_req_q_destroy *)tmp___0;
  }
  {
#line 1305
  if (queue_type == 1) {
#line 1305
    goto case_1;
  } else {

  }
#line 1309
  if (queue_type == 2) {
#line 1309
    goto case_2;
  } else {

  }
#line 1313
  if (queue_type == 3) {
#line 1313
    goto case_3;
  } else {

  }
#line 1317
  if (queue_type == 4) {
#line 1317
    goto case_4;
  } else {

  }
#line 1321
  if (queue_type == 5) {
#line 1321
    goto case_5;
  } else {

  }
#line 1325
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1306
  subsys = 1U;
#line 1307
  opcode = 55U;
#line 1308
  goto ldv_54160;
  case_2: /* CIL Label */ 
#line 1310
  subsys = 1U;
#line 1311
  opcode = 54U;
#line 1312
  goto ldv_54160;
  case_3: /* CIL Label */ 
#line 1314
  subsys = 3U;
#line 1315
  opcode = 9U;
#line 1316
  goto ldv_54160;
  case_4: /* CIL Label */ 
#line 1318
  subsys = 3U;
#line 1319
  opcode = 10U;
#line 1320
  goto ldv_54160;
  case_5: /* CIL Label */ 
#line 1322
  subsys = 1U;
#line 1323
  opcode = 53U;
#line 1324
  goto ldv_54160;
  switch_default: /* CIL Label */ 
  {
#line 1326
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/net/ethernet/emulex/benet/be_cmds.c"),
                       "i" (1326), "i" (12UL));
#line 1326
  __builtin_unreachable();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_54160: 
  {
#line 1329
  be_wrb_cmd_hdr_prepare(& req->hdr, (int )subsys, (int )opcode, 20, wrb, (struct be_dma_mem *)0);
#line 1331
  req->id = q->id;
#line 1333
  status = be_mbox_notify_wait(adapter);
#line 1334
  q->created = 0;
#line 1336
  mutex_unlock(& adapter->mbox_lock);
  }
#line 1337
  return (status);
}
}
#line 1341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_rxq_destroy(struct be_adapter *adapter , struct be_queue_info *q ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_q_destroy *req ;
  int status ;
  void *tmp ;

  {
  {
#line 1347
  spin_lock_bh(& adapter->mcc_lock);
#line 1349
  wrb = wrb_from_mccq(adapter);
  }
#line 1350
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1351
    status = -16;
#line 1352
    goto err;
  } else {

  }
  {
#line 1354
  tmp = embedded_payload(wrb);
#line 1354
  req = (struct be_cmd_req_q_destroy *)tmp;
#line 1356
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 10, 20, wrb, (struct be_dma_mem *)0);
#line 1358
  req->id = q->id;
#line 1360
  status = be_mcc_notify_wait(adapter);
#line 1361
  q->created = 0;
  }
  err: 
  {
#line 1364
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1365
  return (status);
}
}
#line 1371 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_if_create(struct be_adapter *adapter , u32 cap_flags , u32 en_flags , u32 *if_handle ,
                     u32 domain ) 
{ 
  struct be_mcc_wrb wrb ;
  struct be_cmd_req_if_create *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_if_create *resp ;
  void *tmp___0 ;

  {
  {
#line 1374
  wrb.embedded = 0U;
#line 1374
  wrb.payload_length = 0U;
#line 1374
  wrb.tag0 = 0U;
#line 1374
  wrb.tag1 = 0U;
#line 1374
  wrb.rsvd = 0U;
#line 1374
  wrb.payload.embedded_payload[0] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[1] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[2] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[3] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[4] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[5] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[6] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[7] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[8] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[9] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[10] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[11] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[12] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[13] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[14] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[15] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[16] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[17] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[18] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[19] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[20] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[21] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[22] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[23] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[24] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[25] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[26] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[27] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[28] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[29] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[30] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[31] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[32] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[33] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[34] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[35] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[36] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[37] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[38] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[39] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[40] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[41] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[42] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[43] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[44] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[45] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[46] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[47] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[48] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[49] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[50] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[51] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[52] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[53] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[54] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[55] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[56] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[57] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[58] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[59] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[60] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[61] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[62] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[63] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[64] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[65] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[66] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[67] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[68] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[69] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[70] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[71] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[72] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[73] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[74] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[75] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[76] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[77] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[78] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[79] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[80] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[81] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[82] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[83] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[84] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[85] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[86] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[87] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[88] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[89] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[90] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[91] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[92] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[93] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[94] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[95] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[96] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[97] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[98] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[99] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[100] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[101] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[102] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[103] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[104] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[105] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[106] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[107] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[108] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[109] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[110] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[111] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[112] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[113] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[114] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[115] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[116] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[117] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[118] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[119] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[120] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[121] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[122] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[123] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[124] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[125] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[126] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[127] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[128] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[129] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[130] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[131] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[132] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[133] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[134] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[135] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[136] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[137] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[138] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[139] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[140] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[141] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[142] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[143] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[144] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[145] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[146] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[147] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[148] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[149] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[150] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[151] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[152] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[153] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[154] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[155] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[156] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[157] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[158] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[159] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[160] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[161] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[162] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[163] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[164] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[165] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[166] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[167] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[168] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[169] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[170] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[171] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[172] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[173] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[174] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[175] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[176] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[177] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[178] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[179] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[180] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[181] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[182] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[183] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[184] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[185] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[186] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[187] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[188] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[189] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[190] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[191] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[192] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[193] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[194] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[195] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[196] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[197] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[198] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[199] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[200] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[201] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[202] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[203] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[204] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[205] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[206] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[207] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[208] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[209] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[210] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[211] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[212] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[213] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[214] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[215] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[216] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[217] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[218] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[219] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[220] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[221] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[222] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[223] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[224] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[225] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[226] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[227] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[228] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[229] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[230] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[231] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[232] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[233] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[234] = (unsigned char)0;
#line 1374
  wrb.payload.embedded_payload[235] = (unsigned char)0;
#line 1378
  tmp = embedded_payload(& wrb);
#line 1378
  req = (struct be_cmd_req_if_create *)tmp;
#line 1379
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 50, 40, & wrb, (struct be_dma_mem *)0);
#line 1381
  req->hdr.domain = (u8 )domain;
#line 1382
  req->capability_flags = cap_flags;
#line 1383
  req->enable_flags = en_flags;
#line 1384
  req->pmac_invalid = 1U;
#line 1386
  status = be_cmd_notify_wait(adapter, & wrb);
  }
#line 1387
  if (status == 0) {
    {
#line 1388
    tmp___0 = embedded_payload(& wrb);
#line 1388
    resp = (struct be_cmd_resp_if_create *)tmp___0;
#line 1389
    *if_handle = resp->interface_id;
    }
#line 1392
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) && (unsigned int )adapter->virtfn != 0U) {
#line 1393
      *(adapter->pmac_id) = resp->pmac_id;
    } else {

    }
  } else {

  }
#line 1395
  return (status);
}
}
#line 1399 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_if_destroy(struct be_adapter *adapter , int interface_id , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_if_destroy *req ;
  int status ;
  void *tmp ;

  {
#line 1405
  if (interface_id == -1) {
#line 1406
    return (0);
  } else {

  }
  {
#line 1408
  spin_lock_bh(& adapter->mcc_lock);
#line 1410
  wrb = wrb_from_mccq(adapter);
  }
#line 1411
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1412
    status = -16;
#line 1413
    goto err;
  } else {

  }
  {
#line 1415
  tmp = embedded_payload(wrb);
#line 1415
  req = (struct be_cmd_req_if_destroy *)tmp;
#line 1417
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 51, 20, wrb, (struct be_dma_mem *)0);
#line 1419
  req->hdr.domain = (u8 )domain;
#line 1420
  req->interface_id = (unsigned int )interface_id;
#line 1422
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 1424
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1425
  return (status);
}
}
#line 1432 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *hdr ;
  int status ;

  {
  {
#line 1436
  status = 0;
#line 1438
  spin_lock_bh(& adapter->mcc_lock);
#line 1440
  wrb = wrb_from_mccq(adapter);
  }
#line 1441
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1442
    status = -16;
#line 1443
    goto err;
  } else {

  }
  {
#line 1445
  hdr = (struct be_cmd_req_hdr *)nonemb_cmd->va;
#line 1447
  be_wrb_cmd_hdr_prepare(hdr, 3, 4, (int )nonemb_cmd->size, wrb, nonemb_cmd);
  }
#line 1451
  if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 1452
    hdr->version = 0U;
  } else {

  }
#line 1453
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U)) {
#line 1454
    hdr->version = 1U;
  } else {
#line 1456
    hdr->version = 2U;
  }
  {
#line 1458
  be_mcc_notify(adapter);
#line 1459
  adapter->stats_cmd_sent = 1;
  }
  err: 
  {
#line 1462
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1463
  return (status);
}
}
#line 1467 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_cmd_get_pport_stats(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_pport_stats *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 1473
  status = 0;
#line 1475
  tmp = be_cmd_allowed(adapter, 18, 3);
  }
#line 1475
  if (tmp) {
#line 1475
    tmp___0 = 0;
  } else {
#line 1475
    tmp___0 = 1;
  }
#line 1475
  if (tmp___0) {
#line 1477
    return (-1);
  } else {

  }
  {
#line 1479
  spin_lock_bh(& adapter->mcc_lock);
#line 1481
  wrb = wrb_from_mccq(adapter);
  }
#line 1482
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1483
    status = -16;
#line 1484
    goto err;
  } else {

  }
  {
#line 1486
  req = (struct lancer_cmd_req_pport_stats *)nonemb_cmd->va;
#line 1488
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 18, (int )nonemb_cmd->size, wrb, nonemb_cmd);
#line 1492
  req->cmd_params.params.pport_num = (unsigned short )adapter->hba_port_num;
#line 1493
  req->cmd_params.params.reset_stats = 0U;
#line 1495
  be_mcc_notify(adapter);
#line 1496
  adapter->stats_cmd_sent = 1;
  }
  err: 
  {
#line 1499
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1500
  return (status);
}
}
#line 1503 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_mac_to_link_speed(int mac_speed ) 
{ 


  {
  {
#line 1506
  if (mac_speed == 0) {
#line 1506
    goto case_0;
  } else {

  }
#line 1508
  if (mac_speed == 1) {
#line 1508
    goto case_1;
  } else {

  }
#line 1510
  if (mac_speed == 2) {
#line 1510
    goto case_2;
  } else {

  }
#line 1512
  if (mac_speed == 3) {
#line 1512
    goto case_3;
  } else {

  }
#line 1514
  if (mac_speed == 4) {
#line 1514
    goto case_4;
  } else {

  }
#line 1516
  if (mac_speed == 5) {
#line 1516
    goto case_5;
  } else {

  }
#line 1518
  if (mac_speed == 6) {
#line 1518
    goto case_6;
  } else {

  }
#line 1520
  if (mac_speed == 7) {
#line 1520
    goto case_7;
  } else {

  }
#line 1505
  goto switch_break;
  case_0: /* CIL Label */ ;
#line 1507
  return (0);
  case_1: /* CIL Label */ ;
#line 1509
  return (10);
  case_2: /* CIL Label */ ;
#line 1511
  return (100);
  case_3: /* CIL Label */ ;
#line 1513
  return (1000);
  case_4: /* CIL Label */ ;
#line 1515
  return (10000);
  case_5: /* CIL Label */ ;
#line 1517
  return (20000);
  case_6: /* CIL Label */ ;
#line 1519
  return (25000);
  case_7: /* CIL Label */ ;
#line 1521
  return (40000);
  switch_break: /* CIL Label */ ;
  }
#line 1523
  return (0);
}
}
#line 1529 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_link_status_query(struct be_adapter *adapter , u16 *link_speed , u8 *link_status ,
                             u32 dom ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_link_status *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_link_status *resp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1536
  spin_lock_bh(& adapter->mcc_lock);
  }
#line 1538
  if ((unsigned long )link_status != (unsigned long )((u8 *)0U)) {
#line 1539
    *link_status = 0U;
  } else {

  }
  {
#line 1541
  wrb = wrb_from_mccq(adapter);
  }
#line 1542
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1543
    status = -16;
#line 1544
    goto err;
  } else {

  }
  {
#line 1546
  tmp = embedded_payload(wrb);
#line 1546
  req = (struct be_cmd_req_link_status *)tmp;
#line 1548
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 5, 20, wrb, (struct be_dma_mem *)0);
  }
#line 1552
  if ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U) {
#line 1553
    req->hdr.version = 1U;
  } else {

  }
  {
#line 1555
  req->hdr.domain = (u8 )dom;
#line 1557
  status = be_mcc_notify_wait(adapter);
  }
#line 1558
  if (status == 0) {
    {
#line 1559
    tmp___0 = embedded_payload(wrb);
#line 1559
    resp = (struct be_cmd_resp_link_status *)tmp___0;
    }
#line 1560
    if ((unsigned long )link_speed != (unsigned long )((u16 *)0U)) {
#line 1561
      if ((unsigned int )resp->link_speed != 0U) {
#line 1561
        *link_speed = (unsigned int )resp->link_speed * 10U;
      } else {
        {
#line 1561
        tmp___1 = be_mac_to_link_speed((int )resp->mac_speed);
#line 1561
        *link_speed = (u16 )tmp___1;
        }
      }
#line 1565
      if ((unsigned int )resp->logical_link_status == 0U) {
#line 1566
        *link_speed = 0U;
      } else {

      }
    } else {

    }
#line 1568
    if ((unsigned long )link_status != (unsigned long )((u8 *)0U)) {
#line 1569
      *link_status = resp->logical_link_status;
    } else {

    }
  } else {

  }
  err: 
  {
#line 1573
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1574
  return (status);
}
}
#line 1578 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_die_temperature(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_cntl_addnl_attribs *req ;
  int status ;
  void *tmp ;

  {
  {
#line 1582
  status = 0;
#line 1584
  spin_lock_bh(& adapter->mcc_lock);
#line 1586
  wrb = wrb_from_mccq(adapter);
  }
#line 1587
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1588
    status = -16;
#line 1589
    goto err;
  } else {

  }
  {
#line 1591
  tmp = embedded_payload(wrb);
#line 1591
  req = (struct be_cmd_req_get_cntl_addnl_attribs *)tmp;
#line 1593
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 121, 24, wrb, (struct be_dma_mem *)0);
#line 1597
  be_mcc_notify(adapter);
  }
  err: 
  {
#line 1600
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1601
  return (status);
}
}
#line 1605 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_reg_len(struct be_adapter *adapter , u32 *log_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fat *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fat *resp ;
  void *tmp___0 ;

  {
  {
#line 1611
  spin_lock_bh(& adapter->mcc_lock);
#line 1613
  wrb = wrb_from_mccq(adapter);
  }
#line 1614
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1615
    status = -16;
#line 1616
    goto err;
  } else {

  }
  {
#line 1618
  tmp = embedded_payload(wrb);
#line 1618
  req = (struct be_cmd_req_get_fat *)tmp;
#line 1620
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 68, 36, wrb, (struct be_dma_mem *)0);
#line 1622
  req->fat_operation = 1U;
#line 1623
  status = be_mcc_notify_wait(adapter);
  }
#line 1624
  if (status == 0) {
    {
#line 1625
    tmp___0 = embedded_payload(wrb);
#line 1625
    resp = (struct be_cmd_resp_get_fat *)tmp___0;
    }
#line 1626
    if ((unsigned long )log_size != (unsigned long )((u32 *)0U) && resp->log_size != 0U) {
#line 1627
      *log_size = resp->log_size - 4U;
    } else {

    }
  } else {

  }
  err: 
  {
#line 1631
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1632
  return (status);
}
}
#line 1635 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
void be_cmd_get_regs(struct be_adapter *adapter , u32 buf_len , void *buf ) 
{ 
  struct be_dma_mem get_fat_cmd ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fat *req ;
  u32 offset ;
  u32 total_size ;
  u32 buf_size ;
  u32 log_offset ;
  u32 payload_len ;
  int status ;
  u32 _min1 ;
  unsigned int _min2 ;
  struct be_cmd_resp_get_fat *resp ;

  {
#line 1640
  offset = 0U;
#line 1641
  log_offset = 4U;
#line 1644
  if (buf_len == 0U) {
#line 1645
    return;
  } else {

  }
  {
#line 1647
  total_size = buf_len;
#line 1649
  get_fat_cmd.size = 61476U;
#line 1650
  get_fat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )get_fat_cmd.size,
                                        & get_fat_cmd.dma);
  }
#line 1653
  if ((unsigned long )get_fat_cmd.va == (unsigned long )((void *)0)) {
    {
#line 1654
    status = -12;
#line 1655
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure while retrieving FAT data\n");
    }
#line 1657
    return;
  } else {

  }
  {
#line 1660
  spin_lock_bh(& adapter->mcc_lock);
  }
#line 1662
  goto ldv_54268;
  ldv_54267: 
  {
#line 1663
  _min1 = total_size;
#line 1663
  _min2 = 61440U;
#line 1663
  buf_size = _min1 < _min2 ? _min1 : _min2;
#line 1664
  total_size = total_size - buf_size;
#line 1666
  wrb = wrb_from_mccq(adapter);
  }
#line 1667
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1668
    status = -16;
#line 1669
    goto err;
  } else {

  }
  {
#line 1671
  req = (struct be_cmd_req_get_fat *)get_fat_cmd.va;
#line 1673
  payload_len = buf_size + 36U;
#line 1674
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 68, (int )payload_len, wrb, & get_fat_cmd);
#line 1678
  req->fat_operation = 0U;
#line 1679
  req->read_log_offset = log_offset;
#line 1680
  req->read_log_length = buf_size;
#line 1681
  req->data_buffer_size = buf_size;
#line 1683
  status = be_mcc_notify_wait(adapter);
  }
#line 1684
  if (status == 0) {
    {
#line 1685
    resp = (struct be_cmd_resp_get_fat *)get_fat_cmd.va;
#line 1686
    memcpy(buf + (unsigned long )offset, (void const   *)(& resp->data_buffer), (size_t )resp->read_log_length);
    }
  } else {
    {
#line 1690
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "FAT Table Retrieve error\n");
    }
#line 1691
    goto err;
  }
#line 1693
  offset = offset + buf_size;
#line 1694
  log_offset = log_offset + buf_size;
  ldv_54268: ;
#line 1662
  if (total_size != 0U) {
#line 1664
    goto ldv_54267;
  } else {

  }

  err: 
  {
#line 1697
  pci_free_consistent(adapter->pdev, (size_t )get_fat_cmd.size, get_fat_cmd.va, get_fat_cmd.dma);
#line 1700
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1701
  return;
}
}
#line 1704 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_fw_ver(struct be_adapter *adapter , char *fw_ver , char *fw_on_flash ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fw_version *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fw_version *resp ;
  void *tmp___0 ;

  {
  {
#line 1711
  spin_lock_bh(& adapter->mcc_lock);
#line 1713
  wrb = wrb_from_mccq(adapter);
  }
#line 1714
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1715
    status = -16;
#line 1716
    goto err;
  } else {

  }
  {
#line 1719
  tmp = embedded_payload(wrb);
#line 1719
  req = (struct be_cmd_req_get_fw_version *)tmp;
#line 1721
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 35, 80, wrb, (struct be_dma_mem *)0);
#line 1723
  status = be_mcc_notify_wait(adapter);
  }
#line 1724
  if (status == 0) {
    {
#line 1725
    tmp___0 = embedded_payload(wrb);
#line 1725
    resp = (struct be_cmd_resp_get_fw_version *)tmp___0;
#line 1726
    strcpy(fw_ver, (char const   *)(& resp->firmware_version_string));
    }
#line 1727
    if ((unsigned long )fw_on_flash != (unsigned long )((char *)0)) {
      {
#line 1728
      strcpy(fw_on_flash, (char const   *)(& resp->fw_on_flash_version_string));
      }
    } else {

    }
  } else {

  }
  err: 
  {
#line 1731
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1732
  return (status);
}
}
#line 1738 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_modify_eqd(struct be_adapter *adapter , struct be_set_eqd *set_eqd , int num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_modify_eq_delay *req ;
  int status ;
  int i ;
  void *tmp ;

  {
  {
#line 1743
  status = 0;
#line 1745
  spin_lock_bh(& adapter->mcc_lock);
#line 1747
  wrb = wrb_from_mccq(adapter);
  }
#line 1748
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1749
    status = -16;
#line 1750
    goto err;
  } else {

  }
  {
#line 1752
  tmp = embedded_payload(wrb);
#line 1752
  req = (struct be_cmd_req_modify_eq_delay *)tmp;
#line 1754
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 41, 404, wrb, (struct be_dma_mem *)0);
#line 1757
  req->num_eq = (unsigned int )num;
#line 1758
  i = 0;
  }
#line 1758
  goto ldv_54291;
  ldv_54290: 
#line 1759
  req->set_eqd[i].eq_id = (set_eqd + (unsigned long )i)->eq_id;
#line 1760
  req->set_eqd[i].phase = 0U;
#line 1761
  req->set_eqd[i].delay_multiplier = (set_eqd + (unsigned long )i)->delay_multiplier;
#line 1758
  i = i + 1;
  ldv_54291: ;
#line 1758
  if (i < num) {
#line 1760
    goto ldv_54290;
  } else {

  }
  {
#line 1765
  be_mcc_notify(adapter);
  }
  err: 
  {
#line 1767
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1768
  return (status);
}
}
#line 1772 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_vlan_config(struct be_adapter *adapter , u32 if_id , u16 *vtag_array ,
                       u32 num , bool promiscuous ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_vlan_config *req ;
  int status ;
  void *tmp ;

  {
  {
#line 1779
  spin_lock_bh(& adapter->mcc_lock);
#line 1781
  wrb = wrb_from_mccq(adapter);
  }
#line 1782
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1783
    status = -16;
#line 1784
    goto err;
  } else {

  }
  {
#line 1786
  tmp = embedded_payload(wrb);
#line 1786
  req = (struct be_cmd_req_vlan_config *)tmp;
#line 1788
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 4, 148, wrb, (struct be_dma_mem *)0);
#line 1791
  req->interface_id = (u8 )if_id;
#line 1792
  req->promiscuous = (u8 )promiscuous;
#line 1793
  req->untagged = (adapter->res.if_cap_flags & 32U) != 0U;
#line 1794
  req->num_vlan = (u8 )num;
  }
#line 1795
  if (! promiscuous) {
    {
#line 1796
    memcpy((void *)(& req->normal_vlan), (void const   *)vtag_array, (unsigned long )req->num_vlan * 2UL);
    }
  } else {

  }
  {
#line 1800
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 1803
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1804
  return (status);
}
}
#line 1807 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_rx_filter(struct be_adapter *adapter , u32 flags , u32 value ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_dma_mem *mem ;
  struct be_cmd_req_rx_filter *req ;
  int status ;
  u32 tmp ;
  struct netdev_hw_addr *ha ;
  int i ;
  u32 tmp___0 ;
  struct list_head  const  *__mptr ;
  int tmp___1 ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 1810
  mem = & adapter->rx_filter;
#line 1811
  req = (struct be_cmd_req_rx_filter *)mem->va;
#line 1814
  spin_lock_bh(& adapter->mcc_lock);
#line 1816
  wrb = wrb_from_mccq(adapter);
  }
#line 1817
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1818
    status = -16;
#line 1819
    goto err;
  } else {

  }
  {
#line 1821
  memset((void *)req, 0, 424UL);
#line 1822
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 34, 424, wrb, mem);
#line 1826
  req->if_id = (unsigned int )adapter->if_handle;
  }
#line 1827
  if ((flags & 256U) != 0U) {
#line 1828
    req->if_flags_mask = 648U;
#line 1831
    if (value == 1U) {
#line 1832
      req->if_flags = 648U;
    } else {

    }
  } else
#line 1835
  if ((flags & 512U) != 0U) {
#line 1836
    tmp = 512U;
#line 1836
    req->if_flags = tmp;
#line 1836
    req->if_flags_mask = tmp;
  } else
#line 1838
  if ((flags & 16U) != 0U) {
#line 1839
    req->if_flags_mask = 128U;
#line 1841
    if (value == 1U) {
#line 1842
      req->if_flags = 128U;
    } else {

    }
  } else {
#line 1846
    i = 0;
#line 1848
    tmp___0 = 4096U;
#line 1848
    req->if_flags = tmp___0;
#line 1848
    req->if_flags_mask = tmp___0;
#line 1854
    req->if_flags_mask = req->if_flags_mask | (adapter->res.if_cap_flags & 512U);
#line 1857
    req->mcast_num = (unsigned int )(adapter->netdev)->mc.count;
#line 1858
    __mptr = (struct list_head  const  *)(adapter->netdev)->mc.list.next;
#line 1858
    ha = (struct netdev_hw_addr *)__mptr;
#line 1858
    goto ldv_54321;
    ldv_54320: 
    {
#line 1859
    tmp___1 = i;
#line 1859
    i = i + 1;
#line 1859
    memcpy((void *)(& req->mcast_mac[tmp___1].byte), (void const   *)(& ha->addr),
           6UL);
#line 1858
    __mptr___0 = (struct list_head  const  *)ha->list.next;
#line 1858
    ha = (struct netdev_hw_addr *)__mptr___0;
    }
    ldv_54321: ;
#line 1858
    if ((unsigned long )(& ha->list) != (unsigned long )(& (adapter->netdev)->mc.list)) {
#line 1860
      goto ldv_54320;
    } else {

    }

  }
#line 1862
  if ((req->if_flags_mask & adapter->res.if_cap_flags) != req->if_flags_mask) {
    {
#line 1864
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Cannot set rx filter flags 0x%x\n",
             req->if_flags_mask);
#line 1867
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Interface is capable of 0x%x flags only\n",
             adapter->res.if_cap_flags);
    }
  } else {

  }
  {
#line 1871
  req->if_flags_mask = req->if_flags_mask & adapter->res.if_cap_flags;
#line 1873
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 1876
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1877
  return (status);
}
}
#line 1881 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_flow_control(struct be_adapter *adapter , u32 tx_fc , u32 rx_fc ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_flow_control *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1887
  tmp = be_cmd_allowed(adapter, 36, 1);
  }
#line 1887
  if (tmp) {
#line 1887
    tmp___0 = 0;
  } else {
#line 1887
    tmp___0 = 1;
  }
#line 1887
  if (tmp___0) {
#line 1889
    return (-1);
  } else {

  }
  {
#line 1891
  spin_lock_bh(& adapter->mcc_lock);
#line 1893
  wrb = wrb_from_mccq(adapter);
  }
#line 1894
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1895
    status = -16;
#line 1896
    goto err;
  } else {

  }
  {
#line 1898
  tmp___1 = embedded_payload(wrb);
#line 1898
  req = (struct be_cmd_req_set_flow_control *)tmp___1;
#line 1900
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 36, 20, wrb, (struct be_dma_mem *)0);
#line 1903
  req->tx_flow_control = (unsigned short )tx_fc;
#line 1904
  req->rx_flow_control = (unsigned short )rx_fc;
#line 1906
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 1909
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1910
  return (status);
}
}
#line 1914 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_flow_control(struct be_adapter *adapter , u32 *tx_fc , u32 *rx_fc ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_flow_control *req ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct be_cmd_resp_get_flow_control *resp ;
  void *tmp___2 ;

  {
  {
#line 1920
  tmp = be_cmd_allowed(adapter, 37, 1);
  }
#line 1920
  if (tmp) {
#line 1920
    tmp___0 = 0;
  } else {
#line 1920
    tmp___0 = 1;
  }
#line 1920
  if (tmp___0) {
#line 1922
    return (-1);
  } else {

  }
  {
#line 1924
  spin_lock_bh(& adapter->mcc_lock);
#line 1926
  wrb = wrb_from_mccq(adapter);
  }
#line 1927
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 1928
    status = -16;
#line 1929
    goto err;
  } else {

  }
  {
#line 1931
  tmp___1 = embedded_payload(wrb);
#line 1931
  req = (struct be_cmd_req_get_flow_control *)tmp___1;
#line 1933
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 37, 20, wrb, (struct be_dma_mem *)0);
#line 1936
  status = be_mcc_notify_wait(adapter);
  }
#line 1937
  if (status == 0) {
    {
#line 1938
    tmp___2 = embedded_payload(wrb);
#line 1938
    resp = (struct be_cmd_resp_get_flow_control *)tmp___2;
#line 1940
    *tx_fc = (u32 )resp->tx_flow_control;
#line 1941
    *rx_fc = (u32 )resp->rx_flow_control;
    }
  } else {

  }
  err: 
  {
#line 1945
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 1946
  return (status);
}
}
#line 1950 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_query_fw_cfg(struct be_adapter *adapter , u32 *port_num , u32 *mode , u32 *caps ,
                        u16 *asic_rev ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_query_fw_cfg *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_query_fw_cfg *resp ;
  void *tmp___1 ;

  {
  {
#line 1957
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 1957
  if (tmp != 0) {
#line 1958
    return (-1);
  } else {

  }
  {
#line 1960
  wrb = wrb_from_mbox(adapter);
#line 1961
  tmp___0 = embedded_payload(wrb);
#line 1961
  req = (struct be_cmd_req_query_fw_cfg *)tmp___0;
#line 1963
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 58, 140, wrb, (struct be_dma_mem *)0);
#line 1966
  status = be_mbox_notify_wait(adapter);
  }
#line 1967
  if (status == 0) {
    {
#line 1968
    tmp___1 = embedded_payload(wrb);
#line 1968
    resp = (struct be_cmd_resp_query_fw_cfg *)tmp___1;
#line 1969
    *port_num = resp->phys_port;
#line 1970
    *mode = resp->function_mode;
#line 1971
    *caps = resp->function_caps;
#line 1972
    *asic_rev = (unsigned int )((u16 )resp->asic_revision) & 255U;
    }
  } else {

  }
  {
#line 1975
  mutex_unlock(& adapter->mbox_lock);
  }
#line 1976
  return (status);
}
}
#line 1980 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_reset_function(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1986
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
    {
#line 1987
    status = lancer_wait_ready(adapter);
    }
#line 1988
    if (status == 0) {
      {
#line 1989
      iowrite32(134217728U, (void *)adapter->db + 1032U);
#line 1991
      status = lancer_test_and_set_rdy_state(adapter);
      }
    } else {

    }
#line 1993
    if (status != 0) {
      {
#line 1994
      dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Adapter in non recoverable error\n");
      }
    } else {

    }
#line 1997
    return (status);
  } else {

  }
  {
#line 2000
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 2000
  if (tmp != 0) {
#line 2001
    return (-1);
  } else {

  }
  {
#line 2003
  wrb = wrb_from_mbox(adapter);
#line 2004
  tmp___0 = embedded_payload(wrb);
#line 2004
  req = (struct be_cmd_req_hdr *)tmp___0;
#line 2006
  be_wrb_cmd_hdr_prepare(req, 1, 61, 16, wrb, (struct be_dma_mem *)0);
#line 2009
  status = be_mbox_notify_wait(adapter);
#line 2011
  mutex_unlock(& adapter->mbox_lock);
  }
#line 2012
  return (status);
}
}
#line 2015 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_rss_config(struct be_adapter *adapter , u8 *rsstable , u32 rss_hash_opts ,
                      u16 table_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_rss_config *req ;
  u32 myhash[10U] ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 2020
  myhash[0] = 366231461U;
#line 2020
  myhash[1] = 624191578U;
#line 2020
  myhash[2] = 1602709818U;
#line 2020
  myhash[3] = 1449675086U;
#line 2020
  myhash[4] = 869231187U;
#line 2020
  myhash[5] = 942879942U;
#line 2020
  myhash[6] = 1991000663U;
#line 2020
  myhash[7] = 1504854706U;
#line 2020
  myhash[8] = 1051212802U;
#line 2020
  myhash[9] = 1242628868U;
#line 2025
  if ((adapter->res.if_cap_flags & 4U) == 0U) {
#line 2026
    return (0);
  } else {

  }
  {
#line 2028
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 2028
  if (tmp != 0) {
#line 2029
    return (-1);
  } else {

  }
  {
#line 2031
  wrb = wrb_from_mbox(adapter);
#line 2032
  tmp___0 = embedded_payload(wrb);
#line 2032
  req = (struct be_cmd_req_rss_config *)tmp___0;
#line 2034
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 1, 196, wrb, (struct be_dma_mem *)0);
#line 2037
  req->if_id = (unsigned int )adapter->if_handle;
#line 2038
  req->enable_rss = (unsigned short )rss_hash_opts;
#line 2039
  tmp___1 = fls((int )table_size);
#line 2039
  req->cpu_table_size_log2 = (unsigned int )((unsigned short )tmp___1) - 1U;
  }
#line 2041
  if (((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) || ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U)) {
#line 2042
    req->hdr.version = 1U;
  } else {

  }
  {
#line 2044
  memcpy((void *)(& req->cpu_table), (void const   *)rsstable, (size_t )table_size);
#line 2045
  memcpy((void *)(& req->hash), (void const   *)(& myhash), 40UL);
#line 2046
  swap_dws((void *)(& req->hash), 40);
#line 2048
  status = be_mbox_notify_wait(adapter);
#line 2050
  mutex_unlock(& adapter->mbox_lock);
  }
#line 2051
  return (status);
}
}
#line 2055 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_beacon_state(struct be_adapter *adapter , u8 port_num , u8 bcn , u8 sts ,
                            u8 state ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_enable_disable_beacon *req ;
  int status ;
  void *tmp ;

  {
  {
#line 2062
  spin_lock_bh(& adapter->mcc_lock);
#line 2064
  wrb = wrb_from_mccq(adapter);
  }
#line 2065
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2066
    status = -16;
#line 2067
    goto err;
  } else {

  }
  {
#line 2069
  tmp = embedded_payload(wrb);
#line 2069
  req = (struct be_cmd_req_enable_disable_beacon *)tmp;
#line 2071
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 69, 20, wrb, (struct be_dma_mem *)0);
#line 2074
  req->port_num = port_num;
#line 2075
  req->beacon_state = state;
#line 2076
  req->beacon_duration = bcn;
#line 2077
  req->status_duration = sts;
#line 2079
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 2082
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2083
  return (status);
}
}
#line 2087 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_beacon_state(struct be_adapter *adapter , u8 port_num , u32 *state ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_beacon_state *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_beacon_state *resp ;
  void *tmp___0 ;

  {
  {
#line 2093
  spin_lock_bh(& adapter->mcc_lock);
#line 2095
  wrb = wrb_from_mccq(adapter);
  }
#line 2096
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2097
    status = -16;
#line 2098
    goto err;
  } else {

  }
  {
#line 2100
  tmp = embedded_payload(wrb);
#line 2100
  req = (struct be_cmd_req_get_beacon_state *)tmp;
#line 2102
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 70, 20, wrb, (struct be_dma_mem *)0);
#line 2105
  req->port_num = port_num;
#line 2107
  status = be_mcc_notify_wait(adapter);
  }
#line 2108
  if (status == 0) {
    {
#line 2109
    tmp___0 = embedded_payload(wrb);
#line 2109
    resp = (struct be_cmd_resp_get_beacon_state *)tmp___0;
#line 2111
    *state = (u32 )resp->beacon_state;
    }
  } else {

  }
  err: 
  {
#line 2115
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2116
  return (status);
}
}
#line 2119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_cmd_write_object(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                            u32 data_size , u32 data_offset , char const   *obj_name ,
                            u32 *data_written , u8 *change_status , u8 *addn_status ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_write_object *req ;
  struct lancer_cmd_resp_write_object *resp ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 2127
  ctxt = (void *)0;
#line 2130
  spin_lock_bh(& adapter->mcc_lock);
#line 2131
  adapter->flash_status = 0U;
#line 2133
  wrb = wrb_from_mccq(adapter);
  }
#line 2134
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2135
    status = -16;
#line 2136
    goto err_unlock;
  } else {

  }
  {
#line 2139
  tmp = embedded_payload(wrb);
#line 2139
  req = (struct lancer_cmd_req_write_object *)tmp;
#line 2141
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 172, 144, wrb, (struct be_dma_mem *)0);
#line 2146
  ctxt = (void *)(& req->context);
#line 2147
  tmp___0 = amap_mask(24U);
#line 2147
  amap_set(ctxt, 0U, tmp___0, 0U, data_size);
  }
#line 2150
  if (data_size == 0U) {
    {
#line 2151
    tmp___1 = amap_mask(1U);
#line 2151
    amap_set(ctxt, 0U, tmp___1, 31U, 1U);
    }
  } else {
    {
#line 2154
    tmp___2 = amap_mask(1U);
#line 2154
    amap_set(ctxt, 0U, tmp___2, 31U, 0U);
    }
  }
  {
#line 2157
  swap_dws(ctxt, 4);
#line 2158
  req->write_offset = data_offset;
#line 2159
  strcpy((char *)(& req->object_name), obj_name);
#line 2160
  req->descriptor_count = 1U;
#line 2161
  req->buf_len = data_size;
#line 2162
  req->addr_low = (unsigned int )cmd->dma + 144U;
#line 2165
  req->addr_high = (unsigned int )((cmd->dma + 144ULL) >> 32ULL);
#line 2168
  be_mcc_notify(adapter);
#line 2169
  spin_unlock_bh(& adapter->mcc_lock);
#line 2171
  tmp___3 = msecs_to_jiffies(60000U);
#line 2171
  tmp___4 = wait_for_completion_timeout(& adapter->et_cmd_compl, tmp___3);
  }
#line 2171
  if (tmp___4 == 0UL) {
#line 2173
    status = -1;
  } else {
#line 2175
    status = (int )adapter->flash_status;
  }
  {
#line 2177
  tmp___5 = embedded_payload(wrb);
#line 2177
  resp = (struct lancer_cmd_resp_write_object *)tmp___5;
  }
#line 2178
  if (status == 0) {
#line 2179
    *data_written = resp->actual_write_len;
#line 2180
    *change_status = resp->change_status;
  } else {
#line 2182
    *addn_status = resp->additional_status;
  }
#line 2185
  return (status);
  err_unlock: 
  {
#line 2188
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2189
  return (status);
}
}
#line 2192 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_cmd_read_object(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 data_size ,
                           u32 data_offset , char const   *obj_name , u32 *data_read ,
                           u32 *eof , u8 *addn_status ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct lancer_cmd_req_read_object *req ;
  struct lancer_cmd_resp_read_object *resp ;
  int status ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2201
  spin_lock_bh(& adapter->mcc_lock);
#line 2203
  wrb = wrb_from_mccq(adapter);
  }
#line 2204
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2205
    status = -16;
#line 2206
    goto err_unlock;
  } else {

  }
  {
#line 2209
  tmp = embedded_payload(wrb);
#line 2209
  req = (struct lancer_cmd_req_read_object *)tmp;
#line 2211
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 171, 144, wrb, (struct be_dma_mem *)0);
#line 2216
  req->desired_read_len = data_size;
#line 2217
  req->read_offset = data_offset;
#line 2218
  strcpy((char *)(& req->object_name), obj_name);
#line 2219
  req->descriptor_count = 1U;
#line 2220
  req->buf_len = data_size;
#line 2221
  req->addr_low = (unsigned int )cmd->dma;
#line 2222
  req->addr_high = (unsigned int )(cmd->dma >> 32ULL);
#line 2224
  status = be_mcc_notify_wait(adapter);
#line 2226
  tmp___0 = embedded_payload(wrb);
#line 2226
  resp = (struct lancer_cmd_resp_read_object *)tmp___0;
  }
#line 2227
  if (status == 0) {
#line 2228
    *data_read = resp->actual_read_len;
#line 2229
    *eof = resp->eof;
  } else {
#line 2231
    *addn_status = resp->additional_status;
  }
  err_unlock: 
  {
#line 2235
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2236
  return (status);
}
}
#line 2239 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_write_flashrom(struct be_adapter *adapter , struct be_dma_mem *cmd , u32 flash_type ,
                          u32 flash_opcode , u32 buf_size ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_write_flashrom *req ;
  int status ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 2246
  spin_lock_bh(& adapter->mcc_lock);
#line 2247
  adapter->flash_status = 0U;
#line 2249
  wrb = wrb_from_mccq(adapter);
  }
#line 2250
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2251
    status = -16;
#line 2252
    goto err_unlock;
  } else {

  }
  {
#line 2254
  req = (struct be_cmd_write_flashrom *)cmd->va;
#line 2256
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 7, (int )cmd->size, wrb, cmd);
#line 2259
  req->params.op_type = flash_type;
#line 2260
  req->params.op_code = flash_opcode;
#line 2261
  req->params.data_buf_size = buf_size;
#line 2263
  be_mcc_notify(adapter);
#line 2264
  spin_unlock_bh(& adapter->mcc_lock);
#line 2266
  tmp = msecs_to_jiffies(40000U);
#line 2266
  tmp___0 = wait_for_completion_timeout(& adapter->et_cmd_compl, tmp);
  }
#line 2266
  if (tmp___0 == 0UL) {
#line 2268
    status = -1;
  } else {
#line 2270
    status = (int )adapter->flash_status;
  }
#line 2272
  return (status);
  err_unlock: 
  {
#line 2275
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2276
  return (status);
}
}
#line 2279 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_flash_crc(struct be_adapter *adapter , u8 *flashed_crc , int offset ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_read_flash_crc *req ;
  int status ;
  void *tmp ;

  {
  {
#line 2286
  spin_lock_bh(& adapter->mcc_lock);
#line 2288
  wrb = wrb_from_mccq(adapter);
  }
#line 2289
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2290
    status = -16;
#line 2291
    goto err;
  } else {

  }
  {
#line 2293
  tmp = embedded_payload(wrb);
#line 2293
  req = (struct be_cmd_read_flash_crc *)tmp;
#line 2295
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 6, 40, wrb, (struct be_dma_mem *)0);
#line 2299
  req->params.op_type = 1U;
#line 2300
  req->params.op_code = 4U;
#line 2301
  req->params.offset = (unsigned int )offset;
#line 2302
  req->params.data_buf_size = 4U;
#line 2304
  status = be_mcc_notify_wait(adapter);
  }
#line 2305
  if (status == 0) {
    {
#line 2306
    memcpy((void *)flashed_crc, (void const   *)(& req->crc), 4UL);
    }
  } else {

  }
  err: 
  {
#line 2309
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2310
  return (status);
}
}
#line 2313 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_enable_magic_wol(struct be_adapter *adapter , u8 *mac , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_acpi_wol_magic_config *req ;
  int status ;

  {
  {
#line 2320
  spin_lock_bh(& adapter->mcc_lock);
#line 2322
  wrb = wrb_from_mccq(adapter);
  }
#line 2323
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2324
    status = -16;
#line 2325
    goto err;
  } else {

  }
  {
#line 2327
  req = (struct be_cmd_req_acpi_wol_magic_config *)nonemb_cmd->va;
#line 2329
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 12, 604, wrb, nonemb_cmd);
#line 2332
  memcpy((void *)(& req->magic_mac), (void const   *)mac, 6UL);
#line 2334
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 2337
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2338
  return (status);
}
}
#line 2341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_loopback(struct be_adapter *adapter , u8 port_num , u8 loopback_type ,
                        u8 enable ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_lmode *req ;
  int status ;
  void *tmp ;

  {
  {
#line 2348
  spin_lock_bh(& adapter->mcc_lock);
#line 2350
  wrb = wrb_from_mccq(adapter);
  }
#line 2351
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2352
    status = -16;
#line 2353
    goto err;
  } else {

  }
  {
#line 2356
  tmp = embedded_payload(wrb);
#line 2356
  req = (struct be_cmd_req_set_lmode *)tmp;
#line 2358
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 19, 20, wrb, (struct be_dma_mem *)0);
#line 2362
  req->src_port = port_num;
#line 2363
  req->dest_port = port_num;
#line 2364
  req->loopback_type = loopback_type;
#line 2365
  req->loopback_state = enable;
#line 2367
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 2369
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2370
  return (status);
}
}
#line 2373 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_loopback_test(struct be_adapter *adapter , u32 port_num , u32 loopback_type ,
                         u32 pkt_size , u32 num_pkts , u64 pattern ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_loopback_test *req ;
  struct be_cmd_resp_loopback_test *resp ;
  int status ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2381
  spin_lock_bh(& adapter->mcc_lock);
#line 2383
  wrb = wrb_from_mccq(adapter);
  }
#line 2384
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2385
    status = -16;
#line 2386
    goto err;
  } else {

  }
  {
#line 2389
  tmp = embedded_payload(wrb);
#line 2389
  req = (struct be_cmd_req_loopback_test *)tmp;
#line 2391
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 18, 48, wrb, (struct be_dma_mem *)0);
#line 2394
  req->hdr.timeout = 15U;
#line 2395
  req->pattern = pattern;
#line 2396
  req->src_port = port_num;
#line 2397
  req->dest_port = port_num;
#line 2398
  req->pkt_size = pkt_size;
#line 2399
  req->num_pkts = num_pkts;
#line 2400
  req->loopback_type = loopback_type;
#line 2402
  be_mcc_notify(adapter);
#line 2404
  spin_unlock_bh(& adapter->mcc_lock);
#line 2406
  wait_for_completion(& adapter->et_cmd_compl);
#line 2407
  tmp___0 = embedded_payload(wrb);
#line 2407
  resp = (struct be_cmd_resp_loopback_test *)tmp___0;
#line 2408
  status = (int )resp->status;
  }
#line 2410
  return (status);
  err: 
  {
#line 2412
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2413
  return (status);
}
}
#line 2416 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_ddr_dma_test(struct be_adapter *adapter , u64 pattern , u32 byte_cnt ,
                        struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_ddrdma_test *req ;
  int status ;
  int i ;
  int j ;
  struct be_cmd_resp_ddrdma_test *resp ;
  int tmp ;

  {
  {
#line 2422
  j = 0;
#line 2424
  spin_lock_bh(& adapter->mcc_lock);
#line 2426
  wrb = wrb_from_mccq(adapter);
  }
#line 2427
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2428
    status = -16;
#line 2429
    goto err;
  } else {

  }
  {
#line 2431
  req = (struct be_cmd_req_ddrdma_test *)cmd->va;
#line 2432
  be_wrb_cmd_hdr_prepare(& req->hdr, 11, 17, (int )cmd->size, wrb, cmd);
#line 2435
  req->pattern = pattern;
#line 2436
  req->byte_count = byte_cnt;
#line 2437
  i = 0;
  }
#line 2437
  goto ldv_54486;
  ldv_54485: 
#line 2438
  req->snd_buff[i] = (unsigned char )(pattern >> j * 8);
#line 2439
  j = j + 1;
#line 2440
  if (j > 7) {
#line 2441
    j = 0;
  } else {

  }
#line 2437
  i = i + 1;
  ldv_54486: ;
#line 2437
  if ((u32 )i < byte_cnt) {
#line 2439
    goto ldv_54485;
  } else {

  }
  {
#line 2444
  status = be_mcc_notify_wait(adapter);
  }
#line 2446
  if (status == 0) {
    {
#line 2448
    resp = (struct be_cmd_resp_ddrdma_test *)cmd->va;
#line 2449
    tmp = memcmp((void const   *)(& resp->rcv_buff), (void const   *)(& req->snd_buff),
                 (size_t )byte_cnt);
    }
#line 2449
    if (tmp != 0 || resp->snd_err != 0U) {
#line 2451
      status = -1;
    } else {

    }
  } else {

  }
  err: 
  {
#line 2456
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2457
  return (status);
}
}
#line 2460 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_seeprom_data(struct be_adapter *adapter , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_seeprom_read *req ;
  int status ;

  {
  {
#line 2467
  spin_lock_bh(& adapter->mcc_lock);
#line 2469
  wrb = wrb_from_mccq(adapter);
  }
#line 2470
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2471
    status = -16;
#line 2472
    goto err;
  } else {

  }
  {
#line 2474
  req = (struct be_cmd_req_seeprom_read *)nonemb_cmd->va;
#line 2476
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 30, 1040, wrb, nonemb_cmd);
#line 2480
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 2483
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2484
  return (status);
}
}
#line 2487 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_phy_info(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_phy_info *req ;
  struct be_dma_mem cmd ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  struct be_phy_info *resp_phy_info ;

  {
  {
#line 2494
  tmp = be_cmd_allowed(adapter, 102, 1);
  }
#line 2494
  if (tmp) {
#line 2494
    tmp___0 = 0;
  } else {
#line 2494
    tmp___0 = 1;
  }
#line 2494
  if (tmp___0) {
#line 2496
    return (-1);
  } else {

  }
  {
#line 2498
  spin_lock_bh(& adapter->mcc_lock);
#line 2500
  wrb = wrb_from_mccq(adapter);
  }
#line 2501
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2502
    status = -16;
#line 2503
    goto err;
  } else {

  }
  {
#line 2505
  cmd.size = 40U;
#line 2506
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
  }
#line 2508
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
    {
#line 2509
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 2510
    status = -12;
    }
#line 2511
    goto err;
  } else {

  }
  {
#line 2514
  req = (struct be_cmd_req_get_phy_info *)cmd.va;
#line 2516
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 102, 40, wrb, & cmd);
#line 2520
  status = be_mcc_notify_wait(adapter);
  }
#line 2521
  if (status == 0) {
#line 2522
    resp_phy_info = (struct be_phy_info *)cmd.va + 16U;
#line 2524
    adapter->phy.phy_type = resp_phy_info->phy_type;
#line 2525
    adapter->phy.interface_type = resp_phy_info->interface_type;
#line 2527
    adapter->phy.auto_speeds_supported = resp_phy_info->auto_speeds_supported;
#line 2529
    adapter->phy.fixed_speeds_supported = resp_phy_info->fixed_speeds_supported;
#line 2531
    adapter->phy.misc_params = resp_phy_info->misc_params;
#line 2534
    if ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U) {
#line 2535
      adapter->phy.fixed_speeds_supported = 12U;
    } else {

    }
  } else {

  }
  {
#line 2540
  pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
  }
  err: 
  {
#line 2543
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2544
  return (status);
}
}
#line 2547 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_qos(struct be_adapter *adapter , u32 bps , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_qos *req ;
  int status ;
  void *tmp ;

  {
  {
#line 2553
  spin_lock_bh(& adapter->mcc_lock);
#line 2555
  wrb = wrb_from_mccq(adapter);
  }
#line 2556
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2557
    status = -16;
#line 2558
    goto err;
  } else {

  }
  {
#line 2561
  tmp = embedded_payload(wrb);
#line 2561
  req = (struct be_cmd_req_set_qos *)tmp;
#line 2563
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 28, 52, wrb, (struct be_dma_mem *)0);
#line 2566
  req->hdr.domain = (u8 )domain;
#line 2567
  req->valid_bits = 1U;
#line 2568
  req->max_bps_nic = bps;
#line 2570
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 2573
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2574
  return (status);
}
}
#line 2577 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_cntl_attributes(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_cntl_attribs *req ;
  int status ;
  int payload_len ;
  unsigned long _max1 ;
  unsigned long _max2 ;
  struct mgmt_controller_attrib *attribs ;
  struct be_dma_mem attribs_cmd ;
  int tmp ;

  {
  {
#line 2583
  _max1 = 16UL;
#line 2583
  _max2 = 560UL;
#line 2583
  payload_len = (int )(_max1 > _max2 ? _max1 : _max2);
#line 2587
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 2587
  if (tmp != 0) {
#line 2588
    return (-1);
  } else {

  }
  {
#line 2590
  memset((void *)(& attribs_cmd), 0, 24UL);
#line 2591
  attribs_cmd.size = 560U;
#line 2592
  attribs_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )attribs_cmd.size,
                                        & attribs_cmd.dma);
  }
#line 2594
  if ((unsigned long )attribs_cmd.va == (unsigned long )((void *)0)) {
    {
#line 2595
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure\n");
#line 2597
    status = -12;
    }
#line 2598
    goto err;
  } else {

  }
  {
#line 2601
  wrb = wrb_from_mbox(adapter);
  }
#line 2602
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2603
    status = -16;
#line 2604
    goto err;
  } else {

  }
  {
#line 2606
  req = (struct be_cmd_req_cntl_attribs *)attribs_cmd.va;
#line 2608
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 32, payload_len, wrb, & attribs_cmd);
#line 2612
  status = be_mbox_notify_wait(adapter);
  }
#line 2613
  if (status == 0) {
#line 2614
    attribs = (struct mgmt_controller_attrib *)attribs_cmd.va + 16U;
#line 2615
    adapter->hba_port_num = attribs->hba_attribs.phy_port;
  } else {

  }
  err: 
  {
#line 2619
  mutex_unlock(& adapter->mbox_lock);
  }
#line 2620
  if ((unsigned long )attribs_cmd.va != (unsigned long )((void *)0)) {
    {
#line 2621
    pci_free_consistent(adapter->pdev, (size_t )attribs_cmd.size, attribs_cmd.va,
                        attribs_cmd.dma);
    }
  } else {

  }
#line 2623
  return (status);
}
}
#line 2627 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_req_native_mode(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_func_cap *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_set_func_cap *resp ;
  void *tmp___1 ;

  {
  {
#line 2633
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 2633
  if (tmp != 0) {
#line 2634
    return (-1);
  } else {

  }
  {
#line 2636
  wrb = wrb_from_mbox(adapter);
  }
#line 2637
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2638
    status = -16;
#line 2639
    goto err;
  } else {

  }
  {
#line 2642
  tmp___0 = embedded_payload(wrb);
#line 2642
  req = (struct be_cmd_req_set_func_cap *)tmp___0;
#line 2644
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 103, 236, wrb, (struct be_dma_mem *)0);
#line 2647
  req->valid_cap_flags = 6U;
#line 2649
  req->cap_flags = 4U;
#line 2651
  status = be_mbox_notify_wait(adapter);
  }
#line 2652
  if (status == 0) {
    {
#line 2653
    tmp___1 = embedded_payload(wrb);
#line 2653
    resp = (struct be_cmd_resp_set_func_cap *)tmp___1;
#line 2654
    adapter->be3_native = (resp->cap_flags & 4U) != 0U;
    }
#line 2656
    if (! adapter->be3_native) {
      {
#line 2657
      dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "adapter not in advanced mode\n");
      }
    } else {

    }
  } else {

  }
  err: 
  {
#line 2661
  mutex_unlock(& adapter->mbox_lock);
  }
#line 2662
  return (status);
}
}
#line 2666 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_fn_privileges(struct be_adapter *adapter , u32 *privilege , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_fn_privileges *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_fn_privileges *resp ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 2673
  spin_lock_bh(& adapter->mcc_lock);
#line 2675
  wrb = wrb_from_mccq(adapter);
  }
#line 2676
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2677
    status = -16;
#line 2678
    goto err;
  } else {

  }
  {
#line 2681
  tmp = embedded_payload(wrb);
#line 2681
  req = (struct be_cmd_req_get_fn_privileges *)tmp;
#line 2683
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 170, 20, wrb, (struct be_dma_mem *)0);
#line 2687
  req->hdr.domain = (u8 )domain;
#line 2689
  status = be_mcc_notify_wait(adapter);
  }
#line 2690
  if (status == 0) {
    {
#line 2691
    tmp___0 = embedded_payload(wrb);
#line 2691
    resp = (struct be_cmd_resp_get_fn_privileges *)tmp___0;
#line 2693
    *privilege = resp->privilege_mask;
    }
#line 2698
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
      {
#line 2698
      tmp___1 = be_is_mc(adapter);
      }
#line 2698
      if ((int )tmp___1) {
#line 2698
        if ((unsigned int )adapter->virtfn == 0U) {
#line 2700
          *privilege = 1792U;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  err: 
  {
#line 2704
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2705
  return (status);
}
}
#line 2709 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_fn_privileges(struct be_adapter *adapter , u32 privileges , u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_fn_privileges *req ;
  int status ;
  void *tmp ;

  {
  {
#line 2716
  spin_lock_bh(& adapter->mcc_lock);
#line 2718
  wrb = wrb_from_mccq(adapter);
  }
#line 2719
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2720
    status = -16;
#line 2721
    goto err;
  } else {

  }
  {
#line 2724
  tmp = embedded_payload(wrb);
#line 2724
  req = (struct be_cmd_req_set_fn_privileges *)tmp;
#line 2725
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 100, 24, wrb, (struct be_dma_mem *)0);
#line 2728
  req->hdr.domain = (u8 )domain;
  }
#line 2729
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 2730
    req->privileges_lancer = privileges;
  } else {
#line 2732
    req->privileges = privileges;
  }
  {
#line 2734
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 2736
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2737
  return (status);
}
}
#line 2744 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_mac_from_list(struct be_adapter *adapter , u8 *mac , bool *pmac_id_valid ,
                             u32 *pmac_id , u32 if_handle , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_mac_list *req ;
  int status ;
  int mac_count ;
  struct be_dma_mem get_mac_list_cmd ;
  int i ;
  struct be_cmd_resp_get_mac_list *resp ;
  struct get_list_macaddr *mac_entry ;
  u16 mac_addr_size ;
  u32 mac_id ;

  {
  {
#line 2755
  memset((void *)(& get_mac_list_cmd), 0, 24UL);
#line 2756
  get_mac_list_cmd.size = 548U;
#line 2757
  get_mac_list_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )get_mac_list_cmd.size,
                                             & get_mac_list_cmd.dma);
  }
#line 2761
  if ((unsigned long )get_mac_list_cmd.va == (unsigned long )((void *)0)) {
    {
#line 2762
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure during GET_MAC_LIST\n");
    }
#line 2764
    return (-12);
  } else {

  }
  {
#line 2767
  spin_lock_bh(& adapter->mcc_lock);
#line 2769
  wrb = wrb_from_mccq(adapter);
  }
#line 2770
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2771
    status = -16;
#line 2772
    goto out;
  } else {

  }
  {
#line 2775
  req = (struct be_cmd_req_get_mac_list *)get_mac_list_cmd.va;
#line 2777
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 147, (int )get_mac_list_cmd.size, wrb, & get_mac_list_cmd);
#line 2780
  req->hdr.domain = domain;
#line 2781
  req->mac_type = 1U;
  }
#line 2782
  if ((int )*pmac_id_valid) {
#line 2783
    req->mac_id = *pmac_id;
#line 2784
    req->iface_id = (unsigned short )if_handle;
#line 2785
    req->perm_override = 0U;
  } else {
#line 2787
    req->perm_override = 1U;
  }
  {
#line 2790
  status = be_mcc_notify_wait(adapter);
  }
#line 2791
  if (status == 0) {
#line 2792
    resp = (struct be_cmd_resp_get_mac_list *)get_mac_list_cmd.va;
#line 2795
    if ((int )*pmac_id_valid) {
      {
#line 2796
      memcpy((void *)mac, (void const   *)(& resp->macid_macaddr.mac_addr_id.macaddr),
             6UL);
      }
#line 2798
      goto out;
    } else {

    }
#line 2801
    mac_count = (int )resp->true_mac_count + (int )resp->pseudo_mac_count;
#line 2807
    i = 0;
#line 2807
    goto ldv_54576;
    ldv_54575: 
#line 2812
    mac_entry = (struct get_list_macaddr *)(& resp->macaddr_list) + (unsigned long )i;
#line 2813
    mac_addr_size = mac_entry->mac_addr_size;
#line 2817
    if ((unsigned int )mac_addr_size == 4U) {
#line 2818
      *pmac_id_valid = 1;
#line 2819
      mac_id = mac_entry->mac_addr_id.s_mac_id.mac_id;
#line 2820
      *pmac_id = mac_id;
#line 2821
      goto out;
    } else {

    }
#line 2807
    i = i + 1;
    ldv_54576: ;
#line 2807
    if (i < mac_count) {
#line 2809
      goto ldv_54575;
    } else {

    }
    {
#line 2825
    *pmac_id_valid = 0;
#line 2826
    memcpy((void *)mac, (void const   *)(& resp->macaddr_list[0].mac_addr_id.macaddr),
           6UL);
    }
  } else {

  }
  out: 
  {
#line 2831
  spin_unlock_bh(& adapter->mcc_lock);
#line 2832
  pci_free_consistent(adapter->pdev, (size_t )get_mac_list_cmd.size, get_mac_list_cmd.va,
                      get_mac_list_cmd.dma);
  }
#line 2834
  return (status);
}
}
#line 2837 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_active_mac(struct be_adapter *adapter , u32 curr_pmac_id , u8 *mac ,
                          u32 if_handle , bool active , u32 domain ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2841
  if (! active) {
    {
#line 2842
    be_cmd_get_mac_from_list(adapter, mac, & active, & curr_pmac_id, if_handle, (int )((u8 )domain));
    }
  } else {

  }
#line 2844
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
    {
#line 2845
    tmp = be_cmd_mac_addr_query(adapter, mac, 0, if_handle, curr_pmac_id);
    }
#line 2845
    return (tmp);
  } else {
    {
#line 2849
    tmp___0 = be_cmd_get_mac_from_list(adapter, mac, & active, & curr_pmac_id, if_handle,
                                       (int )((u8 )domain));
    }
#line 2849
    return (tmp___0);
  }
}
}
#line 2854 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_perm_mac(struct be_adapter *adapter , u8 *mac ) 
{ 
  int status ;
  bool pmac_valid ;

  {
  {
#line 2857
  pmac_valid = 0;
#line 2859
  memset((void *)mac, 0, 6UL);
  }
#line 2861
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 2862
    if ((unsigned int )adapter->virtfn == 0U) {
      {
#line 2863
      status = be_cmd_mac_addr_query(adapter, mac, 1, 0U, 0U);
      }
    } else {
      {
#line 2866
      status = be_cmd_mac_addr_query(adapter, mac, 0, (u32 )adapter->if_handle, 0U);
      }
    }
  } else {
    {
#line 2869
    status = be_cmd_get_mac_from_list(adapter, mac, & pmac_valid, (u32 *)0U, (u32 )adapter->if_handle,
                                      0);
    }
  }
#line 2873
  return (status);
}
}
#line 2877 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_mac_list(struct be_adapter *adapter , u8 *mac_array , u8 mac_count ,
                        u32 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_mac_list *req ;
  int status ;
  struct be_dma_mem cmd ;

  {
  {
#line 2885
  memset((void *)(& cmd), 0, 24UL);
#line 2886
  cmd.size = 404U;
#line 2887
  cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, & cmd.dma, 208U,
                           (struct dma_attrs *)0);
  }
#line 2889
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 2890
    return (-12);
  } else {

  }
  {
#line 2892
  spin_lock_bh(& adapter->mcc_lock);
#line 2894
  wrb = wrb_from_mccq(adapter);
  }
#line 2895
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2896
    status = -16;
#line 2897
    goto err;
  } else {

  }
  {
#line 2900
  req = (struct be_cmd_req_set_mac_list *)cmd.va;
#line 2901
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 148, 404, wrb, & cmd);
#line 2905
  req->hdr.domain = (u8 )domain;
#line 2906
  req->mac_count = mac_count;
  }
#line 2907
  if ((unsigned int )mac_count != 0U) {
    {
#line 2908
    memcpy((void *)(& req->mac), (void const   *)mac_array, (size_t )((int )mac_count * 6));
    }
  } else {

  }
  {
#line 2910
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 2913
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )cmd.size, cmd.va, cmd.dma, (struct dma_attrs *)0);
#line 2915
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2916
  return (status);
}
}
#line 2923 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_mac(struct be_adapter *adapter , u8 *mac , int if_id , u32 dom ) 
{ 
  bool active_mac ;
  u8 old_mac[6U] ;
  u32 pmac_id ;
  int status ;
  int tmp ;

  {
  {
#line 2925
  active_mac = 0;
#line 2930
  status = be_cmd_get_mac_from_list(adapter, (u8 *)(& old_mac), & active_mac, & pmac_id,
                                    (u32 )if_id, (int )((u8 )dom));
  }
#line 2933
  if (status == 0 && (int )active_mac) {
    {
#line 2934
    be_cmd_pmac_del(adapter, (u32 )if_id, (int )pmac_id, dom);
    }
  } else {

  }
  {
#line 2936
  tmp = be_cmd_set_mac_list(adapter, mac, (unsigned long )mac != (unsigned long )((u8 *)0U),
                            dom);
  }
#line 2936
  return (tmp);
}
}
#line 2939 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_hsw_config(struct be_adapter *adapter , u16 pvid , u32 domain , u16 intf_id ,
                          u16 hsw_mode ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_hsw_config *req ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;

  {
  {
#line 2947
  spin_lock_bh(& adapter->mcc_lock);
#line 2949
  wrb = wrb_from_mccq(adapter);
  }
#line 2950
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2951
    status = -16;
#line 2952
    goto err;
  } else {

  }
  {
#line 2955
  tmp = embedded_payload(wrb);
#line 2955
  req = (struct be_cmd_req_set_hsw_config *)tmp;
#line 2956
  ctxt = (void *)(& req->context);
#line 2958
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 153, 36, wrb, (struct be_dma_mem *)0);
#line 2961
  req->hdr.domain = (u8 )domain;
#line 2962
  tmp___0 = amap_mask(16U);
#line 2962
  amap_set(ctxt, 0U, tmp___0, 0U, (u32 )intf_id);
  }
#line 2963
  if ((unsigned int )pvid != 0U) {
    {
#line 2964
    tmp___1 = amap_mask(1U);
#line 2964
    amap_set(ctxt, 0U, tmp___1, 30U, 1U);
#line 2965
    tmp___2 = amap_mask(16U);
#line 2965
    amap_set(ctxt, 1U, tmp___2, 16U, (u32 )pvid);
    }
  } else {

  }
#line 2967
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && (unsigned int )hsw_mode != 0U) {
    {
#line 2968
    tmp___3 = amap_mask(16U);
#line 2968
    amap_set(ctxt, 0U, tmp___3, 0U, (u32 )adapter->hba_port_num);
#line 2970
    tmp___4 = amap_mask(1U);
#line 2970
    amap_set(ctxt, 0U, tmp___4, 31U, 1U);
#line 2971
    tmp___5 = amap_mask(3U);
#line 2971
    amap_set(ctxt, 1U, tmp___5, 6U, (u32 )hsw_mode);
    }
  } else {

  }
  {
#line 2975
  swap_dws((void *)(& req->context), 20);
#line 2976
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 2979
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 2980
  return (status);
}
}
#line 2984 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_hsw_config(struct be_adapter *adapter , u16 *pvid , u32 domain , u16 intf_id ,
                          u8 *mode ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_hsw_config *req ;
  void *ctxt ;
  int status ;
  u16 vid ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  struct be_cmd_resp_get_hsw_config *resp ;
  void *tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;

  {
  {
#line 2993
  spin_lock_bh(& adapter->mcc_lock);
#line 2995
  wrb = wrb_from_mccq(adapter);
  }
#line 2996
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 2997
    status = -16;
#line 2998
    goto err;
  } else {

  }
  {
#line 3001
  tmp = embedded_payload(wrb);
#line 3001
  req = (struct be_cmd_req_get_hsw_config *)tmp;
#line 3002
  ctxt = (void *)(& req->context);
#line 3004
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 152, 20, wrb, (struct be_dma_mem *)0);
#line 3007
  req->hdr.domain = (u8 )domain;
#line 3008
  tmp___0 = amap_mask(16U);
#line 3008
  amap_set(ctxt, 0U, tmp___0, 0U, (u32 )intf_id);
#line 3010
  tmp___1 = amap_mask(1U);
#line 3010
  amap_set(ctxt, 0U, tmp___1, 30U, 1U);
  }
#line 3012
  if ((((unsigned int )(adapter->pdev)->device != 545U && (unsigned int )(adapter->pdev)->device != 1808U) && ((unsigned int )(adapter->pdev)->device != 529U && (unsigned int )(adapter->pdev)->device != 1792U)) && (unsigned long )mode != (unsigned long )((u8 *)0U)) {
    {
#line 3013
    tmp___2 = amap_mask(16U);
#line 3013
    amap_set(ctxt, 0U, tmp___2, 0U, (u32 )adapter->hba_port_num);
#line 3015
    tmp___3 = amap_mask(1U);
#line 3015
    amap_set(ctxt, 0U, tmp___3, 31U, 1U);
    }
  } else {

  }
  {
#line 3017
  swap_dws((void *)(& req->context), 4);
#line 3019
  status = be_mcc_notify_wait(adapter);
  }
#line 3020
  if (status == 0) {
    {
#line 3021
    tmp___4 = embedded_payload(wrb);
#line 3021
    resp = (struct be_cmd_resp_get_hsw_config *)tmp___4;
#line 3023
    swap_dws((void *)(& resp->context), 16);
#line 3025
    tmp___5 = amap_mask(16U);
#line 3025
    tmp___6 = amap_get((void *)(& resp->context), 0U, tmp___5, 16U);
#line 3025
    vid = (u16 )tmp___6;
    }
#line 3027
    if ((unsigned long )pvid != (unsigned long )((u16 *)0U)) {
#line 3028
      *pvid = vid;
    } else {

    }
#line 3029
    if ((unsigned long )mode != (unsigned long )((u8 *)0U)) {
      {
#line 3030
      tmp___7 = amap_mask(3U);
#line 3030
      tmp___8 = amap_get((void *)(& resp->context), 0U, tmp___7, 6U);
#line 3030
      *mode = (u8 )tmp___8;
      }
    } else {

    }
  } else {

  }
  err: 
  {
#line 3035
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 3036
  return (status);
}
}
#line 3039 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_acpi_wol_magic_config_v1 *req ;
  int status ;
  struct be_dma_mem cmd ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct be_cmd_resp_acpi_wol_magic_config_v1 *resp ;

  {
  {
#line 3043
  status = 0;
#line 3046
  tmp = be_cmd_allowed(adapter, 12, 3);
  }
#line 3046
  if (tmp) {
#line 3046
    tmp___0 = 0;
  } else {
#line 3046
    tmp___0 = 1;
  }
#line 3046
  if (tmp___0) {
#line 3048
    return (-1);
  } else {

  }
  {
#line 3050
  tmp___1 = be_is_wol_excluded(adapter);
  }
#line 3050
  if ((int )tmp___1) {
#line 3051
    return (status);
  } else {

  }
  {
#line 3053
  tmp___2 = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 3053
  if (tmp___2 != 0) {
#line 3054
    return (-1);
  } else {

  }
  {
#line 3056
  memset((void *)(& cmd), 0, 24UL);
#line 3057
  cmd.size = 1204U;
#line 3058
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
  }
#line 3060
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
    {
#line 3061
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure\n");
#line 3063
    status = -12;
    }
#line 3064
    goto err;
  } else {

  }
  {
#line 3067
  wrb = wrb_from_mbox(adapter);
  }
#line 3068
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3069
    status = -16;
#line 3070
    goto err;
  } else {

  }
  {
#line 3073
  req = (struct be_cmd_req_acpi_wol_magic_config_v1 *)cmd.va;
#line 3075
  be_wrb_cmd_hdr_prepare(& req->hdr, 3, 12, 1204, wrb, & cmd);
#line 3079
  req->hdr.version = 1U;
#line 3080
  req->query_options = 2U;
#line 3082
  status = be_mbox_notify_wait(adapter);
  }
#line 3083
  if (status == 0) {
#line 3085
    resp = (struct be_cmd_resp_acpi_wol_magic_config_v1 *)cmd.va;
#line 3087
    adapter->wol_cap = resp->wol_settings;
#line 3088
    if ((int )adapter->wol_cap & 1) {
#line 3089
      adapter->wol_en = 1;
    } else {

    }
  } else {

  }
  err: 
  {
#line 3092
  mutex_unlock(& adapter->mbox_lock);
  }
#line 3093
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
    {
#line 3094
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
    }
  } else {

  }
#line 3095
  return (status);
}
}
#line 3099 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_fw_log_level(struct be_adapter *adapter , u32 level ) 
{ 
  struct be_dma_mem extfat_cmd ;
  struct be_fat_conf_params *cfgs ;
  int status ;
  int i ;
  int j ;
  u32 num_modes ;

  {
  {
#line 3106
  memset((void *)(& extfat_cmd), 0, 24UL);
#line 3107
  extfat_cmd.size = 2844U;
#line 3108
  extfat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )extfat_cmd.size, & extfat_cmd.dma);
  }
#line 3110
  if ((unsigned long )extfat_cmd.va == (unsigned long )((void *)0)) {
#line 3111
    return (-12);
  } else {

  }
  {
#line 3113
  status = be_cmd_get_ext_fat_capabilites(adapter, & extfat_cmd);
  }
#line 3114
  if (status != 0) {
#line 3115
    goto err;
  } else {

  }
#line 3117
  cfgs = (struct be_fat_conf_params *)extfat_cmd.va + 16U;
#line 3119
  i = 0;
#line 3119
  goto ldv_54663;
  ldv_54662: 
#line 3120
  num_modes = cfgs->module[i].num_modes;
#line 3121
  j = 0;
#line 3121
  goto ldv_54660;
  ldv_54659: ;
#line 3122
  if ((unsigned int )cfgs->module[i].trace_lvl[j].mode == 0U) {
#line 3123
    cfgs->module[i].trace_lvl[j].dbg_lvl = level;
  } else {

  }
#line 3121
  j = j + 1;
  ldv_54660: ;
#line 3121
  if ((u32 )j < num_modes) {
#line 3123
    goto ldv_54659;
  } else {

  }
#line 3119
  i = i + 1;
  ldv_54663: ;
#line 3119
  if ((u32 )i < cfgs->num_modules) {
#line 3121
    goto ldv_54662;
  } else {

  }
  {
#line 3128
  status = be_cmd_set_ext_fat_capabilites(adapter, & extfat_cmd, cfgs);
  }
  err: 
  {
#line 3130
  pci_free_consistent(adapter->pdev, (size_t )extfat_cmd.size, extfat_cmd.va, extfat_cmd.dma);
  }
#line 3132
  return (status);
}
}
#line 3135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_fw_log_level(struct be_adapter *adapter ) 
{ 
  struct be_dma_mem extfat_cmd ;
  struct be_fat_conf_params *cfgs ;
  int status ;
  int j ;
  int level ;

  {
  {
#line 3140
  level = 0;
#line 3142
  memset((void *)(& extfat_cmd), 0, 24UL);
#line 3143
  extfat_cmd.size = 2844U;
#line 3144
  extfat_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )extfat_cmd.size, & extfat_cmd.dma);
  }
#line 3147
  if ((unsigned long )extfat_cmd.va == (unsigned long )((void *)0)) {
    {
#line 3148
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "%s: Memory allocation failure\n",
            "be_cmd_get_fw_log_level");
    }
#line 3150
    goto err;
  } else {

  }
  {
#line 3153
  status = be_cmd_get_ext_fat_capabilites(adapter, & extfat_cmd);
  }
#line 3154
  if (status == 0) {
#line 3155
    cfgs = (struct be_fat_conf_params *)extfat_cmd.va + 16U;
#line 3157
    j = 0;
#line 3157
    goto ldv_54676;
    ldv_54675: ;
#line 3158
    if ((unsigned int )cfgs->module[0].trace_lvl[j].mode == 0U) {
#line 3159
      level = (int )cfgs->module[0].trace_lvl[j].dbg_lvl;
    } else {

    }
#line 3157
    j = j + 1;
    ldv_54676: ;
#line 3157
    if ((u32 )j < cfgs->module[0].num_modes) {
#line 3159
      goto ldv_54675;
    } else {

    }

  } else {

  }
  {
#line 3162
  pci_free_consistent(adapter->pdev, (size_t )extfat_cmd.size, extfat_cmd.va, extfat_cmd.dma);
  }
  err: ;
#line 3165
  return (level);
}
}
#line 3168 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_ext_fat_caps *req ;
  int status ;
  int tmp ;

  {
  {
#line 3175
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 3175
  if (tmp != 0) {
#line 3176
    return (-1);
  } else {

  }
  {
#line 3178
  wrb = wrb_from_mbox(adapter);
  }
#line 3179
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3180
    status = -16;
#line 3181
    goto err;
  } else {

  }
  {
#line 3184
  req = (struct be_cmd_req_get_ext_fat_caps *)cmd->va;
#line 3185
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 125, (int )cmd->size, wrb, cmd);
#line 3188
  req->parameter_type = 1U;
#line 3190
  status = be_mbox_notify_wait(adapter);
  }
  err: 
  {
#line 3192
  mutex_unlock(& adapter->mbox_lock);
  }
#line 3193
  return (status);
}
}
#line 3196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_ext_fat_capabilites(struct be_adapter *adapter , struct be_dma_mem *cmd ,
                                   struct be_fat_conf_params *configs ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_ext_fat_caps *req ;
  int status ;

  {
  {
#line 3204
  spin_lock_bh(& adapter->mcc_lock);
#line 3206
  wrb = wrb_from_mccq(adapter);
  }
#line 3207
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3208
    status = -16;
#line 3209
    goto err;
  } else {

  }
  {
#line 3212
  req = (struct be_cmd_req_set_ext_fat_caps *)cmd->va;
#line 3213
  memcpy((void *)(& req->set_params), (void const   *)configs, 2828UL);
#line 3214
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 126, (int )cmd->size, wrb, cmd);
#line 3218
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 3220
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 3221
  return (status);
}
}
#line 3224 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_query_port_name(struct be_adapter *adapter , u8 *port_name ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_port_name *req ;
  int status ;
  void *tmp ;
  struct be_cmd_resp_get_port_name *resp ;
  void *tmp___0 ;

  {
#line 3230
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3231
    *port_name = (unsigned int )adapter->hba_port_num + 48U;
#line 3232
    return (0);
  } else {

  }
  {
#line 3235
  spin_lock_bh(& adapter->mcc_lock);
#line 3237
  wrb = wrb_from_mccq(adapter);
  }
#line 3238
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3239
    status = -16;
#line 3240
    goto err;
  } else {

  }
  {
#line 3243
  tmp = embedded_payload(wrb);
#line 3243
  req = (struct be_cmd_req_get_port_name *)tmp;
#line 3245
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 77, 20, wrb, (struct be_dma_mem *)0);
#line 3248
  req->hdr.version = 1U;
#line 3250
  status = be_mcc_notify_wait(adapter);
  }
#line 3251
  if (status == 0) {
    {
#line 3252
    tmp___0 = embedded_payload(wrb);
#line 3252
    resp = (struct be_cmd_resp_get_port_name *)tmp___0;
#line 3253
    *port_name = resp->port_name[(int )adapter->hba_port_num];
    }
  } else {
#line 3255
    *port_name = (unsigned int )adapter->hba_port_num + 48U;
  }
  err: 
  {
#line 3258
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 3259
  return (status);
}
}
#line 3262 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_nic_res_desc *be_get_nic_desc(u8 *buf , u32 desc_count ) 
{ 
  struct be_res_desc_hdr *hdr ;
  int i ;

  {
#line 3264
  hdr = (struct be_res_desc_hdr *)buf;
#line 3267
  i = 0;
#line 3267
  goto ldv_54711;
  ldv_54710: ;
#line 3268
  if ((unsigned int )hdr->desc_type == 65U || (unsigned int )hdr->desc_type == 81U) {
#line 3270
    return ((struct be_nic_res_desc *)hdr);
  } else {

  }
#line 3272
  hdr->desc_len = (int )hdr->desc_len != 0 ? (u8 )((int )hdr->desc_len) : 72U;
#line 3273
  hdr = hdr + (unsigned long )hdr->desc_len;
#line 3267
  i = i + 1;
  ldv_54711: ;
#line 3267
  if ((u32 )i < desc_count) {
#line 3269
    goto ldv_54710;
  } else {

  }

#line 3275
  return ((struct be_nic_res_desc *)0);
}
}
#line 3278 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static struct be_pcie_res_desc *be_get_pcie_desc(u8 devfn , u8 *buf , u32 desc_count ) 
{ 
  struct be_res_desc_hdr *hdr ;
  struct be_pcie_res_desc *pcie ;
  int i ;

  {
#line 3281
  hdr = (struct be_res_desc_hdr *)buf;
#line 3285
  i = 0;
#line 3285
  goto ldv_54722;
  ldv_54721: ;
#line 3286
  if ((unsigned int )hdr->desc_type == 64U || (unsigned int )hdr->desc_type == 80U) {
#line 3288
    pcie = (struct be_pcie_res_desc *)hdr;
#line 3289
    if ((int )pcie->pf_num == (int )devfn) {
#line 3290
      return (pcie);
    } else {

    }
  } else {

  }
#line 3293
  hdr->desc_len = (int )hdr->desc_len != 0 ? (u8 )((int )hdr->desc_len) : 72U;
#line 3294
  hdr = hdr + (unsigned long )hdr->desc_len;
#line 3285
  i = i + 1;
  ldv_54722: ;
#line 3285
  if ((u32 )i < desc_count) {
#line 3287
    goto ldv_54721;
  } else {

  }

#line 3296
  return ((struct be_pcie_res_desc *)0);
}
}
#line 3299 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static void be_copy_nic_desc(struct be_resources *res , struct be_nic_res_desc *desc ) 
{ 


  {
#line 3302
  res->max_uc_mac = desc->unicast_mac_count;
#line 3303
  res->max_vlans = desc->vlan_count;
#line 3304
  res->max_mcast_mac = desc->mcast_mac_count;
#line 3305
  res->max_tx_qs = desc->txq_count;
#line 3306
  res->max_rss_qs = desc->rssq_count;
#line 3307
  res->max_rx_qs = desc->rq_count;
#line 3308
  res->max_evt_qs = desc->eq_count;
#line 3310
  res->if_cap_flags = desc->cap_flags & 7100U;
#line 3313
  if ((unsigned int )res->max_rss_qs != 0U && (int )res->max_rss_qs == (int )res->max_rx_qs) {
#line 3314
    res->max_rss_qs = (unsigned int )res->max_rss_qs + 65535U;
  } else {

  }
#line 3315
  return;
}
}
#line 3318 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_func_config(struct be_adapter *adapter , struct be_resources *res ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_func_config *req ;
  int status ;
  struct be_dma_mem cmd ;
  int tmp ;
  struct be_cmd_resp_get_func_config *resp ;
  u32 desc_count ;
  struct be_nic_res_desc *desc ;

  {
  {
#line 3325
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 3325
  if (tmp != 0) {
#line 3326
    return (-1);
  } else {

  }
  {
#line 3328
  memset((void *)(& cmd), 0, 24UL);
#line 3329
  cmd.size = 23252U;
#line 3330
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
  }
#line 3332
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
    {
#line 3333
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory alloc failure\n");
#line 3334
    status = -12;
    }
#line 3335
    goto err;
  } else {

  }
  {
#line 3338
  wrb = wrb_from_mbox(adapter);
  }
#line 3339
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3340
    status = -16;
#line 3341
    goto err;
  } else {

  }
  {
#line 3344
  req = (struct be_cmd_req_get_func_config *)cmd.va;
#line 3346
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 160, (int )cmd.size, wrb, & cmd);
  }
#line 3350
  if ((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) {
#line 3351
    req->hdr.version = 1U;
  } else {

  }
  {
#line 3353
  status = be_mbox_notify_wait(adapter);
  }
#line 3354
  if (status == 0) {
    {
#line 3355
    resp = (struct be_cmd_resp_get_func_config *)cmd.va;
#line 3356
    desc_count = resp->desc_count;
#line 3359
    desc = be_get_nic_desc((u8 *)(& resp->func_param), desc_count);
    }
#line 3360
    if ((unsigned long )desc == (unsigned long )((struct be_nic_res_desc *)0)) {
#line 3361
      status = -22;
#line 3362
      goto err;
    } else {

    }
    {
#line 3365
    adapter->pf_number = desc->pf_num;
#line 3366
    be_copy_nic_desc(res, desc);
    }
  } else {

  }
  err: 
  {
#line 3369
  mutex_unlock(& adapter->mbox_lock);
  }
#line 3370
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
    {
#line 3371
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
    }
  } else {

  }
#line 3372
  return (status);
}
}
#line 3376 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_get_profile_config_mbox(struct be_adapter *adapter , u8 domain ,
                                          struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_profile_config *req ;
  int status ;
  int tmp ;

  {
  {
#line 3383
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 3383
  if (tmp != 0) {
#line 3384
    return (-1);
  } else {

  }
  {
#line 3385
  wrb = wrb_from_mbox(adapter);
#line 3387
  req = (struct be_cmd_req_get_profile_config *)cmd->va;
#line 3388
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 164, (int )cmd->size, wrb, cmd);
#line 3392
  req->type = 2U;
#line 3393
  req->hdr.domain = domain;
  }
#line 3394
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3395
    req->hdr.version = 1U;
  } else {

  }
  {
#line 3397
  status = be_mbox_notify_wait(adapter);
#line 3399
  mutex_unlock(& adapter->mbox_lock);
  }
#line 3400
  return (status);
}
}
#line 3404 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int be_cmd_get_profile_config_mccq(struct be_adapter *adapter , u8 domain ,
                                          struct be_dma_mem *cmd ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_profile_config *req ;
  int status ;

  {
  {
#line 3411
  spin_lock_bh(& adapter->mcc_lock);
#line 3413
  wrb = wrb_from_mccq(adapter);
  }
#line 3414
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3415
    status = -16;
#line 3416
    goto err;
  } else {

  }
  {
#line 3419
  req = (struct be_cmd_req_get_profile_config *)cmd->va;
#line 3420
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 164, (int )cmd->size, wrb, cmd);
#line 3424
  req->type = 2U;
#line 3425
  req->hdr.domain = domain;
  }
#line 3426
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
#line 3427
    req->hdr.version = 1U;
  } else {

  }
  {
#line 3429
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 3432
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 3433
  return (status);
}
}
#line 3437 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_profile_config(struct be_adapter *adapter , struct be_resources *res ,
                              u8 domain ) 
{ 
  struct be_cmd_resp_get_profile_config *resp ;
  struct be_pcie_res_desc *pcie ;
  struct be_nic_res_desc *nic ;
  struct be_queue_info *mccq ;
  struct be_dma_mem cmd ;
  u32 desc_count ;
  int status ;

  {
  {
#line 3443
  mccq = & adapter->mcc_obj.q;
#line 3448
  memset((void *)(& cmd), 0, 24UL);
#line 3449
  cmd.size = 23252U;
#line 3450
  cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )cmd.size, & cmd.dma);
  }
#line 3451
  if ((unsigned long )cmd.va == (unsigned long )((void *)0)) {
#line 3452
    return (-12);
  } else {

  }
#line 3454
  if (! mccq->created) {
    {
#line 3455
    status = be_cmd_get_profile_config_mbox(adapter, (int )domain, & cmd);
    }
  } else {
    {
#line 3457
    status = be_cmd_get_profile_config_mccq(adapter, (int )domain, & cmd);
    }
  }
#line 3458
  if (status != 0) {
#line 3459
    goto err;
  } else {

  }
  {
#line 3461
  resp = (struct be_cmd_resp_get_profile_config *)cmd.va;
#line 3462
  desc_count = resp->desc_count;
#line 3464
  pcie = be_get_pcie_desc((int )((u8 )(adapter->pdev)->devfn), (u8 *)(& resp->func_param),
                          desc_count);
  }
#line 3466
  if ((unsigned long )pcie != (unsigned long )((struct be_pcie_res_desc *)0)) {
#line 3467
    res->max_vfs = pcie->num_vfs;
  } else {

  }
  {
#line 3469
  nic = be_get_nic_desc((u8 *)(& resp->func_param), desc_count);
  }
#line 3470
  if ((unsigned long )nic != (unsigned long )((struct be_nic_res_desc *)0)) {
    {
#line 3471
    be_copy_nic_desc(res, nic);
    }
  } else {

  }
  err: ;
#line 3474
  if ((unsigned long )cmd.va != (unsigned long )((void *)0)) {
    {
#line 3475
    pci_free_consistent(adapter->pdev, (size_t )cmd.size, cmd.va, cmd.dma);
    }
  } else {

  }
#line 3476
  return (status);
}
}
#line 3482 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_set_profile_config(struct be_adapter *adapter , u32 bps , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_set_profile_config *req ;
  int status ;
  void *tmp ;

  {
  {
#line 3489
  spin_lock_bh(& adapter->mcc_lock);
#line 3491
  wrb = wrb_from_mccq(adapter);
  }
#line 3492
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3493
    status = -16;
#line 3494
    goto err;
  } else {

  }
  {
#line 3497
  tmp = embedded_payload(wrb);
#line 3497
  req = (struct be_cmd_req_set_profile_config *)tmp;
#line 3499
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 165, 112, wrb, (struct be_dma_mem *)0);
#line 3502
  req->hdr.domain = domain;
#line 3503
  req->desc_count = 1U;
#line 3504
  req->nic_desc.hdr.desc_type = 65U;
#line 3505
  req->nic_desc.hdr.desc_len = 72U;
#line 3506
  req->nic_desc.flags = 208U;
#line 3507
  req->nic_desc.pf_num = adapter->pf_number;
#line 3508
  req->nic_desc.vf_num = domain;
#line 3511
  req->nic_desc.unicast_mac_count = 65535U;
#line 3512
  req->nic_desc.mcc_count = 65535U;
#line 3513
  req->nic_desc.vlan_count = 65535U;
#line 3514
  req->nic_desc.mcast_mac_count = 65535U;
#line 3515
  req->nic_desc.txq_count = 65535U;
#line 3516
  req->nic_desc.rq_count = 65535U;
#line 3517
  req->nic_desc.rssq_count = 65535U;
#line 3518
  req->nic_desc.lro_count = 65535U;
#line 3519
  req->nic_desc.cq_count = 65535U;
#line 3520
  req->nic_desc.toe_conn_count = 65535U;
#line 3521
  req->nic_desc.eq_count = 65535U;
#line 3522
  req->nic_desc.link_param = 255U;
#line 3523
  req->nic_desc.bw_min = 4294967295U;
#line 3524
  req->nic_desc.acpi_params = 255U;
#line 3525
  req->nic_desc.wol_param = 15U;
#line 3528
  req->nic_desc.bw_min = bps;
#line 3529
  req->nic_desc.bw_max = bps;
#line 3530
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 3532
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 3533
  return (status);
}
}
#line 3536 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_if_id(struct be_adapter *adapter , struct be_vf_cfg *vf_cfg , int vf_num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_get_iface_list *req ;
  struct be_cmd_resp_get_iface_list *resp ;
  int status ;
  void *tmp ;

  {
  {
#line 3544
  spin_lock_bh(& adapter->mcc_lock);
#line 3546
  wrb = wrb_from_mccq(adapter);
  }
#line 3547
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3548
    status = -16;
#line 3549
    goto err;
  } else {

  }
  {
#line 3551
  tmp = embedded_payload(wrb);
#line 3551
  req = (struct be_cmd_req_get_iface_list *)tmp;
#line 3553
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 194, 32, wrb, (struct be_dma_mem *)0);
#line 3556
  req->hdr.domain = (unsigned int )((u8 )vf_num) + 1U;
#line 3558
  status = be_mcc_notify_wait(adapter);
  }
#line 3559
  if (status == 0) {
#line 3560
    resp = (struct be_cmd_resp_get_iface_list *)req;
#line 3561
    vf_cfg->if_handle = (int )resp->if_desc.if_id;
  } else {

  }
  err: 
  {
#line 3565
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 3566
  return (status);
}
}
#line 3569 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static int lancer_wait_idle(struct be_adapter *adapter ) 
{ 
  u32 reg_val ;
  int status ;
  int i ;

  {
#line 3573
  status = 0;
#line 3575
  i = 0;
#line 3575
  goto ldv_54797;
  ldv_54796: 
  {
#line 3576
  reg_val = ioread32((void *)adapter->db + 1044U);
  }
#line 3577
  if ((reg_val & 1073741824U) == 0U) {
#line 3578
    goto ldv_54795;
  } else {

  }
  {
#line 3580
  ssleep(1U);
#line 3575
  i = i + 1;
  }
  ldv_54797: ;
#line 3575
  if (i <= 29) {
#line 3577
    goto ldv_54796;
  } else {

  }
  ldv_54795: ;
#line 3583
  if (i == 30) {
#line 3584
    status = -1;
  } else {

  }
#line 3586
  return (status);
}
}
#line 3589 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_physdev_ctrl(struct be_adapter *adapter , u32 mask ) 
{ 
  int status ;

  {
  {
#line 3591
  status = 0;
#line 3593
  status = lancer_wait_idle(adapter);
  }
#line 3594
  if (status != 0) {
#line 3595
    return (status);
  } else {

  }
  {
#line 3597
  iowrite32(mask, (void *)adapter->db + 1044U);
  }
#line 3599
  return (status);
}
}
#line 3603 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
bool dump_present(struct be_adapter *adapter ) 
{ 
  u32 sliport_status ;

  {
  {
#line 3605
  sliport_status = 0U;
#line 3607
  sliport_status = ioread32((void *)adapter->db + 1028U);
  }
#line 3608
  return ((sliport_status & 33554432U) != 0U);
}
}
#line 3611 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int lancer_initiate_dump(struct be_adapter *adapter ) 
{ 
  int status ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 3616
  status = lancer_physdev_ctrl(adapter, 6U);
  }
#line 3618
  if (status < 0) {
    {
#line 3619
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Firmware reset failed\n");
    }
#line 3620
    return (status);
  } else {

  }
  {
#line 3623
  status = lancer_wait_idle(adapter);
  }
#line 3624
  if (status != 0) {
#line 3625
    return (status);
  } else {

  }
  {
#line 3627
  tmp = dump_present(adapter);
  }
#line 3627
  if (tmp) {
#line 3627
    tmp___0 = 0;
  } else {
#line 3627
    tmp___0 = 1;
  }
#line 3627
  if (tmp___0) {
    {
#line 3628
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Dump image not present\n");
    }
#line 3629
    return (-1);
  } else {

  }
#line 3632
  return (0);
}
}
#line 3636 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_enable_vf(struct be_adapter *adapter , u8 domain ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_enable_disable_vf *req ;
  int status ;
  void *tmp ;

  {
#line 3642
  if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
#line 3643
    return (0);
  } else {

  }
  {
#line 3645
  spin_lock_bh(& adapter->mcc_lock);
#line 3647
  wrb = wrb_from_mccq(adapter);
  }
#line 3648
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3649
    status = -16;
#line 3650
    goto err;
  } else {

  }
  {
#line 3653
  tmp = embedded_payload(wrb);
#line 3653
  req = (struct be_cmd_enable_disable_vf *)tmp;
#line 3655
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 196, 20, wrb, (struct be_dma_mem *)0);
#line 3659
  req->hdr.domain = domain;
#line 3660
  req->enable = 1U;
#line 3661
  status = be_mcc_notify_wait(adapter);
  }
  err: 
  {
#line 3663
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 3664
  return (status);
}
}
#line 3667 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_intr_set(struct be_adapter *adapter , bool intr_enable ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_intr_set *req ;
  int status ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 3673
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 3673
  if (tmp != 0) {
#line 3674
    return (-1);
  } else {

  }
  {
#line 3676
  wrb = wrb_from_mbox(adapter);
#line 3678
  tmp___0 = embedded_payload(wrb);
#line 3678
  req = (struct be_cmd_req_intr_set *)tmp___0;
#line 3680
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 89, 20, wrb, (struct be_dma_mem *)0);
#line 3684
  req->intr_enabled = (u8 )intr_enable;
#line 3686
  status = be_mbox_notify_wait(adapter);
#line 3688
  mutex_unlock(& adapter->mbox_lock);
  }
#line 3689
  return (status);
}
}
#line 3693 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_cmd_get_active_profile(struct be_adapter *adapter , u16 *profile_id ) 
{ 
  struct be_cmd_req_get_active_profile *req ;
  struct be_mcc_wrb *wrb ;
  int status ;
  int tmp ;
  void *tmp___0 ;
  struct be_cmd_resp_get_active_profile *resp ;
  void *tmp___1 ;

  {
  {
#line 3699
  tmp = mutex_lock_interruptible_nested(& adapter->mbox_lock, 0U);
  }
#line 3699
  if (tmp != 0) {
#line 3700
    return (-1);
  } else {

  }
  {
#line 3702
  wrb = wrb_from_mbox(adapter);
  }
#line 3703
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3704
    status = -16;
#line 3705
    goto err;
  } else {

  }
  {
#line 3708
  tmp___0 = embedded_payload(wrb);
#line 3708
  req = (struct be_cmd_req_get_active_profile *)tmp___0;
#line 3710
  be_wrb_cmd_hdr_prepare(& req->hdr, 1, 167, 20, wrb, (struct be_dma_mem *)0);
#line 3714
  status = be_mbox_notify_wait(adapter);
  }
#line 3715
  if (status == 0) {
    {
#line 3716
    tmp___1 = embedded_payload(wrb);
#line 3716
    resp = (struct be_cmd_resp_get_active_profile *)tmp___1;
#line 3718
    *profile_id = resp->active_profile_id;
    }
  } else {

  }
  err: 
  {
#line 3722
  mutex_unlock(& adapter->mbox_lock);
  }
#line 3723
  return (status);
}
}
#line 3726 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
int be_roce_mcc_cmd(void *netdev_handle , void *wrb_payload , int wrb_payload_size ,
                    u16 *cmd_status , u16 *ext_status ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_hdr *hdr ;
  struct be_cmd_req_hdr *req ;
  struct be_cmd_resp_hdr *resp ;
  int status ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 3729
  tmp = netdev_priv((struct net_device  const  *)netdev_handle);
#line 3729
  adapter = (struct be_adapter *)tmp;
#line 3731
  hdr = (struct be_cmd_req_hdr *)wrb_payload;
#line 3736
  spin_lock_bh(& adapter->mcc_lock);
#line 3738
  wrb = wrb_from_mccq(adapter);
  }
#line 3739
  if ((unsigned long )wrb == (unsigned long )((struct be_mcc_wrb *)0)) {
#line 3740
    status = -16;
#line 3741
    goto err;
  } else {

  }
  {
#line 3743
  tmp___0 = embedded_payload(wrb);
#line 3743
  req = (struct be_cmd_req_hdr *)tmp___0;
#line 3744
  tmp___1 = embedded_payload(wrb);
#line 3744
  resp = (struct be_cmd_resp_hdr *)tmp___1;
#line 3746
  be_wrb_cmd_hdr_prepare(req, (int )hdr->subsystem, (int )hdr->opcode, wrb_payload_size,
                         wrb, (struct be_dma_mem *)0);
#line 3748
  memcpy((void *)req, (void const   *)wrb_payload, (size_t )wrb_payload_size);
#line 3749
  swap_dws((void *)req, wrb_payload_size);
#line 3751
  status = be_mcc_notify_wait(adapter);
  }
#line 3752
  if ((unsigned long )cmd_status != (unsigned long )((u16 *)0U)) {
#line 3753
    *cmd_status = (u16 )status;
  } else {

  }
#line 3754
  if ((unsigned long )ext_status != (unsigned long )((u16 *)0U)) {
#line 3755
    *ext_status = 0U;
  } else {

  }
  {
#line 3756
  memcpy(wrb_payload, (void const   *)resp, (unsigned long )resp->response_length + 16UL);
#line 3757
  swap_dws(wrb_payload, (int )(resp->response_length + 16U));
  }
  err: 
  {
#line 3759
  spin_unlock_bh(& adapter->mcc_lock);
  }
#line 3760
  return (status);
}
}
#line 3762 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
static char const   __kstrtab_be_roce_mcc_cmd[16U]  = 
#line 3762
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'm',      'c',      'c',      '_', 
        'c',      'm',      'd',      '\000'};
#line 3762
struct kernel_symbol  const  __ksymtab_be_roce_mcc_cmd ;
#line 3762 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.c"
struct kernel_symbol  const  __ksymtab_be_roce_mcc_cmd  =    {(unsigned long )(& be_roce_mcc_cmd), (char const   *)(& __kstrtab_be_roce_mcc_cmd)};
#line 391 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kernel.h"
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 84 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 86
  return ((char const   *)kobj->name);
}
}
#line 798 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 801
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 802
    return ((char const   *)dev->init_name);
  } else {

  }
  {
#line 804
  tmp = kobject_name(& dev->kobj);
  }
#line 804
  return (tmp);
}
}
#line 53 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
__inline static void ethtool_cmd_speed_set(struct ethtool_cmd *ep , __u32 speed ) 
{ 


  {
#line 57
  ep->speed = (unsigned short )speed;
#line 58
  ep->speed_hi = (unsigned short )(speed >> 16);
#line 59
  return;
}
}
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/uapi/linux/ethtool.h"
__inline static __u32 ethtool_cmd_speed(struct ethtool_cmd  const  *ep ) 
{ 


  {
#line 63
  return ((__u32 )(((int )ep->speed_hi << 16) | (int )ep->speed));
}
}
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/ethtool.h"
extern u32 ethtool_op_get_link(struct net_device * ) ;
#line 2601 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static bool netif_carrier_ok(struct net_device  const  *dev ) 
{ 
  int tmp ;

  {
  {
#line 2603
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& dev->state));
  }
#line 2603
  return (tmp == 0);
}
}
#line 1420 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
  {
#line 1422
  tmp = dev_name(& pdev->dev);
  }
#line 1422
  return (tmp);
}
}
#line 1952 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_cmds.h"
__inline static bool check_privilege(struct be_adapter *adapter , u32 flags ) 
{ 


  {
#line 1954
  return ((flags & adapter->cmd_privileges) != 0U);
}
}
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static struct be_ethtool_stat  const  et_stats[37U]  = 
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
  {      {{'r', 'x', '_', 'c', 'r', 'c', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 2,
      4, 36}, 
        {{'r', 'x', '_', 'a', 'l', 'i', 'g', 'n', 'm', 'e', 'n', 't', '_', 's', 'y',
       'm', 'b', 'o', 'l', '_', 'e', 'r', 'r', 'o', 'r', 's', '\000'}, 2, 4, 40}, 
        {{'r', 'x', '_', 'p', 'a', 'u', 's', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's',
       '\000'}, 2, 4, 44}, 
        {{'r', 'x', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l', '_', 'f', 'r', 'a', 'm',
       'e', 's', '\000'}, 2, 4, 52}, 
        {{'r', 'x', '_', 'i', 'n', '_', 'r', 'a', 'n', 'g', 'e', '_', 'e', 'r', 'r',
       'o', 'r', 's', '\000'}, 2, 4, 56}, 
        {{'r', 'x', '_', 'o', 'u', 't', '_', 'r', 'a', 'n', 'g', 'e', '_', 'e', 'r',
       'r', 'o', 'r', 's', '\000'}, 2, 4, 60}, 
        {{'r', 'x', '_', 'f', 'r', 'a', 'm', 'e', '_', 't', 'o', 'o', '_', 'l', 'o',
       'n', 'g', '\000'}, 2, 4, 64}, 
        {{'r', 'x', '_', 'a', 'd', 'd', 'r', 'e', 's', 's', '_', 'f', 'i', 'l', 't',
       'e', 'r', 'e', 'd', '\000'}, 2, 4, 68}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'o', 'o', '_',
       's', 'm', 'a', 'l', 'l', '\000'}, 2, 4, 72}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'o', 'o', '_',
       's', 'h', 'o', 'r', 't', '\000'}, 2, 4, 76}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 'h', 'e', 'a', 'd',
       'e', 'r', '_', 't', 'o', 'o', '_', 's', 'm', 'a', 'l', 'l', '\000'}, 2, 4,
      80}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 't', 'c', 'p', '_',
       'l', 'e', 'n', 'g', 't', 'h', '\000'}, 2, 4, 84}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '_', 'r', 'u', 'n', 't',
       '\000'}, 2, 4, 88}, 
        {{'r', 'x', 'p', 'p', '_', 'f', 'i', 'f', 'o', '_', 'o', 'v', 'e', 'r', 'f',
       'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4, 116}, 
        {{'r', 'x', '_', 'i', 'n', 'p', 'u', 't', '_', 'f', 'i', 'f', 'o', '_', 'o',
       'v', 'e', 'r', 'f', 'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4,
      120}, 
        {{'r', 'x', '_', 'i', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm', '_',
       'e', 'r', 'r', 's', '\000'}, 2, 4, 92}, 
        {{'r', 'x', '_', 't', 'c', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm',
       '_', 'e', 'r', 'r', 's', '\000'}, 2, 4, 96}, 
        {{'r', 'x', '_', 'u', 'd', 'p', '_', 'c', 'h', 'e', 'c', 'k', 's', 'u', 'm',
       '_', 'e', 'r', 'r', 's', '\000'}, 2, 4, 100}, 
        {{'t', 'x', '_', 'p', 'a', 'u', 's', 'e', 'f', 'r', 'a', 'm', 'e', 's', '\000'},
      2, 4, 104}, 
        {{'t', 'x', '_', 'c', 'o', 'n', 't', 'r', 'o', 'l', 'f', 'r', 'a', 'm', 'e',
       's', '\000'}, 2, 4, 112}, 
        {{'r', 'x', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', '_', 'p', 'a', 'u',
       's', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 2, 4, 48}, 
        {{'t', 'x', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', '_', 'p', 'a', 'u',
       's', 'e', 'f', 'r', 'a', 'm', 'e', 's', '\000'}, 2, 4, 108}, 
        {{'p', 'm', 'e', 'm', '_', 'f', 'i', 'f', 'o', '_', 'o', 'v', 'e', 'r', 'f',
       'l', 'o', 'w', '_', 'd', 'r', 'o', 'p', '\000'}, 2, 4, 124}, 
        {{'j', 'a', 'b', 'b', 'e', 'r', '_', 'e', 'v', 'e', 'n', 't', 's', '\000'}, 2,
      4, 128}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'p', 'b', 'u',
       'f', '\000'}, 2, 4, 8}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'e', 'r', 'x',
       '_', 'd', 'e', 's', 'c', 'r', '\000'}, 2, 4, 16}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 't', 'p', 'r',
       'e', '_', 'd', 'e', 's', 'c', 'r', '\000'}, 2, 4, 20}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 't', 'o', 'o', '_', 'm', 'a',
       'n', 'y', '_', 'f', 'r', 'a', 'g', 's', '\000'}, 2, 4, 24}, 
        {{'f', 'o', 'r', 'w', 'a', 'r', 'd', 'e', 'd', '_', 'p', 'a', 'c', 'k', 'e',
       't', 's', '\000'}, 2, 4, 28}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'm', 't', 'u', '\000'}, 2, 4,
      32}, 
        {{'e', 't', 'h', '_', 'r', 'e', 'd', '_', 'd', 'r', 'o', 'p', 's', '\000'}, 2,
      4, 4}, 
        {{'b', 'e', '_', 'o', 'n', '_', 'd', 'i', 'e', '_', 't', 'e', 'm', 'p', 'e',
       'r', 'a', 't', 'u', 'r', 'e', '\000'}, 2, 4, 0}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'b', 'y', 't', 'e', 's', '_', 'l',
       's', 'd', '\000'}, 2, 4, 132}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'b', 'y', 't', 'e', 's', '_', 'm',
       's', 'd', '\000'}, 2, 4, 136}, 
        {{'r', 'x', '_', 'r', 'o', 'c', 'e', '_', 'f', 'r', 'a', 'm', 'e', 's', '\000'},
      2, 4, 140}, 
        {{'r', 'o', 'c', 'e', '_', 'd', 'r', 'o', 'p', 's', '_', 'p', 'a', 'y', 'l',
       'o', 'a', 'd', '_', 'l', 'e', 'n', '\000'}, 2, 4, 144}, 
        {{'r', 'o', 'c', 'e', '_', 'd', 'r', 'o', 'p', 's', '_', 'c', 'r', 'c', '\000'},
      2, 4, 148}};
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static struct be_ethtool_stat  const  et_rx_stats[7U]  = {      {{'r', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 1, 8, 0}, 
        {{'r', 'x', '_', 'p', 'k', 't', 's', '\000'}, 1, 8, 8}, 
        {{'r', 'x', '_', 'c', 'o', 'm', 'p', 'l', '\000'}, 1, 4, 28}, 
        {{'r', 'x', '_', 'm', 'c', 'a', 's', 't', '_', 'p', 'k', 't', 's', '\000'}, 1,
      4, 32}, 
        {{'r', 'x', '_', 'p', 'o', 's', 't', '_', 'f', 'a', 'i', 'l', '\000'}, 1, 4,
      24}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 's', 'k', 'b',
       's', '\000'}, 1, 4, 16}, 
        {{'r', 'x', '_', 'd', 'r', 'o', 'p', 's', '_', 'n', 'o', '_', 'f', 'r', 'a',
       'g', 's', '\000'}, 1, 4, 20}};
#line 152 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static struct be_ethtool_stat  const  et_tx_stats[7U]  = {      {{'t', 'x', '_', 'c', 'o', 'm', 'p', 'l', '\000'}, 0, 8, 32}, 
        {{'t', 'x', '_', 'b', 'y', 't', 'e', 's', '\000'}, 0, 8, 0}, 
        {{'t', 'x', '_', 'p', 'k', 't', 's', '\000'}, 0, 8, 8}, 
        {{'t', 'x', '_', 'r', 'e', 'q', 's', '\000'}, 0, 8, 16}, 
        {{'t', 'x', '_', 'w', 'r', 'b', 's', '\000'}, 0, 8, 24}, 
        {{'t', 'x', '_', 's', 't', 'o', 'p', 's', '\000'}, 0, 4, 48}, 
        {{'t', 'x', '_', 'd', 'r', 'v', '_', 'd', 'r', 'o', 'p', 's', '\000'}, 0, 4,
      52}};
#line 169 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static char const   et_self_tests[5U][32U]  = { {        'M',        'A',        'C',        ' ', 
            'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}, 
   {        'P',        'H',        'Y',        ' ', 
            'L',        'o',        'o',        'p', 
            'b',        'a',        'c',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}, 
   {        'E',        'x',        't',        'e', 
            'r',        'n',        'a',        'l', 
            ' ',        'L',        'o',        'o', 
            'p',        'b',        'a',        'c', 
            'k',        ' ',        't',        'e', 
            's',        't',        '\000'}, 
   {        'D',        'D',        'R',        ' ', 
            'D',        'M',        'A',        ' ', 
            't',        'e',        's',        't', 
            '\000'}, 
   {        'L',        'i',        'n',        'k', 
            ' ',        't',        'e',        's', 
            't',        '\000'}};
#line 183 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_drvinfo(struct net_device *netdev , struct ethtool_drvinfo *drvinfo ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 186
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 186
  adapter = (struct be_adapter *)tmp;
#line 188
  strlcpy((char *)(& drvinfo->driver), "be2net", 32UL);
#line 189
  strlcpy((char *)(& drvinfo->version), "10.0.600.0u", 32UL);
#line 190
  tmp___0 = memcmp((void const   *)(& adapter->fw_ver), (void const   *)(& adapter->fw_on_flash),
                   32UL);
  }
#line 190
  if (tmp___0 == 0) {
    {
#line 191
    strlcpy((char *)(& drvinfo->fw_version), (char const   *)(& adapter->fw_ver),
            32UL);
    }
  } else {
    {
#line 194
    snprintf((char *)(& drvinfo->fw_version), 32UL, "%s [%s]", (char *)(& adapter->fw_ver),
             (char *)(& adapter->fw_on_flash));
    }
  }
  {
#line 197
  tmp___1 = pci_name((struct pci_dev  const  *)adapter->pdev);
#line 197
  strlcpy((char *)(& drvinfo->bus_info), tmp___1, 32UL);
#line 199
  drvinfo->testinfo_len = 0U;
#line 200
  drvinfo->regdump_len = 0U;
#line 201
  drvinfo->eedump_len = 0U;
  }
#line 202
  return;
}
}
#line 205 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 lancer_cmd_get_file_len(struct be_adapter *adapter , u8 *file_name ) 
{ 
  u32 data_read ;
  u32 eof ;
  u8 addn_status ;
  struct be_dma_mem data_len_cmd ;
  int status ;

  {
  {
#line 207
  data_read = 0U;
#line 212
  memset((void *)(& data_len_cmd), 0, 24UL);
#line 214
  status = lancer_cmd_read_object(adapter, & data_len_cmd, 0U, 0U, (char const   *)file_name,
                                  & data_read, & eof, & addn_status);
  }
#line 217
  return (data_read);
}
}
#line 221 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int lancer_cmd_read_file(struct be_adapter *adapter , u8 *file_name , u32 buf_len ,
                                void *buf ) 
{ 
  struct be_dma_mem read_cmd ;
  u32 read_len ;
  u32 total_read_len ;
  u32 chunk_size ;
  u32 eof ;
  u8 addn_status ;
  int status ;
  u32 __min1 ;
  u32 __min2 ;

  {
  {
#line 225
  read_len = 0U;
#line 225
  total_read_len = 0U;
#line 226
  eof = 0U;
#line 228
  status = 0;
#line 230
  read_cmd.size = 32768U;
#line 231
  read_cmd.va = pci_alloc_consistent(adapter->pdev, (size_t )read_cmd.size, & read_cmd.dma);
  }
#line 234
  if ((unsigned long )read_cmd.va == (unsigned long )((void *)0)) {
    {
#line 235
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Memory allocation failure while reading dump\n");
    }
#line 237
    return (-12);
  } else {

  }
#line 240
  goto ldv_53017;
  ldv_53016: 
  {
#line 241
  __min1 = buf_len - total_read_len;
#line 241
  __min2 = 32768U;
#line 241
  chunk_size = __min1 < __min2 ? __min1 : __min2;
#line 243
  chunk_size = (chunk_size + 3U) & 4294967292U;
#line 244
  status = lancer_cmd_read_object(adapter, & read_cmd, chunk_size, total_read_len,
                                  (char const   *)file_name, & read_len, & eof, & addn_status);
  }
#line 247
  if (status == 0) {
    {
#line 248
    memcpy(buf + (unsigned long )total_read_len, (void const   *)read_cmd.va, (size_t )read_len);
#line 249
    total_read_len = total_read_len + read_len;
#line 250
    eof = eof & 2147483648U;
    }
  } else {
#line 252
    status = -5;
#line 253
    goto ldv_53015;
  }
  ldv_53017: ;
#line 240
  if (total_read_len < buf_len && eof == 0U) {
#line 242
    goto ldv_53016;
  } else {

  }
  ldv_53015: 
  {
#line 256
  pci_free_consistent(adapter->pdev, (size_t )read_cmd.size, read_cmd.va, read_cmd.dma);
  }
#line 259
  return (status);
}
}
#line 263 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_reg_len(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u32 log_size ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 265
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 265
  adapter = (struct be_adapter *)tmp;
#line 266
  log_size = 0U;
#line 268
  tmp___0 = check_privilege(adapter, 1792U);
  }
#line 268
  if (tmp___0) {
#line 268
    tmp___1 = 0;
  } else {
#line 268
    tmp___1 = 1;
  }
#line 268
  if (tmp___1) {
#line 269
    return (0);
  } else {

  }
#line 271
  if ((unsigned int )adapter->virtfn == 0U) {
#line 272
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
      {
#line 273
      log_size = lancer_cmd_get_file_len(adapter, (u8 *)"/dbg/dump.bin");
      }
    } else {
      {
#line 276
      be_cmd_get_reg_len(adapter, & log_size);
      }
    }
  } else {

  }
#line 278
  return ((int )log_size);
}
}
#line 282 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_regs(struct net_device *netdev , struct ethtool_regs *regs , void *buf ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 284
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 284
  adapter = (struct be_adapter *)tmp;
  }
#line 286
  if ((unsigned int )adapter->virtfn == 0U) {
    {
#line 287
    memset(buf, 0, (size_t )regs->len);
    }
#line 288
    if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
      {
#line 289
      lancer_cmd_read_file(adapter, (u8 *)"/dbg/dump.bin", regs->len, buf);
      }
    } else {
      {
#line 292
      be_cmd_get_regs(adapter, regs->len, buf);
      }
    }
  } else {

  }
#line 294
  return;
}
}
#line 296 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_coalesce(struct net_device *netdev , struct ethtool_coalesce *et ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_aic_obj *aic ;

  {
  {
#line 299
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 299
  adapter = (struct be_adapter *)tmp;
#line 300
  aic = (struct be_aic_obj *)(& adapter->aic_obj);
#line 303
  et->rx_coalesce_usecs = aic->prev_eqd;
#line 304
  et->rx_coalesce_usecs_high = aic->max_eqd;
#line 305
  et->rx_coalesce_usecs_low = aic->min_eqd;
#line 307
  et->tx_coalesce_usecs = aic->prev_eqd;
#line 308
  et->tx_coalesce_usecs_high = aic->max_eqd;
#line 309
  et->tx_coalesce_usecs_low = aic->min_eqd;
#line 311
  et->use_adaptive_rx_coalesce = (__u32 )aic->enable;
#line 312
  et->use_adaptive_tx_coalesce = (__u32 )aic->enable;
  }
#line 314
  return (0);
}
}
#line 320 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_coalesce(struct net_device *netdev , struct ethtool_coalesce *et ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_aic_obj *aic ;
  struct be_eq_obj *eqo ;
  int i ;
  __u32 _min1 ;
  unsigned int _min2 ;
  __u32 _min1___0 ;
  u32 _min2___0 ;
  __u32 _min1___1 ;
  u32 _min2___1 ;
  u32 _max1 ;
  u32 _max2 ;

  {
  {
#line 323
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 323
  adapter = (struct be_adapter *)tmp;
#line 324
  aic = (struct be_aic_obj *)(& adapter->aic_obj);
#line 328
  i = 0;
#line 328
  eqo = (struct be_eq_obj *)(& adapter->eq_obj) + (unsigned long )i;
  }
#line 328
  goto ldv_53056;
  ldv_53055: 
#line 329
  aic->enable = et->use_adaptive_rx_coalesce != 0U;
#line 330
  _min1 = et->rx_coalesce_usecs_high;
#line 330
  _min2 = 128U;
#line 330
  aic->max_eqd = _min1 < _min2 ? _min1 : _min2;
#line 331
  _min1___0 = et->rx_coalesce_usecs_low;
#line 331
  _min2___0 = aic->max_eqd;
#line 331
  aic->min_eqd = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 332
  _min1___1 = et->rx_coalesce_usecs;
#line 332
  _min2___1 = aic->max_eqd;
#line 332
  aic->et_eqd = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
#line 333
  _max1 = aic->et_eqd;
#line 333
  _max2 = aic->min_eqd;
#line 333
  aic->et_eqd = _max1 > _max2 ? _max1 : _max2;
#line 334
  aic = aic + 1;
#line 328
  i = i + 1;
#line 328
  eqo = eqo + 1;
  ldv_53056: ;
#line 328
  if (i < (int )adapter->num_evt_qs) {
#line 330
    goto ldv_53055;
  } else {

  }

#line 337
  return (0);
}
}
#line 341 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_ethtool_stats(struct net_device *netdev , struct ethtool_stats *stats ,
                                 uint64_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_rx_obj *rxo ;
  struct be_tx_obj *txo ;
  void *p ;
  unsigned int i ;
  unsigned int j ;
  unsigned int base ;
  unsigned int start ;
  struct be_rx_stats *stats___0 ;
  bool tmp___0 ;
  struct be_tx_stats *stats___1 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 344
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 344
  adapter = (struct be_adapter *)tmp;
#line 348
  base = 0U;
#line 350
  i = 0U;
  }
#line 350
  goto ldv_53074;
  ldv_53073: 
#line 351
  p = (void *)(& adapter->drv_stats) + (unsigned long )et_stats[i].offset;
#line 352
  *(data + (unsigned long )i) = (uint64_t )*((u32 *)p);
#line 350
  i = i + 1U;
  ldv_53074: ;
#line 350
  if (i <= 36U) {
#line 352
    goto ldv_53073;
  } else {

  }
#line 354
  base = base + 37U;
#line 356
  j = 0U;
#line 356
  rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )j;
#line 356
  goto ldv_53089;
  ldv_53088: 
#line 357
  stats___0 = & rxo->stats;
  ldv_53079: 
  {
#line 360
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& stats___0->sync));
#line 361
  *(data + (unsigned long )base) = stats___0->rx_bytes;
#line 362
  *(data + (unsigned long )(base + 1U)) = stats___0->rx_pkts;
#line 363
  tmp___0 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& stats___0->sync),
                                     start);
  }
#line 363
  if ((int )tmp___0) {
#line 365
    goto ldv_53079;
  } else {

  }
#line 365
  i = 2U;
#line 365
  goto ldv_53084;
  ldv_53083: 
#line 366
  p = (void *)stats___0 + (unsigned long )et_rx_stats[i].offset;
#line 367
  *(data + (unsigned long )(base + i)) = (uint64_t )*((u32 *)p);
#line 365
  i = i + 1U;
  ldv_53084: ;
#line 365
  if (i <= 6U) {
#line 367
    goto ldv_53083;
  } else {

  }
#line 369
  base = base + 7U;
#line 356
  j = j + 1U;
#line 356
  rxo = rxo + 1;
  ldv_53089: ;
#line 356
  if (j < (unsigned int )adapter->num_rx_qs) {
#line 358
    goto ldv_53088;
  } else {

  }
#line 372
  j = 0U;
#line 372
  txo = (struct be_tx_obj *)(& adapter->tx_obj) + (unsigned long )j;
#line 372
  goto ldv_53104;
  ldv_53103: 
#line 373
  stats___1 = & txo->stats;
  ldv_53092: 
  {
#line 376
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& stats___1->sync_compl));
#line 377
  *(data + (unsigned long )base) = stats___1->tx_compl;
#line 378
  tmp___1 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& stats___1->sync_compl),
                                     start);
  }
#line 378
  if ((int )tmp___1) {
#line 380
    goto ldv_53092;
  } else {

  }

  ldv_53099: 
  {
#line 381
  start = u64_stats_fetch_begin_bh((struct u64_stats_sync  const  *)(& stats___1->sync));
#line 382
  i = 1U;
  }
#line 382
  goto ldv_53097;
  ldv_53096: 
#line 383
  p = (void *)stats___1 + (unsigned long )et_tx_stats[i].offset;
#line 384
  *(data + (unsigned long )(base + i)) = et_tx_stats[i].size == 8 ? *((u64 *)p) : (u64 )*((u32 *)p);
#line 382
  i = i + 1U;
  ldv_53097: ;
#line 382
  if (i <= 6U) {
#line 384
    goto ldv_53096;
  } else {

  }
  {
#line 388
  tmp___2 = u64_stats_fetch_retry_bh((struct u64_stats_sync  const  *)(& stats___1->sync),
                                     start);
  }
#line 388
  if ((int )tmp___2) {
#line 390
    goto ldv_53099;
  } else {

  }
#line 389
  base = base + 7U;
#line 372
  j = j + 1U;
#line 372
  txo = txo + 1;
  ldv_53104: ;
#line 372
  if (j < (unsigned int )adapter->num_tx_qs) {
#line 374
    goto ldv_53103;
  } else {

  }

#line 379
  return;
}
}
#line 394 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_stat_strings(struct net_device *netdev , uint32_t stringset , uint8_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int i ;
  int j ;

  {
  {
#line 397
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 397
  adapter = (struct be_adapter *)tmp;
  }
  {
#line 401
  if (stringset == 1U) {
#line 401
    goto case_1;
  } else {

  }
#line 421
  if (stringset == 0U) {
#line 421
    goto case_0;
  } else {

  }
#line 400
  goto switch_break;
  case_1: /* CIL Label */ 
#line 402
  i = 0;
#line 402
  goto ldv_53118;
  ldv_53117: 
  {
#line 403
  memcpy((void *)data, (void const   *)(& et_stats[i].desc), 32UL);
#line 404
  data = data + 32UL;
#line 402
  i = i + 1;
  }
  ldv_53118: ;
#line 402
  if ((unsigned int )i <= 36U) {
#line 404
    goto ldv_53117;
  } else {

  }
#line 406
  i = 0;
#line 406
  goto ldv_53126;
  ldv_53125: 
#line 407
  j = 0;
#line 407
  goto ldv_53123;
  ldv_53122: 
  {
#line 408
  sprintf((char *)data, "rxq%d: %s", i, (char const   *)(& et_rx_stats[j].desc));
#line 410
  data = data + 32UL;
#line 407
  j = j + 1;
  }
  ldv_53123: ;
#line 407
  if ((unsigned int )j <= 6U) {
#line 409
    goto ldv_53122;
  } else {

  }
#line 406
  i = i + 1;
  ldv_53126: ;
#line 406
  if (i < (int )adapter->num_rx_qs) {
#line 408
    goto ldv_53125;
  } else {

  }
#line 413
  i = 0;
#line 413
  goto ldv_53134;
  ldv_53133: 
#line 414
  j = 0;
#line 414
  goto ldv_53131;
  ldv_53130: 
  {
#line 415
  sprintf((char *)data, "txq%d: %s", i, (char const   *)(& et_tx_stats[j].desc));
#line 417
  data = data + 32UL;
#line 414
  j = j + 1;
  }
  ldv_53131: ;
#line 414
  if ((unsigned int )j <= 6U) {
#line 416
    goto ldv_53130;
  } else {

  }
#line 413
  i = i + 1;
  ldv_53134: ;
#line 413
  if (i < (int )adapter->num_tx_qs) {
#line 415
    goto ldv_53133;
  } else {

  }

#line 420
  goto ldv_53136;
  case_0: /* CIL Label */ 
#line 422
  i = 0;
#line 422
  goto ldv_53141;
  ldv_53140: 
  {
#line 423
  memcpy((void *)data, (void const   *)(& et_self_tests) + (unsigned long )i, 32UL);
#line 424
  data = data + 32UL;
#line 422
  i = i + 1;
  }
  ldv_53141: ;
#line 422
  if ((unsigned int )i <= 4U) {
#line 424
    goto ldv_53140;
  } else {

  }

#line 426
  goto ldv_53136;
  switch_break: /* CIL Label */ ;
  }
  ldv_53136: ;
#line 429
  return;
}
}
#line 430 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_sset_count(struct net_device *netdev , int stringset ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 432
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 432
  adapter = (struct be_adapter *)tmp;
  }
  {
#line 435
  if (stringset == 0) {
#line 435
    goto case_0;
  } else {

  }
#line 437
  if (stringset == 1) {
#line 437
    goto case_1;
  } else {

  }
#line 441
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 436
  return (5);
  case_1: /* CIL Label */ ;
#line 438
  return ((int )((unsigned int )((unsigned long )adapter->num_rx_qs + (unsigned long )adapter->num_tx_qs) * 7U + 37U));
  switch_default: /* CIL Label */ ;
#line 442
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 446 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 be_get_port_type(u32 phy_type , u32 dac_cable_len ) 
{ 
  u32 port ;

  {
  {
#line 451
  if (phy_type == 7U) {
#line 451
    goto case_7;
  } else {

  }
#line 452
  if (phy_type == 8U) {
#line 452
    goto case_8;
  } else {

  }
#line 453
  if (phy_type == 9U) {
#line 453
    goto case_9;
  } else {

  }
#line 456
  if (phy_type == 3U) {
#line 456
    goto case_3;
  } else {

  }
#line 459
  if (phy_type == 1U) {
#line 459
    goto case_1;
  } else {

  }
#line 460
  if (phy_type == 2U) {
#line 460
    goto case_2;
  } else {

  }
#line 463
  if (phy_type == 6U) {
#line 463
    goto case_6;
  } else {

  }
#line 466
  goto switch_default;
  case_7: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_9: /* CIL Label */ 
#line 454
  port = 0U;
#line 455
  goto ldv_53167;
  case_3: /* CIL Label */ 
#line 457
  port = dac_cable_len != 0U ? 5U : 3U;
#line 458
  goto ldv_53167;
  case_1: /* CIL Label */ ;
  case_2: /* CIL Label */ 
#line 461
  port = 3U;
#line 462
  goto ldv_53167;
  case_6: /* CIL Label */ 
#line 464
  port = 0U;
#line 465
  goto ldv_53167;
  switch_default: /* CIL Label */ 
#line 467
  port = 255U;
  switch_break: /* CIL Label */ ;
  }
  ldv_53167: ;
#line 470
  return (port);
}
}
#line 473 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 convert_to_et_setting(u32 if_type , u32 if_speeds ) 
{ 
  u32 val ;

  {
#line 475
  val = 0U;
  {
#line 478
  if (if_type == 7U) {
#line 478
    goto case_7;
  } else {

  }
#line 479
  if (if_type == 8U) {
#line 479
    goto case_8;
  } else {

  }
#line 480
  if (if_type == 9U) {
#line 480
    goto case_9;
  } else {

  }
#line 489
  if (if_type == 5U) {
#line 489
    goto case_5;
  } else {

  }
#line 496
  if (if_type == 4U) {
#line 496
    goto case_4;
  } else {

  }
#line 500
  if (if_type == 3U) {
#line 500
    goto case_3;
  } else {

  }
#line 501
  if (if_type == 1U) {
#line 501
    goto case_1;
  } else {

  }
#line 502
  if (if_type == 2U) {
#line 502
    goto case_2;
  } else {

  }
#line 509
  if (if_type == 6U) {
#line 509
    goto case_6;
  } else {

  }
#line 518
  goto switch_default;
  case_7: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_9: /* CIL Label */ 
#line 481
  val = val | 128U;
#line 482
  if ((if_speeds & 4U) != 0U) {
#line 483
    val = val | 32U;
  } else {

  }
#line 484
  if ((if_speeds & 2U) != 0U) {
#line 485
    val = val | 8U;
  } else {

  }
#line 486
  if ((int )if_speeds & 1) {
#line 487
    val = val | 2U;
  } else {

  }
#line 488
  goto ldv_53181;
  case_5: /* CIL Label */ 
#line 490
  val = val | 65536U;
#line 491
  if ((if_speeds & 4U) != 0U) {
#line 492
    val = val | 131072U;
  } else {

  }
#line 493
  if ((if_speeds & 8U) != 0U) {
#line 494
    val = val | 262144U;
  } else {

  }
#line 495
  goto ldv_53181;
  case_4: /* CIL Label */ 
#line 497
  val = val | 589824U;
#line 499
  goto ldv_53181;
  case_3: /* CIL Label */ ;
  case_1: /* CIL Label */ ;
  case_2: /* CIL Label */ 
#line 503
  val = val | 1024U;
#line 504
  if ((if_speeds & 8U) != 0U) {
#line 505
    val = val | 4096U;
  } else {

  }
#line 506
  if ((if_speeds & 4U) != 0U) {
#line 507
    val = val | 32U;
  } else {

  }
#line 508
  goto ldv_53181;
  case_6: /* CIL Label */ 
#line 510
  val = val | 128U;
#line 511
  if ((if_speeds & 8U) != 0U) {
#line 512
    val = val | 4096U;
  } else {

  }
#line 513
  if ((if_speeds & 4U) != 0U) {
#line 514
    val = val | 32U;
  } else {

  }
#line 515
  if ((if_speeds & 2U) != 0U) {
#line 516
    val = val | 8U;
  } else {

  }
#line 517
  goto ldv_53181;
  switch_default: /* CIL Label */ 
#line 519
  val = val | 128U;
  switch_break: /* CIL Label */ ;
  }
  ldv_53181: ;
#line 522
  return (val);
}
}
#line 525 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
bool be_pause_supported(struct be_adapter *adapter ) 
{ 


  {
#line 527
  return ((bool )((unsigned int )adapter->phy.interface_type != 3U && (unsigned int )adapter->phy.interface_type != 1U));
}
}
#line 532 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_settings(struct net_device *netdev , struct ethtool_cmd *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u8 link_status ;
  u16 link_speed ;
  int status ;
  u32 auto_speeds ;
  u32 fixed_speeds ;
  u32 dac_cable_len ;
  u16 interface_type ;
  u32 tmp___0 ;
  bool tmp___1 ;
  __u32 tmp___2 ;
  bool tmp___3 ;

  {
  {
#line 534
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 534
  adapter = (struct be_adapter *)tmp;
#line 536
  link_speed = 0U;
  }
#line 543
  if (adapter->phy.link_speed < 0) {
    {
#line 544
    status = be_cmd_link_status_query(adapter, & link_speed, & link_status, 0U);
    }
#line 546
    if (status == 0) {
      {
#line 547
      be_link_status_update(adapter, (int )link_status);
      }
    } else {

    }
    {
#line 548
    ethtool_cmd_speed_set(ecmd, (__u32 )link_speed);
#line 550
    status = be_cmd_get_phy_info(adapter);
    }
#line 551
    if (status == 0) {
      {
#line 552
      interface_type = adapter->phy.interface_type;
#line 553
      auto_speeds = (u32 )adapter->phy.auto_speeds_supported;
#line 554
      fixed_speeds = (u32 )adapter->phy.fixed_speeds_supported;
#line 555
      dac_cable_len = adapter->phy.dac_cable_len;
#line 557
      ecmd->supported = convert_to_et_setting((u32 )interface_type, auto_speeds | fixed_speeds);
#line 561
      ecmd->advertising = convert_to_et_setting((u32 )interface_type, auto_speeds);
#line 565
      tmp___0 = be_get_port_type((u32 )interface_type, dac_cable_len);
#line 565
      ecmd->port = (__u8 )tmp___0;
      }
#line 568
      if ((unsigned int )adapter->phy.auto_speeds_supported != 0U) {
#line 569
        ecmd->supported = ecmd->supported | 64U;
#line 570
        ecmd->autoneg = 1U;
#line 571
        ecmd->advertising = ecmd->advertising | 64U;
      } else {

      }
      {
#line 574
      ecmd->supported = ecmd->supported | 8192U;
#line 575
      tmp___1 = be_pause_supported(adapter);
      }
#line 575
      if ((int )tmp___1) {
#line 576
        ecmd->advertising = ecmd->advertising | 8192U;
      } else {

      }
      {
#line 579
      if ((int )adapter->phy.interface_type == 4) {
#line 579
        goto case_4;
      } else {

      }
#line 580
      if ((int )adapter->phy.interface_type == 5) {
#line 580
        goto case_5;
      } else {

      }
#line 583
      goto switch_default;
      case_4: /* CIL Label */ ;
      case_5: /* CIL Label */ 
#line 581
      ecmd->transceiver = 0U;
#line 582
      goto ldv_53206;
      switch_default: /* CIL Label */ 
#line 584
      ecmd->transceiver = 1U;
#line 585
      goto ldv_53206;
      switch_break: /* CIL Label */ ;
      }
      ldv_53206: ;
    } else {
#line 588
      ecmd->port = 255U;
#line 589
      ecmd->autoneg = 0U;
#line 590
      ecmd->transceiver = 2U;
    }
    {
#line 594
    tmp___2 = ethtool_cmd_speed((struct ethtool_cmd  const  *)ecmd);
#line 594
    adapter->phy.link_speed = (int )tmp___2;
#line 595
    adapter->phy.port_type = ecmd->port;
#line 596
    adapter->phy.transceiver = ecmd->transceiver;
#line 597
    adapter->phy.autoneg = ecmd->autoneg;
#line 598
    adapter->phy.advertising = ecmd->advertising;
#line 599
    adapter->phy.supported = ecmd->supported;
    }
  } else {
    {
#line 601
    ethtool_cmd_speed_set(ecmd, (__u32 )adapter->phy.link_speed);
#line 602
    ecmd->port = adapter->phy.port_type;
#line 603
    ecmd->transceiver = adapter->phy.transceiver;
#line 604
    ecmd->autoneg = adapter->phy.autoneg;
#line 605
    ecmd->advertising = adapter->phy.advertising;
#line 606
    ecmd->supported = adapter->phy.supported;
    }
  }
  {
#line 609
  tmp___3 = netif_carrier_ok((struct net_device  const  *)netdev);
#line 609
  ecmd->duplex = (int )tmp___3 ? 1U : 255U;
#line 610
  ecmd->phy_address = (__u8 )adapter->port_num;
  }
#line 612
  return (0);
}
}
#line 615 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_ringparam(struct net_device *netdev , struct ethtool_ringparam *ring ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
  {
#line 618
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 618
  adapter = (struct be_adapter *)tmp;
#line 620
  tmp___0 = (__u32 )adapter->rx_obj[0].q.len;
#line 620
  ring->rx_pending = tmp___0;
#line 620
  ring->rx_max_pending = tmp___0;
#line 621
  tmp___1 = (__u32 )adapter->tx_obj[0].q.len;
#line 621
  ring->tx_pending = tmp___1;
#line 621
  ring->tx_max_pending = tmp___1;
  }
#line 622
  return;
}
}
#line 625 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 627
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 627
  adapter = (struct be_adapter *)tmp;
#line 629
  be_cmd_get_flow_control(adapter, & ecmd->tx_pause, & ecmd->rx_pause);
#line 630
  ecmd->autoneg = (__u32 )adapter->phy.fc_autoneg;
  }
#line 631
  return;
}
}
#line 634 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_pauseparam(struct net_device *netdev , struct ethtool_pauseparam *ecmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;

  {
  {
#line 636
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 636
  adapter = (struct be_adapter *)tmp;
  }
#line 639
  if (ecmd->autoneg != (__u32 )adapter->phy.fc_autoneg) {
#line 640
    return (-22);
  } else {

  }
  {
#line 641
  adapter->tx_fc = ecmd->tx_pause;
#line 642
  adapter->rx_fc = ecmd->rx_pause;
#line 644
  status = be_cmd_set_flow_control(adapter, adapter->tx_fc, adapter->rx_fc);
  }
#line 646
  if (status != 0) {
    {
#line 647
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "Pause param set failed.\n");
    }
  } else {

  }
#line 649
  return (status);
}
}
#line 653 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_phys_id(struct net_device *netdev , enum ethtool_phys_id_state state ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 656
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 656
  adapter = (struct be_adapter *)tmp;
  }
  {
#line 659
  if ((unsigned int )state == 1U) {
#line 659
    goto case_1;
  } else {

  }
#line 664
  if ((unsigned int )state == 2U) {
#line 664
    goto case_2;
  } else {

  }
#line 669
  if ((unsigned int )state == 3U) {
#line 669
    goto case_3;
  } else {

  }
#line 674
  if ((unsigned int )state == 0U) {
#line 674
    goto case_0;
  } else {

  }
#line 658
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 660
  be_cmd_get_beacon_state(adapter, (int )adapter->hba_port_num, & adapter->beacon_state);
  }
#line 662
  return (1);
  case_2: /* CIL Label */ 
  {
#line 665
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, 1);
  }
#line 667
  goto ldv_53231;
  case_3: /* CIL Label */ 
  {
#line 670
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, 0);
  }
#line 672
  goto ldv_53231;
  case_0: /* CIL Label */ 
  {
#line 675
  be_cmd_set_beacon_state(adapter, (int )adapter->hba_port_num, 0, 0, (int )((u8 )adapter->beacon_state));
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_53231: ;
#line 679
  return (0);
}
}
#line 682 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_dump(struct net_device *netdev , struct ethtool_dump *dump ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct device *dev ;
  int status ;
  bool tmp___0 ;

  {
  {
#line 684
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 684
  adapter = (struct be_adapter *)tmp;
#line 685
  dev = & (adapter->pdev)->dev;
  }
#line 688
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
    {
#line 689
    dev_err((struct device  const  *)dev, "FW dump not supported\n");
    }
#line 690
    return (-95);
  } else {

  }
  {
#line 693
  tmp___0 = dump_present(adapter);
  }
#line 693
  if ((int )tmp___0) {
    {
#line 694
    dev_err((struct device  const  *)dev, "Previous dump not cleared, not forcing dump\n");
    }
#line 695
    return (0);
  } else {

  }
  {
#line 699
  if (dump->flag == 1U) {
#line 699
    goto case_1;
  } else {

  }
#line 704
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 700
  status = lancer_initiate_dump(adapter);
  }
#line 701
  if (status == 0) {
    {
#line 702
    _dev_info((struct device  const  *)dev, "F/w dump initiated successfully\n");
    }
  } else {

  }
#line 703
  goto ldv_53242;
  switch_default: /* CIL Label */ 
  {
#line 705
  dev_err((struct device  const  *)dev, "Invalid dump level: 0x%x\n", dump->flag);
  }
#line 706
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_53242: ;
#line 708
  return (status);
}
}
#line 712 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 714
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 714
  adapter = (struct be_adapter *)tmp;
  }
#line 716
  if ((int )adapter->wol_cap & 1) {
#line 717
    wol->supported = wol->supported | 32U;
#line 718
    if ((int )adapter->wol_en) {
#line 719
      wol->wolopts = wol->wolopts | 32U;
    } else {

    }
  } else {
#line 721
    wol->wolopts = 0U;
  }
  {
#line 723
  memset((void *)(& wol->sopass), 0, 6UL);
  }
#line 724
  return;
}
}
#line 727 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_wol(struct net_device *netdev , struct ethtool_wolinfo *wol ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 729
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 729
  adapter = (struct be_adapter *)tmp;
  }
#line 731
  if ((wol->wolopts & 4294967263U) != 0U) {
#line 732
    return (-95);
  } else {

  }
#line 734
  if (((int )adapter->wol_cap & 1) == 0) {
    {
#line 735
    dev_warn((struct device  const  *)(& (adapter->pdev)->dev), "WOL not supported\n");
    }
#line 736
    return (-95);
  } else {

  }
#line 739
  if ((wol->wolopts & 32U) != 0U) {
#line 740
    adapter->wol_en = 1;
  } else {
#line 742
    adapter->wol_en = 0;
  }
#line 744
  return (0);
}
}
#line 748 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_test_ddr_dma(struct be_adapter *adapter ) 
{ 
  int ret ;
  int i ;
  struct be_dma_mem ddrdma_cmd ;
  u64 pattern[2U] ;

  {
  {
#line 752
  pattern[0] = 6510615555426900570ULL;
#line 752
  pattern[1] = 0xa5a5a5a5a5a5a5a5ULL;
#line 756
  ddrdma_cmd.size = 8224U;
#line 757
  ddrdma_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )ddrdma_cmd.size,
                                  & ddrdma_cmd.dma, 208U, (struct dma_attrs *)0);
  }
#line 759
  if ((unsigned long )ddrdma_cmd.va == (unsigned long )((void *)0)) {
#line 760
    return (-12);
  } else {

  }
#line 762
  i = 0;
#line 762
  goto ldv_53263;
  ldv_53262: 
  {
#line 763
  ret = be_cmd_ddr_dma_test(adapter, pattern[i], 4096U, & ddrdma_cmd);
  }
#line 765
  if (ret != 0) {
#line 766
    goto err;
  } else {

  }
#line 762
  i = i + 1;
  ldv_53263: ;
#line 762
  if (i <= 1) {
#line 764
    goto ldv_53262;
  } else {

  }

  err: 
  {
#line 770
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )ddrdma_cmd.size, ddrdma_cmd.va,
                 ddrdma_cmd.dma, (struct dma_attrs *)0);
  }
#line 772
  return (ret);
}
}
#line 775 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u64 be_loopback_test(struct be_adapter *adapter , u8 loopback_type , u64 *status ) 
{ 
  int tmp ;

  {
  {
#line 778
  be_cmd_set_loopback(adapter, (int )adapter->hba_port_num, (int )loopback_type, 1);
#line 780
  tmp = be_cmd_loopback_test(adapter, (u32 )adapter->hba_port_num, (u32 )loopback_type,
                             1500U, 2U, 2748ULL);
#line 780
  *status = (u64 )tmp;
#line 783
  be_cmd_set_loopback(adapter, (int )adapter->hba_port_num, 255, 1);
  }
#line 785
  return (*status);
}
}
#line 789 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_self_test(struct net_device *netdev , struct ethtool_test *test , u64 *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  u8 link_status ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  int tmp___3 ;

  {
  {
#line 791
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 791
  adapter = (struct be_adapter *)tmp;
#line 793
  link_status = 0U;
  }
#line 795
  if ((adapter->function_caps & 64U) != 0U) {
    {
#line 796
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "Self test not supported\n");
#line 797
    test->flags = test->flags | 2U;
    }
#line 798
    return;
  } else {

  }
  {
#line 801
  memset((void *)data, 0, 40UL);
  }
#line 803
  if ((int )test->flags & 1) {
    {
#line 804
    tmp___0 = be_loopback_test(adapter, 0, data);
    }
#line 804
    if (tmp___0 != 0ULL) {
#line 806
      test->flags = test->flags | 2U;
    } else {

    }
    {
#line 808
    tmp___1 = be_loopback_test(adapter, 1, data + 1UL);
    }
#line 808
    if (tmp___1 != 0ULL) {
#line 810
      test->flags = test->flags | 2U;
    } else {

    }
    {
#line 812
    tmp___2 = be_loopback_test(adapter, 2, data + 2UL);
    }
#line 812
    if (tmp___2 != 0ULL) {
#line 814
      test->flags = test->flags | 2U;
    } else {

    }
  } else {

  }
#line 818
  if ((unsigned int )(adapter->pdev)->device != 57888U && (unsigned int )(adapter->pdev)->device != 57896U) {
    {
#line 818
    tmp___3 = be_test_ddr_dma(adapter);
    }
#line 818
    if (tmp___3 != 0) {
#line 819
      *(data + 3UL) = 1ULL;
#line 820
      test->flags = test->flags | 2U;
    } else {

    }
  } else {

  }
  {
#line 823
  status = be_cmd_link_status_query(adapter, (u16 *)0U, & link_status, 0U);
  }
#line 824
  if (status != 0) {
#line 825
    test->flags = test->flags | 2U;
#line 826
    *(data + 4UL) = 0xffffffffffffffffULL;
  } else
#line 827
  if ((unsigned int )link_status == 0U) {
#line 828
    test->flags = test->flags | 2U;
#line 829
    *(data + 4UL) = 1ULL;
  } else {

  }
#line 831
  return;
}
}
#line 834 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_do_flash(struct net_device *netdev , struct ethtool_flash *efl ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 836
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 836
  adapter = (struct be_adapter *)tmp;
#line 838
  tmp___0 = be_load_fw(adapter, (u8 *)(& efl->data));
  }
#line 838
  return (tmp___0);
}
}
#line 842 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_eeprom_len(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;

  {
  {
#line 844
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 844
  adapter = (struct be_adapter *)tmp;
#line 846
  tmp___0 = check_privilege(adapter, 1792U);
  }
#line 846
  if (tmp___0) {
#line 846
    tmp___1 = 0;
  } else {
#line 846
    tmp___1 = 1;
  }
#line 846
  if (tmp___1) {
#line 847
    return (0);
  } else {

  }
#line 849
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 850
    if ((unsigned int )adapter->virtfn == 0U) {
      {
#line 851
      tmp___2 = lancer_cmd_get_file_len(adapter, (u8 *)"/vpd/ntr_pf.vpd");
      }
#line 851
      return ((int )tmp___2);
    } else {
      {
#line 854
      tmp___3 = lancer_cmd_get_file_len(adapter, (u8 *)"/vpd/ntr_vf.vpd");
      }
#line 854
      return ((int )tmp___3);
    }
  } else {
#line 857
    return (1024);
  }
}
}
#line 862 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_read_eeprom(struct net_device *netdev , struct ethtool_eeprom *eeprom ,
                          uint8_t *data ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  struct be_dma_mem eeprom_cmd ;
  struct be_cmd_resp_seeprom_read *resp ;
  int status ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 865
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 865
  adapter = (struct be_adapter *)tmp;
  }
#line 870
  if (eeprom->len == 0U) {
#line 871
    return (-22);
  } else {

  }
#line 873
  if ((unsigned int )(adapter->pdev)->device == 57888U || (unsigned int )(adapter->pdev)->device == 57896U) {
#line 874
    if ((unsigned int )adapter->virtfn == 0U) {
      {
#line 875
      tmp___0 = lancer_cmd_read_file(adapter, (u8 *)"/vpd/ntr_pf.vpd", eeprom->len,
                                     (void *)data);
      }
#line 875
      return (tmp___0);
    } else {
      {
#line 878
      tmp___1 = lancer_cmd_read_file(adapter, (u8 *)"/vpd/ntr_vf.vpd", eeprom->len,
                                     (void *)data);
      }
#line 878
      return (tmp___1);
    }
  } else {

  }
  {
#line 882
  eeprom->magic = (__u32 )(((int )(adapter->pdev)->device << 16) | 6562);
#line 884
  memset((void *)(& eeprom_cmd), 0, 24UL);
#line 885
  eeprom_cmd.size = 1040U;
#line 886
  eeprom_cmd.va = dma_alloc_attrs(& (adapter->pdev)->dev, (size_t )eeprom_cmd.size,
                                  & eeprom_cmd.dma, 208U, (struct dma_attrs *)0);
  }
#line 889
  if ((unsigned long )eeprom_cmd.va == (unsigned long )((void *)0)) {
#line 890
    return (-12);
  } else {

  }
  {
#line 892
  status = be_cmd_get_seeprom_data(adapter, & eeprom_cmd);
  }
#line 894
  if (status == 0) {
    {
#line 895
    resp = (struct be_cmd_resp_seeprom_read *)eeprom_cmd.va;
#line 896
    memcpy((void *)data, (void const   *)(& resp->seeprom_data) + (unsigned long )eeprom->offset,
           (size_t )eeprom->len);
    }
  } else {

  }
  {
#line 898
  dma_free_attrs(& (adapter->pdev)->dev, (size_t )eeprom_cmd.size, eeprom_cmd.va,
                 eeprom_cmd.dma, (struct dma_attrs *)0);
  }
#line 901
  return (status);
}
}
#line 904 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u32 be_get_msg_level(struct net_device *netdev ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 906
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 906
  adapter = (struct be_adapter *)tmp;
  }
#line 908
  return (adapter->msg_enable);
}
}
#line 911 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_set_msg_level(struct net_device *netdev , u32 level ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;

  {
  {
#line 913
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 913
  adapter = (struct be_adapter *)tmp;
  }
#line 915
  if (adapter->msg_enable == level) {
#line 916
    return;
  } else {

  }
#line 918
  if (((level ^ adapter->msg_enable) & 8192U) != 0U) {
#line 919
    if (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U)) {
      {
#line 920
      be_cmd_set_fw_log_level(adapter, (level & 8192U) != 0U ? 48U : 64U);
      }
    } else {

    }
  } else {

  }
#line 923
  adapter->msg_enable = level;
#line 925
  return;
}
}
#line 928 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static u64 be_get_rss_hash_opts(struct be_adapter *adapter , u64 flow_type ) 
{ 
  u64 data ;

  {
#line 930
  data = 0ULL;
  {
#line 933
  if (flow_type == 1ULL) {
#line 933
    goto case_1;
  } else {

  }
#line 939
  if (flow_type == 2ULL) {
#line 939
    goto case_2;
  } else {

  }
#line 945
  if (flow_type == 5ULL) {
#line 945
    goto case_5;
  } else {

  }
#line 951
  if (flow_type == 6ULL) {
#line 951
    goto case_6;
  } else {

  }
#line 932
  goto switch_break;
  case_1: /* CIL Label */ ;
#line 934
  if ((int )adapter->rss_flags & 1) {
#line 935
    data = data | 48ULL;
  } else {

  }
#line 936
  if ((adapter->rss_flags & 2ULL) != 0ULL) {
#line 937
    data = data | 192ULL;
  } else {

  }
#line 938
  goto ldv_53313;
  case_2: /* CIL Label */ ;
#line 940
  if ((int )adapter->rss_flags & 1) {
#line 941
    data = data | 48ULL;
  } else {

  }
#line 942
  if ((adapter->rss_flags & 16ULL) != 0ULL) {
#line 943
    data = data | 192ULL;
  } else {

  }
#line 944
  goto ldv_53313;
  case_5: /* CIL Label */ ;
#line 946
  if ((adapter->rss_flags & 4ULL) != 0ULL) {
#line 947
    data = data | 48ULL;
  } else {

  }
#line 948
  if ((adapter->rss_flags & 8ULL) != 0ULL) {
#line 949
    data = data | 192ULL;
  } else {

  }
#line 950
  goto ldv_53313;
  case_6: /* CIL Label */ ;
#line 952
  if ((adapter->rss_flags & 4ULL) != 0ULL) {
#line 953
    data = data | 48ULL;
  } else {

  }
#line 954
  if ((adapter->rss_flags & 32ULL) != 0ULL) {
#line 955
    data = data | 192ULL;
  } else {

  }
#line 956
  goto ldv_53313;
  switch_break: /* CIL Label */ ;
  }
  ldv_53313: ;
#line 959
  return (data);
}
}
#line 962 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_get_rxnfc(struct net_device *netdev , struct ethtool_rxnfc *cmd , u32 *rule_locs ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 965
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 965
  adapter = (struct be_adapter *)tmp;
#line 967
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
  }
#line 967
  if (tmp___0) {
#line 967
    tmp___1 = 0;
  } else {
#line 967
    tmp___1 = 1;
  }
#line 967
  if (tmp___1) {
    {
#line 968
    _dev_info((struct device  const  *)(& (adapter->pdev)->dev), "ethtool::get_rxnfc: RX flow hashing is disabled\n");
    }
#line 970
    return (-22);
  } else {

  }
  {
#line 974
  if (cmd->cmd == 41U) {
#line 974
    goto case_41;
  } else {

  }
#line 977
  if (cmd->cmd == 45U) {
#line 977
    goto case_45;
  } else {

  }
#line 980
  goto switch_default;
  case_41: /* CIL Label */ 
  {
#line 975
  cmd->data = be_get_rss_hash_opts(adapter, (u64 )cmd->flow_type);
  }
#line 976
  goto ldv_53324;
  case_45: /* CIL Label */ 
#line 978
  cmd->data = (__u64 )((int )adapter->num_rx_qs + -1);
#line 979
  goto ldv_53324;
  switch_default: /* CIL Label */ ;
#line 981
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_53324: ;
#line 984
  return (0);
}
}
#line 987 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_rss_hash_opts(struct be_adapter *adapter , struct ethtool_rxnfc *cmd ) 
{ 
  struct be_rx_obj *rxo ;
  int status ;
  int i ;
  int j ;
  u8 rsstable[128U] ;
  u32 rss_flags ;
  bool tmp ;

  {
#line 991
  status = 0;
#line 993
  rss_flags = (u32 )adapter->rss_flags;
#line 995
  if (cmd->data != 48ULL && cmd->data != 240ULL) {
#line 997
    return (-22);
  } else {

  }
  {
#line 1000
  if (cmd->flow_type == 1U) {
#line 1000
    goto case_1;
  } else {

  }
#line 1007
  if (cmd->flow_type == 5U) {
#line 1007
    goto case_5;
  } else {

  }
#line 1014
  if (cmd->flow_type == 2U) {
#line 1014
    goto case_2;
  } else {

  }
#line 1025
  if (cmd->flow_type == 6U) {
#line 1025
    goto case_6;
  } else {

  }
#line 1036
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 1001
  if (cmd->data == 48ULL) {
#line 1002
    rss_flags = rss_flags & 4294967293U;
  } else
#line 1003
  if (cmd->data == 240ULL) {
#line 1004
    rss_flags = rss_flags | 3U;
  } else {

  }
#line 1006
  goto ldv_53338;
  case_5: /* CIL Label */ ;
#line 1008
  if (cmd->data == 48ULL) {
#line 1009
    rss_flags = rss_flags & 4294967287U;
  } else
#line 1010
  if (cmd->data == 240ULL) {
#line 1011
    rss_flags = rss_flags | 12U;
  } else {

  }
#line 1013
  goto ldv_53338;
  case_2: /* CIL Label */ ;
#line 1015
  if (cmd->data == 240ULL && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1017
    return (-22);
  } else {

  }
#line 1019
  if (cmd->data == 48ULL) {
#line 1020
    rss_flags = rss_flags & 4294967279U;
  } else
#line 1021
  if (cmd->data == 240ULL) {
#line 1022
    rss_flags = rss_flags | 17U;
  } else {

  }
#line 1024
  goto ldv_53338;
  case_6: /* CIL Label */ ;
#line 1026
  if (cmd->data == 240ULL && (((unsigned int )(adapter->pdev)->device == 545U || (unsigned int )(adapter->pdev)->device == 1808U) || ((unsigned int )(adapter->pdev)->device == 529U || (unsigned int )(adapter->pdev)->device == 1792U))) {
#line 1028
    return (-22);
  } else {

  }
#line 1030
  if (cmd->data == 48ULL) {
#line 1031
    rss_flags = rss_flags & 4294967263U;
  } else
#line 1032
  if (cmd->data == 240ULL) {
#line 1033
    rss_flags = rss_flags | 36U;
  } else {

  }
#line 1035
  goto ldv_53338;
  switch_default: /* CIL Label */ ;
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_53338: ;
#line 1040
  if ((u64 )rss_flags == adapter->rss_flags) {
#line 1041
    return (status);
  } else {

  }
  {
#line 1043
  tmp = be_multi_rxq((struct be_adapter  const  *)adapter);
  }
#line 1043
  if ((int )tmp) {
#line 1044
    j = 0;
#line 1044
    goto ldv_53347;
    ldv_53346: 
#line 1045
    i = 0;
#line 1045
    rxo = (struct be_rx_obj *)(& adapter->rx_obj) + (unsigned long )i;
#line 1045
    goto ldv_53345;
    ldv_53344: ;
#line 1046
    if (j + i > 127) {
#line 1047
      goto ldv_53343;
    } else {

    }
#line 1048
    rsstable[j + i] = rxo->rss_id;
#line 1045
    i = i + 1;
#line 1045
    rxo = rxo + 1;
    ldv_53345: ;
#line 1045
    if (i < (int )adapter->num_rx_qs + -1) {
#line 1047
      goto ldv_53344;
    } else {

    }
    ldv_53343: 
#line 1044
    j = j + ((int )adapter->num_rx_qs + -1);
    ldv_53347: ;
#line 1044
    if (j <= 127) {
#line 1046
      goto ldv_53346;
    } else {

    }

  } else {

  }
  {
#line 1052
  status = be_cmd_rss_config(adapter, (u8 *)(& rsstable), rss_flags, 128);
  }
#line 1053
  if (status == 0) {
#line 1054
    adapter->rss_flags = (u64 )rss_flags;
  } else {

  }
#line 1056
  return (status);
}
}
#line 1059 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_rxnfc(struct net_device *netdev , struct ethtool_rxnfc *cmd ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  int status ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1061
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1061
  adapter = (struct be_adapter *)tmp;
#line 1062
  status = 0;
#line 1064
  tmp___0 = be_multi_rxq((struct be_adapter  const  *)adapter);
  }
#line 1064
  if (tmp___0) {
#line 1064
    tmp___1 = 0;
  } else {
#line 1064
    tmp___1 = 1;
  }
#line 1064
  if (tmp___1) {
    {
#line 1065
    dev_err((struct device  const  *)(& (adapter->pdev)->dev), "ethtool::set_rxnfc: RX flow hashing is disabled\n");
    }
#line 1067
    return (-22);
  } else {

  }
  {
#line 1071
  if (cmd->cmd == 42U) {
#line 1071
    goto case_42;
  } else {

  }
#line 1074
  goto switch_default;
  case_42: /* CIL Label */ 
  {
#line 1072
  status = be_set_rss_hash_opts(adapter, cmd);
  }
#line 1073
  goto ldv_53356;
  switch_default: /* CIL Label */ ;
#line 1075
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_53356: ;
#line 1078
  return (status);
}
}
#line 1081 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static void be_get_channels(struct net_device *netdev , struct ethtool_channels *ch ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u16 tmp___0 ;

  {
  {
#line 1084
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1084
  adapter = (struct be_adapter *)tmp;
#line 1086
  ch->combined_count = (__u32 )adapter->num_evt_qs;
#line 1087
  tmp___0 = be_max_qs(adapter);
#line 1087
  ch->max_combined = (__u32 )tmp___0;
  }
#line 1088
  return;
}
}
#line 1090 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
static int be_set_channels(struct net_device *netdev , struct ethtool_channels *ch ) 
{ 
  struct be_adapter *adapter ;
  void *tmp ;
  u16 tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1093
  tmp = netdev_priv((struct net_device  const  *)netdev);
#line 1093
  adapter = (struct be_adapter *)tmp;
  }
#line 1095
  if (((ch->rx_count != 0U || ch->tx_count != 0U) || ch->other_count != 0U) || ch->combined_count == 0U) {
#line 1097
    return (-22);
  } else {
    {
#line 1095
    tmp___0 = be_max_qs(adapter);
    }
#line 1095
    if (ch->combined_count > (__u32 )tmp___0) {
#line 1097
      return (-22);
    } else {

    }
  }
  {
#line 1099
  adapter->cfg_num_qs = (u16 )ch->combined_count;
#line 1101
  tmp___1 = be_update_queues(adapter);
  }
#line 1101
  return (tmp___1);
}
}
#line 1104 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_ethtool.c"
struct ethtool_ops  const  be_ethtool_ops  = 
#line 1104
     {& be_get_settings, 0, & be_get_drvinfo, & be_get_reg_len, & be_get_regs, & be_get_wol,
    & be_set_wol, & be_get_msg_level, & be_set_msg_level, 0, & ethtool_op_get_link,
    & be_get_eeprom_len, & be_read_eeprom, 0, & be_get_coalesce, & be_set_coalesce,
    & be_get_ringparam, 0, & be_get_pauseparam, & be_set_pauseparam, & be_self_test,
    & be_get_stat_strings, & be_set_phys_id, & be_get_ethtool_stats, 0, 0, 0, 0, & be_get_sset_count,
    & be_get_rxnfc, & be_set_rxnfc, & be_do_flash, 0, 0, 0, 0, & be_get_channels,
    & be_set_channels, 0, 0, & be_set_dump, 0, 0, 0, 0, 0};
#line 116 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_flash_device)(struct net_device * , struct ethtool_flash * )  =    & be_do_flash;
#line 117 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_get_channels)(struct net_device * , struct ethtool_channels * )  =    & be_get_channels;
#line 118 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_get_coalesce)(struct net_device * , struct ethtool_coalesce * )  =    & be_get_coalesce;
#line 119 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_get_drvinfo)(struct net_device * , struct ethtool_drvinfo * )  =    & be_get_drvinfo;
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_get_eeprom)(struct net_device * , struct ethtool_eeprom * , unsigned char * )  =    & be_read_eeprom;
#line 121 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_get_eeprom_len)(struct net_device * )  =    & be_get_eeprom_len;
#line 122 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_get_ethtool_stats)(struct net_device * , struct ethtool_stats * ,
                                         unsigned long long * )  =    & be_get_ethtool_stats;
#line 123 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
unsigned int (*ldv_2_callback_get_link)(struct net_device * )  =    & ethtool_op_get_link;
#line 124 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
unsigned int (*ldv_2_callback_get_msglevel)(struct net_device * )  =    & be_get_msg_level;
#line 125 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_get_pauseparam)(struct net_device * , struct ethtool_pauseparam * )  =    & be_get_pauseparam;
#line 126 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_get_regs)(struct net_device * , struct ethtool_regs * , void * )  =    & be_get_regs;
#line 127 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_get_regs_len)(struct net_device * )  =    & be_get_reg_len;
#line 128 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_get_ringparam)(struct net_device * , struct ethtool_ringparam * )  =    & be_get_ringparam;
#line 129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , unsigned int * )  =    & be_get_rxnfc;
#line 130 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_get_settings)(struct net_device * , struct ethtool_cmd * )  =    & be_get_settings;
#line 131 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_get_sset_count)(struct net_device * , int  )  =    & be_get_sset_count;
#line 132 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_get_strings)(struct net_device * , unsigned int  , unsigned char * )  =    & be_get_stat_strings;
#line 133 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_get_wol)(struct net_device * , struct ethtool_wolinfo * )  =    & be_get_wol;
#line 134 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_self_test)(struct net_device * , struct ethtool_test * , unsigned long long * )  =    & be_self_test;
#line 135 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_set_channels)(struct net_device * , struct ethtool_channels * )  =    & be_set_channels;
#line 136 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_set_coalesce)(struct net_device * , struct ethtool_coalesce * )  =    & be_set_coalesce;
#line 137 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_set_dump)(struct net_device * , struct ethtool_dump * )  =    & be_set_dump;
#line 138 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void (*ldv_2_callback_set_msglevel)(struct net_device * , unsigned int  )  =    & be_set_msg_level;
#line 139 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_set_pauseparam)(struct net_device * , struct ethtool_pauseparam * )  =    & be_set_pauseparam;
#line 140 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_set_phys_id)(struct net_device * , enum ethtool_phys_id_state  )  =    & be_set_phys_id;
#line 141 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_set_rxnfc)(struct net_device * , struct ethtool_rxnfc * )  =    & be_set_rxnfc;
#line 142 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
int (*ldv_2_callback_set_wol)(struct net_device * , struct ethtool_wolinfo * )  =    & be_set_wol;
#line 146 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_10(int (*arg0)(struct net_device * ,
                                                               struct ethtool_eeprom * ,
                                                               unsigned char * ) ,
                                                   struct net_device *arg1 , struct ethtool_eeprom *arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 147
  be_read_eeprom(arg1, arg2, arg3);
  }
#line 148
  return;
}
}
#line 151 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_13(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 152
  be_get_eeprom_len(arg1);
  }
#line 153
  return;
}
}
#line 156 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_14(void (*arg0)(struct net_device * ,
                                                                struct ethtool_stats * ,
                                                                unsigned long long * ) ,
                                                   struct net_device *arg1 , struct ethtool_stats *arg2 ,
                                                   unsigned long long *arg3 ) 
{ 


  {
  {
#line 157
  be_get_ethtool_stats(arg1, arg2, arg3);
  }
#line 158
  return;
}
}
#line 161 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_17(unsigned int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 162
  ethtool_op_get_link(arg1);
  }
#line 163
  return;
}
}
#line 166 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_18(unsigned int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 167
  be_get_msg_level(arg1);
  }
#line 168
  return;
}
}
#line 171 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_19(void (*arg0)(struct net_device * ,
                                                                struct ethtool_pauseparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_pauseparam *arg2 ) 
{ 


  {
  {
#line 172
  be_get_pauseparam(arg1, arg2);
  }
#line 173
  return;
}
}
#line 176 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_20(void (*arg0)(struct net_device * ,
                                                                struct ethtool_regs * ,
                                                                void * ) , struct net_device *arg1 ,
                                                   struct ethtool_regs *arg2 , void *arg3 ) 
{ 


  {
  {
#line 177
  be_get_regs(arg1, arg2, arg3);
  }
#line 178
  return;
}
}
#line 181 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_21(int (*arg0)(struct net_device * ) ,
                                                   struct net_device *arg1 ) 
{ 


  {
  {
#line 182
  be_get_reg_len(arg1);
  }
#line 183
  return;
}
}
#line 186 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_22(void (*arg0)(struct net_device * ,
                                                                struct ethtool_ringparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_ringparam *arg2 ) 
{ 


  {
  {
#line 187
  be_get_ringparam(arg1, arg2);
  }
#line 188
  return;
}
}
#line 191 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_23(int (*arg0)(struct net_device * ,
                                                               struct ethtool_rxnfc * ,
                                                               unsigned int * ) ,
                                                   struct net_device *arg1 , struct ethtool_rxnfc *arg2 ,
                                                   unsigned int *arg3 ) 
{ 


  {
  {
#line 192
  be_get_rxnfc(arg1, arg2, arg3);
  }
#line 193
  return;
}
}
#line 196 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_26(int (*arg0)(struct net_device * ,
                                                               struct ethtool_cmd * ) ,
                                                   struct net_device *arg1 , struct ethtool_cmd *arg2 ) 
{ 


  {
  {
#line 197
  be_get_settings(arg1, arg2);
  }
#line 198
  return;
}
}
#line 201 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_27(int (*arg0)(struct net_device * ,
                                                               int  ) , struct net_device *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 202
  be_get_sset_count(arg1, arg2);
  }
#line 203
  return;
}
}
#line 206 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_3(int (*arg0)(struct net_device * ,
                                                              struct ethtool_flash * ) ,
                                                  struct net_device *arg1 , struct ethtool_flash *arg2 ) 
{ 


  {
  {
#line 207
  be_do_flash(arg1, arg2);
  }
#line 208
  return;
}
}
#line 211 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_30(void (*arg0)(struct net_device * ,
                                                                unsigned int  , unsigned char * ) ,
                                                   struct net_device *arg1 , unsigned int arg2 ,
                                                   unsigned char *arg3 ) 
{ 


  {
  {
#line 212
  be_get_stat_strings(arg1, arg2, arg3);
  }
#line 213
  return;
}
}
#line 216 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_33(void (*arg0)(struct net_device * ,
                                                                struct ethtool_wolinfo * ) ,
                                                   struct net_device *arg1 , struct ethtool_wolinfo *arg2 ) 
{ 


  {
  {
#line 217
  be_get_wol(arg1, arg2);
  }
#line 218
  return;
}
}
#line 221 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_66(void (*arg0)(struct net_device * ,
                                                                struct ethtool_test * ,
                                                                unsigned long long * ) ,
                                                   struct net_device *arg1 , struct ethtool_test *arg2 ,
                                                   unsigned long long *arg3 ) 
{ 


  {
  {
#line 222
  be_self_test(arg1, arg2, arg3);
  }
#line 223
  return;
}
}
#line 226 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_69(int (*arg0)(struct net_device * ,
                                                               struct ethtool_channels * ) ,
                                                   struct net_device *arg1 , struct ethtool_channels *arg2 ) 
{ 


  {
  {
#line 227
  be_set_channels(arg1, arg2);
  }
#line 228
  return;
}
}
#line 231 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_7(void (*arg0)(struct net_device * ,
                                                               struct ethtool_channels * ) ,
                                                  struct net_device *arg1 , struct ethtool_channels *arg2 ) 
{ 


  {
  {
#line 232
  be_get_channels(arg1, arg2);
  }
#line 233
  return;
}
}
#line 236 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_70(int (*arg0)(struct net_device * ,
                                                               struct ethtool_coalesce * ) ,
                                                   struct net_device *arg1 , struct ethtool_coalesce *arg2 ) 
{ 


  {
  {
#line 237
  be_set_coalesce(arg1, arg2);
  }
#line 238
  return;
}
}
#line 241 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_71(int (*arg0)(struct net_device * ,
                                                               struct ethtool_dump * ) ,
                                                   struct net_device *arg1 , struct ethtool_dump *arg2 ) 
{ 


  {
  {
#line 242
  be_set_dump(arg1, arg2);
  }
#line 243
  return;
}
}
#line 246 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_72(void (*arg0)(struct net_device * ,
                                                                unsigned int  ) ,
                                                   struct net_device *arg1 , unsigned int arg2 ) 
{ 


  {
  {
#line 247
  be_set_msg_level(arg1, arg2);
  }
#line 248
  return;
}
}
#line 251 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_75(int (*arg0)(struct net_device * ,
                                                               struct ethtool_pauseparam * ) ,
                                                   struct net_device *arg1 , struct ethtool_pauseparam *arg2 ) 
{ 


  {
  {
#line 252
  be_set_pauseparam(arg1, arg2);
  }
#line 253
  return;
}
}
#line 256 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_76(int (*arg0)(struct net_device * ,
                                                               enum ethtool_phys_id_state  ) ,
                                                   struct net_device *arg1 , enum ethtool_phys_id_state arg2 ) 
{ 


  {
  {
#line 257
  be_set_phys_id(arg1, arg2);
  }
#line 258
  return;
}
}
#line 261 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_77(int (*arg0)(struct net_device * ,
                                                               struct ethtool_rxnfc * ) ,
                                                   struct net_device *arg1 , struct ethtool_rxnfc *arg2 ) 
{ 


  {
  {
#line 262
  be_set_rxnfc(arg1, arg2);
  }
#line 263
  return;
}
}
#line 266 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_78(int (*arg0)(struct net_device * ,
                                                               struct ethtool_wolinfo * ) ,
                                                   struct net_device *arg1 , struct ethtool_wolinfo *arg2 ) 
{ 


  {
  {
#line 267
  be_set_wol(arg1, arg2);
  }
#line 268
  return;
}
}
#line 271 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_8(int (*arg0)(struct net_device * ,
                                                              struct ethtool_coalesce * ) ,
                                                  struct net_device *arg1 , struct ethtool_coalesce *arg2 ) 
{ 


  {
  {
#line 272
  be_get_coalesce(arg1, arg2);
  }
#line 273
  return;
}
}
#line 276 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/weaver/.tmp_be_ethtool.c.aux"
void ldv_dummy_resourceless_instance_callback_2_9(void (*arg0)(struct net_device * ,
                                                               struct ethtool_drvinfo * ) ,
                                                  struct net_device *arg1 , struct ethtool_drvinfo *arg2 ) 
{ 


  {
  {
#line 277
  be_get_drvinfo(arg1, arg2);
  }
#line 278
  return;
}
}
#line 47 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/list.h"
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 76
  __list_add(new, head->prev, head);
  }
#line 77
  return;
}
}
#line 112
extern void list_del(struct list_head * ) ;
#line 138 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
#line 2663 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/include/linux/netdevice.h"
__inline static bool netif_oper_up(struct net_device  const  *dev ) 
{ 


  {
#line 2665
  return ((bool )((unsigned int )dev->operstate == 6U || (unsigned int )dev->operstate == 0U));
}
}
#line 68 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.h"
int be_roce_register_driver(struct ocrdma_driver *drv ) ;
#line 69
void be_roce_unregister_driver(struct ocrdma_driver *drv ) ;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static struct ocrdma_driver *ocrdma_drv  ;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static struct list_head be_adapter_list  =    {& be_adapter_list, & be_adapter_list};
#line 28 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static struct mutex be_adapter_list_lock  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "be_adapter_list_lock.wait_lock",
                                                           0, 0UL}}}}, {& be_adapter_list_lock.wait_list,
                                                                        & be_adapter_list_lock.wait_list},
    0, 0, (void *)(& be_adapter_list_lock), {0, {0, 0}, "be_adapter_list_lock", 0,
                                             0UL}};
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static void _be_roce_dev_add(struct be_adapter *adapter ) 
{ 
  struct be_dev_info dev_info ;
  int i ;
  int num_vec ;
  struct pci_dev *pdev ;
  int _min1 ;
  int _min2 ;

  {
#line 34
  pdev = adapter->pdev;
#line 36
  if ((unsigned long )ocrdma_drv == (unsigned long )((struct ocrdma_driver *)0)) {
#line 37
    return;
  } else {

  }
#line 38
  if ((unsigned int )pdev->device == 1824U) {
#line 40
    if ((unsigned int )adapter->num_msix_vec == 0U) {
#line 41
      return;
    } else {

    }
#line 43
    dev_info.dpp_unmapped_addr = pdev->resource[2].start;
#line 44
    dev_info.dpp_unmapped_len = pdev->resource[2].start != 0ULL || pdev->resource[2].end != pdev->resource[2].start ? ((u32 )pdev->resource[2].end - (u32 )pdev->resource[2].start) + 1U : 0U;
  } else {
#line 46
    dev_info.dpp_unmapped_addr = 0ULL;
#line 47
    dev_info.dpp_unmapped_len = 0U;
  }
  {
#line 49
  dev_info.pdev = adapter->pdev;
#line 50
  dev_info.db = adapter->db;
#line 51
  dev_info.unmapped_db = adapter->roce_db.io_addr;
#line 52
  dev_info.db_page_size = adapter->roce_db.size;
#line 53
  dev_info.db_total_size = adapter->roce_db.total_size;
#line 54
  dev_info.netdev = adapter->netdev;
#line 55
  memcpy((void *)(& dev_info.mac_addr), (void const   *)(adapter->netdev)->dev_addr,
         6UL);
#line 56
  dev_info.dev_family = adapter->sli_family;
  }
#line 57
  if ((unsigned int )adapter->num_msix_vec != 0U) {
#line 61
    num_vec = (int )((u32 )adapter->num_msix_vec + adapter->num_msix_roce_vec);
#line 62
    dev_info.intr_mode = 0;
#line 63
    _min1 = num_vec;
#line 63
    _min2 = 32;
#line 63
    dev_info.msix.num_vectors = _min1 < _min2 ? _min1 : _min2;
#line 68
    dev_info.msix.start_vector = (int )adapter->num_evt_qs;
#line 69
    i = 0;
#line 69
    goto ldv_53785;
    ldv_53784: 
#line 70
    dev_info.msix.vector_list[i] = adapter->msix_entries[i].vector;
#line 69
    i = i + 1;
    ldv_53785: ;
#line 69
    if (i < dev_info.msix.num_vectors) {
#line 71
      goto ldv_53784;
    } else {

    }

  } else {
#line 74
    dev_info.msix.num_vectors = 0;
#line 75
    dev_info.intr_mode = 1;
  }
  {
#line 77
  adapter->ocrdma_dev = (*(ocrdma_drv->add))(& dev_info);
  }
#line 78
  return;
}
}
#line 80 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_add(struct be_adapter *adapter ) 
{ 


  {
#line 82
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
    {
#line 83
    INIT_LIST_HEAD(& adapter->entry);
#line 84
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 85
    list_add_tail(& adapter->entry, & be_adapter_list);
#line 91
    _be_roce_dev_add(adapter);
#line 92
    mutex_unlock(& be_adapter_list_lock);
    }
  } else {

  }
#line 94
  return;
}
}
#line 96 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static void _be_roce_dev_remove(struct be_adapter *adapter ) 
{ 


  {
#line 98
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )ocrdma_drv->remove != (unsigned long )((void (*)(struct ocrdma_dev * ))0)) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) {
    {
#line 99
    (*(ocrdma_drv->remove))(adapter->ocrdma_dev);
    }
  } else {

  }
#line 100
  adapter->ocrdma_dev = (struct ocrdma_dev *)0;
#line 101
  return;
}
}
#line 103 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_remove(struct be_adapter *adapter ) 
{ 


  {
#line 105
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
    {
#line 106
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 107
    _be_roce_dev_remove(adapter);
#line 108
    list_del(& adapter->entry);
#line 109
    mutex_unlock(& be_adapter_list_lock);
    }
  } else {

  }
#line 111
  return;
}
}
#line 113 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static void _be_roce_dev_open(struct be_adapter *adapter ) 
{ 


  {
#line 115
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                       u32  ))0)) {
    {
#line 117
    (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 0U);
    }
  } else {

  }
#line 118
  return;
}
}
#line 120 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_open(struct be_adapter *adapter ) 
{ 


  {
#line 122
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
    {
#line 123
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 124
    _be_roce_dev_open(adapter);
#line 125
    mutex_unlock(& be_adapter_list_lock);
    }
  } else {

  }
#line 127
  return;
}
}
#line 129 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static void _be_roce_dev_close(struct be_adapter *adapter ) 
{ 


  {
#line 131
  if (((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0) && (unsigned long )adapter->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) && (unsigned long )ocrdma_drv->state_change_handler != (unsigned long )((void (*)(struct ocrdma_dev * ,
                                                                                                                                                                                                                                                       u32  ))0)) {
    {
#line 133
    (*(ocrdma_drv->state_change_handler))(adapter->ocrdma_dev, 1U);
    }
  } else {

  }
#line 134
  return;
}
}
#line 136 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_dev_close(struct be_adapter *adapter ) 
{ 


  {
#line 138
  if (((unsigned int )(adapter->pdev)->device == 1824U || (unsigned int )(adapter->pdev)->device == 1832U) && (adapter->function_mode & 4U) != 0U) {
    {
#line 139
    mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 140
    _be_roce_dev_close(adapter);
#line 141
    mutex_unlock(& be_adapter_list_lock);
    }
  } else {

  }
#line 143
  return;
}
}
#line 145 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
int be_roce_register_driver(struct ocrdma_driver *drv ) 
{ 
  struct be_adapter *dev ;
  struct list_head  const  *__mptr ;
  struct net_device *netdev ;
  bool tmp ;
  bool tmp___0 ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 149
  mutex_lock_nested(& be_adapter_list_lock, 0U);
  }
#line 150
  if ((unsigned long )ocrdma_drv != (unsigned long )((struct ocrdma_driver *)0)) {
    {
#line 151
    mutex_unlock(& be_adapter_list_lock);
    }
#line 152
    return (-22);
  } else {

  }
#line 154
  ocrdma_drv = drv;
#line 155
  __mptr = (struct list_head  const  *)be_adapter_list.next;
#line 155
  dev = (struct be_adapter *)__mptr + 0xffffffffffeb8340UL;
#line 155
  goto ldv_53818;
  ldv_53817: 
  {
#line 157
  _be_roce_dev_add(dev);
#line 158
  netdev = dev->netdev;
#line 159
  tmp = netif_running((struct net_device  const  *)netdev);
  }
#line 159
  if ((int )tmp) {
    {
#line 159
    tmp___0 = netif_oper_up((struct net_device  const  *)netdev);
    }
#line 159
    if ((int )tmp___0) {
      {
#line 160
      _be_roce_dev_open(dev);
      }
    } else {

    }
  } else {

  }
#line 155
  __mptr___0 = (struct list_head  const  *)dev->entry.next;
#line 155
  dev = (struct be_adapter *)__mptr___0 + 0xffffffffffeb8340UL;
  ldv_53818: ;
#line 155
  if ((unsigned long )(& dev->entry) != (unsigned long )(& be_adapter_list)) {
#line 157
    goto ldv_53817;
  } else {

  }
  {
#line 162
  mutex_unlock(& be_adapter_list_lock);
  }
#line 163
  return (0);
}
}
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static char const   __kstrtab_be_roce_register_driver[24U]  = 
#line 165
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'r',      'e',      'g',      'i', 
        's',      't',      'e',      'r', 
        '_',      'd',      'r',      'i', 
        'v',      'e',      'r',      '\000'};
#line 165
struct kernel_symbol  const  __ksymtab_be_roce_register_driver ;
#line 165 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
struct kernel_symbol  const  __ksymtab_be_roce_register_driver  =    {(unsigned long )(& be_roce_register_driver), (char const   *)(& __kstrtab_be_roce_register_driver)};
#line 167 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
void be_roce_unregister_driver(struct ocrdma_driver *drv ) 
{ 
  struct be_adapter *dev ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  {
#line 171
  mutex_lock_nested(& be_adapter_list_lock, 0U);
#line 172
  __mptr = (struct list_head  const  *)be_adapter_list.next;
#line 172
  dev = (struct be_adapter *)__mptr + 0xffffffffffeb8340UL;
  }
#line 172
  goto ldv_53836;
  ldv_53835: ;
#line 173
  if ((unsigned long )dev->ocrdma_dev != (unsigned long )((struct ocrdma_dev *)0)) {
    {
#line 174
    _be_roce_dev_remove(dev);
    }
  } else {

  }
#line 172
  __mptr___0 = (struct list_head  const  *)dev->entry.next;
#line 172
  dev = (struct be_adapter *)__mptr___0 + 0xffffffffffeb8340UL;
  ldv_53836: ;
#line 172
  if ((unsigned long )(& dev->entry) != (unsigned long )(& be_adapter_list)) {
#line 174
    goto ldv_53835;
  } else {

  }
  {
#line 176
  ocrdma_drv = (struct ocrdma_driver *)0;
#line 177
  mutex_unlock(& be_adapter_list_lock);
  }
#line 178
  return;
}
}
#line 179 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
static char const   __kstrtab_be_roce_unregister_driver[26U]  = 
#line 179
  {      'b',      'e',      '_',      'r', 
        'o',      'c',      'e',      '_', 
        'u',      'n',      'r',      'e', 
        'g',      'i',      's',      't', 
        'e',      'r',      '_',      'd', 
        'r',      'i',      'v',      'e', 
        'r',      '\000'};
#line 179
struct kernel_symbol  const  __ksymtab_be_roce_unregister_driver ;
#line 179 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/lkbce/drivers/net/ethernet/emulex/benet/be_roce.c"
struct kernel_symbol  const  __ksymtab_be_roce_unregister_driver  =    {(unsigned long )(& be_roce_unregister_driver), (char const   *)(& __kstrtab_be_roce_unregister_driver)};
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
void ldv_atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 23
  v->counter = v->counter + i;
#line 24
  return;
}
}
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
void ldv_atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 29
  v->counter = v->counter - i;
#line 30
  return;
}
}
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
int ldv_atomic_sub_and_test(int i , atomic_t *v ) 
{ 


  {
#line 35
  v->counter = v->counter - i;
#line 36
  if (v->counter != 0) {
#line 37
    return (0);
  } else {

  }
#line 39
  return (1);
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
void ldv_atomic_inc(atomic_t *v ) 
{ 


  {
#line 45
  v->counter = v->counter + 1;
#line 46
  return;
}
}
#line 49 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
void ldv_atomic_dec(atomic_t *v ) 
{ 


  {
#line 51
  v->counter = v->counter - 1;
#line 52
  return;
}
}
#line 55 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
int ldv_atomic_dec_and_test(atomic_t *v ) 
{ 


  {
#line 57
  v->counter = v->counter - 1;
#line 58
  if (v->counter != 0) {
#line 59
    return (0);
  } else {

  }
#line 61
  return (1);
}
}
#line 65 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
int ldv_atomic_inc_and_test(atomic_t *v ) 
{ 


  {
#line 67
  v->counter = v->counter + 1;
#line 68
  if (v->counter != 0) {
#line 69
    return (0);
  } else {

  }
#line 71
  return (1);
}
}
#line 75 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
int ldv_atomic_add_return(int i , atomic_t *v ) 
{ 


  {
#line 77
  v->counter = v->counter + i;
#line 78
  return (v->counter);
}
}
#line 82 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
int ldv_atomic_add_negative(int i , atomic_t *v ) 
{ 


  {
#line 84
  v->counter = v->counter + i;
#line 85
  return (v->counter < 0);
}
}
#line 89 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/arch/atomic.c"
int ldv_atomic_inc_short(short *v ) 
{ 


  {
#line 91
  *v = (short )((unsigned int )((unsigned short )*v) + 1U);
#line 92
  return ((int )*v);
}
}
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 26 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 28
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 29
    return ((dev->p)->driver_data);
  } else {

  }
#line 30
  return ((void *)0);
}
}
#line 39 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 41
  tmp = ldv_xzalloc(8UL);
#line 41
  dev->p = (struct device_private *)tmp;
#line 42
  (dev->p)->driver_data = data;
  }
#line 43
  return (0);
}
}
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 2200UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)master + 1U);
  }
#line 34
  return (master);
}
}
#line 20 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 23
  ldv_assume(val <= 0);
  }
#line 24
  return (val);
}
}
#line 31 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 45
  return (tmp);
}
}
#line 21 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/mm/kzalloc.c"
extern void ldv_check_alloc_flags(gfp_t  ) ;
#line 22
extern void ldv_after_alloc(void * ) ;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/mm/kzalloc.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 28
  ldv_check_alloc_flags(flags);
#line 29
  res = ldv_zalloc(size);
#line 30
  ldv_after_alloc(res);
  }
#line 32
  return (res);
}
}
#line 1 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/avtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/rsg/models/dev.bk.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_usb_dev__probe_failed(int expr ) ;
#line 4
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) ;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/usb/dev.c"
ldv_map LDV_USB_DEV_REF_COUNTS  ;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/usb/dev.c"
struct usb_device *ldv_usb_get_dev(struct usb_device *dev ) 
{ 


  {
#line 30
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
#line 32
    LDV_USB_DEV_REF_COUNTS = LDV_USB_DEV_REF_COUNTS != 0 ? LDV_USB_DEV_REF_COUNTS + 1 : 1;
  } else {

  }
#line 39
  return (dev);
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/usb/dev.c"
void ldv_usb_put_dev(struct usb_device *dev ) 
{ 


  {
#line 46
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
    {
#line 48
    ldv_assert_linux_usb_dev__unincremented_counter_decrement(LDV_USB_DEV_REF_COUNTS != 0);
#line 50
    ldv_assert_linux_usb_dev__less_initial_decrement(LDV_USB_DEV_REF_COUNTS > 0);
    }
#line 54
    if (LDV_USB_DEV_REF_COUNTS > 1) {
#line 54
      LDV_USB_DEV_REF_COUNTS = LDV_USB_DEV_REF_COUNTS + -1;
    } else {
#line 54
      LDV_USB_DEV_REF_COUNTS = 0;
    }
  } else {

  }
#line 56
  return;
}
}
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/usb/dev.c"
void ldv_check_return_value_probe(int retval ) 
{ 


  {
#line 62
  if (retval != 0) {
    {
#line 64
    ldv_assert_linux_usb_dev__probe_failed(LDV_USB_DEV_REF_COUNTS == 0);
    }
  } else {

  }
#line 65
  return;
}
}
#line 69 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/usb/dev.c"
void ldv_initialize(void) 
{ 


  {
#line 72
  LDV_USB_DEV_REF_COUNTS = 0;
#line 73
  return;
}
}
#line 76 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/linux/usb/dev.c"
void ldv_check_final_state(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_dev__more_initial_at_exit(LDV_USB_DEV_REF_COUNTS == 0);
  }
#line 80
  return;
}
}
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/common.h"
extern void ldv_assert(char const   * , int  ) ;
#line 45
void __builtin_trap(void) ;
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/common.c"
void ldv_assume(int expression ) 
{ 


  {
#line 25
  if (expression == 0) {
    ldv_assume_label: ;
#line 29
    goto ldv_assume_label;
  } else {

  }
#line 31
  return;
}
}
#line 33 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/common.c"
void ldv_stop(void) 
{ 


  {
  ldv_stop_label: ;
#line 36
  goto ldv_stop_label;
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/common.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 45
  return (exp);
}
}
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/common.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 56
  ldv_assert("", 0);
  }
#line 57
  return;
}
}
#line 29 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 30
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 39
void *ldv_malloc_unknown_size(void) ;
#line 40
void *ldv_calloc_unknown_size(void) ;
#line 41
void *ldv_zalloc_unknown_size(void) ;
#line 47
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 25 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 26
extern void *calloc(size_t  , size_t  ) ;
#line 27
extern void free(void * ) ;
#line 30 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp___1 = ldv_undef_int();
  }
#line 32
  if (tmp___1 != 0) {
    {
#line 33
    tmp = malloc(size);
#line 33
    res = tmp;
#line 34
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    ldv_assume(tmp___0 == 0L);
    }
#line 36
    return (res);
  } else {
#line 39
    return ((void *)0);
  }
}
}
#line 43 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 48
    tmp___0 = ldv_is_err((void const   *)res);
#line 48
    ldv_assume(tmp___0 == 0L);
    }
#line 49
    return (res);
  } else {
#line 52
    return ((void *)0);
  }
}
}
#line 56 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = ldv_calloc(1UL, size);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 63
  free(s);
  }
#line 64
  return;
}
}
#line 66 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 68
  tmp = malloc(size);
#line 68
  res = tmp;
#line 69
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
#line 70
  ldv_assume(tmp___0 == 0L);
  }
#line 71
  return (res);
}
}
#line 74 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 76
  tmp = calloc(1UL, size);
#line 76
  res = tmp;
#line 77
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 78
  tmp___0 = ldv_is_err((void const   *)res);
#line 78
  ldv_assume(tmp___0 == 0L);
  }
#line 79
  return (res);
}
}
#line 82 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = ldv_undef_int();
  }
#line 84
  if (tmp___1 != 0) {
    {
#line 85
    tmp = external_allocated_data();
#line 85
    res = tmp;
#line 86
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 87
    tmp___0 = ldv_is_err((void const   *)res);
#line 87
    ldv_assume(tmp___0 == 0L);
    }
#line 88
    return (res);
  } else {
#line 91
    return ((void *)0);
  }
}
}
#line 95 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 97
  tmp___1 = ldv_undef_int();
  }
#line 97
  if (tmp___1 != 0) {
    {
#line 98
    tmp = external_allocated_data();
#line 98
    res = tmp;
#line 99
    memset(res, 0, 8UL);
#line 100
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 101
    tmp___0 = ldv_is_err((void const   *)res);
#line 101
    ldv_assume(tmp___0 == 0L);
    }
#line 102
    return (res);
  } else {
#line 105
    return ((void *)0);
  }
}
}
#line 109 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 111
  tmp = ldv_calloc_unknown_size();
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 116
  tmp = external_allocated_data();
#line 116
  res = tmp;
#line 117
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 118
  tmp___0 = ldv_is_err((void const   *)res);
#line 118
  ldv_assume(tmp___0 == 0L);
  }
#line 119
  return (res);
}
}
#line 23 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.h"
void *ldv_undef_ptr(void) ;
#line 24
unsigned long ldv_undef_ulong(void) ;
#line 27
int ldv_undef_int_negative(void) ;
#line 30
int ldv_undef_int_nonpositive(void) ;
#line 24 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern void *__VERIFIER_nondet_pointer(void) ;
#line 40 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = __VERIFIER_nondet_int();
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = __VERIFIER_nondet_pointer();
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 49
  tmp = __VERIFIER_nondet_ulong();
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 54
  tmp = ldv_undef_int();
#line 54
  ret = tmp;
#line 55
  ldv_assume(ret < 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 61
  tmp = ldv_undef_int();
#line 61
  ret = tmp;
#line 62
  ldv_assume(ret <= 0);
  }
#line 63
  return (ret);
}
}
#line 32 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/thread.h"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) ;
#line 35
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) ;
#line 38
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) ;
#line 41
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) ;
#line 27 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/thread.c"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) 
{ 


  {
#line 29
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
    {
#line 30
    (*function)(data);
    }
  } else {

  }
#line 31
  return (0);
}
}
#line 35 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/thread.c"
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) 
{ 
  int i ;

  {
#line 39
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
#line 40
    i = 0;
#line 40
    goto ldv_1179;
    ldv_1178: 
    {
#line 41
    (*function)(data);
#line 40
    i = i + 1;
    }
    ldv_1179: ;
#line 40
    if (i < ldv_thread_set->number) {
#line 42
      goto ldv_1178;
    } else {

    }

  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/thread.c"
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/job/root/verifier/thread.c"
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) 
{ 


  {
#line 56
  return (0);
}
}
#line 2 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/vtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/sbt/bug kind funcs.c"
extern void __VERIFIER_error(void) ;
#line 3 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/vtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/sbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error();
    }
  } else {

  }
#line 6
  return;
}
}
#line 7 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/vtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/sbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) 
{ 


  {
#line 8
  if (! expr) {
    {
#line 9
    __VERIFIER_error();
    }
  } else {

  }
#line 10
  return;
}
}
#line 11 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/vtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/sbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__probe_failed(int expr ) 
{ 


  {
#line 12
  if (! expr) {
    {
#line 13
    __VERIFIER_error();
    }
  } else {

  }
#line 14
  return;
}
}
#line 15 "/home/debian/klever-work/native-scheduler-work-dir/scheduler/jobs/dfbfd2da522a1f5f4786ee57b863db44/klever-core-work-dir/a068ef8/linux-usb-dev/vtg/drivers/net/ethernet/emulex/benet/be2net.ko/linux:usb:dev/sbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) 
{ 


  {
#line 16
  if (! expr) {
    {
#line 17
    __VERIFIER_error();
    }
  } else {

  }
#line 18
  return;
}
}
