extern void __VERIFIER_error() __attribute__ ((__noreturn__));

/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

struct hotplug_slot;
struct hotplug_slot;
struct bus_info {

};
struct slot {
   int a ;
   int b ;
   struct hotplug_slot *hotplug_slot ;
   struct bus_info *bus_on ;
};
struct hotplug_slot {
   struct slot *private ;
   int b ;
};
void __blast_assert(void) 
{ 

  {
  ERROR: __VERIFIER_error();
}
}
struct slot *tmp_slot  ;
int used_tmp_slot  =    0;
int freed_tmp_slot  =    1;
extern void *kzalloc(int  , int  ) ;
void kfree(void *p ) 
{ void *__cil_tmp2 ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;

  {
  {
  __cil_tmp2 = (void *)0;
  __cil_tmp3 = (unsigned int )__cil_tmp2;
  __cil_tmp4 = (unsigned int )p;
  if (__cil_tmp4 != __cil_tmp3) {
    {
    __cil_tmp5 = (unsigned int )tmp_slot;
    __cil_tmp6 = (unsigned int )p;
    if (__cil_tmp6 == __cil_tmp5) {
      freed_tmp_slot = 1;
    } else {

    }
    }
  } else {

  }
  }
  return;
}
}
extern void *__VERIFIER_nondet_pointer(void) ;
static struct bus_info *ibmphp_find_same_bus_num(void) 
{ void *tmp ;

  {
  {
  tmp = __VERIFIER_nondet_pointer();
  }
  return ((struct bus_info *)tmp);
}
}
extern int __VERIFIER_nondet_int(void) ;
static int fillslotinfo(struct hotplug_slot *ptr ) 
{ int tmp ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  }
  return (tmp);
}
}
static int ibmphp_init_devno(struct slot **ptr ) 
{ int tmp ;

  {
  {
  tmp = __VERIFIER_nondet_int();
  }
  return (tmp);
}
}
int ebda_rsrc_controller(void) 
{ struct hotplug_slot *hp_slot_ptr ;
  struct bus_info *bus_info_ptr1 ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  struct slot **__cil_tmp8 ;
  struct slot *__cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
  __cil_tmp6 = (int )8U;
  tmp = kzalloc(__cil_tmp6, 1);
  hp_slot_ptr = (struct hotplug_slot *)tmp;
  }
  if (! hp_slot_ptr) {
    rc = -2;
    goto error_no_slot;
  } else {

  }
  {
  hp_slot_ptr->b = 5;
  __cil_tmp7 = (int )16U;
  tmp___0 = kzalloc(__cil_tmp7, 1);
  tmp_slot = (struct slot *)tmp___0;
  }
  if (! tmp_slot) {
    rc = -2;
    goto error_no_slot;
  } else {

  }
  {
  used_tmp_slot = 0;
  freed_tmp_slot = 0;
  tmp_slot->a = 2;
  tmp_slot->b = 3;
  bus_info_ptr1 = ibmphp_find_same_bus_num();
  }
  if (! bus_info_ptr1) {
    rc = -3;
    goto error;
  } else {

  }
  {
  tmp_slot->bus_on = bus_info_ptr1;
  bus_info_ptr1 = (struct bus_info *)0;
  tmp_slot->hotplug_slot = hp_slot_ptr;
  hp_slot_ptr->private = tmp_slot;
  used_tmp_slot = 1;
  rc = fillslotinfo(hp_slot_ptr);
  }
  if (rc) {
    goto error;
  } else {

  }
  {
  __cil_tmp8 = & hp_slot_ptr->private;
  rc = ibmphp_init_devno(__cil_tmp8);
  }
  if (rc) {
    goto error;
  } else {

  }
  return (0);
  error: 
  {
  __cil_tmp9 = hp_slot_ptr->private;
  __cil_tmp10 = (void *)__cil_tmp9;
  kfree(__cil_tmp10);
  }
  error_no_slot: 
  return (rc);
}
}
int main(void) 
{ 

  {
  {
  ebda_rsrc_controller();
  }
  if (! used_tmp_slot) {
    if (freed_tmp_slot) {

    } else {
      {
      __blast_assert();
      }
    }
  } else {

  }
  return 0;
}
}
