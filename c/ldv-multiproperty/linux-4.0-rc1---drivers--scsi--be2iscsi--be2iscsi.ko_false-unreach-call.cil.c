/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u16 __be16;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u32 __be32;
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u32 __wsum;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int uint;
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long ulong;
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u8 uint8_t;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u16 uint16_t;
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u64 uint64_t;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 phys_addr_t;
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 186
struct hlist_node;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
struct class;
#line 199
struct device;
#line 245
struct completion;
#line 277
struct gendisk;
#line 338
struct module;
#line 346
struct mutex;
#line 389
struct request_queue;
#line 400
struct request;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 15
struct task_struct;
#line 16
struct lockdep_map;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_11 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_9 {
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
   struct __anonstruct____missing_field_name_11 __annonCompField6 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_9 __annonCompField7 ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_12 {
   pteval_t pte ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_12 pte_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_13 pgd_t;
#line 361
struct page;
#line 361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 369
struct file;
#line 382
struct seq_file;
#line 420
struct thread_struct;
#line 422
struct mm_struct;
#line 423
struct cpumask;
#line 424 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dynamic_debug.h"
struct net_device;
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
struct file_operations;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_16 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_16 __annonCompField8 ;
};
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_21 {
   u64 rip ;
   u64 rdp ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_22 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_20 {
   struct __anonstruct____missing_field_name_21 __annonCompField12 ;
   struct __anonstruct____missing_field_name_22 __annonCompField13 ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_23 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_20 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_23 __annonCompField15 ;
};
#line 345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndreg {
   u64 lower_bound ;
   u64 upper_bound ;
};
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndcsr {
   u64 bndcfgu ;
   u64 bndstatus ;
};
#line 386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndreg bndreg[4U] ;
   struct bndcsr bndcsr ;
};
#line 401 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_27 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_26 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_27 __annonCompField17 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_26 __annonCompField18 ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_28 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_28 rwlock_t;
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 623 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 193
struct timespec;
#line 194
struct compat_timespec;
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_futex_33 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_nanosleep_34 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 195
struct pollfd;
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_poll_35 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
union __anonunion____missing_field_name_32 {
   struct __anonstruct_futex_33 futex ;
   struct __anonstruct_nanosleep_34 nanosleep ;
   struct __anonstruct_poll_35 poll ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_32 __annonCompField19 ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jump_label.h"
struct jump_entry;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_48 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_48 seqlock_t;
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct notifier_block;
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
union __anonunion____missing_field_name_49 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_49 __annonCompField20 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct dentry;
#line 88
struct iattr;
#line 89
struct vm_area_struct;
#line 90
struct super_block;
#line 91
struct file_system_type;
#line 92
struct kernfs_open_node;
#line 93
struct kernfs_iattrs;
#line 115
struct kernfs_root;
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 88
struct kernfs_ops;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
union __anonunion____missing_field_name_50 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_50 __annonCompField21 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170
struct vm_operations_struct;
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 469
struct sock;
#line 470
struct kobject;
#line 471
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 135 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/highuid.h"
struct user_namespace;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kuid_t_51 {
   uid_t val ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_51 kuid_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kgid_t_52 {
   gid_t val ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_52 kgid_t;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct bin_attribute;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct tvec_base;
#line 268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct execute_work {
   struct work_struct work ;
};
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct klist_node;
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_53 {
   unsigned long bits[16U] ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_53 nodemask_t;
#line 520
struct path;
#line 521
struct inode;
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 186
struct pinctrl;
#line 187
struct pinctrl_state;
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 540
struct dev_pm_qos;
#line 540 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
};
#line 789 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore;
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
struct blocking_notifier_head {
   struct rw_semaphore rwsem ;
   struct notifier_block *head ;
};
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct ctl_table;
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_118 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_118 mm_context_t;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/xen/features.h"
struct bio_vec;
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io_apic.h"
struct device_node;
#line 1269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct llist_node;
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   u16 flags ;
};
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct dma_map_ops;
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct iommu_ops;
#line 20
struct iommu_group;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 322
struct class_attribute;
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 483 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 652
struct acpi_device;
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 659
struct dma_coherent_mem;
#line 659
struct cma;
#line 659 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 806 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 221 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
struct plist_head {
   struct list_head node_list ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_151 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_152 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_150 {
   struct __anonstruct____missing_field_name_151 __annonCompField34 ;
   struct __anonstruct____missing_field_name_152 __annonCompField35 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct xol_area;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_159 __annonCompField39 ;
   int units ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   union __anonunion____missing_field_name_158 __annonCompField40 ;
   atomic_t _count ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_156 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_157 __annonCompField41 ;
   unsigned int active ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField38 ;
   union __anonunion____missing_field_name_156 __annonCompField42 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_161 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_162 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_161 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_162 __annonCompField45 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_163 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_153 __annonCompField37 ;
   struct __anonstruct____missing_field_name_154 __annonCompField43 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   union __anonunion____missing_field_name_163 __annonCompField47 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct_shared_164 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 248
struct anon_vma;
#line 248
struct mempolicy;
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_164 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 335 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 348
struct kioctx_table;
#line 349
struct linux_binfmt;
#line 349
struct mmu_notifier_mm;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/shm.h"
struct user_struct;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_166 {
   unsigned long sig[1U] ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_166 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_169 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_170 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_171 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_173 {
   void *_lower ;
   void *_upper ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_172 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_173 _addr_bnd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_174 {
   long _band ;
   int _fd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_175 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_167 {
   int _pad[28U] ;
   struct __anonstruct__kill_168 _kill ;
   struct __anonstruct__timer_169 _timer ;
   struct __anonstruct__rt_170 _rt ;
   struct __anonstruct__sigchld_171 _sigchld ;
   struct __anonstruct__sigfault_172 _sigfault ;
   struct __anonstruct__sigpoll_174 _sigpoll ;
   struct __anonstruct__sigsys_175 _sigsys ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_167 _sifields ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int in_hrtirq ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 838
struct ctl_table_root;
#line 839
struct ctl_table_header;
#line 840
struct ctl_dir;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
#line 96 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
#line 117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct __anonstruct____missing_field_name_179 {
   struct ctl_table *ctl_table ;
   int used ;
   int count ;
   int nreg ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
union __anonunion____missing_field_name_178 {
   struct __anonstruct____missing_field_name_179 __annonCompField48 ;
   struct callback_head rcu ;
};
#line 122
struct ctl_table_set;
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct ctl_table_header {
   union __anonunion____missing_field_name_178 __annonCompField49 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
#line 149 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
#line 191
struct assoc_array_ptr;
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_180 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_181 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct __anonstruct____missing_field_name_183 {
   struct key_type *type ;
   char *description ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_182 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_183 __annonCompField52 ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_type_data_184 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_payload_186 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_185 {
   union __anonunion_payload_186 payload ;
   struct assoc_array keys ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_180 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_181 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_182 __annonCompField53 ;
   union __anonunion_type_data_184 type_data ;
   union __anonunion____missing_field_name_185 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct futex_pi_state;
#line 128
struct robust_list_head;
#line 129
struct bio_list;
#line 130
struct fs_struct;
#line 131
struct perf_event_context;
#line 132
struct blk_plug;
#line 182
struct cfs_rq;
#line 183
struct task_group;
#line 471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 518 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 525 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 599
struct autogroup;
#line 600
struct tty_struct;
#line 600
struct taskstats;
#line 600
struct tty_audit_buf;
#line 600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 781 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 824
struct backing_dev_info;
#line 825
struct reclaim_state;
#line 826 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1073
struct io_context;
#line 1107
struct pipe_inode_info;
#line 1108
struct uts_namespace;
#line 1109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1195
struct rt_rq;
#line 1195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1702
struct sched_class;
#line 1702
struct files_struct;
#line 1702
struct css_set;
#line 1702
struct compat_robust_list_head;
#line 1702
struct numa_group;
#line 1702
struct ftrace_ret_stack;
#line 1702 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
};
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef int pci_power_t;
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
union __anonunion____missing_field_name_191 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_191 __annonCompField58 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 438
struct pci_ops;
#line 438
struct msi_controller;
#line 438 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 558 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 580 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 604 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 637 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/scatterlist.h"
struct dma_pool;
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dmapool.h"
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 1281
struct kvec;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct hlist_bl_node;
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_193 {
   spinlock_t lock ;
   int count ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
union __anonunion____missing_field_name_192 {
   struct __anonstruct____missing_field_name_193 __annonCompField59 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_192 __annonCompField60 ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct vfsmount;
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct __anonstruct____missing_field_name_195 {
   u32 hash ;
   u32 len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
union __anonunion____missing_field_name_194 {
   struct __anonstruct____missing_field_name_195 __annonCompField61 ;
   u64 hash_len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_194 __annonCompField62 ;
   unsigned char const   *name ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
union __anonunion_d_u_196 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_196 d_u ;
};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 555 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_198 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
union __anonunion____missing_field_name_197 {
   struct __anonstruct____missing_field_name_198 __annonCompField63 ;
   struct callback_head callback_head ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_197 __annonCompField64 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-rwsem.h"
struct bio_set;
#line 28
struct bio;
#line 29
struct bio_integrity_payload;
#line 30
struct block_device;
#line 31
struct cgroup_subsys_state;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
union __anonunion____missing_field_name_199 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_199 __annonCompField65 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct hd_geometry;
#line 62
struct iovec;
#line 63
struct nameidata;
#line 64
struct kiocb;
#line 65
struct poll_table_struct;
#line 66
struct kstatfs;
#line 67
struct swap_info_struct;
#line 68
struct iov_iter;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
struct __anonstruct_kprojid_t_200 {
   projid_t val ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_200 kprojid_t;
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 164
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
union __anonunion____missing_field_name_201 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_201 __annonCompField66 ;
   enum quota_type type ;
};
#line 183 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 205
struct quota_format_type;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 384 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 414
struct hd_struct;
#line 414 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 531
struct posix_acl;
#line 532
struct inode_operations;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_204 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_205 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 532
struct file_lock_context;
#line 532
struct cdev;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_206 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_204 __annonCompField67 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_205 __annonCompField68 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_206 __annonCompField69 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 776 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion_f_u_207 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_207 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
typedef void *fl_owner_t;
#line 884
struct file_lock;
#line 885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 891 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_get_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_put_owner)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 907
struct net;
#line 912
struct nlm_lockowner;
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_209 {
   struct list_head link ;
   int state ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_208 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_209 afs ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_208 fl_u ;
};
#line 965 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1021 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1223
struct super_operations;
#line 1223
struct xattr_handler;
#line 1223
struct mtd_info;
#line 1223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1475
struct dir_context;
#line 1500 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1506
struct block_device_operations;
#line 1507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   void (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
   int (*dentry_open)(struct dentry * , struct file * , struct cred  const  * ) ;
};
#line 1624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1856 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned char for_kupdate : 1 ;
   unsigned char for_background : 1 ;
   unsigned char tagged_writepages : 1 ;
   unsigned char for_reclaim : 1 ;
   unsigned char range_cyclic : 1 ;
   unsigned char for_sync : 1 ;
};
#line 88
struct bdi_writeback;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long last_old_flush ;
   struct delayed_work dwork ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
};
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[4U] ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
union __anonunion____missing_field_name_214 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
union __anonunion____missing_field_name_215 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_214 __annonCompField73 ;
   union __anonunion____missing_field_name_215 __annonCompField74 ;
   unsigned int flags ;
};
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 312 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 525 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 646 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bsg.h"
struct percpu_ref;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 328
struct elevator_queue;
#line 330
struct blk_trace;
#line 332
struct bsg_job;
#line 333
struct blkcg_gq;
#line 334
struct blk_flush_queue;
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 71
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_SPECIAL = 7,
    REQ_TYPE_ATA_TASKFILE = 8,
    REQ_TYPE_ATA_PC = 9
} ;
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_216 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};
#line 83
struct blk_mq_ctx;
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_217 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_218 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct __anonstruct_elv_220 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct __anonstruct_flush_221 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_219 {
   struct __anonstruct_elv_220 elv ;
   struct __anonstruct_flush_221 flush ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_216 __annonCompField75 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_217 __annonCompField76 ;
   union __anonunion____missing_field_name_218 __annonCompField77 ;
   union __anonunion____missing_field_name_219 __annonCompField78 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hashtable.h"
struct elevator_type;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 237 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 252 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 254
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 311
struct blk_mq_ops;
#line 311
struct blk_mq_hw_ctx;
#line 311
struct throtl_data;
#line 311
struct blk_mq_tag_set;
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   int mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
#line 1069 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1447 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const   *disk_name ;
};
#line 1476 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter * );
#line 1477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 1627
struct blk_mq_tags;
#line 1628 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
struct blk_align_bitmap;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
struct blk_mq_ctxmap {
   unsigned int map_size ;
   unsigned int bits_per_word ;
   struct blk_align_bitmap *map ;
};
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
struct __anonstruct____missing_field_name_223 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_223 __annonCompField79 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
   int next_cpu_batch ;
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
   unsigned long run ;
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
   unsigned int cmd_size ;
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-mq.h"
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
#line 240
struct scsi_cmnd;
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi.h"
struct scsi_lun {
   __u8 scsi_lun[8U] ;
};
#line 593
struct scsi_device;
#line 594
struct scsi_host_cmd_pool;
#line 595
struct scsi_target;
#line 596
struct Scsi_Host;
#line 597
struct scsi_transport_template;
#line 599 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi.h"
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*show_info)(struct seq_file * , struct Scsi_Host * ) ;
   int (*write_info)(struct Scsi_Host * , char * , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   short cmd_per_lun ;
   unsigned char present ;
   int tag_alloc_policy ;
   unsigned char use_blk_tags : 1 ;
   unsigned char track_queue_depth : 1 ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char no_async_abort : 1 ;
   unsigned int max_host_blocked ;
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
   unsigned int cmd_size ;
   struct scsi_host_cmd_pool *cmd_pool ;
   bool disable_blk_mq ;
};
#line 507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_host.h"
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
#line 517 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_host.h"
union __anonunion____missing_field_name_224 {
   struct blk_queue_tag *bqt ;
   struct blk_mq_tag_set tag_set ;
};
#line 517 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_host.h"
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   union __anonunion____missing_field_name_224 __annonCompField80 ;
   atomic_t host_busy ;
   atomic_t host_blocked ;
   unsigned int host_failed ;
   unsigned int host_eh_scheduled ;
   unsigned int host_no ;
   int eh_deadline ;
   unsigned long last_reset ;
   unsigned int max_channel ;
   unsigned int max_id ;
   u64 max_lun ;
   unsigned int unique_id ;
   unsigned short max_cmd_len ;
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   unsigned int nr_hw_queues ;
   unsigned long cmd_serial_number ;
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_blk_mq : 1 ;
   unsigned char use_cmd_list : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   struct workqueue_struct *tmf_work_q ;
   unsigned char no_scsi2_lun_in_cdb : 1 ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
   unsigned char prot_guard_type ;
   struct request_queue *uspace_req_q ;
   unsigned long base ;
   unsigned long io_port ;
   unsigned char n_io_port ;
   unsigned char dma_channel ;
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
#line 935 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_host.h"
struct __kfifo {
   unsigned int in ;
   unsigned int out ;
   unsigned int mask ;
   unsigned int esize ;
   void *data ;
};
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kfifo.h"
union __anonunion____missing_field_name_227 {
   struct __kfifo kfifo ;
   unsigned char *type ;
   unsigned char const   *const_type ;
   char (*rectype)[0U] ;
   void *ptr ;
   void const   *ptr_const ;
};
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kfifo.h"
struct kfifo {
   union __anonunion____missing_field_name_227 __annonCompField81 ;
   unsigned char buf[0U] ;
};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_proto.h"
typedef uint32_t itt_t;
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_proto.h"
struct iscsi_hdr {
   uint8_t opcode ;
   uint8_t flags ;
   uint8_t rsvd2[2U] ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   struct scsi_lun lun ;
   itt_t itt ;
   __be32 ttt ;
   __be32 statsn ;
   __be32 exp_statsn ;
   __be32 max_statsn ;
   uint8_t other[12U] ;
};
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_proto.h"
struct iscsi_scsi_req {
   uint8_t opcode ;
   uint8_t flags ;
   __be16 rsvd2 ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   struct scsi_lun lun ;
   itt_t itt ;
   __be32 data_length ;
   __be32 cmdsn ;
   __be32 exp_statsn ;
   uint8_t cdb[16U] ;
};
#line 282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_proto.h"
struct iscsi_tm {
   uint8_t opcode ;
   uint8_t flags ;
   uint8_t rsvd1[2U] ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   struct scsi_lun lun ;
   itt_t itt ;
   itt_t rtt ;
   __be32 cmdsn ;
   __be32 exp_statsn ;
   __be32 refcmdsn ;
   __be32 exp_datasn ;
   uint8_t rsvd2[8U] ;
};
#line 627 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_proto.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/uio.h"
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uio.h"
union __anonunion____missing_field_name_230 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uio.h"
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_230 __annonCompField84 ;
   unsigned long nr_segs ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/socket.h"
typedef __kernel_sa_family_t sa_family_t;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
#line 360 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/socket.h"
struct in_addr {
   __be32 s_addr ;
};
#line 104 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/in.h"
union __anonunion_in6_u_231 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
#line 104 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/in.h"
struct in6_addr {
   union __anonunion_in6_u_231 in6_u ;
};
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/in6.h"
enum iscsi_tgt_dscvr {
    ISCSI_TGT_DSCVR_SEND_TARGETS = 1,
    ISCSI_TGT_DSCVR_ISNS = 2,
    ISCSI_TGT_DSCVR_SLP = 3
} ;
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
enum iscsi_param_type {
    ISCSI_PARAM = 0,
    ISCSI_HOST_PARAM = 1,
    ISCSI_NET_PARAM = 2,
    ISCSI_FLASHNODE_PARAM = 3,
    ISCSI_CHAP_PARAM = 4,
    ISCSI_IFACE_PARAM = 5
} ;
#line 327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
struct iscsi_iface_param_info {
   uint32_t iface_num ;
   uint32_t len ;
   uint16_t param ;
   uint8_t iface_type ;
   uint8_t param_type ;
   uint8_t value[0U] ;
};
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
union __anonunion_src_234 {
   struct in_addr v4_addr ;
   struct in6_addr v6_addr ;
};
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
union __anonunion_dst_235 {
   struct in_addr v4_addr ;
   struct in6_addr v6_addr ;
};
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
struct iscsi_path {
   uint64_t handle ;
   uint8_t mac_addr[6U] ;
   uint8_t mac_addr_old[6U] ;
   uint32_t ip_addr_len ;
   union __anonunion_src_234 src ;
   union __anonunion_dst_235 dst ;
   uint16_t vlan_id ;
   uint16_t pmtu ;
};
#line 491
enum iscsi_param {
    ISCSI_PARAM_MAX_RECV_DLENGTH = 0,
    ISCSI_PARAM_MAX_XMIT_DLENGTH = 1,
    ISCSI_PARAM_HDRDGST_EN = 2,
    ISCSI_PARAM_DATADGST_EN = 3,
    ISCSI_PARAM_INITIAL_R2T_EN = 4,
    ISCSI_PARAM_MAX_R2T = 5,
    ISCSI_PARAM_IMM_DATA_EN = 6,
    ISCSI_PARAM_FIRST_BURST = 7,
    ISCSI_PARAM_MAX_BURST = 8,
    ISCSI_PARAM_PDU_INORDER_EN = 9,
    ISCSI_PARAM_DATASEQ_INORDER_EN = 10,
    ISCSI_PARAM_ERL = 11,
    ISCSI_PARAM_IFMARKER_EN = 12,
    ISCSI_PARAM_OFMARKER_EN = 13,
    ISCSI_PARAM_EXP_STATSN = 14,
    ISCSI_PARAM_TARGET_NAME = 15,
    ISCSI_PARAM_TPGT = 16,
    ISCSI_PARAM_PERSISTENT_ADDRESS = 17,
    ISCSI_PARAM_PERSISTENT_PORT = 18,
    ISCSI_PARAM_SESS_RECOVERY_TMO = 19,
    ISCSI_PARAM_CONN_PORT = 20,
    ISCSI_PARAM_CONN_ADDRESS = 21,
    ISCSI_PARAM_USERNAME = 22,
    ISCSI_PARAM_USERNAME_IN = 23,
    ISCSI_PARAM_PASSWORD = 24,
    ISCSI_PARAM_PASSWORD_IN = 25,
    ISCSI_PARAM_FAST_ABORT = 26,
    ISCSI_PARAM_ABORT_TMO = 27,
    ISCSI_PARAM_LU_RESET_TMO = 28,
    ISCSI_PARAM_HOST_RESET_TMO = 29,
    ISCSI_PARAM_PING_TMO = 30,
    ISCSI_PARAM_RECV_TMO = 31,
    ISCSI_PARAM_IFACE_NAME = 32,
    ISCSI_PARAM_ISID = 33,
    ISCSI_PARAM_INITIATOR_NAME = 34,
    ISCSI_PARAM_TGT_RESET_TMO = 35,
    ISCSI_PARAM_TARGET_ALIAS = 36,
    ISCSI_PARAM_CHAP_IN_IDX = 37,
    ISCSI_PARAM_CHAP_OUT_IDX = 38,
    ISCSI_PARAM_BOOT_ROOT = 39,
    ISCSI_PARAM_BOOT_NIC = 40,
    ISCSI_PARAM_BOOT_TARGET = 41,
    ISCSI_PARAM_AUTO_SND_TGT_DISABLE = 42,
    ISCSI_PARAM_DISCOVERY_SESS = 43,
    ISCSI_PARAM_PORTAL_TYPE = 44,
    ISCSI_PARAM_CHAP_AUTH_EN = 45,
    ISCSI_PARAM_DISCOVERY_LOGOUT_EN = 46,
    ISCSI_PARAM_BIDI_CHAP_EN = 47,
    ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL = 48,
    ISCSI_PARAM_DEF_TIME2WAIT = 49,
    ISCSI_PARAM_DEF_TIME2RETAIN = 50,
    ISCSI_PARAM_MAX_SEGMENT_SIZE = 51,
    ISCSI_PARAM_STATSN = 52,
    ISCSI_PARAM_KEEPALIVE_TMO = 53,
    ISCSI_PARAM_LOCAL_PORT = 54,
    ISCSI_PARAM_TSID = 55,
    ISCSI_PARAM_DEF_TASKMGMT_TMO = 56,
    ISCSI_PARAM_TCP_TIMESTAMP_STAT = 57,
    ISCSI_PARAM_TCP_WSF_DISABLE = 58,
    ISCSI_PARAM_TCP_NAGLE_DISABLE = 59,
    ISCSI_PARAM_TCP_TIMER_SCALE = 60,
    ISCSI_PARAM_TCP_TIMESTAMP_EN = 61,
    ISCSI_PARAM_TCP_XMIT_WSF = 62,
    ISCSI_PARAM_TCP_RECV_WSF = 63,
    ISCSI_PARAM_IP_FRAGMENT_DISABLE = 64,
    ISCSI_PARAM_IPV4_TOS = 65,
    ISCSI_PARAM_IPV6_TC = 66,
    ISCSI_PARAM_IPV6_FLOW_LABEL = 67,
    ISCSI_PARAM_IS_FW_ASSIGNED_IPV6 = 68,
    ISCSI_PARAM_DISCOVERY_PARENT_IDX = 69,
    ISCSI_PARAM_DISCOVERY_PARENT_TYPE = 70,
    ISCSI_PARAM_LOCAL_IPADDR = 71,
    ISCSI_PARAM_MAX = 72
} ;
#line 567
enum iscsi_host_param {
    ISCSI_HOST_PARAM_HWADDRESS = 0,
    ISCSI_HOST_PARAM_INITIATOR_NAME = 1,
    ISCSI_HOST_PARAM_NETDEV_NAME = 2,
    ISCSI_HOST_PARAM_IPADDRESS = 3,
    ISCSI_HOST_PARAM_PORT_STATE = 4,
    ISCSI_HOST_PARAM_PORT_SPEED = 5,
    ISCSI_HOST_PARAM_MAX = 6
} ;
#line 745 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
struct iscsi_stats_custom {
   char desc[64U] ;
   uint64_t value ;
};
#line 785 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
struct iscsi_stats {
   uint64_t txdata_octets ;
   uint64_t rxdata_octets ;
   uint32_t noptx_pdus ;
   uint32_t scsicmd_pdus ;
   uint32_t tmfcmd_pdus ;
   uint32_t login_pdus ;
   uint32_t text_pdus ;
   uint32_t dataout_pdus ;
   uint32_t logout_pdus ;
   uint32_t snack_pdus ;
   uint32_t noprx_pdus ;
   uint32_t scsirsp_pdus ;
   uint32_t tmfrsp_pdus ;
   uint32_t textrsp_pdus ;
   uint32_t datain_pdus ;
   uint32_t logoutrsp_pdus ;
   uint32_t r2t_pdus ;
   uint32_t async_pdus ;
   uint32_t rjt_pdus ;
   uint32_t digest_err ;
   uint32_t timeout_err ;
   uint32_t custom_length ;
   struct iscsi_stats_custom custom[0U] ;
};
#line 960
struct iscsi_transport;
#line 961
struct iscsi_endpoint;
#line 962
struct iscsi_cls_conn;
#line 963
struct iscsi_conn;
#line 964
struct iscsi_task;
#line 965
struct iscsi_iface;
#line 966
struct iscsi_bus_flash_session;
#line 967
struct iscsi_bus_flash_conn;
#line 968
struct iscsi_cls_session;
#line 968 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
struct iscsi_transport {
   struct module *owner ;
   char *name ;
   unsigned int caps ;
   struct iscsi_cls_session *(*create_session)(struct iscsi_endpoint * , uint16_t  ,
                                               uint16_t  , uint32_t  ) ;
   void (*destroy_session)(struct iscsi_cls_session * ) ;
   struct iscsi_cls_conn *(*create_conn)(struct iscsi_cls_session * , uint32_t  ) ;
   int (*bind_conn)(struct iscsi_cls_session * , struct iscsi_cls_conn * , uint64_t  ,
                    int  ) ;
   int (*start_conn)(struct iscsi_cls_conn * ) ;
   void (*stop_conn)(struct iscsi_cls_conn * , int  ) ;
   void (*destroy_conn)(struct iscsi_cls_conn * ) ;
   int (*set_param)(struct iscsi_cls_conn * , enum iscsi_param  , char * , int  ) ;
   int (*get_ep_param)(struct iscsi_endpoint * , enum iscsi_param  , char * ) ;
   int (*get_conn_param)(struct iscsi_cls_conn * , enum iscsi_param  , char * ) ;
   int (*get_session_param)(struct iscsi_cls_session * , enum iscsi_param  , char * ) ;
   int (*get_host_param)(struct Scsi_Host * , enum iscsi_host_param  , char * ) ;
   int (*set_host_param)(struct Scsi_Host * , enum iscsi_host_param  , char * , int  ) ;
   int (*send_pdu)(struct iscsi_cls_conn * , struct iscsi_hdr * , char * , uint32_t  ) ;
   void (*get_stats)(struct iscsi_cls_conn * , struct iscsi_stats * ) ;
   int (*init_task)(struct iscsi_task * ) ;
   int (*xmit_task)(struct iscsi_task * ) ;
   void (*cleanup_task)(struct iscsi_task * ) ;
   int (*alloc_pdu)(struct iscsi_task * , uint8_t  ) ;
   int (*xmit_pdu)(struct iscsi_task * ) ;
   int (*init_pdu)(struct iscsi_task * , unsigned int  , unsigned int  ) ;
   void (*parse_pdu_itt)(struct iscsi_conn * , itt_t  , int * , int * ) ;
   void (*session_recovery_timedout)(struct iscsi_cls_session * ) ;
   struct iscsi_endpoint *(*ep_connect)(struct Scsi_Host * , struct sockaddr * , int  ) ;
   int (*ep_poll)(struct iscsi_endpoint * , int  ) ;
   void (*ep_disconnect)(struct iscsi_endpoint * ) ;
   int (*tgt_dscvr)(struct Scsi_Host * , enum iscsi_tgt_dscvr  , uint32_t  , struct sockaddr * ) ;
   int (*set_path)(struct Scsi_Host * , struct iscsi_path * ) ;
   int (*set_iface_param)(struct Scsi_Host * , void * , uint32_t  ) ;
   int (*get_iface_param)(struct iscsi_iface * , enum iscsi_param_type  , int  , char * ) ;
   umode_t (*attr_is_visible)(int  , int  ) ;
   int (*bsg_request)(struct bsg_job * ) ;
   int (*send_ping)(struct Scsi_Host * , uint32_t  , uint32_t  , uint32_t  , uint32_t  ,
                    struct sockaddr * ) ;
   int (*get_chap)(struct Scsi_Host * , uint16_t  , uint32_t * , char * ) ;
   int (*delete_chap)(struct Scsi_Host * , uint16_t  ) ;
   int (*set_chap)(struct Scsi_Host * , void * , int  ) ;
   int (*get_flashnode_param)(struct iscsi_bus_flash_session * , int  , char * ) ;
   int (*set_flashnode_param)(struct iscsi_bus_flash_session * , struct iscsi_bus_flash_conn * ,
                              void * , int  ) ;
   int (*new_flashnode)(struct Scsi_Host * , char const   * , int  ) ;
   int (*del_flashnode)(struct iscsi_bus_flash_session * ) ;
   int (*login_flashnode)(struct iscsi_bus_flash_session * , struct iscsi_bus_flash_conn * ) ;
   int (*logout_flashnode)(struct iscsi_bus_flash_session * , struct iscsi_bus_flash_conn * ) ;
   int (*logout_flashnode_sid)(struct iscsi_cls_session * ) ;
   int (*get_host_stats)(struct Scsi_Host * , char * , int  ) ;
   u8 (*check_protection)(struct iscsi_task * , sector_t * ) ;
};
#line 200 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
struct iscsi_cls_conn {
   struct list_head conn_list ;
   void *dd_data ;
   struct iscsi_transport *transport ;
   uint32_t cid ;
   struct mutex ep_mutex ;
   struct iscsi_endpoint *ep ;
   struct device dev ;
};
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
struct iscsi_cls_session {
   struct list_head sess_list ;
   struct iscsi_transport *transport ;
   spinlock_t lock ;
   struct work_struct block_work ;
   struct work_struct unblock_work ;
   struct work_struct scan_work ;
   struct work_struct unbind_work ;
   int recovery_tmo ;
   struct delayed_work recovery_work ;
   unsigned int target_id ;
   bool ida_used ;
   pid_t creator ;
   int state ;
   int sid ;
   void *dd_data ;
   struct device dev ;
};
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
struct iscsi_cls_host {
   atomic_t nr_scans ;
   struct mutex mutex ;
   struct request_queue *bsg_q ;
   uint32_t port_speed ;
   uint32_t port_state ;
};
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
struct iscsi_endpoint {
   void *dd_data ;
   struct device dev ;
   uint64_t id ;
   struct iscsi_cls_conn *conn ;
};
#line 292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
struct iscsi_iface {
   struct device dev ;
   struct iscsi_transport *transport ;
   uint32_t iface_type ;
   uint32_t iface_num ;
   void *dd_data ;
};
#line 300 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
struct iscsi_bus_flash_conn {
   struct list_head conn_list ;
   void *dd_data ;
   struct iscsi_transport *transport ;
   struct device dev ;
   uint32_t exp_statsn ;
   uint32_t statsn ;
   unsigned int max_recv_dlength ;
   unsigned int max_xmit_dlength ;
   unsigned int max_segment_size ;
   unsigned int tcp_xmit_wsf ;
   unsigned int tcp_recv_wsf ;
   int hdrdgst_en ;
   int datadgst_en ;
   int port ;
   char *ipaddress ;
   char *link_local_ipv6_addr ;
   char *redirect_ipaddr ;
   uint16_t keepalive_timeout ;
   uint16_t local_port ;
   uint8_t snack_req_en ;
   uint8_t tcp_timestamp_stat ;
   uint8_t tcp_nagle_disable ;
   uint8_t tcp_wsf_disable ;
   uint8_t tcp_timer_scale ;
   uint8_t tcp_timestamp_en ;
   uint8_t ipv4_tos ;
   uint8_t ipv6_traffic_class ;
   uint8_t ipv6_flow_label ;
   uint8_t fragment_disable ;
   uint8_t is_fw_assigned_ipv6 ;
};
#line 344 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
struct iscsi_bus_flash_session {
   struct list_head sess_list ;
   struct iscsi_transport *transport ;
   unsigned int target_id ;
   int flash_state ;
   void *dd_data ;
   struct device dev ;
   unsigned int first_burst ;
   unsigned int max_burst ;
   unsigned short max_r2t ;
   int default_taskmgmt_timeout ;
   int initial_r2t_en ;
   int imm_data_en ;
   int time2wait ;
   int time2retain ;
   int pdu_inorder_en ;
   int dataseq_inorder_en ;
   int erl ;
   int tpgt ;
   char *username ;
   char *username_in ;
   char *password ;
   char *password_in ;
   char *targetname ;
   char *targetalias ;
   char *portal_type ;
   uint16_t tsid ;
   uint16_t chap_in_idx ;
   uint16_t chap_out_idx ;
   uint16_t discovery_parent_idx ;
   uint16_t discovery_parent_type ;
   uint8_t auto_snd_tgt_disable ;
   uint8_t discovery_sess ;
   uint8_t entry_state ;
   uint8_t chap_auth_en ;
   uint8_t discovery_logout_en ;
   uint8_t bidi_chap_en ;
   uint8_t discovery_auth_optional ;
   uint8_t isid[6U] ;
   uint8_t is_boot_target ;
};
#line 487
struct iscsi_session;
#line 512 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
struct iscsi_r2t_info {
   __be32 ttt ;
   __be32 exp_statsn ;
   uint32_t data_length ;
   uint32_t data_offset ;
   int data_count ;
   int datasn ;
   int sent ;
};
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
struct iscsi_task {
   struct iscsi_hdr *hdr ;
   unsigned short hdr_max ;
   unsigned short hdr_len ;
   itt_t hdr_itt ;
   __be32 cmdsn ;
   struct scsi_lun lun ;
   int itt ;
   unsigned int imm_count ;
   struct iscsi_r2t_info unsol_r2t ;
   char *data ;
   unsigned int data_count ;
   struct scsi_cmnd *sc ;
   struct iscsi_conn *conn ;
   unsigned long last_xfer ;
   unsigned long last_timeout ;
   bool have_checked_conn ;
   bool protected ;
   int state ;
   atomic_t refcount ;
   struct list_head running ;
   void *dd_data ;
};
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
struct iscsi_conn {
   struct iscsi_cls_conn *cls_conn ;
   void *dd_data ;
   struct iscsi_session *session ;
   int stop_stage ;
   struct timer_list transport_timer ;
   unsigned long last_recv ;
   unsigned long last_ping ;
   int ping_timeout ;
   int recv_timeout ;
   struct iscsi_task *ping_task ;
   uint32_t exp_statsn ;
   uint32_t statsn ;
   int id ;
   int c_stage ;
   char *data ;
   struct iscsi_task *login_task ;
   struct iscsi_task *task ;
   struct list_head mgmtqueue ;
   struct list_head cmdqueue ;
   struct list_head requeue ;
   struct work_struct xmitwork ;
   unsigned long suspend_tx ;
   unsigned long suspend_rx ;
   wait_queue_head_t ehwait ;
   struct iscsi_tm tmhdr ;
   struct timer_list tmf_timer ;
   int tmf_state ;
   unsigned int max_recv_dlength ;
   unsigned int max_xmit_dlength ;
   int hdrdgst_en ;
   int datadgst_en ;
   int ifmarker_en ;
   int ofmarker_en ;
   int persistent_port ;
   char *persistent_address ;
   unsigned int max_segment_size ;
   unsigned int tcp_xmit_wsf ;
   unsigned int tcp_recv_wsf ;
   uint16_t keepalive_tmo ;
   uint16_t local_port ;
   uint8_t tcp_timestamp_stat ;
   uint8_t tcp_nagle_disable ;
   uint8_t tcp_wsf_disable ;
   uint8_t tcp_timer_scale ;
   uint8_t tcp_timestamp_en ;
   uint8_t fragment_disable ;
   uint8_t ipv4_tos ;
   uint8_t ipv6_traffic_class ;
   uint8_t ipv6_flow_label ;
   uint8_t is_fw_assigned_ipv6 ;
   char *local_ipaddr ;
   uint64_t txdata_octets ;
   uint64_t rxdata_octets ;
   uint32_t scsicmd_pdus_cnt ;
   uint32_t dataout_pdus_cnt ;
   uint32_t scsirsp_pdus_cnt ;
   uint32_t datain_pdus_cnt ;
   uint32_t r2t_pdus_cnt ;
   uint32_t tmfcmd_pdus_cnt ;
   int32_t tmfrsp_pdus_cnt ;
   uint32_t eh_abort_cnt ;
   uint32_t fmr_unalign_cnt ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
struct iscsi_pool {
   struct kfifo queue ;
   void **pool ;
   int max ;
};
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
struct iscsi_session {
   struct iscsi_cls_session *cls_session ;
   struct mutex eh_mutex ;
   uint32_t cmdsn ;
   uint32_t exp_cmdsn ;
   uint32_t max_cmdsn ;
   uint32_t queued_cmdsn ;
   int abort_timeout ;
   int lu_reset_timeout ;
   int tgt_reset_timeout ;
   int initial_r2t_en ;
   unsigned short max_r2t ;
   int imm_data_en ;
   unsigned int first_burst ;
   unsigned int max_burst ;
   int time2wait ;
   int time2retain ;
   int pdu_inorder_en ;
   int dataseq_inorder_en ;
   int erl ;
   int fast_abort ;
   int tpgt ;
   char *username ;
   char *username_in ;
   char *password ;
   char *password_in ;
   char *targetname ;
   char *targetalias ;
   char *ifacename ;
   char *initiatorname ;
   char *boot_root ;
   char *boot_nic ;
   char *boot_target ;
   char *portal_type ;
   char *discovery_parent_type ;
   uint16_t discovery_parent_idx ;
   uint16_t def_taskmgmt_tmo ;
   uint16_t tsid ;
   uint8_t auto_snd_tgt_disable ;
   uint8_t discovery_sess ;
   uint8_t chap_auth_en ;
   uint8_t discovery_logout_en ;
   uint8_t bidi_chap_en ;
   uint8_t discovery_auth_optional ;
   uint8_t isid[6U] ;
   struct iscsi_transport *tt ;
   struct Scsi_Host *host ;
   struct iscsi_conn *leadconn ;
   spinlock_t frwd_lock ;
   spinlock_t back_lock ;
   int state ;
   int age ;
   int scsi_cmds_max ;
   int cmds_max ;
   struct iscsi_task **cmds ;
   struct iscsi_pool cmdpool ;
   void *dd_data ;
};
#line 494 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
struct attribute_container {
   struct list_head node ;
   struct klist containers ;
   struct class *class ;
   struct attribute_group  const  *grp ;
   struct device_attribute **attrs ;
   int (*match)(struct attribute_container * , struct device * ) ;
   unsigned long flags ;
};
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/attribute_container.h"
struct transport_container;
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/transport_class.h"
struct transport_container {
   struct attribute_container ac ;
   struct attribute_group  const  *statistics ;
};
#line 100
struct scsi_sense_hdr;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_device.h"
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
#line 71
struct scsi_dh_data;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_device.h"
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   atomic_t device_busy ;
   atomic_t device_blocked ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
   unsigned short last_queue_full_depth ;
   unsigned short last_queue_full_count ;
   unsigned long last_queue_full_time ;
   unsigned long queue_ramp_up_period ;
   unsigned long last_queue_ramp_up ;
   unsigned int id ;
   unsigned int channel ;
   u64 lun ;
   unsigned int manufacturer ;
   unsigned int sector_size ;
   void *hostdata ;
   char type ;
   char scsi_level ;
   char inq_periph_qual ;
   unsigned char inquiry_len ;
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   int vpd_pg83_len ;
   unsigned char *vpd_pg83 ;
   int vpd_pg80_len ;
   unsigned char *vpd_pg80 ;
   unsigned char current_tag ;
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
   unsigned int eh_timeout ;
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char try_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned char broken_fua : 1 ;
   unsigned char lun_in_cdb : 1 ;
   atomic_t disk_events_disable_depth ;
   unsigned long supported_events[1U] ;
   unsigned long pending_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int max_device_blocked ;
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_device.h"
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   struct scsi_dh_data *(*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_device.h"
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
};
#line 249
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_device.h"
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   struct kref reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned char expecting_lun_change : 1 ;
   atomic_t target_busy ;
   atomic_t target_blocked ;
   unsigned int can_queue ;
   unsigned int max_target_blocked ;
   char scsi_level ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_device.h"
struct scsi_transport_template {
   struct transport_container host_attrs ;
   struct transport_container target_attrs ;
   struct transport_container device_attrs ;
   int (*user_scan)(struct Scsi_Host * , uint  , uint  , u64  ) ;
   int device_size ;
   int device_private_offset ;
   int target_size ;
   int target_private_offset ;
   int host_size ;
   unsigned char create_work_queue : 1 ;
   void (*eh_strategy_handler)(struct Scsi_Host * ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport.h"
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
};
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_cmnd.h"
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
   struct scatterlist *buffer ;
   int buffers_residual ;
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_cmnd.h"
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   struct delayed_work abort_work ;
   int eh_eflags ;
   unsigned long serial_number ;
   unsigned long jiffies_at_alloc ;
   int retries ;
   int allowed ;
   unsigned char prot_op ;
   unsigned char prot_type ;
   unsigned char prot_flags ;
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
   unsigned int transfersize ;
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
   int flags ;
   unsigned char tag ;
};
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/checksum.h"
struct sk_buff;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdev_features.h"
typedef u64 netdev_features_t;
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/flow_keys.h"
struct napi_struct;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/flow_keys.h"
struct nf_conntrack {
   atomic_t use ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
struct nf_bridge_info {
   atomic_t use ;
   unsigned int mask ;
   struct net_device *physindev ;
   struct net_device *physoutdev ;
   unsigned long data[4U] ;
};
#line 174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
#line 388 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
typedef unsigned int sk_buff_data_t;
#line 389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
struct __anonstruct____missing_field_name_239 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
#line 389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_238 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_239 __annonCompField86 ;
};
#line 389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
struct skb_mstamp {
   union __anonunion____missing_field_name_238 __annonCompField87 ;
};
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_242 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
struct __anonstruct____missing_field_name_241 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_242 __annonCompField88 ;
};
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_240 {
   struct __anonstruct____missing_field_name_241 __annonCompField89 ;
   struct rb_node rbnode ;
};
#line 442
struct sec_path;
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
struct __anonstruct____missing_field_name_244 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_243 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_244 __annonCompField91 ;
};
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_245 {
   unsigned int napi_id ;
   unsigned int sender_cpu ;
};
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_246 {
   __u32 mark ;
   __u32 dropcount ;
   __u32 reserved_tailroom ;
};
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
union __anonunion____missing_field_name_247 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/skbuff.h"
struct sk_buff {
   union __anonunion____missing_field_name_240 __annonCompField90 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_243 __annonCompField92 ;
   __u32 priority ;
   int skb_iif ;
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_245 __annonCompField93 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_246 __annonCompField94 ;
   union __anonunion____missing_field_name_247 __annonCompField95 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
   atomic_t users ;
};
#line 705
struct dst_entry;
#line 3236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/security.h"
struct mnt_namespace;
#line 3237
struct ipc_namespace;
#line 3238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/security.h"
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 145 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/netlink.h"
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
#line 104 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netlink.h"
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
   unsigned int seq ;
   long args[6U] ;
};
#line 1195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netlink.h"
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_252 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_252 __annonCompField96 ;
};
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212
struct module_sect_attrs;
#line 212
struct module_notes_attrs;
#line 212
struct tracepoint;
#line 212
struct ftrace_event_call;
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/aer.h"
struct be_bus_address32 {
   unsigned int address_lo ;
   unsigned int address_hi ;
};
#line 215 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct be_bus_address64 {
   unsigned long long address ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
union __anonunion_u_253 {
   struct be_bus_address32 a32 ;
   struct be_bus_address64 a64 ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct be_bus_address {
   union __anonunion_u_253 u ;
};
#line 226 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct mem_array {
   struct be_bus_address bus_address ;
   void *virtual_address ;
   unsigned int size ;
};
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct be_mem_descriptor {
   unsigned int index ;
   unsigned int category ;
   unsigned int num_elements ;
   unsigned int alignment_mask ;
   unsigned int size_in_bytes ;
   struct mem_array *mem_array ;
};
#line 243
struct iscsi_sge;
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct sgl_handle {
   unsigned int sgl_index ;
   unsigned int type ;
   unsigned int cid ;
   struct iscsi_task *task ;
   struct iscsi_sge *pfrag ;
};
#line 251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct hba_parameters {
   unsigned int ios_per_ctrl ;
   unsigned int cxns_per_ctrl ;
   unsigned int asyncpdus_per_ctrl ;
   unsigned int icds_per_ctrl ;
   unsigned int num_sge_per_io ;
   unsigned int defpdu_hdr_sz ;
   unsigned int defpdu_data_sz ;
   unsigned int num_cq_entries ;
   unsigned int num_eq_entries ;
   unsigned int wrbs_per_cxn ;
   unsigned int crashmode ;
   unsigned int hba_num ;
   unsigned int mgmt_ws_sz ;
   unsigned int hwi_ws_sz ;
   unsigned int eto ;
   unsigned int ldto ;
   unsigned int dbg_flags ;
   unsigned int num_cxn ;
   unsigned int eq_timer ;
   unsigned int num_mcc_pages ;
   unsigned int num_mcc_cq_pages ;
   unsigned int num_cq_pages ;
   unsigned int num_eq_pages ;
   unsigned int num_async_pdu_buf_pages ;
   unsigned int num_async_pdu_buf_sgl_pages ;
   unsigned int num_async_pdu_buf_cq_pages ;
   unsigned int num_async_pdu_hdr_pages ;
   unsigned int num_async_pdu_hdr_sgl_pages ;
   unsigned int num_async_pdu_hdr_cq_pages ;
   unsigned int num_sge ;
};
#line 295 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct invalidate_command_table {
   unsigned short icd ;
   unsigned short cid ;
};
#line 300
struct wrb_handle;
#line 300
struct iscsi_wrb;
#line 300 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct hwi_wrb_context {
   struct list_head wrb_handle_list ;
   struct list_head wrb_handle_drvr_list ;
   struct wrb_handle **pwrb_handle_base ;
   struct wrb_handle **pwrb_handle_basestd ;
   struct iscsi_wrb *plast_wrb ;
   unsigned short alloc_index ;
   unsigned short free_index ;
   unsigned short wrb_handles_available ;
   unsigned short cid ;
   uint8_t ulp_num ;
   uint16_t register_set ;
   uint16_t doorbell_format ;
   uint32_t doorbell_offset ;
};
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct ulp_cid_info {
   unsigned short *cid_array ;
   unsigned short avlbl_cids ;
   unsigned short cid_alloc ;
   unsigned short cid_free ;
};
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/miscdevice.h"
struct pm_qos_request {
   struct plist_node node ;
   int pm_qos_class ;
   struct delayed_work work ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_qos.h"
struct pm_qos_flags_request {
   struct list_head node ;
   s32 flags ;
};
#line 55
enum dev_pm_qos_req_type {
    DEV_PM_QOS_RESUME_LATENCY = 1,
    DEV_PM_QOS_LATENCY_TOLERANCE = 2,
    DEV_PM_QOS_FLAGS = 3
} ;
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_qos.h"
union __anonunion_data_254 {
   struct plist_node pnode ;
   struct pm_qos_flags_request flr ;
};
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_qos.h"
struct dev_pm_qos_request {
   enum dev_pm_qos_req_type type ;
   union __anonunion_data_254 data ;
   struct device *dev ;
};
#line 70
enum pm_qos_type {
    PM_QOS_UNITIALIZED = 0,
    PM_QOS_MAX = 1,
    PM_QOS_MIN = 2,
    PM_QOS_SUM = 3
} ;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_qos.h"
struct pm_qos_constraints {
   struct plist_head list ;
   s32 target_value ;
   s32 default_value ;
   s32 no_constraint_value ;
   enum pm_qos_type type ;
   struct blocking_notifier_head *notifiers ;
};
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_qos.h"
struct pm_qos_flags {
   struct list_head list ;
   s32 effective_flags ;
};
#line 96 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_qos.h"
struct dev_pm_qos {
   struct pm_qos_constraints resume_latency ;
   struct pm_qos_constraints latency_tolerance ;
   struct pm_qos_flags flags ;
   struct dev_pm_qos_request *resume_latency_req ;
   struct dev_pm_qos_request *latency_tolerance_req ;
   struct dev_pm_qos_request *flags_req ;
};
#line 1139 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dmaengine.h"
struct dql {
   unsigned int num_queued ;
   unsigned int adj_limit ;
   unsigned int last_obj_cnt ;
   unsigned int limit ;
   unsigned int num_completed ;
   unsigned int prev_ovlimit ;
   unsigned int prev_num_queued ;
   unsigned int prev_last_obj_cnt ;
   unsigned int lowest_slack ;
   unsigned long slack_start_time ;
   unsigned int max_limit ;
   unsigned int min_limit ;
   unsigned int slack_hold_time ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_256 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_256 sync_serial_settings;
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_257 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_257 te1_settings;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_258 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_258 raw_hdlc_proto;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_259 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_259 fr_proto;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_260 {
   unsigned int dlci ;
};
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_260 fr_proto_pvc;
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_261 {
   unsigned int dlci ;
   char master[16U] ;
};
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_261 fr_proto_pvc_info;
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_262 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_262 cisco_proto;
#line 117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdlc/ioctl.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/if.h"
union __anonunion_ifs_ifsu_263 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_263 ifs_ifsu ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/if.h"
union __anonunion_ifr_ifrn_264 {
   char ifrn_name[16U] ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/if.h"
union __anonunion_ifr_ifru_265 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_264 ifr_ifrn ;
   union __anonunion_ifr_ifru_265 ifr_ifru ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/compat.h"
typedef s32 compat_time_t;
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/compat.h"
typedef s32 compat_long_t;
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/compat.h"
typedef u32 compat_uptr_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/compat.h"
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/compat.h"
struct compat_robust_list {
   compat_uptr_t next ;
};
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/compat.h"
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
#line 715 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/compat.h"
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
#line 189 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 288 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
#line 317 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
#line 334 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
#line 433 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
#line 470 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
#line 498 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
#line 599 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
#line 631 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
#line 673 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
#line 706 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
#line 742 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
#line 753 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
#line 772 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
#line 798 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
#line 968 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
#line 976 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
#line 1052 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/ethtool.h"
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ethtool.h"
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
#line 99 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ethtool.h"
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
#line 235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/flow.h"
struct prot_inuse;
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/flow.h"
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
   struct prot_inuse *inuse ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct u64_stats_sync {

};
#line 145 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/u64_stats_sync.h"
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct icmp_mib {
   unsigned long mibs[28U] ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct tcp_mib {
   unsigned long mibs[16U] ;
};
#line 100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct udp_mib {
   unsigned long mibs[9U] ;
};
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct linux_mib {
   unsigned long mibs[113U] ;
};
#line 112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
#line 118 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/snmp.h"
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/mib.h"
struct netns_unix {
   int sysctl_max_dgram_qlen ;
   struct ctl_table_header *ctl ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/unix.h"
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/packet.h"
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
   int low_thresh ;
};
#line 178 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/inet_frag.h"
struct tcpm_hash_bucket;
#line 179
struct ipv4_devconf;
#line 180
struct fib_rules_ops;
#line 181
struct fib_table;
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/inet_frag.h"
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ipv4.h"
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
#line 27
struct inet_peer_base;
#line 27
struct xt_table;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ipv4.h"
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
   struct hlist_head *fib_table_hash ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct inet_peer_base *peers ;
   struct tcpm_hash_bucket *tcp_metrics_hash ;
   unsigned int tcp_metrics_hash_log ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
   int sysctl_icmp_echo_ignore_broadcasts ;
   int sysctl_icmp_ignore_bogus_error_responses ;
   int sysctl_icmp_ratelimit ;
   int sysctl_icmp_ratemask ;
   int sysctl_icmp_errors_use_inbound_ifaddr ;
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
   int sysctl_ip_no_pmtu_disc ;
   int sysctl_ip_fwd_use_pmtu ;
   int sysctl_ip_nonlocal_bind ;
   int sysctl_fwmark_reflect ;
   int sysctl_tcp_fwmark_accept ;
   int sysctl_tcp_mtu_probing ;
   int sysctl_tcp_base_mss ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
#line 107
struct neighbour;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ipv4.h"
struct dst_ops {
   unsigned short family ;
   __be16 protocol ;
   unsigned int gc_thresh ;
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/dst_ops.h"
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
   int flush_delay ;
   int ip6_rt_max_size ;
   int ip6_rt_gc_min_interval ;
   int ip6_rt_gc_timeout ;
   int ip6_rt_gc_interval ;
   int ip6_rt_gc_elasticity ;
   int ip6_rt_mtu_expires ;
   int ip6_rt_min_advmss ;
   int flowlabel_consistency ;
   int auto_flowlabels ;
   int icmpv6_time ;
   int anycast_src_echo_reply ;
   int fwmark_reflect ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ipv6.h"
struct ipv6_devconf;
#line 36
struct rt6_info;
#line 36
struct rt6_statistics;
#line 36
struct fib6_table;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ipv6.h"
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
   unsigned long ip6_rt_last_gc ;
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
#line 81 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ipv6.h"
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ipv6.h"
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ieee802154_6lowpan.h"
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
#line 20
struct sctp_mib;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/ieee802154_6lowpan.h"
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
   unsigned int rto_min ;
   unsigned int rto_max ;
   int rto_alpha ;
   int rto_beta ;
   int max_burst ;
   int cookie_preserve_enable ;
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
   unsigned int sack_timeout ;
   unsigned int hb_interval ;
   int max_retrans_association ;
   int max_retrans_path ;
   int max_retrans_init ;
   int pf_retrans ;
   int sndbuf_policy ;
   int rcvbuf_policy ;
   int default_auto_asconf ;
   int addip_enable ;
   int addip_noauth ;
   int prsctp_enable ;
   int auth_enable ;
   int scope_policy ;
   int rwnd_upd_shift ;
   unsigned long max_autoclose ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/sctp.h"
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netfilter.h"
struct nf_logger;
#line 339 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netfilter.h"
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/netfilter.h"
struct ebt_table;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/netfilter.h"
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/x_tables.h"
struct hlist_nulls_node;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/x_tables.h"
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_nulls.h"
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netfilter/nf_conntrack_tcp.h"
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/conntrack.h"
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/conntrack.h"
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
   unsigned int tcp_be_liberal ;
   unsigned int tcp_max_retrans ;
};
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/conntrack.h"
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/conntrack.h"
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/conntrack.h"
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/conntrack.h"
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
#line 73
struct ip_conntrack_stat;
#line 73
struct nf_ct_event_notifier;
#line 73
struct nf_exp_event_notifier;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/conntrack.h"
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
   int sysctl_events ;
   int sysctl_acct ;
   int sysctl_auto_assign_helper ;
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
   int sysctl_checksum ;
   unsigned int htable_size ;
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
};
#line 115
struct nft_af_info;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/conntrack.h"
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   unsigned int base_seq ;
   u8 gencursor ;
};
#line 445 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
#line 652 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
   u32 hash_rnd ;
   int hash_rnd_recalc ;
   struct tasklet_struct flush_tasklet ;
};
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/flowcache.h"
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
   int high_watermark ;
   struct timer_list rnd_timer ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/flowcache.h"
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/xfrm.h"
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/xfrm.h"
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
   unsigned int state_num ;
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
#line 88
struct proc_ns_operations;
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netns/xfrm.h"
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ns_common.h"
struct net_generic;
#line 12
struct netns_ipvs;
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ns_common.h"
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
   int ifindex ;
   unsigned int dev_unreg_count ;
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/property.h"
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2
} ;
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/property.h"
struct fwnode_handle {
   enum fwnode_type type ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/of.h"
typedef u32 phandle;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/of.h"
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
   unsigned int unique_id ;
   struct bin_attribute attr ;
};
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/of.h"
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mii.h"
enum ldv_33641 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/phy.h"
typedef enum ldv_33641 phy_interface_t;
#line 126
enum ldv_33694 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
#line 133
struct phy_device;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/phy.h"
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_33694 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   int *irq ;
};
#line 211
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
#line 226 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/phy.h"
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
#line 320
struct phy_driver;
#line 320 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/phy.h"
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
   int link ;
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
   int link_timeout ;
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
#line 426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/phy.h"
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
#line 789 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/phy.h"
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/phy_fixed.h"
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/phy_fixed.h"
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
   int eeprom_len ;
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/dsa.h"
struct dsa_platform_data {
   struct device *netdev ;
   int nr_chips ;
   struct dsa_chip_data *chip ;
};
#line 83
struct packet_type;
#line 84
struct dsa_switch;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/dsa.h"
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
#line 122
struct dsa_switch_driver;
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/dsa.h"
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
#line 183 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/dsa.h"
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
};
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/dsa.h"
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dcbnl.h"
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dcbnl.h"
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
#line 100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dcbnl.h"
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dcbnl.h"
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dcbnl.h"
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
#line 168 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dcbnl.h"
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/dcbnl.h"
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/dcbnl.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/cgroupstats.h"
struct cgroup_root;
#line 59
struct cgroup_subsys;
#line 60
struct cgroup;
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 614
struct cgroup_taskset;
#line 622 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 942 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netprio_cgroup.h"
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/if_link.h"
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
#line 600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/if_link.h"
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
};
#line 118 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/if_bonding.h"
struct netpoll_info;
#line 119
struct wireless_dev;
#line 120
struct wpan_dev;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
typedef enum netdev_tx netdev_tx_t;
#line 129 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
#line 190
struct neigh_parms;
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*rebuild)(struct sk_buff * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
#line 296 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
#line 341
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
#line 389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
typedef enum rx_handler_result rx_handler_result_t;
#line 390 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
#line 538
struct Qdisc;
#line 538 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
   unsigned long trans_start ;
   unsigned long trans_timeout ;
   unsigned long state ;
   struct dql dql ;
};
#line 607 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
#line 619 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
};
#line 631 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
#line 683 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
#line 706 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
   struct callback_head rcu ;
   u16 queues[0U] ;
};
#line 719 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
#line 730 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
#line 741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
#line 757 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
};
#line 770 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_switch_parent_id_get)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_switch_port_stp_update)(struct net_device * , u8  ) ;
};
#line 1238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct __anonstruct_adj_list_291 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct __anonstruct_all_adj_list_292 {
   struct list_head upper ;
   struct list_head lower ;
};
#line 1238
struct iw_handler_def;
#line 1238
struct iw_public_data;
#line 1238
struct forwarding_accel_ops;
#line 1238
struct vlan_info;
#line 1238
struct tipc_bearer;
#line 1238
struct in_device;
#line 1238
struct dn_dev;
#line 1238
struct inet6_dev;
#line 1238
struct cpu_rmap;
#line 1238
struct pcpu_lstats;
#line 1238
struct pcpu_sw_netstats;
#line 1238
struct pcpu_dstats;
#line 1238
struct pcpu_vstats;
#line 1238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
union __anonunion____missing_field_name_293 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
#line 1238
struct garp_port;
#line 1238
struct mrp_port;
#line 1238
struct rtnl_link_ops;
#line 1238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_291 adj_list ;
   struct __anonstruct_all_adj_list_292 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int iflink ;
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   atomic_t carrier_changes ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct forwarding_accel_ops  const  *fwd_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
   unsigned short gflags ;
   unsigned short padded ;
   unsigned char operstate ;
   unsigned char link_mode ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   unsigned short needed_headroom ;
   unsigned short needed_tailroom ;
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
   unsigned char addr_len ;
   unsigned short neigh_priv_len ;
   unsigned short dev_id ;
   unsigned short dev_port ;
   spinlock_t addr_list_lock ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned char name_assign_type ;
   bool uc_promisc ;
   unsigned int promiscuity ;
   unsigned int allmulti ;
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   unsigned long last_rx ;
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
   unsigned int real_num_rx_queues ;
   unsigned long gro_flush_timeout ;
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct netdev_queue *ingress_queue ;
   unsigned char broadcast[32U] ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
   unsigned int real_num_tx_queues ;
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
   spinlock_t tx_global_lock ;
   struct xps_dev_maps *xps_maps ;
   struct cpu_rmap *rx_cpu_rmap ;
   unsigned long trans_start ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct hlist_node index_hlist ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
   bool dismantle ;
   unsigned short rtnl_link_state ;
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   struct net *nd_net ;
   union __anonunion____missing_field_name_293 __annonCompField99 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
   int group ;
   struct pm_qos_request pm_qos_req ;
};
#line 1963 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
#line 2009 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/netdevice.h"
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
#line 563 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/if_vlan.h"
struct blk_iopoll;
#line 5 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-iopoll.h"
typedef int blk_iopoll_fn(struct blk_iopoll * , int  );
#line 6 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-iopoll.h"
struct blk_iopoll {
   struct list_head list ;
   unsigned long state ;
   unsigned long data ;
   int weight ;
   int max ;
   blk_iopoll_fn *poll ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-iopoll.h"
struct be_dma_mem {
   void *va ;
   dma_addr_t dma ;
   u32 size ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct be_queue_info {
   struct be_dma_mem dma_mem ;
   u16 len ;
   u16 entry_size ;
   u16 id ;
   u16 tail ;
   u16 head ;
   bool created ;
   atomic_t used ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct be_aic_obj {
   bool enable ;
   u32 min_eqd ;
   u32 max_eqd ;
   u32 prev_eqd ;
   u32 et_eqd ;
   ulong jiffs ;
   u64 eq_prev ;
};
#line 95
struct beiscsi_hba;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct be_eq_obj {
   bool todo_mcc_cq ;
   bool todo_cq ;
   u32 cq_count ;
   struct be_queue_info q ;
   struct beiscsi_hba *phba ;
   struct be_queue_info *cq ;
   struct work_struct work_cqs ;
   struct blk_iopoll iopoll ;
};
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct be_mcc_obj {
   struct be_queue_info q ;
   struct be_queue_info cq ;
};
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct beiscsi_mcc_tag_state {
   uint8_t tag_state ;
   struct be_dma_mem tag_mem_state ;
};
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct be_ctrl_info {
   u8 *csr ;
   u8 *db ;
   u8 *pcicfg ;
   struct pci_dev *pdev ;
   spinlock_t mbox_lock ;
   struct be_dma_mem mbox_mem ;
   struct be_dma_mem mbox_mem_alloced ;
   struct be_mcc_obj mcc_obj ;
   spinlock_t mcc_lock ;
   spinlock_t mcc_cq_lock ;
   wait_queue_head_t mcc_wait[17U] ;
   unsigned int mcc_tag[16U] ;
   unsigned int mcc_numtag[17U] ;
   unsigned short mcc_alloc_index ;
   unsigned short mcc_free_index ;
   unsigned int mcc_tag_available ;
   struct beiscsi_mcc_tag_state ptag_state[17U] ;
};
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct be_sge {
   __le32 pa_lo ;
   __le32 pa_hi ;
   __le32 len ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
union __anonunion_payload_298 {
   u8 embedded_payload[236U] ;
   struct be_sge sgl[19U] ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_mcc_wrb {
   u32 embedded ;
   u32 payload_length ;
   u32 tag0 ;
   u32 tag1 ;
   u32 rsvd ;
   union __anonunion_payload_298 payload ;
};
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_hdr {
   u8 opcode ;
   u8 subsystem ;
   u8 port_number ;
   u8 domain ;
   u32 timeout ;
   u32 request_length ;
   u8 version ;
   u8 rsvd0[3U] ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_hdr {
   u32 info ;
   u32 status ;
   u32 response_length ;
   u32 actual_resp_len ;
};
#line 288 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_chap_format {
   u32 flags ;
   u8 intr_chap_name[256U] ;
   u8 intr_secret[16U] ;
   u8 target_chap_name[256U] ;
   u8 target_secret[16U] ;
   u16 intr_chap_name_length ;
   u16 intr_secret_length ;
   u16 target_chap_name_length ;
   u16 target_secret_length ;
};
#line 300 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_auth_method_format {
   u8 auth_method_type ;
   u8 padding[3U] ;
   struct mgmt_chap_format chap ;
};
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_conn_login_options {
   u8 flags ;
   u8 header_digest ;
   u8 data_digest ;
   u8 rsvd0 ;
   u32 max_recv_datasegment_len_ini ;
   u32 max_recv_datasegment_len_tgt ;
   u32 tcp_mss ;
   u32 tcp_window_size ;
   struct mgmt_auth_method_format auth_data ;
};
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct ip_addr_format {
   u16 size_of_structure ;
   u8 reserved ;
   u8 ip_type ;
   u8 addr[16U] ;
   u32 rsvd0 ;
};
#line 326 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_conn_info {
   u32 connection_handle ;
   u32 connection_status ;
   u16 src_port ;
   u16 dest_port ;
   u16 dest_port_redirected ;
   u16 cid ;
   u32 estimated_throughput ;
   struct ip_addr_format src_ipaddr ;
   struct ip_addr_format dest_ipaddr ;
   struct ip_addr_format dest_ipaddr_redirected ;
   struct mgmt_conn_login_options negotiated_login_options ;
};
#line 340 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_session_login_options {
   u8 flags ;
   u8 error_recovery_level ;
   u16 rsvd0 ;
   u32 first_burst_length ;
   u32 max_burst_length ;
   u16 max_connections ;
   u16 max_outstanding_r2t ;
   u16 default_time2wait ;
   u16 default_time2retain ;
};
#line 352 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct mgmt_session_info {
   u32 session_handle ;
   u32 status ;
   u8 isid[6U] ;
   u16 tsih ;
   u32 session_flags ;
   u16 conn_count ;
   u16 pad ;
   u8 target_name[224U] ;
   u8 initiator_iscsiname[224U] ;
   struct mgmt_session_login_options negotiated_login_options ;
   struct mgmt_conn_info conn_list[1U] ;
};
#line 420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ip_addr_subnet_format {
   u16 size_of_structure ;
   u8 ip_type ;
   u8 ipv6_prefix_length ;
   u8 addr[16U] ;
   u8 subnet_mask[16U] ;
   u32 rsvd0 ;
};
#line 435 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_if_info_resp {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 vlan_priority ;
   u32 ip_addr_count ;
   u32 dhcp_state ;
   struct be_ip_addr_subnet_format ip_addr ;
};
#line 487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_def_gateway_resp {
   struct be_cmd_req_hdr hdr ;
   struct ip_addr_format ip_addr ;
};
#line 658 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_nic_conf_resp {
   struct be_cmd_resp_hdr hdr ;
   u32 nic_port_count ;
   u32 speed ;
   u32 max_speed ;
   u32 link_state ;
   u32 max_frame_size ;
   u16 size_of_structure ;
   u8 mac_address[6U] ;
   u32 rsvd[23U] ;
};
#line 670 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_hba_name {
   struct be_cmd_req_hdr hdr ;
   u16 flags ;
   u16 rsvd0 ;
   u8 initiator_name[224U] ;
   u8 initiator_alias[32U] ;
};
#line 685 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_ntwk_link_status_resp {
   struct be_cmd_resp_hdr hdr ;
   u8 phys_port ;
   u8 mac_duplex ;
   u8 mac_speed ;
   u8 mac_fault ;
   u8 mgmt_mac_duplex ;
   u8 mgmt_mac_speed ;
   u16 qos_link_speed ;
   u32 logical_link_speed ;
};
#line 1044 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct tcp_connect_and_offload_out {
   struct be_cmd_resp_hdr hdr ;
   u32 connection_handle ;
   u16 cid ;
   u16 rsvd0 ;
};
#line 202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct hwi_controller;
#line 202
struct beiscsi_conn;
#line 202
struct iscsi_boot_kset;
#line 202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct __anonstruct_fw_config_300 {
   unsigned int phys_port ;
   unsigned int eqid_count ;
   unsigned int cqid_count ;
   unsigned int iscsi_cid_start[2U] ;
   unsigned int iscsi_cid_count[2U] ;
   unsigned int iscsi_icd_count[2U] ;
   unsigned int iscsi_icd_start[2U] ;
   unsigned int iscsi_chain_start[2U] ;
   unsigned int iscsi_chain_count[2U] ;
   unsigned short iscsi_features ;
   uint16_t dual_ulp_aware ;
   unsigned long ulp_supported ;
};
#line 202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
struct beiscsi_hba {
   struct hba_parameters params ;
   struct hwi_controller *phwi_ctrlr ;
   unsigned int mem_req[22U] ;
   u8 *csr_va ;
   u8 *db_va ;
   u8 *pci_va ;
   struct be_bus_address csr_pa ;
   struct be_bus_address db_pa ;
   struct be_bus_address pci_pa ;
   struct pci_dev *pcidev ;
   unsigned short asic_revision ;
   unsigned int num_cpus ;
   unsigned int nxt_cqid ;
   struct msix_entry msix_entries[64U] ;
   char *msi_name[64U] ;
   bool msix_enabled ;
   struct be_mem_descriptor *init_mem ;
   unsigned short io_sgl_alloc_index ;
   unsigned short io_sgl_free_index ;
   unsigned short io_sgl_hndl_avbl ;
   struct sgl_handle **io_sgl_hndl_base ;
   struct sgl_handle **sgl_hndl_array ;
   unsigned short eh_sgl_alloc_index ;
   unsigned short eh_sgl_free_index ;
   unsigned short eh_sgl_hndl_avbl ;
   struct sgl_handle **eh_sgl_hndl_base ;
   spinlock_t io_sgl_lock ;
   spinlock_t mgmt_sgl_lock ;
   spinlock_t isr_lock ;
   spinlock_t async_pdu_lock ;
   unsigned int age ;
   struct list_head hba_queue ;
   unsigned short cid_to_cri_map[2048U] ;
   struct ulp_cid_info *cid_array_info[2U] ;
   struct iscsi_endpoint **ep_array ;
   struct beiscsi_conn **conn_table ;
   struct iscsi_boot_kset *boot_kset ;
   struct Scsi_Host *shost ;
   struct iscsi_iface *ipv4_iface ;
   struct iscsi_iface *ipv6_iface ;
   struct __anonstruct_fw_config_300 fw_config ;
   unsigned int state ;
   bool fw_timeout ;
   bool ue_detected ;
   struct delayed_work beiscsi_hw_check_task ;
   bool mac_addr_set ;
   u8 mac_address[6U] ;
   char fw_ver_str[32U] ;
   char wq_name[20U] ;
   struct workqueue_struct *wq ;
   struct be_ctrl_info ctrl ;
   unsigned int generation ;
   unsigned int interface_handle ;
   struct mgmt_session_info boot_sess ;
   struct invalidate_command_table inv_tbl[128U] ;
   struct be_aic_obj aic_obj[64U] ;
   unsigned int attr_log_enable ;
   int (*iotask_fn)(struct iscsi_task * , struct scatterlist * , uint32_t  , uint32_t  ,
                    uint32_t  ) ;
};
#line 435 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct beiscsi_session {
   struct dma_pool *bhs_pool ;
};
#line 442
struct beiscsi_endpoint;
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct beiscsi_conn {
   struct iscsi_conn *conn ;
   struct beiscsi_hba *phba ;
   u32 exp_statsn ;
   u32 doorbell_offset ;
   u32 beiscsi_conn_cid ;
   struct beiscsi_endpoint *ep ;
   unsigned short login_in_progress ;
   struct wrb_handle *plogin_wrb_handle ;
   struct sgl_handle *plogin_sgl_handle ;
   struct beiscsi_session *beiscsi_sess ;
   struct iscsi_task *task ;
};
#line 459 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct pdu_data_out {
   u32 dw[12U] ;
};
#line 487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct be_cmd_bhs {
   struct iscsi_scsi_req iscsi_hdr ;
   unsigned char pad1[16U] ;
   struct pdu_data_out iscsi_data_pdu ;
   unsigned char pad2[210U] ;
};
#line 494 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct beiscsi_io_task {
   struct wrb_handle *pwrb_handle ;
   struct sgl_handle *psgl_handle ;
   struct beiscsi_conn *conn ;
   struct scsi_cmnd *scsi_cmnd ;
   unsigned int cmd_sn ;
   unsigned int flags ;
   unsigned short cid ;
   unsigned short header_len ;
   itt_t libiscsi_itt ;
   struct be_cmd_bhs *cmd_bhs ;
   struct be_bus_address bhs_pa ;
   unsigned short bhs_len ;
   dma_addr_t mtask_addr ;
   uint32_t mtask_data_count ;
   uint8_t wrb_type ;
};
#line 531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct iscsi_sge {
   u32 dw[4U] ;
};
#line 549 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct beiscsi_offload_params {
   u32 dw[6U] ;
};
#line 583 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct async_pdu_handle {
   struct list_head link ;
   struct be_bus_address pa ;
   void *pbuffer ;
   unsigned int consumed ;
   unsigned char index ;
   unsigned char is_header ;
   unsigned short cri ;
   unsigned long buffer_len ;
};
#line 597 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct __anonstruct_wait_queue_301 {
   unsigned char hdr_received ;
   unsigned char hdr_len ;
   unsigned short bytes_received ;
   unsigned int bytes_needed ;
   struct list_head list ;
};
#line 597 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct hwi_async_entry {
   struct __anonstruct_wait_queue_301 wait_queue ;
   struct list_head header_busy_list ;
   struct list_head data_busy_list ;
};
#line 610 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct __anonstruct_async_header_302 {
   struct be_bus_address pa_base ;
   void *va_base ;
   void *ring_base ;
   struct async_pdu_handle *handle_base ;
   unsigned int host_write_ptr ;
   unsigned int ep_read_ptr ;
   unsigned int writables ;
   unsigned int free_entries ;
   unsigned int busy_entries ;
   struct list_head free_list ;
};
#line 610 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct __anonstruct_async_data_303 {
   struct be_bus_address pa_base ;
   void *va_base ;
   void *ring_base ;
   struct async_pdu_handle *handle_base ;
   unsigned int host_write_ptr ;
   unsigned int ep_read_ptr ;
   unsigned int writables ;
   unsigned int free_entries ;
   unsigned int busy_entries ;
   struct list_head free_list ;
};
#line 610 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct hwi_async_pdu_context {
   struct __anonstruct_async_header_302 async_header ;
   struct __anonstruct_async_data_303 async_data ;
   unsigned int buffer_size ;
   unsigned int num_entries ;
   unsigned short cid_to_async_cri_map[2048U] ;
   struct hwi_async_entry *async_entry ;
};
#line 735 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct iscsi_wrb {
   u32 dw[16U] ;
};
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct be_ring {
   u32 pages ;
   u32 id ;
   u32 num ;
   u32 cidx ;
   u32 pidx ;
   u32 item_size ;
   u8 ulp_num ;
   u16 register_set ;
   u16 doorbell_format ;
   u32 doorbell_offset ;
   void *va ;
};
#line 1013
struct mcc_wrb;
#line 1013
struct hwi_context_memory;
#line 1013 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct hwi_controller {
   struct list_head io_sgl_list ;
   struct list_head eh_sgl_list ;
   struct sgl_handle *psgl_handle_base ;
   unsigned int wrb_mem_index ;
   struct hwi_wrb_context *wrb_context ;
   struct mcc_wrb *pmcc_wrb_base ;
   struct be_ring default_pdu_hdr[2U] ;
   struct be_ring default_pdu_data[2U] ;
   struct hwi_context_memory *phwi_ctxt ;
};
#line 1029
enum hwh_type_enum {
    HWH_TYPE_IO = 1,
    HWH_TYPE_LOGOUT = 2,
    HWH_TYPE_TMF = 3,
    HWH_TYPE_NOP = 4,
    HWH_TYPE_IO_RD = 5,
    HWH_TYPE_LOGIN = 11,
    HWH_TYPE_INVALID = 4294967295U
} ;
#line 1039 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct wrb_handle {
   enum hwh_type_enum type ;
   unsigned short wrb_index ;
   unsigned short nxt_wrb_index ;
   struct iscsi_task *pio_handle ;
   struct iscsi_wrb *pwrb ;
};
#line 1048 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct hwi_context_memory {
   u16 min_eqd ;
   u16 max_eqd ;
   u16 cur_eqd ;
   struct be_eq_obj be_eq[64U] ;
   struct be_queue_info be_cq[63U] ;
   struct be_queue_info *be_wrbq ;
   struct be_queue_info be_def_hdrq[2U] ;
   struct be_queue_info be_def_dataq[2U] ;
   struct hwi_async_pdu_context *pasync_ctx[2U] ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct mcc_sge {
   u32 pa_lo ;
   u32 pa_hi ;
   u32 length ;
};
#line 81 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
union __anonunion_u_307 {
   struct mcc_sge sgl[19U] ;
   u32 embedded[59U] ;
};
#line 81 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct mcc_wrb_payload {
   union __anonunion_u_307 u ;
};
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct mcc_wrb {
   u32 dw[0U] ;
   u32 payload_length ;
   u32 tag[2U] ;
   u32 rsvd2[1U] ;
   struct mcc_wrb_payload payload ;
};
#line 230
struct beiscsi_sess;
#line 230 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct beiscsi_endpoint {
   struct beiscsi_hba *phba ;
   struct beiscsi_sess *sess ;
   struct beiscsi_conn *conn ;
   struct iscsi_endpoint *openiscsi_ep ;
   unsigned short ip_type ;
   char dst6_addr[64U] ;
   unsigned long dst_addr ;
   unsigned short ep_cid ;
   unsigned int fw_handle ;
   u16 dst_tcpport ;
   u16 cid_vld ;
};
#line 51 "/home/ubuntu/klever-work/linux/ldv/irq.h"
struct ldv_thread;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqhandler.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 695 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct iscsi_boot_kobj {
   struct kobject kobj ;
   struct attribute_group *attr_group ;
   struct list_head list ;
   void *data ;
   ssize_t (*show)(void * , int  , char * ) ;
   umode_t (*is_visible)(void * , int  ) ;
   void (*release)(void * ) ;
};
#line 103 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/iscsi_boot_sysfs.h"
struct iscsi_boot_kset {
   struct list_head kobj_list ;
   struct kset *kset ;
};
#line 641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct bsg_buffer {
   unsigned int payload_len ;
   int sg_cnt ;
   struct scatterlist *sg_list ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bsg-lib.h"
struct bsg_job {
   struct device *dev ;
   struct request *req ;
   void *request ;
   void *reply ;
   unsigned int request_len ;
   unsigned int reply_len ;
   struct bsg_buffer request_payload ;
   struct bsg_buffer reply_payload ;
   void *dd_data ;
};
#line 266 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_proto.h"
struct iscsi_nopin {
   uint8_t opcode ;
   uint8_t flags ;
   __be16 rsvd2 ;
   uint8_t rsvd3 ;
   uint8_t dlength[3U] ;
   struct scsi_lun lun ;
   itt_t itt ;
   __be32 ttt ;
   __be32 statsn ;
   __be32 exp_cmdsn ;
   __be32 max_cmdsn ;
   uint8_t rsvd4[12U] ;
};
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_proto.h"
struct iscsi_tm_rsp {
   uint8_t opcode ;
   uint8_t flags ;
   uint8_t response ;
   uint8_t qualifier ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   uint8_t rsvd2[8U] ;
   itt_t itt ;
   itt_t rtt ;
   __be32 statsn ;
   __be32 exp_cmdsn ;
   __be32 max_cmdsn ;
   uint8_t rsvd3[12U] ;
};
#line 547 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_proto.h"
struct iscsi_logout_rsp {
   uint8_t opcode ;
   uint8_t flags ;
   uint8_t response ;
   uint8_t rsvd2 ;
   uint8_t hlength ;
   uint8_t dlength[3U] ;
   uint8_t rsvd3[8U] ;
   itt_t itt ;
   __be32 rsvd4 ;
   __be32 statsn ;
   __be32 exp_cmdsn ;
   __be32 max_cmdsn ;
   __be32 rsvd5 ;
   __be16 t2wait ;
   __be16 t2retain ;
   __be32 rsvd6 ;
};
#line 465 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/iscsi_if.h"
enum iscsi_err {
    ISCSI_OK = 0,
    ISCSI_ERR_DATASN = 1001,
    ISCSI_ERR_DATA_OFFSET = 1002,
    ISCSI_ERR_MAX_CMDSN = 1003,
    ISCSI_ERR_EXP_CMDSN = 1004,
    ISCSI_ERR_BAD_OPCODE = 1005,
    ISCSI_ERR_DATALEN = 1006,
    ISCSI_ERR_AHSLEN = 1007,
    ISCSI_ERR_PROTO = 1008,
    ISCSI_ERR_LUN = 1009,
    ISCSI_ERR_BAD_ITT = 1010,
    ISCSI_ERR_CONN_FAILED = 1011,
    ISCSI_ERR_R2TSN = 1012,
    ISCSI_ERR_SESSION_FAILED = 1013,
    ISCSI_ERR_HDR_DGST = 1014,
    ISCSI_ERR_DATA_DGST = 1015,
    ISCSI_ERR_PARAM_NOT_FOUND = 1016,
    ISCSI_ERR_NO_SCSI_CMD = 1017,
    ISCSI_ERR_INVALID_HOST = 1018,
    ISCSI_ERR_XMIT_FAILED = 1019,
    ISCSI_ERR_TCP_CONN_CLOSE = 1020,
    ISCSI_ERR_SCSI_EH_SESSION_RST = 1021,
    ISCSI_ERR_NOP_TIMEDOUT = 1022
} ;
#line 494 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
struct iscsi_bsg_host_vendor {
   uint64_t vendor_id ;
   uint32_t vendor_cmd[0U] ;
};
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_bsg_iscsi.h"
struct iscsi_bsg_host_vendor_reply {
   uint32_t vendor_rsp[0U] ;
};
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_bsg_iscsi.h"
union __anonunion_rqst_data_241 {
   struct iscsi_bsg_host_vendor h_vendor ;
};
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_bsg_iscsi.h"
struct iscsi_bsg_request {
   uint32_t msgcode ;
   union __anonunion_rqst_data_241 rqst_data ;
};
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_bsg_iscsi.h"
union __anonunion_reply_data_242 {
   struct iscsi_bsg_host_vendor_reply vendor_reply ;
};
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_bsg_iscsi.h"
struct iscsi_bsg_reply {
   uint32_t result ;
   uint32_t reply_payload_rcv_len ;
   union __anonunion_reply_data_242 reply_data ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_mcc_compl {
   u32 status ;
   u32 tag0 ;
   u32 tag1 ;
   u32 flags ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_async_event_trailer {
   u32 code ;
};
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_async_event_link_state {
   u8 physical_port ;
   u8 port_link_status ;
   u8 port_duplex ;
   u8 port_speed ;
   u8 port_fault ;
   u8 rsvd0[7U] ;
   struct be_async_event_trailer trailer ;
};
#line 226 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct phys_addr {
   u32 lo ;
   u32 hi ;
};
#line 282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_set_eqd {
   u32 eq_id ;
   u32 phase ;
   u32 delay_multiplier ;
};
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_session_resp {
   struct be_cmd_resp_hdr hdr ;
   struct mgmt_session_info session_info ;
};
#line 872 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct sol_cqe {
   u32 dw[4U] ;
};
#line 936 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct common_sol_cqe {
   u32 exp_cmdsn ;
   u32 res_cnt ;
   u16 wrb_index ;
   u16 cid ;
   u8 hw_sts ;
   u8 cmd_wnd ;
   u8 res_flag ;
   u8 i_resp ;
   u8 i_flags ;
   u8 i_sts ;
};
#line 1057 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct dmsg_cqe {
   u32 dw[4U] ;
};
#line 520 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct be_status_bhs {
   struct iscsi_scsi_req iscsi_hdr ;
   unsigned char pad1[16U] ;
   unsigned char sense_info[258U] ;
};
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct i_t_dpdu_cqe {
   u32 dw[4U] ;
};
#line 692 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct be_eq_entry {
   u32 dw[1U] ;
};
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct pdu_nop_out {
   u32 dw[12U] ;
};
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct pdu_base {
   u32 dw[16U] ;
};
#line 5829 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct ldv_struct_EMGentry_20 {
   int signal_pending ;
};
#line 661 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_struct_free_irq_14 {
   int arg0 ;
   int signal_pending ;
};
#line 666 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_struct_interrupt_instance_0 {
   int arg0 ;
   enum irqreturn (*arg1)(int  , void * ) ;
   enum irqreturn (*arg2)(int  , void * ) ;
   void *arg3 ;
   int signal_pending ;
};
#line 674 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_struct_pci_instance_3 {
   struct pci_driver *arg0 ;
   int signal_pending ;
};
#line 679 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_struct_timer_instance_12 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
#line 4231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
typedef int ldv_func_ret_type___1;
#line 4243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
typedef int ldv_func_ret_type___2;
#line 4255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
typedef int ldv_func_ret_type___3;
#line 4541 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
typedef int ldv_func_ret_type___4;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 215 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/in.h"
struct sockaddr_in {
   __kernel_sa_family_t sin_family ;
   __be16 sin_port ;
   struct in_addr sin_addr ;
   unsigned char __pad[8U] ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/in6.h"
struct sockaddr_in6 {
   unsigned short sin6_family ;
   __be16 sin6_port ;
   __be32 sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   __u32 sin6_scope_id ;
};
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_session_req {
   struct be_cmd_req_hdr hdr ;
   u32 session_handle ;
};
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_boot_target_req {
   struct be_cmd_req_hdr hdr ;
};
#line 385 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_boot_target_resp {
   struct be_cmd_resp_hdr hdr ;
   u32 boot_session_count ;
   int boot_session_handle ;
};
#line 391 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_reopen_session_req {
   struct be_cmd_req_hdr hdr ;
   u16 reopen_type ;
   u16 rsvd ;
   u32 session_handle ;
};
#line 429 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_if_info_req {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 ip_type ;
};
#line 444 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ip_addr_record {
   u32 action ;
   u32 interface_hndl ;
   struct be_ip_addr_subnet_format ip_addr ;
   u32 status ;
};
#line 451 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ip_addr_record_params {
   u32 record_entry_count ;
   struct be_ip_addr_record ip_record ;
};
#line 456 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_set_ip_addr_req {
   struct be_cmd_req_hdr hdr ;
   struct be_ip_addr_record_params ip_params ;
};
#line 461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_set_dhcp_req {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 ip_type ;
   u32 flags ;
   u32 retry_count ;
};
#line 470 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_rel_dhcp_req {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 ip_type ;
};
#line 476 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_set_def_gateway_req {
   struct be_cmd_req_hdr hdr ;
   u32 action ;
   struct ip_addr_format ip_addr ;
};
#line 482 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_def_gateway_req {
   struct be_cmd_req_hdr hdr ;
   u32 ip_type ;
};
#line 631 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct __anonstruct_delay_301 {
   __le32 eq_id ;
   __le32 phase ;
   __le32 delay_multiplier ;
};
#line 631 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_modify_eq_delay {
   struct be_cmd_req_hdr hdr ;
   __le32 num_eq ;
   struct __anonstruct_delay_301 delay[64U] ;
};
#line 680 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_ntwk_link_status_req {
   struct be_cmd_req_hdr hdr ;
   u32 rsvd0 ;
};
#line 990 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct iscsi_cleanup_req {
   struct be_cmd_req_hdr hdr ;
   u16 chute ;
   u8 hdr_ring_id ;
   u8 data_ring_id ;
};
#line 1024 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct tcp_connect_and_offload_in_v1 {
   struct be_cmd_req_hdr hdr ;
   struct ip_addr_format ip_address ;
   u16 tcp_port ;
   u16 cid ;
   u16 cq_id ;
   u16 defq_id ;
   struct phys_addr dataout_template_pa ;
   u16 hdr_ring_id ;
   u16 data_ring_id ;
   u8 do_offload ;
   u8 ifd_state ;
   u8 rsvd0[2U] ;
   u16 tcp_window_size ;
   u8 tcp_window_scale_count ;
   u8 rsvd1 ;
   unsigned int tcp_mss : 24 ;
   u8 rsvd2 ;
};
#line 1067 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct tcp_upload_params_in {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u16 upload_type ;
   u32 reset_seq ;
};
#line 1083 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ulp_fw_cfg {
   u32 ulp_mode ;
   u32 etx_base ;
   u32 etx_count ;
   u32 sq_base ;
   u32 sq_count ;
   u32 rq_base ;
   u32 rq_count ;
   u32 dq_base ;
   u32 dq_count ;
   u32 lro_base ;
   u32 lro_count ;
   u32 icd_base ;
   u32 icd_count ;
};
#line 1100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_ulp_chain_icd {
   u32 chain_base ;
   u32 chain_count ;
};
#line 1105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_fw_cfg {
   struct be_cmd_req_hdr hdr ;
   u32 be_config_number ;
   u32 asic_revision ;
   u32 phys_port ;
   u32 function_mode ;
   struct be_ulp_fw_cfg ulp[2U] ;
   u32 function_caps ;
   u32 cqid_base ;
   u32 cqid_count ;
   u32 eqid_base ;
   u32 eqid_count ;
   struct be_ulp_chain_icd chain_icd[2U] ;
};
#line 1122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_get_all_if_id_req {
   struct be_cmd_req_hdr hdr ;
   u32 if_count ;
   u32 if_hndl_list[1U] ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct iscsi_invalidate_connection_params_in {
   struct be_cmd_req_hdr hdr ;
   unsigned int session_handle ;
   unsigned short cid ;
   unsigned short unused ;
   unsigned short cleanup_type ;
   unsigned short save_cfg ;
};
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct invalidate_commands_params_in {
   struct be_cmd_req_hdr hdr ;
   unsigned int ref_handle ;
   unsigned int icd_count ;
   struct invalidate_command_table table[128U] ;
   unsigned short cleanup_type ;
   unsigned short unused ;
};
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct mgmt_hba_attributes {
   u8 flashrom_version_string[32U] ;
   u8 manufacturer_name[32U] ;
   u32 supported_modes ;
   u8 seeprom_version_lo ;
   u8 seeprom_version_hi ;
   u8 rsvd0[2U] ;
   u32 fw_cmd_data_struct_version ;
   u32 ep_fw_data_struct_version ;
   u8 ncsi_version_string[12U] ;
   u32 default_extended_timeout ;
   u8 controller_model_number[32U] ;
   u8 controller_description[64U] ;
   u8 controller_serial_number[32U] ;
   u8 ip_version_string[32U] ;
   u8 firmware_version_string[32U] ;
   u8 bios_version_string[32U] ;
   u8 redboot_version_string[32U] ;
   u8 driver_version_string[32U] ;
   u8 fw_on_flash_version_string[32U] ;
   u32 functionalities_supported ;
   u16 max_cdblength ;
   u8 asic_revision ;
   u8 generational_guid[16U] ;
   u8 hba_port_count ;
   u16 default_link_down_timeout ;
   u8 iscsi_ver_min_max ;
   u8 multifunction_device ;
   u8 cache_valid ;
   u8 hba_status ;
   u8 max_domains_supported ;
   u8 phy_port ;
   u32 firmware_post_status ;
   u32 hba_mtu[8U] ;
   u8 iscsi_features ;
   u8 asic_generation ;
   u8 future_u8[2U] ;
   u32 future_u32[3U] ;
};
#line 197 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct mgmt_controller_attributes {
   struct mgmt_hba_attributes hba_attribs ;
   u16 pci_vendor_id ;
   u16 pci_device_id ;
   u16 pci_sub_vendor_id ;
   u16 pci_sub_system_id ;
   u8 pci_bus_number ;
   u8 pci_device_number ;
   u8 pci_function_number ;
   u8 interface_type ;
   u64 unique_identifier ;
   u8 netfilters ;
   u8 rsvd0[3U] ;
   u32 future_u32[4U] ;
};
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct be_mgmt_controller_attributes {
   struct be_cmd_req_hdr hdr ;
   struct mgmt_controller_attributes params ;
};
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct be_mgmt_controller_attributes_resp {
   struct be_cmd_resp_hdr hdr ;
   struct mgmt_controller_attributes params ;
};
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
struct be_bsg_vendor_cmd {
   struct be_cmd_req_hdr hdr ;
   unsigned short region ;
   unsigned short offset ;
   unsigned short sector ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_mcc_mailbox {
   struct be_mcc_wrb wrb ;
   struct be_mcc_compl compl ;
};
#line 231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct virt_addr {
   u32 lo ;
   u32 hi ;
};
#line 268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_eq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_eq_create {
   struct be_cmd_resp_hdr resp_hdr ;
   u16 eq_id ;
   u16 rsvd0 ;
};
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_set_vlan_req {
   struct be_cmd_req_hdr hdr ;
   u32 interface_hndl ;
   u32 vlan_priority ;
};
#line 543 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_cq_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 page_size ;
   u8 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[4U] ;
};
#line 552 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_cq_create {
   struct be_cmd_resp_hdr hdr ;
   u16 cq_id ;
   u16 rsvd0 ;
};
#line 578 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_mcc_create {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 rsvd0 ;
   u8 context[16U] ;
   struct phys_addr pages[8U] ;
};
#line 586 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_resp_mcc_create {
   struct be_cmd_resp_hdr hdr ;
   u16 id ;
   u16 rsvd0 ;
};
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_cmd_req_q_destroy {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u16 bypass_flush ;
};
#line 773 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_default_pdu_context {
   u32 dw[4U] ;
};
#line 807 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_defq_create_req {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 ulp_num ;
   u8 dua_feature ;
   struct be_default_pdu_context context ;
   struct phys_addr pages[8U] ;
};
#line 818 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_defq_create_resp {
   struct be_cmd_req_hdr hdr ;
   u16 id ;
   u8 rsvd0 ;
   u8 ulp_num ;
   u32 doorbell_offset ;
   u16 register_set ;
   u16 doorbell_format ;
};
#line 828 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_post_template_pages_req {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 type ;
   struct phys_addr scratch_pa ;
   struct virt_addr scratch_va ;
   struct virt_addr pages_va ;
   struct phys_addr pages[16U] ;
};
#line 839 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_remove_template_pages_req {
   struct be_cmd_req_hdr hdr ;
   u16 type ;
   u16 rsvd0 ;
};
#line 845 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_post_sgl_pages_req {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u16 page_offset ;
   u32 rsvd0 ;
   struct phys_addr pages[26U] ;
   u32 rsvd1 ;
};
#line 854 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_wrbq_create_req {
   struct be_cmd_req_hdr hdr ;
   u16 num_pages ;
   u8 ulp_num ;
   u8 dua_feature ;
   struct phys_addr pages[8U] ;
};
#line 862 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
struct be_wrbq_create_resp {
   struct be_cmd_resp_hdr resp_hdr ;
   u16 cid ;
   u8 rsvd0 ;
   u8 ulp_num ;
   u32 doorbell_offset ;
   u16 register_set ;
   u16 doorbell_format ;
};
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   struct kthread_worker *worker ;
};
#line 351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
struct dma_chan;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};
#line 151
struct spi_message;
#line 152
struct spi_transfer;
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
   bool (*can_dma)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master * ) ;
   int (*transfer_one_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_transfer_hardware)(struct spi_master * ) ;
   int (*prepare_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_message)(struct spi_master * , struct spi_message * ) ;
   void (*set_cs)(struct spi_device * , bool  ) ;
   int (*transfer_one)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};
#line 506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_transfer {
   void const   *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned char cs_change : 1 ;
   unsigned char tx_nbits : 3 ;
   unsigned char rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};
#line 630 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned char is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 720 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/pm.h"
typedef unsigned int mmc_pm_flag_t;
#line 26
struct mmc_card;
#line 27
struct sdio_func;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
typedef void sdio_irq_handler_t(struct sdio_func * );
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func_tuple {
   struct sdio_func_tuple *next ;
   unsigned char code ;
   unsigned char size ;
   unsigned char data[0U] ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func {
   struct mmc_card *card ;
   struct device dev ;
   sdio_irq_handler_t *irq_handler ;
   unsigned int num ;
   unsigned char class ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned int max_blksize ;
   unsigned int cur_blksize ;
   unsigned int enable_timeout ;
   unsigned int state ;
   u8 tmpbuf[4U] ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
};
#line 161
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
} ;
#line 167
struct led_trigger;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct led_classdev {
   char const   *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev * , enum led_brightness  ) ;
   int (*brightness_set_sync)(struct led_classdev * , enum led_brightness  ) ;
   enum led_brightness (*brightness_get)(struct led_classdev * ) ;
   int (*blink_set)(struct led_classdev * , unsigned long * , unsigned long * ) ;
   struct device *dev ;
   struct attribute_group  const  **groups ;
   struct list_head node ;
   char const   *default_trigger ;
   unsigned long blink_delay_on ;
   unsigned long blink_delay_off ;
   struct timer_list blink_timer ;
   int blink_brightness ;
   void (*flash_resume)(struct led_classdev * ) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/leds.h"
struct led_trigger {
   char const   *name ;
   void (*activate)(struct led_classdev * ) ;
   void (*deactivate)(struct led_classdev * ) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debugfs.h"
struct fault_attr {
   unsigned long probability ;
   unsigned long interval ;
   atomic_t times ;
   atomic_t space ;
   unsigned long verbose ;
   u32 task_filter ;
   unsigned long stacktrace_depth ;
   unsigned long require_start ;
   unsigned long require_end ;
   unsigned long reject_start ;
   unsigned long reject_end ;
   unsigned long count ;
   struct ratelimit_state ratelimit_state ;
   struct dentry *dname ;
};
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_data;
#line 654
struct mmc_request;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_command {
   u32 opcode ;
   u32 arg ;
   u32 resp[4U] ;
   unsigned int flags ;
   unsigned int retries ;
   unsigned int error ;
   unsigned int busy_timeout ;
   bool sanitize_busy ;
   struct mmc_data *data ;
   struct mmc_request *mrq ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_data {
   unsigned int timeout_ns ;
   unsigned int timeout_clks ;
   unsigned int blksz ;
   unsigned int blocks ;
   unsigned int error ;
   unsigned int flags ;
   unsigned int bytes_xfered ;
   struct mmc_command *stop ;
   struct mmc_request *mrq ;
   unsigned int sg_len ;
   struct scatterlist *sg ;
   s32 host_cookie ;
};
#line 127
struct mmc_host;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_request {
   struct mmc_command *sbc ;
   struct mmc_command *cmd ;
   struct mmc_data *data ;
   struct mmc_command *stop ;
   struct completion completion ;
   void (*done)(struct mmc_request * ) ;
   struct mmc_host *host ;
};
#line 139
struct mmc_async_req;
#line 214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_cid {
   unsigned int manfid ;
   char prod_name[8U] ;
   unsigned char prv ;
   unsigned int serial ;
   unsigned short oemid ;
   unsigned short year ;
   unsigned char hwrev ;
   unsigned char fwrev ;
   unsigned char month ;
};
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_csd {
   unsigned char structure ;
   unsigned char mmca_vsn ;
   unsigned short cmdclass ;
   unsigned short tacc_clks ;
   unsigned int tacc_ns ;
   unsigned int c_size ;
   unsigned int r2w_factor ;
   unsigned int max_dtr ;
   unsigned int erase_size ;
   unsigned int read_blkbits ;
   unsigned int write_blkbits ;
   unsigned int capacity ;
   unsigned char read_partial : 1 ;
   unsigned char read_misalign : 1 ;
   unsigned char write_partial : 1 ;
   unsigned char write_misalign : 1 ;
   unsigned char dsr_imp : 1 ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ext_csd {
   u8 rev ;
   u8 erase_group_def ;
   u8 sec_feature_support ;
   u8 rel_sectors ;
   u8 rel_param ;
   u8 part_config ;
   u8 cache_ctrl ;
   u8 rst_n_function ;
   u8 max_packed_writes ;
   u8 max_packed_reads ;
   u8 packed_event_en ;
   unsigned int part_time ;
   unsigned int sa_timeout ;
   unsigned int generic_cmd6_time ;
   unsigned int power_off_longtime ;
   u8 power_off_notification ;
   unsigned int hs_max_dtr ;
   unsigned int hs200_max_dtr ;
   unsigned int sectors ;
   unsigned int hc_erase_size ;
   unsigned int hc_erase_timeout ;
   unsigned int sec_trim_mult ;
   unsigned int sec_erase_mult ;
   unsigned int trim_timeout ;
   bool partition_setting_completed ;
   unsigned long long enhanced_area_offset ;
   unsigned int enhanced_area_size ;
   unsigned int cache_size ;
   bool hpi_en ;
   bool hpi ;
   unsigned int hpi_cmd ;
   bool bkops ;
   bool man_bkops_en ;
   unsigned int data_sector_size ;
   unsigned int data_tag_unit_size ;
   unsigned int boot_ro_lock ;
   bool boot_ro_lockable ;
   bool ffu_capable ;
   u8 fwrev[8U] ;
   u8 raw_exception_status ;
   u8 raw_partition_support ;
   u8 raw_rpmb_size_mult ;
   u8 raw_erased_mem_count ;
   u8 raw_ext_csd_structure ;
   u8 raw_card_type ;
   u8 out_of_int_time ;
   u8 raw_pwr_cl_52_195 ;
   u8 raw_pwr_cl_26_195 ;
   u8 raw_pwr_cl_52_360 ;
   u8 raw_pwr_cl_26_360 ;
   u8 raw_s_a_timeout ;
   u8 raw_hc_erase_gap_size ;
   u8 raw_erase_timeout_mult ;
   u8 raw_hc_erase_grp_size ;
   u8 raw_sec_trim_mult ;
   u8 raw_sec_erase_mult ;
   u8 raw_sec_feature_support ;
   u8 raw_trim_mult ;
   u8 raw_pwr_cl_200_195 ;
   u8 raw_pwr_cl_200_360 ;
   u8 raw_pwr_cl_ddr_52_195 ;
   u8 raw_pwr_cl_ddr_52_360 ;
   u8 raw_pwr_cl_ddr_200_360 ;
   u8 raw_bkops_status ;
   u8 raw_sectors[4U] ;
   unsigned int feature_support ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_scr {
   unsigned char sda_vsn ;
   unsigned char sda_spec3 ;
   unsigned char bus_widths ;
   unsigned char cmds ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_ssr {
   unsigned int au ;
   unsigned int erase_timeout ;
   unsigned int erase_offset ;
};
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_switch_caps {
   unsigned int hs_max_dtr ;
   unsigned int uhs_max_dtr ;
   unsigned int sd3_bus_mode ;
   unsigned int sd3_drv_type ;
   unsigned int sd3_curr_limit ;
};
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cccr {
   unsigned int sdio_vsn ;
   unsigned int sd_vsn ;
   unsigned char multi_block : 1 ;
   unsigned char low_speed : 1 ;
   unsigned char wide_bus : 1 ;
   unsigned char high_power : 1 ;
   unsigned char high_speed : 1 ;
   unsigned char disable_cd : 1 ;
};
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cis {
   unsigned short vendor ;
   unsigned short device ;
   unsigned short blksize ;
   unsigned int max_dtr ;
};
#line 200
struct mmc_ios;
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_part {
   unsigned int size ;
   unsigned int part_cfg ;
   char name[20U] ;
   bool force_ro ;
   unsigned int area_type ;
};
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_card {
   struct mmc_host *host ;
   struct device dev ;
   u32 ocr ;
   unsigned int rca ;
   unsigned int type ;
   unsigned int state ;
   unsigned int quirks ;
   unsigned int erase_size ;
   unsigned int erase_shift ;
   unsigned int pref_erase ;
   u8 erased_byte ;
   u32 raw_cid[4U] ;
   u32 raw_csd[4U] ;
   u32 raw_scr[2U] ;
   struct mmc_cid cid ;
   struct mmc_csd csd ;
   struct mmc_ext_csd ext_csd ;
   struct sd_scr scr ;
   struct sd_ssr ssr ;
   struct sd_switch_caps sw_caps ;
   unsigned int sdio_funcs ;
   struct sdio_cccr cccr ;
   struct sdio_cis cis ;
   struct sdio_func *sdio_func[7U] ;
   struct sdio_func *sdio_single_irq ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
   unsigned int sd_bus_speed ;
   unsigned int mmc_avail_type ;
   struct dentry *debugfs_root ;
   struct mmc_part part[7U] ;
   unsigned int nr_parts ;
};
#line 519 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ios {
   unsigned int clock ;
   unsigned short vdd ;
   unsigned char bus_mode ;
   unsigned char chip_select ;
   unsigned char power_mode ;
   unsigned char bus_width ;
   unsigned char timing ;
   unsigned char signal_voltage ;
   unsigned char drv_type ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host_ops {
   int (*enable)(struct mmc_host * ) ;
   int (*disable)(struct mmc_host * ) ;
   void (*post_req)(struct mmc_host * , struct mmc_request * , int  ) ;
   void (*pre_req)(struct mmc_host * , struct mmc_request * , bool  ) ;
   void (*request)(struct mmc_host * , struct mmc_request * ) ;
   void (*set_ios)(struct mmc_host * , struct mmc_ios * ) ;
   int (*get_ro)(struct mmc_host * ) ;
   int (*get_cd)(struct mmc_host * ) ;
   void (*enable_sdio_irq)(struct mmc_host * , int  ) ;
   void (*init_card)(struct mmc_host * , struct mmc_card * ) ;
   int (*start_signal_voltage_switch)(struct mmc_host * , struct mmc_ios * ) ;
   int (*card_busy)(struct mmc_host * ) ;
   int (*execute_tuning)(struct mmc_host * , u32  ) ;
   int (*prepare_hs400_tuning)(struct mmc_host * , struct mmc_ios * ) ;
   int (*select_drive_strength)(unsigned int  , int  , int  ) ;
   void (*hw_reset)(struct mmc_host * ) ;
   void (*card_event)(struct mmc_host * ) ;
   int (*multi_io_quirk)(struct mmc_card * , unsigned int  , int  ) ;
};
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_async_req {
   struct mmc_request *mrq ;
   int (*err_check)(struct mmc_card * , struct mmc_async_req * ) ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_slot {
   int cd_irq ;
   void *handler_priv ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_context_info {
   bool is_done_rcv ;
   bool is_new_req ;
   bool is_waiting_last_req ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
};
#line 196
struct regulator;
#line 197
struct mmc_pwrseq;
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_supply {
   struct regulator *vmmc ;
   struct regulator *vqmmc ;
};
#line 204
struct mmc_bus_ops;
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host {
   struct device *parent ;
   struct device class_dev ;
   int index ;
   struct mmc_host_ops  const  *ops ;
   struct mmc_pwrseq *pwrseq ;
   unsigned int f_min ;
   unsigned int f_max ;
   unsigned int f_init ;
   u32 ocr_avail ;
   u32 ocr_avail_sdio ;
   u32 ocr_avail_sd ;
   u32 ocr_avail_mmc ;
   struct notifier_block pm_notify ;
   u32 max_current_330 ;
   u32 max_current_300 ;
   u32 max_current_180 ;
   u32 caps ;
   u32 caps2 ;
   mmc_pm_flag_t pm_caps ;
   int clk_requests ;
   unsigned int clk_delay ;
   bool clk_gated ;
   struct delayed_work clk_gate_work ;
   unsigned int clk_old ;
   spinlock_t clk_lock ;
   struct mutex clk_gate_mutex ;
   struct device_attribute clkgate_delay_attr ;
   unsigned long clkgate_delay ;
   unsigned int max_seg_size ;
   unsigned short max_segs ;
   unsigned short unused ;
   unsigned int max_req_size ;
   unsigned int max_blk_size ;
   unsigned int max_blk_count ;
   unsigned int max_busy_timeout ;
   spinlock_t lock ;
   struct mmc_ios ios ;
   unsigned char use_spi_crc : 1 ;
   unsigned char claimed : 1 ;
   unsigned char bus_dead : 1 ;
   unsigned char removed : 1 ;
   int rescan_disable ;
   int rescan_entered ;
   bool trigger_card_event ;
   struct mmc_card *card ;
   wait_queue_head_t wq ;
   struct task_struct *claimer ;
   int claim_cnt ;
   struct delayed_work detect ;
   int detect_change ;
   struct mmc_slot slot ;
   struct mmc_bus_ops  const  *bus_ops ;
   unsigned int bus_refs ;
   unsigned int sdio_irqs ;
   struct task_struct *sdio_irq_thread ;
   bool sdio_irq_pending ;
   atomic_t sdio_irq_thread_abort ;
   mmc_pm_flag_t pm_flags ;
   struct led_trigger *led ;
   bool regulator_enabled ;
   struct mmc_supply supply ;
   struct dentry *debugfs_root ;
   struct mmc_async_req *areq ;
   struct mmc_context_info context_info ;
   struct fault_attr fail_mmc_request ;
   unsigned int actual_clock ;
   unsigned int slotno ;
   int dsr_req ;
   u32 dsr ;
   unsigned long private[0U] ;
};
#line 24 "/home/ubuntu/klever-work/verifier/map.h"
typedef int ldv_map;
#line 27
struct usb_device;
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct urb;
#line 8 "thread.c"
struct ldv_thread_set {
   int number ;
   struct ldv_thread **threads ;
};
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct ldv_thread {
   int identifier ;
   void (*function)(void * ) ;
};
#line 22 "/home/ubuntu/klever-work/verifier/set.h"
typedef _Bool ldv_set;
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 28 "/home/ubuntu/klever-work/verifier/common.h"
void ldv_assume(int expression ) ;
#line 6 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) ;
#line 7
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) ;
#line 11
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) ;
#line 32
void *ldv_linux_drivers_base_class_create_class(void) ;
#line 33
int ldv_linux_drivers_base_class_register_class(void) ;
#line 64
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) ;
#line 69
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) ;
#line 74
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) ;
#line 79
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) ;
#line 114
void *ldv_linux_usb_gadget_create_class(void) ;
#line 115
int ldv_linux_usb_gadget_register_class(void) ;
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 139
  ldv_linux_alloc_irq_check_alloc_nonatomic();
#line 143
  ldv_linux_alloc_usb_lock_check_alloc_nonatomic();
  }
#line 144
  return;
}
}
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
  {
#line 150
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 154
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 155
  return;
}
}
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
void ldv_check_for_read_section(void) 
{ 


  {
  {
#line 161
  ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section();
#line 165
  ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section();
#line 169
  ldv_linux_kernel_rcu_update_lock_check_for_read_section();
#line 173
  ldv_linux_kernel_rcu_srcu_check_for_read_section();
  }
#line 174
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
void *ldv_create_class(void) 
{ 
  void *res1 ;
  void *tmp ;
  void *res2 ;
  void *tmp___0 ;

  {
  {
#line 180
  tmp = ldv_linux_drivers_base_class_create_class();
#line 180
  res1 = tmp;
#line 181
  tmp___0 = ldv_linux_usb_gadget_create_class();
#line 181
  res2 = tmp___0;
#line 182
  ldv_assume((unsigned long )res1 == (unsigned long )res2);
  }
#line 183
  return (res1);
}
}
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
int ldv_register_class(void) 
{ 
  int res1 ;
  int tmp ;
  int res2 ;
  int tmp___0 ;

  {
  {
#line 194
  tmp = ldv_linux_drivers_base_class_register_class();
#line 194
  res1 = tmp;
#line 195
  tmp___0 = ldv_linux_usb_gadget_register_class();
#line 195
  res2 = tmp___0;
#line 196
  ldv_assume(res1 == res2);
  }
#line 197
  return (res1);
}
}
#line 23 "/home/ubuntu/klever-work/linux/ldv/err.h"
void *ldv_err_ptr(long error ) ;
#line 39 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_malloc_unknown_size(void) ;
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
void *ldv_alloc_macro(gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 312
  ldv_check_alloc_flags(flags);
#line 313
  tmp = ldv_malloc_unknown_size();
  }
#line 313
  return (tmp);
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *__memset(void * , int  , size_t  ) ;
#line 65
extern char *strcpy(char * , char const   * ) ;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
extern int ( /* missing proto */  __builtin_unreachable)() ;
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  {
#line 804
  __edi = __edi;
#line 804
  __esi = __esi;
#line 804
  __edx = __edx;
#line 804
  __ecx = __ecx;
#line 804
  __eax = __eax;
#line 804
  tmp = __builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  }
#line 804
  if (tmp != 0L) {
    {
#line 804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
#line 804
    __builtin_unreachable();
    }
  } else {

  }
#line 804
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 804
  __ret = __eax;
#line 804
  return (__ret);
}
}
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 1041 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
extern void dev_printk(char const   * , struct device  const  * , char const   * 
                       , ...) ;
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/scatterlist.h"
extern struct dma_pool *dma_pool_create(char const   * , struct device * , size_t  ,
                                        size_t  , size_t  ) ;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dmapool.h"
extern void dma_pool_destroy(struct dma_pool * ) ;
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 78
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL) && *(dev->dma_mask) != 0ULL);
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-debug.h"
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 30
extern struct dma_map_ops *dma_ops ;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
  {
#line 37
  tmp = __builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
  }
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 103 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
  }
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
  }
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
  {
#line 145
  tmp___0 = is_device_dma_capable(dev);
  }
#line 145
  if (tmp___0 == 0) {
#line 146
    return ((void *)0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return ((void *)0);
  } else {

  }
  {
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  }
#line 155
  return (memory);
}
}
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 166
  if (tmp___1 != 0L) {
    {
#line 166
    warn_slowpath_null("./arch/x86/include/asm/dma-mapping.h", 166);
    }
  } else {

  }
  {
#line 166
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
    {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
    }
  } else {

  }
#line 174
  return;
}
}
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
  {
#line 19
  tmp = dma_alloc_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                        size, dma_handle, 32U, (struct dma_attrs *)0);
  }
#line 19
  return (tmp);
}
}
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                         dma_addr_t dma_handle ) 
{ 


  {
  {
#line 34
  dma_free_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                 size, vaddr, dma_handle, (struct dma_attrs *)0);
  }
#line 35
  return;
}
}
#line 754 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_host.h"
__inline static void *shost_priv(struct Scsi_Host *shost ) 
{ 


  {
#line 756
  return ((void *)(& shost->hostdata));
}
}
#line 759
extern int scsi_is_host_device(struct device  const  * ) ;
#line 761 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_host.h"
__inline static struct Scsi_Host *dev_to_shost(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 763
  goto ldv_35997;
  ldv_35996: ;
#line 764
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
#line 765
    return ((struct Scsi_Host *)0);
  } else {

  }
#line 766
  dev = dev->parent;
  ldv_35997: 
  {
#line 763
  tmp = scsi_is_host_device((struct device  const  *)dev);
  }
#line 763
  if (tmp == 0) {
#line 765
    goto ldv_35996;
  } else {

  }
#line 768
  __mptr = (struct device  const  *)dev;
#line 768
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffc48UL);
}
}
#line 443 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
extern struct iscsi_endpoint *iscsi_create_endpoint(int  ) ;
#line 444
extern void iscsi_destroy_endpoint(struct iscsi_endpoint * ) ;
#line 445
extern struct iscsi_endpoint *iscsi_lookup_endpoint(u64  ) ;
#line 447
extern struct iscsi_iface *iscsi_create_iface(struct Scsi_Host * , struct iscsi_transport * ,
                                              uint32_t  , uint32_t  , int  ) ;
#line 451
extern void iscsi_destroy_iface(struct iscsi_iface * ) ;
#line 453
extern char *iscsi_get_port_speed_name(struct Scsi_Host * ) ;
#line 454
extern char *iscsi_get_port_state_name(struct Scsi_Host * ) ;
#line 396 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
extern int iscsi_host_get_param(struct Scsi_Host * , enum iscsi_host_param  , char * ) ;
#line 410
extern struct iscsi_cls_session *iscsi_session_setup(struct iscsi_transport * , struct Scsi_Host * ,
                                                     uint16_t  , int  , int  , uint32_t  ,
                                                     unsigned int  ) ;
#line 412
extern void iscsi_session_teardown(struct iscsi_cls_session * ) ;
#line 414
extern int iscsi_set_param(struct iscsi_cls_conn * , enum iscsi_param  , char * ,
                           int  ) ;
#line 425
extern struct iscsi_cls_conn *iscsi_conn_setup(struct iscsi_cls_session * , int  ,
                                               uint32_t  ) ;
#line 428
extern int iscsi_conn_start(struct iscsi_cls_conn * ) ;
#line 430
extern int iscsi_conn_bind(struct iscsi_cls_session * , struct iscsi_cls_conn * ,
                           int  ) ;
#line 440
extern void iscsi_suspend_queue(struct iscsi_conn * ) ;
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netlink.h"
extern struct nlattr *nla_find(struct nlattr  const  * , int  , int  ) ;
#line 666 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netlink.h"
__inline static void *nla_data(struct nlattr  const  *nla ) 
{ 


  {
#line 668
  return ((void *)nla + 4U);
}
}
#line 685 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netlink.h"
__inline static int nla_ok(struct nlattr  const  *nla , int remaining ) 
{ 


  {
#line 687
  return ((remaining > 3 && (unsigned int )((unsigned short )nla->nla_len) > 3U) && (int )nla->nla_len <= remaining);
}
}
#line 700 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/net/netlink.h"
__inline static struct nlattr *nla_next(struct nlattr  const  *nla , int *remaining ) 
{ 
  int totlen ;

  {
#line 702
  totlen = ((int )nla->nla_len + 3) & -4;
#line 704
  *remaining = *remaining - totlen;
#line 705
  return ((struct nlattr *)nla + (unsigned long )totlen);
}
}
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/if_ether.h"
extern ssize_t sysfs_format_mac(char * , unsigned char const   * , int  ) ;
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-iopoll.h"
extern void blk_iopoll_enable(struct blk_iopoll * ) ;
#line 44
extern void blk_iopoll_disable(struct blk_iopoll * ) ;
#line 622 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
__inline static void *embedded_payload(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 624
  return ((void *)(& wrb->payload.embedded_payload));
}
}
#line 721
unsigned int be_cmd_get_initname(struct beiscsi_hba *phba ) ;
#line 722
unsigned int be_cmd_get_port_speed(struct beiscsi_hba *phba ) ;
#line 728
int beiscsi_mccq_compl(struct beiscsi_hba *phba , uint32_t tag , struct be_mcc_wrb **wrb ,
                       struct be_dma_mem *mbx_cmd_mem ) ;
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static u32 amap_mask(u32 bitsize ) 
{ 


  {
#line 167
  return (bitsize != 32U ? (u32 )((1 << (int )bitsize) + -1) : 4294967295U);
}
}
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static void amap_set(void *ptr , u32 dw_offset , u32 mask , u32 offset ,
                              u32 value ) 
{ 
  u32 *dw ;

  {
#line 173
  dw = (u32 *)ptr + (unsigned long )dw_offset;
#line 174
  *dw = *dw & ~ (mask << (int )offset);
#line 175
  *dw = *dw | ((mask & value) << (int )offset);
#line 176
  return;
}
}
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
void beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ) ;
#line 844
unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq ) ;
#line 846 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
__inline static bool beiscsi_error(struct beiscsi_hba *phba ) 
{ 


  {
#line 848
  return ((bool )((int )phba->ue_detected || (int )phba->fw_timeout));
}
}
#line 100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
int mgmt_open_connection(struct beiscsi_hba *phba , struct sockaddr *dst_addr , struct beiscsi_endpoint *beiscsi_ep ,
                         struct be_dma_mem *nonemb_cmd ) ;
#line 105
unsigned int mgmt_upload_connection(struct beiscsi_hba *phba , unsigned short cid ,
                                    unsigned int upload_flag ) ;
#line 272
unsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba , struct beiscsi_endpoint *beiscsi_ep ,
                                        unsigned short cid , unsigned short issue_reset ,
                                        unsigned short savecfg_flag ) ;
#line 278
int mgmt_set_ip(struct beiscsi_hba *phba , struct iscsi_iface_param_info *ip_param ,
                struct iscsi_iface_param_info *subnet_param , uint32_t boot_proto ) ;
#line 293
int mgmt_get_nic_conf(struct beiscsi_hba *phba , struct be_cmd_get_nic_conf_resp *nic ) ;
#line 296
int mgmt_get_if_info(struct beiscsi_hba *phba , int ip_type , struct be_cmd_get_if_info_resp **if_info ) ;
#line 299
int mgmt_get_gateway(struct beiscsi_hba *phba , int ip_type , struct be_cmd_get_def_gateway_resp *gateway ) ;
#line 302
int mgmt_set_gateway(struct beiscsi_hba *phba , struct iscsi_iface_param_info *gateway_param ) ;
#line 308
unsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba ) ;
#line 310
int mgmt_set_vlan(struct beiscsi_hba *phba , uint16_t vlan_tag ) ;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.h"
void beiscsi_create_def_ifaces(struct beiscsi_hba *phba ) ;
#line 35
void beiscsi_destroy_def_ifaces(struct beiscsi_hba *phba ) ;
#line 37
int be2iscsi_iface_get_param(struct iscsi_iface *iface , enum iscsi_param_type param_type ,
                             int param , char *buf ) ;
#line 41
int be2iscsi_iface_set_param(struct Scsi_Host *shost , void *data , uint32_t dt_len ) ;
#line 44
umode_t be2iscsi_attr_is_visible(int param_type , int param ) ;
#line 46
void beiscsi_offload_connection(struct beiscsi_conn *beiscsi_conn , struct beiscsi_offload_params *params ) ;
#line 53
struct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep , unsigned short cmds_max ,
                                                 unsigned short qdepth , unsigned int initial_cmdsn ) ;
#line 58
void beiscsi_session_destroy(struct iscsi_cls_session *cls_session ) ;
#line 60
struct iscsi_cls_conn *beiscsi_conn_create(struct iscsi_cls_session *cls_session ,
                                           unsigned int cid ) ;
#line 63
int beiscsi_conn_bind(struct iscsi_cls_session *cls_session , struct iscsi_cls_conn *cls_conn ,
                      unsigned long long transport_fd , int is_leading ) ;
#line 67
int beiscsi_ep_get_param(struct iscsi_endpoint *ep , enum iscsi_param param , char *buf ) ;
#line 70
int beiscsi_get_host_param(struct Scsi_Host *shost , enum iscsi_host_param param ,
                           char *buf ) ;
#line 73
int beiscsi_get_macaddr(char *buf , struct beiscsi_hba *phba ) ;
#line 75
int beiscsi_set_param(struct iscsi_cls_conn *cls_conn , enum iscsi_param param , char *buf ,
                      int buflen ) ;
#line 78
int beiscsi_conn_start(struct iscsi_cls_conn *cls_conn ) ;
#line 80
struct iscsi_endpoint *beiscsi_ep_connect(struct Scsi_Host *shost , struct sockaddr *dst_addr ,
                                          int non_blocking ) ;
#line 84
int beiscsi_ep_poll(struct iscsi_endpoint *ep , int timeout_ms ) ;
#line 86
void beiscsi_ep_disconnect(struct iscsi_endpoint *ep ) ;
#line 88
void beiscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn , struct iscsi_stats *stats ) ;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
struct iscsi_transport beiscsi_iscsi_transport ;
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
struct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep , unsigned short cmds_max ,
                                                 unsigned short qdepth , unsigned int initial_cmdsn ) 
{ 
  struct Scsi_Host *shost ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct iscsi_cls_session *cls_session ;
  struct beiscsi_hba *phba ;
  struct iscsi_session *sess ;
  struct beiscsi_session *beiscsi_sess ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 54
  if ((unsigned long )ep == (unsigned long )((struct iscsi_endpoint *)0)) {
    {
#line 55
    printk("\vbeiscsi_session_create: invalid ep\n");
    }
#line 57
    return ((struct iscsi_cls_session *)0);
  } else {

  }
#line 59
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 60
  phba = beiscsi_ep->phba;
#line 62
  if ((phba->state & 4U) != 0U) {
#line 63
    log_value = phba->attr_log_enable;
#line 63
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 63
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : PCI_ERROR Recovery\n",
                 64);
      }
    } else {

    }
#line 65
    return ((struct iscsi_cls_session *)0);
  } else {
#line 67
    log_value___0 = phba->attr_log_enable;
#line 67
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 67
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : In beiscsi_session_create\n", 68);
      }
    } else {

    }
  }
#line 71
  if ((unsigned int )cmds_max > (beiscsi_ep->phba)->params.wrbs_per_cxn) {
#line 72
    log_value___1 = phba->attr_log_enable;
#line 72
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 72
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Cannot handle %d cmds.Max cmds per session supported is %d. Using %d.\n",
                 77, (int )cmds_max, (beiscsi_ep->phba)->params.wrbs_per_cxn, (beiscsi_ep->phba)->params.wrbs_per_cxn);
      }
    } else {

    }
#line 79
    cmds_max = (u16 )(beiscsi_ep->phba)->params.wrbs_per_cxn;
  } else {

  }
  {
#line 82
  shost = phba->shost;
#line 83
  cls_session = iscsi_session_setup(& beiscsi_iscsi_transport, shost, (int )cmds_max,
                                    8, 88, initial_cmdsn, 4294967295U);
  }
#line 88
  if ((unsigned long )cls_session == (unsigned long )((struct iscsi_cls_session *)0)) {
#line 89
    return ((struct iscsi_cls_session *)0);
  } else {

  }
  {
#line 90
  sess = (struct iscsi_session *)cls_session->dd_data;
#line 91
  beiscsi_sess = (struct beiscsi_session *)sess->dd_data;
#line 92
  beiscsi_sess->bhs_pool = dma_pool_create("beiscsi_bhs_pool", & (phba->pcidev)->dev,
                                           324UL, 64UL, 0UL);
  }
#line 96
  if ((unsigned long )beiscsi_sess->bhs_pool == (unsigned long )((struct dma_pool *)0)) {
#line 97
    goto destroy_sess;
  } else {

  }
#line 99
  return (cls_session);
  destroy_sess: 
  {
#line 101
  iscsi_session_teardown(cls_session);
  }
#line 102
  return ((struct iscsi_cls_session *)0);
}
}
#line 112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_session_destroy(struct iscsi_cls_session *cls_session ) 
{ 
  struct iscsi_session *sess ;
  struct beiscsi_session *beiscsi_sess ;

  {
  {
#line 114
  sess = (struct iscsi_session *)cls_session->dd_data;
#line 115
  beiscsi_sess = (struct beiscsi_session *)sess->dd_data;
#line 117
  printk("\016In beiscsi_session_destroy\n");
#line 118
  dma_pool_destroy(beiscsi_sess->bhs_pool);
#line 119
  iscsi_session_teardown(cls_session);
  }
#line 120
  return;
}
}
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
struct iscsi_cls_conn *beiscsi_conn_create(struct iscsi_cls_session *cls_session ,
                                           unsigned int cid ) 
{ 
  struct beiscsi_hba *phba ;
  struct Scsi_Host *shost ;
  struct iscsi_cls_conn *cls_conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct iscsi_conn *conn ;
  struct iscsi_session *sess ;
  struct beiscsi_session *beiscsi_sess ;
  void *tmp ;
  uint32_t log_value ;

  {
  {
#line 138
  shost = dev_to_shost(cls_session->dev.parent);
#line 139
  tmp = shost_priv(shost);
#line 139
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 141
  log_value = phba->attr_log_enable;
  }
#line 141
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 141
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_conn_create ,cidfrom iscsi layer=%d\n",
               143, cid);
    }
  } else {

  }
  {
#line 145
  cls_conn = iscsi_conn_setup(cls_session, 80, cid);
  }
#line 146
  if ((unsigned long )cls_conn == (unsigned long )((struct iscsi_cls_conn *)0)) {
#line 147
    return ((struct iscsi_cls_conn *)0);
  } else {

  }
#line 149
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 150
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 151
  beiscsi_conn->ep = (struct beiscsi_endpoint *)0;
#line 152
  beiscsi_conn->phba = phba;
#line 153
  beiscsi_conn->conn = conn;
#line 154
  sess = (struct iscsi_session *)cls_session->dd_data;
#line 155
  beiscsi_sess = (struct beiscsi_session *)sess->dd_data;
#line 156
  beiscsi_conn->beiscsi_sess = beiscsi_sess;
#line 157
  return (cls_conn);
}
}
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_bindconn_cid(struct beiscsi_hba *phba , struct beiscsi_conn *beiscsi_conn ,
                                unsigned int cid ) 
{ 
  uint16_t cri_index ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 170
  cri_index = phba->cid_to_cri_map[cid];
#line 172
  if ((unsigned long )*(phba->conn_table + (unsigned long )cri_index) != (unsigned long )((struct beiscsi_conn *)0)) {
#line 173
    log_value = phba->attr_log_enable;
#line 173
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 173
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Connection table already occupied. Detected clash\n",
                 174);
      }
    } else {

    }
#line 176
    return (-22);
  } else {
#line 178
    log_value___0 = phba->attr_log_enable;
#line 178
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 178
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : phba->conn_table[%d]=%p(beiscsi_conn)\n", 180, (int )cri_index,
                 beiscsi_conn);
      }
    } else {

    }
#line 182
    *(phba->conn_table + (unsigned long )cri_index) = beiscsi_conn;
  }
#line 184
  return (0);
}
}
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_conn_bind(struct iscsi_cls_session *cls_session , struct iscsi_cls_conn *cls_conn ,
                      unsigned long long transport_fd , int is_leading ) 
{ 
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct Scsi_Host *shost ;
  struct Scsi_Host *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_wrb_context *pwrb_context ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct iscsi_endpoint *ep ;
  int tmp___1 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___2 ;

  {
  {
#line 199
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 200
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 201
  tmp = dev_to_shost(cls_session->dev.parent);
#line 201
  shost = tmp;
#line 202
  tmp___0 = shost_priv(shost);
#line 202
  phba = (struct beiscsi_hba *)tmp___0 + 224U;
#line 203
  phwi_ctrlr = phba->phwi_ctrlr;
#line 208
  ep = iscsi_lookup_endpoint(transport_fd);
  }
#line 209
  if ((unsigned long )ep == (unsigned long )((struct iscsi_endpoint *)0)) {
#line 210
    return (-22);
  } else {

  }
  {
#line 212
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 214
  tmp___1 = iscsi_conn_bind(cls_session, cls_conn, is_leading);
  }
#line 214
  if (tmp___1 != 0) {
#line 215
    return (-22);
  } else {

  }
#line 217
  if ((unsigned long )beiscsi_ep->phba != (unsigned long )phba) {
#line 218
    log_value = phba->attr_log_enable;
#line 218
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 218
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : beiscsi_ep->hba=%p not equal to phba=%p\n",
                 220, beiscsi_ep->phba, phba);
      }
    } else {

    }
#line 222
    return (-17);
  } else {

  }
#line 225
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )phba->cid_to_cri_map[(int )beiscsi_ep->ep_cid];
#line 228
  beiscsi_conn->beiscsi_conn_cid = (u32 )beiscsi_ep->ep_cid;
#line 229
  beiscsi_conn->ep = beiscsi_ep;
#line 230
  beiscsi_ep->conn = beiscsi_conn;
#line 231
  beiscsi_conn->doorbell_offset = pwrb_context->doorbell_offset;
#line 233
  log_value___0 = phba->attr_log_enable;
#line 233
  if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 233
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : beiscsi_conn=%p conn=%p ep_cid=%d\n",
               235, beiscsi_conn, conn, (int )beiscsi_ep->ep_cid);
    }
  } else {

  }
  {
#line 237
  tmp___2 = beiscsi_bindconn_cid(phba, beiscsi_conn, (unsigned int )beiscsi_ep->ep_cid);
  }
#line 237
  return (tmp___2);
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_create_ipv4_iface(struct beiscsi_hba *phba ) 
{ 
  uint32_t log_value ;

  {
#line 242
  if ((unsigned long )phba->ipv4_iface != (unsigned long )((struct iscsi_iface *)0)) {
#line 243
    return (0);
  } else {

  }
  {
#line 245
  phba->ipv4_iface = iscsi_create_iface(phba->shost, & beiscsi_iscsi_transport, 1U,
                                        0U, 0);
  }
#line 249
  if ((unsigned long )phba->ipv4_iface == (unsigned long )((struct iscsi_iface *)0)) {
#line 250
    log_value = phba->attr_log_enable;
#line 250
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 250
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Could not create default IPv4 address.\n",
                 252);
      }
    } else {

    }
#line 253
    return (-19);
  } else {

  }
#line 256
  return (0);
}
}
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_create_ipv6_iface(struct beiscsi_hba *phba ) 
{ 
  uint32_t log_value ;

  {
#line 261
  if ((unsigned long )phba->ipv6_iface != (unsigned long )((struct iscsi_iface *)0)) {
#line 262
    return (0);
  } else {

  }
  {
#line 264
  phba->ipv6_iface = iscsi_create_iface(phba->shost, & beiscsi_iscsi_transport, 2U,
                                        0U, 0);
  }
#line 268
  if ((unsigned long )phba->ipv6_iface == (unsigned long )((struct iscsi_iface *)0)) {
#line 269
    log_value = phba->attr_log_enable;
#line 269
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 269
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Could not create default IPv6 address.\n",
                 271);
      }
    } else {

    }
#line 272
    return (-19);
  } else {

  }
#line 275
  return (0);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_create_def_ifaces(struct beiscsi_hba *phba ) 
{ 
  struct be_cmd_get_if_info_resp *if_info ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 282
  tmp = mgmt_get_if_info(phba, 1, & if_info);
  }
#line 282
  if (tmp == 0) {
    {
#line 283
    beiscsi_create_ipv4_iface(phba);
#line 284
    kfree((void const   *)if_info);
    }
  } else {

  }
  {
#line 287
  tmp___0 = mgmt_get_if_info(phba, 16, & if_info);
  }
#line 287
  if (tmp___0 == 0) {
    {
#line 288
    beiscsi_create_ipv6_iface(phba);
#line 289
    kfree((void const   *)if_info);
    }
  } else {

  }
#line 291
  return;
}
}
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_destroy_def_ifaces(struct beiscsi_hba *phba ) 
{ 


  {
#line 295
  if ((unsigned long )phba->ipv6_iface != (unsigned long )((struct iscsi_iface *)0)) {
    {
#line 296
    iscsi_destroy_iface(phba->ipv6_iface);
    }
  } else {

  }
#line 297
  if ((unsigned long )phba->ipv4_iface != (unsigned long )((struct iscsi_iface *)0)) {
    {
#line 298
    iscsi_destroy_iface(phba->ipv4_iface);
    }
  } else {

  }
#line 299
  return;
}
}
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_set_static_ip(struct Scsi_Host *shost , struct iscsi_iface_param_info *iface_param ,
                                 void *data , uint32_t dt_len ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  struct iscsi_iface_param_info *iface_ip ;
  struct iscsi_iface_param_info *iface_subnet ;
  struct nlattr *nla ;
  int ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
  {
#line 306
  tmp = shost_priv(shost);
#line 306
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 307
  iface_ip = (struct iscsi_iface_param_info *)0;
#line 308
  iface_subnet = (struct iscsi_iface_param_info *)0;
  }
  {
#line 314
  if ((int )iface_param->param == 4) {
#line 314
    goto case_4;
  } else {

  }
#line 323
  if ((int )iface_param->param == 1) {
#line 323
    goto case_1;
  } else {

  }
#line 329
  if ((int )iface_param->param == 2) {
#line 329
    goto case_2;
  } else {

  }
#line 335
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 315
  nla = nla_find((struct nlattr  const  *)data, (int )dt_len, 1);
  }
#line 316
  if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
    {
#line 317
    tmp___0 = nla_data((struct nlattr  const  *)nla);
#line 317
    iface_ip = (struct iscsi_iface_param_info *)tmp___0;
    }
  } else {

  }
  {
#line 319
  nla = nla_find((struct nlattr  const  *)data, (int )dt_len, 2);
  }
#line 320
  if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
    {
#line 321
    tmp___1 = nla_data((struct nlattr  const  *)nla);
#line 321
    iface_subnet = (struct iscsi_iface_param_info *)tmp___1;
    }
  } else {

  }
#line 322
  goto ldv_56638;
  case_1: /* CIL Label */ 
  {
#line 324
  iface_ip = iface_param;
#line 325
  nla = nla_find((struct nlattr  const  *)data, (int )dt_len, 2);
  }
#line 326
  if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
    {
#line 327
    tmp___2 = nla_data((struct nlattr  const  *)nla);
#line 327
    iface_subnet = (struct iscsi_iface_param_info *)tmp___2;
    }
  } else {

  }
#line 328
  goto ldv_56638;
  case_2: /* CIL Label */ 
  {
#line 330
  iface_subnet = iface_param;
#line 331
  nla = nla_find((struct nlattr  const  *)data, (int )dt_len, 1);
  }
#line 332
  if ((unsigned long )nla != (unsigned long )((struct nlattr *)0)) {
    {
#line 333
    tmp___3 = nla_data((struct nlattr  const  *)nla);
#line 333
    iface_ip = (struct iscsi_iface_param_info *)tmp___3;
    }
  } else {

  }
#line 334
  goto ldv_56638;
  switch_default: /* CIL Label */ 
#line 336
  log_value = phba->attr_log_enable;
#line 336
  if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 336
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Unsupported param %d\n",
               338, (int )iface_param->param);
    }
  } else {

  }
  switch_break: /* CIL Label */ ;
  }
  ldv_56638: ;
#line 341
  if ((unsigned long )iface_ip == (unsigned long )((struct iscsi_iface_param_info *)0) || (unsigned long )iface_subnet == (unsigned long )((struct iscsi_iface_param_info *)0)) {
#line 342
    log_value___0 = phba->attr_log_enable;
#line 342
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 342
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : IP and Subnet Mask required\n",
                 343);
      }
    } else {

    }
#line 344
    return (-22);
  } else {

  }
  {
#line 347
  ret = mgmt_set_ip(phba, iface_ip, iface_subnet, 1U);
  }
#line 350
  return (ret);
}
}
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_set_vlan_tag(struct Scsi_Host *shost , struct iscsi_iface_param_info *iface_param ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  int ret ;
  uint32_t log_value ;
  unsigned int tmp___0 ;
  uint32_t log_value___0 ;

  {
  {
#line 369
  tmp = shost_priv(shost);
#line 369
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 370
  ret = 0;
#line 373
  tmp___0 = mgmt_get_all_if_id(phba);
  }
#line 373
  if (tmp___0 != 0U) {
#line 374
    log_value = phba->attr_log_enable;
#line 374
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 374
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Getting Interface Handle Failed\n",
                 375);
      }
    } else {

    }
#line 376
    return (-5);
  } else {

  }
  {
#line 380
  if ((int )iface_param->param == 15) {
#line 380
    goto case_15;
  } else {

  }
#line 384
  if ((int )iface_param->param == 16) {
#line 384
    goto case_16;
  } else {

  }
#line 388
  goto switch_default;
  case_15: /* CIL Label */ ;
#line 381
  if ((unsigned int )iface_param->value[0] != 2U) {
    {
#line 382
    ret = mgmt_set_vlan(phba, 65535);
    }
  } else {

  }
#line 383
  goto ldv_56652;
  case_16: /* CIL Label */ 
  {
#line 385
  ret = mgmt_set_vlan(phba, (int )*((uint16_t *)(& iface_param->value)));
  }
#line 387
  goto ldv_56652;
  switch_default: /* CIL Label */ 
#line 389
  log_value___0 = phba->attr_log_enable;
#line 389
  if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
    {
#line 389
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Unknown Param Type : %d\n",
               391, (int )iface_param->param);
    }
  } else {

  }
#line 392
  return (-38);
  switch_break: /* CIL Label */ ;
  }
  ldv_56652: ;
#line 394
  return (ret);
}
}
#line 399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_set_ipv4(struct Scsi_Host *shost , struct iscsi_iface_param_info *iface_param ,
                            void *data , uint32_t dt_len ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  int ret ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
  {
#line 403
  tmp = shost_priv(shost);
#line 403
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 404
  ret = 0;
  }
  {
#line 408
  if ((int )iface_param->param == 3) {
#line 408
    goto case_3;
  } else {

  }
#line 411
  if ((int )iface_param->param == 4) {
#line 411
    goto case_4;
  } else {

  }
#line 423
  if ((int )iface_param->param == 12) {
#line 423
    goto case_12;
  } else {

  }
#line 429
  if ((int )iface_param->param == 2) {
#line 429
    goto case_2;
  } else {

  }
#line 430
  if ((int )iface_param->param == 1) {
#line 430
    goto case_1;
  } else {

  }
#line 434
  if ((int )iface_param->param == 15) {
#line 434
    goto case_15;
  } else {

  }
#line 435
  if ((int )iface_param->param == 16) {
#line 435
    goto case_16;
  } else {

  }
#line 438
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 409
  ret = mgmt_set_gateway(phba, iface_param);
  }
#line 410
  goto ldv_56665;
  case_4: /* CIL Label */ ;
#line 412
  if ((unsigned int )iface_param->value[0] == 2U) {
    {
#line 413
    ret = mgmt_set_ip(phba, iface_param, (struct iscsi_iface_param_info *)0, 2U);
    }
  } else
#line 415
  if ((unsigned int )iface_param->value[0] == 1U) {
    {
#line 416
    ret = beiscsi_set_static_ip(shost, iface_param, data, dt_len);
    }
  } else {
#line 419
    log_value = phba->attr_log_enable;
#line 419
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 419
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Invalid BOOTPROTO: %d\n",
                 421, (int )iface_param->value[0]);
      }
    } else {

    }
  }
#line 422
  goto ldv_56665;
  case_12: /* CIL Label */ ;
#line 424
  if ((unsigned int )iface_param->value[0] == 2U) {
    {
#line 425
    ret = beiscsi_create_ipv4_iface(phba);
    }
  } else {
    {
#line 427
    iscsi_destroy_iface(phba->ipv4_iface);
    }
  }
#line 428
  goto ldv_56665;
  case_2: /* CIL Label */ ;
  case_1: /* CIL Label */ 
  {
#line 431
  ret = beiscsi_set_static_ip(shost, iface_param, data, dt_len);
  }
#line 433
  goto ldv_56665;
  case_15: /* CIL Label */ ;
  case_16: /* CIL Label */ 
  {
#line 436
  ret = beiscsi_set_vlan_tag(shost, iface_param);
  }
#line 437
  goto ldv_56665;
  switch_default: /* CIL Label */ 
#line 439
  log_value___0 = phba->attr_log_enable;
#line 439
  if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 439
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Param %d not supported\n",
               441, (int )iface_param->param);
    }
  } else {

  }
  switch_break: /* CIL Label */ ;
  }
  ldv_56665: ;
#line 444
  return (ret);
}
}
#line 448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_set_ipv6(struct Scsi_Host *shost , struct iscsi_iface_param_info *iface_param ,
                            void *data , uint32_t dt_len ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  int ret ;
  uint32_t log_value ;

  {
  {
#line 452
  tmp = shost_priv(shost);
#line 452
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 453
  ret = 0;
  }
  {
#line 456
  if ((int )iface_param->param == 12) {
#line 456
    goto case_12;
  } else {

  }
#line 464
  if ((int )iface_param->param == 7) {
#line 464
    goto case_7;
  } else {

  }
#line 468
  goto switch_default;
  case_12: /* CIL Label */ ;
#line 457
  if ((unsigned int )iface_param->value[0] == 2U) {
    {
#line 458
    ret = beiscsi_create_ipv6_iface(phba);
    }
  } else {
    {
#line 460
    iscsi_destroy_iface(phba->ipv6_iface);
#line 461
    ret = 0;
    }
  }
#line 463
  goto ldv_56684;
  case_7: /* CIL Label */ 
  {
#line 465
  ret = mgmt_set_ip(phba, iface_param, (struct iscsi_iface_param_info *)0, 1U);
  }
#line 467
  goto ldv_56684;
  switch_default: /* CIL Label */ 
#line 469
  log_value = phba->attr_log_enable;
#line 469
  if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 469
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Param %d not supported\n",
               471, (int )iface_param->param);
    }
  } else {

  }
  switch_break: /* CIL Label */ ;
  }
  ldv_56684: ;
#line 474
  return (ret);
}
}
#line 477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int be2iscsi_iface_set_param(struct Scsi_Host *shost , void *data , uint32_t dt_len ) 
{ 
  struct iscsi_iface_param_info *iface_param ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  struct nlattr *attrib ;
  uint32_t rm_len ;
  int ret ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  int tmp___1 ;

  {
  {
#line 480
  iface_param = (struct iscsi_iface_param_info *)0;
#line 481
  tmp = shost_priv(shost);
#line 481
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 483
  rm_len = dt_len;
#line 484
  ret = 0;
  }
#line 486
  if ((phba->state & 4U) != 0U) {
#line 487
    log_value = phba->attr_log_enable;
#line 487
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 487
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 488);
      }
    } else {

    }
#line 489
    return (-16);
  } else {

  }
#line 492
  attrib = (struct nlattr *)data;
#line 492
  rm_len = dt_len;
#line 492
  goto ldv_56707;
  ldv_56706: 
  {
#line 493
  tmp___0 = nla_data((struct nlattr  const  *)attrib);
#line 493
  iface_param = (struct iscsi_iface_param_info *)tmp___0;
  }
#line 495
  if ((unsigned int )iface_param->param_type != 2U) {
#line 496
    goto ldv_56699;
  } else {

  }
#line 501
  if (iface_param->iface_num != 0U) {
#line 502
    log_value___0 = phba->attr_log_enable;
#line 502
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 502
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Invalid iface_num %d.Only iface_num 0 is supported.\n",
                 505, iface_param->iface_num);
      }
    } else {

    }
#line 507
    return (-22);
  } else {

  }
  {
#line 511
  if ((int )iface_param->iface_type == 1) {
#line 511
    goto case_1;
  } else {

  }
#line 515
  if ((int )iface_param->iface_type == 2) {
#line 515
    goto case_2;
  } else {

  }
#line 519
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 512
  ret = beiscsi_set_ipv4(shost, iface_param, data, dt_len);
  }
#line 514
  goto ldv_56702;
  case_2: /* CIL Label */ 
  {
#line 516
  ret = beiscsi_set_ipv6(shost, iface_param, data, dt_len);
  }
#line 518
  goto ldv_56702;
  switch_default: /* CIL Label */ 
#line 520
  log_value___1 = phba->attr_log_enable;
#line 520
  if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 520
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Invalid iface type :%d passed\n",
               522, (int )iface_param->iface_type);
    }
  } else {

  }
#line 523
  goto ldv_56702;
  switch_break: /* CIL Label */ ;
  }
  ldv_56702: ;
#line 526
  if (ret != 0) {
#line 527
    return (ret);
  } else {

  }
  ldv_56699: 
  {
#line 492
  attrib = nla_next((struct nlattr  const  *)attrib, (int *)(& rm_len));
  }
  ldv_56707: 
  {
#line 492
  tmp___1 = nla_ok((struct nlattr  const  *)attrib, (int )rm_len);
  }
#line 492
  if (tmp___1 != 0) {
#line 494
    goto ldv_56706;
  } else {

  }

#line 530
  return (ret);
}
}
#line 533 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int be2iscsi_get_if_param(struct beiscsi_hba *phba , struct iscsi_iface *iface ,
                                 int param , char *buf ) 
{ 
  struct be_cmd_get_if_info_resp *if_info ;
  int len ;
  int ip_type ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 538
  ip_type = 1;
#line 540
  if (iface->iface_type == 2U) {
#line 541
    ip_type = 16;
  } else {

  }
  {
#line 543
  len = mgmt_get_if_info(phba, ip_type, & if_info);
  }
#line 544
  if (len != 0) {
#line 545
    return (len);
  } else {

  }
  {
#line 548
  if (param == 1) {
#line 548
    goto case_1;
  } else {

  }
#line 551
  if (param == 7) {
#line 551
    goto case_7;
  } else {

  }
#line 554
  if (param == 4) {
#line 554
    goto case_4;
  } else {

  }
#line 560
  if (param == 2) {
#line 560
    goto case_2;
  } else {

  }
#line 563
  if (param == 15) {
#line 563
    goto case_15;
  } else {

  }
#line 568
  if (param == 13) {
#line 568
    goto case_13;
  } else {

  }
#line 576
  if (param == 14) {
#line 576
    goto case_14;
  } else {

  }
#line 584
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 549
  len = sprintf(buf, "%pI4\n", (u8 *)(& if_info->ip_addr.addr));
  }
#line 550
  goto ldv_56719;
  case_7: /* CIL Label */ 
  {
#line 552
  len = sprintf(buf, "%pI6\n", (u8 *)(& if_info->ip_addr.addr));
  }
#line 553
  goto ldv_56719;
  case_4: /* CIL Label */ ;
#line 555
  if (if_info->dhcp_state == 0U) {
    {
#line 556
    len = sprintf(buf, "static\n");
    }
  } else {
    {
#line 558
    len = sprintf(buf, "dhcp\n");
    }
  }
#line 559
  goto ldv_56719;
  case_2: /* CIL Label */ 
  {
#line 561
  len = sprintf(buf, "%pI4\n", (u8 *)(& if_info->ip_addr.subnet_mask));
  }
#line 562
  goto ldv_56719;
  case_15: /* CIL Label */ 
  {
#line 564
  len = sprintf(buf, "%s\n", if_info->vlan_priority == 65535U ? (char *)"Disabled\n" : (char *)"Enabled\n");
  }
#line 567
  goto ldv_56719;
  case_13: /* CIL Label */ ;
#line 569
  if (if_info->vlan_priority == 65535U) {
#line 570
    len = -22;
  } else {
    {
#line 572
    len = sprintf(buf, "%d\n", if_info->vlan_priority & 4095U);
    }
  }
#line 575
  goto ldv_56719;
  case_14: /* CIL Label */ ;
#line 577
  if (if_info->vlan_priority == 65535U) {
#line 578
    len = -22;
  } else {
    {
#line 580
    len = sprintf(buf, "%d\n", (if_info->vlan_priority >> 13) & 7U);
    }
  }
#line 583
  goto ldv_56719;
  switch_default: /* CIL Label */ 
  {
#line 585
  __ret_warn_on = 1;
#line 585
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 585
  if (tmp != 0L) {
    {
#line 585
    warn_slowpath_null("drivers/scsi/be2iscsi/be_iscsi.c", 585);
    }
  } else {

  }
  {
#line 585
  __builtin_expect(__ret_warn_on != 0, 0L);
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_56719: 
  {
#line 588
  kfree((void const   *)if_info);
  }
#line 589
  return (len);
}
}
#line 592 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int be2iscsi_iface_get_param(struct iscsi_iface *iface , enum iscsi_param_type param_type ,
                             int param , char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct Scsi_Host *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  struct be_cmd_get_def_gateway_resp gateway ;
  int len ;
  uint32_t log_value ;

  {
  {
#line 596
  tmp = dev_to_shost(iface->dev.parent);
#line 596
  shost = tmp;
#line 597
  tmp___0 = shost_priv(shost);
#line 597
  phba = (struct beiscsi_hba *)tmp___0 + 224U;
#line 599
  len = -38;
  }
#line 601
  if ((phba->state & 4U) != 0U) {
#line 602
    log_value = phba->attr_log_enable;
#line 602
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 602
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 603);
      }
    } else {

    }
#line 604
    return (-16);
  } else {

  }
  {
#line 608
  if (param == 1) {
#line 608
    goto case_1;
  } else {

  }
#line 609
  if (param == 2) {
#line 609
    goto case_2;
  } else {

  }
#line 610
  if (param == 4) {
#line 610
    goto case_4;
  } else {

  }
#line 611
  if (param == 7) {
#line 611
    goto case_7;
  } else {

  }
#line 612
  if (param == 15) {
#line 612
    goto case_15;
  } else {

  }
#line 613
  if (param == 13) {
#line 613
    goto case_13;
  } else {

  }
#line 614
  if (param == 14) {
#line 614
    goto case_14;
  } else {

  }
#line 617
  if (param == 12) {
#line 617
    goto case_12;
  } else {

  }
#line 620
  if (param == 3) {
#line 620
    goto case_3;
  } else {

  }
#line 626
  goto switch_default;
  case_1: /* CIL Label */ ;
  case_2: /* CIL Label */ ;
  case_4: /* CIL Label */ ;
  case_7: /* CIL Label */ ;
  case_15: /* CIL Label */ ;
  case_13: /* CIL Label */ ;
  case_14: /* CIL Label */ 
  {
#line 615
  len = be2iscsi_get_if_param(phba, iface, param, buf);
  }
#line 616
  goto ldv_56747;
  case_12: /* CIL Label */ 
  {
#line 618
  len = sprintf(buf, "enabled\n");
  }
#line 619
  goto ldv_56747;
  case_3: /* CIL Label */ 
  {
#line 621
  __memset((void *)(& gateway), 0, 40UL);
#line 622
  len = mgmt_get_gateway(phba, 1, & gateway);
  }
#line 623
  if (len == 0) {
    {
#line 624
    len = sprintf(buf, "%pI4\n", & gateway.ip_addr.addr);
    }
  } else {

  }
#line 625
  goto ldv_56747;
  switch_default: /* CIL Label */ 
#line 627
  len = -38;
  switch_break: /* CIL Label */ ;
  }
  ldv_56747: ;
#line 630
  return (len);
}
}
#line 641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_ep_get_param(struct iscsi_endpoint *ep , enum iscsi_param param , char *buf ) 
{ 
  struct beiscsi_endpoint *beiscsi_ep ;
  int len ;
  uint32_t log_value ;

  {
#line 644
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 645
  len = 0;
#line 647
  log_value = (beiscsi_ep->phba)->attr_log_enable;
#line 647
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 647
    dev_printk("\016", (struct device  const  *)(& ((beiscsi_ep->phba)->shost)->shost_gendev),
               "BS_%d : In beiscsi_ep_get_param, param= %d\n", 650, (unsigned int )param);
    }
  } else {

  }
  {
#line 653
  if ((unsigned int )param == 20U) {
#line 653
    goto case_20;
  } else {

  }
#line 656
  if ((unsigned int )param == 21U) {
#line 656
    goto case_21;
  } else {

  }
#line 662
  goto switch_default;
  case_20: /* CIL Label */ 
  {
#line 654
  len = sprintf(buf, "%hu\n", (int )beiscsi_ep->dst_tcpport);
  }
#line 655
  goto ldv_56760;
  case_21: /* CIL Label */ ;
#line 657
  if ((unsigned int )beiscsi_ep->ip_type == 1U) {
    {
#line 658
    len = sprintf(buf, "%pI4\n", & beiscsi_ep->dst_addr);
    }
  } else {
    {
#line 660
    len = sprintf(buf, "%pI6\n", & beiscsi_ep->dst6_addr);
    }
  }
#line 661
  goto ldv_56760;
  switch_default: /* CIL Label */ ;
#line 663
  return (-38);
  switch_break: /* CIL Label */ ;
  }
  ldv_56760: ;
#line 665
  return (len);
}
}
#line 668 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_set_param(struct iscsi_cls_conn *cls_conn , enum iscsi_param param , char *buf ,
                      int buflen ) 
{ 
  struct iscsi_conn *conn ;
  struct iscsi_session *session ;
  struct beiscsi_hba *phba ;
  int ret ;
  uint32_t log_value ;

  {
#line 671
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 672
  session = conn->session;
#line 673
  phba = (struct beiscsi_hba *)0;
#line 676
  phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
#line 677
  log_value = phba->attr_log_enable;
#line 677
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 677
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_conn_set_param, param= %d\n",
               679, (unsigned int )param);
    }
  } else {

  }
  {
#line 681
  ret = iscsi_set_param(cls_conn, param, buf, buflen);
  }
#line 682
  if (ret != 0) {
#line 683
    return (ret);
  } else {

  }
  {
#line 689
  if ((unsigned int )param == 7U) {
#line 689
    goto case_7;
  } else {

  }
#line 693
  if ((unsigned int )param == 0U) {
#line 693
    goto case_0;
  } else {

  }
#line 697
  if ((unsigned int )param == 8U) {
#line 697
    goto case_8;
  } else {

  }
#line 701
  if ((unsigned int )param == 1U) {
#line 701
    goto case_1;
  } else {

  }
#line 704
  goto switch_default;
  case_7: /* CIL Label */ ;
#line 690
  if (session->first_burst > 8192U) {
#line 691
    session->first_burst = 8192U;
  } else {

  }
#line 692
  goto ldv_56775;
  case_0: /* CIL Label */ ;
#line 694
  if (conn->max_recv_dlength > 65536U) {
#line 695
    conn->max_recv_dlength = 65536U;
  } else {

  }
#line 696
  goto ldv_56775;
  case_8: /* CIL Label */ ;
#line 698
  if (session->max_burst > 262144U) {
#line 699
    session->max_burst = 262144U;
  } else {

  }
#line 700
  goto ldv_56775;
  case_1: /* CIL Label */ ;
#line 702
  if (conn->max_xmit_dlength > 65536U) {
#line 703
    conn->max_xmit_dlength = 65536U;
  } else {

  }
  switch_default: /* CIL Label */ ;
#line 705
  return (0);
  switch_break: /* CIL Label */ ;
  }
  ldv_56775: ;
#line 708
  return (0);
}
}
#line 718 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_get_initname(char *buf , struct beiscsi_hba *phba ) 
{ 
  int rc ;
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_hba_name *resp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  void *tmp ;

  {
  {
#line 725
  tag = be_cmd_get_initname(phba);
  }
#line 726
  if (tag == 0U) {
#line 727
    log_value = phba->attr_log_enable;
#line 727
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 727
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Getting Initiator Name Failed\n",
                 728);
      }
    } else {

    }
#line 730
    return (-16);
  } else {

  }
  {
#line 733
  rc = beiscsi_mccq_compl(phba, tag, & wrb, (struct be_dma_mem *)0);
  }
#line 734
  if (rc != 0) {
#line 735
    log_value___0 = phba->attr_log_enable;
#line 735
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 735
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Initiator Name MBX Failed\n",
                 737);
      }
    } else {

    }
#line 738
    return (rc);
  } else {

  }
  {
#line 741
  tmp = embedded_payload(wrb);
#line 741
  resp = (struct be_cmd_hba_name *)tmp;
#line 742
  rc = sprintf(buf, "%s\n", (u8 *)(& resp->initiator_name));
  }
#line 743
  return (rc);
}
}
#line 751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_get_port_state(struct Scsi_Host *shost ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  struct iscsi_cls_host *ihost ;

  {
  {
#line 753
  tmp = shost_priv(shost);
#line 753
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 754
  ihost = (struct iscsi_cls_host *)shost->shost_data;
#line 756
  ihost->port_state = phba->state == 1U ? 2U : 1U;
  }
#line 757
  return;
}
}
#line 766 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_get_port_speed(struct Scsi_Host *shost ) 
{ 
  int rc ;
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_ntwk_link_status_resp *resp ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  struct iscsi_cls_host *ihost ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  void *tmp___0 ;

  {
  {
#line 772
  tmp = shost_priv(shost);
#line 772
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 773
  ihost = (struct iscsi_cls_host *)shost->shost_data;
#line 775
  tag = be_cmd_get_port_speed(phba);
  }
#line 776
  if (tag == 0U) {
#line 777
    log_value = phba->attr_log_enable;
#line 777
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 777
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Getting Port Speed Failed\n",
                 778);
      }
    } else {

    }
#line 780
    return (-16);
  } else {

  }
  {
#line 782
  rc = beiscsi_mccq_compl(phba, tag, & wrb, (struct be_dma_mem *)0);
  }
#line 783
  if (rc != 0) {
#line 784
    log_value___0 = phba->attr_log_enable;
#line 784
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 784
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Port Speed MBX Failed\n",
                 786);
      }
    } else {

    }
#line 787
    return (rc);
  } else {

  }
  {
#line 789
  tmp___0 = embedded_payload(wrb);
#line 789
  resp = (struct be_cmd_ntwk_link_status_resp *)tmp___0;
  }
  {
#line 792
  if ((int )resp->mac_speed == 1) {
#line 792
    goto case_1;
  } else {

  }
#line 795
  if ((int )resp->mac_speed == 2) {
#line 795
    goto case_2;
  } else {

  }
#line 798
  if ((int )resp->mac_speed == 3) {
#line 798
    goto case_3;
  } else {

  }
#line 801
  if ((int )resp->mac_speed == 4) {
#line 801
    goto case_4;
  } else {

  }
#line 804
  goto switch_default;
  case_1: /* CIL Label */ 
#line 793
  ihost->port_speed = 2U;
#line 794
  goto ldv_56807;
  case_2: /* CIL Label */ 
#line 796
  ihost->port_speed = 4U;
#line 797
  goto ldv_56807;
  case_3: /* CIL Label */ 
#line 799
  ihost->port_speed = 8U;
#line 800
  goto ldv_56807;
  case_4: /* CIL Label */ 
#line 802
  ihost->port_speed = 16U;
#line 803
  goto ldv_56807;
  switch_default: /* CIL Label */ 
#line 805
  ihost->port_speed = 1U;
  switch_break: /* CIL Label */ ;
  }
  ldv_56807: ;
#line 807
  return (0);
}
}
#line 818 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_get_host_param(struct Scsi_Host *shost , enum iscsi_host_param param ,
                           char *buf ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  int status ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  char *tmp___0 ;
  uint32_t log_value___3 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 821
  tmp = shost_priv(shost);
#line 821
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 822
  status = 0;
  }
#line 825
  if ((phba->state & 4U) != 0U) {
#line 826
    log_value = phba->attr_log_enable;
#line 826
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 826
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 827);
      }
    } else {

    }
#line 828
    return (-16);
  } else {
#line 830
    log_value___0 = phba->attr_log_enable;
#line 830
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 830
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : In beiscsi_get_host_param, param = %d\n", 832, (unsigned int )param);
      }
    } else {

    }
  }
  {
#line 836
  if ((unsigned int )param == 0U) {
#line 836
    goto case_0;
  } else {

  }
#line 844
  if ((unsigned int )param == 1U) {
#line 844
    goto case_1;
  } else {

  }
#line 852
  if ((unsigned int )param == 4U) {
#line 852
    goto case_4;
  } else {

  }
#line 856
  if ((unsigned int )param == 5U) {
#line 856
    goto case_5;
  } else {

  }
#line 865
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 837
  status = beiscsi_get_macaddr(buf, phba);
  }
#line 838
  if (status < 0) {
#line 839
    log_value___1 = phba->attr_log_enable;
#line 839
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 839
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : beiscsi_get_macaddr Failed\n",
                 840);
      }
    } else {

    }
#line 841
    return (status);
  } else {

  }
#line 843
  goto ldv_56823;
  case_1: /* CIL Label */ 
  {
#line 845
  status = beiscsi_get_initname(buf, phba);
  }
#line 846
  if (status < 0) {
#line 847
    log_value___2 = phba->attr_log_enable;
#line 847
    if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 847
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Retreiving Initiator Name Failed\n",
                 848);
      }
    } else {

    }
#line 849
    return (status);
  } else {

  }
#line 851
  goto ldv_56823;
  case_4: /* CIL Label */ 
  {
#line 853
  beiscsi_get_port_state(shost);
#line 854
  tmp___0 = iscsi_get_port_state_name(shost);
#line 854
  status = sprintf(buf, "%s\n", tmp___0);
  }
#line 855
  goto ldv_56823;
  case_5: /* CIL Label */ 
  {
#line 857
  status = beiscsi_get_port_speed(shost);
  }
#line 858
  if (status != 0) {
#line 859
    log_value___3 = phba->attr_log_enable;
#line 859
    if ((log_value___3 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 859
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Retreiving Port Speed Failed\n",
                 860);
      }
    } else {

    }
#line 861
    return (status);
  } else {

  }
  {
#line 863
  tmp___1 = iscsi_get_port_speed_name(shost);
#line 863
  status = sprintf(buf, "%s\n", tmp___1);
  }
#line 864
  goto ldv_56823;
  switch_default: /* CIL Label */ 
  {
#line 866
  tmp___2 = iscsi_host_get_param(shost, param, buf);
  }
#line 866
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
  ldv_56823: ;
#line 868
  return (status);
}
}
#line 871 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_get_macaddr(char *buf , struct beiscsi_hba *phba ) 
{ 
  struct be_cmd_get_nic_conf_resp resp ;
  int rc ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 876
  if ((int )phba->mac_addr_set) {
    {
#line 877
    tmp = sysfs_format_mac(buf, (unsigned char const   *)(& phba->mac_address), 6);
    }
#line 877
    return ((int )tmp);
  } else {

  }
  {
#line 879
  __memset((void *)(& resp), 0, 136UL);
#line 880
  rc = mgmt_get_nic_conf(phba, & resp);
  }
#line 881
  if (rc != 0) {
#line 882
    return (rc);
  } else {

  }
  {
#line 884
  phba->mac_addr_set = 1;
#line 885
  __memcpy((void *)(& phba->mac_address), (void const   *)(& resp.mac_address), 6UL);
#line 886
  tmp___0 = sysfs_format_mac(buf, (unsigned char const   *)(& phba->mac_address),
                             6);
  }
#line 886
  return ((int )tmp___0);
}
}
#line 896 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn , struct iscsi_stats *stats ) 
{ 
  struct iscsi_conn *conn ;
  struct beiscsi_hba *phba ;
  uint32_t log_value ;

  {
#line 899
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 900
  phba = (struct beiscsi_hba *)0;
#line 902
  phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
#line 903
  log_value = phba->attr_log_enable;
#line 903
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 903
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_conn_get_stats\n",
               904);
    }
  } else {

  }
  {
#line 906
  stats->txdata_octets = conn->txdata_octets;
#line 907
  stats->rxdata_octets = conn->rxdata_octets;
#line 908
  stats->dataout_pdus = conn->dataout_pdus_cnt;
#line 909
  stats->scsirsp_pdus = conn->scsirsp_pdus_cnt;
#line 910
  stats->scsicmd_pdus = conn->scsicmd_pdus_cnt;
#line 911
  stats->datain_pdus = conn->datain_pdus_cnt;
#line 912
  stats->tmfrsp_pdus = (uint32_t )conn->tmfrsp_pdus_cnt;
#line 913
  stats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;
#line 914
  stats->r2t_pdus = conn->r2t_pdus_cnt;
#line 915
  stats->digest_err = 0U;
#line 916
  stats->timeout_err = 0U;
#line 917
  stats->custom_length = 1U;
#line 918
  strcpy((char *)(& stats->custom[0].desc), "eh_abort_cnt");
#line 919
  stats->custom[0].value = (uint64_t )conn->eh_abort_cnt;
  }
#line 920
  return;
}
}
#line 927 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_set_params_for_offld(struct beiscsi_conn *beiscsi_conn , struct beiscsi_offload_params *params ) 
{ 
  struct iscsi_conn *conn ;
  struct iscsi_session *session ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;

  {
  {
#line 930
  conn = beiscsi_conn->conn;
#line 931
  session = conn->session;
#line 933
  tmp = amap_mask(32U);
#line 933
  amap_set((void *)params, 0U, tmp, 0U, session->max_burst);
#line 935
  tmp___0 = amap_mask(32U);
#line 935
  amap_set((void *)params, 1U, tmp___0, 0U, conn->max_xmit_dlength);
#line 938
  tmp___1 = amap_mask(32U);
#line 938
  amap_set((void *)params, 2U, tmp___1, 0U, session->first_burst);
#line 940
  tmp___2 = amap_mask(2U);
#line 940
  amap_set((void *)params, 3U, tmp___2, 0U, (u32 )session->erl);
#line 942
  tmp___3 = amap_mask(1U);
#line 942
  amap_set((void *)params, 3U, tmp___3, 2U, (u32 )conn->datadgst_en);
#line 944
  tmp___4 = amap_mask(1U);
#line 944
  amap_set((void *)params, 3U, tmp___4, 3U, (u32 )conn->hdrdgst_en);
#line 946
  tmp___5 = amap_mask(1U);
#line 946
  amap_set((void *)params, 3U, tmp___5, 4U, (u32 )session->initial_r2t_en);
#line 948
  tmp___6 = amap_mask(1U);
#line 948
  amap_set((void *)params, 3U, tmp___6, 5U, (u32 )session->imm_data_en);
#line 950
  tmp___7 = amap_mask(1U);
#line 950
  amap_set((void *)params, 3U, tmp___7, 6U, (u32 )session->dataseq_inorder_en);
#line 953
  tmp___8 = amap_mask(1U);
#line 953
  amap_set((void *)params, 3U, tmp___8, 7U, (u32 )session->pdu_inorder_en);
#line 956
  tmp___9 = amap_mask(16U);
#line 956
  amap_set((void *)params, 3U, tmp___9, 8U, (u32 )session->max_r2t);
#line 958
  tmp___10 = amap_mask(32U);
#line 958
  amap_set((void *)params, 4U, tmp___10, 0U, conn->exp_statsn - 1U);
#line 960
  tmp___11 = amap_mask(32U);
#line 960
  amap_set((void *)params, 5U, tmp___11, 0U, conn->max_recv_dlength);
  }
#line 961
  return;
}
}
#line 970 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_conn_start(struct iscsi_cls_conn *cls_conn ) 
{ 
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct beiscsi_offload_params params ;
  struct beiscsi_hba *phba ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 972
  conn = (struct iscsi_conn *)cls_conn->dd_data;
#line 973
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 978
  phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
#line 980
  if ((phba->state & 4U) != 0U) {
#line 981
    log_value = phba->attr_log_enable;
#line 981
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 981
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 982);
      }
    } else {

    }
#line 983
    return (-16);
  } else {
#line 985
    log_value___0 = (beiscsi_conn->phba)->attr_log_enable;
#line 985
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 985
      dev_printk("\016", (struct device  const  *)(& ((beiscsi_conn->phba)->shost)->shost_gendev),
                 "BS_%d : In beiscsi_conn_start\n", 987);
      }
    } else {

    }
  }
  {
#line 990
  __memset((void *)(& params), 0, 24UL);
#line 991
  beiscsi_ep = beiscsi_conn->ep;
  }
#line 992
  if ((unsigned long )beiscsi_ep == (unsigned long )((struct beiscsi_endpoint *)0)) {
#line 993
    log_value___1 = (beiscsi_conn->phba)->attr_log_enable;
#line 993
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 993
      dev_printk("\v", (struct device  const  *)(& ((beiscsi_conn->phba)->shost)->shost_gendev),
                 "BS_%d : In beiscsi_conn_start , no beiscsi_ep\n", 995);
      }
    } else {

    }
  } else {

  }
  {
#line 997
  beiscsi_conn->login_in_progress = 0U;
#line 998
  beiscsi_set_params_for_offld(beiscsi_conn, & params);
#line 999
  beiscsi_offload_connection(beiscsi_conn, & params);
#line 1000
  iscsi_conn_start(cls_conn);
  }
#line 1001
  return (0);
}
}
#line 1008 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_get_cid(struct beiscsi_hba *phba ) 
{ 
  unsigned short cid ;
  unsigned short cid_from_ulp ;
  struct ulp_cid_info *cid_info ;
  uint16_t cid_avlbl_ulp0 ;
  uint16_t cid_avlbl_ulp1 ;
  unsigned short tmp ;
  int tmp___1 ;

  {
  {
#line 1010
  cid = 65535U;
#line 1011
  cid_info = (struct ulp_cid_info *)0;
#line 1015
  cid_avlbl_ulp0 = (unsigned long )phba->cid_array_info[0] != (unsigned long )((struct ulp_cid_info *)0) ? (phba->cid_array_info[0])->avlbl_cids : 0U;
#line 1017
  cid_avlbl_ulp1 = (unsigned long )phba->cid_array_info[1] != (unsigned long )((struct ulp_cid_info *)0) ? (phba->cid_array_info[1])->avlbl_cids : 0U;
#line 1019
  cid_from_ulp = (int )cid_avlbl_ulp0 <= (int )cid_avlbl_ulp1;
#line 1022
  tmp___1 = variable_test_bit((long )cid_from_ulp, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 1022
  if (tmp___1 != 0) {
#line 1023
    cid_info = phba->cid_array_info[(int )cid_from_ulp];
#line 1024
    if ((unsigned int )cid_info->avlbl_cids == 0U) {
#line 1025
      return ((int )cid);
    } else {

    }
#line 1027
    tmp = cid_info->cid_alloc;
#line 1027
    cid_info->cid_alloc = (unsigned short )((int )cid_info->cid_alloc + 1);
#line 1027
    cid = *(cid_info->cid_array + (unsigned long )tmp);
#line 1029
    if ((unsigned int )cid_info->cid_alloc == phba->fw_config.iscsi_cid_count[(int )cid_from_ulp]) {
#line 1031
      cid_info->cid_alloc = 0U;
    } else {

    }
#line 1033
    cid_info->avlbl_cids = (unsigned short )((int )cid_info->avlbl_cids - 1);
  } else {

  }
#line 1035
  return ((int )cid);
}
}
#line 1043 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_put_cid(struct beiscsi_hba *phba , unsigned short cid ) 
{ 
  uint16_t cid_post_ulp ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_wrb_context *pwrb_context ;
  struct ulp_cid_info *cid_info ;
  uint16_t cri_index ;
  unsigned short tmp ;

  {
#line 1048
  cid_info = (struct ulp_cid_info *)0;
#line 1049
  cri_index = phba->cid_to_cri_map[(int )cid];
#line 1051
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1052
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 1053
  cid_post_ulp = (uint16_t )pwrb_context->ulp_num;
#line 1055
  cid_info = phba->cid_array_info[(int )cid_post_ulp];
#line 1056
  cid_info->avlbl_cids = (unsigned short )((int )cid_info->avlbl_cids + 1);
#line 1058
  tmp = cid_info->cid_free;
#line 1058
  cid_info->cid_free = (unsigned short )((int )cid_info->cid_free + 1);
#line 1058
  *(cid_info->cid_array + (unsigned long )tmp) = cid;
#line 1059
  if ((unsigned int )cid_info->cid_free == phba->fw_config.iscsi_cid_count[(int )cid_post_ulp]) {
#line 1060
    cid_info->cid_free = 0U;
  } else {

  }
#line 1061
  return;
}
}
#line 1067 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep ) 
{ 
  struct beiscsi_hba *phba ;
  struct beiscsi_conn *beiscsi_conn ;

  {
  {
#line 1069
  phba = beiscsi_ep->phba;
#line 1072
  beiscsi_put_cid(phba, (int )beiscsi_ep->ep_cid);
#line 1073
  beiscsi_ep->phba = (struct beiscsi_hba *)0;
#line 1074
  *(phba->ep_array + (unsigned long )phba->cid_to_cri_map[(int )beiscsi_ep->ep_cid]) = (struct iscsi_endpoint *)0;
  }
#line 1082
  if ((unsigned long )beiscsi_ep->conn == (unsigned long )((struct beiscsi_conn *)0)) {
#line 1083
    return;
  } else {

  }
#line 1085
  beiscsi_conn = beiscsi_ep->conn;
#line 1086
  if ((unsigned int )beiscsi_conn->login_in_progress != 0U) {
    {
#line 1087
    beiscsi_free_mgmt_task_handles(beiscsi_conn, beiscsi_conn->task);
#line 1089
    beiscsi_conn->login_in_progress = 0U;
    }
  } else {

  }
#line 1091
  return;
}
}
#line 1101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_open_conn(struct iscsi_endpoint *ep , struct sockaddr *src_addr ,
                             struct sockaddr *dst_addr , int non_blocking ) 
{ 
  struct beiscsi_endpoint *beiscsi_ep ;
  struct beiscsi_hba *phba ;
  struct tcp_connect_and_offload_out *ptcpcnct_out ;
  struct be_dma_mem nonemb_cmd ;
  unsigned int tag ;
  unsigned int req_memsize ;
  int ret ;
  uint32_t log_value ;
  int tmp ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  int tmp___0 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;

  {
#line 1105
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1106
  phba = beiscsi_ep->phba;
#line 1110
  ret = -12;
#line 1112
  log_value = phba->attr_log_enable;
#line 1112
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1112
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_open_conn\n",
               1113);
    }
  } else {

  }
  {
#line 1115
  tmp = beiscsi_get_cid(phba);
#line 1115
  beiscsi_ep->ep_cid = (unsigned short )tmp;
  }
#line 1116
  if ((unsigned int )beiscsi_ep->ep_cid == 65535U) {
#line 1117
    log_value___0 = phba->attr_log_enable;
#line 1117
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1117
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : No free cid available\n",
                 1118);
      }
    } else {

    }
#line 1119
    return (ret);
  } else {

  }
#line 1122
  log_value___1 = phba->attr_log_enable;
#line 1122
  if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1122
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_open_conn, ep_cid=%d\n",
               1124, (int )beiscsi_ep->ep_cid);
    }
  } else {

  }
#line 1126
  *(phba->ep_array + (unsigned long )phba->cid_to_cri_map[(int )beiscsi_ep->ep_cid]) = ep;
#line 1129
  beiscsi_ep->cid_vld = 0U;
#line 1131
  if (phba->generation - 2U <= 1U) {
#line 1132
    req_memsize = 64U;
  } else {
#line 1134
    req_memsize = 72U;
  }
  {
#line 1136
  nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev, (size_t )req_memsize, & nonemb_cmd.dma);
  }
#line 1139
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 1141
    log_value___2 = phba->attr_log_enable;
#line 1141
    if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1141
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Failed to allocate memory for mgmt_open_connection\n",
                 1143);
      }
    } else {

    }
    {
#line 1145
    beiscsi_free_ep(beiscsi_ep);
    }
#line 1146
    return (-12);
  } else {

  }
  {
#line 1148
  nonemb_cmd.size = req_memsize;
#line 1149
  __memset(nonemb_cmd.va, 0, (size_t )nonemb_cmd.size);
#line 1150
  tmp___0 = mgmt_open_connection(phba, dst_addr, beiscsi_ep, & nonemb_cmd);
#line 1150
  tag = (unsigned int )tmp___0;
  }
#line 1151
  if (tag == 0U) {
#line 1152
    log_value___3 = phba->attr_log_enable;
#line 1152
    if ((log_value___3 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1152
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : mgmt_open_connection Failed for cid=%d\n",
                 1154, (int )beiscsi_ep->ep_cid);
      }
    } else {

    }
    {
#line 1156
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
#line 1158
    beiscsi_free_ep(beiscsi_ep);
    }
#line 1159
    return (-11);
  } else {

  }
  {
#line 1162
  ret = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, & nonemb_cmd);
  }
#line 1163
  if (ret != 0) {
#line 1164
    log_value___4 = phba->attr_log_enable;
#line 1164
    if ((log_value___4 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1164
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : mgmt_open_connection Failed",
                 1166);
      }
    } else {

    }
#line 1168
    if (ret != -16) {
      {
#line 1169
      pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                          nonemb_cmd.dma);
      }
    } else {

    }
    {
#line 1172
    beiscsi_free_ep(beiscsi_ep);
    }
#line 1173
    return (ret);
  } else {

  }
#line 1176
  ptcpcnct_out = (struct tcp_connect_and_offload_out *)nonemb_cmd.va;
#line 1177
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1178
  beiscsi_ep->fw_handle = ptcpcnct_out->connection_handle;
#line 1179
  beiscsi_ep->cid_vld = 1U;
#line 1180
  log_value___5 = phba->attr_log_enable;
#line 1180
  if ((log_value___5 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1180
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : mgmt_open_connection Success\n",
               1181);
    }
  } else {

  }
  {
#line 1183
  pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va, nonemb_cmd.dma);
  }
#line 1185
  return (0);
}
}
#line 1197 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
struct iscsi_endpoint *beiscsi_ep_connect(struct Scsi_Host *shost , struct sockaddr *dst_addr ,
                                          int non_blocking ) 
{ 
  struct beiscsi_hba *phba ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct iscsi_endpoint *ep ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  uint32_t log_value ;
  void *tmp___1 ;
  bool tmp___2 ;
  uint32_t log_value___0 ;
  void *tmp___3 ;
  uint32_t log_value___1 ;
  void *tmp___4 ;
  void *tmp___5 ;
  uint32_t log_value___2 ;
  void *tmp___6 ;

  {
#line 1205
  if ((unsigned long )shost != (unsigned long )((struct Scsi_Host *)0)) {
    {
#line 1206
    tmp = shost_priv(shost);
#line 1206
    phba = (struct beiscsi_hba *)tmp + 224U;
    }
  } else {
    {
#line 1208
    ret = -6;
#line 1209
    printk("\vbeiscsi_ep_connect shost is NULL\n");
#line 1211
    tmp___0 = ERR_PTR((long )ret);
    }
#line 1211
    return ((struct iscsi_endpoint *)tmp___0);
  }
  {
#line 1214
  tmp___2 = beiscsi_error(phba);
  }
#line 1214
  if ((int )tmp___2) {
#line 1215
    ret = -5;
#line 1216
    log_value = phba->attr_log_enable;
#line 1216
    if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 1216
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : The FW state Not Stable!!!\n",
                 1217);
      }
    } else {

    }
    {
#line 1218
    tmp___1 = ERR_PTR((long )ret);
    }
#line 1218
    return ((struct iscsi_endpoint *)tmp___1);
  } else {

  }
#line 1221
  if ((phba->state & 4U) != 0U) {
#line 1222
    ret = -16;
#line 1223
    log_value___0 = phba->attr_log_enable;
#line 1223
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1223
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In PCI_ERROR Recovery\n",
                 1224);
      }
    } else {

    }
    {
#line 1225
    tmp___3 = ERR_PTR((long )ret);
    }
#line 1225
    return ((struct iscsi_endpoint *)tmp___3);
  } else
#line 1226
  if ((phba->state & 2U) != 0U) {
#line 1227
    ret = -16;
#line 1228
    log_value___1 = phba->attr_log_enable;
#line 1228
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 1228
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : The Adapter Port state is Down!!!\n",
                 1229);
      }
    } else {

    }
    {
#line 1230
    tmp___4 = ERR_PTR((long )ret);
    }
#line 1230
    return ((struct iscsi_endpoint *)tmp___4);
  } else {

  }
  {
#line 1233
  ep = iscsi_create_endpoint(128);
  }
#line 1234
  if ((unsigned long )ep == (unsigned long )((struct iscsi_endpoint *)0)) {
    {
#line 1235
    ret = -12;
#line 1236
    tmp___5 = ERR_PTR((long )ret);
    }
#line 1236
    return ((struct iscsi_endpoint *)tmp___5);
  } else {

  }
  {
#line 1239
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1240
  beiscsi_ep->phba = phba;
#line 1241
  beiscsi_ep->openiscsi_ep = ep;
#line 1242
  ret = beiscsi_open_conn(ep, (struct sockaddr *)0, dst_addr, non_blocking);
  }
#line 1243
  if (ret != 0) {
#line 1244
    log_value___2 = phba->attr_log_enable;
#line 1244
    if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1244
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : Failed in beiscsi_open_conn\n",
                 1245);
      }
    } else {

    }
#line 1246
    goto free_ep;
  } else {

  }
#line 1249
  return (ep);
  free_ep: 
  {
#line 1252
  iscsi_destroy_endpoint(ep);
#line 1253
  tmp___6 = ERR_PTR((long )ret);
  }
#line 1253
  return ((struct iscsi_endpoint *)tmp___6);
}
}
#line 1263 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
int beiscsi_ep_poll(struct iscsi_endpoint *ep , int timeout_ms ) 
{ 
  struct beiscsi_endpoint *beiscsi_ep ;
  uint32_t log_value ;

  {
#line 1265
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1267
  log_value = (beiscsi_ep->phba)->attr_log_enable;
#line 1267
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1267
    dev_printk("\016", (struct device  const  *)(& ((beiscsi_ep->phba)->shost)->shost_gendev),
               "BS_%d : In  beiscsi_ep_poll\n", 1268);
    }
  } else {

  }
#line 1270
  if ((unsigned int )beiscsi_ep->cid_vld == 1U) {
#line 1271
    return (1);
  } else {
#line 1273
    return (0);
  }
}
}
#line 1283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static void beiscsi_flush_cq(struct beiscsi_hba *phba ) 
{ 
  uint16_t i ;
  struct be_eq_obj *pbe_eq ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;

  {
#line 1290
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1291
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 1293
  i = 0U;
#line 1293
  goto ldv_56930;
  ldv_56929: 
  {
#line 1294
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 1295
  blk_iopoll_disable(& pbe_eq->iopoll);
#line 1296
  beiscsi_process_cq(pbe_eq);
#line 1297
  blk_iopoll_enable(& pbe_eq->iopoll);
#line 1293
  i = (uint16_t )((int )i + 1);
  }
  ldv_56930: ;
#line 1293
  if ((unsigned int )i < phba->num_cpus) {
#line 1295
    goto ldv_56929;
  } else {

  }

#line 1300
  return;
}
}
#line 1306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_close_conn(struct beiscsi_endpoint *beiscsi_ep , int flag ) 
{ 
  int ret ;
  unsigned int tag ;
  struct beiscsi_hba *phba ;
  uint32_t log_value ;

  {
  {
#line 1308
  ret = 0;
#line 1310
  phba = beiscsi_ep->phba;
#line 1312
  tag = mgmt_upload_connection(phba, (int )beiscsi_ep->ep_cid, (unsigned int )flag);
  }
#line 1313
  if (tag == 0U) {
#line 1314
    log_value = phba->attr_log_enable;
#line 1314
    if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 1314
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : upload failed for cid 0x%x\n", 1316, (int )beiscsi_ep->ep_cid);
      }
    } else {

    }
#line 1318
    ret = -11;
  } else {

  }
  {
#line 1321
  ret = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
#line 1324
  beiscsi_flush_cq(phba);
  }
#line 1326
  return (ret);
}
}
#line 1334 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
static int beiscsi_unbind_conn_to_cid(struct beiscsi_hba *phba , unsigned int cid ) 
{ 
  uint16_t cri_index ;
  uint32_t log_value ;

  {
#line 1337
  cri_index = phba->cid_to_cri_map[cid];
#line 1339
  if ((unsigned long )*(phba->conn_table + (unsigned long )cri_index) != (unsigned long )((struct beiscsi_conn *)0)) {
#line 1340
    *(phba->conn_table + (unsigned long )cri_index) = (struct beiscsi_conn *)0;
  } else {
#line 1342
    log_value = phba->attr_log_enable;
#line 1342
    if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 1342
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BS_%d : Connection table Not occupied.\n", 1343);
      }
    } else {

    }
#line 1344
    return (-22);
  }
#line 1346
  return (0);
}
}
#line 1355 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
void beiscsi_ep_disconnect(struct iscsi_endpoint *ep ) 
{ 
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct beiscsi_hba *phba ;
  unsigned int tag ;
  uint8_t mgmt_invalidate_flag ;
  uint8_t tcp_upload_flag ;
  unsigned short savecfg_flag ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 1362
  savecfg_flag = 1U;
#line 1364
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 1365
  phba = beiscsi_ep->phba;
#line 1366
  log_value = phba->attr_log_enable;
#line 1366
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1366
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : In beiscsi_ep_disconnect for ep_cid = %d\n",
               1368, (int )beiscsi_ep->ep_cid);
    }
  } else {

  }
#line 1370
  if ((unsigned long )beiscsi_ep->conn != (unsigned long )((struct beiscsi_conn *)0)) {
    {
#line 1371
    beiscsi_conn = beiscsi_ep->conn;
#line 1372
    iscsi_suspend_queue(beiscsi_conn->conn);
#line 1373
    mgmt_invalidate_flag = 255U;
#line 1374
    tcp_upload_flag = 1U;
    }
  } else {
#line 1376
    mgmt_invalidate_flag = 0U;
#line 1377
    tcp_upload_flag = 3U;
  }
#line 1380
  if ((phba->state & 4U) != 0U) {
#line 1381
    log_value___0 = phba->attr_log_enable;
#line 1381
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1381
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : PCI_ERROR Recovery\n",
                 1382);
      }
    } else {

    }
#line 1383
    goto free_ep;
  } else {

  }
  {
#line 1386
  tag = mgmt_invalidate_connection(phba, beiscsi_ep, (int )beiscsi_ep->ep_cid, (int )mgmt_invalidate_flag,
                                   (int )savecfg_flag);
  }
#line 1390
  if (tag == 0U) {
#line 1391
    log_value___1 = phba->attr_log_enable;
#line 1391
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1391
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : mgmt_invalidate_connection Failed for cid=%d\n",
                 1393, (int )beiscsi_ep->ep_cid);
      }
    } else {

    }
  } else {

  }
  {
#line 1396
  beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
#line 1397
  beiscsi_close_conn(beiscsi_ep, (int )tcp_upload_flag);
  }
  free_ep: 
  {
#line 1399
  msleep(250U);
#line 1400
  beiscsi_free_ep(beiscsi_ep);
#line 1401
  beiscsi_unbind_conn_to_cid(phba, (unsigned int )beiscsi_ep->ep_cid);
#line 1402
  iscsi_destroy_endpoint(beiscsi_ep->openiscsi_ep);
  }
#line 1403
  return;
}
}
#line 1405 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_iscsi.c"
umode_t be2iscsi_attr_is_visible(int param_type , int param ) 
{ 


  {
  {
#line 1408
  if (param_type == 2) {
#line 1408
    goto case_2;
  } else {

  }
#line 1423
  if (param_type == 1) {
#line 1423
    goto case_1___0;
  } else {

  }
#line 1433
  if (param_type == 0) {
#line 1433
    goto case_0___0;
  } else {

  }
#line 1407
  goto switch_break;
  case_2: /* CIL Label */ ;
  {
#line 1410
  if (param == 12) {
#line 1410
    goto case_12;
  } else {

  }
#line 1411
  if (param == 1) {
#line 1411
    goto case_1;
  } else {

  }
#line 1412
  if (param == 2) {
#line 1412
    goto case_2___0;
  } else {

  }
#line 1413
  if (param == 4) {
#line 1413
    goto case_4;
  } else {

  }
#line 1414
  if (param == 3) {
#line 1414
    goto case_3;
  } else {

  }
#line 1415
  if (param == 7) {
#line 1415
    goto case_7;
  } else {

  }
#line 1416
  if (param == 13) {
#line 1416
    goto case_13;
  } else {

  }
#line 1417
  if (param == 14) {
#line 1417
    goto case_14;
  } else {

  }
#line 1418
  if (param == 15) {
#line 1418
    goto case_15;
  } else {

  }
#line 1420
  goto switch_default;
  case_12: /* CIL Label */ ;
  case_1: /* CIL Label */ ;
  case_2___0: /* CIL Label */ ;
  case_4: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
  case_7: /* CIL Label */ ;
  case_13: /* CIL Label */ ;
  case_14: /* CIL Label */ ;
  case_15: /* CIL Label */ ;
#line 1419
  return (292U);
  switch_default: /* CIL Label */ ;
#line 1421
  return (0U);
  switch_break___0: /* CIL Label */ ;
  }
  case_1___0: /* CIL Label */ ;
  {
#line 1425
  if (param == 0) {
#line 1425
    goto case_0;
  } else {

  }
#line 1426
  if (param == 1) {
#line 1426
    goto case_1___1;
  } else {

  }
#line 1427
  if (param == 4) {
#line 1427
    goto case_4___0;
  } else {

  }
#line 1428
  if (param == 5) {
#line 1428
    goto case_5;
  } else {

  }
#line 1430
  goto switch_default___0;
  case_0: /* CIL Label */ ;
  case_1___1: /* CIL Label */ ;
  case_4___0: /* CIL Label */ ;
  case_5: /* CIL Label */ ;
#line 1429
  return (292U);
  switch_default___0: /* CIL Label */ ;
#line 1431
  return (0U);
  switch_break___1: /* CIL Label */ ;
  }
  case_0___0: /* CIL Label */ ;
  {
#line 1435
  if (param == 0) {
#line 1435
    goto case_0___1;
  } else {

  }
#line 1436
  if (param == 1) {
#line 1436
    goto case_1___2;
  } else {

  }
#line 1437
  if (param == 2) {
#line 1437
    goto case_2___1;
  } else {

  }
#line 1438
  if (param == 3) {
#line 1438
    goto case_3___0;
  } else {

  }
#line 1439
  if (param == 21) {
#line 1439
    goto case_21;
  } else {

  }
#line 1440
  if (param == 20) {
#line 1440
    goto case_20;
  } else {

  }
#line 1441
  if (param == 14) {
#line 1441
    goto case_14___0;
  } else {

  }
#line 1442
  if (param == 17) {
#line 1442
    goto case_17;
  } else {

  }
#line 1443
  if (param == 18) {
#line 1443
    goto case_18;
  } else {

  }
#line 1444
  if (param == 30) {
#line 1444
    goto case_30;
  } else {

  }
#line 1445
  if (param == 31) {
#line 1445
    goto case_31;
  } else {

  }
#line 1446
  if (param == 4) {
#line 1446
    goto case_4___1;
  } else {

  }
#line 1447
  if (param == 5) {
#line 1447
    goto case_5___0;
  } else {

  }
#line 1448
  if (param == 6) {
#line 1448
    goto case_6;
  } else {

  }
#line 1449
  if (param == 7) {
#line 1449
    goto case_7___0;
  } else {

  }
#line 1450
  if (param == 8) {
#line 1450
    goto case_8;
  } else {

  }
#line 1451
  if (param == 9) {
#line 1451
    goto case_9;
  } else {

  }
#line 1452
  if (param == 10) {
#line 1452
    goto case_10;
  } else {

  }
#line 1453
  if (param == 11) {
#line 1453
    goto case_11;
  } else {

  }
#line 1454
  if (param == 15) {
#line 1454
    goto case_15___0;
  } else {

  }
#line 1455
  if (param == 16) {
#line 1455
    goto case_16;
  } else {

  }
#line 1456
  if (param == 22) {
#line 1456
    goto case_22;
  } else {

  }
#line 1457
  if (param == 24) {
#line 1457
    goto case_24;
  } else {

  }
#line 1458
  if (param == 23) {
#line 1458
    goto case_23;
  } else {

  }
#line 1459
  if (param == 25) {
#line 1459
    goto case_25;
  } else {

  }
#line 1460
  if (param == 26) {
#line 1460
    goto case_26;
  } else {

  }
#line 1461
  if (param == 27) {
#line 1461
    goto case_27;
  } else {

  }
#line 1462
  if (param == 28) {
#line 1462
    goto case_28;
  } else {

  }
#line 1463
  if (param == 32) {
#line 1463
    goto case_32;
  } else {

  }
#line 1464
  if (param == 34) {
#line 1464
    goto case_34;
  } else {

  }
#line 1466
  goto switch_default___1;
  case_0___1: /* CIL Label */ ;
  case_1___2: /* CIL Label */ ;
  case_2___1: /* CIL Label */ ;
  case_3___0: /* CIL Label */ ;
  case_21: /* CIL Label */ ;
  case_20: /* CIL Label */ ;
  case_14___0: /* CIL Label */ ;
  case_17: /* CIL Label */ ;
  case_18: /* CIL Label */ ;
  case_30: /* CIL Label */ ;
  case_31: /* CIL Label */ ;
  case_4___1: /* CIL Label */ ;
  case_5___0: /* CIL Label */ ;
  case_6: /* CIL Label */ ;
  case_7___0: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_11: /* CIL Label */ ;
  case_15___0: /* CIL Label */ ;
  case_16: /* CIL Label */ ;
  case_22: /* CIL Label */ ;
  case_24: /* CIL Label */ ;
  case_23: /* CIL Label */ ;
  case_25: /* CIL Label */ ;
  case_26: /* CIL Label */ ;
  case_27: /* CIL Label */ ;
  case_28: /* CIL Label */ ;
  case_32: /* CIL Label */ ;
  case_34: /* CIL Label */ ;
#line 1465
  return (292U);
  switch_default___1: /* CIL Label */ ;
#line 1467
  return (0U);
  switch_break___2: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 1471
  return (0U);
}
}
#line 729 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_iscsi.c.aux"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
  {
#line 732
  tmp = ldv_err_ptr(error);
  }
#line 732
  return (tmp);
}
}
#line 1 "<compiler builtins>"
int __builtin_bswap32(int  ) ;
#line 31 "/home/ubuntu/klever-work/verifier/common.h"
void ldv_stop(void) ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_linux_arch_io_check_final_state(void) ;
#line 20
void ldv_linux_block_genhd_check_final_state(void) ;
#line 24
void ldv_linux_block_queue_check_final_state(void) ;
#line 28
void ldv_linux_block_request_check_final_state(void) ;
#line 37
void ldv_linux_drivers_base_class_check_final_state(void) ;
#line 48
void ldv_linux_fs_char_dev_check_final_state(void) ;
#line 52
void ldv_linux_fs_sysfs_check_final_state(void) ;
#line 56
void ldv_linux_kernel_locking_rwlock_check_final_state(void) ;
#line 60
void ldv_linux_kernel_module_check_final_state(void) ;
#line 65
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) ;
#line 70
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) ;
#line 75
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) ;
#line 80
void ldv_linux_kernel_rcu_srcu_check_final_state(void) ;
#line 84
void ldv_linux_lib_find_bit_initialize(void) ;
#line 88
void ldv_linux_lib_idr_check_final_state(void) ;
#line 92
void ldv_linux_mmc_sdio_func_check_final_state(void) ;
#line 96
void ldv_linux_net_register_reset_error_counter(void) ;
#line 97
void ldv_linux_net_register_check_return_value_probe(int retval ) ;
#line 101
void ldv_linux_net_rtnetlink_check_final_state(void) ;
#line 105
void ldv_linux_net_sock_check_final_state(void) ;
#line 110
void ldv_linux_usb_coherent_check_final_state(void) ;
#line 122
void ldv_linux_usb_gadget_check_final_state(void) ;
#line 126
void ldv_linux_usb_register_reset_error_counter(void) ;
#line 127
void ldv_linux_usb_register_check_return_value_probe(int retval ) ;
#line 132
void ldv_linux_usb_urb_check_final_state(void) ;
#line 217
void *ldv_kzalloc(size_t size , gfp_t flags ) ;
#line 225
void ldv_linux_usb_dev_atomic_dec(atomic_t *v ) ;
#line 22 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void *ldv_linux_arch_io_io_mem_remap(void) ;
#line 294
void ldv_linux_arch_io_io_mem_unmap(void) ;
#line 34 "/home/ubuntu/klever-work/linux/ldv/common.h"
static void ldv_ldv_initialize_180(void) ;
#line 47
int ldv_post_init(int init_ret_val ) ;
#line 50
static int ldv_ldv_post_init_177(int ldv_func_arg1 ) ;
#line 58
extern void ldv_pre_probe(void) ;
#line 61
static void ldv_ldv_pre_probe_181(void) ;
#line 65
static void ldv_ldv_pre_probe_183(void) ;
#line 67
int ldv_post_probe(int probe_ret_val ) ;
#line 70
static int ldv_ldv_post_probe_182(int retval ) ;
#line 74
static int ldv_ldv_post_probe_184(int retval ) ;
#line 83
int ldv_filter_err_code(int ret_val ) ;
#line 122
static void ldv_ldv_check_final_state_178(void) ;
#line 126
static void ldv_ldv_check_final_state_179(void) ;
#line 32 "/home/ubuntu/klever-work/verifier/memory.h"
void ldv_free(void *s ) ;
#line 34
void *ldv_xmalloc(size_t size ) ;
#line 308 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
extern void ldv_after_alloc(void * ) ;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/export.h"
extern struct module __this_module ;
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 206
  __asm__  volatile   ("":);
#line 206
  return (0);

#line 206
  return (1);
}
}
#line 308 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
#line 310
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
#line 479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int fls64(__u64 x ) 
{ 
  int bitpos ;

  {
#line 481
  bitpos = -1;
#line 487
  __asm__  ("bsrq %1,%q0": "+r" (bitpos): "rm" (x));
#line 490
  return (bitpos + 1);
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/swab.h"
__inline static __u32 __fswab32(__u32 val ) 
{ 
  int tmp ;

  {
  {
#line 60
  tmp = __builtin_bswap32(val);
  }
#line 60
  return ((__u32 )tmp);
}
}
#line 174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitops.h"
__inline static unsigned int fls_long(unsigned long l ) 
{ 
  int tmp___0 ;

  {
  {
#line 178
  tmp___0 = fls64((__u64 )l);
  }
#line 178
  return ((unsigned int )tmp___0);
}
}
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/log2.h"
__inline static unsigned long __roundup_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
  {
#line 63
  tmp = fls_long(n - 1UL);
  }
#line 63
  return (1UL << (int )tmp);
}
}
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/log2.h"
__inline static unsigned long __rounddown_pow_of_two(unsigned long n ) 
{ 
  unsigned int tmp ;

  {
  {
#line 72
  tmp = fls_long(n);
  }
#line 72
  return (1UL << (int )(tmp - 1U));
}
}
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 392
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 404
extern int sscanf(char const   * , char const   *  , ...) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 63
  __list_add(new, head, head->next);
  }
#line 64
  return;
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 77
  __list_add(new, head->prev, head);
  }
#line 78
  return;
}
}
#line 112
extern void __list_del_entry(struct list_head * ) ;
#line 113
extern void list_del(struct list_head * ) ;
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 


  {
  {
#line 156
  __list_del_entry(list);
#line 157
  list_add(list, head);
  }
#line 158
  return;
}
}
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
#line 189
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , unsigned int  ) ;
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  int tmp___0 ;

  {
  {
#line 306
  tmp___0 = __bitmap_weight(src, nbits);
  }
#line 306
  return (tmp___0);
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 88
extern struct cpumask  const  * const  cpu_online_mask ;
#line 475 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 477
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), (unsigned int )nr_cpu_ids);
  }
#line 477
  return ((unsigned int )tmp);
}
}
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_dec(atomic_t *v ) ;
#line 279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
#line 449 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
extern void __ldv_linux_kernel_locking_spinlock_spin_lock(spinlock_t * ) ;
#line 476
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_134(spinlock_t *ldv_func_arg1 ) ;
#line 480
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_136(spinlock_t *ldv_func_arg1 ) ;
#line 484
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_152(spinlock_t *ldv_func_arg1 ) ;
#line 488
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_154(spinlock_t *ldv_func_arg1 ) ;
#line 520
void ldv_linux_kernel_locking_spinlock_spin_lock_async_pdu_lock_of_beiscsi_hba(void) ;
#line 521
void ldv_linux_kernel_locking_spinlock_spin_unlock_async_pdu_lock_of_beiscsi_hba(void) ;
#line 528
void ldv_linux_kernel_locking_spinlock_spin_lock_back_lock_of_iscsi_session(void) ;
#line 529
void ldv_linux_kernel_locking_spinlock_spin_unlock_back_lock_of_iscsi_session(void) ;
#line 536
void ldv_linux_kernel_locking_spinlock_spin_lock_frwd_lock_of_iscsi_session(void) ;
#line 537
void ldv_linux_kernel_locking_spinlock_spin_unlock_frwd_lock_of_iscsi_session(void) ;
#line 552
void ldv_linux_kernel_locking_spinlock_spin_lock_io_sgl_lock_of_beiscsi_hba(void) ;
#line 553
void ldv_linux_kernel_locking_spinlock_spin_unlock_io_sgl_lock_of_beiscsi_hba(void) ;
#line 560
void ldv_linux_kernel_locking_spinlock_spin_lock_isr_lock_of_beiscsi_hba(void) ;
#line 561
void ldv_linux_kernel_locking_spinlock_spin_unlock_isr_lock_of_beiscsi_hba(void) ;
#line 600
void ldv_linux_kernel_locking_spinlock_spin_lock_mgmt_sgl_lock_of_beiscsi_hba(void) ;
#line 601
void ldv_linux_kernel_locking_spinlock_spin_unlock_mgmt_sgl_lock_of_beiscsi_hba(void) ;
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.h"
void ldv_switch_to_interrupt_context(void) ;
#line 42
void ldv_switch_to_process_context(void) ;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 30
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 42
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
  }
#line 313
  return;
}
}
#line 362
__inline static void ldv_spin_lock_158(spinlock_t *lock ) ;
#line 366
__inline static void ldv_spin_lock_158(spinlock_t *lock ) ;
#line 370
__inline static void ldv_spin_lock_165(spinlock_t *lock ) ;
#line 374
__inline static void ldv_spin_lock_165(spinlock_t *lock ) ;
#line 378
__inline static void ldv_spin_lock_158(spinlock_t *lock ) ;
#line 382
__inline static void ldv_spin_lock_165(spinlock_t *lock ) ;
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
  {
#line 385
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
  }
#line 386
  return;
}
}
#line 407
__inline static void ldv_spin_lock_bh_121(spinlock_t *lock ) ;
#line 411
__inline static void ldv_spin_lock_bh_121(spinlock_t *lock ) ;
#line 415
__inline static void ldv_spin_lock_bh_142(spinlock_t *lock ) ;
#line 419
__inline static void ldv_spin_lock_bh_142(spinlock_t *lock ) ;
#line 423
__inline static void ldv_spin_lock_bh_146(spinlock_t *lock ) ;
#line 427
__inline static void ldv_spin_lock_bh_146(spinlock_t *lock ) ;
#line 431
__inline static void ldv_spin_lock_bh_146(spinlock_t *lock ) ;
#line 435
__inline static void ldv_spin_lock_bh_156(spinlock_t *lock ) ;
#line 439
__inline static void ldv_spin_lock_bh_142(spinlock_t *lock ) ;
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  {
#line 365
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
  }
#line 366
  return;
}
}
#line 411
__inline static void ldv_spin_unlock_159(spinlock_t *lock ) ;
#line 415
__inline static void ldv_spin_unlock_159(spinlock_t *lock ) ;
#line 419
__inline static void ldv_spin_unlock_166(spinlock_t *lock ) ;
#line 423
__inline static void ldv_spin_unlock_166(spinlock_t *lock ) ;
#line 427
__inline static void ldv_spin_unlock_159(spinlock_t *lock ) ;
#line 431
__inline static void ldv_spin_unlock_166(spinlock_t *lock ) ;
#line 432 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
  {
#line 434
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
  }
#line 435
  return;
}
}
#line 456
__inline static void ldv_spin_unlock_bh_122(spinlock_t *lock ) ;
#line 460
__inline static void ldv_spin_unlock_bh_122(spinlock_t *lock ) ;
#line 464
__inline static void ldv_spin_unlock_bh_122(spinlock_t *lock ) ;
#line 468
__inline static void ldv_spin_unlock_bh_122(spinlock_t *lock ) ;
#line 472
__inline static void ldv_spin_unlock_bh_122(spinlock_t *lock ) ;
#line 476
__inline static void ldv_spin_unlock_bh_143(spinlock_t *lock ) ;
#line 480
__inline static void ldv_spin_unlock_bh_143(spinlock_t *lock ) ;
#line 484
__inline static void ldv_spin_unlock_bh_147(spinlock_t *lock ) ;
#line 488
__inline static void ldv_spin_unlock_bh_147(spinlock_t *lock ) ;
#line 492
__inline static void ldv_spin_unlock_bh_147(spinlock_t *lock ) ;
#line 496
__inline static void ldv_spin_unlock_bh_157(spinlock_t *lock ) ;
#line 500
__inline static void ldv_spin_unlock_bh_143(spinlock_t *lock ) ;
#line 514 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 516
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
  }
#line 517
  return;
}
}
#line 546
__inline static void ldv_spin_unlock_irqrestore_135(spinlock_t *lock , unsigned long flags ) ;
#line 550
__inline static void ldv_spin_unlock_irqrestore_135(spinlock_t *lock , unsigned long flags ) ;
#line 554
__inline static void ldv_spin_unlock_irqrestore_135(spinlock_t *lock , unsigned long flags ) ;
#line 558
__inline static void ldv_spin_unlock_irqrestore_135(spinlock_t *lock , unsigned long flags ) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 913
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 914
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 283
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 291
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
extern void delayed_work_timer_fn(unsigned long  ) ;
#line 180
extern void __init_work(struct work_struct * , int  ) ;
#line 351
extern struct workqueue_struct *system_wq ;
#line 360
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
#line 420
extern void destroy_workqueue(struct workqueue_struct * ) ;
#line 427
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
#line 429
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
#line 447
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  {
#line 470
  tmp = queue_work_on(8192, wq, work);
  }
#line 470
  return (tmp);
}
}
#line 481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 485
  tmp = queue_delayed_work_on(8192, wq, dwork, delay);
  }
#line 485
  return (tmp);
}
}
#line 554 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
__inline static bool schedule_delayed_work(struct delayed_work *dwork , unsigned long delay ) 
{ 
  bool tmp ;

  {
  {
#line 557
  tmp = queue_delayed_work(system_wq, dwork, delay);
  }
#line 557
  return (tmp);
}
}
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
static void *ldv_ioremap_nocache_131(resource_size_t ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 190
static void *ldv_ioremap_nocache_132(resource_size_t ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 194
static void *ldv_ioremap_nocache_133(resource_size_t ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
#line 215
static void ldv_iounmap_128(void volatile   *ldv_func_arg1 ) ;
#line 219
static void ldv_iounmap_129(void volatile   *ldv_func_arg1 ) ;
#line 223
static void ldv_iounmap_130(void volatile   *ldv_func_arg1 ) ;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/iomap.h"
extern unsigned int ioread32(void * ) ;
#line 37
extern void iowrite32(u32  , void * ) ;
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 842
  return ((void *)dev->driver_data);
}
}
#line 845 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 847
  dev->driver_data = data;
#line 848
  return;
}
}
#line 1050
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 542
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
extern struct pci_dev *pci_dev_get(struct pci_dev * ) ;
#line 803
extern void pci_dev_put(struct pci_dev * ) ;
#line 940
extern int pci_enable_device(struct pci_dev * ) ;
#line 957
extern void pci_disable_device(struct pci_dev * ) ;
#line 960
extern void pci_set_master(struct pci_dev * ) ;
#line 1015
extern int pci_save_state(struct pci_dev * ) ;
#line 1016
extern void pci_restore_state(struct pci_dev * ) ;
#line 1029
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 1136
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
#line 1140
static int ldv___pci_register_driver_175(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                         char const   *ldv_func_arg3 ) ;
#line 1149
extern void pci_unregister_driver(struct pci_driver * ) ;
#line 1152
static void ldv_pci_unregister_driver_176(struct pci_driver *ldv_func_arg1 ) ;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dmapool.h"
static void *ldv_dma_pool_alloc_162(struct dma_pool *ldv_func_arg1 , gfp_t flags ,
                                    dma_addr_t *ldv_func_arg3 ) ;
#line 29
extern void dma_pool_free(struct dma_pool * , void * , dma_addr_t  ) ;
#line 1217 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
extern void pci_disable_msix(struct pci_dev * ) ;
#line 1228
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int  , int  ) ;
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 242
extern size_t sg_copy_from_buffer(struct scatterlist * , unsigned int  , void * ,
                                  size_t  ) ;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 71
  return ((unsigned int )dma_direction <= 2U);
}
}
#line 131 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-debug.h"
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
#line 44
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 15
  tmp = get_dma_ops(dev);
#line 15
  ops = tmp;
#line 18
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
#line 19
  tmp___0 = valid_dma_direction((int )dir);
#line 19
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 19
  if (tmp___1 != 0L) {
    {
#line 19
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
#line 19
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 20
  tmp___2 = __phys_addr((unsigned long )ptr);
#line 20
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
#line 23
  tmp___3 = __phys_addr((unsigned long )ptr);
#line 23
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
  }
#line 26
  return (addr);
}
}
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 34
  tmp = get_dma_ops(dev);
#line 34
  ops = tmp;
#line 36
  tmp___0 = valid_dma_direction((int )dir);
#line 36
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 36
  if (tmp___1 != 0L) {
    {
#line 36
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
#line 36
    __builtin_unreachable();
    }
  } else {

  }
#line 37
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
    {
#line 38
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
    }
  } else {

  }
  {
#line 39
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
  }
#line 40
  return;
}
}
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
extern int dma_supported(struct device * , u64  ) ;
#line 61
extern int dma_set_mask(struct device * , u64  ) ;
#line 97 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-mapping.h"
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 99
  tmp = dma_supported(dev, mask);
  }
#line 99
  if (tmp == 0) {
#line 100
    return (-5);
  } else {

  }
#line 101
  dev->coherent_dma_mask = mask;
#line 102
  return (0);
}
}
#line 179
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flags ) ;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static void *pci_zalloc_consistent(struct pci_dev *hwdev , size_t size ,
                                            dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
  {
#line 26
  tmp = dma_zalloc_coherent((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                            size, dma_handle, 32U);
  }
#line 26
  return (tmp);
}
}
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static dma_addr_t pci_map_single(struct pci_dev *hwdev , void *ptr , size_t size ,
                                          int direction ) 
{ 
  dma_addr_t tmp ;

  {
  {
#line 40
  tmp = dma_map_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                             ptr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
  }
#line 40
  return (tmp);
}
}
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static void pci_unmap_single(struct pci_dev *hwdev , dma_addr_t dma_addr ,
                                      size_t size , int direction ) 
{ 


  {
  {
#line 47
  dma_unmap_single_attrs((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                         dma_addr, size, (enum dma_data_direction )direction, (struct dma_attrs *)0);
  }
#line 48
  return;
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 115
  tmp = dma_set_mask(& dev->dev, mask);
  }
#line 115
  return (tmp);
}
}
#line 118 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 120
  tmp = dma_set_coherent_mask(& dev->dev, mask);
  }
#line 120
  return (tmp);
}
}
#line 1474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  {
#line 1476
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  }
#line 1476
  return (tmp);
}
}
#line 1479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
  {
#line 1481
  dev_set_drvdata(& pdev->dev, data);
  }
#line 1482
  return;
}
}
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hardirq.h"
extern void synchronize_irq(unsigned int  ) ;
#line 1010 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
extern void blk_queue_max_segment_size(struct request_queue * , unsigned int  ) ;
#line 761 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_host.h"
__inline static struct Scsi_Host *dev_to_shost___0(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 763
  goto ldv_36292;
  ldv_36291: ;
#line 764
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
#line 765
    return ((struct Scsi_Host *)0);
  } else {

  }
#line 766
  dev = dev->parent;
  ldv_36292: 
  {
#line 763
  tmp = scsi_is_host_device((struct device  const  *)dev);
  }
#line 763
  if (tmp == 0) {
#line 765
    goto ldv_36291;
  } else {

  }
#line 768
  __mptr = (struct device  const  *)dev;
#line 768
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffc48UL);
}
}
#line 796
extern struct Scsi_Host *scsi_host_get(struct Scsi_Host * ) ;
#line 797
extern void scsi_host_put(struct Scsi_Host * ) ;
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
__inline static void ssleep(unsigned int seconds ) 
{ 


  {
  {
#line 52
  msleep(seconds * 1000U);
  }
#line 53
  return;
}
}
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
  }
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_138(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                  void * ) ,
                                        unsigned long flags , char const   *name ,
                                        void *dev ) ;
#line 141
__inline static int ldv_request_irq_139(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                  void * ) ,
                                        unsigned long flags , char const   *name ,
                                        void *dev ) ;
#line 145
__inline static int ldv_request_irq_140(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                  void * ) ,
                                        unsigned long flags , char const   *name ,
                                        void *dev ) ;
#line 154
extern void free_irq(unsigned int  , void * ) ;
#line 157
static void ldv_free_irq_141(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 161
static void ldv_free_irq_173(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 165
static void ldv_free_irq_174(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/iscsi_boot_sysfs.h"
extern struct iscsi_boot_kobj *iscsi_boot_create_initiator(struct iscsi_boot_kset * ,
                                                           int  , void * , ssize_t (*)(void * ,
                                                                                       int  ,
                                                                                       char * ) ,
                                                           umode_t (*)(void * , int  ) ,
                                                           void (*)(void * ) ) ;
#line 117
extern struct iscsi_boot_kobj *iscsi_boot_create_ethernet(struct iscsi_boot_kset * ,
                                                          int  , void * , ssize_t (*)(void * ,
                                                                                      int  ,
                                                                                      char * ) ,
                                                          umode_t (*)(void * , int  ) ,
                                                          void (*)(void * ) ) ;
#line 123
extern struct iscsi_boot_kobj *iscsi_boot_create_target(struct iscsi_boot_kset * ,
                                                        int  , void * , ssize_t (*)(void * ,
                                                                                    int  ,
                                                                                    char * ) ,
                                                        umode_t (*)(void * , int  ) ,
                                                        void (*)(void * ) ) ;
#line 130
extern struct iscsi_boot_kset *iscsi_boot_create_host_kset(unsigned int  ) ;
#line 131
extern void iscsi_boot_destroy_kset(struct iscsi_boot_kset * ) ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bsg-lib.h"
extern void bsg_job_done(struct bsg_job * , int  , unsigned int  ) ;
#line 176 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_transport_iscsi.h"
extern struct scsi_transport_template *iscsi_register_transport(struct iscsi_transport * ) ;
#line 177
extern int iscsi_unregister_transport(struct iscsi_transport * ) ;
#line 283
extern void iscsi_host_for_each_session(struct Scsi_Host * , void (*)(struct iscsi_cls_session * ) ) ;
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
extern int iscsi_eh_abort(struct scsi_cmnd * ) ;
#line 383
extern int iscsi_eh_session_reset(struct scsi_cmnd * ) ;
#line 384
extern int iscsi_eh_device_reset(struct scsi_cmnd * ) ;
#line 385
extern int iscsi_queuecommand(struct Scsi_Host * , struct scsi_cmnd * ) ;
#line 398
extern int iscsi_host_add(struct Scsi_Host * , struct device * ) ;
#line 399
extern struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template * , int  , bool  ) ;
#line 402
extern void iscsi_host_remove(struct Scsi_Host * ) ;
#line 403
extern void iscsi_host_free(struct Scsi_Host * ) ;
#line 404
extern int iscsi_target_alloc(struct scsi_target * ) ;
#line 413
extern void iscsi_session_recovery_timedout(struct iscsi_cls_session * ) ;
#line 416
extern int iscsi_session_get_param(struct iscsi_cls_session * , enum iscsi_param  ,
                                   char * ) ;
#line 427
extern void iscsi_conn_teardown(struct iscsi_cls_conn * ) ;
#line 429
extern void iscsi_conn_stop(struct iscsi_cls_conn * , int  ) ;
#line 432
extern void iscsi_conn_failure(struct iscsi_conn * , enum iscsi_err  ) ;
#line 435
extern int iscsi_conn_get_param(struct iscsi_cls_conn * , enum iscsi_param  , char * ) ;
#line 454
extern int iscsi_conn_send_pdu(struct iscsi_cls_conn * , struct iscsi_hdr * , char * ,
                               uint32_t  ) ;
#line 458
extern int __iscsi_complete_pdu(struct iscsi_conn * , struct iscsi_hdr * , char * ,
                                int  ) ;
#line 464
extern void iscsi_put_task(struct iscsi_task * ) ;
#line 467
extern void iscsi_complete_scsi_task(struct iscsi_task * , uint32_t  , uint32_t  ) ;
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_device.h"
__inline static struct scsi_target *scsi_target(struct scsi_device *sdev ) 
{ 
  struct device  const  *__mptr ;

  {
#line 312
  __mptr = (struct device  const  *)sdev->sdev_gendev.parent;
#line 312
  return ((struct scsi_target *)__mptr + 0xffffffffffffffd8UL);
}
}
#line 379
extern int scsi_change_queue_depth(struct scsi_device * , int  ) ;
#line 168 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_cmnd.h"
extern int scsi_dma_map(struct scsi_cmnd * ) ;
#line 169
extern void scsi_dma_unmap(struct scsi_cmnd * ) ;
#line 176 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_cmnd.h"
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
#line 178
  return (cmd->sdb.table.sgl);
}
}
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_cmnd.h"
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 


  {
#line 183
  return (cmd->sdb.length);
}
}
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_cmnd.h"
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 


  {
#line 188
  cmd->sdb.resid = resid;
#line 189
  return;
}
}
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ctype.h"
extern unsigned char const   _ctype[] ;
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/aer.h"
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
#line 43
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
#line 44
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk-iopoll.h"
__inline static int blk_iopoll_sched_prep(struct blk_iopoll *iop ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 28
  tmp___0 = constant_test_bit(1L, (unsigned long const volatile   *)(& iop->state));
  }
#line 28
  if (tmp___0 == 0) {
    {
#line 29
    tmp = test_and_set_bit(0L, (unsigned long volatile   *)(& iop->state));
    }
#line 29
    return (tmp);
  } else {

  }
#line 31
  return (1);
}
}
#line 39
extern void blk_iopoll_sched(struct blk_iopoll * ) ;
#line 40
extern void blk_iopoll_init(struct blk_iopoll * , int  , blk_iopoll_fn * ) ;
#line 41
extern void blk_iopoll_complete(struct blk_iopoll * ) ;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static u32 MODULO(u16 val , u16 limit ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  {
#line 50
  __ret_warn_on = ((int )limit & ((int )limit + -1)) != 0;
#line 50
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 50
  if (tmp != 0L) {
    {
#line 50
    warn_slowpath_null("drivers/scsi/be2iscsi/be.h", 50);
    }
  } else {

  }
  {
#line 50
  __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 51
  return ((u32 )((int )val & ((int )limit + -1)));
}
}
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static void index_inc(u16 *index , u16 limit ) 
{ 
  u32 tmp ;

  {
  {
#line 56
  tmp = MODULO((int )((unsigned int )*index + 1U), (int )limit);
#line 56
  *index = (u16 )tmp;
  }
#line 57
  return;
}
}
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static void *queue_tail_node(struct be_queue_info *q ) 
{ 


  {
#line 71
  return (q->dma_mem.va + (unsigned long )((int )q->tail * (int )q->entry_size));
}
}
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static void queue_tail_inc(struct be_queue_info *q ) 
{ 


  {
  {
#line 81
  index_inc(& q->tail, (int )q->len);
  }
#line 82
  return;
}
}
#line 704 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl , struct be_queue_info *eq , int eq_delay ) ;
#line 707
int beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl , struct be_queue_info *cq , struct be_queue_info *eq ,
                          bool sol_evts , bool no_delay , int coalesce_wm ) ;
#line 712
int beiscsi_cmd_q_destroy(struct be_ctrl_info *ctrl , struct be_queue_info *q , int queue_type ) ;
#line 714
int beiscsi_cmd_mccq_create(struct beiscsi_hba *phba , struct be_queue_info *mccq ,
                            struct be_queue_info *cq ) ;
#line 719
int mgmt_check_supported_fw(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ) ;
#line 724
void free_mcc_tag(struct be_ctrl_info *ctrl , unsigned int tag ) ;
#line 726
int be_cmd_modify_eq_delay(struct beiscsi_hba *phba , struct be_set_eqd *set_eqd ,
                           int num ) ;
#line 732
int be_cmd_fw_initialize(struct be_ctrl_info *ctrl ) ;
#line 733
int be_cmd_fw_uninit(struct be_ctrl_info *ctrl ) ;
#line 740
void beiscsi_async_link_state_process(struct beiscsi_hba *phba , struct be_async_event_link_state *evt ) ;
#line 742
int be_mcc_compl_process_isr(struct be_ctrl_info *ctrl , struct be_mcc_compl *compl ) ;
#line 747
int be_cmd_create_default_pdu_queue(struct be_ctrl_info *ctrl , struct be_queue_info *cq ,
                                    struct be_queue_info *dq , int length , int entry_size ,
                                    uint8_t is_header , uint8_t ulp_num ) ;
#line 753
int be_cmd_iscsi_post_template_hdr(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem ) ;
#line 756
int be_cmd_iscsi_remove_template_hdr(struct be_ctrl_info *ctrl ) ;
#line 758
int be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem ,
                                u32 page_offset___0 , u32 num_pages ) ;
#line 762
int beiscsi_cmd_reset_function(struct beiscsi_hba *phba ) ;
#line 764
int be_cmd_wrbq_create(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem , struct be_queue_info *wrbq ,
                       struct hwi_wrb_context *pwrb_context , uint8_t ulp_num ) ;
#line 769
bool is_link_state_evt(u32 trailer ) ;
#line 1350
int be_chk_reset_complete(struct beiscsi_hba *phba ) ;
#line 1358
void be2iscsi_fail_session(struct iscsi_cls_session *cls_session ) ;
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static u32 amap_get(void *ptr , u32 dw_offset , u32 mask , u32 offset ) 
{ 
  u32 *dw ;

  {
#line 187
  dw = (u32 *)ptr;
#line 188
  return (mask & (*(dw + (unsigned long )dw_offset) >> (int )offset));
}
}
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static void swap_dws(void *wrb , int len ) 
{ 


  {
#line 201
  return;
}
}
#line 832 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.h"
struct wrb_handle *alloc_wrb_handle(struct beiscsi_hba *phba , unsigned int cid ) ;
#line 834
void free_mgmt_sgl_handle(struct beiscsi_hba *phba , struct sgl_handle *psgl_handle ) ;
#line 836
void beiscsi_process_all_cqs(struct work_struct *work ) ;
#line 840
void hwi_ring_cq_db(struct beiscsi_hba *phba , unsigned int id , unsigned int num_processed ,
                    unsigned char rearm , unsigned char event ) ;
#line 99 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
int mgmt_epfw_cleanup(struct beiscsi_hba *phba , unsigned short ulp_num ) ;
#line 108
unsigned int mgmt_invalidate_icds(struct beiscsi_hba *phba , struct invalidate_command_table *inv_tbl ,
                                  unsigned int num_invalidate , unsigned int cid ,
                                  struct be_dma_mem *nonemb_cmd ) ;
#line 112
unsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ,
                                         struct bsg_job *job , struct be_dma_mem *nonemb_cmd ) ;
#line 269
int mgmt_get_fw_config(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ) ;
#line 289
unsigned int mgmt_get_session_info(struct beiscsi_hba *phba , u32 boot_session_handle ,
                                   struct be_dma_mem *nonemb_cmd ) ;
#line 305
int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba , unsigned int *s_handle ) ;
#line 312
ssize_t beiscsi_drvr_ver_disp(struct device *dev , struct device_attribute *attr ,
                              char *buf ) ;
#line 315
ssize_t beiscsi_fw_ver_disp(struct device *dev , struct device_attribute *attr , char *buf ) ;
#line 318
ssize_t beiscsi_active_session_disp(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) ;
#line 321
ssize_t beiscsi_adap_family_disp(struct device *dev , struct device_attribute *attr ,
                                 char *buf ) ;
#line 325
ssize_t beiscsi_free_session_disp(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) ;
#line 328
ssize_t beiscsi_phys_port_disp(struct device *dev , struct device_attribute *attr ,
                               char *buf ) ;
#line 331
void beiscsi_offload_cxn_v0(struct beiscsi_offload_params *params , struct wrb_handle *pwrb_handle ,
                            struct be_mem_descriptor *mem_descr ) ;
#line 335
void beiscsi_offload_cxn_v2(struct beiscsi_offload_params *params , struct wrb_handle *pwrb_handle ) ;
#line 337
void beiscsi_ue_detect(struct beiscsi_hba *phba ) ;
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static unsigned int be_iopoll_budget  =    10U;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static unsigned int be_max_phys_size  =    64U;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static unsigned int enable_msix  =    1U;
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static uint beiscsi_log_enable  =    0U;
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
ssize_t beiscsi_log_enable_disp(struct device *dev , struct device_attribute *attrib ,
                                char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint32_t param_val ;
  int tmp___0 ;

  {
  {
#line 152
  __mptr = (struct device  const  *)dev;
#line 152
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c8UL;
#line 152
  tmp = shost_priv(shost);
#line 152
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 152
  param_val = 0U;
#line 152
  param_val = phba->attr_log_enable;
#line 152
  tmp___0 = snprintf(buf, 4096UL, "%d\n", phba->attr_log_enable);
  }
#line 152
  return ((ssize_t )tmp___0);
}
}
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
int beiscsi_log_enable_change(struct beiscsi_hba *phba , uint32_t val ) 
{ 
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 152
  if (val <= 255U) {
#line 152
    log_value = phba->attr_log_enable;
#line 152
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 152
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BA_%d : beiscsi_log_enable updated from 0x%x ==> 0x%x\n",
                 152, phba->attr_log_enable, val);
      }
    } else {

    }
#line 152
    phba->attr_log_enable = val;
#line 152
    return (0);
  } else {

  }
#line 152
  log_value___0 = phba->attr_log_enable;
#line 152
  if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 152
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BA_%d beiscsi_log_enable attribute cannot be updated to 0x%x, range allowed is [0x00 - 0xFF]\n",
               152, val);
    }
  } else {

  }
#line 152
  return (-22);
}
}
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
ssize_t beiscsi_log_enable_store(struct device *dev , struct device_attribute *attr ,
                                 char const   *buf , size_t count ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint32_t param_val ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 152
  __mptr = (struct device  const  *)dev;
#line 152
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c8UL;
#line 152
  tmp = shost_priv(shost);
#line 152
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 152
  param_val = 0U;
  }
#line 152
  if (((int )_ctype[(int )((unsigned char )*buf)] & 4) == 0) {
#line 152
    return (-22L);
  } else {

  }
  {
#line 152
  tmp___0 = sscanf(buf, "%i", & param_val);
  }
#line 152
  if (tmp___0 != 1) {
#line 152
    return (-22L);
  } else {

  }
  {
#line 152
  tmp___2 = beiscsi_log_enable_change(phba, param_val);
  }
#line 152
  if (tmp___2 == 0) {
    {
#line 152
    tmp___1 = strlen(buf);
    }
#line 152
    return ((ssize_t )tmp___1);
  } else {
#line 152
    return (-22L);
  }
}
}
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
int beiscsi_log_enable_init(struct beiscsi_hba *phba , uint32_t val ) 
{ 
  uint32_t log_value ;

  {
#line 152
  if (val <= 255U) {
#line 152
    phba->attr_log_enable = val;
#line 152
    return (0);
  } else {

  }
#line 152
  log_value = phba->attr_log_enable;
#line 152
  if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 152
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BA_%d beiscsi_log_enable attribute cannot be updated to 0x%x, range allowed is [0x00 - 0xFF]\n",
               152, val);
    }
  } else {

  }
#line 152
  phba->attr_log_enable = 0U;
#line 152
  return (-22);
}
}
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_log_enable  =    {{"beiscsi_log_enable", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                                {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & beiscsi_log_enable_disp, & beiscsi_log_enable_store};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_drvr_ver  =    {{"beiscsi_drvr_ver", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & beiscsi_drvr_ver_disp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_adapter_family  =    {{"beiscsi_adapter_family", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                    {(char)0}, {(char)0}, {(char)0},
                                                    {(char)0}, {(char)0}}}}, & beiscsi_adap_family_disp,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_fw_ver  =    {{"beiscsi_fw_ver", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & beiscsi_fw_ver_disp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                        char const   * , size_t  ))0};
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_phys_port  =    {{"beiscsi_phys_port", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                               {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & beiscsi_phys_port_disp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                           char const   * , size_t  ))0};
#line 159 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_active_session_count  =    {{"beiscsi_active_session_count", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                          {(char)0}, {(char)0}, {(char)0},
                                                          {(char)0}, {(char)0}}}},
    & beiscsi_active_session_disp, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                char const   * , size_t  ))0};
#line 161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute dev_attr_beiscsi_free_session_count  =    {{"beiscsi_free_session_count", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                        {(char)0}, {(char)0}, {(char)0},
                                                        {(char)0}, {(char)0}}}}, & beiscsi_free_session_disp,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct device_attribute *beiscsi_attrs[8U]  = 
#line 162
  {      & dev_attr_beiscsi_log_enable,      & dev_attr_beiscsi_drvr_ver,      & dev_attr_beiscsi_adapter_family,      & dev_attr_beiscsi_fw_ver, 
        & dev_attr_beiscsi_active_session_count,      & dev_attr_beiscsi_free_session_count,      & dev_attr_beiscsi_phys_port,      (struct device_attribute *)0};
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static char const   *cqe_desc[36U]  = 
#line 173
  {      "RESERVED_DESC",      "SOL_CMD_COMPLETE",      "SOL_CMD_KILLED_DATA_DIGEST_ERR",      "CXN_KILLED_PDU_SIZE_EXCEEDS_DSL", 
        "CXN_KILLED_BURST_LEN_MISMATCH",      "CXN_KILLED_AHS_RCVD",      "CXN_KILLED_HDR_DIGEST_ERR",      "CXN_KILLED_UNKNOWN_HDR", 
        "CXN_KILLED_STALE_ITT_TTT_RCVD",      "CXN_KILLED_INVALID_ITT_TTT_RCVD",      "CXN_KILLED_RST_RCVD",      "CXN_KILLED_TIMED_OUT", 
        "CXN_KILLED_RST_SENT",      "CXN_KILLED_FIN_RCVD",      "CXN_KILLED_BAD_UNSOL_PDU_RCVD",      "CXN_KILLED_BAD_WRB_INDEX_ERROR", 
        "CXN_KILLED_OVER_RUN_RESIDUAL",      "CXN_KILLED_UNDER_RUN_RESIDUAL",      "CMD_KILLED_INVALID_STATSN_RCVD",      "CMD_KILLED_INVALID_R2T_RCVD", 
        "CMD_CXN_KILLED_LUN_INVALID",      "CMD_CXN_KILLED_ICD_INVALID",      "CMD_CXN_KILLED_ITT_INVALID",      "CMD_CXN_KILLED_SEQ_OUTOFORDER", 
        "CMD_CXN_KILLED_INVALID_DATASN_RCVD",      "CXN_INVALIDATE_NOTIFY",      "CXN_INVALIDATE_INDEX_NOTIFY",      "CMD_INVALIDATED_NOTIFY", 
        "UNSOL_HDR_NOTIFY",      "UNSOL_DATA_NOTIFY",      "UNSOL_DATA_DIGEST_ERROR_NOTIFY",      "DRIVERMSG_NOTIFY", 
        "CXN_KILLED_CMND_DATA_NOT_ON_SAME_CONN",      "SOL_CMD_KILLED_DIF_ERR",      "CXN_KILLED_SYN_RCVD",      "CXN_KILLED_IMM_DATA_RCVD"};
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_slave_configure(struct scsi_device *sdev ) 
{ 


  {
  {
#line 214
  blk_queue_max_segment_size(sdev->request_queue, 65536U);
  }
#line 215
  return (0);
}
}
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_eh_abort(struct scsi_cmnd *sc ) 
{ 
  struct iscsi_cls_session *cls_session ;
  struct iscsi_task *aborted_task ;
  struct beiscsi_io_task *aborted_io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_session *session ;
  struct invalidate_command_table *inv_tbl ;
  struct be_dma_mem nonemb_cmd ;
  unsigned int cid ;
  unsigned int tag ;
  unsigned int num_invalidate ;
  int rc ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp ;
  u32 tmp___0 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___1 ;

  {
  {
#line 221
  aborted_task = (struct iscsi_task *)sc->SCp.ptr;
#line 232
  tmp = scsi_target(sc->device);
#line 232
  __mptr = (struct device  const  *)tmp->dev.parent;
#line 232
  cls_session = (struct iscsi_cls_session *)__mptr + 0xfffffffffffffd58UL;
#line 233
  session = (struct iscsi_session *)cls_session->dd_data;
#line 235
  ldv_spin_lock_bh_121(& session->frwd_lock);
  }
#line 236
  if ((unsigned long )aborted_task == (unsigned long )((struct iscsi_task *)0) || (unsigned long )aborted_task->sc == (unsigned long )((struct scsi_cmnd *)0)) {
    {
#line 238
    ldv_spin_unlock_bh_122(& session->frwd_lock);
    }
#line 239
    return (8194);
  } else {

  }
#line 242
  aborted_io_task = (struct beiscsi_io_task *)aborted_task->dd_data;
#line 243
  if ((unsigned long )aborted_io_task->scsi_cmnd == (unsigned long )((struct scsi_cmnd *)0)) {
    {
#line 245
    ldv_spin_unlock_bh_122(& session->frwd_lock);
    }
#line 246
    return (8194);
  } else {

  }
  {
#line 248
  ldv_spin_unlock_bh_122(& session->frwd_lock);
#line 250
  tmp___0 = amap_mask(1U);
#line 250
  amap_set((void *)(aborted_io_task->pwrb_handle)->pwrb, 0U, tmp___0, 15U, 1U);
#line 254
  conn = aborted_task->conn;
#line 255
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 256
  phba = beiscsi_conn->phba;
#line 259
  cid = beiscsi_conn->beiscsi_conn_cid;
#line 260
  inv_tbl = (struct invalidate_command_table *)(& phba->inv_tbl);
#line 261
  __memset((void *)inv_tbl, 0, 4UL);
#line 262
  inv_tbl->cid = (unsigned short )cid;
#line 263
  inv_tbl->icd = (unsigned short )(aborted_io_task->psgl_handle)->sgl_index;
#line 264
  num_invalidate = 1U;
#line 265
  nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev, 540UL, & nonemb_cmd.dma);
  }
#line 268
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 269
    log_value = phba->attr_log_enable;
#line 269
    if ((log_value & 8U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 269
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory formgmt_invalidate_icds\n",
                 271);
      }
    } else {

    }
#line 272
    return (8195);
  } else {

  }
  {
#line 274
  nonemb_cmd.size = 540U;
#line 276
  tag = mgmt_invalidate_icds(phba, inv_tbl, num_invalidate, cid, & nonemb_cmd);
  }
#line 278
  if (tag == 0U) {
#line 279
    log_value___0 = phba->attr_log_enable;
#line 279
    if ((log_value___0 & 8U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 279
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : mgmt_invalidate_icds could not besubmitted\n",
                 281);
      }
    } else {

    }
    {
#line 282
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
    }
#line 285
    return (8195);
  } else {

  }
  {
#line 288
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, & nonemb_cmd);
  }
#line 289
  if (rc != -16) {
    {
#line 290
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
    }
  } else {

  }
  {
#line 293
  tmp___1 = iscsi_eh_abort(sc);
  }
#line 293
  return (tmp___1);
}
}
#line 296 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_eh_device_reset(struct scsi_cmnd *sc ) 
{ 
  struct iscsi_task *abrt_task ;
  struct beiscsi_io_task *abrt_io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_session *session ;
  struct iscsi_cls_session *cls_session ;
  struct invalidate_command_table *inv_tbl ;
  struct be_dma_mem nonemb_cmd ;
  unsigned int cid ;
  unsigned int tag ;
  unsigned int i ;
  unsigned int num_invalidate ;
  int rc ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp ;
  u32 tmp___0 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___1 ;

  {
  {
#line 311
  tmp = scsi_target(sc->device);
#line 311
  __mptr = (struct device  const  *)tmp->dev.parent;
#line 311
  cls_session = (struct iscsi_cls_session *)__mptr + 0xfffffffffffffd58UL;
#line 312
  session = (struct iscsi_session *)cls_session->dd_data;
#line 313
  ldv_spin_lock_bh_121(& session->frwd_lock);
  }
#line 314
  if ((unsigned long )session->leadconn == (unsigned long )((struct iscsi_conn *)0) || session->state != 2) {
    {
#line 315
    ldv_spin_unlock_bh_122(& session->frwd_lock);
    }
#line 316
    return (8195);
  } else {

  }
  {
#line 318
  conn = session->leadconn;
#line 319
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 320
  phba = beiscsi_conn->phba;
#line 321
  cid = beiscsi_conn->beiscsi_conn_cid;
#line 322
  inv_tbl = (struct invalidate_command_table *)(& phba->inv_tbl);
#line 323
  __memset((void *)inv_tbl, 0, 512UL);
#line 324
  num_invalidate = 0U;
#line 325
  i = 0U;
  }
#line 325
  goto ldv_56917;
  ldv_56916: 
#line 326
  abrt_task = *((conn->session)->cmds + (unsigned long )i);
#line 327
  abrt_io_task = (struct beiscsi_io_task *)abrt_task->dd_data;
#line 328
  if ((unsigned long )abrt_task->sc == (unsigned long )((struct scsi_cmnd *)0) || abrt_task->state == 0) {
#line 329
    goto ldv_56915;
  } else {

  }
#line 331
  if ((sc->device)->lun != ((abrt_task->sc)->device)->lun) {
#line 332
    goto ldv_56915;
  } else {

  }
  {
#line 335
  tmp___0 = amap_mask(1U);
#line 335
  amap_set((void *)(abrt_io_task->pwrb_handle)->pwrb, 0U, tmp___0, 15U, 1U);
#line 339
  inv_tbl->cid = (unsigned short )cid;
#line 340
  inv_tbl->icd = (unsigned short )(abrt_io_task->psgl_handle)->sgl_index;
#line 341
  num_invalidate = num_invalidate + 1U;
#line 342
  inv_tbl = inv_tbl + 1;
  }
  ldv_56915: 
#line 325
  i = i + 1U;
  ldv_56917: ;
#line 325
  if (i < (unsigned int )(conn->session)->cmds_max) {
#line 327
    goto ldv_56916;
  } else {

  }
  {
#line 344
  ldv_spin_unlock_bh_122(& session->frwd_lock);
#line 345
  inv_tbl = (struct invalidate_command_table *)(& phba->inv_tbl);
#line 347
  nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev, 540UL, & nonemb_cmd.dma);
  }
#line 350
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 351
    log_value = phba->attr_log_enable;
#line 351
    if ((log_value & 8U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 351
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory formgmt_invalidate_icds\n",
                 353);
      }
    } else {

    }
#line 354
    return (8195);
  } else {

  }
  {
#line 356
  nonemb_cmd.size = 540U;
#line 357
  __memset(nonemb_cmd.va, 0, (size_t )nonemb_cmd.size);
#line 358
  tag = mgmt_invalidate_icds(phba, inv_tbl, num_invalidate, cid, & nonemb_cmd);
  }
#line 360
  if (tag == 0U) {
#line 361
    log_value___0 = phba->attr_log_enable;
#line 361
    if ((log_value___0 & 8U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 361
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : mgmt_invalidate_icds could not be submitted\n",
                 363);
      }
    } else {

    }
    {
#line 364
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
    }
#line 366
    return (8195);
  } else {

  }
  {
#line 369
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, & nonemb_cmd);
  }
#line 370
  if (rc != -16) {
    {
#line 371
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
    }
  } else {

  }
  {
#line 373
  tmp___1 = iscsi_eh_device_reset(sc);
  }
#line 373
  return (tmp___1);
}
}
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static ssize_t beiscsi_show_boot_tgt_info(void *data , int type , char *buf ) 
{ 
  struct beiscsi_hba *phba ;
  struct mgmt_session_info *boot_sess ;
  struct mgmt_conn_info *boot_conn ;
  char *str ;
  int rc ;
  size_t tmp ;

  {
#line 378
  phba = (struct beiscsi_hba *)data;
#line 379
  boot_sess = & phba->boot_sess;
#line 380
  boot_conn = (struct mgmt_conn_info *)(& boot_sess->conn_list);
#line 381
  str = buf;
  {
#line 385
  if (type == 7) {
#line 385
    goto case_7;
  } else {

  }
#line 390
  if (type == 2) {
#line 390
    goto case_2;
  } else {

  }
#line 398
  if (type == 3) {
#line 398
    goto case_3;
  } else {

  }
#line 402
  if (type == 8) {
#line 402
    goto case_8;
  } else {

  }
#line 409
  if (type == 9) {
#line 409
    goto case_9;
  } else {

  }
#line 416
  if (type == 10) {
#line 416
    goto case_10;
  } else {

  }
#line 423
  if (type == 11) {
#line 423
    goto case_11;
  } else {

  }
#line 430
  if (type == 1) {
#line 430
    goto case_1;
  } else {

  }
#line 433
  if (type == 6) {
#line 433
    goto case_6;
  } else {

  }
#line 436
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 386
  tmp = strlen((char const   *)(& boot_sess->target_name));
#line 386
  rc = sprintf(buf, "%.*s\n", (int )tmp, (char *)(& boot_sess->target_name));
  }
#line 389
  goto ldv_56932;
  case_2: /* CIL Label */ ;
#line 391
  if ((unsigned int )boot_conn->dest_ipaddr.ip_type == 1U) {
    {
#line 392
    rc = sprintf(buf, "%pI4\n", (char *)(& boot_conn->dest_ipaddr.addr));
    }
  } else {
    {
#line 395
    rc = sprintf(str, "%pI6\n", (char *)(& boot_conn->dest_ipaddr.addr));
    }
  }
#line 397
  goto ldv_56932;
  case_3: /* CIL Label */ 
  {
#line 399
  rc = sprintf(str, "%d\n", (int )boot_conn->dest_port);
  }
#line 400
  goto ldv_56932;
  case_8: /* CIL Label */ 
  {
#line 403
  rc = sprintf(str, "%.*s\n", (int )boot_conn->negotiated_login_options.auth_data.chap.target_chap_name_length,
               (char *)(& boot_conn->negotiated_login_options.auth_data.chap.target_chap_name));
  }
#line 408
  goto ldv_56932;
  case_9: /* CIL Label */ 
  {
#line 410
  rc = sprintf(str, "%.*s\n", (int )boot_conn->negotiated_login_options.auth_data.chap.target_secret_length,
               (char *)(& boot_conn->negotiated_login_options.auth_data.chap.target_secret));
  }
#line 415
  goto ldv_56932;
  case_10: /* CIL Label */ 
  {
#line 417
  rc = sprintf(str, "%.*s\n", (int )boot_conn->negotiated_login_options.auth_data.chap.intr_chap_name_length,
               (char *)(& boot_conn->negotiated_login_options.auth_data.chap.intr_chap_name));
  }
#line 422
  goto ldv_56932;
  case_11: /* CIL Label */ 
  {
#line 424
  rc = sprintf(str, "%.*s\n", (int )boot_conn->negotiated_login_options.auth_data.chap.intr_secret_length,
               (char *)(& boot_conn->negotiated_login_options.auth_data.chap.intr_secret));
  }
#line 429
  goto ldv_56932;
  case_1: /* CIL Label */ 
  {
#line 431
  rc = sprintf(str, "2\n");
  }
#line 432
  goto ldv_56932;
  case_6: /* CIL Label */ 
  {
#line 434
  rc = sprintf(str, "0\n");
  }
#line 435
  goto ldv_56932;
  switch_default: /* CIL Label */ 
#line 437
  rc = -38;
#line 438
  goto ldv_56932;
  switch_break: /* CIL Label */ ;
  }
  ldv_56932: ;
#line 440
  return ((ssize_t )rc);
}
}
#line 443 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static ssize_t beiscsi_show_boot_ini_info(void *data , int type , char *buf ) 
{ 
  struct beiscsi_hba *phba ;
  char *str ;
  int rc ;

  {
#line 445
  phba = (struct beiscsi_hba *)data;
#line 446
  str = buf;
  {
#line 450
  if (type == 6) {
#line 450
    goto case_6;
  } else {

  }
#line 453
  goto switch_default;
  case_6: /* CIL Label */ 
  {
#line 451
  rc = sprintf(str, "%s\n", (u8 *)(& phba->boot_sess.initiator_iscsiname));
  }
#line 452
  goto ldv_56951;
  switch_default: /* CIL Label */ 
#line 454
  rc = -38;
#line 455
  goto ldv_56951;
  switch_break: /* CIL Label */ ;
  }
  ldv_56951: ;
#line 457
  return ((ssize_t )rc);
}
}
#line 460 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static ssize_t beiscsi_show_boot_eth_info(void *data , int type , char *buf ) 
{ 
  struct beiscsi_hba *phba ;
  char *str ;
  int rc ;

  {
#line 462
  phba = (struct beiscsi_hba *)data;
#line 463
  str = buf;
  {
#line 467
  if (type == 1) {
#line 467
    goto case_1;
  } else {

  }
#line 470
  if (type == 0) {
#line 470
    goto case_0;
  } else {

  }
#line 473
  if (type == 10) {
#line 473
    goto case_10;
  } else {

  }
#line 476
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 468
  rc = sprintf(str, "2\n");
  }
#line 469
  goto ldv_56962;
  case_0: /* CIL Label */ 
  {
#line 471
  rc = sprintf(str, "0\n");
  }
#line 472
  goto ldv_56962;
  case_10: /* CIL Label */ 
  {
#line 474
  rc = beiscsi_get_macaddr(str, phba);
  }
#line 475
  goto ldv_56962;
  switch_default: /* CIL Label */ 
#line 477
  rc = -38;
#line 478
  goto ldv_56962;
  switch_break: /* CIL Label */ ;
  }
  ldv_56962: ;
#line 480
  return ((ssize_t )rc);
}
}
#line 484 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static umode_t beiscsi_tgt_get_attr_visibility(void *data , int type ) 
{ 
  umode_t rc ;

  {
  {
#line 489
  if (type == 7) {
#line 489
    goto case_7;
  } else {

  }
#line 490
  if (type == 2) {
#line 490
    goto case_2;
  } else {

  }
#line 491
  if (type == 3) {
#line 491
    goto case_3;
  } else {

  }
#line 492
  if (type == 8) {
#line 492
    goto case_8;
  } else {

  }
#line 493
  if (type == 9) {
#line 493
    goto case_9;
  } else {

  }
#line 494
  if (type == 10) {
#line 494
    goto case_10;
  } else {

  }
#line 495
  if (type == 11) {
#line 495
    goto case_11;
  } else {

  }
#line 496
  if (type == 6) {
#line 496
    goto case_6;
  } else {

  }
#line 497
  if (type == 1) {
#line 497
    goto case_1;
  } else {

  }
#line 500
  goto switch_default;
  case_7: /* CIL Label */ ;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_11: /* CIL Label */ ;
  case_6: /* CIL Label */ ;
  case_1: /* CIL Label */ 
#line 498
  rc = 292U;
#line 499
  goto ldv_56980;
  switch_default: /* CIL Label */ 
#line 501
  rc = 0U;
#line 502
  goto ldv_56980;
  switch_break: /* CIL Label */ ;
  }
  ldv_56980: ;
#line 504
  return (rc);
}
}
#line 507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static umode_t beiscsi_ini_get_attr_visibility(void *data , int type ) 
{ 
  umode_t rc ;

  {
  {
#line 512
  if (type == 6) {
#line 512
    goto case_6;
  } else {

  }
#line 515
  goto switch_default;
  case_6: /* CIL Label */ 
#line 513
  rc = 292U;
#line 514
  goto ldv_56988;
  switch_default: /* CIL Label */ 
#line 516
  rc = 0U;
#line 517
  goto ldv_56988;
  switch_break: /* CIL Label */ ;
  }
  ldv_56988: ;
#line 519
  return (rc);
}
}
#line 523 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static umode_t beiscsi_eth_get_attr_visibility(void *data , int type ) 
{ 
  umode_t rc ;

  {
  {
#line 528
  if (type == 1) {
#line 528
    goto case_1;
  } else {

  }
#line 529
  if (type == 10) {
#line 529
    goto case_10;
  } else {

  }
#line 530
  if (type == 0) {
#line 530
    goto case_0;
  } else {

  }
#line 533
  goto switch_default;
  case_1: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_0: /* CIL Label */ 
#line 531
  rc = 292U;
#line 532
  goto ldv_56998;
  switch_default: /* CIL Label */ 
#line 534
  rc = 0U;
#line 535
  goto ldv_56998;
  switch_break: /* CIL Label */ ;
  }
  ldv_56998: ;
#line 537
  return (rc);
}
}
#line 541 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct pci_device_id  const  beiscsi_pci_id_table[7U]  = {      {6562U, 530U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 546U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1794U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1795U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {6562U, 1810U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {4319U, 1826U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 550 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct pci_device_id  const  __mod_pci__beiscsi_pci_id_table_device_table[7U]  ;
#line 553 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct scsi_host_template beiscsi_sht  = 
#line 553
     {& __this_module, "Emulex 10Gbe open-iscsi Initiator Driver", 0, 0, 0, 0, 0, & iscsi_queuecommand,
    & beiscsi_eh_abort, & beiscsi_eh_device_reset, & iscsi_eh_session_reset, 0, 0,
    0, & beiscsi_slave_configure, 0, & iscsi_target_alloc, 0, 0, 0, & scsi_change_queue_depth,
    0, 0, 0, 0, 0, 0, "be2iscsi", 0, 1024, -1, 30U, (unsigned short)0, 1024U, 0UL,
    128, (unsigned char)0, 0, (unsigned char)0, 1U, (unsigned char)0, (unsigned char)0,
    1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U,
    (struct device_attribute **)(& beiscsi_attrs), 0, {0, 0}, 72057594037934498ULL,
    0U, 0, (_Bool)0};
#line 575 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct scsi_transport_template *beiscsi_scsi_transport  ;
#line 577 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct beiscsi_hba *beiscsi_hba_alloc(struct pci_dev *pcidev ) 
{ 
  struct beiscsi_hba *phba ;
  struct Scsi_Host *shost ;
  void *tmp ;

  {
  {
#line 582
  shost = iscsi_host_alloc(& beiscsi_sht, 13040, 0);
  }
#line 583
  if ((unsigned long )shost == (unsigned long )((struct Scsi_Host *)0)) {
    {
#line 584
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_hba_alloc - iscsi_host_alloc failed\n");
    }
#line 586
    return ((struct beiscsi_hba *)0);
  } else {

  }
  {
#line 588
  shost->max_id = 256U;
#line 589
  shost->max_channel = 0U;
#line 590
  shost->max_cmd_len = 16U;
#line 591
  shost->max_lun = 256ULL;
#line 592
  shost->transportt = beiscsi_scsi_transport;
#line 593
  tmp = shost_priv(shost);
#line 593
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 594
  __memset((void *)phba, 0, 13040UL);
#line 595
  phba->shost = shost;
#line 596
  phba->pcidev = pci_dev_get(pcidev);
#line 597
  pci_set_drvdata(pcidev, (void *)phba);
#line 598
  phba->interface_handle = 4294967295U;
  }
#line 600
  return (phba);
}
}
#line 603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_unmap_pci_function(struct beiscsi_hba *phba ) 
{ 


  {
#line 605
  if ((unsigned long )phba->csr_va != (unsigned long )((u8 *)0U)) {
    {
#line 606
    ldv_iounmap_128((void volatile   *)phba->csr_va);
#line 607
    phba->csr_va = (u8 *)0U;
    }
  } else {

  }
#line 609
  if ((unsigned long )phba->db_va != (unsigned long )((u8 *)0U)) {
    {
#line 610
    ldv_iounmap_129((void volatile   *)phba->db_va);
#line 611
    phba->db_va = (u8 *)0U;
    }
  } else {

  }
#line 613
  if ((unsigned long )phba->pci_va != (unsigned long )((u8 *)0U)) {
    {
#line 614
    ldv_iounmap_130((void volatile   *)phba->pci_va);
#line 615
    phba->pci_va = (u8 *)0U;
    }
  } else {

  }
#line 617
  return;
}
}
#line 619 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_map_pci_bars(struct beiscsi_hba *phba , struct pci_dev *pcidev ) 
{ 
  u8 *addr ;
  int pcicfg_reg ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 625
  tmp = ldv_ioremap_nocache_131(pcidev->resource[2].start, pcidev->resource[2].start != 0ULL || pcidev->resource[2].end != pcidev->resource[2].start ? (unsigned long )((pcidev->resource[2].end - pcidev->resource[2].start) + 1ULL) : 0UL);
#line 625
  addr = (u8 *)tmp;
  }
#line 627
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 628
    return (-12);
  } else {

  }
  {
#line 629
  phba->ctrl.csr = addr;
#line 630
  phba->csr_va = addr;
#line 631
  phba->csr_pa.u.a64.address = pcidev->resource[2].start;
#line 633
  tmp___0 = ldv_ioremap_nocache_132(pcidev->resource[4].start, 131072UL);
#line 633
  addr = (u8 *)tmp___0;
  }
#line 634
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 635
    goto pci_map_err;
  } else {

  }
#line 636
  phba->ctrl.db = addr;
#line 637
  phba->db_va = addr;
#line 638
  phba->db_pa.u.a64.address = pcidev->resource[4].start;
#line 640
  if (phba->generation == 2U) {
#line 641
    pcicfg_reg = 1;
  } else {
#line 643
    pcicfg_reg = 0;
  }
  {
#line 645
  tmp___1 = ldv_ioremap_nocache_133(pcidev->resource[pcicfg_reg].start, pcidev->resource[pcicfg_reg].start != 0ULL || pcidev->resource[pcicfg_reg].end != pcidev->resource[pcicfg_reg].start ? (unsigned long )((pcidev->resource[pcicfg_reg].end - pcidev->resource[pcicfg_reg].start) + 1ULL) : 0UL);
#line 645
  addr = (u8 *)tmp___1;
  }
#line 648
  if ((unsigned long )addr == (unsigned long )((u8 *)0U)) {
#line 649
    goto pci_map_err;
  } else {

  }
#line 650
  phba->ctrl.pcicfg = addr;
#line 651
  phba->pci_va = addr;
#line 652
  phba->pci_pa.u.a64.address = pcidev->resource[pcicfg_reg].start;
#line 653
  return (0);
  pci_map_err: 
  {
#line 656
  beiscsi_unmap_pci_function(phba);
  }
#line 657
  return (-12);
}
}
#line 660 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_enable_pci(struct pci_dev *pcidev ) 
{ 
  int ret ;

  {
  {
#line 664
  ret = pci_enable_device(pcidev);
  }
#line 665
  if (ret != 0) {
    {
#line 666
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_enable_pci - enable device failed\n");
    }
#line 668
    return (ret);
  } else {

  }
  {
#line 671
  pci_set_master(pcidev);
#line 672
  ret = pci_set_dma_mask(pcidev, 0xffffffffffffffffULL);
  }
#line 673
  if (ret != 0) {
    {
#line 674
    ret = pci_set_dma_mask(pcidev, 4294967295ULL);
    }
#line 675
    if (ret != 0) {
      {
#line 676
      dev_err((struct device  const  *)(& pcidev->dev), "Could not set PCI DMA Mask\n");
#line 677
      pci_disable_device(pcidev);
      }
#line 678
      return (ret);
    } else {
      {
#line 680
      ret = pci_set_consistent_dma_mask(pcidev, 4294967295ULL);
      }
    }
  } else {
    {
#line 684
    ret = pci_set_consistent_dma_mask(pcidev, 0xffffffffffffffffULL);
    }
#line 685
    if (ret != 0) {
      {
#line 686
      dev_err((struct device  const  *)(& pcidev->dev), "Could not set PCI DMA Mask\n");
#line 687
      pci_disable_device(pcidev);
      }
#line 688
      return (ret);
    } else {

    }
  }
#line 691
  return (0);
}
}
#line 694 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int be_ctrl_init(struct beiscsi_hba *phba , struct pci_dev *pdev ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_dma_mem *mbox_mem_alloc ;
  struct be_dma_mem *mbox_mem_align ;
  int status ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;

  {
  {
#line 696
  ctrl = & phba->ctrl;
#line 697
  mbox_mem_alloc = & ctrl->mbox_mem_alloced;
#line 698
  mbox_mem_align = & ctrl->mbox_mem;
#line 699
  status = 0;
#line 701
  ctrl->pdev = pdev;
#line 702
  status = beiscsi_map_pci_bars(phba, pdev);
  }
#line 703
  if (status != 0) {
#line 704
    return (status);
  } else {

  }
  {
#line 705
  mbox_mem_alloc->size = 288U;
#line 706
  mbox_mem_alloc->va = pci_alloc_consistent(pdev, (size_t )mbox_mem_alloc->size, & mbox_mem_alloc->dma);
  }
#line 709
  if ((unsigned long )mbox_mem_alloc->va == (unsigned long )((void *)0)) {
    {
#line 710
    beiscsi_unmap_pci_function(phba);
    }
#line 711
    return (-12);
  } else {

  }
  {
#line 714
  mbox_mem_align->size = 272U;
#line 715
  mbox_mem_align->va = (void *)(((unsigned long )mbox_mem_alloc->va + 15UL) & 0xfffffffffffffff0UL);
#line 716
  mbox_mem_align->dma = (unsigned long long )((unsigned long )mbox_mem_alloc->dma + 15UL) & 0xfffffffffffffff0ULL;
#line 717
  __memset(mbox_mem_align->va, 0, 272UL);
#line 718
  spinlock_check(& ctrl->mbox_lock);
#line 718
  __raw_spin_lock_init(& ctrl->mbox_lock.__annonCompField18.rlock, "&(&ctrl->mbox_lock)->rlock",
                       & __key);
#line 719
  spinlock_check(& phba->ctrl.mcc_lock);
#line 719
  __raw_spin_lock_init(& phba->ctrl.mcc_lock.__annonCompField18.rlock, "&(&phba->ctrl.mcc_lock)->rlock",
                       & __key___0);
#line 720
  spinlock_check(& phba->ctrl.mcc_cq_lock);
#line 720
  __raw_spin_lock_init(& phba->ctrl.mcc_cq_lock.__annonCompField18.rlock, "&(&phba->ctrl.mcc_cq_lock)->rlock",
                       & __key___1);
  }
#line 722
  return (status);
}
}
#line 729 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_get_params(struct beiscsi_hba *phba ) 
{ 
  uint32_t total_cid_count ;
  uint32_t total_icd_count ;
  uint8_t ulp_num ;
  uint32_t align_mask ;
  uint32_t icd_post_per_page ;
  uint32_t icd_count_unavailable ;
  uint32_t icd_start ;
  uint32_t icd_count ;
  uint32_t icd_start_align ;
  uint32_t icd_count_align ;
  uint32_t log_value ;
  int tmp___0 ;

  {
#line 731
  total_cid_count = 0U;
#line 732
  total_icd_count = 0U;
#line 733
  ulp_num = 0U;
#line 735
  total_cid_count = phba->fw_config.iscsi_cid_count[0] + phba->fw_config.iscsi_cid_count[1];
#line 738
  ulp_num = 0U;
#line 738
  goto ldv_57050;
  ldv_57049: 
  {
#line 739
  align_mask = 0U;
#line 740
  icd_post_per_page = 0U;
#line 741
  icd_count_unavailable = 0U;
#line 742
  icd_start = 0U;
#line 742
  icd_count = 0U;
#line 743
  icd_start_align = 0U;
#line 743
  icd_count_align = 0U;
#line 745
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 745
  if (tmp___0 != 0) {
#line 746
    icd_start = phba->fw_config.iscsi_icd_start[(int )ulp_num];
#line 747
    icd_count = phba->fw_config.iscsi_icd_count[(int )ulp_num];
#line 750
    icd_post_per_page = 8U;
#line 752
    align_mask = icd_post_per_page - 1U;
#line 755
    if (icd_start % icd_post_per_page != 0U) {
#line 756
      icd_start_align = (icd_start + icd_post_per_page) & ~ align_mask;
#line 759
      phba->fw_config.iscsi_icd_start[(int )ulp_num] = icd_start_align;
    } else {

    }
#line 764
    icd_count_align = icd_count & ~ align_mask;
#line 767
    if (icd_start_align != 0U) {
#line 768
      icd_count_unavailable = (icd_start_align - icd_start) + (icd_count - icd_count_align);
    } else {

    }
#line 774
    phba->fw_config.iscsi_icd_count[(int )ulp_num] = icd_count - icd_count_unavailable;
#line 777
    log_value = phba->attr_log_enable;
#line 777
    if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 777
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : Aligned ICD values\n\t ICD Start : %d\n\t ICD Count : %d\n\t ICD Discarded : %d\n",
                 786, phba->fw_config.iscsi_icd_start[(int )ulp_num], phba->fw_config.iscsi_icd_count[(int )ulp_num],
                 icd_count_unavailable);
      }
    } else {

    }
#line 787
    goto ldv_57048;
  } else {

  }
#line 738
  ulp_num = (uint8_t )((int )ulp_num + 1);
  ldv_57050: ;
#line 738
  if ((unsigned int )ulp_num <= 1U) {
#line 740
    goto ldv_57049;
  } else {

  }
  ldv_57048: 
#line 791
  total_icd_count = phba->fw_config.iscsi_icd_count[(int )ulp_num];
#line 792
  phba->params.ios_per_ctrl = (total_icd_count - total_cid_count) - 32U;
#line 795
  phba->params.cxns_per_ctrl = total_cid_count;
#line 796
  phba->params.asyncpdus_per_ctrl = total_cid_count;
#line 797
  phba->params.icds_per_ctrl = total_icd_count;
#line 798
  phba->params.num_sge_per_io = 32U;
#line 799
  phba->params.defpdu_hdr_sz = 64U;
#line 800
  phba->params.defpdu_data_sz = 8192U;
#line 801
  phba->params.eq_timer = 64U;
#line 802
  phba->params.num_eq_entries = 1024U;
#line 803
  phba->params.num_cq_entries = 1024U;
#line 804
  phba->params.wrbs_per_cxn = 256U;
#line 805
  return;
}
}
#line 807 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_ring_eq_db(struct beiscsi_hba *phba , unsigned int id , unsigned int clr_interrupt ,
                           unsigned int num_processed , unsigned char rearm , unsigned char event ) 
{ 
  u32 val ;

  {
#line 812
  val = 0U;
#line 814
  if ((unsigned int )rearm != 0U) {
#line 815
    val = val | 536870912U;
  } else {

  }
#line 816
  if (clr_interrupt != 0U) {
#line 817
    val = val | 512U;
  } else {

  }
#line 818
  if ((unsigned int )event != 0U) {
#line 819
    val = val | 1024U;
  } else {

  }
  {
#line 821
  val = val | (num_processed << 16);
#line 823
  val = val | (id & 511U);
#line 826
  val = val | (((id >> 9) << 11) & 65535U);
#line 830
  iowrite32(val, (void *)phba->db_va + 288U);
  }
#line 831
  return;
}
}
#line 838 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static irqreturn_t be_isr_mcc(int irq , void *dev_id ) 
{ 
  struct beiscsi_hba *phba ;
  struct be_eq_entry *eqe ;
  struct be_queue_info *eq ;
  struct be_queue_info *mcc ;
  unsigned int num_eq_processed ;
  struct be_eq_obj *pbe_eq ;
  unsigned long flags ;
  void *tmp ;
  u32 tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 841
  eqe = (struct be_eq_entry *)0;
#line 848
  pbe_eq = (struct be_eq_obj *)dev_id;
#line 849
  eq = & pbe_eq->q;
#line 850
  phba = pbe_eq->phba;
#line 851
  mcc = & phba->ctrl.mcc_obj.cq;
#line 852
  tmp = queue_tail_node(eq);
#line 852
  eqe = (struct be_eq_entry *)tmp;
#line 854
  num_eq_processed = 0U;
  }
#line 856
  goto ldv_57072;
  ldv_57071: ;
#line 858
  if (eqe->dw[0UL] >> 16 == (u32 )mcc->id) {
    {
#line 861
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_134(& phba->isr_lock);
#line 862
    pbe_eq->todo_mcc_cq = 1;
#line 863
    ldv_spin_unlock_irqrestore_135(& phba->isr_lock, flags);
    }
  } else {

  }
  {
#line 865
  tmp___0 = amap_mask(1U);
#line 865
  amap_set((void *)eqe, 0U, tmp___0, 0U, 0U);
#line 866
  queue_tail_inc(eq);
#line 867
  tmp___1 = queue_tail_node(eq);
#line 867
  eqe = (struct be_eq_entry *)tmp___1;
#line 868
  num_eq_processed = num_eq_processed + 1U;
  }
  ldv_57072: ;
#line 856
  if ((int )eqe->dw[0UL] & 1) {
#line 858
    goto ldv_57071;
  } else {

  }

#line 870
  if ((int )pbe_eq->todo_mcc_cq) {
    {
#line 871
    queue_work(phba->wq, & pbe_eq->work_cqs);
    }
  } else {

  }
#line 872
  if (num_eq_processed != 0U) {
    {
#line 873
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 1U, num_eq_processed, 1, 1);
    }
  } else {

  }
#line 875
  return (1);
}
}
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static irqreturn_t be_isr_msix(int irq , void *dev_id ) 
{ 
  struct beiscsi_hba *phba ;
  struct be_eq_entry *eqe ;
  struct be_queue_info *eq ;
  struct be_queue_info *cq ;
  unsigned int num_eq_processed ;
  struct be_eq_obj *pbe_eq ;
  void *tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 886
  eqe = (struct be_eq_entry *)0;
#line 892
  pbe_eq = (struct be_eq_obj *)dev_id;
#line 893
  eq = & pbe_eq->q;
#line 894
  cq = pbe_eq->cq;
#line 895
  tmp = queue_tail_node(eq);
#line 895
  eqe = (struct be_eq_entry *)tmp;
#line 897
  phba = pbe_eq->phba;
#line 898
  num_eq_processed = 0U;
  }
#line 899
  goto ldv_57085;
  ldv_57084: 
  {
#line 901
  tmp___0 = blk_iopoll_sched_prep(& pbe_eq->iopoll);
  }
#line 901
  if (tmp___0 == 0) {
    {
#line 902
    blk_iopoll_sched(& pbe_eq->iopoll);
    }
  } else {

  }
  {
#line 904
  tmp___1 = amap_mask(1U);
#line 904
  amap_set((void *)eqe, 0U, tmp___1, 0U, 0U);
#line 905
  queue_tail_inc(eq);
#line 906
  tmp___2 = queue_tail_node(eq);
#line 906
  eqe = (struct be_eq_entry *)tmp___2;
#line 907
  num_eq_processed = num_eq_processed + 1U;
  }
  ldv_57085: ;
#line 899
  if ((int )eqe->dw[0UL] & 1) {
#line 901
    goto ldv_57084;
  } else {

  }

#line 910
  if (num_eq_processed != 0U) {
    {
#line 911
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 1U, num_eq_processed, 0, 1);
    }
  } else {

  }
#line 913
  return (1);
}
}
#line 921 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static irqreturn_t be_isr(int irq , void *dev_id ) 
{ 
  struct beiscsi_hba *phba ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_eq_entry *eqe ;
  struct be_queue_info *eq ;
  struct be_queue_info *mcc ;
  unsigned long flags ;
  unsigned long index ;
  unsigned int num_mcceq_processed ;
  unsigned int num_ioeq_processed ;
  struct be_ctrl_info *ctrl ;
  struct be_eq_obj *pbe_eq ;
  int isr ;
  unsigned int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u32 tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 926
  eqe = (struct be_eq_entry *)0;
#line 935
  phba = (struct beiscsi_hba *)dev_id;
#line 936
  ctrl = & phba->ctrl;
#line 937
  tmp = ioread32((void *)(ctrl->csr + ((unsigned long )(((ctrl->pdev)->devfn & 7U) * 4U) + 3096UL)));
#line 937
  isr = (int )tmp;
  }
#line 939
  if (isr == 0) {
#line 940
    return (0);
  } else {

  }
  {
#line 942
  phwi_ctrlr = phba->phwi_ctrlr;
#line 943
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 944
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq);
#line 946
  eq = & phwi_context->be_eq[0].q;
#line 947
  mcc = & phba->ctrl.mcc_obj.cq;
#line 948
  index = 0UL;
#line 949
  tmp___0 = queue_tail_node(eq);
#line 949
  eqe = (struct be_eq_entry *)tmp___0;
#line 951
  num_ioeq_processed = 0U;
#line 952
  num_mcceq_processed = 0U;
  }
#line 953
  goto ldv_57105;
  ldv_57104: ;
#line 955
  if (eqe->dw[0UL] >> 16 == (u32 )mcc->id) {
    {
#line 958
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_136(& phba->isr_lock);
#line 959
    pbe_eq->todo_mcc_cq = 1;
#line 960
    ldv_spin_unlock_irqrestore_135(& phba->isr_lock, flags);
#line 961
    num_mcceq_processed = num_mcceq_processed + 1U;
    }
  } else {
    {
#line 963
    tmp___1 = blk_iopoll_sched_prep(& pbe_eq->iopoll);
    }
#line 963
    if (tmp___1 == 0) {
      {
#line 964
      blk_iopoll_sched(& pbe_eq->iopoll);
      }
    } else {

    }
#line 965
    num_ioeq_processed = num_ioeq_processed + 1U;
  }
  {
#line 967
  tmp___2 = amap_mask(1U);
#line 967
  amap_set((void *)eqe, 0U, tmp___2, 0U, 0U);
#line 968
  queue_tail_inc(eq);
#line 969
  tmp___3 = queue_tail_node(eq);
#line 969
  eqe = (struct be_eq_entry *)tmp___3;
  }
  ldv_57105: ;
#line 953
  if ((int )eqe->dw[0UL] & 1) {
#line 955
    goto ldv_57104;
  } else {

  }

#line 971
  if ((num_ioeq_processed | num_mcceq_processed) != 0U) {
#line 972
    if ((int )pbe_eq->todo_mcc_cq) {
      {
#line 973
      queue_work(phba->wq, & pbe_eq->work_cqs);
      }
    } else {

    }
#line 975
    if (num_mcceq_processed != 0U && num_ioeq_processed == 0U) {
      {
#line 976
      hwi_ring_eq_db(phba, (unsigned int )eq->id, 0U, num_ioeq_processed + num_mcceq_processed,
                     1, 1);
      }
    } else {
      {
#line 980
      hwi_ring_eq_db(phba, (unsigned int )eq->id, 0U, num_ioeq_processed + num_mcceq_processed,
                     0, 1);
      }
    }
#line 984
    return (1);
  } else {
#line 986
    return (0);
  }
}
}
#line 989 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_irqs(struct beiscsi_hba *phba ) 
{ 
  struct pci_dev *pcidev ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  int ret ;
  int msix_vec ;
  int i ;
  int j ;
  void *tmp ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 991
  pcidev = phba->pcidev;
#line 996
  phwi_ctrlr = phba->phwi_ctrlr;
#line 997
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 999
  if ((int )phba->msix_enabled) {
#line 1000
    i = 0;
#line 1000
    goto ldv_57120;
    ldv_57119: 
    {
#line 1001
    tmp = kzalloc(20UL, 208U);
#line 1001
    phba->msi_name[i] = (char *)tmp;
    }
#line 1003
    if ((unsigned long )phba->msi_name[i] == (unsigned long )((char *)0)) {
#line 1004
      ret = -12;
#line 1005
      goto free_msix_irqs;
    } else {

    }
    {
#line 1008
    sprintf(phba->msi_name[i], "beiscsi_%02x_%02x", (phba->shost)->host_no, i);
#line 1010
    msix_vec = (int )phba->msix_entries[i].vector;
#line 1011
    ret = ldv_request_irq_138((unsigned int )msix_vec, & be_isr_msix, 0UL, (char const   *)phba->msi_name[i],
                              (void *)(& phwi_context->be_eq) + (unsigned long )i);
    }
#line 1014
    if (ret != 0) {
#line 1015
      log_value = phba->attr_log_enable;
#line 1015
      if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 1015
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : beiscsi_init_irqs-Failed toregister msix for i = %d\n",
                   1018, i);
        }
      } else {

      }
      {
#line 1019
      kfree((void const   *)phba->msi_name[i]);
      }
#line 1020
      goto free_msix_irqs;
    } else {

    }
#line 1000
    i = i + 1;
    ldv_57120: ;
#line 1000
    if ((unsigned int )i < phba->num_cpus) {
#line 1002
      goto ldv_57119;
    } else {

    }
    {
#line 1023
    tmp___0 = kzalloc(20UL, 208U);
#line 1023
    phba->msi_name[i] = (char *)tmp___0;
    }
#line 1024
    if ((unsigned long )phba->msi_name[i] == (unsigned long )((char *)0)) {
#line 1025
      ret = -12;
#line 1026
      goto free_msix_irqs;
    } else {

    }
    {
#line 1028
    sprintf(phba->msi_name[i], "beiscsi_mcc_%02x", (phba->shost)->host_no);
#line 1030
    msix_vec = (int )phba->msix_entries[i].vector;
#line 1031
    ret = ldv_request_irq_139((unsigned int )msix_vec, & be_isr_mcc, 0UL, (char const   *)phba->msi_name[i],
                              (void *)(& phwi_context->be_eq) + (unsigned long )i);
    }
#line 1033
    if (ret != 0) {
#line 1034
      log_value___0 = phba->attr_log_enable;
#line 1034
      if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 1034
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : beiscsi_init_irqs-Failed to register beiscsi_msix_mcc\n",
                   1036);
        }
      } else {

      }
      {
#line 1037
      kfree((void const   *)phba->msi_name[i]);
      }
#line 1038
      goto free_msix_irqs;
    } else {

    }
  } else {
    {
#line 1042
    ret = ldv_request_irq_140(pcidev->irq, & be_isr, 128UL, "beiscsi", (void *)phba);
    }
#line 1044
    if (ret != 0) {
#line 1045
      log_value___1 = phba->attr_log_enable;
#line 1045
      if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 1045
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : beiscsi_init_irqs-Failed to register irq\\n", 1047);
        }
      } else {

      }
#line 1048
      return (ret);
    } else {

    }
  }
#line 1051
  return (0);
  free_msix_irqs: 
#line 1053
  j = i + -1;
#line 1053
  goto ldv_57125;
  ldv_57124: 
  {
#line 1054
  kfree((void const   *)phba->msi_name[j]);
#line 1055
  msix_vec = (int )phba->msix_entries[j].vector;
#line 1056
  ldv_free_irq_141((unsigned int )msix_vec, (void *)(& phwi_context->be_eq) + (unsigned long )j);
#line 1053
  j = j - 1;
  }
  ldv_57125: ;
#line 1053
  if (j >= 0) {
#line 1055
    goto ldv_57124;
  } else {

  }

#line 1058
  return (ret);
}
}
#line 1061 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
void hwi_ring_cq_db(struct beiscsi_hba *phba , unsigned int id , unsigned int num_processed ,
                    unsigned char rearm , unsigned char event ) 
{ 
  u32 val ;

  {
#line 1065
  val = 0U;
#line 1067
  if ((unsigned int )rearm != 0U) {
#line 1068
    val = val | 536870912U;
  } else {

  }
  {
#line 1070
  val = val | (num_processed << 16);
#line 1073
  val = val | (id & 1023U);
#line 1076
  val = val | (((id >> 10) << 11) & 65535U);
#line 1080
  iowrite32(val, (void *)phba->db_va + 288U);
  }
#line 1081
  return;
}
}
#line 1084 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static unsigned int beiscsi_process_async_pdu(struct beiscsi_conn *beiscsi_conn ,
                                              struct beiscsi_hba *phba , struct pdu_base *ppdu ,
                                              unsigned long pdu_len , void *pbuffer ,
                                              unsigned long buf_len ) 
{ 
  struct iscsi_conn *conn ;
  struct iscsi_session *session ;
  struct iscsi_task *task ;
  struct beiscsi_io_task *io_task ;
  struct iscsi_hdr *login_hdr ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 1090
  conn = beiscsi_conn->conn;
#line 1091
  session = conn->session;
  {
#line 1098
  if ((ppdu->dw[0UL] & 63U) == 32U) {
#line 1098
    goto case_32;
  } else {

  }
#line 1102
  if ((ppdu->dw[0UL] & 63U) == 50U) {
#line 1102
    goto case_50;
  } else {

  }
#line 1104
  if ((ppdu->dw[0UL] & 63U) == 63U) {
#line 1104
    goto case_63;
  } else {

  }
#line 1111
  if ((ppdu->dw[0UL] & 63U) == 35U) {
#line 1111
    goto case_35;
  } else {

  }
#line 1112
  if ((ppdu->dw[0UL] & 63U) == 36U) {
#line 1112
    goto case_36;
  } else {

  }
#line 1118
  goto switch_default;
  case_32: /* CIL Label */ 
#line 1099
  pbuffer = (void *)0;
#line 1100
  buf_len = 0UL;
#line 1101
  goto ldv_57149;
  case_50: /* CIL Label */ ;
#line 1103
  goto ldv_57149;
  case_63: /* CIL Label */ 
  {
#line 1105
  __ret_warn_on = (unsigned long )pbuffer == (unsigned long )((void *)0);
#line 1105
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 1105
  if (tmp != 0L) {
    {
#line 1105
    warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 1105);
    }
  } else {

  }
  {
#line 1105
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 1106
  __ret_warn_on___0 = buf_len != 48UL;
#line 1106
  tmp___0 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
#line 1106
  if (tmp___0 != 0L) {
    {
#line 1106
    warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 1106);
    }
  } else {

  }
  {
#line 1106
  __builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1107
  log_value = phba->attr_log_enable;
  }
#line 1107
  if ((log_value & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 1107
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In ISCSI_OP_REJECT\n",
               1109);
    }
  } else {

  }
#line 1110
  goto ldv_57149;
  case_35: /* CIL Label */ ;
  case_36: /* CIL Label */ 
#line 1113
  task = conn->login_task;
#line 1114
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1115
  login_hdr = (struct iscsi_hdr *)ppdu;
#line 1116
  login_hdr->itt = io_task->libiscsi_itt;
#line 1117
  goto ldv_57149;
  switch_default: /* CIL Label */ 
#line 1119
  log_value___0 = phba->attr_log_enable;
#line 1119
  if ((log_value___0 & 48U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
    {
#line 1119
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Unrecognized opcode 0x%x in async msg\n",
               1124, ppdu->dw[0UL] & 63U);
    }
  } else {

  }
#line 1125
  return (1U);
  switch_break: /* CIL Label */ ;
  }
  ldv_57149: 
  {
#line 1128
  ldv_spin_lock_bh_142(& session->back_lock);
#line 1129
  __iscsi_complete_pdu(conn, (struct iscsi_hdr *)ppdu, (char *)pbuffer, (int )buf_len);
#line 1130
  ldv_spin_unlock_bh_143(& session->back_lock);
  }
#line 1131
  return (0U);
}
}
#line 1134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct sgl_handle *alloc_io_sgl_handle(struct beiscsi_hba *phba ) 
{ 
  struct sgl_handle *psgl_handle ;
  uint32_t log_value ;

  {
#line 1138
  if ((unsigned int )phba->io_sgl_hndl_avbl != 0U) {
#line 1139
    log_value = phba->attr_log_enable;
#line 1139
    if ((log_value & 16U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 1139
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : In alloc_io_sgl_handle, io_sgl_alloc_index=%d\n", 1142,
                 (int )phba->io_sgl_alloc_index);
      }
    } else {

    }
#line 1144
    psgl_handle = *(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_alloc_index);
#line 1146
    *(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_alloc_index) = (struct sgl_handle *)0;
#line 1147
    phba->io_sgl_hndl_avbl = (unsigned short )((int )phba->io_sgl_hndl_avbl - 1);
#line 1148
    if ((unsigned int )phba->io_sgl_alloc_index == phba->params.ios_per_ctrl - 1U) {
#line 1150
      phba->io_sgl_alloc_index = 0U;
    } else {
#line 1152
      phba->io_sgl_alloc_index = (unsigned short )((int )phba->io_sgl_alloc_index + 1);
    }
  } else {
#line 1154
    psgl_handle = (struct sgl_handle *)0;
  }
#line 1155
  return (psgl_handle);
}
}
#line 1159 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void free_io_sgl_handle(struct beiscsi_hba *phba , struct sgl_handle *psgl_handle ) 
{ 
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 1161
  log_value = phba->attr_log_enable;
#line 1161
  if ((log_value & 16U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1161
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In free_,io_sgl_free_index=%d\n",
               1163, (int )phba->io_sgl_free_index);
    }
  } else {

  }
#line 1165
  if ((unsigned long )*(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_free_index) != (unsigned long )((struct sgl_handle *)0)) {
#line 1170
    log_value___0 = phba->attr_log_enable;
#line 1170
    if ((log_value___0 & 16U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 1170
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : Double Free in IO SGL io_sgl_free_index=%d,value there=%p\n",
                 1174, (int )phba->io_sgl_free_index, *(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_free_index));
      }
    } else {

    }
#line 1175
    return;
  } else {

  }
#line 1177
  *(phba->io_sgl_hndl_base + (unsigned long )phba->io_sgl_free_index) = psgl_handle;
#line 1178
  phba->io_sgl_hndl_avbl = (unsigned short )((int )phba->io_sgl_hndl_avbl + 1);
#line 1179
  if ((unsigned int )phba->io_sgl_free_index == phba->params.ios_per_ctrl - 1U) {
#line 1180
    phba->io_sgl_free_index = 0U;
  } else {
#line 1182
    phba->io_sgl_free_index = (unsigned short )((int )phba->io_sgl_free_index + 1);
  }
#line 1183
  return;
}
}
#line 1192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct wrb_handle *alloc_wrb_handle(struct beiscsi_hba *phba , unsigned int cid ) 
{ 
  struct hwi_wrb_context *pwrb_context ;
  struct hwi_controller *phwi_ctrlr ;
  struct wrb_handle *pwrb_handle ;
  struct wrb_handle *pwrb_handle_tmp ;
  uint16_t cri_index ;

  {
#line 1197
  cri_index = phba->cid_to_cri_map[cid];
#line 1199
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1200
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 1201
  if ((unsigned int )pwrb_context->wrb_handles_available > 1U) {
#line 1202
    pwrb_handle = *(pwrb_context->pwrb_handle_base + (unsigned long )pwrb_context->alloc_index);
#line 1204
    pwrb_context->wrb_handles_available = (unsigned short )((int )pwrb_context->wrb_handles_available - 1);
#line 1205
    if ((unsigned int )pwrb_context->alloc_index == phba->params.wrbs_per_cxn - 1U) {
#line 1207
      pwrb_context->alloc_index = 0U;
    } else {
#line 1209
      pwrb_context->alloc_index = (unsigned short )((int )pwrb_context->alloc_index + 1);
    }
#line 1210
    pwrb_handle_tmp = *(pwrb_context->pwrb_handle_base + (unsigned long )pwrb_context->alloc_index);
#line 1212
    pwrb_handle->nxt_wrb_index = pwrb_handle_tmp->wrb_index;
  } else {
#line 1214
    pwrb_handle = (struct wrb_handle *)0;
  }
#line 1215
  return (pwrb_handle);
}
}
#line 1227 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void free_wrb_handle(struct beiscsi_hba *phba , struct hwi_wrb_context *pwrb_context ,
                            struct wrb_handle *pwrb_handle ) 
{ 
  uint32_t log_value ;

  {
#line 1230
  *(pwrb_context->pwrb_handle_base + (unsigned long )pwrb_context->free_index) = pwrb_handle;
#line 1231
  pwrb_context->wrb_handles_available = (unsigned short )((int )pwrb_context->wrb_handles_available + 1);
#line 1232
  if ((unsigned int )pwrb_context->free_index == phba->params.wrbs_per_cxn - 1U) {
#line 1233
    pwrb_context->free_index = 0U;
  } else {
#line 1235
    pwrb_context->free_index = (unsigned short )((int )pwrb_context->free_index + 1);
  }
#line 1237
  log_value = phba->attr_log_enable;
#line 1237
  if ((log_value & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1237
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : FREE WRB: pwrb_handle=%p free_index=0x%xwrb_handles_available=%d\n",
               1242, pwrb_handle, (int )pwrb_context->free_index, (int )pwrb_context->wrb_handles_available);
    }
  } else {

  }
#line 1239
  return;
}
}
#line 1245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct sgl_handle *alloc_mgmt_sgl_handle(struct beiscsi_hba *phba ) 
{ 
  struct sgl_handle *psgl_handle ;
  uint32_t log_value ;

  {
#line 1249
  if ((unsigned int )phba->eh_sgl_hndl_avbl != 0U) {
#line 1250
    psgl_handle = *(phba->eh_sgl_hndl_base + (unsigned long )phba->eh_sgl_alloc_index);
#line 1251
    *(phba->eh_sgl_hndl_base + (unsigned long )phba->eh_sgl_alloc_index) = (struct sgl_handle *)0;
#line 1252
    log_value = phba->attr_log_enable;
#line 1252
    if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 1252
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : mgmt_sgl_alloc_index=%d=0x%x\n", 1255, (int )phba->eh_sgl_alloc_index,
                 (int )phba->eh_sgl_alloc_index);
      }
    } else {

    }
#line 1257
    phba->eh_sgl_hndl_avbl = (unsigned short )((int )phba->eh_sgl_hndl_avbl - 1);
#line 1258
    if ((unsigned int )phba->eh_sgl_alloc_index == (phba->params.icds_per_ctrl - phba->params.ios_per_ctrl) - 1U) {
#line 1261
      phba->eh_sgl_alloc_index = 0U;
    } else {
#line 1263
      phba->eh_sgl_alloc_index = (unsigned short )((int )phba->eh_sgl_alloc_index + 1);
    }
  } else {
#line 1265
    psgl_handle = (struct sgl_handle *)0;
  }
#line 1266
  return (psgl_handle);
}
}
#line 1270 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
void free_mgmt_sgl_handle(struct beiscsi_hba *phba , struct sgl_handle *psgl_handle ) 
{ 
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 1273
  log_value = phba->attr_log_enable;
#line 1273
  if ((log_value & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1273
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In  free_mgmt_sgl_handle,eh_sgl_free_index=%d\n",
               1276, (int )phba->eh_sgl_free_index);
    }
  } else {

  }
#line 1278
  if ((unsigned long )*(phba->eh_sgl_hndl_base + (unsigned long )phba->eh_sgl_free_index) != (unsigned long )((struct sgl_handle *)0)) {
#line 1283
    log_value___0 = phba->attr_log_enable;
#line 1283
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 1283
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Double Free in eh SGL ,eh_sgl_free_index=%d\n",
                 1286, (int )phba->eh_sgl_free_index);
      }
    } else {

    }
#line 1287
    return;
  } else {

  }
#line 1289
  *(phba->eh_sgl_hndl_base + (unsigned long )phba->eh_sgl_free_index) = psgl_handle;
#line 1290
  phba->eh_sgl_hndl_avbl = (unsigned short )((int )phba->eh_sgl_hndl_avbl + 1);
#line 1291
  if ((unsigned int )phba->eh_sgl_free_index == (phba->params.icds_per_ctrl - phba->params.ios_per_ctrl) - 1U) {
#line 1293
    phba->eh_sgl_free_index = 0U;
  } else {
#line 1295
    phba->eh_sgl_free_index = (unsigned short )((int )phba->eh_sgl_free_index + 1);
  }
#line 1296
  return;
}
}
#line 1299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_complete_io(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ,
                           struct common_sol_cqe *csol_cqe ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct be_status_bhs *sts_bhs ;
  struct iscsi_conn *conn ;
  unsigned char *sense ;
  u32 resid ;
  u32 exp_cmdsn ;
  u32 max_cmdsn ;
  u8 rsp ;
  u8 status ;
  u8 flags ;
  unsigned int tmp ;
  u16 sense_len ;
  unsigned short *slen ;
  __u16 tmp___0 ;
  u16 __min1 ;
  u16 __min2 ;

  {
#line 1303
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1304
  sts_bhs = (struct be_status_bhs *)io_task->cmd_bhs;
#line 1306
  conn = beiscsi_conn->conn;
#line 1308
  resid = 0U;
#line 1311
  exp_cmdsn = csol_cqe->exp_cmdsn;
#line 1312
  max_cmdsn = (csol_cqe->exp_cmdsn + (u32 )csol_cqe->cmd_wnd) - 1U;
#line 1314
  rsp = csol_cqe->i_resp;
#line 1315
  status = csol_cqe->i_sts;
#line 1316
  flags = csol_cqe->i_flags;
#line 1317
  resid = csol_cqe->res_cnt;
#line 1319
  if ((unsigned long )task->sc == (unsigned long )((struct scsi_cmnd *)0)) {
#line 1320
    if ((unsigned long )io_task->scsi_cmnd != (unsigned long )((struct scsi_cmnd *)0)) {
      {
#line 1321
      scsi_dma_unmap(io_task->scsi_cmnd);
#line 1322
      io_task->scsi_cmnd = (struct scsi_cmnd *)0;
      }
    } else {

    }
#line 1325
    return;
  } else {

  }
#line 1327
  (task->sc)->result = (int )status;
#line 1328
  if ((unsigned int )rsp != 0U) {
#line 1329
    (task->sc)->result = 458752;
#line 1330
    goto unmap;
  } else {

  }
#line 1334
  if (((int )flags & 6) != 0) {
#line 1335
    if ((unsigned int )status == 0U && ((int )flags & 4) != 0) {
#line 1336
      (task->sc)->result = 458752;
    } else {

    }
#line 1338
    if (((int )flags & 2) != 0) {
      {
#line 1339
      scsi_set_resid(task->sc, (int )resid);
      }
#line 1340
      if ((unsigned int )status == 0U) {
        {
#line 1340
        tmp = scsi_bufflen(task->sc);
        }
#line 1340
        if (tmp - resid < (task->sc)->underflow) {
#line 1342
          (task->sc)->result = 458752;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 1346
  if ((unsigned int )status == 2U) {
    {
#line 1348
    slen = (unsigned short *)(& sts_bhs->sense_info);
#line 1350
    sense = (unsigned char *)(& sts_bhs->sense_info) + 2UL;
#line 1351
    tmp___0 = __fswab16((int )*slen);
#line 1351
    sense_len = tmp___0;
#line 1352
    __min1 = sense_len;
#line 1352
    __min2 = 96U;
#line 1352
    __memcpy((void *)(task->sc)->sense_buffer, (void const   *)sense, (size_t )((int )__min1 < (int )__min2 ? __min1 : __min2));
    }
  } else {

  }
#line 1356
  if (((int )(io_task->cmd_bhs)->iscsi_hdr.flags & 64) != 0) {
#line 1357
    conn->rxdata_octets = conn->rxdata_octets + (uint64_t )resid;
  } else {

  }
  unmap: 
  {
#line 1359
  scsi_dma_unmap(io_task->scsi_cmnd);
#line 1360
  io_task->scsi_cmnd = (struct scsi_cmnd *)0;
#line 1361
  iscsi_complete_scsi_task(task, exp_cmdsn, max_cmdsn);
  }
#line 1362
  return;
}
}
#line 1365 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_complete_logout(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ,
                               struct common_sol_cqe *csol_cqe ) 
{ 
  struct iscsi_logout_rsp *hdr ;
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  {
#line 1370
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1371
  conn = beiscsi_conn->conn;
#line 1373
  hdr = (struct iscsi_logout_rsp *)task->hdr;
#line 1374
  hdr->opcode = 38U;
#line 1375
  hdr->t2wait = 5U;
#line 1376
  hdr->t2retain = 0U;
#line 1377
  hdr->flags = csol_cqe->i_flags;
#line 1378
  hdr->response = csol_cqe->i_resp;
#line 1379
  tmp = __fswab32(csol_cqe->exp_cmdsn);
#line 1379
  hdr->exp_cmdsn = tmp;
#line 1380
  tmp___0 = __fswab32((csol_cqe->exp_cmdsn + (u32 )csol_cqe->cmd_wnd) - 1U);
#line 1380
  hdr->max_cmdsn = tmp___0;
#line 1383
  hdr->dlength[0] = 0U;
#line 1384
  hdr->dlength[1] = 0U;
#line 1385
  hdr->dlength[2] = 0U;
#line 1386
  hdr->hlength = 0U;
#line 1387
  hdr->itt = io_task->libiscsi_itt;
#line 1388
  __iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, (char *)0, 0);
  }
#line 1389
  return;
}
}
#line 1392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_complete_tmf(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ,
                            struct common_sol_cqe *csol_cqe ) 
{ 
  struct iscsi_tm_rsp *hdr ;
  struct iscsi_conn *conn ;
  struct beiscsi_io_task *io_task ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  {
#line 1397
  conn = beiscsi_conn->conn;
#line 1398
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1400
  hdr = (struct iscsi_tm_rsp *)task->hdr;
#line 1401
  hdr->opcode = 34U;
#line 1402
  hdr->flags = csol_cqe->i_flags;
#line 1403
  hdr->response = csol_cqe->i_resp;
#line 1404
  tmp = __fswab32(csol_cqe->exp_cmdsn);
#line 1404
  hdr->exp_cmdsn = tmp;
#line 1405
  tmp___0 = __fswab32((csol_cqe->exp_cmdsn + (u32 )csol_cqe->cmd_wnd) - 1U);
#line 1405
  hdr->max_cmdsn = tmp___0;
#line 1408
  hdr->itt = io_task->libiscsi_itt;
#line 1409
  __iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, (char *)0, 0);
  }
#line 1410
  return;
}
}
#line 1413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_complete_drvr_msgs(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                                   struct sol_cqe *psol ) 
{ 
  struct hwi_wrb_context *pwrb_context ;
  struct wrb_handle *pwrb_handle ;
  struct hwi_controller *phwi_ctrlr ;
  struct iscsi_task *task ;
  struct beiscsi_io_task *io_task ;
  uint16_t wrb_index ;
  uint16_t cid ;
  uint16_t cri_index ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;

  {
#line 1417
  pwrb_handle = (struct wrb_handle *)0;
#line 1423
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1424
  if (phba->generation - 2U <= 1U) {
    {
#line 1425
    tmp = amap_mask(8U);
#line 1425
    tmp___0 = amap_get((void *)psol, 2U, tmp, 16U);
#line 1425
    wrb_index = (uint16_t )tmp___0;
#line 1427
    tmp___1 = amap_mask(10U);
#line 1427
    tmp___2 = amap_get((void *)psol, 2U, tmp___1, 6U);
#line 1427
    cid = (uint16_t )tmp___2;
    }
  } else {
    {
#line 1430
    tmp___3 = amap_mask(16U);
#line 1430
    tmp___4 = amap_get((void *)psol, 2U, tmp___3, 16U);
#line 1430
    wrb_index = (uint16_t )tmp___4;
#line 1432
    tmp___5 = amap_mask(13U);
#line 1432
    tmp___6 = amap_get((void *)psol, 3U, tmp___5, 16U);
#line 1432
    cid = (uint16_t )tmp___6;
    }
  }
  {
#line 1436
  cri_index = phba->cid_to_cri_map[(int )cid];
#line 1437
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 1438
  pwrb_handle = *(pwrb_context->pwrb_handle_basestd + (unsigned long )wrb_index);
#line 1439
  task = pwrb_handle->pio_handle;
#line 1441
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1442
  __memset((void *)(io_task->pwrb_handle)->pwrb, 0, 64UL);
#line 1443
  iscsi_put_task(task);
  }
#line 1444
  return;
}
}
#line 1447 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_complete_nopin_resp(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ,
                                   struct common_sol_cqe *csol_cqe ) 
{ 
  struct iscsi_nopin *hdr ;
  struct iscsi_conn *conn ;
  struct beiscsi_io_task *io_task ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  {
#line 1452
  conn = beiscsi_conn->conn;
#line 1453
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 1455
  hdr = (struct iscsi_nopin *)task->hdr;
#line 1456
  hdr->flags = csol_cqe->i_flags;
#line 1457
  tmp = __fswab32(csol_cqe->exp_cmdsn);
#line 1457
  hdr->exp_cmdsn = tmp;
#line 1458
  tmp___0 = __fswab32((csol_cqe->exp_cmdsn + (u32 )csol_cqe->cmd_wnd) - 1U);
#line 1458
  hdr->max_cmdsn = tmp___0;
#line 1461
  hdr->opcode = 32U;
#line 1462
  hdr->itt = io_task->libiscsi_itt;
#line 1463
  __iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, (char *)0, 0);
  }
#line 1464
  return;
}
}
#line 1466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void adapter_get_sol_cqe(struct beiscsi_hba *phba , struct sol_cqe *psol ,
                                struct common_sol_cqe *csol_cqe ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;
  u32 tmp___23 ;
  u32 tmp___24 ;
  u32 tmp___25 ;
  u32 tmp___26 ;
  u32 tmp___27 ;
  u32 tmp___28 ;
  u32 tmp___29 ;
  u32 tmp___30 ;
  u32 tmp___31 ;
  u32 tmp___32 ;
  u32 tmp___33 ;
  u32 tmp___34 ;

  {
#line 1470
  if (phba->generation - 2U <= 1U) {
    {
#line 1471
    tmp = amap_mask(32U);
#line 1471
    csol_cqe->exp_cmdsn = amap_get((void *)psol, 1U, tmp, 0U);
#line 1473
    tmp___0 = amap_mask(31U);
#line 1473
    csol_cqe->res_cnt = amap_get((void *)psol, 3U, tmp___0, 0U);
#line 1475
    tmp___1 = amap_mask(8U);
#line 1475
    tmp___2 = amap_get((void *)psol, 2U, tmp___1, 24U);
#line 1475
    csol_cqe->cmd_wnd = (u8 )tmp___2;
#line 1477
    tmp___3 = amap_mask(8U);
#line 1477
    tmp___4 = amap_get((void *)psol, 2U, tmp___3, 16U);
#line 1477
    csol_cqe->wrb_index = (u16 )tmp___4;
#line 1479
    tmp___5 = amap_mask(10U);
#line 1479
    tmp___6 = amap_get((void *)psol, 2U, tmp___5, 6U);
#line 1479
    csol_cqe->cid = (u16 )tmp___6;
#line 1481
    tmp___7 = amap_mask(8U);
#line 1481
    tmp___8 = amap_get((void *)psol, 0U, tmp___7, 0U);
#line 1481
    csol_cqe->hw_sts = (u8 )tmp___8;
#line 1483
    tmp___9 = amap_mask(8U);
#line 1483
    tmp___10 = amap_get((void *)psol, 0U, tmp___9, 16U);
#line 1483
    csol_cqe->i_resp = (u8 )tmp___10;
#line 1485
    tmp___11 = amap_mask(8U);
#line 1485
    tmp___12 = amap_get((void *)psol, 0U, tmp___11, 8U);
#line 1485
    csol_cqe->i_sts = (u8 )tmp___12;
#line 1487
    tmp___13 = amap_mask(7U);
#line 1487
    tmp___14 = amap_get((void *)psol, 0U, tmp___13, 24U);
#line 1487
    csol_cqe->i_flags = (u8 )tmp___14;
    }
  } else {
    {
#line 1490
    tmp___15 = amap_mask(32U);
#line 1490
    csol_cqe->exp_cmdsn = amap_get((void *)psol, 1U, tmp___15, 0U);
#line 1492
    tmp___16 = amap_mask(31U);
#line 1492
    csol_cqe->res_cnt = amap_get((void *)psol, 3U, tmp___16, 0U);
#line 1494
    tmp___17 = amap_mask(16U);
#line 1494
    tmp___18 = amap_get((void *)psol, 0U, tmp___17, 16U);
#line 1494
    csol_cqe->wrb_index = (u16 )tmp___18;
#line 1496
    tmp___19 = amap_mask(13U);
#line 1496
    tmp___20 = amap_get((void *)psol, 2U, tmp___19, 16U);
#line 1496
    csol_cqe->cid = (u16 )tmp___20;
#line 1498
    tmp___21 = amap_mask(8U);
#line 1498
    tmp___22 = amap_get((void *)psol, 0U, tmp___21, 0U);
#line 1498
    csol_cqe->hw_sts = (u8 )tmp___22;
#line 1500
    tmp___23 = amap_mask(8U);
#line 1500
    tmp___24 = amap_get((void *)psol, 2U, tmp___23, 8U);
#line 1500
    csol_cqe->cmd_wnd = (u8 )tmp___24;
#line 1502
    tmp___29 = amap_mask(1U);
#line 1502
    tmp___30 = amap_get((void *)psol, 2U, tmp___29, 6U);
    }
#line 1502
    if (tmp___30 != 0U) {
      {
#line 1504
      tmp___25 = amap_mask(8U);
#line 1504
      tmp___26 = amap_get((void *)psol, 0U, tmp___25, 8U);
#line 1504
      csol_cqe->i_sts = (u8 )tmp___26;
      }
    } else {
      {
#line 1507
      tmp___27 = amap_mask(8U);
#line 1507
      tmp___28 = amap_get((void *)psol, 0U, tmp___27, 8U);
#line 1507
      csol_cqe->i_resp = (u8 )tmp___28;
      }
    }
    {
#line 1509
    tmp___31 = amap_mask(1U);
#line 1509
    tmp___32 = amap_get((void *)psol, 2U, tmp___31, 29U);
    }
#line 1509
    if (tmp___32 != 0U) {
#line 1511
      csol_cqe->i_flags = 2U;
    } else {

    }
    {
#line 1513
    tmp___33 = amap_mask(1U);
#line 1513
    tmp___34 = amap_get((void *)psol, 2U, tmp___33, 30U);
    }
#line 1513
    if (tmp___34 != 0U) {
#line 1515
      csol_cqe->i_flags = (u8 )((unsigned int )csol_cqe->i_flags | 4U);
    } else {

    }
  }
#line 1517
  return;
}
}
#line 1520 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_complete_cmd(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                             struct sol_cqe *psol ) 
{ 
  struct hwi_wrb_context *pwrb_context ;
  struct wrb_handle *pwrb_handle ;
  struct iscsi_wrb *pwrb ;
  struct hwi_controller *phwi_ctrlr ;
  struct iscsi_task *task ;
  unsigned int type ;
  struct iscsi_conn *conn ;
  struct iscsi_session *session ;
  struct common_sol_cqe csol_cqe ;
  uint16_t cri_index ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
  {
#line 1525
  pwrb = (struct iscsi_wrb *)0;
#line 1529
  conn = beiscsi_conn->conn;
#line 1530
  session = conn->session;
#line 1531
  csol_cqe.exp_cmdsn = 0U;
#line 1531
  csol_cqe.res_cnt = 0U;
#line 1531
  csol_cqe.wrb_index = (unsigned short)0;
#line 1531
  csol_cqe.cid = (unsigned short)0;
#line 1531
  csol_cqe.hw_sts = (unsigned char)0;
#line 1531
  csol_cqe.cmd_wnd = (unsigned char)0;
#line 1531
  csol_cqe.res_flag = (unsigned char)0;
#line 1531
  csol_cqe.i_resp = (unsigned char)0;
#line 1531
  csol_cqe.i_flags = (unsigned char)0;
#line 1531
  csol_cqe.i_sts = (unsigned char)0;
#line 1532
  cri_index = 0U;
#line 1534
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1537
  adapter_get_sol_cqe(phba, psol, & csol_cqe);
#line 1539
  cri_index = phba->cid_to_cri_map[(int )csol_cqe.cid];
#line 1540
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 1542
  pwrb_handle = *(pwrb_context->pwrb_handle_basestd + (unsigned long )csol_cqe.wrb_index);
#line 1545
  task = pwrb_handle->pio_handle;
#line 1546
  pwrb = pwrb_handle->pwrb;
#line 1547
  type = (unsigned int )((struct beiscsi_io_task *)task->dd_data)->wrb_type;
#line 1549
  ldv_spin_lock_bh_142(& session->back_lock);
  }
  {
#line 1551
  if (type == 1U) {
#line 1551
    goto case_1;
  } else {

  }
#line 1552
  if (type == 5U) {
#line 1552
    goto case_5;
  } else {

  }
#line 1560
  if (type == 2U) {
#line 1560
    goto case_2;
  } else {

  }
#line 1567
  if (type == 11U) {
#line 1567
    goto case_11;
  } else {

  }
#line 1574
  if (type == 4U) {
#line 1574
    goto case_4;
  } else {

  }
#line 1578
  goto switch_default;
  case_1: /* CIL Label */ ;
  case_5: /* CIL Label */ ;
#line 1553
  if (((int )(task->hdr)->opcode & 63) == 0) {
    {
#line 1555
    be_complete_nopin_resp(beiscsi_conn, task, & csol_cqe);
    }
  } else {
    {
#line 1557
    be_complete_io(beiscsi_conn, task, & csol_cqe);
    }
  }
#line 1558
  goto ldv_57278;
  case_2: /* CIL Label */ ;
#line 1561
  if (((int )(task->hdr)->opcode & 63) == 6) {
    {
#line 1562
    be_complete_logout(beiscsi_conn, task, & csol_cqe);
    }
  } else {
    {
#line 1564
    be_complete_tmf(beiscsi_conn, task, & csol_cqe);
    }
  }
#line 1565
  goto ldv_57278;
  case_11: /* CIL Label */ 
#line 1568
  log_value = phba->attr_log_enable;
#line 1568
  if ((log_value & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 1568
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d :\t\t No HWH_TYPE_LOGIN Expected in hwi_complete_cmd- Solicited path\n",
               1571);
    }
  } else {

  }
#line 1572
  goto ldv_57278;
  case_4: /* CIL Label */ 
  {
#line 1575
  be_complete_nopin_resp(beiscsi_conn, task, & csol_cqe);
  }
#line 1576
  goto ldv_57278;
  switch_default: /* CIL Label */ 
#line 1579
  log_value___0 = phba->attr_log_enable;
#line 1579
  if ((log_value___0 & 48U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
    {
#line 1579
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In hwi_complete_cmd, unknown type = %dwrb_index 0x%x CID 0x%x\n",
               1584, type, (int )csol_cqe.wrb_index, (int )csol_cqe.cid);
    }
  } else {

  }
#line 1585
  goto ldv_57278;
  switch_break: /* CIL Label */ ;
  }
  ldv_57278: 
  {
#line 1588
  ldv_spin_unlock_bh_143(& session->back_lock);
  }
#line 1589
  return;
}
}
#line 1591 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct list_head *hwi_get_async_busy_list(struct hwi_async_pdu_context *pasync_ctx ,
                                                 unsigned int is_header , unsigned int host_write_ptr ) 
{ 


  {
#line 1595
  if (is_header != 0U) {
#line 1596
    return (& (pasync_ctx->async_entry + (unsigned long )host_write_ptr)->header_busy_list);
  } else {
#line 1599
    return (& (pasync_ctx->async_entry + (unsigned long )host_write_ptr)->data_busy_list);
  }
}
}
#line 1603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct async_pdu_handle *hwi_get_async_handle(struct beiscsi_hba *phba , struct beiscsi_conn *beiscsi_conn ,
                                                     struct hwi_async_pdu_context *pasync_ctx ,
                                                     struct i_t_dpdu_cqe *pdpdu_cqe ,
                                                     unsigned int *pcq_index ) 
{ 
  struct be_bus_address phys_addr ;
  struct list_head *pbusy_list ;
  struct async_pdu_handle *pasync_handle ;
  unsigned char is_header ;
  unsigned int index ;
  unsigned int dpl ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  uint32_t log_value ;
  int __ret_warn_on ;
  int tmp___3 ;
  long tmp___4 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int __ret_warn_on___0 ;
  long tmp___5 ;

  {
#line 1610
  pasync_handle = (struct async_pdu_handle *)0;
#line 1611
  is_header = 0U;
#line 1614
  if (phba->generation - 2U <= 1U) {
    {
#line 1615
    tmp = amap_mask(16U);
#line 1615
    dpl = amap_get((void *)pdpdu_cqe, 2U, tmp, 16U);
#line 1617
    tmp___0 = amap_mask(16U);
#line 1617
    index = amap_get((void *)pdpdu_cqe, 3U, tmp___0, 0U);
    }
  } else {
    {
#line 1620
    tmp___1 = amap_mask(17U);
#line 1620
    dpl = amap_get((void *)pdpdu_cqe, 2U, tmp___1, 15U);
#line 1622
    tmp___2 = amap_mask(16U);
#line 1622
    index = amap_get((void *)pdpdu_cqe, 3U, tmp___2, 0U);
    }
  }
#line 1626
  phys_addr.u.a32.address_lo = pdpdu_cqe->dw[1UL] - dpl;
#line 1629
  phys_addr.u.a32.address_hi = pdpdu_cqe->dw[0UL];
#line 1633
  phys_addr.u.a64.address = phys_addr.u.a64.address;
  {
#line 1638
  if ((pdpdu_cqe->dw[2UL] & 63U) == 28U) {
#line 1638
    goto case_28;
  } else {

  }
#line 1644
  if ((pdpdu_cqe->dw[2UL] & 63U) == 29U) {
#line 1644
    goto case_29;
  } else {

  }
#line 1648
  goto switch_default;
  case_28: /* CIL Label */ 
  {
#line 1639
  is_header = 1U;
#line 1641
  pbusy_list = hwi_get_async_busy_list(pasync_ctx, (unsigned int )is_header, index);
  }
#line 1643
  goto ldv_57304;
  case_29: /* CIL Label */ 
  {
#line 1645
  pbusy_list = hwi_get_async_busy_list(pasync_ctx, (unsigned int )is_header, index);
  }
#line 1647
  goto ldv_57304;
  switch_default: /* CIL Label */ 
#line 1649
  pbusy_list = (struct list_head *)0;
#line 1650
  log_value = phba->attr_log_enable;
#line 1650
  if ((log_value & 48U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
    {
#line 1650
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Unexpected code=%d\n",
               1654, pdpdu_cqe->dw[2UL] & 63U);
    }
  } else {

  }
#line 1655
  return ((struct async_pdu_handle *)0);
  switch_break: /* CIL Label */ ;
  }
  ldv_57304: 
  {
#line 1658
  tmp___3 = list_empty((struct list_head  const  *)pbusy_list);
#line 1658
  __ret_warn_on = tmp___3 != 0;
#line 1658
  tmp___4 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 1658
  if (tmp___4 != 0L) {
    {
#line 1658
    warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 1658);
    }
  } else {

  }
  {
#line 1658
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 1659
  __mptr = (struct list_head  const  *)pbusy_list->next;
#line 1659
  pasync_handle = (struct async_pdu_handle *)__mptr;
  }
#line 1659
  goto ldv_57316;
  ldv_57315: ;
#line 1660
  if (pasync_handle->pa.u.a64.address == phys_addr.u.a64.address) {
#line 1661
    goto ldv_57314;
  } else {

  }
#line 1659
  __mptr___0 = (struct list_head  const  *)pasync_handle->link.next;
#line 1659
  pasync_handle = (struct async_pdu_handle *)__mptr___0;
  ldv_57316: ;
#line 1659
  if ((unsigned long )(& pasync_handle->link) != (unsigned long )pbusy_list) {
#line 1661
    goto ldv_57315;
  } else {

  }
  ldv_57314: 
  {
#line 1664
  __ret_warn_on___0 = (unsigned long )pasync_handle == (unsigned long )((struct async_pdu_handle *)0);
#line 1664
  tmp___5 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
#line 1664
  if (tmp___5 != 0L) {
    {
#line 1664
    warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 1664);
    }
  } else {

  }
  {
#line 1664
  __builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1666
  pasync_handle->cri = pasync_ctx->cid_to_async_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 1668
  pasync_handle->is_header = is_header;
#line 1669
  pasync_handle->buffer_len = (unsigned long )dpl;
#line 1670
  *pcq_index = index;
  }
#line 1672
  return (pasync_handle);
}
}
#line 1676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static unsigned int hwi_update_async_writables(struct beiscsi_hba *phba , struct hwi_async_pdu_context *pasync_ctx ,
                                               unsigned int is_header , unsigned int cq_index ) 
{ 
  struct list_head *pbusy_list ;
  struct async_pdu_handle *pasync_handle ;
  unsigned int num_entries ;
  unsigned int writables ;
  unsigned int *pep_read_ptr ;
  unsigned int *pwritables ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  int tmp___2 ;
  uint32_t log_value ;
  int __ret_warn_on___1 ;
  long tmp___3 ;

  {
#line 1682
  writables = 0U;
#line 1685
  num_entries = pasync_ctx->num_entries;
#line 1686
  if (is_header != 0U) {
#line 1687
    pep_read_ptr = & pasync_ctx->async_header.ep_read_ptr;
#line 1688
    pwritables = & pasync_ctx->async_header.writables;
  } else {
#line 1690
    pep_read_ptr = & pasync_ctx->async_data.ep_read_ptr;
#line 1691
    pwritables = & pasync_ctx->async_data.writables;
  }
#line 1694
  goto ldv_57338;
  ldv_57337: 
  {
#line 1695
  *pep_read_ptr = *pep_read_ptr + 1U;
#line 1696
  *pep_read_ptr = *pep_read_ptr % num_entries;
#line 1698
  pbusy_list = hwi_get_async_busy_list(pasync_ctx, is_header, *pep_read_ptr);
  }
#line 1700
  if (writables == 0U) {
    {
#line 1701
    tmp = list_empty((struct list_head  const  *)pbusy_list);
#line 1701
    __ret_warn_on = tmp != 0;
#line 1701
    tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 1701
    if (tmp___0 != 0L) {
      {
#line 1701
      warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 1701);
      }
    } else {

    }
    {
#line 1701
    __builtin_expect(__ret_warn_on != 0, 0L);
    }
  } else {

  }
  {
#line 1703
  tmp___2 = list_empty((struct list_head  const  *)pbusy_list);
  }
#line 1703
  if (tmp___2 == 0) {
    {
#line 1704
    __mptr = (struct list_head  const  *)pbusy_list->next;
#line 1704
    pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1707
    __ret_warn_on___0 = (unsigned long )pasync_handle == (unsigned long )((struct async_pdu_handle *)0);
#line 1707
    tmp___1 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
    }
#line 1707
    if (tmp___1 != 0L) {
      {
#line 1707
      warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 1707);
      }
    } else {

    }
    {
#line 1707
    __builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 1708
    pasync_handle->consumed = 1U;
    }
  } else {

  }
#line 1711
  writables = writables + 1U;
  ldv_57338: ;
#line 1694
  if (*pep_read_ptr != cq_index) {
#line 1696
    goto ldv_57337;
  } else {

  }

#line 1714
  if (writables == 0U) {
#line 1715
    log_value = phba->attr_log_enable;
#line 1715
    if ((log_value & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1715
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Duplicate notification received - index 0x%x!!\n",
                 1718, cq_index);
      }
    } else {

    }
    {
#line 1719
    __ret_warn_on___1 = 1;
#line 1719
    tmp___3 = __builtin_expect(__ret_warn_on___1 != 0, 0L);
    }
#line 1719
    if (tmp___3 != 0L) {
      {
#line 1719
      warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 1719);
      }
    } else {

    }
    {
#line 1719
    __builtin_expect(__ret_warn_on___1 != 0, 0L);
    }
  } else {

  }
#line 1722
  *pwritables = *pwritables + writables;
#line 1723
  return (0U);
}
}
#line 1726 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_free_async_msg(struct beiscsi_hba *phba , struct hwi_async_pdu_context *pasync_ctx ,
                               unsigned int cri ) 
{ 
  struct async_pdu_handle *pasync_handle ;
  struct async_pdu_handle *tmp_handle ;
  struct list_head *plist ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
#line 1733
  plist = & (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list;
#line 1734
  __mptr = (struct list_head  const  *)plist->next;
#line 1734
  pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1734
  __mptr___0 = (struct list_head  const  *)pasync_handle->link.next;
#line 1734
  tmp_handle = (struct async_pdu_handle *)__mptr___0;
#line 1734
  goto ldv_57358;
  ldv_57357: 
  {
#line 1735
  list_del(& pasync_handle->link);
  }
#line 1737
  if ((unsigned int )pasync_handle->is_header != 0U) {
    {
#line 1738
    list_add_tail(& pasync_handle->link, & pasync_ctx->async_header.free_list);
#line 1740
    pasync_ctx->async_header.free_entries = pasync_ctx->async_header.free_entries + 1U;
    }
  } else {
    {
#line 1742
    list_add_tail(& pasync_handle->link, & pasync_ctx->async_data.free_list);
#line 1744
    pasync_ctx->async_data.free_entries = pasync_ctx->async_data.free_entries + 1U;
    }
  }
#line 1734
  pasync_handle = tmp_handle;
#line 1734
  __mptr___1 = (struct list_head  const  *)tmp_handle->link.next;
#line 1734
  tmp_handle = (struct async_pdu_handle *)__mptr___1;
  ldv_57358: ;
#line 1734
  if ((unsigned long )(& pasync_handle->link) != (unsigned long )plist) {
#line 1736
    goto ldv_57357;
  } else {

  }
  {
#line 1748
  INIT_LIST_HEAD(& (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list);
#line 1749
  (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_received = 0U;
#line 1750
  (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received = 0U;
  }
#line 1751
  return;
}
}
#line 1754 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct phys_addr *hwi_get_ring_address(struct hwi_async_pdu_context *pasync_ctx ,
                                              unsigned int is_header , unsigned int host_write_ptr ) 
{ 
  struct phys_addr *pasync_sge ;

  {
#line 1757
  pasync_sge = (struct phys_addr *)0;
#line 1759
  if (is_header != 0U) {
#line 1760
    pasync_sge = (struct phys_addr *)pasync_ctx->async_header.ring_base;
  } else {
#line 1762
    pasync_sge = (struct phys_addr *)pasync_ctx->async_data.ring_base;
  }
#line 1764
  return (pasync_sge + (unsigned long )host_write_ptr);
}
}
#line 1767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_post_async_buffers(struct beiscsi_hba *phba , unsigned int is_header ,
                                   uint8_t ulp_num ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_async_pdu_context *pasync_ctx ;
  struct async_pdu_handle *pasync_handle ;
  struct list_head *pfree_link ;
  struct list_head *pbusy_list ;
  struct phys_addr *pasync_sge ;
  unsigned int ring_id ;
  unsigned int num_entries ;
  unsigned int host_write_num ;
  unsigned int doorbell_offset ;
  unsigned int writables ;
  unsigned int i ;
  u32 doorbell ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int _min1___0 ;
  unsigned int _min2___0 ;
  struct list_head  const  *__mptr ;
  int __ret_warn_on ;
  long tmp ;

  {
#line 1778
  i = 0U;
#line 1779
  doorbell = 0U;
#line 1781
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1782
  pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )ulp_num];
#line 1783
  num_entries = pasync_ctx->num_entries;
#line 1785
  if (is_header != 0U) {
#line 1786
    _min1 = pasync_ctx->async_header.writables;
#line 1786
    _min2 = pasync_ctx->async_header.free_entries;
#line 1786
    writables = _min1 < _min2 ? _min1 : _min2;
#line 1788
    pfree_link = pasync_ctx->async_header.free_list.next;
#line 1789
    host_write_num = pasync_ctx->async_header.host_write_ptr;
#line 1790
    ring_id = phwi_ctrlr->default_pdu_hdr[(int )ulp_num].id;
#line 1791
    doorbell_offset = phwi_ctrlr->default_pdu_hdr[(int )ulp_num].doorbell_offset;
  } else {
#line 1794
    _min1___0 = pasync_ctx->async_data.writables;
#line 1794
    _min2___0 = pasync_ctx->async_data.free_entries;
#line 1794
    writables = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 1796
    pfree_link = pasync_ctx->async_data.free_list.next;
#line 1797
    host_write_num = pasync_ctx->async_data.host_write_ptr;
#line 1798
    ring_id = phwi_ctrlr->default_pdu_data[(int )ulp_num].id;
#line 1799
    doorbell_offset = phwi_ctrlr->default_pdu_data[(int )ulp_num].doorbell_offset;
  }
#line 1803
  writables = (writables / 8U) * 8U;
#line 1804
  if (writables != 0U) {
#line 1805
    i = 0U;
#line 1805
    goto ldv_57395;
    ldv_57394: 
    {
#line 1806
    pbusy_list = hwi_get_async_busy_list(pasync_ctx, is_header, host_write_num);
#line 1810
    __mptr = (struct list_head  const  *)pfree_link;
#line 1810
    pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1812
    __ret_warn_on = (unsigned long )pasync_handle == (unsigned long )((struct async_pdu_handle *)0);
#line 1812
    tmp = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 1812
    if (tmp != 0L) {
      {
#line 1812
      warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 1812);
      }
    } else {

    }
    {
#line 1812
    __builtin_expect(__ret_warn_on != 0, 0L);
#line 1813
    pasync_handle->consumed = 0U;
#line 1815
    pfree_link = pfree_link->next;
#line 1817
    pasync_sge = hwi_get_ring_address(pasync_ctx, is_header, host_write_num);
#line 1820
    pasync_sge->hi = pasync_handle->pa.u.a32.address_lo;
#line 1821
    pasync_sge->lo = pasync_handle->pa.u.a32.address_hi;
#line 1823
    list_move(& pasync_handle->link, pbusy_list);
#line 1825
    host_write_num = host_write_num + 1U;
#line 1826
    host_write_num = host_write_num % num_entries;
#line 1805
    i = i + 1U;
    }
    ldv_57395: ;
#line 1805
    if (i < writables) {
#line 1807
      goto ldv_57394;
    } else {

    }

#line 1829
    if (is_header != 0U) {
#line 1830
      pasync_ctx->async_header.host_write_ptr = host_write_num;
#line 1832
      pasync_ctx->async_header.free_entries = pasync_ctx->async_header.free_entries - writables;
#line 1833
      pasync_ctx->async_header.writables = pasync_ctx->async_header.writables - writables;
#line 1834
      pasync_ctx->async_header.busy_entries = pasync_ctx->async_header.busy_entries + writables;
    } else {
#line 1836
      pasync_ctx->async_data.host_write_ptr = host_write_num;
#line 1837
      pasync_ctx->async_data.free_entries = pasync_ctx->async_data.free_entries - writables;
#line 1838
      pasync_ctx->async_data.writables = pasync_ctx->async_data.writables - writables;
#line 1839
      pasync_ctx->async_data.busy_entries = pasync_ctx->async_data.busy_entries + writables;
    }
    {
#line 1842
    doorbell = doorbell | (ring_id & 16383U);
#line 1843
    doorbell = doorbell | 16384U;
#line 1844
    doorbell = doorbell;
#line 1845
    doorbell = doorbell | ((writables & 16383U) << 16);
#line 1848
    iowrite32(doorbell, (void *)phba->db_va + (unsigned long )doorbell_offset);
    }
  } else {

  }
#line 1850
  return;
}
}
#line 1852 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_flush_default_pdu_buffer(struct beiscsi_hba *phba , struct beiscsi_conn *beiscsi_conn ,
                                         struct i_t_dpdu_cqe *pdpdu_cqe ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_async_pdu_context *pasync_ctx ;
  struct async_pdu_handle *pasync_handle ;
  unsigned int cq_index ;
  uint16_t cri_index ;
  long tmp ;

  {
  {
#line 1858
  pasync_handle = (struct async_pdu_handle *)0;
#line 1859
  cq_index = 4294967295U;
#line 1860
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 1863
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1864
  pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )(phwi_ctrlr->wrb_context + (unsigned long )cri_index)->ulp_num];
#line 1868
  pasync_handle = hwi_get_async_handle(phba, beiscsi_conn, pasync_ctx, pdpdu_cqe,
                                       & cq_index);
#line 1870
  tmp = __builtin_expect((unsigned int )pasync_handle->is_header != 0U, 0L);
  }
#line 1870
  if (tmp != 0L) {
    {
#line 1870
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/scsi/be2iscsi/be_main.c"),
                         "i" (1870), "i" (12UL));
#line 1870
    __builtin_unreachable();
    }
  } else {

  }
#line 1871
  if (pasync_handle->consumed == 0U) {
    {
#line 1872
    hwi_update_async_writables(phba, pasync_ctx, (unsigned int )pasync_handle->is_header,
                               cq_index);
    }
  } else {

  }
  {
#line 1875
  hwi_free_async_msg(phba, pasync_ctx, (unsigned int )pasync_handle->cri);
#line 1876
  hwi_post_async_buffers(phba, (unsigned int )pasync_handle->is_header, (int )(phwi_ctrlr->wrb_context + (unsigned long )cri_index)->ulp_num);
  }
#line 1878
  return;
}
}
#line 1882 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static unsigned int hwi_fwd_async_msg(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                                      struct hwi_async_pdu_context *pasync_ctx , unsigned short cri ) 
{ 
  struct list_head *plist ;
  struct async_pdu_handle *pasync_handle ;
  void *phdr ;
  unsigned int hdr_len ;
  unsigned int buf_len ;
  unsigned int status ;
  unsigned int index ;
  unsigned int offset ;
  void *pfirst_buffer ;
  unsigned int num_buf ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 1888
  phdr = (void *)0;
#line 1889
  hdr_len = 0U;
#line 1889
  buf_len = 0U;
#line 1890
  index = 0U;
#line 1890
  offset = 0U;
#line 1891
  pfirst_buffer = (void *)0;
#line 1892
  num_buf = 0U;
#line 1894
  plist = & (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list;
#line 1896
  __mptr = (struct list_head  const  *)plist->next;
#line 1896
  pasync_handle = (struct async_pdu_handle *)__mptr;
#line 1896
  goto ldv_57428;
  ldv_57427: ;
#line 1897
  if (index == 0U) {
#line 1898
    phdr = pasync_handle->pbuffer;
#line 1899
    hdr_len = (unsigned int )pasync_handle->buffer_len;
  } else {
#line 1901
    buf_len = (unsigned int )pasync_handle->buffer_len;
#line 1902
    if (num_buf == 0U) {
#line 1903
      pfirst_buffer = pasync_handle->pbuffer;
#line 1904
      num_buf = num_buf + 1U;
    } else {

    }
    {
#line 1906
    __memcpy(pfirst_buffer + (unsigned long )offset, (void const   *)pasync_handle->pbuffer,
             (size_t )buf_len);
#line 1908
    offset = offset + buf_len;
    }
  }
#line 1910
  index = index + 1U;
#line 1896
  __mptr___0 = (struct list_head  const  *)pasync_handle->link.next;
#line 1896
  pasync_handle = (struct async_pdu_handle *)__mptr___0;
  ldv_57428: ;
#line 1896
  if ((unsigned long )(& pasync_handle->link) != (unsigned long )plist) {
#line 1898
    goto ldv_57427;
  } else {

  }
  {
#line 1913
  status = beiscsi_process_async_pdu(beiscsi_conn, phba, (struct pdu_base *)phdr,
                                     (unsigned long )hdr_len, pfirst_buffer, (unsigned long )offset);
#line 1917
  hwi_free_async_msg(phba, pasync_ctx, (unsigned int )cri);
  }
#line 1918
  return (0U);
}
}
#line 1922 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static unsigned int hwi_gather_async_pdu(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                                         struct async_pdu_handle *pasync_handle ) 
{ 
  struct hwi_async_pdu_context *pasync_ctx ;
  struct hwi_controller *phwi_ctrlr ;
  unsigned int bytes_needed ;
  unsigned int status ;
  unsigned short cri ;
  struct pdu_base *ppdu ;
  __u16 tmp ;

  {
  {
#line 1928
  bytes_needed = 0U;
#line 1928
  status = 0U;
#line 1929
  cri = pasync_handle->cri;
#line 1932
  phwi_ctrlr = phba->phwi_ctrlr;
#line 1933
  pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )(phwi_ctrlr->wrb_context + (unsigned long )phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid])->ulp_num];
#line 1938
  list_del(& pasync_handle->link);
  }
#line 1939
  if ((unsigned int )pasync_handle->is_header != 0U) {
#line 1940
    pasync_ctx->async_header.busy_entries = pasync_ctx->async_header.busy_entries - 1U;
#line 1941
    if ((unsigned int )(pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_received != 0U) {
      {
#line 1942
      hwi_free_async_msg(phba, pasync_ctx, (unsigned int )cri);
#line 1943
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/scsi/be2iscsi/be_main.c"),
                           "i" (1943), "i" (12UL));
#line 1943
      __builtin_unreachable();
      }
    } else {

    }
    {
#line 1946
    (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received = 0U;
#line 1947
    (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_received = 1U;
#line 1948
    (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_len = (unsigned char )pasync_handle->buffer_len;
#line 1950
    list_add_tail(& pasync_handle->link, & (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list);
#line 1953
    ppdu = (struct pdu_base *)pasync_handle->pbuffer;
#line 1954
    tmp = __fswab16((int )((unsigned short )(ppdu->dw[1UL] >> 16)));
#line 1954
    bytes_needed = (((ppdu->dw[1UL] & 65280U) << 8) & 4294901760U) | (u32 )tmp;
    }
#line 1960
    if (status == 0U) {
#line 1961
      (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_needed = bytes_needed;
#line 1964
      if (bytes_needed == 0U) {
        {
#line 1965
        status = hwi_fwd_async_msg(beiscsi_conn, phba, pasync_ctx, (int )cri);
        }
      } else {

      }
    } else {

    }
  } else {
#line 1969
    pasync_ctx->async_data.busy_entries = pasync_ctx->async_data.busy_entries - 1U;
#line 1970
    if ((unsigned int )(pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.hdr_received != 0U) {
      {
#line 1971
      list_add_tail(& pasync_handle->link, & (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.list);
#line 1975
      (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received = (int )(pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received + (int )((unsigned short )pasync_handle->buffer_len);
      }
#line 1978
      if ((unsigned int )(pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_received >= (pasync_ctx->async_entry + (unsigned long )cri)->wait_queue.bytes_needed) {
        {
#line 1982
        status = hwi_fwd_async_msg(beiscsi_conn, phba, pasync_ctx, (int )cri);
        }
      } else {

      }
    } else {

    }
  }
#line 1986
  return (status);
}
}
#line 1989 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_process_default_pdu_ring(struct beiscsi_conn *beiscsi_conn , struct beiscsi_hba *phba ,
                                         struct i_t_dpdu_cqe *pdpdu_cqe ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_async_pdu_context *pasync_ctx ;
  struct async_pdu_handle *pasync_handle ;
  unsigned int cq_index ;
  uint16_t cri_index ;

  {
  {
#line 1995
  pasync_handle = (struct async_pdu_handle *)0;
#line 1996
  cq_index = 4294967295U;
#line 1997
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 2000
  phwi_ctrlr = phba->phwi_ctrlr;
#line 2001
  pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )(phwi_ctrlr->wrb_context + (unsigned long )cri_index)->ulp_num];
#line 2005
  pasync_handle = hwi_get_async_handle(phba, beiscsi_conn, pasync_ctx, pdpdu_cqe,
                                       & cq_index);
  }
#line 2008
  if (pasync_handle->consumed == 0U) {
    {
#line 2009
    hwi_update_async_writables(phba, pasync_ctx, (unsigned int )pasync_handle->is_header,
                               cq_index);
    }
  } else {

  }
  {
#line 2012
  hwi_gather_async_pdu(beiscsi_conn, phba, pasync_handle);
#line 2013
  hwi_post_async_buffers(phba, (unsigned int )pasync_handle->is_header, (int )(phwi_ctrlr->wrb_context + (unsigned long )cri_index)->ulp_num);
  }
#line 2015
  return;
}
}
#line 2018 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_process_mcc_isr(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *mcc_cq ;
  struct be_mcc_compl *mcc_compl ;
  unsigned int num_processed ;
  void *tmp ;
  uint32_t log_value ;
  bool tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 2022
  num_processed = 0U;
#line 2024
  mcc_cq = & phba->ctrl.mcc_obj.cq;
#line 2025
  tmp = queue_tail_node(mcc_cq);
#line 2025
  mcc_compl = (struct be_mcc_compl *)tmp;
#line 2026
  mcc_compl->flags = mcc_compl->flags;
  }
#line 2027
  goto ldv_57459;
  ldv_57458: ;
#line 2029
  if (num_processed > 31U) {
    {
#line 2030
    hwi_ring_cq_db(phba, (unsigned int )mcc_cq->id, num_processed, 0, 0);
#line 2032
    num_processed = 0U;
    }
  } else {

  }
#line 2034
  if ((mcc_compl->flags & 1073741824U) != 0U) {
    {
#line 2036
    tmp___0 = is_link_state_evt(mcc_compl->flags);
    }
#line 2036
    if ((int )tmp___0) {
      {
#line 2038
      beiscsi_async_link_state_process(phba, (struct be_async_event_link_state *)mcc_compl);
      }
    } else {
#line 2041
      log_value = phba->attr_log_enable;
#line 2041
      if ((log_value & 2U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 2041
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d :  Unsupported Async Event, flags = 0x%08x\n", 2044, mcc_compl->flags);
        }
      } else {

      }
    }
  } else
#line 2045
  if ((mcc_compl->flags & 268435456U) != 0U) {
    {
#line 2046
    be_mcc_compl_process_isr(& phba->ctrl, mcc_compl);
#line 2047
    atomic_dec(& phba->ctrl.mcc_obj.q.used);
    }
  } else {

  }
  {
#line 2050
  mcc_compl->flags = 0U;
#line 2051
  queue_tail_inc(mcc_cq);
#line 2052
  tmp___1 = queue_tail_node(mcc_cq);
#line 2052
  mcc_compl = (struct be_mcc_compl *)tmp___1;
#line 2053
  mcc_compl->flags = mcc_compl->flags;
#line 2054
  num_processed = num_processed + 1U;
  }
  ldv_57459: ;
#line 2027
  if ((int )mcc_compl->flags < 0) {
#line 2029
    goto ldv_57458;
  } else {

  }

#line 2057
  if (num_processed != 0U) {
    {
#line 2058
    hwi_ring_cq_db(phba, (unsigned int )mcc_cq->id, num_processed, 1, 0);
    }
  } else {

  }
#line 2059
  return;
}
}
#line 2069 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq ) 
{ 
  struct be_queue_info *cq ;
  struct sol_cqe *sol ;
  struct dmsg_cqe *dmsg ;
  unsigned int num_processed ;
  unsigned int tot_nump ;
  unsigned short code ;
  unsigned short cid ;
  uint16_t cri_index ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_endpoint *beiscsi_ep ;
  struct iscsi_endpoint *ep ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;
  uint32_t log_value___6 ;
  uint32_t log_value___7 ;
  u32 tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 2074
  num_processed = 0U;
#line 2075
  tot_nump = 0U;
#line 2076
  code = 0U;
#line 2076
  cid = 0U;
#line 2077
  cri_index = 0U;
#line 2083
  cq = pbe_eq->cq;
#line 2084
  tmp = queue_tail_node(cq);
#line 2084
  sol = (struct sol_cqe *)tmp;
#line 2085
  phba = pbe_eq->phba;
  }
#line 2087
  goto ldv_57521;
  ldv_57520: 
  {
#line 2089
  swap_dws((void *)sol, 16);
#line 2091
  code = (unsigned int )((unsigned short )sol->dw[2UL]) & 63U;
  }
#line 2095
  if (phba->generation - 2U <= 1U) {
    {
#line 2096
    tmp___0 = amap_mask(10U);
#line 2096
    tmp___1 = amap_get((void *)sol, 2U, tmp___0, 6U);
#line 2096
    cid = (unsigned short )tmp___1;
    }
  } else
#line 2098
  if (((unsigned int )code == 31U || (unsigned int )code == 28U) || (unsigned int )code == 29U) {
    {
#line 2101
    tmp___2 = amap_mask(13U);
#line 2101
    tmp___3 = amap_get((void *)sol, 3U, tmp___2, 16U);
#line 2101
    cid = (unsigned short )tmp___3;
    }
  } else {
    {
#line 2105
    tmp___4 = amap_mask(13U);
#line 2105
    tmp___5 = amap_get((void *)sol, 2U, tmp___4, 16U);
#line 2105
    cid = (unsigned short )tmp___5;
    }
  }
#line 2109
  cri_index = phba->cid_to_cri_map[(int )cid];
#line 2110
  ep = *(phba->ep_array + (unsigned long )cri_index);
#line 2112
  if ((unsigned long )ep == (unsigned long )((struct iscsi_endpoint *)0)) {
#line 2116
    log_value = phba->attr_log_enable;
#line 2116
    if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 2116
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : proc cqe of disconn ep: cid %d\n",
                 2119, (int )cid);
      }
    } else {

    }
#line 2120
    goto proc_next_cqe;
  } else {

  }
#line 2123
  beiscsi_ep = (struct beiscsi_endpoint *)ep->dd_data;
#line 2124
  beiscsi_conn = beiscsi_ep->conn;
#line 2126
  if (num_processed > 31U) {
    {
#line 2127
    hwi_ring_cq_db(phba, (unsigned int )cq->id, num_processed, 0, 0);
#line 2129
    tot_nump = tot_nump + num_processed;
#line 2130
    num_processed = 0U;
    }
  } else {

  }
  {
#line 2134
  if ((int )code == 1) {
#line 2134
    goto case_1;
  } else {

  }
#line 2137
  if ((int )code == 31) {
#line 2137
    goto case_31;
  } else {

  }
#line 2146
  if ((int )code == 28) {
#line 2146
    goto case_28;
  } else {

  }
#line 2157
  if ((int )code == 29) {
#line 2157
    goto case_29;
  } else {

  }
#line 2168
  if ((int )code == 26) {
#line 2168
    goto case_26;
  } else {

  }
#line 2169
  if ((int )code == 27) {
#line 2169
    goto case_27;
  } else {

  }
#line 2170
  if ((int )code == 25) {
#line 2170
    goto case_25;
  } else {

  }
#line 2176
  if ((int )code == 2) {
#line 2176
    goto case_2;
  } else {

  }
#line 2177
  if ((int )code == 18) {
#line 2177
    goto case_18;
  } else {

  }
#line 2178
  if ((int )code == 19) {
#line 2178
    goto case_19;
  } else {

  }
#line 2179
  if ((int )code == 20) {
#line 2179
    goto case_20;
  } else {

  }
#line 2180
  if ((int )code == 21) {
#line 2180
    goto case_21;
  } else {

  }
#line 2181
  if ((int )code == 22) {
#line 2181
    goto case_22;
  } else {

  }
#line 2182
  if ((int )code == 23) {
#line 2182
    goto case_23;
  } else {

  }
#line 2183
  if ((int )code == 24) {
#line 2183
    goto case_24;
  } else {

  }
#line 2189
  if ((int )code == 30) {
#line 2189
    goto case_30;
  } else {

  }
#line 2199
  if ((int )code == 3) {
#line 2199
    goto case_3;
  } else {

  }
#line 2200
  if ((int )code == 4) {
#line 2200
    goto case_4;
  } else {

  }
#line 2201
  if ((int )code == 5) {
#line 2201
    goto case_5;
  } else {

  }
#line 2202
  if ((int )code == 6) {
#line 2202
    goto case_6;
  } else {

  }
#line 2203
  if ((int )code == 7) {
#line 2203
    goto case_7;
  } else {

  }
#line 2204
  if ((int )code == 8) {
#line 2204
    goto case_8;
  } else {

  }
#line 2205
  if ((int )code == 9) {
#line 2205
    goto case_9;
  } else {

  }
#line 2206
  if ((int )code == 11) {
#line 2206
    goto case_11;
  } else {

  }
#line 2207
  if ((int )code == 13) {
#line 2207
    goto case_13;
  } else {

  }
#line 2208
  if ((int )code == 12) {
#line 2208
    goto case_12;
  } else {

  }
#line 2209
  if ((int )code == 10) {
#line 2209
    goto case_10;
  } else {

  }
#line 2210
  if ((int )code == 14) {
#line 2210
    goto case_14;
  } else {

  }
#line 2211
  if ((int )code == 15) {
#line 2211
    goto case_15;
  } else {

  }
#line 2212
  if ((int )code == 16) {
#line 2212
    goto case_16;
  } else {

  }
#line 2213
  if ((int )code == 17) {
#line 2213
    goto case_17;
  } else {

  }
#line 2214
  if ((int )code == 32) {
#line 2214
    goto case_32;
  } else {

  }
#line 2223
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2135
  hwi_complete_cmd(beiscsi_conn, phba, sol);
  }
#line 2136
  goto ldv_57479;
  case_31: /* CIL Label */ 
#line 2138
  log_value___0 = phba->attr_log_enable;
#line 2138
  if ((log_value___0 & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 2138
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Received %s[%d] on CID : %d\n",
               2141, cqe_desc[(int )code], (int )code, (int )cid);
    }
  } else {

  }
  {
#line 2143
  dmsg = (struct dmsg_cqe *)sol;
#line 2144
  hwi_complete_drvr_msgs(beiscsi_conn, phba, sol);
  }
#line 2145
  goto ldv_57479;
  case_28: /* CIL Label */ 
#line 2147
  log_value___1 = phba->attr_log_enable;
#line 2147
  if ((log_value___1 & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 2147
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Received %s[%d] on CID : %d\n",
               2150, cqe_desc[(int )code], (int )code, (int )cid);
    }
  } else {

  }
  {
#line 2152
  ldv_spin_lock_bh_146(& phba->async_pdu_lock);
#line 2153
  hwi_process_default_pdu_ring(beiscsi_conn, phba, (struct i_t_dpdu_cqe *)sol);
#line 2155
  ldv_spin_unlock_bh_147(& phba->async_pdu_lock);
  }
#line 2156
  goto ldv_57479;
  case_29: /* CIL Label */ 
#line 2158
  log_value___2 = phba->attr_log_enable;
#line 2158
  if ((log_value___2 & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 2158
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Received %s[%d] on CID : %d\n",
               2161, cqe_desc[(int )code], (int )code, (int )cid);
    }
  } else {

  }
  {
#line 2163
  ldv_spin_lock_bh_146(& phba->async_pdu_lock);
#line 2164
  hwi_process_default_pdu_ring(beiscsi_conn, phba, (struct i_t_dpdu_cqe *)sol);
#line 2166
  ldv_spin_unlock_bh_147(& phba->async_pdu_lock);
  }
#line 2167
  goto ldv_57479;
  case_26: /* CIL Label */ ;
  case_27: /* CIL Label */ ;
  case_25: /* CIL Label */ 
#line 2171
  log_value___3 = phba->attr_log_enable;
#line 2171
  if ((log_value___3 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 2171
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Ignoring %s[%d] on CID : %d\n",
               2174, cqe_desc[(int )code], (int )code, (int )cid);
    }
  } else {

  }
#line 2175
  goto ldv_57479;
  case_2: /* CIL Label */ ;
  case_18: /* CIL Label */ ;
  case_19: /* CIL Label */ ;
  case_20: /* CIL Label */ ;
  case_21: /* CIL Label */ ;
  case_22: /* CIL Label */ ;
  case_23: /* CIL Label */ ;
  case_24: /* CIL Label */ 
#line 2184
  log_value___4 = phba->attr_log_enable;
#line 2184
  if ((log_value___4 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 2184
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Cmd Notification %s[%d] on CID : %d\n",
               2187, cqe_desc[(int )code], (int )code, (int )cid);
    }
  } else {

  }
#line 2188
  goto ldv_57479;
  case_30: /* CIL Label */ 
#line 2190
  log_value___5 = phba->attr_log_enable;
#line 2190
  if ((log_value___5 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 2190
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d :  Dropping %s[%d] on DPDU ring on CID : %d\n",
               2193, cqe_desc[(int )code], (int )code, (int )cid);
    }
  } else {

  }
  {
#line 2194
  ldv_spin_lock_bh_146(& phba->async_pdu_lock);
#line 2195
  hwi_flush_default_pdu_buffer(phba, beiscsi_conn, (struct i_t_dpdu_cqe *)sol);
#line 2197
  ldv_spin_unlock_bh_147(& phba->async_pdu_lock);
  }
#line 2198
  goto ldv_57479;
  case_3: /* CIL Label */ ;
  case_4: /* CIL Label */ ;
  case_5: /* CIL Label */ ;
  case_6: /* CIL Label */ ;
  case_7: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
  case_9: /* CIL Label */ ;
  case_11: /* CIL Label */ ;
  case_13: /* CIL Label */ ;
  case_12: /* CIL Label */ ;
  case_10: /* CIL Label */ ;
  case_14: /* CIL Label */ ;
  case_15: /* CIL Label */ ;
  case_16: /* CIL Label */ ;
  case_17: /* CIL Label */ ;
  case_32: /* CIL Label */ 
#line 2215
  log_value___6 = phba->attr_log_enable;
#line 2215
  if ((log_value___6 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 2215
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Event %s[%d] received on CID : %d\n",
               2218, cqe_desc[(int )code], (int )code, (int )cid);
    }
  } else {

  }
#line 2219
  if ((unsigned long )beiscsi_conn != (unsigned long )((struct beiscsi_conn *)0)) {
    {
#line 2220
    iscsi_conn_failure(beiscsi_conn->conn, 1011);
    }
  } else {

  }
#line 2222
  goto ldv_57479;
  switch_default: /* CIL Label */ 
#line 2224
  log_value___7 = phba->attr_log_enable;
#line 2224
  if ((log_value___7 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 2224
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Invalid CQE Event Received Code : %dCID 0x%x...\n",
               2228, (int )code, (int )cid);
    }
  } else {

  }
#line 2229
  goto ldv_57479;
  switch_break: /* CIL Label */ ;
  }
  ldv_57479: ;
  proc_next_cqe: 
  {
#line 2233
  tmp___6 = amap_mask(1U);
#line 2233
  amap_set((void *)sol, 3U, tmp___6, 31U, 0U);
#line 2234
  queue_tail_inc(cq);
#line 2235
  tmp___7 = queue_tail_node(cq);
#line 2235
  sol = (struct sol_cqe *)tmp___7;
#line 2236
  num_processed = num_processed + 1U;
  }
  ldv_57521: ;
#line 2087
  if ((int )sol->dw[3UL] < 0) {
#line 2089
    goto ldv_57520;
  } else {

  }

#line 2239
  if (num_processed != 0U) {
    {
#line 2240
    tot_nump = tot_nump + num_processed;
#line 2241
    hwi_ring_cq_db(phba, (unsigned int )cq->id, num_processed, 1, 0);
    }
  } else {

  }
#line 2243
  return (tot_nump);
}
}
#line 2246 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
void beiscsi_process_all_cqs(struct work_struct *work ) 
{ 
  unsigned long flags ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct beiscsi_hba *phba ;
  struct be_eq_obj *pbe_eq ;
  struct work_struct  const  *__mptr ;

  {
#line 2253
  __mptr = (struct work_struct  const  *)work;
#line 2253
  pbe_eq = (struct be_eq_obj *)__mptr + 0xffffffffffffffc0UL;
#line 2255
  phba = pbe_eq->phba;
#line 2256
  phwi_ctrlr = phba->phwi_ctrlr;
#line 2257
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 2259
  if ((int )pbe_eq->todo_mcc_cq) {
    {
#line 2260
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_152(& phba->isr_lock);
#line 2261
    pbe_eq->todo_mcc_cq = 0;
#line 2262
    ldv_spin_unlock_irqrestore_135(& phba->isr_lock, flags);
#line 2263
    beiscsi_process_mcc_isr(phba);
    }
  } else {

  }
#line 2266
  if ((int )pbe_eq->todo_cq) {
    {
#line 2267
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_154(& phba->isr_lock);
#line 2268
    pbe_eq->todo_cq = 0;
#line 2269
    ldv_spin_unlock_irqrestore_135(& phba->isr_lock, flags);
#line 2270
    beiscsi_process_cq(pbe_eq);
    }
  } else {

  }
  {
#line 2274
  hwi_ring_eq_db(phba, (unsigned int )pbe_eq->q.id, 0U, 0U, 1, 1);
  }
#line 2275
  return;
}
}
#line 2277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int be_iopoll(struct blk_iopoll *iop , int budget ) 
{ 
  unsigned int ret ;
  struct beiscsi_hba *phba ;
  struct be_eq_obj *pbe_eq ;
  struct blk_iopoll  const  *__mptr ;
  uint32_t log_value ;

  {
  {
#line 2283
  __mptr = (struct blk_iopoll  const  *)iop;
#line 2283
  pbe_eq = (struct be_eq_obj *)__mptr + 0xffffffffffffff70UL;
#line 2284
  ret = beiscsi_process_cq(pbe_eq);
#line 2285
  pbe_eq->cq_count = pbe_eq->cq_count + ret;
  }
#line 2286
  if (ret < (unsigned int )budget) {
    {
#line 2287
    phba = pbe_eq->phba;
#line 2288
    blk_iopoll_complete(iop);
#line 2289
    log_value = phba->attr_log_enable;
    }
#line 2289
    if ((log_value & 48U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 2289
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : rearm pbe_eq->q.id =%d\n", 2292, (int )pbe_eq->q.id);
      }
    } else {

    }
    {
#line 2293
    hwi_ring_eq_db(phba, (unsigned int )pbe_eq->q.id, 0U, 0U, 1, 1);
    }
  } else {

  }
#line 2295
  return ((int )ret);
}
}
#line 2299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_write_sgl_v2(struct iscsi_wrb *pwrb , struct scatterlist *sg , unsigned int num_sg ,
                             struct beiscsi_io_task *io_task ) 
{ 
  struct iscsi_sge *psgl ;
  unsigned int sg_len ;
  unsigned int index ;
  unsigned int sge_len ;
  unsigned long long addr ;
  struct scatterlist *l_sg ;
  unsigned int offset ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;

  {
  {
#line 2304
  sge_len = 0U;
#line 2309
  tmp = amap_mask(32U);
#line 2309
  amap_set((void *)pwrb, 5U, tmp, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2311
  tmp___0 = amap_mask(32U);
#line 2311
  amap_set((void *)pwrb, 4U, tmp___0, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2314
  l_sg = sg;
#line 2315
  index = 0U;
  }
#line 2315
  goto ldv_57557;
  ldv_57556: ;
#line 2317
  if (index == 0U) {
    {
#line 2318
    sg_len = sg->dma_length;
#line 2319
    addr = sg->dma_address;
#line 2320
    tmp___1 = amap_mask(32U);
#line 2320
    amap_set((void *)pwrb, 9U, tmp___1, 0U, (unsigned int )addr);
#line 2323
    tmp___2 = amap_mask(32U);
#line 2323
    amap_set((void *)pwrb, 8U, tmp___2, 0U, (unsigned int )(addr >> 32ULL));
#line 2326
    tmp___3 = amap_mask(17U);
#line 2326
    amap_set((void *)pwrb, 11U, tmp___3, 0U, sg_len);
#line 2329
    sge_len = sg_len;
    }
  } else {
    {
#line 2331
    tmp___4 = amap_mask(24U);
#line 2331
    amap_set((void *)pwrb, 14U, tmp___4, 0U, sge_len);
#line 2333
    sg_len = sg->dma_length;
#line 2334
    addr = sg->dma_address;
#line 2335
    tmp___5 = amap_mask(32U);
#line 2335
    amap_set((void *)pwrb, 13U, tmp___5, 0U, (unsigned int )addr);
#line 2338
    tmp___6 = amap_mask(32U);
#line 2338
    amap_set((void *)pwrb, 12U, tmp___6, 0U, (unsigned int )(addr >> 32ULL));
#line 2341
    tmp___7 = amap_mask(17U);
#line 2341
    amap_set((void *)pwrb, 15U, tmp___7, 0U, sg_len);
    }
  }
  {
#line 2315
  index = index + 1U;
#line 2315
  sg = sg_next(sg);
  }
  ldv_57557: ;
#line 2315
  if (index < num_sg && index <= 1U) {
#line 2317
    goto ldv_57556;
  } else {

  }
  {
#line 2346
  psgl = (io_task->psgl_handle)->pfrag;
#line 2347
  __memset((void *)psgl, 0, 512UL);
#line 2349
  tmp___8 = amap_mask(17U);
#line 2349
  amap_set((void *)psgl, 3U, tmp___8, 0U, (u32 )((int )io_task->bhs_len + -2));
#line 2351
  tmp___9 = amap_mask(32U);
#line 2351
  amap_set((void *)psgl, 0U, tmp___9, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2353
  tmp___10 = amap_mask(32U);
#line 2353
  amap_set((void *)psgl, 1U, tmp___10, 0U, io_task->bhs_pa.u.a32.address_lo);
  }
#line 2356
  if (num_sg == 1U) {
    {
#line 2357
    tmp___11 = amap_mask(1U);
#line 2357
    amap_set((void *)pwrb, 10U, tmp___11, 31U, 1U);
#line 2359
    tmp___12 = amap_mask(1U);
#line 2359
    amap_set((void *)pwrb, 14U, tmp___12, 31U, 0U);
    }
  } else
#line 2361
  if (num_sg == 2U) {
    {
#line 2362
    tmp___13 = amap_mask(1U);
#line 2362
    amap_set((void *)pwrb, 10U, tmp___13, 31U, 0U);
#line 2364
    tmp___14 = amap_mask(1U);
#line 2364
    amap_set((void *)pwrb, 14U, tmp___14, 31U, 1U);
    }
  } else {
    {
#line 2367
    tmp___15 = amap_mask(1U);
#line 2367
    amap_set((void *)pwrb, 10U, tmp___15, 31U, 0U);
#line 2369
    tmp___16 = amap_mask(1U);
#line 2369
    amap_set((void *)pwrb, 14U, tmp___16, 31U, 0U);
    }
  }
#line 2373
  sg = l_sg;
#line 2374
  psgl = psgl + 1;
#line 2375
  psgl = psgl + 1;
#line 2376
  offset = 0U;
#line 2377
  index = 0U;
#line 2377
  goto ldv_57560;
  ldv_57559: 
  {
#line 2378
  sg_len = sg->dma_length;
#line 2379
  addr = sg->dma_address;
#line 2380
  tmp___17 = amap_mask(32U);
#line 2380
  amap_set((void *)psgl, 1U, tmp___17, 0U, (unsigned int )addr);
#line 2382
  tmp___18 = amap_mask(32U);
#line 2382
  amap_set((void *)psgl, 0U, tmp___18, 0U, (unsigned int )(addr >> 32ULL));
#line 2384
  tmp___19 = amap_mask(17U);
#line 2384
  amap_set((void *)psgl, 3U, tmp___19, 0U, sg_len);
#line 2385
  tmp___20 = amap_mask(22U);
#line 2385
  amap_set((void *)psgl, 2U, tmp___20, 0U, offset);
#line 2386
  tmp___21 = amap_mask(1U);
#line 2386
  amap_set((void *)psgl, 2U, tmp___21, 31U, 0U);
#line 2387
  offset = offset + sg_len;
#line 2377
  index = index + 1U;
#line 2377
  sg = sg_next(sg);
#line 2377
  psgl = psgl + 1;
  }
  ldv_57560: ;
#line 2377
  if (index < num_sg) {
#line 2379
    goto ldv_57559;
  } else {

  }
  {
#line 2389
  psgl = psgl - 1;
#line 2390
  tmp___22 = amap_mask(1U);
#line 2390
  amap_set((void *)psgl, 2U, tmp___22, 31U, 1U);
  }
#line 2391
  return;
}
}
#line 2394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_write_sgl(struct iscsi_wrb *pwrb , struct scatterlist *sg , unsigned int num_sg ,
                          struct beiscsi_io_task *io_task ) 
{ 
  struct iscsi_sge *psgl ;
  unsigned int sg_len ;
  unsigned int index ;
  unsigned int sge_len ;
  unsigned long long addr ;
  struct scatterlist *l_sg ;
  unsigned int offset ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  u32 tmp___21 ;
  u32 tmp___22 ;

  {
  {
#line 2399
  sge_len = 0U;
#line 2404
  tmp = amap_mask(32U);
#line 2404
  amap_set((void *)pwrb, 5U, tmp, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2406
  tmp___0 = amap_mask(32U);
#line 2406
  amap_set((void *)pwrb, 4U, tmp___0, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2409
  l_sg = sg;
#line 2410
  index = 0U;
  }
#line 2410
  goto ldv_57576;
  ldv_57575: ;
#line 2412
  if (index == 0U) {
    {
#line 2413
    sg_len = sg->dma_length;
#line 2414
    addr = sg->dma_address;
#line 2415
    tmp___1 = amap_mask(32U);
#line 2415
    amap_set((void *)pwrb, 9U, tmp___1, 0U, (unsigned int )addr);
#line 2417
    tmp___2 = amap_mask(32U);
#line 2417
    amap_set((void *)pwrb, 8U, tmp___2, 0U, (unsigned int )(addr >> 32));
#line 2419
    tmp___3 = amap_mask(17U);
#line 2419
    amap_set((void *)pwrb, 11U, tmp___3, 0U, sg_len);
#line 2421
    sge_len = sg_len;
    }
  } else {
    {
#line 2423
    tmp___4 = amap_mask(22U);
#line 2423
    amap_set((void *)pwrb, 14U, tmp___4, 0U, sge_len);
#line 2425
    sg_len = sg->dma_length;
#line 2426
    addr = sg->dma_address;
#line 2427
    tmp___5 = amap_mask(32U);
#line 2427
    amap_set((void *)pwrb, 13U, tmp___5, 0U, (unsigned int )addr);
#line 2429
    tmp___6 = amap_mask(32U);
#line 2429
    amap_set((void *)pwrb, 12U, tmp___6, 0U, (unsigned int )(addr >> 32));
#line 2431
    tmp___7 = amap_mask(17U);
#line 2431
    amap_set((void *)pwrb, 15U, tmp___7, 0U, sg_len);
    }
  }
  {
#line 2410
  index = index + 1U;
#line 2410
  sg = sg_next(sg);
  }
  ldv_57576: ;
#line 2410
  if (index < num_sg && index <= 1U) {
#line 2412
    goto ldv_57575;
  } else {

  }
  {
#line 2435
  psgl = (io_task->psgl_handle)->pfrag;
#line 2436
  __memset((void *)psgl, 0, 512UL);
#line 2438
  tmp___8 = amap_mask(17U);
#line 2438
  amap_set((void *)psgl, 3U, tmp___8, 0U, (u32 )((int )io_task->bhs_len + -2));
#line 2440
  tmp___9 = amap_mask(32U);
#line 2440
  amap_set((void *)psgl, 0U, tmp___9, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2442
  tmp___10 = amap_mask(32U);
#line 2442
  amap_set((void *)psgl, 1U, tmp___10, 0U, io_task->bhs_pa.u.a32.address_lo);
  }
#line 2445
  if (num_sg == 1U) {
    {
#line 2446
    tmp___11 = amap_mask(1U);
#line 2446
    amap_set((void *)pwrb, 10U, tmp___11, 31U, 1U);
#line 2448
    tmp___12 = amap_mask(1U);
#line 2448
    amap_set((void *)pwrb, 14U, tmp___12, 31U, 0U);
    }
  } else
#line 2450
  if (num_sg == 2U) {
    {
#line 2451
    tmp___13 = amap_mask(1U);
#line 2451
    amap_set((void *)pwrb, 10U, tmp___13, 31U, 0U);
#line 2453
    tmp___14 = amap_mask(1U);
#line 2453
    amap_set((void *)pwrb, 14U, tmp___14, 31U, 1U);
    }
  } else {
    {
#line 2456
    tmp___15 = amap_mask(1U);
#line 2456
    amap_set((void *)pwrb, 10U, tmp___15, 31U, 0U);
#line 2458
    tmp___16 = amap_mask(1U);
#line 2458
    amap_set((void *)pwrb, 14U, tmp___16, 31U, 0U);
    }
  }
#line 2461
  sg = l_sg;
#line 2462
  psgl = psgl + 1;
#line 2463
  psgl = psgl + 1;
#line 2464
  offset = 0U;
#line 2465
  index = 0U;
#line 2465
  goto ldv_57579;
  ldv_57578: 
  {
#line 2466
  sg_len = sg->dma_length;
#line 2467
  addr = sg->dma_address;
#line 2468
  tmp___17 = amap_mask(32U);
#line 2468
  amap_set((void *)psgl, 1U, tmp___17, 0U, (u32 )addr);
#line 2470
  tmp___18 = amap_mask(32U);
#line 2470
  amap_set((void *)psgl, 0U, tmp___18, 0U, (u32 )(addr >> 32));
#line 2472
  tmp___19 = amap_mask(17U);
#line 2472
  amap_set((void *)psgl, 3U, tmp___19, 0U, sg_len);
#line 2473
  tmp___20 = amap_mask(22U);
#line 2473
  amap_set((void *)psgl, 2U, tmp___20, 0U, offset);
#line 2474
  tmp___21 = amap_mask(1U);
#line 2474
  amap_set((void *)psgl, 2U, tmp___21, 31U, 0U);
#line 2475
  offset = offset + sg_len;
#line 2465
  index = index + 1U;
#line 2465
  sg = sg_next(sg);
#line 2465
  psgl = psgl + 1;
  }
  ldv_57579: ;
#line 2465
  if (index < num_sg) {
#line 2467
    goto ldv_57578;
  } else {

  }
  {
#line 2477
  psgl = psgl - 1;
#line 2478
  tmp___22 = amap_mask(1U);
#line 2478
  amap_set((void *)psgl, 2U, tmp___22, 31U, 1U);
  }
#line 2479
  return;
}
}
#line 2486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_write_buffer(struct iscsi_wrb *pwrb , struct iscsi_task *task ) 
{ 
  struct iscsi_sge *psgl ;
  struct beiscsi_io_task *io_task ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  uint8_t dsp_value ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;

  {
  {
#line 2489
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 2490
  beiscsi_conn = io_task->conn;
#line 2491
  phba = beiscsi_conn->phba;
#line 2492
  dsp_value = 0U;
#line 2494
  io_task->bhs_len = 322U;
#line 2495
  tmp = amap_mask(32U);
#line 2495
  amap_set((void *)pwrb, 5U, tmp, 0U, io_task->bhs_pa.u.a32.address_lo);
#line 2497
  tmp___0 = amap_mask(32U);
#line 2497
  amap_set((void *)pwrb, 4U, tmp___0, 0U, io_task->bhs_pa.u.a32.address_hi);
  }
#line 2500
  if ((unsigned long )task->data != (unsigned long )((char *)0)) {
#line 2503
    dsp_value = task->data_count != 0U;
#line 2505
    if (phba->generation - 2U <= 1U) {
      {
#line 2506
      tmp___1 = amap_mask(1U);
#line 2506
      amap_set((void *)pwrb, 0U, tmp___1, 24U, (u32 )dsp_value);
      }
    } else {
      {
#line 2509
      tmp___2 = amap_mask(1U);
#line 2509
      amap_set((void *)pwrb, 11U, tmp___2, 28U, (u32 )dsp_value);
      }
    }
#line 2513
    if ((unsigned int )dsp_value != 0U) {
      {
#line 2514
      io_task->mtask_addr = pci_map_single(phba->pcidev, (void *)task->data, (size_t )task->data_count,
                                           1);
#line 2518
      io_task->mtask_data_count = task->data_count;
      }
    } else {
#line 2520
      io_task->mtask_addr = 0ULL;
    }
    {
#line 2522
    tmp___3 = amap_mask(32U);
#line 2522
    amap_set((void *)pwrb, 9U, tmp___3, 0U, (unsigned int )io_task->mtask_addr);
#line 2524
    tmp___4 = amap_mask(32U);
#line 2524
    amap_set((void *)pwrb, 8U, tmp___4, 0U, (unsigned int )(io_task->mtask_addr >> 32ULL));
#line 2526
    tmp___5 = amap_mask(17U);
#line 2526
    amap_set((void *)pwrb, 11U, tmp___5, 0U, task->data_count);
#line 2529
    tmp___6 = amap_mask(1U);
#line 2529
    amap_set((void *)pwrb, 10U, tmp___6, 31U, 1U);
    }
  } else {
    {
#line 2531
    tmp___7 = amap_mask(1U);
#line 2531
    amap_set((void *)pwrb, 0U, tmp___7, 24U, 0U);
#line 2532
    io_task->mtask_addr = 0ULL;
    }
  }
  {
#line 2535
  psgl = (io_task->psgl_handle)->pfrag;
#line 2537
  tmp___8 = amap_mask(17U);
#line 2537
  amap_set((void *)psgl, 3U, tmp___8, 0U, (u32 )io_task->bhs_len);
#line 2539
  tmp___9 = amap_mask(32U);
#line 2539
  amap_set((void *)psgl, 0U, tmp___9, 0U, io_task->bhs_pa.u.a32.address_hi);
#line 2541
  tmp___10 = amap_mask(32U);
#line 2541
  amap_set((void *)psgl, 1U, tmp___10, 0U, io_task->bhs_pa.u.a32.address_lo);
  }
#line 2543
  if ((unsigned long )task->data != (unsigned long )((char *)0)) {
    {
#line 2544
    psgl = psgl + 1;
#line 2545
    tmp___11 = amap_mask(32U);
#line 2545
    amap_set((void *)psgl, 0U, tmp___11, 0U, 0U);
#line 2546
    tmp___12 = amap_mask(32U);
#line 2546
    amap_set((void *)psgl, 1U, tmp___12, 0U, 0U);
#line 2547
    tmp___13 = amap_mask(17U);
#line 2547
    amap_set((void *)psgl, 3U, tmp___13, 0U, 0U);
#line 2548
    tmp___14 = amap_mask(22U);
#line 2548
    amap_set((void *)psgl, 2U, tmp___14, 0U, 0U);
#line 2549
    tmp___15 = amap_mask(9U);
#line 2549
    amap_set((void *)psgl, 2U, tmp___15, 22U, 0U);
#line 2550
    tmp___16 = amap_mask(1U);
#line 2550
    amap_set((void *)psgl, 2U, tmp___16, 31U, 0U);
#line 2552
    psgl = psgl + 1;
    }
#line 2553
    if ((unsigned long )task->data != (unsigned long )((char *)0)) {
      {
#line 2554
      tmp___17 = amap_mask(32U);
#line 2554
      amap_set((void *)psgl, 1U, tmp___17, 0U, (unsigned int )io_task->mtask_addr);
#line 2556
      tmp___18 = amap_mask(32U);
#line 2556
      amap_set((void *)psgl, 0U, tmp___18, 0U, (unsigned int )(io_task->mtask_addr >> 32ULL));
      }
    } else {

    }
    {
#line 2559
    tmp___19 = amap_mask(17U);
#line 2559
    amap_set((void *)psgl, 3U, tmp___19, 0U, 262U);
    }
  } else {

  }
  {
#line 2561
  tmp___20 = amap_mask(1U);
#line 2561
  amap_set((void *)psgl, 2U, tmp___20, 31U, 1U);
  }
#line 2562
  return;
}
}
#line 2568 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_find_mem_req(struct beiscsi_hba *phba ) 
{ 
  uint8_t mem_descr_index ;
  uint8_t ulp_num ;
  unsigned int num_cq_pages ;
  unsigned int num_async_pdu_buf_pages ;
  unsigned int num_async_pdu_data_pages ;
  unsigned int wrb_sz_per_cxn ;
  unsigned int num_async_pdu_buf_sgl_pages ;
  unsigned int num_async_pdu_data_sgl_pages ;
  unsigned long tmp___67 ;
  int tmp___69 ;

  {
  {
#line 2575
  num_cq_pages = (unsigned long )phba->params.num_cq_entries * 16UL > 4095UL ? (unsigned int )((((unsigned long )phba->params.num_cq_entries + 256UL) * 16UL - 1UL) / 4096UL) : 1U;
#line 2578
  phba->params.hwi_ws_sz = 264U;
#line 2580
  phba->mem_req[21] = 128U;
#line 2582
  phba->mem_req[0] = 15000U;
#line 2586
  phba->mem_req[1] = (phba->params.wrbs_per_cxn * phba->params.cxns_per_ctrl) * 64U;
#line 2589
  wrb_sz_per_cxn = phba->params.wrbs_per_cxn * 24U;
#line 2591
  tmp___67 = __roundup_pow_of_two((unsigned long )(wrb_sz_per_cxn * phba->params.cxns_per_ctrl));
#line 2591
  phba->mem_req[2] = (unsigned int )tmp___67;
#line 2594
  phba->mem_req[3] = phba->params.icds_per_ctrl * 32U;
#line 2596
  phba->mem_req[4] = (phba->params.num_sge_per_io * phba->params.icds_per_ctrl) * 16U;
#line 2598
  ulp_num = 0U;
  }
#line 2598
  goto ldv_57602;
  ldv_57601: 
  {
#line 2599
  tmp___69 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 2599
  if (tmp___69 != 0) {
#line 2601
    num_async_pdu_buf_sgl_pages = (unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] * 8UL > 4095UL ? (unsigned int )((((unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] + 512UL) * 8UL - 1UL) / 4096UL) : 1U;
#line 2606
    num_async_pdu_buf_pages = phba->fw_config.iscsi_cid_count[(int )ulp_num] * phba->params.defpdu_hdr_sz > 4095U ? (unsigned int )(((unsigned long )(phba->fw_config.iscsi_cid_count[(int )ulp_num] * phba->params.defpdu_hdr_sz) + 4095UL) / 4096UL) : 1U;
#line 2611
    num_async_pdu_data_pages = phba->fw_config.iscsi_cid_count[(int )ulp_num] * phba->params.defpdu_data_sz > 4095U ? (unsigned int )(((unsigned long )(phba->fw_config.iscsi_cid_count[(int )ulp_num] * phba->params.defpdu_data_sz) + 4095UL) / 4096UL) : 1U;
#line 2616
    num_async_pdu_data_sgl_pages = (unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] * 8UL > 4095UL ? (unsigned int )((((unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] + 512UL) * 8UL - 1UL) / 4096UL) : 1U;
#line 2621
    mem_descr_index = (unsigned int )ulp_num * 8U + 5U;
#line 2623
    phba->mem_req[(int )mem_descr_index] = phba->fw_config.iscsi_cid_count[(int )ulp_num] * 128U;
#line 2627
    mem_descr_index = (unsigned int )ulp_num * 8U + 6U;
#line 2629
    phba->mem_req[(int )mem_descr_index] = num_async_pdu_buf_pages * 4096U;
#line 2633
    mem_descr_index = (unsigned int )ulp_num * 8U + 7U;
#line 2635
    phba->mem_req[(int )mem_descr_index] = num_async_pdu_data_pages * 4096U;
#line 2639
    mem_descr_index = (unsigned int )((uint8_t )((int )ulp_num + 1)) * 8U;
#line 2641
    phba->mem_req[(int )mem_descr_index] = num_async_pdu_buf_sgl_pages * 4096U;
#line 2645
    mem_descr_index = (unsigned int )ulp_num * 8U + 9U;
#line 2647
    phba->mem_req[(int )mem_descr_index] = num_async_pdu_data_sgl_pages * 4096U;
#line 2651
    mem_descr_index = (unsigned int )ulp_num * 8U + 10U;
#line 2653
    phba->mem_req[(int )mem_descr_index] = phba->fw_config.iscsi_cid_count[(int )ulp_num] * 48U;
#line 2657
    mem_descr_index = (unsigned int )ulp_num * 8U + 11U;
#line 2659
    phba->mem_req[(int )mem_descr_index] = phba->fw_config.iscsi_cid_count[(int )ulp_num] * 48U;
#line 2663
    mem_descr_index = (unsigned int )ulp_num * 8U + 12U;
#line 2665
    phba->mem_req[(int )mem_descr_index] = phba->fw_config.iscsi_cid_count[(int )ulp_num] * 56U + 4256U;
  } else {

  }
#line 2598
  ulp_num = (uint8_t )((int )ulp_num + 1);
  ldv_57602: ;
#line 2598
  if ((unsigned int )ulp_num <= 1U) {
#line 2600
    goto ldv_57601;
  } else {

  }

#line 2605
  return;
}
}
#line 2673 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_alloc_mem(struct beiscsi_hba *phba ) 
{ 
  dma_addr_t bus_add ;
  struct hwi_controller *phwi_ctrlr ;
  struct be_mem_descriptor *mem_descr ;
  struct mem_array *mem_arr ;
  struct mem_array *mem_arr_orig ;
  unsigned int i ;
  unsigned int j ;
  unsigned int alloc_size ;
  unsigned int curr_alloc_size ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned long tmp___70 ;
  unsigned long tmp___138 ;
  unsigned int _min1___0 ;
  unsigned int _min2___0 ;
  void *tmp___139 ;

  {
  {
#line 2681
  tmp = kzalloc((size_t )phba->params.hwi_ws_sz, 208U);
#line 2681
  phba->phwi_ctrlr = (struct hwi_controller *)tmp;
  }
#line 2682
  if ((unsigned long )phba->phwi_ctrlr == (unsigned long )((struct hwi_controller *)0)) {
#line 2683
    return (-12);
  } else {

  }
  {
#line 2686
  phwi_ctrlr = phba->phwi_ctrlr;
#line 2687
  tmp___0 = kzalloc((unsigned long )phba->params.cxns_per_ctrl * 80UL, 208U);
#line 2687
  phwi_ctrlr->wrb_context = (struct hwi_wrb_context *)tmp___0;
  }
#line 2690
  if ((unsigned long )phwi_ctrlr->wrb_context == (unsigned long )((struct hwi_wrb_context *)0)) {
#line 2691
    return (-12);
  } else {

  }
  {
#line 2693
  tmp___1 = kcalloc(22UL, 32UL, 208U);
#line 2693
  phba->init_mem = (struct be_mem_descriptor *)tmp___1;
  }
#line 2695
  if ((unsigned long )phba->init_mem == (unsigned long )((struct be_mem_descriptor *)0)) {
    {
#line 2696
    kfree((void const   *)phwi_ctrlr->wrb_context);
#line 2697
    kfree((void const   *)phba->phwi_ctrlr);
    }
#line 2698
    return (-12);
  } else {

  }
  {
#line 2701
  tmp___2 = kmalloc(4608UL, 208U);
#line 2701
  mem_arr_orig = (struct mem_array *)tmp___2;
  }
#line 2703
  if ((unsigned long )mem_arr_orig == (unsigned long )((struct mem_array *)0)) {
    {
#line 2704
    kfree((void const   *)phba->init_mem);
#line 2705
    kfree((void const   *)phwi_ctrlr->wrb_context);
#line 2706
    kfree((void const   *)phba->phwi_ctrlr);
    }
#line 2707
    return (-12);
  } else {

  }
#line 2710
  mem_descr = phba->init_mem;
#line 2711
  i = 0U;
#line 2711
  goto ldv_57627;
  ldv_57626: ;
#line 2712
  if (phba->mem_req[i] == 0U) {
#line 2713
    mem_descr->mem_array = (struct mem_array *)0;
#line 2714
    mem_descr = mem_descr + 1;
#line 2715
    goto ldv_57616;
  } else {

  }
  {
#line 2718
  j = 0U;
#line 2719
  mem_arr = mem_arr_orig;
#line 2720
  alloc_size = phba->mem_req[i];
#line 2721
  __memset((void *)mem_arr, 0, 4608UL);
#line 2723
  _min1 = be_max_phys_size * 1024U;
#line 2723
  _min2 = alloc_size;
#line 2723
  curr_alloc_size = _min1 < _min2 ? _min1 : _min2;
  }
  ldv_57624: 
  {
#line 2725
  mem_arr->virtual_address = pci_alloc_consistent(phba->pcidev, (size_t )curr_alloc_size,
                                                  & bus_add);
  }
#line 2729
  if ((unsigned long )mem_arr->virtual_address == (unsigned long )((void *)0)) {
#line 2730
    if (curr_alloc_size <= 16384U) {
#line 2731
      goto free_mem;
    } else {

    }
    {
#line 2732
    tmp___138 = __rounddown_pow_of_two((unsigned long )curr_alloc_size);
    }
#line 2732
    if ((unsigned long )curr_alloc_size != tmp___138) {
      {
#line 2734
      tmp___70 = __rounddown_pow_of_two((unsigned long )curr_alloc_size);
#line 2734
      curr_alloc_size = (unsigned int )tmp___70;
      }
    } else {
#line 2737
      curr_alloc_size = curr_alloc_size / 2U;
    }
  } else {
#line 2739
    mem_arr->bus_address.u.a64.address = bus_add;
#line 2741
    mem_arr->size = curr_alloc_size;
#line 2742
    alloc_size = alloc_size - curr_alloc_size;
#line 2743
    _min1___0 = be_max_phys_size * 1024U;
#line 2743
    _min2___0 = alloc_size;
#line 2743
    curr_alloc_size = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 2745
    j = j + 1U;
#line 2746
    mem_arr = mem_arr + 1;
  }
#line 2748
  if (alloc_size != 0U) {
#line 2750
    goto ldv_57624;
  } else {

  }
  {
#line 2749
  mem_descr->num_elements = j;
#line 2750
  mem_descr->size_in_bytes = phba->mem_req[i];
#line 2751
  tmp___139 = kmalloc((unsigned long )j * 24UL, 208U);
#line 2751
  mem_descr->mem_array = (struct mem_array *)tmp___139;
  }
#line 2753
  if ((unsigned long )mem_descr->mem_array == (unsigned long )((struct mem_array *)0)) {
#line 2754
    goto free_mem;
  } else {

  }
  {
#line 2756
  __memcpy((void *)mem_descr->mem_array, (void const   *)mem_arr_orig, (unsigned long )j * 24UL);
#line 2758
  mem_descr = mem_descr + 1;
  }
  ldv_57616: 
#line 2711
  i = i + 1U;
  ldv_57627: ;
#line 2711
  if (i <= 21U) {
#line 2713
    goto ldv_57626;
  } else {

  }
  {
#line 2760
  kfree((void const   *)mem_arr_orig);
  }
#line 2761
  return (0);
  free_mem: 
#line 2763
  mem_descr->num_elements = j;
#line 2764
  goto ldv_57633;
  ldv_57632: 
#line 2765
  j = mem_descr->num_elements;
#line 2765
  goto ldv_57630;
  ldv_57629: 
  {
#line 2766
  pci_free_consistent(phba->pcidev, (size_t )(mem_descr->mem_array + (unsigned long )(j - 1U))->size,
                      (mem_descr->mem_array + (unsigned long )(j - 1U))->virtual_address,
                      (mem_descr->mem_array + (unsigned long )(j - 1U))->bus_address.u.a64.address);
#line 2765
  j = j - 1U;
  }
  ldv_57630: ;
#line 2765
  if (j != 0U) {
#line 2767
    goto ldv_57629;
  } else {

  }

#line 2774
  if (i != 0U) {
    {
#line 2775
    i = i - 1U;
#line 2776
    kfree((void const   *)mem_descr->mem_array);
#line 2777
    mem_descr = mem_descr - 1;
    }
  } else {

  }
  ldv_57633: ;
#line 2764
  if ((i | j) != 0U) {
#line 2766
    goto ldv_57632;
  } else {

  }
  {
#line 2780
  kfree((void const   *)mem_arr_orig);
#line 2781
  kfree((void const   *)phba->init_mem);
#line 2782
  kfree((void const   *)(phba->phwi_ctrlr)->wrb_context);
#line 2783
  kfree((void const   *)phba->phwi_ctrlr);
  }
#line 2784
  return (-12);
}
}
#line 2787 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_get_memory(struct beiscsi_hba *phba ) 
{ 
  int tmp ;

  {
  {
#line 2789
  beiscsi_find_mem_req(phba);
#line 2790
  tmp = beiscsi_alloc_mem(phba);
  }
#line 2790
  return (tmp);
}
}
#line 2793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void iscsi_init_global_templates(struct beiscsi_hba *phba ) 
{ 
  struct pdu_data_out *pdata_out ;
  struct pdu_nop_out *pnop_out ;
  struct be_mem_descriptor *mem_descr ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
  {
#line 2799
  mem_descr = phba->init_mem;
#line 2800
  mem_descr = mem_descr + 21UL;
#line 2801
  pdata_out = (struct pdu_data_out *)(mem_descr->mem_array)->virtual_address;
#line 2803
  __memset((void *)pdata_out, 0, 64UL);
#line 2805
  tmp = amap_mask(6U);
#line 2805
  amap_set((void *)pdata_out, 0U, tmp, 0U, 5U);
#line 2808
  pnop_out = (struct pdu_nop_out *)(mem_descr->mem_array)->virtual_address + 64U;
#line 2812
  __memset((void *)pnop_out, 0, 64UL);
#line 2813
  tmp___0 = amap_mask(32U);
#line 2813
  amap_set((void *)pnop_out, 5U, tmp___0, 0U, 4294967295U);
#line 2814
  tmp___1 = amap_mask(1U);
#line 2814
  amap_set((void *)pnop_out, 0U, tmp___1, 15U, 1U);
#line 2815
  tmp___2 = amap_mask(1U);
#line 2815
  amap_set((void *)pnop_out, 0U, tmp___2, 6U, 0U);
  }
#line 2816
  return;
}
}
#line 2818 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_wrb_handle(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr_wrbh ;
  struct be_mem_descriptor *mem_descr_wrb ;
  struct hwi_context_memory *phwi_ctxt ;
  struct wrb_handle *pwrb_handle ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_wrb_context *pwrb_context ;
  struct iscsi_wrb *pwrb ;
  unsigned int num_cxn_wrbh ;
  unsigned int num_cxn_wrb ;
  unsigned int j ;
  unsigned int idx ;
  unsigned int index ;
  void *tmp ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  void *tmp___1 ;
  uint32_t log_value___1 ;

  {
  {
#line 2822
  pwrb_handle = (struct wrb_handle *)0;
#line 2825
  pwrb = (struct iscsi_wrb *)0;
#line 2826
  num_cxn_wrbh = 0U;
#line 2827
  num_cxn_wrb = 0U;
#line 2827
  idx = 0U;
#line 2829
  mem_descr_wrbh = phba->init_mem;
#line 2830
  mem_descr_wrbh = mem_descr_wrbh + 2UL;
#line 2832
  mem_descr_wrb = phba->init_mem;
#line 2833
  mem_descr_wrb = mem_descr_wrb + 1UL;
#line 2834
  phwi_ctrlr = phba->phwi_ctrlr;
#line 2837
  phwi_ctxt = phwi_ctrlr->phwi_ctxt;
#line 2838
  tmp = kzalloc((unsigned long )phba->params.cxns_per_ctrl * 40UL, 208U);
#line 2838
  phwi_ctxt->be_wrbq = (struct be_queue_info *)tmp;
  }
#line 2841
  if ((unsigned long )phwi_ctxt->be_wrbq == (unsigned long )((struct be_queue_info *)0)) {
#line 2842
    log_value = phba->attr_log_enable;
#line 2842
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 2842
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : WRBQ Mem Alloc Failed\n",
                 2843);
      }
    } else {

    }
#line 2844
    return (-12);
  } else {

  }
#line 2847
  index = 0U;
#line 2847
  goto ldv_57667;
  ldv_57666: 
  {
#line 2848
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )index;
#line 2849
  tmp___0 = kzalloc((unsigned long )phba->params.wrbs_per_cxn * 8UL, 208U);
#line 2849
  pwrb_context->pwrb_handle_base = (struct wrb_handle **)tmp___0;
  }
#line 2852
  if ((unsigned long )pwrb_context->pwrb_handle_base == (unsigned long )((struct wrb_handle **)0)) {
#line 2853
    log_value___0 = phba->attr_log_enable;
#line 2853
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 2853
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Mem Alloc Failed. Failing to load\n",
                 2854);
      }
    } else {

    }
#line 2855
    goto init_wrb_hndl_failed;
  } else {

  }
  {
#line 2857
  tmp___1 = kzalloc((unsigned long )phba->params.wrbs_per_cxn * 8UL, 208U);
#line 2857
  pwrb_context->pwrb_handle_basestd = (struct wrb_handle **)tmp___1;
  }
#line 2860
  if ((unsigned long )pwrb_context->pwrb_handle_basestd == (unsigned long )((struct wrb_handle **)0)) {
#line 2861
    log_value___1 = phba->attr_log_enable;
#line 2861
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 2861
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Mem Alloc Failed. Failing to load\n",
                 2862);
      }
    } else {

    }
#line 2863
    goto init_wrb_hndl_failed;
  } else {

  }
#line 2865
  if (num_cxn_wrbh == 0U) {
#line 2866
    pwrb_handle = (struct wrb_handle *)(mem_descr_wrbh->mem_array + (unsigned long )idx)->virtual_address;
#line 2868
    num_cxn_wrbh = (unsigned int )((unsigned long )(mem_descr_wrbh->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.wrbs_per_cxn * 24UL));
#line 2871
    idx = idx + 1U;
  } else {

  }
#line 2873
  pwrb_context->alloc_index = 0U;
#line 2874
  pwrb_context->wrb_handles_available = 0U;
#line 2875
  pwrb_context->free_index = 0U;
#line 2877
  if (num_cxn_wrbh != 0U) {
#line 2878
    j = 0U;
#line 2878
    goto ldv_57664;
    ldv_57663: 
#line 2879
    *(pwrb_context->pwrb_handle_base + (unsigned long )j) = pwrb_handle;
#line 2880
    *(pwrb_context->pwrb_handle_basestd + (unsigned long )j) = pwrb_handle;
#line 2882
    pwrb_context->wrb_handles_available = (unsigned short )((int )pwrb_context->wrb_handles_available + 1);
#line 2883
    pwrb_handle->wrb_index = (unsigned short )j;
#line 2884
    pwrb_handle = pwrb_handle + 1;
#line 2878
    j = j + 1U;
    ldv_57664: ;
#line 2878
    if (j < phba->params.wrbs_per_cxn) {
#line 2880
      goto ldv_57663;
    } else {

    }
#line 2886
    num_cxn_wrbh = num_cxn_wrbh - 1U;
  } else {

  }
#line 2847
  index = index + 1U;
  ldv_57667: ;
#line 2847
  if (index < phba->params.cxns_per_ctrl) {
#line 2849
    goto ldv_57666;
  } else {

  }
#line 2889
  idx = 0U;
#line 2890
  index = 0U;
#line 2890
  goto ldv_57673;
  ldv_57672: 
#line 2891
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )index;
#line 2892
  if (num_cxn_wrb == 0U) {
#line 2893
    pwrb = (struct iscsi_wrb *)(mem_descr_wrb->mem_array + (unsigned long )idx)->virtual_address;
#line 2894
    num_cxn_wrb = (unsigned int )((unsigned long )(mem_descr_wrb->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.wrbs_per_cxn * 64UL));
#line 2897
    idx = idx + 1U;
  } else {

  }
#line 2900
  if (num_cxn_wrb != 0U) {
#line 2901
    j = 0U;
#line 2901
    goto ldv_57670;
    ldv_57669: 
#line 2902
    pwrb_handle = *(pwrb_context->pwrb_handle_base + (unsigned long )j);
#line 2903
    pwrb_handle->pwrb = pwrb;
#line 2904
    pwrb = pwrb + 1;
#line 2901
    j = j + 1U;
    ldv_57670: ;
#line 2901
    if (j < phba->params.wrbs_per_cxn) {
#line 2903
      goto ldv_57669;
    } else {

    }
#line 2906
    num_cxn_wrb = num_cxn_wrb - 1U;
  } else {

  }
#line 2890
  index = index + 1U;
  ldv_57673: ;
#line 2890
  if (index < phba->params.cxns_per_ctrl) {
#line 2892
    goto ldv_57672;
  } else {

  }

#line 2909
  return (0);
  init_wrb_hndl_failed: 
#line 2911
  j = index;
#line 2911
  goto ldv_57676;
  ldv_57675: 
  {
#line 2912
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )j;
#line 2913
  kfree((void const   *)pwrb_context->pwrb_handle_base);
#line 2914
  kfree((void const   *)pwrb_context->pwrb_handle_basestd);
#line 2911
  j = j - 1U;
  }
  ldv_57676: ;
#line 2911
  if (j != 0U) {
#line 2913
    goto ldv_57675;
  } else {

  }

#line 2916
  return (-12);
}
}
#line 2919 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int hwi_init_async_pdu_ctx(struct beiscsi_hba *phba ) 
{ 
  uint8_t ulp_num ;
  struct hwi_controller *phwi_ctrlr ;
  struct hba_parameters *p ;
  struct hwi_async_pdu_context *pasync_ctx ;
  struct async_pdu_handle *pasync_header_h ;
  struct async_pdu_handle *pasync_data_h ;
  unsigned int index ;
  unsigned int idx ;
  unsigned int num_per_mem ;
  unsigned int num_async_data ;
  struct be_mem_descriptor *mem_descr ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;
  uint32_t log_value___6 ;
  uint32_t log_value___7 ;
  uint32_t log_value___8 ;
  uint32_t log_value___9 ;
  int tmp___0 ;

  {
#line 2923
  p = & phba->params;
#line 2929
  ulp_num = 0U;
#line 2929
  goto ldv_57707;
  ldv_57706: 
  {
#line 2930
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 2930
  if (tmp___0 != 0) {
    {
#line 2932
    mem_descr = phba->init_mem;
#line 2933
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 12);
#line 2936
    phwi_ctrlr = phba->phwi_ctrlr;
#line 2937
    (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )ulp_num] = (struct hwi_async_pdu_context *)(mem_descr->mem_array)->virtual_address;
#line 2941
    pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[(int )ulp_num];
#line 2942
    __memset((void *)pasync_ctx, 0, 4256UL);
#line 2944
    pasync_ctx->async_entry = (struct hwi_async_entry *)((unsigned long )pasync_ctx + 4256UL);
#line 2949
    pasync_ctx->num_entries = phba->fw_config.iscsi_cid_count[(int )ulp_num];
#line 2951
    pasync_ctx->buffer_size = p->defpdu_hdr_sz;
#line 2953
    mem_descr = phba->init_mem;
#line 2954
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 6);
    }
#line 2956
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 2957
      log_value = phba->attr_log_enable;
#line 2957
      if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
        {
#line 2957
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_BUF_ULP%d va=%p\n",
                   2962, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
        }
      } else {

      }
    } else {
#line 2964
      log_value___0 = phba->attr_log_enable;
#line 2964
      if ((int )log_value___0 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 2964
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 2967, (int )ulp_num);
        }
      } else {

      }
    }
#line 2969
    pasync_ctx->async_header.va_base = (mem_descr->mem_array)->virtual_address;
#line 2972
    pasync_ctx->async_header.pa_base.u.a64.address = (mem_descr->mem_array)->bus_address.u.a64.address;
#line 2976
    mem_descr = phba->init_mem;
#line 2977
    mem_descr = mem_descr + (unsigned long )(((int )ulp_num + 1) * 8);
#line 2979
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 2980
      log_value___1 = phba->attr_log_enable;
#line 2980
      if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
        {
#line 2980
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_RING_ULP%d va=%p\n",
                   2985, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
        }
      } else {

      }
    } else {
#line 2987
      log_value___2 = phba->attr_log_enable;
#line 2987
      if ((int )log_value___2 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 2987
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 2990, (int )ulp_num);
        }
      } else {

      }
    }
#line 2992
    pasync_ctx->async_header.ring_base = (mem_descr->mem_array)->virtual_address;
#line 2995
    mem_descr = phba->init_mem;
#line 2996
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 10);
#line 2998
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 2999
      log_value___3 = phba->attr_log_enable;
#line 2999
      if ((int )log_value___3 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
        {
#line 2999
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_HANDLE_ULP%d va=%p\n",
                   3004, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
        }
      } else {

      }
    } else {
#line 3006
      log_value___4 = phba->attr_log_enable;
#line 3006
      if ((int )log_value___4 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 3006
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3009, (int )ulp_num);
        }
      } else {

      }
    }
    {
#line 3011
    pasync_ctx->async_header.handle_base = (struct async_pdu_handle *)(mem_descr->mem_array)->virtual_address;
#line 3013
    pasync_ctx->async_header.writables = 0U;
#line 3014
    INIT_LIST_HEAD(& pasync_ctx->async_header.free_list);
#line 3016
    mem_descr = phba->init_mem;
#line 3017
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 9);
    }
#line 3019
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 3020
      log_value___5 = phba->attr_log_enable;
#line 3020
      if ((int )log_value___5 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
        {
#line 3020
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_DATA_RING_ULP%d va=%p\n",
                   3025, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
        }
      } else {

      }
    } else {
#line 3027
      log_value___6 = phba->attr_log_enable;
#line 3027
      if ((int )log_value___6 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 3027
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3030, (int )ulp_num);
        }
      } else {

      }
    }
#line 3032
    pasync_ctx->async_data.ring_base = (mem_descr->mem_array)->virtual_address;
#line 3035
    mem_descr = phba->init_mem;
#line 3036
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 11);
#line 3038
    if ((unsigned long )(mem_descr->mem_array)->virtual_address == (unsigned long )((void *)0)) {
#line 3039
      log_value___7 = phba->attr_log_enable;
#line 3039
      if ((int )log_value___7 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 3039
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3042, (int )ulp_num);
        }
      } else {

      }
    } else {

    }
    {
#line 3044
    pasync_ctx->async_data.handle_base = (struct async_pdu_handle *)(mem_descr->mem_array)->virtual_address;
#line 3046
    pasync_ctx->async_data.writables = 0U;
#line 3047
    INIT_LIST_HEAD(& pasync_ctx->async_data.free_list);
#line 3049
    pasync_header_h = pasync_ctx->async_header.handle_base;
#line 3052
    pasync_data_h = pasync_ctx->async_data.handle_base;
#line 3056
    mem_descr = phba->init_mem;
#line 3057
    mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 7);
    }
#line 3059
    if ((unsigned long )(mem_descr->mem_array)->virtual_address != (unsigned long )((void *)0)) {
#line 3060
      log_value___8 = phba->attr_log_enable;
#line 3060
      if ((int )log_value___8 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
        {
#line 3060
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : hwi_init_async_pdu_ctx HWI_MEM_ASYNC_DATA_BUF_ULP%d va=%p\n",
                   3065, (int )ulp_num, (mem_descr->mem_array)->virtual_address);
        }
      } else {

      }
    } else {
#line 3067
      log_value___9 = phba->attr_log_enable;
#line 3067
      if ((int )log_value___9 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 3067
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : No Virtual address for ULP : %d\n", 3070, (int )ulp_num);
        }
      } else {

      }
    }
#line 3072
    idx = 0U;
#line 3073
    pasync_ctx->async_data.va_base = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3075
    pasync_ctx->async_data.pa_base.u.a64.address = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3079
    num_async_data = (mem_descr->mem_array + (unsigned long )idx)->size / phba->params.defpdu_data_sz;
#line 3081
    num_per_mem = 0U;
#line 3083
    index = 0U;
#line 3083
    goto ldv_57704;
    ldv_57703: 
    {
#line 3085
    pasync_header_h->cri = 65535U;
#line 3086
    pasync_header_h->index = (unsigned char )index;
#line 3087
    INIT_LIST_HEAD(& pasync_header_h->link);
#line 3088
    pasync_header_h->pbuffer = (void *)((unsigned long )pasync_ctx->async_header.va_base + (unsigned long )(p->defpdu_hdr_sz * index));
#line 3094
    pasync_header_h->pa.u.a64.address = pasync_ctx->async_header.pa_base.u.a64.address + (unsigned long long )(p->defpdu_hdr_sz * index);
#line 3098
    list_add_tail(& pasync_header_h->link, & pasync_ctx->async_header.free_list);
#line 3101
    pasync_header_h = pasync_header_h + 1;
#line 3102
    pasync_ctx->async_header.free_entries = pasync_ctx->async_header.free_entries + 1U;
#line 3103
    pasync_ctx->async_header.writables = pasync_ctx->async_header.writables + 1U;
#line 3105
    INIT_LIST_HEAD(& (pasync_ctx->async_entry + (unsigned long )index)->wait_queue.list);
#line 3107
    INIT_LIST_HEAD(& (pasync_ctx->async_entry + (unsigned long )index)->header_busy_list);
#line 3109
    pasync_data_h->cri = 65535U;
#line 3110
    pasync_data_h->index = (unsigned char )index;
#line 3111
    INIT_LIST_HEAD(& pasync_data_h->link);
    }
#line 3113
    if (num_async_data == 0U) {
#line 3114
      num_per_mem = 0U;
#line 3115
      idx = idx + 1U;
#line 3116
      pasync_ctx->async_data.va_base = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3119
      pasync_ctx->async_data.pa_base.u.a64.address = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3123
      num_async_data = (mem_descr->mem_array + (unsigned long )idx)->size / phba->params.defpdu_data_sz;
    } else {

    }
    {
#line 3128
    pasync_data_h->pbuffer = (void *)((unsigned long )pasync_ctx->async_data.va_base + (unsigned long )(p->defpdu_data_sz * num_per_mem));
#line 3133
    pasync_data_h->pa.u.a64.address = pasync_ctx->async_data.pa_base.u.a64.address + (unsigned long long )(p->defpdu_data_sz * num_per_mem);
#line 3137
    num_per_mem = num_per_mem + 1U;
#line 3138
    num_async_data = num_async_data - 1U;
#line 3140
    list_add_tail(& pasync_data_h->link, & pasync_ctx->async_data.free_list);
#line 3143
    pasync_data_h = pasync_data_h + 1;
#line 3144
    pasync_ctx->async_data.free_entries = pasync_ctx->async_data.free_entries + 1U;
#line 3145
    pasync_ctx->async_data.writables = pasync_ctx->async_data.writables + 1U;
#line 3147
    INIT_LIST_HEAD(& (pasync_ctx->async_entry + (unsigned long )index)->data_busy_list);
#line 3084
    index = index + 1U;
    }
    ldv_57704: ;
#line 3083
    if (index < phba->fw_config.iscsi_cid_count[(int )ulp_num]) {
#line 3085
      goto ldv_57703;
    } else {

    }
#line 3151
    pasync_ctx->async_header.host_write_ptr = 0U;
#line 3152
    pasync_ctx->async_header.ep_read_ptr = 4294967295U;
#line 3153
    pasync_ctx->async_data.host_write_ptr = 0U;
#line 3154
    pasync_ctx->async_data.ep_read_ptr = 4294967295U;
  } else {

  }
#line 2929
  ulp_num = (uint8_t )((int )ulp_num + 1);
  ldv_57707: ;
#line 2929
  if ((unsigned int )ulp_num <= 1U) {
#line 2931
    goto ldv_57706;
  } else {

  }

#line 3158
  return (0);
}
}
#line 3162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int be_sgl_create_contiguous(void *virtual_address , u64 physical_address ,
                                    u32 length , struct be_dma_mem *sgl ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int __ret_warn_on___1 ;
  long tmp___1 ;
  int __ret_warn_on___2 ;
  long tmp___2 ;

  {
  {
#line 3166
  __ret_warn_on = (unsigned long )virtual_address == (unsigned long )((void *)0);
#line 3166
  tmp = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 3166
  if (tmp != 0L) {
    {
#line 3166
    warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 3166);
    }
  } else {

  }
  {
#line 3166
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 3167
  __ret_warn_on___0 = physical_address == 0ULL;
#line 3167
  tmp___0 = __builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
#line 3167
  if (tmp___0 != 0L) {
    {
#line 3167
    warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 3167);
    }
  } else {

  }
  {
#line 3167
  __builtin_expect(__ret_warn_on___0 != 0, 0L);
#line 3168
  __ret_warn_on___1 = length == 0U;
#line 3168
  tmp___1 = __builtin_expect(__ret_warn_on___1 != 0, 0L);
  }
#line 3168
  if (tmp___1 != 0L) {
    {
#line 3168
    warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 3168);
    }
  } else {

  }
  {
#line 3168
  __builtin_expect(__ret_warn_on___1 != 0, 0L);
#line 3169
  __ret_warn_on___2 = (unsigned long )sgl == (unsigned long )((struct be_dma_mem *)0);
#line 3169
  tmp___2 = __builtin_expect(__ret_warn_on___2 != 0, 0L);
  }
#line 3169
  if (tmp___2 != 0L) {
    {
#line 3169
    warn_slowpath_null("drivers/scsi/be2iscsi/be_main.c", 3169);
    }
  } else {

  }
  {
#line 3169
  __builtin_expect(__ret_warn_on___2 != 0, 0L);
#line 3171
  sgl->va = virtual_address;
#line 3172
  sgl->dma = physical_address;
#line 3173
  sgl->size = length;
  }
#line 3175
  return (0);
}
}
#line 3178 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_sgl_destroy_contiguous(struct be_dma_mem *sgl ) 
{ 


  {
  {
#line 3180
  __memset((void *)sgl, 0, 24UL);
  }
#line 3181
  return;
}
}
#line 3184 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_build_be_sgl_arr(struct beiscsi_hba *phba , struct mem_array *pmem ,
                                 struct be_dma_mem *sgl ) 
{ 


  {
#line 3187
  if ((unsigned long )sgl->va != (unsigned long )((void *)0)) {
    {
#line 3188
    be_sgl_destroy_contiguous(sgl);
    }
  } else {

  }
  {
#line 3190
  be_sgl_create_contiguous(pmem->virtual_address, pmem->bus_address.u.a64.address,
                           pmem->size, sgl);
  }
#line 3193
  return;
}
}
#line 3196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_build_be_sgl_by_offset(struct beiscsi_hba *phba , struct mem_array *pmem ,
                                       struct be_dma_mem *sgl ) 
{ 


  {
#line 3199
  if ((unsigned long )sgl->va != (unsigned long )((void *)0)) {
    {
#line 3200
    be_sgl_destroy_contiguous(sgl);
    }
  } else {

  }
  {
#line 3202
  be_sgl_create_contiguous(pmem->virtual_address, pmem->bus_address.u.a64.address,
                           pmem->size, sgl);
  }
#line 3205
  return;
}
}
#line 3207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int be_fill_queue(struct be_queue_info *q , u16 len , u16 entry_size , void *vaddress ) 
{ 
  struct be_dma_mem *mem ;

  {
  {
#line 3210
  mem = & q->dma_mem;
#line 3212
  __memset((void *)q, 0, 40UL);
#line 3213
  q->len = len;
#line 3214
  q->entry_size = entry_size;
#line 3215
  mem->size = (u32 )((int )len * (int )entry_size);
#line 3216
  mem->va = vaddress;
  }
#line 3217
  if ((unsigned long )mem->va == (unsigned long )((void *)0)) {
#line 3218
    return (-12);
  } else {

  }
  {
#line 3219
  __memset(mem->va, 0, (size_t )mem->size);
  }
#line 3220
  return (0);
}
}
#line 3223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_eqs(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ) 
{ 
  unsigned int i ;
  unsigned int num_eq_pages ;
  int ret ;
  int eq_for_mcc ;
  struct be_queue_info *eq ;
  struct be_dma_mem *mem ;
  void *eq_vaddress ;
  dma_addr_t paddr ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 3227
  ret = 0;
#line 3233
  num_eq_pages = (unsigned long )phba->params.num_eq_entries * 4UL > 4095UL ? (unsigned int )((((unsigned long )phba->params.num_eq_entries + 1024UL) * 4UL - 1UL) / 4096UL) : 1U;
#line 3236
  if ((int )phba->msix_enabled) {
#line 3237
    eq_for_mcc = 1;
  } else {
#line 3239
    eq_for_mcc = 0;
  }
#line 3240
  i = 0U;
#line 3240
  goto ldv_57760;
  ldv_57759: 
  {
#line 3241
  eq = & phwi_context->be_eq[i].q;
#line 3242
  mem = & eq->dma_mem;
#line 3243
  phwi_context->be_eq[i].phba = phba;
#line 3244
  eq_vaddress = pci_alloc_consistent(phba->pcidev, (unsigned long )num_eq_pages * 4096UL,
                                     & paddr);
  }
#line 3247
  if ((unsigned long )eq_vaddress == (unsigned long )((void *)0)) {
#line 3248
    goto create_eq_error;
  } else {

  }
  {
#line 3250
  mem->va = eq_vaddress;
#line 3251
  ret = be_fill_queue(eq, (int )((u16 )phba->params.num_eq_entries), 4, eq_vaddress);
  }
#line 3253
  if (ret != 0) {
#line 3254
    log_value = phba->attr_log_enable;
#line 3254
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3254
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_fill_queue Failed for EQ\n",
                 3255);
      }
    } else {

    }
#line 3256
    goto create_eq_error;
  } else {

  }
  {
#line 3259
  mem->dma = paddr;
#line 3260
  ret = beiscsi_cmd_eq_create(& phba->ctrl, eq, (int )phwi_context->cur_eqd);
  }
#line 3262
  if (ret != 0) {
#line 3263
    log_value___0 = phba->attr_log_enable;
#line 3263
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3263
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_cmd_eq_createFailed for EQ\n",
                 3265);
      }
    } else {

    }
#line 3266
    goto create_eq_error;
  } else {

  }
#line 3269
  log_value___1 = phba->attr_log_enable;
#line 3269
  if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 3269
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : eqid = %d\n",
               3271, (int )phwi_context->be_eq[i].q.id);
    }
  } else {

  }
#line 3240
  i = i + 1U;
  ldv_57760: ;
#line 3240
  if (i < phba->num_cpus + (unsigned int )eq_for_mcc) {
#line 3242
    goto ldv_57759;
  } else {

  }

#line 3273
  return (0);
  create_eq_error: 
#line 3275
  i = 0U;
#line 3275
  goto ldv_57763;
  ldv_57762: 
#line 3276
  eq = & phwi_context->be_eq[i].q;
#line 3277
  mem = & eq->dma_mem;
#line 3278
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
    {
#line 3279
    pci_free_consistent(phba->pcidev, (unsigned long )num_eq_pages * 4096UL, mem->va,
                        mem->dma);
    }
  } else {

  }
#line 3275
  i = i + 1U;
  ldv_57763: ;
#line 3275
  if (i < phba->num_cpus + (unsigned int )eq_for_mcc) {
#line 3277
    goto ldv_57762;
  } else {

  }

#line 3283
  return (ret);
}
}
#line 3286 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_cqs(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ) 
{ 
  unsigned int i ;
  unsigned int num_cq_pages ;
  int ret ;
  struct be_queue_info *cq ;
  struct be_queue_info *eq ;
  struct be_dma_mem *mem ;
  struct be_eq_obj *pbe_eq ;
  void *cq_vaddress ;
  dma_addr_t paddr ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 3290
  ret = 0;
#line 3297
  num_cq_pages = (unsigned long )phba->params.num_cq_entries * 16UL > 4095UL ? (unsigned int )((((unsigned long )phba->params.num_cq_entries + 256UL) * 16UL - 1UL) / 4096UL) : 1U;
#line 3300
  i = 0U;
#line 3300
  goto ldv_57783;
  ldv_57782: 
  {
#line 3301
  cq = (struct be_queue_info *)(& phwi_context->be_cq) + (unsigned long )i;
#line 3302
  eq = & phwi_context->be_eq[i].q;
#line 3303
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 3304
  pbe_eq->cq = cq;
#line 3305
  pbe_eq->phba = phba;
#line 3306
  mem = & cq->dma_mem;
#line 3307
  cq_vaddress = pci_alloc_consistent(phba->pcidev, (unsigned long )num_cq_pages * 4096UL,
                                     & paddr);
  }
#line 3310
  if ((unsigned long )cq_vaddress == (unsigned long )((void *)0)) {
#line 3311
    goto create_cq_error;
  } else {

  }
  {
#line 3312
  ret = be_fill_queue(cq, (int )((u16 )phba->params.num_cq_entries), 16, cq_vaddress);
  }
#line 3314
  if (ret != 0) {
#line 3315
    log_value = phba->attr_log_enable;
#line 3315
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3315
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_fill_queue Failed for ISCSI CQ\n",
                 3317);
      }
    } else {

    }
#line 3318
    goto create_cq_error;
  } else {

  }
  {
#line 3321
  mem->dma = paddr;
#line 3322
  ret = beiscsi_cmd_cq_create(& phba->ctrl, cq, eq, 0, 0, 0);
  }
#line 3324
  if (ret != 0) {
#line 3325
    log_value___0 = phba->attr_log_enable;
#line 3325
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3325
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_cmd_eq_createFailed for ISCSI CQ\n",
                 3327);
      }
    } else {

    }
#line 3328
    goto create_cq_error;
  } else {

  }
#line 3330
  log_value___1 = phba->attr_log_enable;
#line 3330
  if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 3330
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : iscsi cq_id is %d for eq_id %d\niSCSI CQ CREATED\n",
               3332, (int )cq->id, (int )eq->id);
    }
  } else {

  }
#line 3300
  i = i + 1U;
  ldv_57783: ;
#line 3300
  if (i < phba->num_cpus) {
#line 3302
    goto ldv_57782;
  } else {

  }

#line 3334
  return (0);
  create_cq_error: 
#line 3337
  i = 0U;
#line 3337
  goto ldv_57786;
  ldv_57785: 
#line 3338
  cq = (struct be_queue_info *)(& phwi_context->be_cq) + (unsigned long )i;
#line 3339
  mem = & cq->dma_mem;
#line 3340
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
    {
#line 3341
    pci_free_consistent(phba->pcidev, (unsigned long )num_cq_pages * 4096UL, mem->va,
                        mem->dma);
    }
  } else {

  }
#line 3337
  i = i + 1U;
  ldv_57786: ;
#line 3337
  if (i < phba->num_cpus) {
#line 3339
    goto ldv_57785;
  } else {

  }

#line 3345
  return (ret);
}
}
#line 3350 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_def_hdr(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ,
                                  struct hwi_controller *phwi_ctrlr , unsigned int def_pdu_ring_sz ,
                                  uint8_t ulp_num ) 
{ 
  unsigned int idx ;
  int ret ;
  struct be_queue_info *dq ;
  struct be_queue_info *cq ;
  struct be_dma_mem *mem ;
  struct be_mem_descriptor *mem_descr ;
  void *dq_vaddress ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
  {
#line 3362
  idx = 0U;
#line 3363
  dq = (struct be_queue_info *)(& phwi_context->be_def_hdrq) + (unsigned long )ulp_num;
#line 3364
  cq = (struct be_queue_info *)(& phwi_context->be_cq);
#line 3365
  mem = & dq->dma_mem;
#line 3366
  mem_descr = phba->init_mem;
#line 3367
  mem_descr = mem_descr + (unsigned long )(((int )ulp_num + 1) * 8);
#line 3369
  dq_vaddress = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3370
  ret = be_fill_queue(dq, (int )((u16 )((mem_descr->mem_array)->size / 8U)), 8, dq_vaddress);
  }
#line 3373
  if (ret != 0) {
#line 3374
    log_value = phba->attr_log_enable;
#line 3374
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3374
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_fill_queue Failed for DEF PDU HDR on ULP : %d\n",
                 3376, (int )ulp_num);
      }
    } else {

    }
#line 3378
    return (ret);
  } else {

  }
  {
#line 3380
  mem->dma = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3382
  ret = be_cmd_create_default_pdu_queue(& phba->ctrl, cq, dq, (int )def_pdu_ring_sz,
                                        (int )phba->params.defpdu_hdr_sz, 1, (int )ulp_num);
  }
#line 3386
  if (ret != 0) {
#line 3387
    log_value___0 = phba->attr_log_enable;
#line 3387
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3387
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_cmd_create_default_pdu_queue Failed DEFHDR on ULP : %d\n",
                 3389, (int )ulp_num);
      }
    } else {

    }
#line 3391
    return (ret);
  } else {

  }
#line 3394
  log_value___1 = phba->attr_log_enable;
#line 3394
  if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 3394
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : iscsi hdr def pdu id for ULP : %d is %d\n",
               3397, (int )ulp_num, (int )phwi_context->be_def_hdrq[(int )ulp_num].id);
    }
  } else {

  }
  {
#line 3398
  hwi_post_async_buffers(phba, 1U, (int )ulp_num);
  }
#line 3399
  return (0);
}
}
#line 3403 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_def_data(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ,
                                   struct hwi_controller *phwi_ctrlr , unsigned int def_pdu_ring_sz ,
                                   uint8_t ulp_num ) 
{ 
  unsigned int idx ;
  int ret ;
  struct be_queue_info *dataq ;
  struct be_queue_info *cq ;
  struct be_dma_mem *mem ;
  struct be_mem_descriptor *mem_descr ;
  void *dq_vaddress ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
  {
#line 3415
  idx = 0U;
#line 3416
  dataq = (struct be_queue_info *)(& phwi_context->be_def_dataq) + (unsigned long )ulp_num;
#line 3417
  cq = (struct be_queue_info *)(& phwi_context->be_cq);
#line 3418
  mem = & dataq->dma_mem;
#line 3419
  mem_descr = phba->init_mem;
#line 3420
  mem_descr = mem_descr + (unsigned long )((int )ulp_num * 8 + 9);
#line 3422
  dq_vaddress = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3423
  ret = be_fill_queue(dataq, (int )((u16 )((mem_descr->mem_array)->size / 8U)), 8,
                      dq_vaddress);
  }
#line 3426
  if (ret != 0) {
#line 3427
    log_value = phba->attr_log_enable;
#line 3427
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3427
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : be_fill_queue Failed for DEF PDU DATA on ULP : %d\n",
                 3430, (int )ulp_num);
      }
    } else {

    }
#line 3432
    return (ret);
  } else {

  }
  {
#line 3434
  mem->dma = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3436
  ret = be_cmd_create_default_pdu_queue(& phba->ctrl, cq, dataq, (int )def_pdu_ring_sz,
                                        (int )phba->params.defpdu_data_sz, 0, (int )ulp_num);
  }
#line 3440
  if (ret != 0) {
#line 3441
    log_value___0 = phba->attr_log_enable;
#line 3441
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3441
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d be_cmd_create_default_pdu_queue Failed for DEF PDU DATA on ULP : %d\n",
                 3444, (int )ulp_num);
      }
    } else {

    }
#line 3445
    return (ret);
  } else {

  }
#line 3448
  log_value___1 = phba->attr_log_enable;
#line 3448
  if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 3448
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : iscsi def data id on ULP : %d is  %d\n",
               3451, (int )ulp_num, (int )phwi_context->be_def_dataq[(int )ulp_num].id);
    }
  } else {

  }
  {
#line 3453
  hwi_post_async_buffers(phba, 0U, (int )ulp_num);
#line 3454
  log_value___2 = phba->attr_log_enable;
  }
#line 3454
  if ((int )log_value___2 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 3454
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : DEFAULT PDU DATA RING CREATEDon ULP : %d\n",
               3456, (int )ulp_num);
    }
  } else {

  }
#line 3458
  return (0);
}
}
#line 3463 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_post_template_hdr(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr ;
  struct mem_array *pm_arr ;
  struct be_dma_mem sgl ;
  int status ;
  int ulp_num ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___0 ;

  {
#line 3470
  ulp_num = 0;
#line 3470
  goto ldv_57834;
  ldv_57833: 
  {
#line 3471
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 3471
  if (tmp___0 != 0) {
    {
#line 3472
    mem_descr = phba->init_mem;
#line 3473
    mem_descr = mem_descr + (unsigned long )(ulp_num * 8 + 5);
#line 3475
    pm_arr = mem_descr->mem_array;
#line 3477
    hwi_build_be_sgl_arr(phba, pm_arr, & sgl);
#line 3478
    status = be_cmd_iscsi_post_template_hdr(& phba->ctrl, & sgl);
    }
#line 3481
    if (status != 0) {
#line 3482
      log_value = phba->attr_log_enable;
#line 3482
      if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 3482
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Post Template HDR Failed forULP_%d\n", 3484, ulp_num);
        }
      } else {

      }
#line 3485
      return (status);
    } else {

    }
#line 3488
    log_value___0 = phba->attr_log_enable;
#line 3488
    if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 3488
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : Template HDR Pages Posted forULP_%d\n", 3490, ulp_num);
      }
    } else {

    }
  } else {

  }
#line 3470
  ulp_num = ulp_num + 1;
  ldv_57834: ;
#line 3470
  if (ulp_num <= 1) {
#line 3472
    goto ldv_57833;
  } else {

  }

#line 3493
  return (0);
}
}
#line 3497 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_post_pages(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr ;
  struct mem_array *pm_arr ;
  unsigned int page_offset___0 ;
  unsigned int i ;
  struct be_dma_mem sgl ;
  int status ;
  int ulp_num ;
  int tmp___0 ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 3503
  ulp_num = 0;
#line 3505
  mem_descr = phba->init_mem;
#line 3506
  mem_descr = mem_descr + 4UL;
#line 3507
  pm_arr = mem_descr->mem_array;
#line 3509
  ulp_num = 0;
#line 3509
  goto ldv_57848;
  ldv_57847: 
  {
#line 3510
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 3510
  if (tmp___0 != 0) {
#line 3511
    goto ldv_57846;
  } else {

  }
#line 3509
  ulp_num = ulp_num + 1;
  ldv_57848: ;
#line 3509
  if (ulp_num <= 1) {
#line 3511
    goto ldv_57847;
  } else {

  }
  ldv_57846: 
#line 3513
  page_offset___0 = (unsigned int )((((unsigned long )phba->params.num_sge_per_io * (unsigned long )phba->fw_config.iscsi_icd_start[ulp_num]) * 16UL) / 4096UL);
#line 3515
  i = 0U;
#line 3515
  goto ldv_57851;
  ldv_57850: 
  {
#line 3516
  hwi_build_be_sgl_arr(phba, pm_arr, & sgl);
#line 3517
  status = be_cmd_iscsi_post_sgl_pages(& phba->ctrl, & sgl, page_offset___0, pm_arr->size / 4096U);
#line 3520
  page_offset___0 = page_offset___0 + pm_arr->size / 4096U;
  }
#line 3521
  if (status != 0) {
#line 3522
    log_value = phba->attr_log_enable;
#line 3522
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3522
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : post sgl failed.\n",
                 3523);
      }
    } else {

    }
#line 3524
    return (status);
  } else {

  }
#line 3526
  pm_arr = pm_arr + 1;
#line 3515
  i = i + 1U;
  ldv_57851: ;
#line 3515
  if (i < mem_descr->num_elements) {
#line 3517
    goto ldv_57850;
  } else {

  }
#line 3528
  log_value___0 = phba->attr_log_enable;
#line 3528
  if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 3528
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : POSTED PAGES\n",
               3529);
    }
  } else {

  }
#line 3530
  return (0);
}
}
#line 3533 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_queue_free(struct beiscsi_hba *phba , struct be_queue_info *q ) 
{ 
  struct be_dma_mem *mem ;

  {
#line 3535
  mem = & q->dma_mem;
#line 3536
  if ((unsigned long )mem->va != (unsigned long )((void *)0)) {
    {
#line 3537
    pci_free_consistent(phba->pcidev, (size_t )mem->size, mem->va, mem->dma);
#line 3539
    mem->va = (void *)0;
    }
  } else {

  }
#line 3541
  return;
}
}
#line 3543 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int be_queue_alloc(struct beiscsi_hba *phba , struct be_queue_info *q , u16 len ,
                          u16 entry_size ) 
{ 
  struct be_dma_mem *mem ;

  {
  {
#line 3546
  mem = & q->dma_mem;
#line 3548
  __memset((void *)q, 0, 40UL);
#line 3549
  q->len = len;
#line 3550
  q->entry_size = entry_size;
#line 3551
  mem->size = (u32 )((int )len * (int )entry_size);
#line 3552
  mem->va = pci_zalloc_consistent(phba->pcidev, (size_t )mem->size, & mem->dma);
  }
#line 3553
  if ((unsigned long )mem->va == (unsigned long )((void *)0)) {
#line 3554
    return (-12);
  } else {

  }
#line 3555
  return (0);
}
}
#line 3559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_create_wrb_rings(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ,
                                    struct hwi_controller *phwi_ctrlr ) 
{ 
  unsigned int wrb_mem_index ;
  unsigned int offset ;
  unsigned int size ;
  unsigned int num_wrb_rings ;
  u64 pa_addr_lo ;
  unsigned int idx ;
  unsigned int num ;
  unsigned int i ;
  unsigned int ulp_num ;
  struct mem_array *pwrb_arr ;
  void *wrb_vaddr ;
  struct be_dma_mem sgl ;
  struct be_mem_descriptor *mem_descr ;
  struct hwi_wrb_context *pwrb_context ;
  int status ;
  uint8_t ulp_count ;
  uint8_t ulp_base_num ;
  uint16_t cid_count_ulp[2U] ;
  unsigned int tmp ;
  void *tmp___0 ;
  uint32_t log_value ;
  int tmp___2 ;
  uint32_t log_value___0 ;

  {
#line 3572
  ulp_count = 0U;
#line 3572
  ulp_base_num = 0U;
#line 3573
  cid_count_ulp[0] = 0U;
#line 3573
  tmp = 1U;
  {
#line 3573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3573
    if (tmp >= 2U) {
#line 3573
      goto while_break;
    } else {

    }
#line 3573
    cid_count_ulp[tmp] = (unsigned short)0;
#line 3573
    tmp = tmp + 1U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3575
  idx = 0U;
#line 3576
  mem_descr = phba->init_mem;
#line 3577
  mem_descr = mem_descr + 1UL;
#line 3578
  tmp___0 = kmalloc((unsigned long )phba->params.cxns_per_ctrl * 24UL, 208U);
#line 3578
  pwrb_arr = (struct mem_array *)tmp___0;
  }
#line 3580
  if ((unsigned long )pwrb_arr == (unsigned long )((struct mem_array *)0)) {
#line 3581
    log_value = phba->attr_log_enable;
#line 3581
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3581
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Memory alloc failed in create wrb ring.\n",
                 3582);
      }
    } else {

    }
#line 3583
    return (-12);
  } else {

  }
#line 3585
  wrb_vaddr = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3586
  pa_addr_lo = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3587
  num_wrb_rings = (unsigned int )((unsigned long )(mem_descr->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.wrbs_per_cxn * 64UL));
#line 3590
  num = 0U;
#line 3590
  goto ldv_57891;
  ldv_57890: ;
#line 3591
  if (num_wrb_rings != 0U) {
#line 3592
    (pwrb_arr + (unsigned long )num)->virtual_address = wrb_vaddr;
#line 3593
    (pwrb_arr + (unsigned long )num)->bus_address.u.a64.address = pa_addr_lo;
#line 3594
    (pwrb_arr + (unsigned long )num)->size = phba->params.wrbs_per_cxn * 64U;
#line 3596
    wrb_vaddr = wrb_vaddr + (unsigned long )(pwrb_arr + (unsigned long )num)->size;
#line 3597
    pa_addr_lo = pa_addr_lo + (u64 )(pwrb_arr + (unsigned long )num)->size;
#line 3598
    num_wrb_rings = num_wrb_rings - 1U;
  } else {
#line 3600
    idx = idx + 1U;
#line 3601
    wrb_vaddr = (mem_descr->mem_array + (unsigned long )idx)->virtual_address;
#line 3602
    pa_addr_lo = (mem_descr->mem_array + (unsigned long )idx)->bus_address.u.a64.address;
#line 3604
    num_wrb_rings = (unsigned int )((unsigned long )(mem_descr->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.wrbs_per_cxn * 64UL));
#line 3607
    (pwrb_arr + (unsigned long )num)->virtual_address = wrb_vaddr;
#line 3608
    (pwrb_arr + (unsigned long )num)->bus_address.u.a64.address = pa_addr_lo;
#line 3610
    (pwrb_arr + (unsigned long )num)->size = phba->params.wrbs_per_cxn * 64U;
#line 3612
    wrb_vaddr = wrb_vaddr + (unsigned long )(pwrb_arr + (unsigned long )num)->size;
#line 3613
    pa_addr_lo = pa_addr_lo + (u64 )(pwrb_arr + (unsigned long )num)->size;
#line 3614
    num_wrb_rings = num_wrb_rings - 1U;
  }
#line 3590
  num = num + 1U;
  ldv_57891: ;
#line 3590
  if (num < phba->params.cxns_per_ctrl) {
#line 3592
    goto ldv_57890;
  } else {

  }
#line 3619
  ulp_num = 0U;
#line 3619
  goto ldv_57894;
  ldv_57893: 
  {
#line 3620
  tmp___2 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 3620
  if (tmp___2 != 0) {
#line 3621
    ulp_count = (uint8_t )((int )ulp_count + 1);
#line 3622
    ulp_base_num = (uint8_t )ulp_num;
#line 3623
    cid_count_ulp[ulp_num] = (uint16_t )phba->fw_config.iscsi_cid_count[ulp_num];
  } else {

  }
#line 3619
  ulp_num = ulp_num + 1U;
  ldv_57894: ;
#line 3619
  if (ulp_num <= 1U) {
#line 3621
    goto ldv_57893;
  } else {

  }
#line 3627
  i = 0U;
#line 3627
  goto ldv_57898;
  ldv_57897: 
#line 3628
  wrb_mem_index = 0U;
#line 3629
  offset = 0U;
#line 3630
  size = 0U;
#line 3632
  if ((unsigned int )ulp_count > 1U) {
#line 3633
    ulp_base_num = (uint8_t )(((int )ulp_base_num + 1) % 2);
#line 3635
    if ((unsigned int )cid_count_ulp[(int )ulp_base_num] == 0U) {
#line 3636
      ulp_base_num = (uint8_t )(((int )ulp_base_num + 1) % 2);
    } else {

    }
#line 3639
    cid_count_ulp[(int )ulp_base_num] = (uint16_t )((int )cid_count_ulp[(int )ulp_base_num] - 1);
  } else {

  }
  {
#line 3643
  hwi_build_be_sgl_by_offset(phba, pwrb_arr + (unsigned long )i, & sgl);
#line 3644
  status = be_cmd_wrbq_create(& phba->ctrl, & sgl, phwi_context->be_wrbq + (unsigned long )i,
                              phwi_ctrlr->wrb_context + (unsigned long )i, (int )ulp_base_num);
  }
#line 3648
  if (status != 0) {
#line 3649
    log_value___0 = phba->attr_log_enable;
#line 3649
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3649
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : wrbq create failed.",
                 3650);
      }
    } else {

    }
    {
#line 3651
    kfree((void const   *)pwrb_arr);
    }
#line 3652
    return (status);
  } else {

  }
#line 3654
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )i;
#line 3655
  phba->cid_to_cri_map[(int )pwrb_context->cid] = (unsigned short )i;
#line 3627
  i = i + 1U;
  ldv_57898: ;
#line 3627
  if (i < phba->params.cxns_per_ctrl) {
#line 3629
    goto ldv_57897;
  } else {

  }
  {
#line 3657
  kfree((void const   *)pwrb_arr);
  }
#line 3658
  return (0);
}
}
#line 3661 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void free_wrb_handles(struct beiscsi_hba *phba ) 
{ 
  unsigned int index ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_wrb_context *pwrb_context ;

  {
#line 3667
  phwi_ctrlr = phba->phwi_ctrlr;
#line 3668
  index = 0U;
#line 3668
  goto ldv_57907;
  ldv_57906: 
  {
#line 3669
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )index;
#line 3670
  kfree((void const   *)pwrb_context->pwrb_handle_base);
#line 3671
  kfree((void const   *)pwrb_context->pwrb_handle_basestd);
#line 3668
  index = index + 1U;
  }
  ldv_57907: ;
#line 3668
  if (index < phba->params.cxns_per_ctrl) {
#line 3670
    goto ldv_57906;
  } else {

  }

#line 3675
  return;
}
}
#line 3675 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_mcc_queues_destroy(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *q ;
  struct be_ctrl_info *ctrl ;

  {
#line 3678
  ctrl = & phba->ctrl;
#line 3680
  q = & phba->ctrl.mcc_obj.q;
#line 3681
  if ((int )q->created) {
    {
#line 3682
    beiscsi_cmd_q_destroy(ctrl, q, 3);
    }
  } else {

  }
  {
#line 3683
  be_queue_free(phba, q);
#line 3685
  q = & phba->ctrl.mcc_obj.cq;
  }
#line 3686
  if ((int )q->created) {
    {
#line 3687
    beiscsi_cmd_q_destroy(ctrl, q, 2);
    }
  } else {

  }
  {
#line 3688
  be_queue_free(phba, q);
  }
#line 3689
  return;
}
}
#line 3691 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_cleanup(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *q ;
  struct be_ctrl_info *ctrl ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct hwi_async_pdu_context *pasync_ctx ;
  int i ;
  int eq_for_mcc ;
  int ulp_num ;
  int tmp___0 ;

  {
  {
#line 3694
  ctrl = & phba->ctrl;
#line 3700
  phwi_ctrlr = phba->phwi_ctrlr;
#line 3701
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 3703
  be_cmd_iscsi_remove_template_hdr(ctrl);
#line 3705
  i = 0;
  }
#line 3705
  goto ldv_57926;
  ldv_57925: 
#line 3706
  q = phwi_context->be_wrbq + (unsigned long )i;
#line 3707
  if ((int )q->created) {
    {
#line 3708
    beiscsi_cmd_q_destroy(ctrl, q, 4);
    }
  } else {

  }
#line 3705
  i = i + 1;
  ldv_57926: ;
#line 3705
  if ((unsigned int )i < phba->params.cxns_per_ctrl) {
#line 3707
    goto ldv_57925;
  } else {

  }
  {
#line 3710
  kfree((void const   *)phwi_context->be_wrbq);
#line 3711
  free_wrb_handles(phba);
#line 3713
  ulp_num = 0;
  }
#line 3713
  goto ldv_57929;
  ldv_57928: 
  {
#line 3714
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 3714
  if (tmp___0 != 0) {
#line 3716
    q = (struct be_queue_info *)(& phwi_context->be_def_hdrq) + (unsigned long )ulp_num;
#line 3717
    if ((int )q->created) {
      {
#line 3718
      beiscsi_cmd_q_destroy(ctrl, q, 5);
      }
    } else {

    }
#line 3720
    q = (struct be_queue_info *)(& phwi_context->be_def_dataq) + (unsigned long )ulp_num;
#line 3721
    if ((int )q->created) {
      {
#line 3722
      beiscsi_cmd_q_destroy(ctrl, q, 5);
      }
    } else {

    }
#line 3724
    pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[ulp_num];
  } else {

  }
#line 3713
  ulp_num = ulp_num + 1;
  ldv_57929: ;
#line 3713
  if (ulp_num <= 1) {
#line 3715
    goto ldv_57928;
  } else {

  }
  {
#line 3728
  beiscsi_cmd_q_destroy(ctrl, (struct be_queue_info *)0, 6);
#line 3730
  i = 0;
  }
#line 3730
  goto ldv_57932;
  ldv_57931: 
#line 3731
  q = (struct be_queue_info *)(& phwi_context->be_cq) + (unsigned long )i;
#line 3732
  if ((int )q->created) {
    {
#line 3733
    beiscsi_cmd_q_destroy(ctrl, q, 2);
    }
  } else {

  }
#line 3730
  i = i + 1;
  ldv_57932: ;
#line 3730
  if ((unsigned int )i < phba->num_cpus) {
#line 3732
    goto ldv_57931;
  } else {

  }
  {
#line 3736
  be_mcc_queues_destroy(phba);
  }
#line 3737
  if ((int )phba->msix_enabled) {
#line 3738
    eq_for_mcc = 1;
  } else {
#line 3740
    eq_for_mcc = 0;
  }
#line 3741
  i = 0;
#line 3741
  goto ldv_57935;
  ldv_57934: 
#line 3742
  q = & phwi_context->be_eq[i].q;
#line 3743
  if ((int )q->created) {
    {
#line 3744
    beiscsi_cmd_q_destroy(ctrl, q, 1);
    }
  } else {

  }
#line 3741
  i = i + 1;
  ldv_57935: ;
#line 3741
  if ((unsigned int )i < phba->num_cpus + (unsigned int )eq_for_mcc) {
#line 3743
    goto ldv_57934;
  } else {

  }
  {
#line 3746
  be_cmd_fw_uninit(ctrl);
  }
#line 3747
  return;
}
}
#line 3749 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int be_mcc_queues_create(struct beiscsi_hba *phba , struct hwi_context_memory *phwi_context ) 
{ 
  struct be_queue_info *q ;
  struct be_queue_info *cq ;
  struct be_ctrl_info *ctrl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 3753
  ctrl = & phba->ctrl;
#line 3756
  cq = & phba->ctrl.mcc_obj.cq;
#line 3757
  tmp = be_queue_alloc(phba, cq, 256, 16);
  }
#line 3757
  if (tmp != 0) {
#line 3759
    goto err;
  } else {

  }
#line 3761
  if ((int )phba->msix_enabled) {
    {
#line 3762
    tmp___0 = beiscsi_cmd_cq_create(ctrl, cq, & phwi_context->be_eq[phba->num_cpus].q,
                                    0, 1, 0);
    }
#line 3762
    if (tmp___0 != 0) {
#line 3764
      goto mcc_cq_free;
    } else {

    }
  } else {
    {
#line 3766
    tmp___1 = beiscsi_cmd_cq_create(ctrl, cq, & phwi_context->be_eq[0].q, 0, 1, 0);
    }
#line 3766
    if (tmp___1 != 0) {
#line 3768
      goto mcc_cq_free;
    } else {

    }
  }
  {
#line 3772
  q = & phba->ctrl.mcc_obj.q;
#line 3773
  tmp___2 = be_queue_alloc(phba, q, 128, 256);
  }
#line 3773
  if (tmp___2 != 0) {
#line 3774
    goto mcc_cq_destroy;
  } else {

  }
  {
#line 3777
  tmp___3 = beiscsi_cmd_mccq_create(phba, q, cq);
  }
#line 3777
  if (tmp___3 != 0) {
#line 3778
    goto mcc_q_free;
  } else {

  }
#line 3780
  return (0);
  mcc_q_free: 
  {
#line 3783
  be_queue_free(phba, q);
  }
  mcc_cq_destroy: 
  {
#line 3785
  beiscsi_cmd_q_destroy(ctrl, cq, 2);
  }
  mcc_cq_free: 
  {
#line 3787
  be_queue_free(phba, cq);
  }
  err: ;
#line 3789
  return (-12);
}
}
#line 3798 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void find_num_cpus(struct beiscsi_hba *phba ) 
{ 
  int num_cpus ;
  unsigned int tmp ;

  {
  {
#line 3800
  num_cpus = 0;
#line 3802
  tmp = cpumask_weight(cpu_online_mask);
#line 3802
  num_cpus = (int )tmp;
  }
  {
#line 3805
  if (phba->generation == 2U) {
#line 3805
    goto case_2;
  } else {

  }
#line 3806
  if (phba->generation == 3U) {
#line 3806
    goto case_3;
  } else {

  }
#line 3810
  if (phba->generation == 4U) {
#line 3810
    goto case_4;
  } else {

  }
#line 3825
  goto switch_default;
  case_2: /* CIL Label */ ;
  case_3: /* CIL Label */ 
#line 3807
  phba->num_cpus = (unsigned int )(7 < num_cpus ? 7 : num_cpus);
#line 3809
  goto ldv_57954;
  case_4: /* CIL Label */ ;
#line 3815
  if (phba->fw_config.eqid_count == 1U) {
#line 3816
    enable_msix = 0U;
#line 3817
    phba->num_cpus = 1U;
#line 3818
    return;
  } else {

  }
#line 3821
  phba->num_cpus = phba->fw_config.eqid_count - 1U < (unsigned int )num_cpus ? phba->fw_config.eqid_count - 1U : (unsigned int )num_cpus;
#line 3824
  goto ldv_57954;
  switch_default: /* CIL Label */ 
#line 3826
  phba->num_cpus = 1U;
  switch_break: /* CIL Label */ ;
  }
  ldv_57954: ;
#line 3829
  return;
}
}
#line 3830 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int hwi_init_port(struct beiscsi_hba *phba ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  unsigned int def_pdu_ring_sz ;
  struct be_ctrl_info *ctrl ;
  int status ;
  int ulp_num ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  int tmp___0 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;
  uint32_t log_value___6 ;
  uint16_t async_arr_idx ;
  uint16_t cri ;
  struct hwi_async_pdu_context *pasync_ctx ;
  uint16_t tmp___1 ;
  int tmp___3 ;
  uint32_t log_value___7 ;
  uint32_t log_value___8 ;

  {
  {
#line 3835
  ctrl = & phba->ctrl;
#line 3838
  phwi_ctrlr = phba->phwi_ctrlr;
#line 3839
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 3840
  phwi_context->max_eqd = 128U;
#line 3841
  phwi_context->min_eqd = 0U;
#line 3842
  phwi_context->cur_eqd = 0U;
#line 3843
  be_cmd_fw_initialize(& phba->ctrl);
#line 3845
  status = beiscsi_create_eqs(phba, phwi_context);
  }
#line 3846
  if (status != 0) {
#line 3847
    log_value = phba->attr_log_enable;
#line 3847
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3847
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EQ not created\n",
                 3848);
      }
    } else {

    }
#line 3849
    goto error;
  } else {

  }
  {
#line 3852
  status = be_mcc_queues_create(phba, phwi_context);
  }
#line 3853
  if (status != 0) {
#line 3854
    goto error;
  } else {

  }
  {
#line 3856
  status = mgmt_check_supported_fw(ctrl, phba);
  }
#line 3857
  if (status != 0) {
#line 3858
    log_value___0 = phba->attr_log_enable;
#line 3858
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3858
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Unsupported fw version\n",
                 3859);
      }
    } else {

    }
#line 3860
    goto error;
  } else {

  }
  {
#line 3863
  status = beiscsi_create_cqs(phba, phwi_context);
  }
#line 3864
  if (status != 0) {
#line 3865
    log_value___1 = phba->attr_log_enable;
#line 3865
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3865
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : CQ not created\n",
                 3866);
      }
    } else {

    }
#line 3867
    goto error;
  } else {

  }
#line 3870
  ulp_num = 0;
#line 3870
  goto ldv_57973;
  ldv_57972: 
  {
#line 3871
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 3871
  if (tmp___0 != 0) {
    {
#line 3873
    def_pdu_ring_sz = phba->fw_config.iscsi_cid_count[ulp_num] * 8U;
#line 3877
    status = beiscsi_create_def_hdr(phba, phwi_context, phwi_ctrlr, def_pdu_ring_sz,
                                    (int )((uint8_t )ulp_num));
    }
#line 3881
    if (status != 0) {
#line 3882
      log_value___2 = phba->attr_log_enable;
#line 3882
      if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 3882
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Default Header not created for ULP : %d\n", 3884, ulp_num);
        }
      } else {

      }
#line 3885
      goto error;
    } else {

    }
    {
#line 3888
    status = beiscsi_create_def_data(phba, phwi_context, phwi_ctrlr, def_pdu_ring_sz,
                                     (int )((uint8_t )ulp_num));
    }
#line 3892
    if (status != 0) {
#line 3893
      log_value___3 = phba->attr_log_enable;
#line 3893
      if ((int )log_value___3 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 3893
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Default Data not created for ULP : %d\n", 3895, ulp_num);
        }
      } else {

      }
#line 3896
      goto error;
    } else {

    }
  } else {

  }
#line 3870
  ulp_num = ulp_num + 1;
  ldv_57973: ;
#line 3870
  if (ulp_num <= 1) {
#line 3872
    goto ldv_57972;
  } else {

  }
  {
#line 3901
  status = beiscsi_post_pages(phba);
  }
#line 3902
  if (status != 0) {
#line 3903
    log_value___4 = phba->attr_log_enable;
#line 3903
    if ((int )log_value___4 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3903
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Post SGL Pages Failed\n",
                 3904);
      }
    } else {

    }
#line 3905
    goto error;
  } else {

  }
  {
#line 3908
  status = beiscsi_post_template_hdr(phba);
  }
#line 3909
  if (status != 0) {
#line 3910
    log_value___5 = phba->attr_log_enable;
#line 3910
    if ((int )log_value___5 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3910
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Template HDR Posting for CXN Failed\n",
                 3911);
      }
    } else {

    }
  } else {

  }
  {
#line 3914
  status = beiscsi_create_wrb_rings(phba, phwi_context, phwi_ctrlr);
  }
#line 3915
  if (status != 0) {
#line 3916
    log_value___6 = phba->attr_log_enable;
#line 3916
    if ((int )log_value___6 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3916
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : WRB Rings not created\n",
                 3917);
      }
    } else {

    }
#line 3918
    goto error;
  } else {

  }
#line 3921
  ulp_num = 0;
#line 3921
  goto ldv_57985;
  ldv_57984: 
  {
#line 3922
  async_arr_idx = 0U;
#line 3924
  tmp___3 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 3924
  if (tmp___3 != 0) {
#line 3925
    cri = 0U;
#line 3928
    pasync_ctx = (phwi_ctrlr->phwi_ctxt)->pasync_ctx[ulp_num];
#line 3930
    cri = 0U;
#line 3930
    goto ldv_57982;
    ldv_57981: ;
#line 3932
    if (ulp_num == (int )(phwi_ctrlr->wrb_context + (unsigned long )cri)->ulp_num) {
#line 3934
      tmp___1 = async_arr_idx;
#line 3934
      async_arr_idx = (uint16_t )((int )async_arr_idx + 1);
#line 3934
      pasync_ctx->cid_to_async_cri_map[(int )(phwi_ctrlr->wrb_context + (unsigned long )cri)->cid] = tmp___1;
    } else {

    }
#line 3931
    cri = (uint16_t )((int )cri + 1);
    ldv_57982: ;
#line 3930
    if ((unsigned int )cri < phba->params.cxns_per_ctrl) {
#line 3933
      goto ldv_57981;
    } else {

    }

  } else {

  }
#line 3921
  ulp_num = ulp_num + 1;
  ldv_57985: ;
#line 3921
  if (ulp_num <= 1) {
#line 3923
    goto ldv_57984;
  } else {

  }
#line 3941
  log_value___7 = phba->attr_log_enable;
#line 3941
  if ((int )log_value___7 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 3941
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : hwi_init_port success\n",
               3942);
    }
  } else {

  }
#line 3943
  return (0);
  error: 
#line 3946
  log_value___8 = phba->attr_log_enable;
#line 3946
  if ((int )log_value___8 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 3946
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : hwi_init_port failed",
               3947);
    }
  } else {

  }
  {
#line 3948
  hwi_cleanup(phba);
  }
#line 3949
  return (status);
}
}
#line 3952 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int hwi_init_controller(struct beiscsi_hba *phba ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp ;
  uint32_t log_value___1 ;
  int tmp___0 ;
  uint32_t log_value___2 ;
  int tmp___1 ;

  {
#line 3956
  phwi_ctrlr = phba->phwi_ctrlr;
#line 3957
  if ((phba->init_mem)->num_elements == 1U) {
#line 3958
    phwi_ctrlr->phwi_ctxt = (struct hwi_context_memory *)((phba->init_mem)->mem_array)->virtual_address;
#line 3960
    log_value = phba->attr_log_enable;
#line 3960
    if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 3960
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d :  phwi_ctrlr->phwi_ctxt=%p\n", 3962, phwi_ctrlr->phwi_ctxt);
      }
    } else {

    }
  } else {
#line 3964
    log_value___0 = phba->attr_log_enable;
#line 3964
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3964
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : HWI_MEM_ADDN_CONTEXT is more than one element.Failing to load\n",
                 3966);
      }
    } else {

    }
#line 3967
    return (-12);
  }
  {
#line 3970
  iscsi_init_global_templates(phba);
#line 3971
  tmp = beiscsi_init_wrb_handle(phba);
  }
#line 3971
  if (tmp != 0) {
#line 3972
    return (-12);
  } else {

  }
  {
#line 3974
  tmp___0 = hwi_init_async_pdu_ctx(phba);
  }
#line 3974
  if (tmp___0 != 0) {
#line 3975
    log_value___1 = phba->attr_log_enable;
#line 3975
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3975
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : hwi_init_async_pdu_ctx failed\n",
                 3976);
      }
    } else {

    }
#line 3977
    return (-12);
  } else {

  }
  {
#line 3980
  tmp___1 = hwi_init_port(phba);
  }
#line 3980
  if (tmp___1 != 0) {
#line 3981
    log_value___2 = phba->attr_log_enable;
#line 3981
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 3981
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : hwi_init_controller failed\n",
                 3982);
      }
    } else {

    }
#line 3984
    return (-12);
  } else {

  }
#line 3986
  return (0);
}
}
#line 3989 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_free_mem(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr ;
  int i ;
  int j ;

  {
#line 3994
  mem_descr = phba->init_mem;
#line 3995
  i = 0;
#line 3996
  j = 0;
#line 3997
  i = 0;
#line 3997
  goto ldv_58007;
  ldv_58006: 
#line 3998
  j = (int )mem_descr->num_elements;
#line 3998
  goto ldv_58004;
  ldv_58003: 
  {
#line 3999
  pci_free_consistent(phba->pcidev, (size_t )(mem_descr->mem_array + ((unsigned long )j + 0xffffffffffffffffUL))->size,
                      (mem_descr->mem_array + ((unsigned long )j + 0xffffffffffffffffUL))->virtual_address,
                      (mem_descr->mem_array + ((unsigned long )j + 0xffffffffffffffffUL))->bus_address.u.a64.address);
#line 3998
  j = j - 1;
  }
  ldv_58004: ;
#line 3998
  if (j > 0) {
#line 4000
    goto ldv_58003;
  } else {

  }
  {
#line 4006
  kfree((void const   *)mem_descr->mem_array);
#line 4007
  mem_descr = mem_descr + 1;
#line 3997
  i = i + 1;
  }
  ldv_58007: ;
#line 3997
  if (i <= 21) {
#line 3999
    goto ldv_58006;
  } else {

  }
  {
#line 4009
  kfree((void const   *)phba->init_mem);
#line 4010
  kfree((void const   *)(phba->phwi_ctrlr)->wrb_context);
#line 4011
  kfree((void const   *)phba->phwi_ctrlr);
  }
#line 4012
  return;
}
}
#line 4014 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_controller(struct beiscsi_hba *phba ) 
{ 
  int ret ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
  {
#line 4016
  ret = -12;
#line 4018
  ret = beiscsi_get_memory(phba);
  }
#line 4019
  if (ret < 0) {
#line 4020
    log_value = phba->attr_log_enable;
#line 4020
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4020
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe -Failed in beiscsi_alloc_memory\n",
                 4022);
      }
    } else {

    }
#line 4023
    return (ret);
  } else {

  }
  {
#line 4026
  ret = hwi_init_controller(phba);
  }
#line 4027
  if (ret != 0) {
#line 4028
    goto free_init;
  } else {

  }
#line 4029
  log_value___0 = phba->attr_log_enable;
#line 4029
  if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 4029
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Return success from beiscsi_init_controller",
               4030);
    }
  } else {

  }
#line 4032
  return (0);
  free_init: 
  {
#line 4035
  beiscsi_free_mem(phba);
  }
#line 4036
  return (ret);
}
}
#line 4039 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_sgl_handle(struct beiscsi_hba *phba ) 
{ 
  struct be_mem_descriptor *mem_descr_sglh ;
  struct be_mem_descriptor *mem_descr_sg ;
  struct sgl_handle *psgl_handle ;
  struct iscsi_sge *pfrag ;
  unsigned int arr_index ;
  unsigned int i ;
  unsigned int idx ;
  unsigned int ulp_icd_start ;
  unsigned int ulp_num ;
  void *tmp ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  int tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 4045
  ulp_num = 0U;
#line 4047
  phba->io_sgl_hndl_avbl = 0U;
#line 4048
  phba->eh_sgl_hndl_avbl = 0U;
#line 4050
  mem_descr_sglh = phba->init_mem;
#line 4051
  mem_descr_sglh = mem_descr_sglh + 3UL;
#line 4052
  if (mem_descr_sglh->num_elements == 1U) {
    {
#line 4053
    tmp = kzalloc((unsigned long )phba->params.ios_per_ctrl * 8UL, 208U);
#line 4053
    phba->io_sgl_hndl_base = (struct sgl_handle **)tmp;
    }
#line 4056
    if ((unsigned long )phba->io_sgl_hndl_base == (unsigned long )((struct sgl_handle **)0)) {
#line 4057
      log_value = phba->attr_log_enable;
#line 4057
      if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 4057
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Mem Alloc Failed. Failing to load\n", 4058);
        }
      } else {

      }
#line 4059
      return (-12);
    } else {

    }
    {
#line 4061
    tmp___0 = kzalloc((unsigned long )(phba->params.icds_per_ctrl - phba->params.ios_per_ctrl) * 8UL,
                      208U);
#line 4061
    phba->eh_sgl_hndl_base = (struct sgl_handle **)tmp___0;
    }
#line 4065
    if ((unsigned long )phba->eh_sgl_hndl_base == (unsigned long )((struct sgl_handle **)0)) {
      {
#line 4066
      kfree((void const   *)phba->io_sgl_hndl_base);
#line 4067
      log_value___0 = phba->attr_log_enable;
      }
#line 4067
      if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 4067
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Mem Alloc Failed. Failing to load\n", 4068);
        }
      } else {

      }
#line 4069
      return (-12);
    } else {

    }
  } else {
#line 4072
    log_value___1 = phba->attr_log_enable;
#line 4072
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4072
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : HWI_MEM_SGLH is more than one element.Failing to load\n",
                 4074);
      }
    } else {

    }
#line 4075
    return (-12);
  }
#line 4078
  arr_index = 0U;
#line 4079
  idx = 0U;
#line 4080
  goto ldv_58035;
  ldv_58034: 
#line 4081
  psgl_handle = (struct sgl_handle *)(mem_descr_sglh->mem_array + (unsigned long )idx)->virtual_address;
#line 4083
  i = 0U;
#line 4083
  goto ldv_58032;
  ldv_58031: ;
#line 4085
  if (arr_index < phba->params.ios_per_ctrl) {
#line 4086
    *(phba->io_sgl_hndl_base + (unsigned long )arr_index) = psgl_handle;
#line 4087
    phba->io_sgl_hndl_avbl = (unsigned short )((int )phba->io_sgl_hndl_avbl + 1);
#line 4088
    arr_index = arr_index + 1U;
  } else {
#line 4090
    *(phba->eh_sgl_hndl_base + (unsigned long )(arr_index - phba->params.ios_per_ctrl)) = psgl_handle;
#line 4093
    arr_index = arr_index + 1U;
#line 4094
    phba->eh_sgl_hndl_avbl = (unsigned short )((int )phba->eh_sgl_hndl_avbl + 1);
  }
#line 4096
  psgl_handle = psgl_handle + 1;
#line 4084
  i = i + 1U;
  ldv_58032: ;
#line 4083
  if (i < (mem_descr_sglh->mem_array + (unsigned long )idx)->size / 32U) {
#line 4085
    goto ldv_58031;
  } else {

  }
#line 4098
  idx = idx + 1U;
  ldv_58035: ;
#line 4080
  if (idx < mem_descr_sglh->num_elements) {
#line 4082
    goto ldv_58034;
  } else {

  }
#line 4100
  log_value___2 = phba->attr_log_enable;
#line 4100
  if ((int )log_value___2 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 4100
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : phba->io_sgl_hndl_avbl=%dphba->eh_sgl_hndl_avbl=%d\n",
               4104, (int )phba->io_sgl_hndl_avbl, (int )phba->eh_sgl_hndl_avbl);
    }
  } else {

  }
#line 4106
  mem_descr_sg = phba->init_mem;
#line 4107
  mem_descr_sg = mem_descr_sg + 4UL;
#line 4108
  log_value___3 = phba->attr_log_enable;
#line 4108
  if ((int )log_value___3 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 4108
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "\n BM_%d : mem_descr_sg->num_elements=%d\n",
               4110, mem_descr_sg->num_elements);
    }
  } else {

  }
#line 4112
  ulp_num = 0U;
#line 4112
  goto ldv_58041;
  ldv_58040: 
  {
#line 4113
  tmp___2 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 4113
  if (tmp___2 != 0) {
#line 4114
    goto ldv_58039;
  } else {

  }
#line 4112
  ulp_num = ulp_num + 1U;
  ldv_58041: ;
#line 4112
  if (ulp_num <= 1U) {
#line 4114
    goto ldv_58040;
  } else {

  }
  ldv_58039: 
#line 4116
  ulp_icd_start = phba->fw_config.iscsi_icd_start[ulp_num];
#line 4118
  arr_index = 0U;
#line 4119
  idx = 0U;
#line 4120
  goto ldv_58046;
  ldv_58045: 
#line 4121
  pfrag = (struct iscsi_sge *)(mem_descr_sg->mem_array + (unsigned long )idx)->virtual_address;
#line 4123
  i = 0U;
#line 4123
  goto ldv_58043;
  ldv_58042: ;
#line 4127
  if (arr_index < phba->params.ios_per_ctrl) {
#line 4128
    psgl_handle = *(phba->io_sgl_hndl_base + (unsigned long )arr_index);
  } else {
#line 4130
    psgl_handle = *(phba->eh_sgl_hndl_base + (unsigned long )(arr_index - phba->params.ios_per_ctrl));
  }
  {
#line 4132
  psgl_handle->pfrag = pfrag;
#line 4133
  tmp___3 = amap_mask(32U);
#line 4133
  amap_set((void *)pfrag, 0U, tmp___3, 0U, 0U);
#line 4134
  tmp___4 = amap_mask(32U);
#line 4134
  amap_set((void *)pfrag, 1U, tmp___4, 0U, 0U);
#line 4135
  pfrag = pfrag + (unsigned long )phba->params.num_sge_per_io;
#line 4136
  tmp___5 = arr_index;
#line 4136
  arr_index = arr_index + 1U;
#line 4136
  psgl_handle->sgl_index = ulp_icd_start + tmp___5;
#line 4126
  i = i + 1U;
  }
  ldv_58043: ;
#line 4123
  if ((unsigned long )i < (unsigned long )(mem_descr_sg->mem_array + (unsigned long )idx)->size / ((unsigned long )phba->params.num_sge_per_io * 16UL)) {
#line 4127
    goto ldv_58042;
  } else {

  }
#line 4138
  idx = idx + 1U;
  ldv_58046: ;
#line 4120
  if (idx < mem_descr_sg->num_elements) {
#line 4122
    goto ldv_58045;
  } else {

  }
#line 4140
  phba->io_sgl_free_index = 0U;
#line 4141
  phba->io_sgl_alloc_index = 0U;
#line 4142
  phba->eh_sgl_free_index = 0U;
#line 4143
  phba->eh_sgl_alloc_index = 0U;
#line 4144
  return (0);
}
}
#line 4147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int hba_setup_cid_tbls(struct beiscsi_hba *phba ) 
{ 
  int ret ;
  uint16_t i ;
  uint16_t ulp_num ;
  struct ulp_cid_info *ptr_cid_info ;
  void *tmp ;
  uint32_t log_value ;
  void *tmp___0 ;
  uint32_t log_value___0 ;
  int tmp___2 ;
  void *tmp___3 ;
  uint32_t log_value___1 ;
  void *tmp___4 ;
  uint32_t log_value___2 ;
  unsigned short tmp___5 ;
  int tmp___7 ;
  int tmp___9 ;

  {
#line 4151
  ptr_cid_info = (struct ulp_cid_info *)0;
#line 4153
  ulp_num = 0U;
#line 4153
  goto ldv_58059;
  ldv_58058: 
  {
#line 4154
  tmp___2 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 4154
  if (tmp___2 != 0) {
    {
#line 4155
    tmp = kzalloc(16UL, 208U);
#line 4155
    ptr_cid_info = (struct ulp_cid_info *)tmp;
    }
#line 4158
    if ((unsigned long )ptr_cid_info == (unsigned long )((struct ulp_cid_info *)0)) {
#line 4159
      log_value = phba->attr_log_enable;
#line 4159
      if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 4159
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Failed to allocate memoryfor ULP_CID_INFO for ULP : %d\n",
                   4162, (int )ulp_num);
        }
      } else {

      }
#line 4163
      ret = -12;
#line 4164
      goto free_memory;
    } else {

    }
    {
#line 4169
    tmp___0 = kzalloc((unsigned long )phba->fw_config.iscsi_cid_count[(int )ulp_num] * 8UL,
                      208U);
#line 4169
    ptr_cid_info->cid_array = (unsigned short *)tmp___0;
    }
#line 4172
    if ((unsigned long )ptr_cid_info->cid_array == (unsigned long )((unsigned short *)0U)) {
#line 4173
      log_value___0 = phba->attr_log_enable;
#line 4173
      if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 4173
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Failed to allocate memoryfor CID_ARRAY for ULP : %d\n",
                   4176, (int )ulp_num);
        }
      } else {

      }
      {
#line 4177
      kfree((void const   *)ptr_cid_info);
#line 4178
      ptr_cid_info = (struct ulp_cid_info *)0;
#line 4179
      ret = -12;
      }
#line 4181
      goto free_memory;
    } else {

    }
#line 4183
    ptr_cid_info->avlbl_cids = (unsigned short )phba->fw_config.iscsi_cid_count[(int )ulp_num];
#line 4187
    phba->cid_array_info[(int )ulp_num] = ptr_cid_info;
  } else {

  }
#line 4153
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_58059: ;
#line 4153
  if ((unsigned int )ulp_num <= 1U) {
#line 4155
    goto ldv_58058;
  } else {

  }
  {
#line 4190
  tmp___3 = kzalloc((unsigned long )phba->params.cxns_per_ctrl * 8UL, 208U);
#line 4190
  phba->ep_array = (struct iscsi_endpoint **)tmp___3;
  }
#line 4192
  if ((unsigned long )phba->ep_array == (unsigned long )((struct iscsi_endpoint **)0)) {
#line 4193
    log_value___1 = phba->attr_log_enable;
#line 4193
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4193
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory in hba_setup_cid_tbls\n",
                 4195);
      }
    } else {

    }
#line 4196
    ret = -12;
#line 4198
    goto free_memory;
  } else {

  }
  {
#line 4201
  tmp___4 = kzalloc((unsigned long )phba->params.cxns_per_ctrl * 8UL, 208U);
#line 4201
  phba->conn_table = (struct beiscsi_conn **)tmp___4;
  }
#line 4203
  if ((unsigned long )phba->conn_table == (unsigned long )((struct beiscsi_conn **)0)) {
#line 4204
    log_value___2 = phba->attr_log_enable;
#line 4204
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4204
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory inhba_setup_cid_tbls\n",
                 4206);
      }
    } else {

    }
    {
#line 4208
    kfree((void const   *)phba->ep_array);
#line 4209
    phba->ep_array = (struct iscsi_endpoint **)0;
#line 4210
    ret = -12;
    }
#line 4212
    goto free_memory;
  } else {

  }
#line 4215
  i = 0U;
#line 4215
  goto ldv_58064;
  ldv_58063: 
#line 4216
  ulp_num = (uint16_t )((phba->phwi_ctrlr)->wrb_context + (unsigned long )i)->ulp_num;
#line 4218
  ptr_cid_info = phba->cid_array_info[(int )ulp_num];
#line 4219
  tmp___5 = ptr_cid_info->cid_alloc;
#line 4219
  ptr_cid_info->cid_alloc = (unsigned short )((int )ptr_cid_info->cid_alloc + 1);
#line 4219
  *(ptr_cid_info->cid_array + (unsigned long )tmp___5) = ((phba->phwi_ctrlr)->wrb_context + (unsigned long )i)->cid;
#line 4215
  i = (uint16_t )((int )i + 1);
  ldv_58064: ;
#line 4215
  if ((unsigned int )i < phba->params.cxns_per_ctrl) {
#line 4217
    goto ldv_58063;
  } else {

  }
#line 4224
  ulp_num = 0U;
#line 4224
  goto ldv_58067;
  ldv_58066: 
  {
#line 4225
  tmp___7 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 4225
  if (tmp___7 != 0) {
#line 4226
    ptr_cid_info = phba->cid_array_info[(int )ulp_num];
#line 4228
    ptr_cid_info->cid_alloc = 0U;
#line 4229
    ptr_cid_info->cid_free = 0U;
  } else {

  }
#line 4224
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_58067: ;
#line 4224
  if ((unsigned int )ulp_num <= 1U) {
#line 4226
    goto ldv_58066;
  } else {

  }

#line 4232
  return (0);
  free_memory: 
#line 4235
  ulp_num = 0U;
#line 4235
  goto ldv_58070;
  ldv_58069: 
  {
#line 4236
  tmp___9 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 4236
  if (tmp___9 != 0) {
#line 4237
    ptr_cid_info = phba->cid_array_info[(int )ulp_num];
#line 4239
    if ((unsigned long )ptr_cid_info != (unsigned long )((struct ulp_cid_info *)0)) {
      {
#line 4240
      kfree((void const   *)ptr_cid_info->cid_array);
#line 4241
      kfree((void const   *)ptr_cid_info);
#line 4242
      phba->cid_array_info[(int )ulp_num] = (struct ulp_cid_info *)0;
      }
    } else {

    }
  } else {

  }
#line 4235
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_58070: ;
#line 4235
  if ((unsigned int )ulp_num <= 1U) {
#line 4237
    goto ldv_58069;
  } else {

  }

#line 4247
  return (ret);
}
}
#line 4250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_enable_intr(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_queue_info *eq ;
  u8 *addr ;
  u32 reg ;
  u32 i ;
  u32 enabled ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
  {
#line 4252
  ctrl = & phba->ctrl;
#line 4260
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4261
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 4263
  addr = ctrl->pcicfg + 252UL;
#line 4265
  reg = ioread32((void *)addr);
#line 4267
  enabled = reg & 536870912U;
  }
#line 4268
  if (enabled == 0U) {
#line 4269
    reg = reg | 536870912U;
#line 4270
    log_value = phba->attr_log_enable;
#line 4270
    if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 4270
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : reg =x%08x addr=%p\n", 4271, reg, addr);
      }
    } else {

    }
    {
#line 4272
    iowrite32(reg, (void *)addr);
    }
  } else {

  }
#line 4275
  if (! phba->msix_enabled) {
#line 4276
    eq = & phwi_context->be_eq[0].q;
#line 4277
    log_value___0 = phba->attr_log_enable;
#line 4277
    if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 4277
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : eq->id=%d\n", 4278, (int )eq->id);
      }
    } else {

    }
    {
#line 4280
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 0U, 0U, 1, 1);
    }
  } else {
#line 4282
    i = 0U;
#line 4282
    goto ldv_58087;
    ldv_58086: 
#line 4283
    eq = & phwi_context->be_eq[i].q;
#line 4284
    log_value___1 = phba->attr_log_enable;
#line 4284
    if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 4284
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : eq->id=%d\n", 4285, (int )eq->id);
      }
    } else {

    }
    {
#line 4286
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 0U, 0U, 1, 1);
#line 4282
    i = i + 1U;
    }
    ldv_58087: ;
#line 4282
    if (i <= phba->num_cpus) {
#line 4284
      goto ldv_58086;
    } else {

    }

  }
#line 4290
  return;
}
}
#line 4291 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_disable_intr(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  u8 *addr ;
  u32 reg ;
  unsigned int tmp ;
  u32 enabled ;
  uint32_t log_value ;

  {
  {
#line 4293
  ctrl = & phba->ctrl;
#line 4295
  addr = ctrl->pcicfg + 252UL;
#line 4296
  tmp = ioread32((void *)addr);
#line 4296
  reg = tmp;
#line 4298
  enabled = reg & 536870912U;
  }
#line 4299
  if (enabled != 0U) {
    {
#line 4300
    reg = reg & 3758096383U;
#line 4301
    iowrite32(reg, (void *)addr);
    }
  } else {
#line 4303
    log_value = phba->attr_log_enable;
#line 4303
    if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 4303
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : In hwi_disable_intr, Already Disabled\n",
                 4304);
      }
    } else {

    }
  }
#line 4305
  return;
}
}
#line 4317 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_get_boot_info(struct beiscsi_hba *phba ) 
{ 
  struct be_cmd_get_session_resp *session_resp ;
  struct be_dma_mem nonemb_cmd ;
  unsigned int tag ;
  unsigned int s_handle ;
  int ret ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
  {
#line 4323
  ret = -12;
#line 4326
  ret = be_mgmt_get_boot_shandle(phba, & s_handle);
  }
#line 4327
  if (ret != 0) {
#line 4328
    log_value = phba->attr_log_enable;
#line 4328
    if ((log_value & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4328
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : No boot session\n",
                 4330);
      }
    } else {

    }
#line 4331
    return (ret);
  } else {

  }
  {
#line 4333
  nonemb_cmd.va = pci_zalloc_consistent(phba->ctrl.pdev, 1180UL, & nonemb_cmd.dma);
  }
#line 4336
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 4337
    log_value___0 = phba->attr_log_enable;
#line 4337
    if ((log_value___0 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4337
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory forbeiscsi_get_session_info\n",
                 4340);
      }
    } else {

    }
#line 4342
    return (-12);
  } else {

  }
  {
#line 4345
  tag = mgmt_get_session_info(phba, s_handle, & nonemb_cmd);
  }
#line 4347
  if (tag == 0U) {
#line 4348
    log_value___1 = phba->attr_log_enable;
#line 4348
    if ((log_value___1 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4348
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_get_session_info Failed\n",
                 4351);
      }
    } else {

    }
#line 4353
    goto boot_freemem;
  } else {

  }
  {
#line 4356
  ret = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, & nonemb_cmd);
  }
#line 4357
  if (ret != 0) {
#line 4358
    log_value___2 = phba->attr_log_enable;
#line 4358
    if ((log_value___2 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4358
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_get_session_info Failed",
                 4360);
      }
    } else {

    }
#line 4362
    if (ret != -16) {
#line 4363
      goto boot_freemem;
    } else {
#line 4365
      return (ret);
    }
  } else {

  }
  {
#line 4368
  session_resp = (struct be_cmd_get_session_resp *)nonemb_cmd.va;
#line 4370
  __memcpy((void *)(& phba->boot_sess), (void const   *)(& session_resp->session_info),
           1164UL);
#line 4372
  ret = 0;
  }
  boot_freemem: 
  {
#line 4375
  pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va, nonemb_cmd.dma);
  }
#line 4377
  return (ret);
}
}
#line 4380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_boot_release(void *data ) 
{ 
  struct beiscsi_hba *phba ;

  {
  {
#line 4382
  phba = (struct beiscsi_hba *)data;
#line 4384
  scsi_host_put(phba->shost);
  }
#line 4385
  return;
}
}
#line 4387 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_setup_boot_info(struct beiscsi_hba *phba ) 
{ 
  struct iscsi_boot_kobj *boot_kobj ;
  int tmp ;
  struct Scsi_Host *tmp___0 ;
  struct Scsi_Host *tmp___1 ;
  struct Scsi_Host *tmp___2 ;

  {
#line 4392
  if ((unsigned long )phba->boot_kset != (unsigned long )((struct iscsi_boot_kset *)0)) {
#line 4393
    return (0);
  } else {

  }
  {
#line 4396
  tmp = beiscsi_get_boot_info(phba);
  }
#line 4396
  if (tmp != 0) {
#line 4398
    return (0);
  } else {

  }
  {
#line 4400
  phba->boot_kset = iscsi_boot_create_host_kset((phba->shost)->host_no);
  }
#line 4401
  if ((unsigned long )phba->boot_kset == (unsigned long )((struct iscsi_boot_kset *)0)) {
#line 4402
    return (-12);
  } else {

  }
  {
#line 4405
  tmp___0 = scsi_host_get(phba->shost);
  }
#line 4405
  if ((unsigned long )tmp___0 == (unsigned long )((struct Scsi_Host *)0)) {
#line 4406
    goto free_kset;
  } else {

  }
  {
#line 4407
  boot_kobj = iscsi_boot_create_target(phba->boot_kset, 0, (void *)phba, & beiscsi_show_boot_tgt_info,
                                       & beiscsi_tgt_get_attr_visibility, & beiscsi_boot_release);
  }
#line 4411
  if ((unsigned long )boot_kobj == (unsigned long )((struct iscsi_boot_kobj *)0)) {
#line 4412
    goto put_shost;
  } else {

  }
  {
#line 4414
  tmp___1 = scsi_host_get(phba->shost);
  }
#line 4414
  if ((unsigned long )tmp___1 == (unsigned long )((struct Scsi_Host *)0)) {
#line 4415
    goto free_kset;
  } else {

  }
  {
#line 4416
  boot_kobj = iscsi_boot_create_initiator(phba->boot_kset, 0, (void *)phba, & beiscsi_show_boot_ini_info,
                                          & beiscsi_ini_get_attr_visibility, & beiscsi_boot_release);
  }
#line 4420
  if ((unsigned long )boot_kobj == (unsigned long )((struct iscsi_boot_kobj *)0)) {
#line 4421
    goto put_shost;
  } else {

  }
  {
#line 4423
  tmp___2 = scsi_host_get(phba->shost);
  }
#line 4423
  if ((unsigned long )tmp___2 == (unsigned long )((struct Scsi_Host *)0)) {
#line 4424
    goto free_kset;
  } else {

  }
  {
#line 4425
  boot_kobj = iscsi_boot_create_ethernet(phba->boot_kset, 0, (void *)phba, & beiscsi_show_boot_eth_info,
                                         & beiscsi_eth_get_attr_visibility, & beiscsi_boot_release);
  }
#line 4429
  if ((unsigned long )boot_kobj == (unsigned long )((struct iscsi_boot_kobj *)0)) {
#line 4430
    goto put_shost;
  } else {

  }
#line 4431
  return (0);
  put_shost: 
  {
#line 4434
  scsi_host_put(phba->shost);
  }
  free_kset: 
  {
#line 4436
  iscsi_boot_destroy_kset(phba->boot_kset);
  }
#line 4437
  return (-12);
}
}
#line 4440 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_init_port(struct beiscsi_hba *phba ) 
{ 
  int ret ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  int tmp ;

  {
  {
#line 4444
  ret = beiscsi_init_controller(phba);
  }
#line 4445
  if (ret < 0) {
#line 4446
    log_value = phba->attr_log_enable;
#line 4446
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4446
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe - Failed inbeiscsi_init_controller\n",
                 4448);
      }
    } else {

    }
#line 4449
    return (ret);
  } else {

  }
  {
#line 4451
  ret = beiscsi_init_sgl_handle(phba);
  }
#line 4452
  if (ret < 0) {
#line 4453
    log_value___0 = phba->attr_log_enable;
#line 4453
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4453
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe - Failed inbeiscsi_init_sgl_handle\n",
                 4455);
      }
    } else {

    }
#line 4456
    goto do_cleanup_ctrlr;
  } else {

  }
  {
#line 4459
  tmp = hba_setup_cid_tbls(phba);
  }
#line 4459
  if (tmp != 0) {
#line 4460
    log_value___1 = phba->attr_log_enable;
#line 4460
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 4460
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed in hba_setup_cid_tbls\n",
                 4461);
      }
    } else {

    }
    {
#line 4462
    kfree((void const   *)phba->io_sgl_hndl_base);
#line 4463
    kfree((void const   *)phba->eh_sgl_hndl_base);
    }
#line 4464
    goto do_cleanup_ctrlr;
  } else {

  }
#line 4467
  return (ret);
  do_cleanup_ctrlr: 
  {
#line 4470
  hwi_cleanup(phba);
  }
#line 4471
  return (ret);
}
}
#line 4474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void hwi_purge_eq(struct beiscsi_hba *phba ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_queue_info *eq ;
  struct be_eq_entry *eqe ;
  int i ;
  int eq_msix ;
  unsigned int num_processed ;
  void *tmp ;
  u32 tmp___0 ;
  void *tmp___1 ;

  {
#line 4479
  eqe = (struct be_eq_entry *)0;
#line 4483
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4484
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 4485
  if ((int )phba->msix_enabled) {
#line 4486
    eq_msix = 1;
  } else {
#line 4488
    eq_msix = 0;
  }
#line 4490
  i = 0;
#line 4490
  goto ldv_58142;
  ldv_58141: 
  {
#line 4491
  eq = & phwi_context->be_eq[i].q;
#line 4492
  tmp = queue_tail_node(eq);
#line 4492
  eqe = (struct be_eq_entry *)tmp;
#line 4493
  num_processed = 0U;
  }
#line 4494
  goto ldv_58139;
  ldv_58138: 
  {
#line 4496
  tmp___0 = amap_mask(1U);
#line 4496
  amap_set((void *)eqe, 0U, tmp___0, 0U, 0U);
#line 4497
  queue_tail_inc(eq);
#line 4498
  tmp___1 = queue_tail_node(eq);
#line 4498
  eqe = (struct be_eq_entry *)tmp___1;
#line 4499
  num_processed = num_processed + 1U;
  }
  ldv_58139: ;
#line 4494
  if ((int )eqe->dw[0UL] & 1) {
#line 4496
    goto ldv_58138;
  } else {

  }

#line 4502
  if (num_processed != 0U) {
    {
#line 4503
    hwi_ring_eq_db(phba, (unsigned int )eq->id, 1U, num_processed, 1, 1);
    }
  } else {

  }
#line 4490
  i = i + 1;
  ldv_58142: ;
#line 4490
  if ((unsigned int )i < phba->num_cpus + (unsigned int )eq_msix) {
#line 4492
    goto ldv_58141;
  } else {

  }

#line 4497
  return;
}
}
#line 4507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_clean_port(struct beiscsi_hba *phba ) 
{ 
  int mgmt_status ;
  int ulp_num ;
  struct ulp_cid_info *ptr_cid_info ;
  uint32_t log_value ;
  int tmp___0 ;
  int tmp___2 ;

  {
#line 4510
  ptr_cid_info = (struct ulp_cid_info *)0;
#line 4512
  ulp_num = 0;
#line 4512
  goto ldv_58152;
  ldv_58151: 
  {
#line 4513
  tmp___0 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 4513
  if (tmp___0 != 0) {
    {
#line 4514
    mgmt_status = mgmt_epfw_cleanup(phba, (int )((unsigned short )ulp_num));
    }
#line 4515
    if (mgmt_status != 0) {
#line 4516
      log_value = phba->attr_log_enable;
#line 4516
      if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 4516
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : mgmt_epfw_cleanup FAILED for ULP_%d\n", 4519, ulp_num);
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 4512
  ulp_num = ulp_num + 1;
  ldv_58152: ;
#line 4512
  if (ulp_num <= 1) {
#line 4514
    goto ldv_58151;
  } else {

  }
  {
#line 4523
  hwi_purge_eq(phba);
#line 4524
  hwi_cleanup(phba);
#line 4525
  kfree((void const   *)phba->io_sgl_hndl_base);
#line 4526
  kfree((void const   *)phba->eh_sgl_hndl_base);
#line 4527
  kfree((void const   *)phba->ep_array);
#line 4528
  kfree((void const   *)phba->conn_table);
#line 4530
  ulp_num = 0;
  }
#line 4530
  goto ldv_58155;
  ldv_58154: 
  {
#line 4531
  tmp___2 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 4531
  if (tmp___2 != 0) {
#line 4532
    ptr_cid_info = phba->cid_array_info[ulp_num];
#line 4534
    if ((unsigned long )ptr_cid_info != (unsigned long )((struct ulp_cid_info *)0)) {
      {
#line 4535
      kfree((void const   *)ptr_cid_info->cid_array);
#line 4536
      kfree((void const   *)ptr_cid_info);
#line 4537
      phba->cid_array_info[ulp_num] = (struct ulp_cid_info *)0;
      }
    } else {

    }
  } else {

  }
#line 4530
  ulp_num = ulp_num + 1;
  ldv_58155: ;
#line 4530
  if (ulp_num <= 1) {
#line 4532
    goto ldv_58154;
  } else {

  }

#line 4537
  return;
}
}
#line 4552 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
void beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn , struct iscsi_task *task ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct beiscsi_hba *phba ;
  struct hwi_wrb_context *pwrb_context ;
  struct hwi_controller *phwi_ctrlr ;
  uint16_t cri_index ;

  {
#line 4556
  phba = beiscsi_conn->phba;
#line 4559
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 4562
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4563
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 4565
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4567
  if ((unsigned long )io_task->pwrb_handle != (unsigned long )((struct wrb_handle *)0)) {
    {
#line 4568
    __memset((void *)(io_task->pwrb_handle)->pwrb, 0, 64UL);
#line 4570
    free_wrb_handle(phba, pwrb_context, io_task->pwrb_handle);
#line 4572
    io_task->pwrb_handle = (struct wrb_handle *)0;
    }
  } else {

  }
#line 4575
  if ((unsigned long )io_task->psgl_handle != (unsigned long )((struct sgl_handle *)0)) {
    {
#line 4576
    ldv_spin_lock_bh_156(& phba->mgmt_sgl_lock);
#line 4577
    free_mgmt_sgl_handle(phba, io_task->psgl_handle);
#line 4579
    io_task->psgl_handle = (struct sgl_handle *)0;
#line 4580
    ldv_spin_unlock_bh_157(& phba->mgmt_sgl_lock);
    }
  } else {

  }
#line 4583
  if (io_task->mtask_addr != 0ULL) {
    {
#line 4584
    pci_unmap_single(phba->pcidev, io_task->mtask_addr, (size_t )io_task->mtask_data_count,
                     1);
    }
  } else {

  }
#line 4587
  return;
}
}
#line 4595 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_cleanup_task(struct iscsi_task *task ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct beiscsi_session *beiscsi_sess ;
  struct hwi_wrb_context *pwrb_context ;
  struct hwi_controller *phwi_ctrlr ;
  uint16_t cri_index ;

  {
#line 4597
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4598
  conn = task->conn;
#line 4599
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4600
  phba = beiscsi_conn->phba;
#line 4601
  beiscsi_sess = beiscsi_conn->beiscsi_sess;
#line 4604
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 4607
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4608
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 4610
  if ((unsigned long )io_task->cmd_bhs != (unsigned long )((struct be_cmd_bhs *)0)) {
    {
#line 4611
    dma_pool_free(beiscsi_sess->bhs_pool, (void *)io_task->cmd_bhs, io_task->bhs_pa.u.a64.address);
#line 4613
    io_task->cmd_bhs = (struct be_cmd_bhs *)0;
    }
  } else {

  }
#line 4616
  if ((unsigned long )task->sc != (unsigned long )((struct scsi_cmnd *)0)) {
#line 4617
    if ((unsigned long )io_task->pwrb_handle != (unsigned long )((struct wrb_handle *)0)) {
      {
#line 4618
      free_wrb_handle(phba, pwrb_context, io_task->pwrb_handle);
#line 4620
      io_task->pwrb_handle = (struct wrb_handle *)0;
      }
    } else {

    }
#line 4623
    if ((unsigned long )io_task->psgl_handle != (unsigned long )((struct sgl_handle *)0)) {
      {
#line 4624
      ldv_spin_lock_158(& phba->io_sgl_lock);
#line 4625
      free_io_sgl_handle(phba, io_task->psgl_handle);
#line 4626
      ldv_spin_unlock_159(& phba->io_sgl_lock);
#line 4627
      io_task->psgl_handle = (struct sgl_handle *)0;
      }
    } else {

    }
#line 4630
    if ((unsigned long )io_task->scsi_cmnd != (unsigned long )((struct scsi_cmnd *)0)) {
      {
#line 4631
      scsi_dma_unmap(io_task->scsi_cmnd);
#line 4632
      io_task->scsi_cmnd = (struct scsi_cmnd *)0;
      }
    } else {

    }
  } else
#line 4635
  if ((unsigned int )beiscsi_conn->login_in_progress == 0U) {
    {
#line 4636
    beiscsi_free_mgmt_task_handles(beiscsi_conn, task);
    }
  } else {

  }
#line 4637
  return;
}
}
#line 4641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
void beiscsi_offload_connection(struct beiscsi_conn *beiscsi_conn , struct beiscsi_offload_params *params ) 
{ 
  struct wrb_handle *pwrb_handle ;
  struct beiscsi_hba *phba ;
  struct iscsi_task *task ;
  struct iscsi_session *session ;
  u32 doorbell ;

  {
  {
#line 4645
  phba = beiscsi_conn->phba;
#line 4646
  task = beiscsi_conn->task;
#line 4647
  session = (task->conn)->session;
#line 4648
  doorbell = 0U;
#line 4654
  beiscsi_conn->login_in_progress = 0U;
#line 4655
  ldv_spin_lock_bh_142(& session->back_lock);
#line 4656
  beiscsi_cleanup_task(task);
#line 4657
  ldv_spin_unlock_bh_143(& session->back_lock);
#line 4659
  pwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid);
  }
#line 4662
  if (phba->generation - 2U <= 1U) {
    {
#line 4663
    beiscsi_offload_cxn_v0(params, pwrb_handle, phba->init_mem);
    }
  } else {
    {
#line 4666
    beiscsi_offload_cxn_v2(params, pwrb_handle);
    }
  }
  {
#line 4668
  swap_dws((void *)pwrb_handle->pwrb, 64);
#line 4671
  doorbell = doorbell | (beiscsi_conn->beiscsi_conn_cid & 65535U);
#line 4672
  doorbell = doorbell | (u32 )(((int )pwrb_handle->wrb_index & 255) << 16);
#line 4674
  doorbell = doorbell | 16777216U;
#line 4675
  iowrite32(doorbell, (void *)phba->db_va + (unsigned long )beiscsi_conn->doorbell_offset);
  }
#line 4677
  return;
}
}
#line 4679 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_parse_pdu(struct iscsi_conn *conn , itt_t itt , int *index , int *age ) 
{ 


  {
#line 4682
  *index = (int )itt;
#line 4683
  if ((unsigned long )age != (unsigned long )((int *)0)) {
#line 4684
    *age = (conn->session)->age;
  } else {

  }
#line 4685
  return;
}
}
#line 4697 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_alloc_pdu(struct iscsi_task *task , uint8_t opcode ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct hwi_wrb_context *pwrb_context ;
  struct hwi_controller *phwi_ctrlr ;
  itt_t itt ;
  uint16_t cri_index ;
  struct beiscsi_session *beiscsi_sess ;
  dma_addr_t paddr ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  __u32 tmp___0 ;

  {
  {
#line 4699
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4700
  conn = task->conn;
#line 4701
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4702
  phba = beiscsi_conn->phba;
#line 4706
  cri_index = 0U;
#line 4707
  beiscsi_sess = beiscsi_conn->beiscsi_sess;
#line 4710
  tmp = ldv_dma_pool_alloc_162(beiscsi_sess->bhs_pool, 32U, & paddr);
#line 4710
  io_task->cmd_bhs = (struct be_cmd_bhs *)tmp;
  }
#line 4712
  if ((unsigned long )io_task->cmd_bhs == (unsigned long )((struct be_cmd_bhs *)0)) {
#line 4713
    return (-12);
  } else {

  }
#line 4714
  io_task->bhs_pa.u.a64.address = paddr;
#line 4715
  io_task->libiscsi_itt = (unsigned int )task->itt;
#line 4716
  io_task->conn = beiscsi_conn;
#line 4718
  task->hdr = (struct iscsi_hdr *)(& (io_task->cmd_bhs)->iscsi_hdr);
#line 4719
  task->hdr_max = 324U;
#line 4720
  io_task->psgl_handle = (struct sgl_handle *)0;
#line 4721
  io_task->pwrb_handle = (struct wrb_handle *)0;
#line 4723
  if ((unsigned long )task->sc != (unsigned long )((struct scsi_cmnd *)0)) {
    {
#line 4724
    ldv_spin_lock_158(& phba->io_sgl_lock);
#line 4725
    io_task->psgl_handle = alloc_io_sgl_handle(phba);
#line 4726
    ldv_spin_unlock_159(& phba->io_sgl_lock);
    }
#line 4727
    if ((unsigned long )io_task->psgl_handle == (unsigned long )((struct sgl_handle *)0)) {
#line 4728
      log_value = phba->attr_log_enable;
#line 4728
      if ((log_value & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 4728
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Alloc of IO_SGL_ICD Failedfor the CID : %d\n", 4732, beiscsi_conn->beiscsi_conn_cid);
        }
      } else {

      }
#line 4733
      goto free_hndls;
    } else {

    }
    {
#line 4735
    io_task->pwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid);
    }
#line 4737
    if ((unsigned long )io_task->pwrb_handle == (unsigned long )((struct wrb_handle *)0)) {
#line 4738
      log_value___0 = phba->attr_log_enable;
#line 4738
      if ((log_value___0 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 4738
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BM_%d : Alloc of WRB_HANDLE Failedfor the CID : %d\n", 4742, beiscsi_conn->beiscsi_conn_cid);
        }
      } else {

      }
#line 4743
      goto free_io_hndls;
    } else {

    }
  } else {
#line 4746
    io_task->scsi_cmnd = (struct scsi_cmnd *)0;
#line 4747
    if (((int )opcode & 63) == 3) {
#line 4748
      beiscsi_conn->task = task;
#line 4749
      if ((unsigned int )beiscsi_conn->login_in_progress == 0U) {
        {
#line 4750
        ldv_spin_lock_165(& phba->mgmt_sgl_lock);
#line 4751
        io_task->psgl_handle = alloc_mgmt_sgl_handle(phba);
#line 4753
        ldv_spin_unlock_166(& phba->mgmt_sgl_lock);
        }
#line 4754
        if ((unsigned long )io_task->psgl_handle == (unsigned long )((struct sgl_handle *)0)) {
#line 4755
          log_value___1 = phba->attr_log_enable;
#line 4755
          if ((log_value___1 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
            {
#line 4755
            dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                       "BM_%d : Alloc of MGMT_SGL_ICD Failedfor the CID : %d\n", 4761,
                       beiscsi_conn->beiscsi_conn_cid);
            }
          } else {

          }
#line 4762
          goto free_hndls;
        } else {

        }
        {
#line 4765
        beiscsi_conn->login_in_progress = 1U;
#line 4766
        beiscsi_conn->plogin_sgl_handle = io_task->psgl_handle;
#line 4768
        io_task->pwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid);
        }
#line 4771
        if ((unsigned long )io_task->pwrb_handle == (unsigned long )((struct wrb_handle *)0)) {
#line 4772
          log_value___2 = phba->attr_log_enable;
#line 4772
          if ((log_value___2 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
            {
#line 4772
            dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                       "BM_%d : Alloc of WRB_HANDLE Failedfor the CID : %d\n", 4778,
                       beiscsi_conn->beiscsi_conn_cid);
            }
          } else {

          }
#line 4779
          goto free_mgmt_hndls;
        } else {

        }
#line 4781
        beiscsi_conn->plogin_wrb_handle = io_task->pwrb_handle;
      } else {
#line 4785
        io_task->psgl_handle = beiscsi_conn->plogin_sgl_handle;
#line 4787
        io_task->pwrb_handle = beiscsi_conn->plogin_wrb_handle;
      }
    } else {
      {
#line 4791
      ldv_spin_lock_165(& phba->mgmt_sgl_lock);
#line 4792
      io_task->psgl_handle = alloc_mgmt_sgl_handle(phba);
#line 4793
      ldv_spin_unlock_166(& phba->mgmt_sgl_lock);
      }
#line 4794
      if ((unsigned long )io_task->psgl_handle == (unsigned long )((struct sgl_handle *)0)) {
#line 4795
        log_value___3 = phba->attr_log_enable;
#line 4795
        if ((log_value___3 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
          {
#line 4795
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BM_%d : Alloc of MGMT_SGL_ICD Failedfor the CID : %d\n", 4801,
                     beiscsi_conn->beiscsi_conn_cid);
          }
        } else {

        }
#line 4802
        goto free_hndls;
      } else {

      }
      {
#line 4804
      io_task->pwrb_handle = alloc_wrb_handle(phba, beiscsi_conn->beiscsi_conn_cid);
      }
#line 4807
      if ((unsigned long )io_task->pwrb_handle == (unsigned long )((struct wrb_handle *)0)) {
#line 4808
        log_value___4 = phba->attr_log_enable;
#line 4808
        if ((log_value___4 & 48U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
          {
#line 4808
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BM_%d : Alloc of WRB_HANDLE Failedfor the CID : %d\n", 4812,
                     beiscsi_conn->beiscsi_conn_cid);
          }
        } else {

        }
#line 4813
        goto free_mgmt_hndls;
      } else {

      }
    }
  }
  {
#line 4818
  tmp___0 = __fswab32(((unsigned int )(io_task->pwrb_handle)->wrb_index << 16) | (io_task->psgl_handle)->sgl_index);
#line 4818
  itt = tmp___0;
#line 4821
  (io_task->pwrb_handle)->pio_handle = task;
#line 4823
  (io_task->cmd_bhs)->iscsi_hdr.itt = itt;
  }
#line 4824
  return (0);
  free_io_hndls: 
  {
#line 4827
  ldv_spin_lock_158(& phba->io_sgl_lock);
#line 4828
  free_io_sgl_handle(phba, io_task->psgl_handle);
#line 4829
  ldv_spin_unlock_159(& phba->io_sgl_lock);
  }
#line 4830
  goto free_hndls;
  free_mgmt_hndls: 
  {
#line 4832
  ldv_spin_lock_165(& phba->mgmt_sgl_lock);
#line 4833
  free_mgmt_sgl_handle(phba, io_task->psgl_handle);
#line 4834
  io_task->psgl_handle = (struct sgl_handle *)0;
#line 4835
  ldv_spin_unlock_166(& phba->mgmt_sgl_lock);
  }
  free_hndls: 
#line 4837
  phwi_ctrlr = phba->phwi_ctrlr;
#line 4838
  cri_index = phba->cid_to_cri_map[beiscsi_conn->beiscsi_conn_cid];
#line 4840
  pwrb_context = phwi_ctrlr->wrb_context + (unsigned long )cri_index;
#line 4841
  if ((unsigned long )io_task->pwrb_handle != (unsigned long )((struct wrb_handle *)0)) {
    {
#line 4842
    free_wrb_handle(phba, pwrb_context, io_task->pwrb_handle);
    }
  } else {

  }
  {
#line 4843
  io_task->pwrb_handle = (struct wrb_handle *)0;
#line 4844
  dma_pool_free(beiscsi_sess->bhs_pool, (void *)io_task->cmd_bhs, io_task->bhs_pa.u.a64.address);
#line 4846
  io_task->cmd_bhs = (struct be_cmd_bhs *)0;
  }
#line 4847
  return (-12);
}
}
#line 4849 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
int beiscsi_iotask_v2(struct iscsi_task *task , struct scatterlist *sg , unsigned int num_sg ,
                      unsigned int xferlen , unsigned int writedir ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_wrb *pwrb ;
  unsigned int doorbell ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  __u16 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  __u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;

  {
#line 4854
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4855
  conn = task->conn;
#line 4856
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4857
  phba = beiscsi_conn->phba;
#line 4858
  pwrb = (struct iscsi_wrb *)0;
#line 4859
  doorbell = 0U;
#line 4861
  pwrb = (io_task->pwrb_handle)->pwrb;
#line 4863
  (io_task->cmd_bhs)->iscsi_hdr.exp_statsn = 0U;
#line 4864
  io_task->bhs_len = 324U;
#line 4866
  if (writedir != 0U) {
    {
#line 4867
    tmp = amap_mask(5U);
#line 4867
    amap_set((void *)pwrb, 0U, tmp, 27U, 1U);
#line 4869
    tmp___0 = amap_mask(1U);
#line 4869
    amap_set((void *)pwrb, 11U, tmp___0, 28U, 1U);
    }
  } else {
    {
#line 4871
    tmp___1 = amap_mask(5U);
#line 4871
    amap_set((void *)pwrb, 0U, tmp___1, 27U, 5U);
#line 4873
    tmp___2 = amap_mask(1U);
#line 4873
    amap_set((void *)pwrb, 11U, tmp___2, 28U, 0U);
    }
  }
  {
#line 4876
  tmp___3 = amap_mask(5U);
#line 4876
  tmp___4 = amap_get((void *)pwrb, 0U, tmp___3, 27U);
#line 4876
  io_task->wrb_type = (uint8_t )tmp___4;
#line 4879
  tmp___5 = __fswab16((int )*((unsigned short *)(& (io_task->cmd_bhs)->iscsi_hdr.lun)));
#line 4879
  tmp___6 = amap_mask(16U);
#line 4879
  amap_set((void *)pwrb, 1U, tmp___6, 16U, (u32 )tmp___5);
#line 4882
  tmp___7 = amap_mask(25U);
#line 4882
  amap_set((void *)pwrb, 0U, tmp___7, 0U, xferlen);
#line 4883
  tmp___8 = amap_mask(8U);
#line 4883
  amap_set((void *)pwrb, 1U, tmp___8, 8U, (u32 )(io_task->pwrb_handle)->wrb_index);
#line 4885
  tmp___9 = __fswab32(task->cmdsn);
#line 4885
  tmp___10 = amap_mask(32U);
#line 4885
  amap_set((void *)pwrb, 7U, tmp___10, 0U, tmp___9);
#line 4887
  tmp___11 = amap_mask(16U);
#line 4887
  amap_set((void *)pwrb, 2U, tmp___11, 0U, (io_task->psgl_handle)->sgl_index);
#line 4890
  hwi_write_sgl_v2(pwrb, sg, num_sg, io_task);
#line 4891
  tmp___12 = amap_mask(8U);
#line 4891
  amap_set((void *)pwrb, 1U, tmp___12, 0U, (u32 )(io_task->pwrb_handle)->nxt_wrb_index);
#line 4894
  swap_dws((void *)pwrb, 64);
#line 4896
  doorbell = doorbell | (beiscsi_conn->beiscsi_conn_cid & 65535U);
#line 4897
  doorbell = doorbell | (unsigned int )(((int )(io_task->pwrb_handle)->wrb_index & 255) << 16);
#line 4900
  doorbell = doorbell | 16777216U;
#line 4901
  iowrite32(doorbell, (void *)phba->db_va + (unsigned long )beiscsi_conn->doorbell_offset);
  }
#line 4903
  return (0);
}
}
#line 4906 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_iotask(struct iscsi_task *task , struct scatterlist *sg , unsigned int num_sg ,
                          unsigned int xferlen , unsigned int writedir ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_wrb *pwrb ;
  unsigned int doorbell ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  __u16 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  __u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;

  {
#line 4911
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4912
  conn = task->conn;
#line 4913
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4914
  phba = beiscsi_conn->phba;
#line 4915
  pwrb = (struct iscsi_wrb *)0;
#line 4916
  doorbell = 0U;
#line 4918
  pwrb = (io_task->pwrb_handle)->pwrb;
#line 4919
  (io_task->cmd_bhs)->iscsi_hdr.exp_statsn = 0U;
#line 4920
  io_task->bhs_len = 324U;
#line 4922
  if (writedir != 0U) {
    {
#line 4923
    tmp = amap_mask(4U);
#line 4923
    amap_set((void *)pwrb, 0U, tmp, 28U, 1U);
#line 4925
    tmp___0 = amap_mask(1U);
#line 4925
    amap_set((void *)pwrb, 0U, tmp___0, 24U, 1U);
    }
  } else {
    {
#line 4927
    tmp___1 = amap_mask(4U);
#line 4927
    amap_set((void *)pwrb, 0U, tmp___1, 28U, 5U);
#line 4929
    tmp___2 = amap_mask(1U);
#line 4929
    amap_set((void *)pwrb, 0U, tmp___2, 24U, 0U);
    }
  }
  {
#line 4932
  tmp___3 = amap_mask(4U);
#line 4932
  tmp___4 = amap_get((void *)pwrb, 0U, tmp___3, 28U);
#line 4932
  io_task->wrb_type = (uint8_t )tmp___4;
#line 4935
  tmp___5 = __fswab16((int )*((unsigned short *)(& (io_task->cmd_bhs)->iscsi_hdr.lun)));
#line 4935
  tmp___6 = amap_mask(14U);
#line 4935
  amap_set((void *)pwrb, 0U, tmp___6, 0U, (u32 )tmp___5);
#line 4938
  tmp___7 = amap_mask(24U);
#line 4938
  amap_set((void *)pwrb, 1U, tmp___7, 8U, xferlen);
#line 4939
  tmp___8 = amap_mask(8U);
#line 4939
  amap_set((void *)pwrb, 0U, tmp___8, 16U, (u32 )(io_task->pwrb_handle)->wrb_index);
#line 4941
  tmp___9 = __fswab32(task->cmdsn);
#line 4941
  tmp___10 = amap_mask(32U);
#line 4941
  amap_set((void *)pwrb, 6U, tmp___10, 0U, tmp___9);
#line 4943
  tmp___11 = amap_mask(12U);
#line 4943
  amap_set((void *)pwrb, 2U, tmp___11, 0U, (io_task->psgl_handle)->sgl_index);
#line 4946
  hwi_write_sgl(pwrb, sg, num_sg, io_task);
#line 4948
  tmp___12 = amap_mask(8U);
#line 4948
  amap_set((void *)pwrb, 1U, tmp___12, 0U, (u32 )(io_task->pwrb_handle)->nxt_wrb_index);
#line 4950
  swap_dws((void *)pwrb, 64);
#line 4952
  doorbell = doorbell | (beiscsi_conn->beiscsi_conn_cid & 65535U);
#line 4953
  doorbell = doorbell | (unsigned int )(((int )(io_task->pwrb_handle)->wrb_index & 255) << 16);
#line 4955
  doorbell = doorbell | 16777216U;
#line 4957
  iowrite32(doorbell, (void *)phba->db_va + (unsigned long )beiscsi_conn->doorbell_offset);
  }
#line 4959
  return (0);
}
}
#line 4962 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_mtask(struct iscsi_task *task ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct iscsi_conn *conn ;
  struct beiscsi_conn *beiscsi_conn ;
  struct beiscsi_hba *phba ;
  struct iscsi_wrb *pwrb ;
  unsigned int doorbell ;
  unsigned int cid ;
  unsigned int pwrb_typeoffset ;
  __u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  __u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  uint32_t log_value ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;

  {
  {
#line 4964
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 4965
  conn = task->conn;
#line 4966
  beiscsi_conn = (struct beiscsi_conn *)conn->dd_data;
#line 4967
  phba = beiscsi_conn->phba;
#line 4968
  pwrb = (struct iscsi_wrb *)0;
#line 4969
  doorbell = 0U;
#line 4971
  pwrb_typeoffset = 0U;
#line 4973
  cid = beiscsi_conn->beiscsi_conn_cid;
#line 4974
  pwrb = (io_task->pwrb_handle)->pwrb;
#line 4975
  __memset((void *)pwrb, 0, 64UL);
  }
#line 4977
  if (phba->generation - 2U <= 1U) {
    {
#line 4978
    tmp = __fswab32(task->cmdsn);
#line 4978
    tmp___0 = amap_mask(32U);
#line 4978
    amap_set((void *)pwrb, 6U, tmp___0, 0U, tmp);
#line 4980
    tmp___1 = amap_mask(8U);
#line 4980
    amap_set((void *)pwrb, 0U, tmp___1, 16U, (u32 )(io_task->pwrb_handle)->wrb_index);
#line 4982
    tmp___2 = amap_mask(12U);
#line 4982
    amap_set((void *)pwrb, 2U, tmp___2, 0U, (io_task->psgl_handle)->sgl_index);
#line 4984
    tmp___3 = amap_mask(24U);
#line 4984
    amap_set((void *)pwrb, 1U, tmp___3, 8U, task->data_count);
#line 4986
    tmp___4 = amap_mask(8U);
#line 4986
    amap_set((void *)pwrb, 1U, tmp___4, 0U, (u32 )(io_task->pwrb_handle)->nxt_wrb_index);
#line 4988
    pwrb_typeoffset = 28U;
    }
  } else {
    {
#line 4990
    tmp___5 = __fswab32(task->cmdsn);
#line 4990
    tmp___6 = amap_mask(32U);
#line 4990
    amap_set((void *)pwrb, 7U, tmp___6, 0U, tmp___5);
#line 4992
    tmp___7 = amap_mask(8U);
#line 4992
    amap_set((void *)pwrb, 1U, tmp___7, 8U, (u32 )(io_task->pwrb_handle)->wrb_index);
#line 4994
    tmp___8 = amap_mask(16U);
#line 4994
    amap_set((void *)pwrb, 2U, tmp___8, 0U, (io_task->psgl_handle)->sgl_index);
#line 4996
    tmp___9 = amap_mask(25U);
#line 4996
    amap_set((void *)pwrb, 0U, tmp___9, 0U, task->data_count);
#line 4998
    tmp___10 = amap_mask(8U);
#line 4998
    amap_set((void *)pwrb, 1U, tmp___10, 0U, (u32 )(io_task->pwrb_handle)->nxt_wrb_index);
#line 5000
    pwrb_typeoffset = 27U;
    }
  }
  {
#line 5005
  if (((int )(task->hdr)->opcode & 63) == 3) {
#line 5005
    goto case_3;
  } else {

  }
#line 5010
  if (((int )(task->hdr)->opcode & 63) == 0) {
#line 5010
    goto case_0;
  } else {

  }
#line 5030
  if (((int )(task->hdr)->opcode & 63) == 4) {
#line 5030
    goto case_4;
  } else {

  }
#line 5034
  if (((int )(task->hdr)->opcode & 63) == 2) {
#line 5034
    goto case_2;
  } else {

  }
#line 5038
  if (((int )(task->hdr)->opcode & 63) == 6) {
#line 5038
    goto case_6;
  } else {

  }
#line 5043
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 5006
  tmp___11 = amap_mask(32U);
#line 5006
  amap_set((void *)pwrb, 6U, tmp___11, 0U, 1U);
#line 5007
  pwrb->dw[0] = pwrb->dw[0] | (u32 )(11 << (int )pwrb_typeoffset);
#line 5008
  hwi_write_buffer(pwrb, task);
  }
#line 5009
  goto ldv_58253;
  case_0: /* CIL Label */ ;
#line 5011
  if ((task->hdr)->ttt != 4294967295U) {
#line 5012
    pwrb->dw[0] = pwrb->dw[0] | (u32 )(11 << (int )pwrb_typeoffset);
#line 5013
    if (phba->generation - 2U <= 1U) {
      {
#line 5014
      tmp___12 = amap_mask(1U);
#line 5014
      amap_set((void *)pwrb, 0U, tmp___12, 25U, 1U);
      }
    } else {
      {
#line 5017
      tmp___13 = amap_mask(1U);
#line 5017
      amap_set((void *)pwrb, 11U, tmp___13, 29U, 1U);
      }
    }
  } else {
#line 5020
    pwrb->dw[0] = pwrb->dw[0] | (u32 )(5 << (int )pwrb_typeoffset);
#line 5021
    if (phba->generation - 2U <= 1U) {
      {
#line 5022
      tmp___14 = amap_mask(1U);
#line 5022
      amap_set((void *)pwrb, 0U, tmp___14, 25U, 0U);
      }
    } else {
      {
#line 5025
      tmp___15 = amap_mask(1U);
#line 5025
      amap_set((void *)pwrb, 11U, tmp___15, 29U, 0U);
      }
    }
  }
  {
#line 5028
  hwi_write_buffer(pwrb, task);
  }
#line 5029
  goto ldv_58253;
  case_4: /* CIL Label */ 
  {
#line 5031
  pwrb->dw[0] = pwrb->dw[0] | (u32 )(11 << (int )pwrb_typeoffset);
#line 5032
  hwi_write_buffer(pwrb, task);
  }
#line 5033
  goto ldv_58253;
  case_2: /* CIL Label */ 
  {
#line 5035
  pwrb->dw[0] = pwrb->dw[0] | (u32 )(2 << (int )pwrb_typeoffset);
#line 5036
  hwi_write_buffer(pwrb, task);
  }
#line 5037
  goto ldv_58253;
  case_6: /* CIL Label */ 
  {
#line 5039
  pwrb->dw[0] = pwrb->dw[0] | (u32 )(2 << (int )pwrb_typeoffset);
#line 5040
  hwi_write_buffer(pwrb, task);
  }
#line 5041
  goto ldv_58253;
  switch_default: /* CIL Label */ 
#line 5044
  log_value = phba->attr_log_enable;
#line 5044
  if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 5044
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : opcode =%d Not supported\n",
               5046, (int )(task->hdr)->opcode & 63);
    }
  } else {

  }
#line 5048
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_58253: ;
#line 5052
  if (phba->generation - 2U <= 1U) {
    {
#line 5052
    tmp___16 = amap_mask(4U);
#line 5052
    tmp___17 = amap_get((void *)pwrb, 0U, tmp___16, 28U);
#line 5052
    io_task->wrb_type = (uint8_t )tmp___17;
    }
  } else {
    {
#line 5052
    tmp___18 = amap_mask(5U);
#line 5052
    tmp___19 = amap_get((void *)pwrb, 0U, tmp___18, 27U);
#line 5052
    io_task->wrb_type = (uint8_t )tmp___19;
    }
  }
  {
#line 5056
  doorbell = doorbell | (cid & 65535U);
#line 5057
  doorbell = doorbell | (unsigned int )(((int )(io_task->pwrb_handle)->wrb_index & 255) << 16);
#line 5059
  doorbell = doorbell | 16777216U;
#line 5060
  iowrite32(doorbell, (void *)phba->db_va + (unsigned long )beiscsi_conn->doorbell_offset);
  }
#line 5062
  return (0);
}
}
#line 5065 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_task_xmit(struct iscsi_task *task ) 
{ 
  struct beiscsi_io_task *io_task ;
  struct scsi_cmnd *sc ;
  struct beiscsi_hba *phba ;
  struct scatterlist *sg ;
  int num_sg ;
  unsigned int writedir ;
  unsigned int xferlen ;
  int tmp ;
  struct iscsi_conn *conn ;
  struct beiscsi_hba *phba___0 ;
  uint32_t log_value ;
  unsigned int tmp___0 ;
  __u32 tmp___1 ;
  int tmp___2 ;

  {
#line 5067
  io_task = (struct beiscsi_io_task *)task->dd_data;
#line 5068
  sc = task->sc;
#line 5069
  phba = (struct beiscsi_hba *)0;
#line 5072
  writedir = 0U;
#line 5072
  xferlen = 0U;
#line 5074
  phba = ((struct beiscsi_conn *)(task->conn)->dd_data)->phba;
#line 5076
  if ((unsigned long )sc == (unsigned long )((struct scsi_cmnd *)0)) {
    {
#line 5077
    tmp = beiscsi_mtask(task);
    }
#line 5077
    return (tmp);
  } else {

  }
  {
#line 5079
  io_task->scsi_cmnd = sc;
#line 5080
  num_sg = scsi_dma_map(sc);
  }
#line 5081
  if (num_sg < 0) {
#line 5082
    conn = task->conn;
#line 5083
    phba___0 = (struct beiscsi_hba *)0;
#line 5085
    phba___0 = ((struct beiscsi_conn *)conn->dd_data)->phba;
#line 5086
    log_value = phba___0->attr_log_enable;
#line 5086
    if ((log_value & 80U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5086
      tmp___0 = scsi_bufflen(sc);
#line 5086
      tmp___1 = __fswab32((io_task->cmd_bhs)->iscsi_hdr.itt);
#line 5086
      dev_printk("\v", (struct device  const  *)(& (phba___0->shost)->shost_gendev),
                 "BM_%d : scsi_dma_map Failed Driver_ITT : 0x%x ITT : 0x%x Xferlen : 0x%x\n",
                 5091, tmp___1, io_task->libiscsi_itt, tmp___0);
      }
    } else {

    }
#line 5093
    return (num_sg);
  } else {

  }
  {
#line 5095
  xferlen = scsi_bufflen(sc);
#line 5096
  sg = scsi_sglist(sc);
  }
#line 5097
  if ((unsigned int )sc->sc_data_direction == 1U) {
#line 5098
    writedir = 1U;
  } else {
#line 5100
    writedir = 0U;
  }
  {
#line 5102
  tmp___2 = (*(phba->iotask_fn))(task, sg, (uint32_t )num_sg, xferlen, writedir);
  }
#line 5102
  return (tmp___2);
}
}
#line 5109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_bsg_request(struct bsg_job *job ) 
{ 
  struct Scsi_Host *shost ;
  struct beiscsi_hba *phba ;
  struct iscsi_bsg_request *bsg_req ;
  int rc ;
  unsigned int tag ;
  struct be_dma_mem nonemb_cmd ;
  struct be_cmd_resp_hdr *resp ;
  struct iscsi_bsg_reply *bsg_reply ;
  unsigned short status ;
  unsigned short extd_status ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  long __ret ;
  unsigned long tmp___0 ;
  wait_queue_t __wait ;
  long __ret___0 ;
  unsigned long tmp___1 ;
  long __int ;
  long tmp___2 ;
  bool __cond ;
  bool __cond___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
  {
#line 5113
  bsg_req = (struct iscsi_bsg_request *)job->request;
#line 5114
  rc = -22;
#line 5118
  bsg_reply = (struct iscsi_bsg_reply *)job->reply;
#line 5121
  shost = dev_to_shost___0(job->dev);
#line 5122
  tmp = shost_priv(shost);
#line 5122
  phba = (struct beiscsi_hba *)tmp + 224U;
  }
  {
#line 5125
  if (bsg_req->msgcode == 2147483903U) {
#line 5125
    goto case_2147483903;
  } else {

  }
#line 5177
  goto switch_default;
  case_2147483903: /* CIL Label */ 
  {
#line 5126
  nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev, (size_t )job->request_payload.payload_len,
                                       & nonemb_cmd.dma);
  }
#line 5129
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 5130
    log_value = phba->attr_log_enable;
#line 5130
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5130
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to allocate memory for beiscsi_bsg_request\n",
                 5132);
      }
    } else {

    }
#line 5133
    return (-12);
  } else {

  }
  {
#line 5135
  tag = mgmt_vendor_specific_fw_cmd(& phba->ctrl, phba, job, & nonemb_cmd);
  }
#line 5137
  if (tag == 0U) {
#line 5138
    log_value___0 = phba->attr_log_enable;
#line 5138
    if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5138
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : MBX Tag Allocation Failed\n",
                 5139);
      }
    } else {

    }
    {
#line 5141
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
    }
#line 5143
    return (-11);
  } else {

  }
  {
#line 5146
  tmp___0 = msecs_to_jiffies(110000U);
#line 5146
  __ret = (long )tmp___0;
#line 5146
  __might_sleep("drivers/scsi/be2iscsi/be_main.c", 5150, 0);
#line 5146
  __cond___0 = phba->ctrl.mcc_numtag[tag] != 0U;
  }
#line 5146
  if ((int )__cond___0 && __ret == 0L) {
#line 5146
    __ret = 1L;
  } else {

  }
#line 5146
  if (((int )__cond___0 || __ret == 0L) == 0) {
    {
#line 5146
    tmp___1 = msecs_to_jiffies(110000U);
#line 5146
    __ret___0 = (long )tmp___1;
#line 5146
    INIT_LIST_HEAD(& __wait.task_list);
#line 5146
    __wait.flags = 0U;
    }
    ldv_58299: 
    {
#line 5146
    tmp___2 = prepare_to_wait_event((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + (unsigned long )tag,
                                    & __wait, 1);
#line 5146
    __int = tmp___2;
#line 5146
    __cond = phba->ctrl.mcc_numtag[tag] != 0U;
    }
#line 5146
    if ((int )__cond && __ret___0 == 0L) {
#line 5146
      __ret___0 = 1L;
    } else {

    }
#line 5146
    if (((int )__cond || __ret___0 == 0L) != 0) {
#line 5146
      goto ldv_58298;
    } else {

    }
#line 5146
    if (__int != 0L) {
#line 5146
      __ret___0 = __int;
#line 5146
      goto ldv_58298;
    } else {

    }
    {
#line 5146
    __ret___0 = schedule_timeout(__ret___0);
    }
#line 5146
    goto ldv_58299;
    ldv_58298: 
    {
#line 5146
    finish_wait((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + (unsigned long )tag,
                & __wait);
    }
#line 5146
    __ret = __ret___0;
  } else {

  }
  {
#line 5146
  rc = (int )__ret;
#line 5151
  extd_status = (unsigned short )((phba->ctrl.mcc_numtag[tag] & 65280U) >> 8);
#line 5152
  status = (unsigned int )((unsigned short )phba->ctrl.mcc_numtag[tag]) & 255U;
#line 5153
  free_mcc_tag(& phba->ctrl, tag);
#line 5154
  resp = (struct be_cmd_resp_hdr *)nonemb_cmd.va;
#line 5155
  sg_copy_from_buffer(job->reply_payload.sg_list, (unsigned int )job->reply_payload.sg_cnt,
                      nonemb_cmd.va, (unsigned long )resp->response_length + 16UL);
#line 5159
  bsg_reply->reply_payload_rcv_len = resp->response_length;
#line 5160
  bsg_reply->result = (uint32_t )status;
#line 5161
  bsg_job_done(job, (int )bsg_reply->result, bsg_reply->reply_payload_rcv_len);
#line 5163
  pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va, nonemb_cmd.dma);
  }
#line 5165
  if ((unsigned int )((int )status | (int )extd_status) != 0U) {
#line 5166
    log_value___1 = phba->attr_log_enable;
#line 5166
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5166
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : MBX Cmd Failed status = %d extd_status = %d\n",
                 5169, (int )status, (int )extd_status);
      }
    } else {

    }
#line 5171
    return (-5);
  } else {
#line 5173
    rc = 0;
  }
#line 5175
  goto ldv_58303;
  switch_default: /* CIL Label */ 
#line 5178
  log_value___2 = phba->attr_log_enable;
#line 5178
  if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 5178
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Unsupported bsg command: 0x%x\n",
               5180, bsg_req->msgcode);
    }
  } else {

  }
#line 5181
  goto ldv_58303;
  switch_break: /* CIL Label */ ;
  }
  ldv_58303: ;
#line 5184
  return (rc);
}
}
#line 5187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
void beiscsi_hba_attrs_init(struct beiscsi_hba *phba ) 
{ 


  {
  {
#line 5190
  beiscsi_log_enable_init(phba, beiscsi_log_enable);
  }
#line 5191
  return;
}
}
#line 5200 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_quiesce(struct beiscsi_hba *phba , uint32_t unload_state ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_eq_obj *pbe_eq ;
  unsigned int i ;
  unsigned int msix_vec ;

  {
  {
#line 5208
  phwi_ctrlr = phba->phwi_ctrlr;
#line 5209
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 5210
  hwi_disable_intr(phba);
  }
#line 5211
  if ((int )phba->msix_enabled) {
#line 5212
    i = 0U;
#line 5212
    goto ldv_58319;
    ldv_58318: 
    {
#line 5213
    msix_vec = phba->msix_entries[i].vector;
#line 5214
    synchronize_irq(msix_vec);
#line 5215
    ldv_free_irq_173(msix_vec, (void *)(& phwi_context->be_eq) + (unsigned long )i);
#line 5216
    kfree((void const   *)phba->msi_name[i]);
#line 5212
    i = i + 1U;
    }
    ldv_58319: ;
#line 5212
    if (i <= phba->num_cpus) {
#line 5214
      goto ldv_58318;
    } else {

    }

  } else
#line 5219
  if ((phba->pcidev)->irq != 0U) {
    {
#line 5220
    synchronize_irq((phba->pcidev)->irq);
#line 5221
    ldv_free_irq_174((phba->pcidev)->irq, (void *)phba);
    }
  } else {

  }
  {
#line 5223
  pci_disable_msix(phba->pcidev);
#line 5224
  cancel_delayed_work_sync(& phba->beiscsi_hw_check_task);
#line 5226
  i = 0U;
  }
#line 5226
  goto ldv_58322;
  ldv_58321: 
  {
#line 5227
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5228
  blk_iopoll_disable(& pbe_eq->iopoll);
#line 5226
  i = i + 1U;
  }
  ldv_58322: ;
#line 5226
  if (i < phba->num_cpus) {
#line 5228
    goto ldv_58321;
  } else {

  }

#line 5231
  if (unload_state == 1U) {
    {
#line 5232
    destroy_workqueue(phba->wq);
#line 5233
    beiscsi_clean_port(phba);
#line 5234
    beiscsi_free_mem(phba);
#line 5236
    beiscsi_unmap_pci_function(phba);
#line 5237
    pci_free_consistent(phba->pcidev, (size_t )phba->ctrl.mbox_mem_alloced.size, phba->ctrl.mbox_mem_alloced.va,
                        phba->ctrl.mbox_mem_alloced.dma);
    }
  } else {
    {
#line 5242
    hwi_purge_eq(phba);
#line 5243
    hwi_cleanup(phba);
    }
  }
#line 5245
  return;
}
}
#line 5248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_remove(struct pci_dev *pcidev ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;

  {
  {
#line 5251
  phba = (struct beiscsi_hba *)0;
#line 5253
  tmp = pci_get_drvdata(pcidev);
#line 5253
  phba = (struct beiscsi_hba *)tmp;
  }
#line 5254
  if ((unsigned long )phba == (unsigned long )((struct beiscsi_hba *)0)) {
    {
#line 5255
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_remove called with no phba\n");
    }
#line 5256
    return;
  } else {

  }
  {
#line 5259
  beiscsi_destroy_def_ifaces(phba);
#line 5260
  beiscsi_quiesce(phba, 1U);
#line 5261
  iscsi_boot_destroy_kset(phba->boot_kset);
#line 5262
  iscsi_host_remove(phba->shost);
#line 5263
  pci_dev_put(phba->pcidev);
#line 5264
  iscsi_host_free(phba->shost);
#line 5265
  pci_disable_pcie_error_reporting(pcidev);
#line 5266
  pci_set_drvdata(pcidev, (void *)0);
#line 5267
  pci_disable_device(pcidev);
  }
#line 5268
  return;
}
}
#line 5270 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_shutdown(struct pci_dev *pcidev ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;

  {
  {
#line 5273
  phba = (struct beiscsi_hba *)0;
#line 5275
  tmp = pci_get_drvdata(pcidev);
#line 5275
  phba = (struct beiscsi_hba *)tmp;
  }
#line 5276
  if ((unsigned long )phba == (unsigned long )((struct beiscsi_hba *)0)) {
    {
#line 5277
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_shutdown called with no phba\n");
    }
#line 5278
    return;
  } else {

  }
  {
#line 5281
  phba->state = 8U;
#line 5282
  iscsi_host_for_each_session(phba->shost, & be2iscsi_fail_session);
#line 5283
  beiscsi_quiesce(phba, 1U);
#line 5284
  pci_disable_device(pcidev);
  }
#line 5285
  return;
}
}
#line 5287 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_msix_enable(struct beiscsi_hba *phba ) 
{ 
  int i ;
  int status ;

  {
#line 5291
  i = 0;
#line 5291
  goto ldv_58338;
  ldv_58337: 
#line 5292
  phba->msix_entries[i].entry = (u16 )i;
#line 5291
  i = i + 1;
  ldv_58338: ;
#line 5291
  if ((unsigned int )i <= phba->num_cpus) {
#line 5293
    goto ldv_58337;
  } else {

  }
  {
#line 5294
  status = pci_enable_msix_range(phba->pcidev, (struct msix_entry *)(& phba->msix_entries),
                                 (int )(phba->num_cpus + 1U), (int )(phba->num_cpus + 1U));
  }
#line 5296
  if (status > 0) {
#line 5297
    phba->msix_enabled = 1;
  } else {

  }
#line 5299
  return;
}
}
#line 5302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_eqd_update(struct beiscsi_hba *phba ) 
{ 
  struct be_set_eqd set_eqd[64U] ;
  struct be_aic_obj *aic ;
  struct be_eq_obj *pbe_eq ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  int eqd ;
  int i ;
  int num ;
  ulong now ;
  u32 pps ;
  u32 delta ;
  unsigned int tag ;
  u32 __min1 ;
  u32 __min2 ;
  u32 __max1 ;
  u32 __max2 ;
  int tmp ;

  {
#line 5309
  num = 0;
#line 5314
  phwi_ctrlr = phba->phwi_ctrlr;
#line 5315
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 5317
  i = 0;
#line 5317
  goto ldv_58369;
  ldv_58368: 
#line 5318
  aic = (struct be_aic_obj *)(& phba->aic_obj) + (unsigned long )i;
#line 5319
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5320
  now = jiffies;
#line 5321
  if ((aic->jiffs == 0UL || (long )(now - aic->jiffs) < 0L) || (u64 )pbe_eq->cq_count < aic->eq_prev) {
#line 5323
    aic->jiffs = now;
#line 5324
    aic->eq_prev = (u64 )pbe_eq->cq_count;
#line 5325
    goto ldv_58361;
  } else {

  }
  {
#line 5327
  delta = jiffies_to_msecs(now - aic->jiffs);
#line 5328
  pps = ((pbe_eq->cq_count - (unsigned int )aic->eq_prev) * 1000U) / delta;
#line 5329
  eqd = (int )(pps / 1500U << 2);
  }
#line 5331
  if (eqd <= 7) {
#line 5332
    eqd = 0;
  } else {

  }
#line 5333
  __min1 = (u32 )eqd;
#line 5333
  __min2 = (u32 )phwi_context->max_eqd;
#line 5333
  eqd = (int )(__min1 < __min2 ? __min1 : __min2);
#line 5334
  __max1 = (u32 )eqd;
#line 5334
  __max2 = (u32 )phwi_context->min_eqd;
#line 5334
  eqd = (int )(__max1 > __max2 ? __max1 : __max2);
#line 5336
  aic->jiffs = now;
#line 5337
  aic->eq_prev = (u64 )pbe_eq->cq_count;
#line 5339
  if ((u32 )eqd != aic->prev_eqd) {
#line 5340
    set_eqd[num].delay_multiplier = (u32 )((eqd * 65) / 100);
#line 5341
    set_eqd[num].eq_id = (u32 )pbe_eq->q.id;
#line 5342
    aic->prev_eqd = (u32 )eqd;
#line 5343
    num = num + 1;
  } else {

  }
  ldv_58361: 
#line 5317
  i = i + 1;
  ldv_58369: ;
#line 5317
  if ((unsigned int )i <= phba->num_cpus) {
#line 5319
    goto ldv_58368;
  } else {

  }

#line 5346
  if (num != 0) {
    {
#line 5347
    tmp = be_cmd_modify_eq_delay(phba, (struct be_set_eqd *)(& set_eqd), num);
#line 5347
    tag = (unsigned int )tmp;
    }
#line 5348
    if (tag != 0U) {
      {
#line 5349
      beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
      }
    } else {

    }
  } else {

  }
#line 5351
  return;
}
}
#line 5353 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void be_check_boot_session(struct beiscsi_hba *phba ) 
{ 
  uint32_t log_value ;
  int tmp ;

  {
  {
#line 5355
  tmp = beiscsi_setup_boot_info(phba);
  }
#line 5355
  if (tmp != 0) {
#line 5356
    log_value = phba->attr_log_enable;
#line 5356
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5356
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Could not set up iSCSI boot info on async event.\n",
                 5358);
      }
    } else {

    }
  } else {

  }
#line 5358
  return;
}
}
#line 5368 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_hw_health_check(struct work_struct *work ) 
{ 
  struct beiscsi_hba *phba ;
  struct work_struct  const  *__mptr ;
  unsigned long tmp ;

  {
  {
#line 5371
  __mptr = (struct work_struct  const  *)work;
#line 5371
  phba = (struct beiscsi_hba *)__mptr + 0xffffffffffffe8e0UL;
#line 5374
  be_eqd_update(phba);
  }
#line 5376
  if ((phba->state & 16U) != 0U) {
    {
#line 5377
    phba->state = phba->state & 4294967279U;
#line 5378
    be_check_boot_session(phba);
    }
  } else {

  }
  {
#line 5381
  beiscsi_ue_detect(phba);
#line 5383
  tmp = msecs_to_jiffies(1000U);
#line 5383
  schedule_delayed_work(& phba->beiscsi_hw_check_task, tmp);
  }
#line 5385
  return;
}
}
#line 5388 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static pci_ers_result_t beiscsi_eeh_err_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
  {
#line 5391
  phba = (struct beiscsi_hba *)0;
#line 5393
  tmp = pci_get_drvdata(pdev);
#line 5393
  phba = (struct beiscsi_hba *)tmp;
#line 5394
  phba->state = phba->state | 4U;
#line 5396
  log_value = phba->attr_log_enable;
  }
#line 5396
  if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 5396
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH error detected\n",
               5397);
    }
  } else {

  }
  {
#line 5399
  beiscsi_quiesce(phba, 2U);
  }
#line 5401
  if (state == 3U) {
#line 5402
    log_value___0 = phba->attr_log_enable;
#line 5402
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5402
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH : State PERM Failure",
                 5403);
      }
    } else {

    }
#line 5404
    return (4U);
  } else {

  }
  {
#line 5407
  pci_disable_device(pdev);
  }
#line 5415
  if (pdev->devfn == 0U) {
    {
#line 5416
    ssleep(30U);
    }
  } else {

  }
#line 5418
  return (3U);
}
}
#line 5421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static pci_ers_result_t beiscsi_eeh_reset(struct pci_dev *pdev ) 
{ 
  struct beiscsi_hba *phba ;
  int status ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
  {
#line 5423
  phba = (struct beiscsi_hba *)0;
#line 5424
  status = 0;
#line 5426
  tmp = pci_get_drvdata(pdev);
#line 5426
  phba = (struct beiscsi_hba *)tmp;
#line 5428
  log_value = phba->attr_log_enable;
  }
#line 5428
  if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 5428
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH Reset\n",
               5429);
    }
  } else {

  }
  {
#line 5431
  status = pci_enable_device(pdev);
  }
#line 5432
  if (status != 0) {
#line 5433
    return (4U);
  } else {

  }
  {
#line 5435
  pci_set_master(pdev);
#line 5436
  pci_set_power_state(pdev, 0);
#line 5437
  pci_restore_state(pdev);
#line 5440
  status = be_chk_reset_complete(phba);
  }
#line 5441
  if (status == 0) {
#line 5442
    log_value___0 = phba->attr_log_enable;
#line 5442
    if ((int )log_value___0 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 5442
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH Reset Completed\n",
                 5443);
      }
    } else {

    }
  } else {
#line 5445
    log_value___1 = phba->attr_log_enable;
#line 5445
    if ((int )log_value___1 & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 5445
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : EEH Reset Completion Failure\n",
                 5446);
      }
    } else {

    }
#line 5447
    return (4U);
  }
  {
#line 5450
  pci_cleanup_aer_uncorrect_error_status(pdev);
  }
#line 5451
  return (5U);
}
}
#line 5454 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_eeh_resume(struct pci_dev *pdev ) 
{ 
  int ret ;
  int i ;
  struct be_eq_obj *pbe_eq ;
  struct beiscsi_hba *phba ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
  {
#line 5456
  ret = 0;
#line 5458
  phba = (struct beiscsi_hba *)0;
#line 5462
  tmp = pci_get_drvdata(pdev);
#line 5462
  phba = (struct beiscsi_hba *)tmp;
#line 5463
  pci_save_state(pdev);
  }
#line 5465
  if (enable_msix != 0U) {
    {
#line 5466
    find_num_cpus(phba);
    }
  } else {
#line 5468
    phba->num_cpus = 1U;
  }
#line 5470
  if (enable_msix != 0U) {
    {
#line 5471
    beiscsi_msix_enable(phba);
    }
#line 5472
    if (! phba->msix_enabled) {
#line 5473
      phba->num_cpus = 1U;
    } else {

    }
  } else {

  }
  {
#line 5476
  ret = beiscsi_cmd_reset_function(phba);
  }
#line 5477
  if (ret != 0) {
#line 5478
    log_value = phba->attr_log_enable;
#line 5478
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5478
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Reset Failed\n",
                 5479);
      }
    } else {

    }
#line 5480
    goto ret_err;
  } else {

  }
  {
#line 5483
  ret = be_chk_reset_complete(phba);
  }
#line 5484
  if (ret != 0) {
#line 5485
    log_value___0 = phba->attr_log_enable;
#line 5485
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5485
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to get out of reset.\n",
                 5486);
      }
    } else {

    }
#line 5487
    goto ret_err;
  } else {

  }
  {
#line 5490
  beiscsi_get_params(phba);
#line 5491
  (phba->shost)->max_id = phba->params.cxns_per_ctrl;
#line 5492
  (phba->shost)->can_queue = (int )phba->params.ios_per_ctrl;
#line 5493
  ret = hwi_init_controller(phba);
#line 5495
  i = 0;
  }
#line 5495
  goto ldv_58410;
  ldv_58409: 
  {
#line 5496
  __init_waitqueue_head((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + ((unsigned long )i + 1UL),
                        "&phba->ctrl.mcc_wait[i + 1]", & __key);
#line 5497
  phba->ctrl.mcc_tag[i] = (unsigned int )(i + 1);
#line 5498
  phba->ctrl.mcc_numtag[i + 1] = 0U;
#line 5499
  phba->ctrl.mcc_tag_available = phba->ctrl.mcc_tag_available + 1U;
#line 5495
  i = i + 1;
  }
  ldv_58410: ;
#line 5495
  if (i <= 15) {
#line 5497
    goto ldv_58409;
  } else {

  }
#line 5502
  phwi_ctrlr = phba->phwi_ctrlr;
#line 5503
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 5505
  i = 0;
#line 5505
  goto ldv_58413;
  ldv_58412: 
  {
#line 5506
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5507
  blk_iopoll_init(& pbe_eq->iopoll, (int )be_iopoll_budget, & be_iopoll);
#line 5509
  blk_iopoll_enable(& pbe_eq->iopoll);
#line 5505
  i = i + 1;
  }
  ldv_58413: ;
#line 5505
  if ((unsigned int )i < phba->num_cpus) {
#line 5507
    goto ldv_58412;
  } else {

  }
  {
#line 5512
  i = (int )phba->msix_enabled ? i : 0;
#line 5514
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5515
  __init_work(& pbe_eq->work_cqs, 0);
#line 5515
  __constr_expr_0.counter = 137438953408L;
#line 5515
  pbe_eq->work_cqs.data = __constr_expr_0;
#line 5515
  lockdep_init_map(& pbe_eq->work_cqs.lockdep_map, "(&pbe_eq->work_cqs)", & __key___0,
                   0);
#line 5515
  INIT_LIST_HEAD(& pbe_eq->work_cqs.entry);
#line 5515
  pbe_eq->work_cqs.func = & beiscsi_process_all_cqs;
#line 5517
  ret = beiscsi_init_irqs(phba);
  }
#line 5518
  if (ret < 0) {
#line 5519
    log_value___1 = phba->attr_log_enable;
#line 5519
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5519
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_eeh_resume - Failed to beiscsi_init_irqs\n",
                 5521);
      }
    } else {

    }
#line 5522
    goto ret_err;
  } else {

  }
  {
#line 5525
  hwi_enable_intr(phba);
#line 5526
  phba->state = phba->state & 4294967291U;
  }
#line 5528
  return;
  ret_err: 
#line 5530
  log_value___2 = phba->attr_log_enable;
#line 5530
  if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 5530
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : AER EEH Resume Failed\n",
               5531);
    }
  } else {

  }
#line 5532
  return;
}
}
#line 5534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_dev_probe(struct pci_dev *pcidev , struct pci_device_id  const  *id ) 
{ 
  struct beiscsi_hba *phba ;
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct be_eq_obj *pbe_eq ;
  int ret ;
  int i ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  struct lock_class_key __key___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;
  uint32_t log_value___5 ;
  struct lock_class_key __key___3 ;
  unsigned short tmp ;
  struct lock_class_key __key___4 ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___0 ;
  uint32_t log_value___6 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___6 ;
  struct lock_class_key __key___7 ;
  atomic_long_t __constr_expr_1 ;
  uint32_t log_value___7 ;
  int tmp___1 ;
  uint32_t log_value___8 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  uint32_t log_value___9 ;

  {
  {
#line 5537
  phba = (struct beiscsi_hba *)0;
#line 5541
  ret = 0;
#line 5543
  ret = beiscsi_enable_pci(pcidev);
  }
#line 5544
  if (ret < 0) {
    {
#line 5545
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_dev_probe - Failed to enable pci device\n");
    }
#line 5547
    return (ret);
  } else {

  }
  {
#line 5550
  phba = beiscsi_hba_alloc(pcidev);
  }
#line 5551
  if ((unsigned long )phba == (unsigned long )((struct beiscsi_hba *)0)) {
    {
#line 5552
    dev_err((struct device  const  *)(& pcidev->dev), "beiscsi_dev_probe - Failed in beiscsi_hba_alloc\n");
    }
#line 5554
    goto disable_pci;
  } else {

  }
  {
#line 5558
  ret = pci_enable_pcie_error_reporting(pcidev);
  }
#line 5559
  if (ret != 0) {
#line 5560
    log_value = phba->attr_log_enable;
#line 5560
    if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 5560
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : PCIe Error Reporting Enabling Failed\n",
                 5562);
      }
    } else {

    }
  } else {

  }
  {
#line 5564
  pci_save_state(pcidev);
#line 5567
  beiscsi_hba_attrs_init(phba);
#line 5569
  phba->fw_timeout = 0;
#line 5570
  phba->mac_addr_set = 0;
  }
  {
#line 5574
  if ((int )pcidev->device == 530) {
#line 5574
    goto case_530;
  } else {

  }
#line 5575
  if ((int )pcidev->device == 1794) {
#line 5575
    goto case_1794;
  } else {

  }
#line 5576
  if ((int )pcidev->device == 1795) {
#line 5576
    goto case_1795;
  } else {

  }
#line 5580
  if ((int )pcidev->device == 546) {
#line 5580
    goto case_546;
  } else {

  }
#line 5581
  if ((int )pcidev->device == 1810) {
#line 5581
    goto case_1810;
  } else {

  }
#line 5585
  if ((int )pcidev->device == 1826) {
#line 5585
    goto case_1826;
  } else {

  }
#line 5589
  goto switch_default;
  case_530: /* CIL Label */ ;
  case_1794: /* CIL Label */ ;
  case_1795: /* CIL Label */ 
#line 5577
  phba->generation = 2U;
#line 5578
  phba->iotask_fn = & beiscsi_iotask;
#line 5579
  goto ldv_58434;
  case_546: /* CIL Label */ ;
  case_1810: /* CIL Label */ 
#line 5582
  phba->generation = 3U;
#line 5583
  phba->iotask_fn = & beiscsi_iotask;
#line 5584
  goto ldv_58434;
  case_1826: /* CIL Label */ 
#line 5586
  phba->generation = 4U;
#line 5587
  phba->iotask_fn = & beiscsi_iotask_v2;
#line 5588
  goto ldv_58434;
  switch_default: /* CIL Label */ 
#line 5590
  phba->generation = 0U;
  switch_break: /* CIL Label */ ;
  }
  ldv_58434: 
  {
#line 5593
  ret = be_ctrl_init(phba, pcidev);
  }
#line 5594
  if (ret != 0) {
#line 5595
    log_value___0 = phba->attr_log_enable;
#line 5595
    if ((int )log_value___0 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5595
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe-Failed in be_ctrl_init\n",
                 5597);
      }
    } else {

    }
#line 5598
    goto hba_free;
  } else {

  }
  {
#line 5601
  ret = beiscsi_cmd_reset_function(phba);
  }
#line 5602
  if (ret != 0) {
#line 5603
    log_value___1 = phba->attr_log_enable;
#line 5603
    if ((int )log_value___1 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5603
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Reset Failed\n",
                 5604);
      }
    } else {

    }
#line 5605
    goto hba_free;
  } else {

  }
  {
#line 5607
  ret = be_chk_reset_complete(phba);
  }
#line 5608
  if (ret != 0) {
#line 5609
    log_value___2 = phba->attr_log_enable;
#line 5609
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5609
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Failed to get out of reset.\n",
                 5610);
      }
    } else {

    }
#line 5611
    goto hba_free;
  } else {

  }
  {
#line 5614
  spinlock_check(& phba->io_sgl_lock);
#line 5614
  __raw_spin_lock_init(& phba->io_sgl_lock.__annonCompField18.rlock, "&(&phba->io_sgl_lock)->rlock",
                       & __key);
#line 5615
  spinlock_check(& phba->mgmt_sgl_lock);
#line 5615
  __raw_spin_lock_init(& phba->mgmt_sgl_lock.__annonCompField18.rlock, "&(&phba->mgmt_sgl_lock)->rlock",
                       & __key___0);
#line 5616
  spinlock_check(& phba->isr_lock);
#line 5616
  __raw_spin_lock_init(& phba->isr_lock.__annonCompField18.rlock, "&(&phba->isr_lock)->rlock",
                       & __key___1);
#line 5617
  spinlock_check(& phba->async_pdu_lock);
#line 5617
  __raw_spin_lock_init(& phba->async_pdu_lock.__annonCompField18.rlock, "&(&phba->async_pdu_lock)->rlock",
                       & __key___2);
#line 5618
  ret = mgmt_get_fw_config(& phba->ctrl, phba);
  }
#line 5619
  if (ret != 0) {
#line 5620
    log_value___3 = phba->attr_log_enable;
#line 5620
    if ((int )log_value___3 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5620
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Error getting fw config\n",
                 5621);
      }
    } else {

    }
#line 5622
    goto free_port;
  } else {

  }
#line 5625
  if (enable_msix != 0U) {
    {
#line 5626
    find_num_cpus(phba);
    }
  } else {
#line 5628
    phba->num_cpus = 1U;
  }
#line 5630
  log_value___4 = phba->attr_log_enable;
#line 5630
  if ((int )log_value___4 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 5630
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : num_cpus = %d\n",
               5632, phba->num_cpus);
    }
  } else {

  }
#line 5634
  if (enable_msix != 0U) {
    {
#line 5635
    beiscsi_msix_enable(phba);
    }
#line 5636
    if (! phba->msix_enabled) {
#line 5637
      phba->num_cpus = 1U;
    } else {

    }
  } else {

  }
  {
#line 5640
  (phba->shost)->max_id = phba->params.cxns_per_ctrl;
#line 5641
  beiscsi_get_params(phba);
#line 5642
  (phba->shost)->can_queue = (int )phba->params.ios_per_ctrl;
#line 5643
  ret = beiscsi_init_port(phba);
  }
#line 5644
  if (ret < 0) {
#line 5645
    log_value___5 = phba->attr_log_enable;
#line 5645
    if ((int )log_value___5 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5645
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe-Failed in beiscsi_init_port\n",
                 5647);
      }
    } else {

    }
#line 5648
    goto free_port;
  } else {

  }
#line 5651
  i = 0;
#line 5651
  goto ldv_58453;
  ldv_58452: 
  {
#line 5652
  __init_waitqueue_head((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + ((unsigned long )i + 1UL),
                        "&phba->ctrl.mcc_wait[i + 1]", & __key___3);
#line 5653
  phba->ctrl.mcc_tag[i] = (unsigned int )(i + 1);
#line 5654
  phba->ctrl.mcc_numtag[i + 1] = 0U;
#line 5655
  phba->ctrl.mcc_tag_available = phba->ctrl.mcc_tag_available + 1U;
#line 5656
  __memset((void *)(& phba->ctrl.ptag_state[i].tag_mem_state), 0, 24UL);
#line 5651
  i = i + 1;
  }
  ldv_58453: ;
#line 5651
  if (i <= 15) {
#line 5653
    goto ldv_58452;
  } else {

  }
  {
#line 5660
  tmp = 0U;
#line 5660
  phba->ctrl.mcc_free_index = tmp;
#line 5660
  phba->ctrl.mcc_alloc_index = tmp;
#line 5662
  snprintf((char *)(& phba->wq_name), 20UL, "beiscsi_%02x_wq", (phba->shost)->host_no);
#line 5664
  __lock_name = "\"%s\"phba->wq_name";
#line 5664
  tmp___0 = __alloc_workqueue_key("%s", 8U, 1, & __key___4, __lock_name, (char *)(& phba->wq_name));
#line 5664
  phba->wq = tmp___0;
  }
#line 5665
  if ((unsigned long )phba->wq == (unsigned long )((struct workqueue_struct *)0)) {
#line 5666
    log_value___6 = phba->attr_log_enable;
#line 5666
    if ((int )log_value___6 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5666
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe-Failed to allocate work queue\n",
                 5668);
      }
    } else {

    }
#line 5669
    goto free_twq;
  } else {

  }
  {
#line 5672
  __init_work(& phba->beiscsi_hw_check_task.work, 0);
#line 5672
  __constr_expr_0.counter = 137438953408L;
#line 5672
  phba->beiscsi_hw_check_task.work.data = __constr_expr_0;
#line 5672
  lockdep_init_map(& phba->beiscsi_hw_check_task.work.lockdep_map, "(&(&phba->beiscsi_hw_check_task)->work)",
                   & __key___5, 0);
#line 5672
  INIT_LIST_HEAD(& phba->beiscsi_hw_check_task.work.entry);
#line 5672
  phba->beiscsi_hw_check_task.work.func = & beiscsi_hw_health_check;
#line 5672
  init_timer_key(& phba->beiscsi_hw_check_task.timer, 2U, "(&(&phba->beiscsi_hw_check_task)->timer)",
                 & __key___6);
#line 5672
  phba->beiscsi_hw_check_task.timer.function = & delayed_work_timer_fn;
#line 5672
  phba->beiscsi_hw_check_task.timer.data = (unsigned long )(& phba->beiscsi_hw_check_task);
#line 5675
  phwi_ctrlr = phba->phwi_ctrlr;
#line 5676
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 5678
  i = 0;
  }
#line 5678
  goto ldv_58464;
  ldv_58463: 
  {
#line 5679
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5680
  blk_iopoll_init(& pbe_eq->iopoll, (int )be_iopoll_budget, & be_iopoll);
#line 5682
  blk_iopoll_enable(& pbe_eq->iopoll);
#line 5678
  i = i + 1;
  }
  ldv_58464: ;
#line 5678
  if ((unsigned int )i < phba->num_cpus) {
#line 5680
    goto ldv_58463;
  } else {

  }
  {
#line 5685
  i = (int )phba->msix_enabled ? i : 0;
#line 5687
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5688
  __init_work(& pbe_eq->work_cqs, 0);
#line 5688
  __constr_expr_1.counter = 137438953408L;
#line 5688
  pbe_eq->work_cqs.data = __constr_expr_1;
#line 5688
  lockdep_init_map(& pbe_eq->work_cqs.lockdep_map, "(&pbe_eq->work_cqs)", & __key___7,
                   0);
#line 5688
  INIT_LIST_HEAD(& pbe_eq->work_cqs.entry);
#line 5688
  pbe_eq->work_cqs.func = & beiscsi_process_all_cqs;
#line 5690
  ret = beiscsi_init_irqs(phba);
  }
#line 5691
  if (ret < 0) {
#line 5692
    log_value___7 = phba->attr_log_enable;
#line 5692
    if ((int )log_value___7 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5692
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : beiscsi_dev_probe-Failed to beiscsi_init_irqs\n",
                 5694);
      }
    } else {

    }
#line 5695
    goto free_blkenbld;
  } else {

  }
  {
#line 5697
  hwi_enable_intr(phba);
#line 5699
  tmp___1 = iscsi_host_add(phba->shost, & (phba->pcidev)->dev);
  }
#line 5699
  if (tmp___1 != 0) {
#line 5700
    goto free_blkenbld;
  } else {

  }
  {
#line 5702
  tmp___2 = beiscsi_setup_boot_info(phba);
  }
#line 5702
  if (tmp___2 != 0) {
#line 5707
    log_value___8 = phba->attr_log_enable;
#line 5707
    if ((int )log_value___8 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 5707
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BM_%d : Could not set up iSCSI boot info.\n",
                 5709);
      }
    } else {

    }
  } else {

  }
  {
#line 5711
  beiscsi_create_def_ifaces(phba);
#line 5712
  tmp___3 = msecs_to_jiffies(1000U);
#line 5712
  schedule_delayed_work(& phba->beiscsi_hw_check_task, tmp___3);
#line 5715
  log_value___9 = phba->attr_log_enable;
  }
#line 5715
  if ((int )log_value___9 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 5715
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "\n\n\n BM_%d : SUCCESS - DRIVER LOADED\n\n\n",
               5716);
    }
  } else {

  }
#line 5717
  return (0);
  free_blkenbld: 
  {
#line 5720
  destroy_workqueue(phba->wq);
#line 5721
  i = 0;
  }
#line 5721
  goto ldv_58473;
  ldv_58472: 
  {
#line 5722
  pbe_eq = (struct be_eq_obj *)(& phwi_context->be_eq) + (unsigned long )i;
#line 5723
  blk_iopoll_disable(& pbe_eq->iopoll);
#line 5721
  i = i + 1;
  }
  ldv_58473: ;
#line 5721
  if ((unsigned int )i < phba->num_cpus) {
#line 5723
    goto ldv_58472;
  } else {

  }

  free_twq: 
  {
#line 5726
  beiscsi_clean_port(phba);
#line 5727
  beiscsi_free_mem(phba);
  }
  free_port: 
  {
#line 5729
  pci_free_consistent(phba->pcidev, (size_t )phba->ctrl.mbox_mem_alloced.size, phba->ctrl.mbox_mem_alloced.va,
                      phba->ctrl.mbox_mem_alloced.dma);
#line 5733
  beiscsi_unmap_pci_function(phba);
  }
  hba_free: ;
#line 5735
  if ((int )phba->msix_enabled) {
    {
#line 5736
    pci_disable_msix(phba->pcidev);
    }
  } else {

  }
  {
#line 5737
  iscsi_host_remove(phba->shost);
#line 5738
  pci_dev_put(phba->pcidev);
#line 5739
  iscsi_host_free(phba->shost);
  }
  disable_pci: 
  {
#line 5741
  pci_disable_device(pcidev);
  }
#line 5742
  return (ret);
}
}
#line 5745 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct pci_error_handlers beiscsi_eeh_handlers  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& beiscsi_eeh_err_detected),
    0, 0, & beiscsi_eeh_reset, 0, & beiscsi_eeh_resume};
#line 5751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
struct iscsi_transport beiscsi_iscsi_transport  = 
#line 5751
     {& __this_module, (char *)"be2iscsi", 2233U, & beiscsi_session_create, & beiscsi_session_destroy,
    & beiscsi_conn_create, & beiscsi_conn_bind, & beiscsi_conn_start, & iscsi_conn_stop,
    & iscsi_conn_teardown, & beiscsi_set_param, & beiscsi_ep_get_param, & iscsi_conn_get_param,
    & iscsi_session_get_param, & beiscsi_get_host_param, 0, & iscsi_conn_send_pdu,
    & beiscsi_conn_get_stats, 0, & beiscsi_task_xmit, & beiscsi_cleanup_task, & beiscsi_alloc_pdu,
    0, 0, & beiscsi_parse_pdu, & iscsi_session_recovery_timedout, & beiscsi_ep_connect,
    & beiscsi_ep_poll, & beiscsi_ep_disconnect, 0, 0, & be2iscsi_iface_set_param,
    & be2iscsi_iface_get_param, & be2iscsi_attr_is_visible, & beiscsi_bsg_request,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 5784 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static struct pci_driver beiscsi_pci_driver  = 
#line 5784
     {{0, 0}, "be2iscsi", (struct pci_device_id  const  *)(& beiscsi_pci_id_table),
    & beiscsi_dev_probe, & beiscsi_remove, 0, 0, 0, 0, & beiscsi_shutdown, 0, (struct pci_error_handlers  const  *)(& beiscsi_eeh_handlers),
    {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0U}}, 0U, 0U, 0, {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                                                           {0, 0}}};
#line 5794 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static int beiscsi_module_init(void) 
{ 
  int ret ;

  {
  {
#line 5798
  beiscsi_scsi_transport = iscsi_register_transport(& beiscsi_iscsi_transport);
  }
#line 5800
  if ((unsigned long )beiscsi_scsi_transport == (unsigned long )((struct scsi_transport_template *)0)) {
    {
#line 5801
    printk("\vbeiscsi_module_init - Unable to  register beiscsi transport.\n");
    }
#line 5803
    return (-12);
  } else {

  }
  {
#line 5805
  printk("\016In beiscsi_module_init, tt=%p\n", & beiscsi_iscsi_transport);
#line 5808
  ret = ldv___pci_register_driver_175(& beiscsi_pci_driver, & __this_module, "be2iscsi");
  }
#line 5809
  if (ret != 0) {
    {
#line 5810
    printk("\vbeiscsi_module_init - Unable to  register beiscsi pci driver.\n");
    }
#line 5812
    goto unregister_iscsi_transport;
  } else {

  }
#line 5814
  return (0);
  unregister_iscsi_transport: 
  {
#line 5817
  iscsi_unregister_transport(& beiscsi_iscsi_transport);
  }
#line 5818
  return (ret);
}
}
#line 5821 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_main.c"
static void beiscsi_module_exit(void) 
{ 


  {
  {
#line 5823
  ldv_pci_unregister_driver_176(& beiscsi_pci_driver);
#line 5824
  iscsi_unregister_transport(& beiscsi_iscsi_transport);
  }
#line 5825
  return;
}
}
#line 686 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_EMGentry_exit_beiscsi_module_exit_20_2(void (*arg0)(void) ) ;
#line 687
int ldv_EMGentry_init_beiscsi_module_init_20_13(int (*arg0)(void) ) ;
#line 688
int ldv___pci_register_driver(int arg0 , struct pci_driver *arg1 , struct module *arg2 ,
                              char *arg3 ) ;
#line 689
void ldv_dispatch_deregister_18_1(struct pci_driver *arg0 ) ;
#line 690
void ldv_dispatch_deregister_dummy_factory_10_20_4(void) ;
#line 691
void ldv_dispatch_deregister_dummy_resourceless_instance_8_20_5(void) ;
#line 692
void ldv_dispatch_deregister_scsi_host_template_instance_7_20_6(void) ;
#line 693
void ldv_dispatch_instance_deregister_13_2(struct timer_list *arg0 ) ;
#line 694
void ldv_dispatch_instance_register_13_3(struct timer_list *arg0 ) ;
#line 695
void ldv_dispatch_irq_deregister_14_1(int arg0 ) ;
#line 696
void ldv_dispatch_irq_register_15_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 697
void ldv_dispatch_irq_register_16_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 698
void ldv_dispatch_irq_register_17_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 699
void ldv_dispatch_register_19_2(struct pci_driver *arg0 ) ;
#line 700
void ldv_dispatch_register_dummy_factory_10_20_7(void) ;
#line 701
void ldv_dispatch_register_dummy_resourceless_instance_8_20_8(void) ;
#line 702
void ldv_dispatch_register_scsi_host_template_instance_7_20_9(void) ;
#line 703
void ldv_dummy_resourceless_instance_callback_10_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 704
void ldv_dummy_resourceless_instance_callback_10_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 705
void ldv_dummy_resourceless_instance_callback_11_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 706
void ldv_dummy_resourceless_instance_callback_11_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 707
void ldv_dummy_resourceless_instance_callback_5_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 708
void ldv_dummy_resourceless_instance_callback_5_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) ;
#line 709
void ldv_dummy_resourceless_instance_callback_6_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 710
void ldv_dummy_resourceless_instance_callback_6_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) ;
#line 711
void ldv_dummy_resourceless_instance_callback_7_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 712
void ldv_dummy_resourceless_instance_callback_7_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) ;
#line 713
void ldv_dummy_resourceless_instance_callback_8_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 714
void ldv_dummy_resourceless_instance_callback_8_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) ;
#line 715
void ldv_dummy_resourceless_instance_callback_9_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) ;
#line 716
void ldv_dummy_resourceless_instance_callback_9_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) ;
#line 717
void ldv_entry_EMGentry_20(void *arg0 ) ;
#line 718
void main(void) ;
#line 719
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) ;
#line 720
enum irqreturn ldv_interrupt_instance_handler_0_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 721
enum irqreturn ldv_interrupt_instance_handler_1_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 722
enum irqreturn ldv_interrupt_instance_handler_2_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 723
void ldv_interrupt_instance_thread_0_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 724
void ldv_interrupt_instance_thread_1_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 725
void ldv_interrupt_instance_thread_2_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 726
void ldv_interrupt_interrupt_instance_0(void *arg0 ) ;
#line 727
void ldv_interrupt_interrupt_instance_1(void *arg0 ) ;
#line 728
void ldv_interrupt_interrupt_instance_2(void *arg0 ) ;
#line 729
void ldv_pci_instance_callback_3_10(unsigned int (*arg0)(struct pci_dev * , enum pci_channel_state  ) ,
                                    struct pci_dev *arg1 , enum pci_channel_state arg2 ) ;
#line 730
void ldv_pci_instance_callback_3_23(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 731
void ldv_pci_instance_callback_3_24(unsigned int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 732
int ldv_pci_instance_probe_3_17(int (*arg0)(struct pci_dev * , struct pci_device_id * ) ,
                                struct pci_dev *arg1 , struct pci_device_id *arg2 ) ;
#line 733
void ldv_pci_instance_release_3_2(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 734
void ldv_pci_instance_resume_3_5(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 735
void ldv_pci_instance_resume_early_3_6(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 736
void ldv_pci_instance_shutdown_3_3(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) ;
#line 737
int ldv_pci_instance_suspend_3_8(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                 struct pci_dev *arg1 , struct pm_message arg2 ) ;
#line 738
int ldv_pci_instance_suspend_late_3_7(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                      struct pci_dev *arg1 , struct pm_message arg2 ) ;
#line 739
void ldv_pci_pci_instance_3(void *arg0 ) ;
#line 740
void ldv_pci_unregister_driver(void *arg0 , struct pci_driver *arg1 ) ;
#line 741
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) ;
#line 742
void ldv_scsi_host_template_instance_callback_4_17(unsigned short (*arg0)(int  , int  ) ,
                                                   int arg1 , int arg2 ) ;
#line 743
void ldv_scsi_host_template_instance_callback_4_20(int (*arg0)(struct iscsi_cls_session * ,
                                                               struct iscsi_cls_conn * ,
                                                               unsigned long long  ,
                                                               int  ) , struct iscsi_cls_session *arg1 ,
                                                   struct iscsi_cls_conn *arg2 , unsigned long long arg3 ,
                                                   int arg4 ) ;
#line 744
void ldv_scsi_host_template_instance_callback_4_23(int (*arg0)(struct bsg_job * ) ,
                                                   struct bsg_job *arg1 ) ;
#line 745
void ldv_scsi_host_template_instance_callback_4_24(int (*arg0)(struct scsi_device * ,
                                                               int  ) , struct scsi_device *arg1 ,
                                                   int arg2 ) ;
#line 746
void ldv_scsi_host_template_instance_callback_4_27(void (*arg0)(struct iscsi_task * ) ,
                                                   struct iscsi_task *arg1 ) ;
#line 747
void ldv_scsi_host_template_instance_callback_4_28(struct iscsi_cls_conn *(*arg0)(struct iscsi_cls_session * ,
                                                                                  unsigned int  ) ,
                                                   struct iscsi_cls_session *arg1 ,
                                                   unsigned int arg2 ) ;
#line 748
void ldv_scsi_host_template_instance_callback_4_31(struct iscsi_cls_session *(*arg0)(struct iscsi_endpoint * ,
                                                                                     unsigned short  ,
                                                                                     unsigned short  ,
                                                                                     unsigned int  ) ,
                                                   struct iscsi_endpoint *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 , unsigned int arg4 ) ;
#line 749
void ldv_scsi_host_template_instance_callback_4_34(void (*arg0)(struct iscsi_cls_conn * ) ,
                                                   struct iscsi_cls_conn *arg1 ) ;
#line 750
void ldv_scsi_host_template_instance_callback_4_35(void (*arg0)(struct iscsi_cls_session * ) ,
                                                   struct iscsi_cls_session *arg1 ) ;
#line 751
void ldv_scsi_host_template_instance_callback_4_36(int (*arg0)(struct scsi_cmnd * ) ,
                                                   struct scsi_cmnd *arg1 ) ;
#line 752
void ldv_scsi_host_template_instance_callback_4_37(int (*arg0)(struct scsi_cmnd * ) ,
                                                   struct scsi_cmnd *arg1 ) ;
#line 753
void ldv_scsi_host_template_instance_callback_4_38(int (*arg0)(struct scsi_cmnd * ) ,
                                                   struct scsi_cmnd *arg1 ) ;
#line 754
void ldv_scsi_host_template_instance_callback_4_39(struct iscsi_endpoint *(*arg0)(struct Scsi_Host * ,
                                                                                  struct sockaddr * ,
                                                                                  int  ) ,
                                                   struct Scsi_Host *arg1 , struct sockaddr *arg2 ,
                                                   int arg3 ) ;
#line 755
void ldv_scsi_host_template_instance_callback_4_4(int (*arg0)(struct iscsi_task * ,
                                                              unsigned char  ) , struct iscsi_task *arg1 ,
                                                  unsigned char arg2 ) ;
#line 756
void ldv_scsi_host_template_instance_callback_4_42(void (*arg0)(struct iscsi_endpoint * ) ,
                                                   struct iscsi_endpoint *arg1 ) ;
#line 757
void ldv_scsi_host_template_instance_callback_4_43(int (*arg0)(struct iscsi_endpoint * ,
                                                               int  ) , struct iscsi_endpoint *arg1 ,
                                                   int arg2 ) ;
#line 758
void ldv_scsi_host_template_instance_callback_4_46(int (*arg0)(struct iscsi_cls_conn * ,
                                                               enum iscsi_param  ,
                                                               char * ) , struct iscsi_cls_conn *arg1 ,
                                                   enum iscsi_param *arg2 , char *arg3 ) ;
#line 759
void ldv_scsi_host_template_instance_callback_4_49(int (*arg0)(struct iscsi_endpoint * ,
                                                               enum iscsi_param  ,
                                                               char * ) , struct iscsi_endpoint *arg1 ,
                                                   enum iscsi_param *arg2 , char *arg3 ) ;
#line 760
void ldv_scsi_host_template_instance_callback_4_52(int (*arg0)(struct Scsi_Host * ,
                                                               enum iscsi_host_param  ,
                                                               char * ) , struct Scsi_Host *arg1 ,
                                                   enum iscsi_host_param *arg2 , char *arg3 ) ;
#line 761
void ldv_scsi_host_template_instance_callback_4_55(int (*arg0)(struct iscsi_iface * ,
                                                               enum iscsi_param_type  ,
                                                               int  , char * ) , struct iscsi_iface *arg1 ,
                                                   enum iscsi_param_type *arg2 , int arg3 ,
                                                   char *arg4 ) ;
#line 762
void ldv_scsi_host_template_instance_callback_4_58(int (*arg0)(struct iscsi_cls_session * ,
                                                               enum iscsi_param  ,
                                                               char * ) , struct iscsi_cls_session *arg1 ,
                                                   enum iscsi_param *arg2 , char *arg3 ) ;
#line 763
void ldv_scsi_host_template_instance_callback_4_61(void (*arg0)(struct iscsi_cls_conn * ,
                                                                struct iscsi_stats * ) ,
                                                   struct iscsi_cls_conn *arg1 , struct iscsi_stats *arg2 ) ;
#line 764
void ldv_scsi_host_template_instance_callback_4_64(void (*arg0)(struct iscsi_conn * ,
                                                                unsigned int  , int * ,
                                                                int * ) , struct iscsi_conn *arg1 ,
                                                   unsigned int arg2 , int *arg3 ,
                                                   int *arg4 ) ;
#line 765
void ldv_scsi_host_template_instance_callback_4_67(int (*arg0)(struct Scsi_Host * ,
                                                               struct scsi_cmnd * ) ,
                                                   struct Scsi_Host *arg1 , struct scsi_cmnd *arg2 ) ;
#line 766
void ldv_scsi_host_template_instance_callback_4_68(int (*arg0)(struct iscsi_cls_conn * ,
                                                               struct iscsi_hdr * ,
                                                               char * , unsigned int  ) ,
                                                   struct iscsi_cls_conn *arg1 , struct iscsi_hdr *arg2 ,
                                                   char *arg3 , unsigned int arg4 ) ;
#line 767
void ldv_scsi_host_template_instance_callback_4_71(void (*arg0)(struct iscsi_cls_session * ) ,
                                                   struct iscsi_cls_session *arg1 ) ;
#line 768
void ldv_scsi_host_template_instance_callback_4_72(int (*arg0)(struct Scsi_Host * ,
                                                               void * , unsigned int  ) ,
                                                   struct Scsi_Host *arg1 , void *arg2 ,
                                                   unsigned int arg3 ) ;
#line 769
void ldv_scsi_host_template_instance_callback_4_75(int (*arg0)(struct iscsi_cls_conn * ,
                                                               enum iscsi_param  ,
                                                               char * , int  ) , struct iscsi_cls_conn *arg1 ,
                                                   enum iscsi_param *arg2 , char *arg3 ,
                                                   int arg4 ) ;
#line 770
void ldv_scsi_host_template_instance_callback_4_78(int (*arg0)(struct scsi_device * ) ,
                                                   struct scsi_device *arg1 ) ;
#line 771
void ldv_scsi_host_template_instance_callback_4_79(int (*arg0)(struct iscsi_cls_conn * ) ,
                                                   struct iscsi_cls_conn *arg1 ) ;
#line 772
void ldv_scsi_host_template_instance_callback_4_80(void (*arg0)(struct iscsi_cls_conn * ,
                                                                int  ) , struct iscsi_cls_conn *arg1 ,
                                                   int arg2 ) ;
#line 773
void ldv_scsi_host_template_instance_callback_4_83(int (*arg0)(struct scsi_target * ) ,
                                                   struct scsi_target *arg1 ) ;
#line 774
void ldv_scsi_host_template_instance_callback_4_84(int (*arg0)(struct iscsi_task * ) ,
                                                   struct iscsi_task *arg1 ) ;
#line 775
int ldv_scsi_host_template_instance_probe_4_10(int (*arg0)(struct Scsi_Host * ) ,
                                               struct Scsi_Host *arg1 ) ;
#line 776
void ldv_scsi_host_template_instance_release_4_2(int (*arg0)(struct Scsi_Host * ) ,
                                                 struct Scsi_Host *arg1 ) ;
#line 777
void ldv_scsi_host_template_scsi_host_template_instance_4(void *arg0 ) ;
#line 778
void ldv_struct_device_attribute_dummy_resourceless_instance_10(void *arg0 ) ;
#line 779
void ldv_struct_device_attribute_dummy_resourceless_instance_11(void *arg0 ) ;
#line 780
void ldv_struct_device_attribute_dummy_resourceless_instance_5(void *arg0 ) ;
#line 781
void ldv_struct_device_attribute_dummy_resourceless_instance_6(void *arg0 ) ;
#line 782
void ldv_struct_device_attribute_dummy_resourceless_instance_7(void *arg0 ) ;
#line 783
void ldv_struct_device_attribute_dummy_resourceless_instance_8(void *arg0 ) ;
#line 784
void ldv_struct_device_attribute_dummy_resourceless_instance_9(void *arg0 ) ;
#line 785
void ldv_timer_dummy_factory_13(void *arg0 ) ;
#line 786
void ldv_timer_instance_callback_12_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) ;
#line 787
void ldv_timer_timer_instance_12(void *arg0 ) ;
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_0  ;
#line 791 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_1  ;
#line 792 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_10  ;
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_11  ;
#line 794 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_12  ;
#line 795 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_13  ;
#line 796 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_2  ;
#line 797 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_20  ;
#line 798 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_3  ;
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_4  ;
#line 800 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_5  ;
#line 801 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_6  ;
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_7  ;
#line 803 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_8  ;
#line 804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
struct ldv_thread ldv_thread_9  ;
#line 810 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_EMGentry_exit_beiscsi_module_exit_20_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 811
  beiscsi_module_exit();
  }
#line 812
  return;
}
}
#line 815 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
int ldv_EMGentry_init_beiscsi_module_init_20_13(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 816
  tmp = beiscsi_module_init();
  }
#line 816
  return (tmp);
}
}
#line 820 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
int ldv___pci_register_driver(int arg0 , struct pci_driver *arg1 , struct module *arg2 ,
                              char *arg3 ) 
{ 
  struct pci_driver *ldv_19_pci_driver_pci_driver ;
  int tmp ;

  {
  {
#line 827
  tmp = ldv_undef_int();
  }
#line 827
  if (tmp != 0) {
    {
#line 829
    ldv_assume(arg0 == 0);
#line 830
    ldv_19_pci_driver_pci_driver = arg1;
#line 834
    ldv_dispatch_register_19_2(ldv_19_pci_driver_pci_driver);
    }
#line 838
    return (arg0);
  } else {
    {
#line 842
    ldv_assume(arg0 != 0);
    }
#line 846
    return (arg0);
  }
#line 849
  return (arg0);
}
}
#line 854 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_deregister_18_1(struct pci_driver *arg0 ) 
{ 


  {
#line 858
  return;
}
}
#line 862 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_deregister_dummy_factory_10_20_4(void) 
{ 


  {
#line 866
  return;
}
}
#line 870 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_8_20_5(void) 
{ 


  {
#line 886
  return;
}
}
#line 890 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_deregister_scsi_host_template_instance_7_20_6(void) 
{ 


  {
#line 894
  return;
}
}
#line 898 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_instance_deregister_13_2(struct timer_list *arg0 ) 
{ 


  {
#line 902
  return;
}
}
#line 906 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_instance_register_13_3(struct timer_list *arg0 ) 
{ 
  struct ldv_struct_timer_instance_12 *cf_arg_12 ;
  void *tmp ;

  {
  {
#line 909
  tmp = ldv_xmalloc(16UL);
#line 909
  cf_arg_12 = (struct ldv_struct_timer_instance_12 *)tmp;
#line 910
  cf_arg_12->arg0 = arg0;
#line 911
  ldv_timer_timer_instance_12((void *)cf_arg_12);
  }
#line 912
  return;
}
}
#line 916 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_irq_deregister_14_1(int arg0 ) 
{ 
  int tmp ;

  {
  {
#line 921
  tmp = ldv_undef_int();
  }
  {
#line 922
  if (tmp == 0) {
#line 922
    goto case_0;
  } else {

  }
#line 926
  if (tmp == 1) {
#line 926
    goto case_1;
  } else {

  }
#line 930
  if (tmp == 2) {
#line 930
    goto case_2;
  } else {

  }
#line 934
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 924
  goto ldv_59126;
  case_1: /* CIL Label */ ;
#line 928
  goto ldv_59126;
  case_2: /* CIL Label */ ;
#line 932
  goto ldv_59126;
  switch_default: /* CIL Label */ 
  {
#line 934
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_59126: ;
#line 936
  return;
}
}
#line 940 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_irq_register_15_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_0 *cf_arg_0 ;
  struct ldv_struct_interrupt_instance_0 *cf_arg_1 ;
  struct ldv_struct_interrupt_instance_0 *cf_arg_2 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 945
  tmp = ldv_undef_int();
  }
  {
#line 946
  if (tmp == 0) {
#line 946
    goto case_0;
  } else {

  }
#line 955
  if (tmp == 1) {
#line 955
    goto case_1;
  } else {

  }
#line 964
  if (tmp == 2) {
#line 964
    goto case_2;
  } else {

  }
#line 973
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 947
  tmp___0 = ldv_xmalloc(40UL);
#line 947
  cf_arg_0 = (struct ldv_struct_interrupt_instance_0 *)tmp___0;
#line 948
  cf_arg_0->arg0 = arg0;
#line 949
  cf_arg_0->arg1 = arg1;
#line 950
  cf_arg_0->arg2 = arg2;
#line 951
  cf_arg_0->arg3 = arg3;
#line 952
  ldv_interrupt_interrupt_instance_0((void *)cf_arg_0);
  }
#line 953
  goto ldv_59145;
  case_1: /* CIL Label */ 
  {
#line 956
  tmp___1 = ldv_xmalloc(40UL);
#line 956
  cf_arg_1 = (struct ldv_struct_interrupt_instance_0 *)tmp___1;
#line 957
  cf_arg_1->arg0 = arg0;
#line 958
  cf_arg_1->arg1 = arg1;
#line 959
  cf_arg_1->arg2 = arg2;
#line 960
  cf_arg_1->arg3 = arg3;
#line 961
  ldv_interrupt_interrupt_instance_1((void *)cf_arg_1);
  }
#line 962
  goto ldv_59145;
  case_2: /* CIL Label */ 
  {
#line 965
  tmp___2 = ldv_xmalloc(40UL);
#line 965
  cf_arg_2 = (struct ldv_struct_interrupt_instance_0 *)tmp___2;
#line 966
  cf_arg_2->arg0 = arg0;
#line 967
  cf_arg_2->arg1 = arg1;
#line 968
  cf_arg_2->arg2 = arg2;
#line 969
  cf_arg_2->arg3 = arg3;
#line 970
  ldv_interrupt_interrupt_instance_2((void *)cf_arg_2);
  }
#line 971
  goto ldv_59145;
  switch_default: /* CIL Label */ 
  {
#line 973
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_59145: ;
#line 975
  return;
}
}
#line 979 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_irq_register_16_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_0 *cf_arg_0 ;
  struct ldv_struct_interrupt_instance_0 *cf_arg_1 ;
  struct ldv_struct_interrupt_instance_0 *cf_arg_2 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 984
  tmp = ldv_undef_int();
  }
  {
#line 985
  if (tmp == 0) {
#line 985
    goto case_0;
  } else {

  }
#line 994
  if (tmp == 1) {
#line 994
    goto case_1;
  } else {

  }
#line 1003
  if (tmp == 2) {
#line 1003
    goto case_2;
  } else {

  }
#line 1012
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 986
  tmp___0 = ldv_xmalloc(40UL);
#line 986
  cf_arg_0 = (struct ldv_struct_interrupt_instance_0 *)tmp___0;
#line 987
  cf_arg_0->arg0 = arg0;
#line 988
  cf_arg_0->arg1 = arg1;
#line 989
  cf_arg_0->arg2 = arg2;
#line 990
  cf_arg_0->arg3 = arg3;
#line 991
  ldv_interrupt_interrupt_instance_0((void *)cf_arg_0);
  }
#line 992
  goto ldv_59164;
  case_1: /* CIL Label */ 
  {
#line 995
  tmp___1 = ldv_xmalloc(40UL);
#line 995
  cf_arg_1 = (struct ldv_struct_interrupt_instance_0 *)tmp___1;
#line 996
  cf_arg_1->arg0 = arg0;
#line 997
  cf_arg_1->arg1 = arg1;
#line 998
  cf_arg_1->arg2 = arg2;
#line 999
  cf_arg_1->arg3 = arg3;
#line 1000
  ldv_interrupt_interrupt_instance_1((void *)cf_arg_1);
  }
#line 1001
  goto ldv_59164;
  case_2: /* CIL Label */ 
  {
#line 1004
  tmp___2 = ldv_xmalloc(40UL);
#line 1004
  cf_arg_2 = (struct ldv_struct_interrupt_instance_0 *)tmp___2;
#line 1005
  cf_arg_2->arg0 = arg0;
#line 1006
  cf_arg_2->arg1 = arg1;
#line 1007
  cf_arg_2->arg2 = arg2;
#line 1008
  cf_arg_2->arg3 = arg3;
#line 1009
  ldv_interrupt_interrupt_instance_2((void *)cf_arg_2);
  }
#line 1010
  goto ldv_59164;
  switch_default: /* CIL Label */ 
  {
#line 1012
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_59164: ;
#line 1014
  return;
}
}
#line 1018 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_irq_register_17_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_0 *cf_arg_0 ;
  struct ldv_struct_interrupt_instance_0 *cf_arg_1 ;
  struct ldv_struct_interrupt_instance_0 *cf_arg_2 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1023
  tmp = ldv_undef_int();
  }
  {
#line 1024
  if (tmp == 0) {
#line 1024
    goto case_0;
  } else {

  }
#line 1033
  if (tmp == 1) {
#line 1033
    goto case_1;
  } else {

  }
#line 1042
  if (tmp == 2) {
#line 1042
    goto case_2;
  } else {

  }
#line 1051
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1025
  tmp___0 = ldv_xmalloc(40UL);
#line 1025
  cf_arg_0 = (struct ldv_struct_interrupt_instance_0 *)tmp___0;
#line 1026
  cf_arg_0->arg0 = arg0;
#line 1027
  cf_arg_0->arg1 = arg1;
#line 1028
  cf_arg_0->arg2 = arg2;
#line 1029
  cf_arg_0->arg3 = arg3;
#line 1030
  ldv_interrupt_interrupt_instance_0((void *)cf_arg_0);
  }
#line 1031
  goto ldv_59183;
  case_1: /* CIL Label */ 
  {
#line 1034
  tmp___1 = ldv_xmalloc(40UL);
#line 1034
  cf_arg_1 = (struct ldv_struct_interrupt_instance_0 *)tmp___1;
#line 1035
  cf_arg_1->arg0 = arg0;
#line 1036
  cf_arg_1->arg1 = arg1;
#line 1037
  cf_arg_1->arg2 = arg2;
#line 1038
  cf_arg_1->arg3 = arg3;
#line 1039
  ldv_interrupt_interrupt_instance_1((void *)cf_arg_1);
  }
#line 1040
  goto ldv_59183;
  case_2: /* CIL Label */ 
  {
#line 1043
  tmp___2 = ldv_xmalloc(40UL);
#line 1043
  cf_arg_2 = (struct ldv_struct_interrupt_instance_0 *)tmp___2;
#line 1044
  cf_arg_2->arg0 = arg0;
#line 1045
  cf_arg_2->arg1 = arg1;
#line 1046
  cf_arg_2->arg2 = arg2;
#line 1047
  cf_arg_2->arg3 = arg3;
#line 1048
  ldv_interrupt_interrupt_instance_2((void *)cf_arg_2);
  }
#line 1049
  goto ldv_59183;
  switch_default: /* CIL Label */ 
  {
#line 1051
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_59183: ;
#line 1053
  return;
}
}
#line 1057 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_register_19_2(struct pci_driver *arg0 ) 
{ 
  struct ldv_struct_pci_instance_3 *cf_arg_3 ;
  void *tmp ;

  {
  {
#line 1060
  tmp = ldv_xmalloc(16UL);
#line 1060
  cf_arg_3 = (struct ldv_struct_pci_instance_3 *)tmp;
#line 1061
  cf_arg_3->arg0 = arg0;
#line 1062
  ldv_pci_pci_instance_3((void *)cf_arg_3);
  }
#line 1063
  return;
}
}
#line 1067 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_register_dummy_factory_10_20_7(void) 
{ 
  struct ldv_struct_EMGentry_20 *cf_arg_13 ;
  void *tmp ;

  {
  {
#line 1070
  tmp = ldv_xmalloc(4UL);
#line 1070
  cf_arg_13 = (struct ldv_struct_EMGentry_20 *)tmp;
#line 1071
  ldv_timer_dummy_factory_13((void *)cf_arg_13);
  }
#line 1072
  return;
}
}
#line 1076 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_8_20_8(void) 
{ 
  struct ldv_struct_EMGentry_20 *cf_arg_5 ;
  struct ldv_struct_EMGentry_20 *cf_arg_6 ;
  struct ldv_struct_EMGentry_20 *cf_arg_7 ;
  struct ldv_struct_EMGentry_20 *cf_arg_8 ;
  struct ldv_struct_EMGentry_20 *cf_arg_9 ;
  struct ldv_struct_EMGentry_20 *cf_arg_10 ;
  struct ldv_struct_EMGentry_20 *cf_arg_11 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 1085
  tmp = ldv_xmalloc(4UL);
#line 1085
  cf_arg_5 = (struct ldv_struct_EMGentry_20 *)tmp;
#line 1086
  ldv_struct_device_attribute_dummy_resourceless_instance_5((void *)cf_arg_5);
#line 1087
  tmp___0 = ldv_xmalloc(4UL);
#line 1087
  cf_arg_6 = (struct ldv_struct_EMGentry_20 *)tmp___0;
#line 1088
  ldv_struct_device_attribute_dummy_resourceless_instance_6((void *)cf_arg_6);
#line 1089
  tmp___1 = ldv_xmalloc(4UL);
#line 1089
  cf_arg_7 = (struct ldv_struct_EMGentry_20 *)tmp___1;
#line 1090
  ldv_struct_device_attribute_dummy_resourceless_instance_7((void *)cf_arg_7);
#line 1091
  tmp___2 = ldv_xmalloc(4UL);
#line 1091
  cf_arg_8 = (struct ldv_struct_EMGentry_20 *)tmp___2;
#line 1092
  ldv_struct_device_attribute_dummy_resourceless_instance_8((void *)cf_arg_8);
#line 1093
  tmp___3 = ldv_xmalloc(4UL);
#line 1093
  cf_arg_9 = (struct ldv_struct_EMGentry_20 *)tmp___3;
#line 1094
  ldv_struct_device_attribute_dummy_resourceless_instance_9((void *)cf_arg_9);
#line 1095
  tmp___4 = ldv_xmalloc(4UL);
#line 1095
  cf_arg_10 = (struct ldv_struct_EMGentry_20 *)tmp___4;
#line 1096
  ldv_struct_device_attribute_dummy_resourceless_instance_10((void *)cf_arg_10);
#line 1097
  tmp___5 = ldv_xmalloc(4UL);
#line 1097
  cf_arg_11 = (struct ldv_struct_EMGentry_20 *)tmp___5;
#line 1098
  ldv_struct_device_attribute_dummy_resourceless_instance_11((void *)cf_arg_11);
  }
#line 1099
  return;
}
}
#line 1103 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dispatch_register_scsi_host_template_instance_7_20_9(void) 
{ 
  struct ldv_struct_EMGentry_20 *cf_arg_4 ;
  void *tmp ;

  {
  {
#line 1106
  tmp = ldv_xmalloc(4UL);
#line 1106
  cf_arg_4 = (struct ldv_struct_EMGentry_20 *)tmp;
#line 1107
  ldv_scsi_host_template_scsi_host_template_instance_4((void *)cf_arg_4);
  }
#line 1108
  return;
}
}
#line 1112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_10_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 1113
  beiscsi_log_enable_disp(arg1, arg2, arg3);
  }
#line 1114
  return;
}
}
#line 1117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_10_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1118
  beiscsi_log_enable_store(arg1, arg2, (char const   *)arg3, arg4);
  }
#line 1119
  return;
}
}
#line 1122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_11_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 1123
  beiscsi_phys_port_disp(arg1, arg2, arg3);
  }
#line 1124
  return;
}
}
#line 1127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_11_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1128
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1129
  return;
}
}
#line 1132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_5_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1133
  beiscsi_active_session_disp(arg1, arg2, arg3);
  }
#line 1134
  return;
}
}
#line 1137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_5_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1138
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1139
  return;
}
}
#line 1142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1143
  beiscsi_adap_family_disp(arg1, arg2, arg3);
  }
#line 1144
  return;
}
}
#line 1147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_6_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1148
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1149
  return;
}
}
#line 1152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_7_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1153
  beiscsi_drvr_ver_disp(arg1, arg2, arg3);
  }
#line 1154
  return;
}
}
#line 1157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_7_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1158
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1159
  return;
}
}
#line 1162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_8_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1163
  beiscsi_free_session_disp(arg1, arg2, arg3);
  }
#line 1164
  return;
}
}
#line 1167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_8_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1168
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1169
  return;
}
}
#line 1172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_9_3(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * ) , struct device *arg1 ,
                                                  struct device_attribute *arg2 ,
                                                  char *arg3 ) 
{ 


  {
  {
#line 1173
  beiscsi_fw_ver_disp(arg1, arg2, arg3);
  }
#line 1174
  return;
}
}
#line 1177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_dummy_resourceless_instance_callback_9_9(long (*arg0)(struct device * , struct device_attribute * ,
                                                               char * , unsigned long  ) ,
                                                  struct device *arg1 , struct device_attribute *arg2 ,
                                                  char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1178
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1179
  return;
}
}
#line 1182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_entry_EMGentry_20(void *arg0 ) 
{ 
  void (*ldv_20_exit_beiscsi_module_exit_default)(void) ;
  int (*ldv_20_init_beiscsi_module_init_default)(void) ;
  int ldv_20_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1191
  ldv_20_ret_default = ldv_EMGentry_init_beiscsi_module_init_20_13(ldv_20_init_beiscsi_module_init_default);
#line 1193
  ldv_20_ret_default = ldv_ldv_post_init_177(ldv_20_ret_default);
#line 1196
  tmp___0 = ldv_undef_int();
  }
#line 1196
  if (tmp___0 != 0) {
    {
#line 1198
    ldv_assume(ldv_20_ret_default != 0);
#line 1202
    ldv_ldv_check_final_state_178();
#line 1203
    ldv_stop();
    }
#line 1207
    return;
  } else {
    {
#line 1211
    ldv_assume(ldv_20_ret_default == 0);
#line 1214
    tmp = ldv_undef_int();
    }
#line 1214
    if (tmp != 0) {
      {
#line 1216
      ldv_dispatch_register_scsi_host_template_instance_7_20_9();
#line 1220
      ldv_dispatch_register_dummy_resourceless_instance_8_20_8();
#line 1224
      ldv_dispatch_register_dummy_factory_10_20_7();
#line 1228
      ldv_dispatch_deregister_scsi_host_template_instance_7_20_6();
#line 1232
      ldv_dispatch_deregister_dummy_resourceless_instance_8_20_5();
#line 1236
      ldv_dispatch_deregister_dummy_factory_10_20_4();
      }
    } else {

    }
    {
#line 1247
    ldv_EMGentry_exit_beiscsi_module_exit_20_2(ldv_20_exit_beiscsi_module_exit_default);
#line 1251
    ldv_ldv_check_final_state_179();
#line 1252
    ldv_stop();
    }
#line 1256
    return;
  }
#line 1259
  return;
}
}
#line 1264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void main(void) 
{ 


  {
  {
#line 1265
  ldv_ldv_initialize_180();
#line 1266
  ldv_entry_EMGentry_20((void *)0);
  }
#line 1267
  return;
}
}
#line 1271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) 
{ 
  int ldv_14_line_line ;

  {
  {
#line 1277
  ldv_14_line_line = arg1;
#line 1281
  ldv_dispatch_irq_deregister_14_1(ldv_14_line_line);
  }
#line 1285
  return;
#line 1287
  return;
}
}
#line 1292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
enum irqreturn ldv_interrupt_instance_handler_0_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 1293
  tmp = be_isr(arg1, arg2);
  }
#line 1293
  return (tmp);
}
}
#line 1297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
enum irqreturn ldv_interrupt_instance_handler_1_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 1298
  tmp = be_isr_mcc(arg1, arg2);
  }
#line 1298
  return (tmp);
}
}
#line 1302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
enum irqreturn ldv_interrupt_instance_handler_2_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  irqreturn_t tmp ;

  {
  {
#line 1303
  tmp = be_isr_msix(arg1, arg2);
  }
#line 1303
  return (tmp);
}
}
#line 1307 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_instance_thread_0_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 1308
  (*arg0)(arg1, arg2);
  }
#line 1309
  return;
}
}
#line 1312 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_instance_thread_1_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 1313
  (*arg0)(arg1, arg2);
  }
#line 1314
  return;
}
}
#line 1317 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_instance_thread_2_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 1318
  (*arg0)(arg1, arg2);
  }
#line 1319
  return;
}
}
#line 1322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_interrupt_instance_0(void *arg0 ) 
{ 
  enum irqreturn (*ldv_0_callback_handler)(int  , void * ) ;
  void *ldv_0_data_data ;
  int ldv_0_line_line ;
  enum irqreturn ldv_0_ret_val_default ;
  enum irqreturn (*ldv_0_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_0 *data ;
  int tmp ;

  {
#line 1331
  data = (struct ldv_struct_interrupt_instance_0 *)arg0;
#line 1336
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_0 *)0)) {
    {
#line 1337
    ldv_0_line_line = data->arg0;
#line 1338
    ldv_0_callback_handler = data->arg1;
#line 1339
    ldv_0_thread_thread = data->arg2;
#line 1340
    ldv_0_data_data = data->arg3;
#line 1341
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1347
  ldv_switch_to_interrupt_context();
#line 1349
  ldv_0_ret_val_default = ldv_interrupt_instance_handler_0_5(ldv_0_callback_handler,
                                                             ldv_0_line_line, ldv_0_data_data);
#line 1351
  ldv_switch_to_process_context();
#line 1354
  tmp = ldv_undef_int();
  }
#line 1354
  if (tmp != 0) {
    {
#line 1356
    ldv_assume((unsigned int )ldv_0_ret_val_default == 2U);
    }
#line 1360
    if ((unsigned long )ldv_0_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                    void * ))0)) {
      {
#line 1362
      ldv_interrupt_instance_thread_0_3(ldv_0_thread_thread, ldv_0_line_line, ldv_0_data_data);
      }
    } else {

    }
  } else {
    {
#line 1369
    ldv_assume((unsigned int )ldv_0_ret_val_default != 2U);
    }
  }
#line 1378
  return;
#line 1380
  return;
}
}
#line 1385 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_interrupt_instance_1(void *arg0 ) 
{ 
  enum irqreturn (*ldv_1_callback_handler)(int  , void * ) ;
  void *ldv_1_data_data ;
  int ldv_1_line_line ;
  enum irqreturn ldv_1_ret_val_default ;
  enum irqreturn (*ldv_1_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_0 *data ;
  int tmp ;

  {
#line 1394
  data = (struct ldv_struct_interrupt_instance_0 *)arg0;
#line 1399
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_0 *)0)) {
    {
#line 1400
    ldv_1_line_line = data->arg0;
#line 1401
    ldv_1_callback_handler = data->arg1;
#line 1402
    ldv_1_thread_thread = data->arg2;
#line 1403
    ldv_1_data_data = data->arg3;
#line 1404
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1410
  ldv_switch_to_interrupt_context();
#line 1412
  ldv_1_ret_val_default = ldv_interrupt_instance_handler_1_5(ldv_1_callback_handler,
                                                             ldv_1_line_line, ldv_1_data_data);
#line 1414
  ldv_switch_to_process_context();
#line 1417
  tmp = ldv_undef_int();
  }
#line 1417
  if (tmp != 0) {
    {
#line 1419
    ldv_assume((unsigned int )ldv_1_ret_val_default == 2U);
    }
#line 1423
    if ((unsigned long )ldv_1_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                    void * ))0)) {
      {
#line 1425
      ldv_interrupt_instance_thread_1_3(ldv_1_thread_thread, ldv_1_line_line, ldv_1_data_data);
      }
    } else {

    }
  } else {
    {
#line 1432
    ldv_assume((unsigned int )ldv_1_ret_val_default != 2U);
    }
  }
#line 1441
  return;
#line 1443
  return;
}
}
#line 1448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_interrupt_interrupt_instance_2(void *arg0 ) 
{ 
  enum irqreturn (*ldv_2_callback_handler)(int  , void * ) ;
  void *ldv_2_data_data ;
  int ldv_2_line_line ;
  enum irqreturn ldv_2_ret_val_default ;
  enum irqreturn (*ldv_2_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_0 *data ;
  int tmp ;

  {
#line 1457
  data = (struct ldv_struct_interrupt_instance_0 *)arg0;
#line 1462
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_0 *)0)) {
    {
#line 1463
    ldv_2_line_line = data->arg0;
#line 1464
    ldv_2_callback_handler = data->arg1;
#line 1465
    ldv_2_thread_thread = data->arg2;
#line 1466
    ldv_2_data_data = data->arg3;
#line 1467
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1473
  ldv_switch_to_interrupt_context();
#line 1475
  ldv_2_ret_val_default = ldv_interrupt_instance_handler_2_5(ldv_2_callback_handler,
                                                             ldv_2_line_line, ldv_2_data_data);
#line 1477
  ldv_switch_to_process_context();
#line 1480
  tmp = ldv_undef_int();
  }
#line 1480
  if (tmp != 0) {
    {
#line 1482
    ldv_assume((unsigned int )ldv_2_ret_val_default == 2U);
    }
#line 1486
    if ((unsigned long )ldv_2_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                    void * ))0)) {
      {
#line 1488
      ldv_interrupt_instance_thread_2_3(ldv_2_thread_thread, ldv_2_line_line, ldv_2_data_data);
      }
    } else {

    }
  } else {
    {
#line 1495
    ldv_assume((unsigned int )ldv_2_ret_val_default != 2U);
    }
  }
#line 1504
  return;
#line 1506
  return;
}
}
#line 1511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_callback_3_10(unsigned int (*arg0)(struct pci_dev * , enum pci_channel_state  ) ,
                                    struct pci_dev *arg1 , enum pci_channel_state arg2 ) 
{ 


  {
  {
#line 1512
  beiscsi_eeh_err_detected(arg1, (pci_channel_state_t )arg2);
  }
#line 1513
  return;
}
}
#line 1516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_callback_3_23(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1517
  beiscsi_eeh_resume(arg1);
  }
#line 1518
  return;
}
}
#line 1521 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_callback_3_24(unsigned int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1522
  beiscsi_eeh_reset(arg1);
  }
#line 1523
  return;
}
}
#line 1526 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
int ldv_pci_instance_probe_3_17(int (*arg0)(struct pci_dev * , struct pci_device_id * ) ,
                                struct pci_dev *arg1 , struct pci_device_id *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1527
  tmp = beiscsi_dev_probe(arg1, (struct pci_device_id  const  *)arg2);
  }
#line 1527
  return (tmp);
}
}
#line 1531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_release_3_2(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1532
  beiscsi_remove(arg1);
  }
#line 1533
  return;
}
}
#line 1536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_resume_3_5(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1537
  (*arg0)(arg1);
  }
#line 1538
  return;
}
}
#line 1541 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_resume_early_3_6(int (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1542
  (*arg0)(arg1);
  }
#line 1543
  return;
}
}
#line 1546 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_instance_shutdown_3_3(void (*arg0)(struct pci_dev * ) , struct pci_dev *arg1 ) 
{ 


  {
  {
#line 1547
  beiscsi_shutdown(arg1);
  }
#line 1548
  return;
}
}
#line 1551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
int ldv_pci_instance_suspend_3_8(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                 struct pci_dev *arg1 , struct pm_message arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1552
  tmp = (*arg0)(arg1, arg2);
  }
#line 1552
  return (tmp);
}
}
#line 1556 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
int ldv_pci_instance_suspend_late_3_7(int (*arg0)(struct pci_dev * , struct pm_message  ) ,
                                      struct pci_dev *arg1 , struct pm_message arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1557
  tmp = (*arg0)(arg1, arg2);
  }
#line 1557
  return (tmp);
}
}
#line 1561 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_pci_instance_3(void *arg0 ) 
{ 
  unsigned int (*ldv_3_callback_error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
  void (*ldv_3_callback_func_1_ptr)(struct pci_dev * ) ;
  unsigned int (*ldv_3_callback_slot_reset)(struct pci_dev * ) ;
  struct pci_driver *ldv_3_container_pci_driver ;
  struct pci_dev *ldv_3_resource_dev ;
  enum pci_channel_state ldv_3_resource_enum_pci_channel_state ;
  struct pm_message ldv_3_resource_pm_message ;
  struct pci_device_id *ldv_3_resource_struct_pci_device_id_ptr ;
  int ldv_3_ret_default ;
  struct ldv_struct_pci_instance_3 *data ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1574
  data = (struct ldv_struct_pci_instance_3 *)arg0;
#line 1578
  ldv_3_ret_default = 1;
#line 1581
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_pci_instance_3 *)0)) {
    {
#line 1582
    ldv_3_container_pci_driver = data->arg0;
#line 1583
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1588
  tmp = ldv_xmalloc(2968UL);
#line 1588
  ldv_3_resource_dev = (struct pci_dev *)tmp;
#line 1589
  tmp___0 = ldv_xmalloc(32UL);
#line 1589
  ldv_3_resource_struct_pci_device_id_ptr = (struct pci_device_id *)tmp___0;
  }
#line 1596
  goto ldv_main_3;
#line 1598
  return;
  ldv_main_3: 
  {
#line 1604
  tmp___2 = ldv_undef_int();
  }
#line 1604
  if (tmp___2 != 0) {
    {
#line 1607
    ldv_ldv_pre_probe_181();
#line 1609
    ldv_3_ret_default = ldv_pci_instance_probe_3_17((int (*)(struct pci_dev * , struct pci_device_id * ))ldv_3_container_pci_driver->probe,
                                                    ldv_3_resource_dev, ldv_3_resource_struct_pci_device_id_ptr);
#line 1611
    ldv_3_ret_default = ldv_ldv_post_probe_182(ldv_3_ret_default);
#line 1614
    tmp___1 = ldv_undef_int();
    }
#line 1614
    if (tmp___1 != 0) {
      {
#line 1616
      ldv_assume(ldv_3_ret_default == 0);
      }
#line 1623
      goto ldv_call_3;
    } else {
      {
#line 1627
      ldv_assume(ldv_3_ret_default != 0);
      }
#line 1634
      goto ldv_main_3;
    }
  } else {
    {
#line 1639
    ldv_free((void *)ldv_3_resource_dev);
#line 1640
    ldv_free((void *)ldv_3_resource_struct_pci_device_id_ptr);
    }
#line 1648
    return;
  }
#line 1651
  return;
  ldv_call_3: 
  {
#line 1657
  tmp___3 = ldv_undef_int();
  }
  {
#line 1658
  if (tmp___3 == 1) {
#line 1658
    goto case_1;
  } else {

  }
#line 1671
  if (tmp___3 == 2) {
#line 1671
    goto case_2;
  } else {

  }
#line 1686
  if (tmp___3 == 3) {
#line 1686
    goto case_3;
  } else {

  }
#line 1703
  if (tmp___3 == 4) {
#line 1703
    goto case_4;
  } else {

  }
#line 1743
  if (tmp___3 == 5) {
#line 1743
    goto case_5;
  } else {

  }
#line 1761
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1661
  ldv_pci_instance_callback_3_24(ldv_3_callback_slot_reset, ldv_3_resource_dev);
  }
#line 1668
  goto ldv_call_3;
  case_2: /* CIL Label */ 
  {
#line 1674
  ldv_pci_instance_callback_3_23(ldv_3_callback_func_1_ptr, ldv_3_resource_dev);
  }
#line 1681
  goto ldv_call_3;
#line 1683
  goto ldv_call_3;
  case_3: /* CIL Label */ 
  {
#line 1689
  ldv_pci_instance_callback_3_10(ldv_3_callback_error_detected, ldv_3_resource_dev,
                                 ldv_3_resource_enum_pci_channel_state);
  }
#line 1696
  goto ldv_call_3;
#line 1698
  goto ldv_call_3;
#line 1700
  goto ldv_call_3;
  case_4: /* CIL Label */ ;
#line 1705
  if ((unsigned long )ldv_3_container_pci_driver->suspend != (unsigned long )((int (*)(struct pci_dev * ,
                                                                                       pm_message_t  ))0)) {
    {
#line 1707
    ldv_3_ret_default = ldv_pci_instance_suspend_3_8(ldv_3_container_pci_driver->suspend,
                                                     ldv_3_resource_dev, ldv_3_resource_pm_message);
    }
  } else {

  }
  {
#line 1710
  ldv_3_ret_default = ldv_filter_err_code(ldv_3_ret_default);
  }
#line 1714
  if ((unsigned long )ldv_3_container_pci_driver->suspend_late != (unsigned long )((int (*)(struct pci_dev * ,
                                                                                            pm_message_t  ))0)) {
    {
#line 1716
    ldv_3_ret_default = ldv_pci_instance_suspend_late_3_7(ldv_3_container_pci_driver->suspend_late,
                                                          ldv_3_resource_dev, ldv_3_resource_pm_message);
    }
  } else {

  }
  {
#line 1719
  ldv_3_ret_default = ldv_filter_err_code(ldv_3_ret_default);
  }
#line 1723
  if ((unsigned long )ldv_3_container_pci_driver->resume_early != (unsigned long )((int (*)(struct pci_dev * ))0)) {
    {
#line 1725
    ldv_pci_instance_resume_early_3_6(ldv_3_container_pci_driver->resume_early, ldv_3_resource_dev);
    }
  } else {

  }
#line 1730
  if ((unsigned long )ldv_3_container_pci_driver->resume != (unsigned long )((int (*)(struct pci_dev * ))0)) {
    {
#line 1732
    ldv_pci_instance_resume_3_5(ldv_3_container_pci_driver->resume, ldv_3_resource_dev);
    }
  } else {

  }
#line 1740
  goto ldv_call_3;
  case_5: /* CIL Label */ 
  {
#line 1746
  ldv_pci_instance_shutdown_3_3(ldv_3_container_pci_driver->shutdown, ldv_3_resource_dev);
#line 1751
  ldv_pci_instance_release_3_2(ldv_3_container_pci_driver->remove, ldv_3_resource_dev);
  }
#line 1758
  goto ldv_main_3;
  switch_default: /* CIL Label */ 
  {
#line 1761
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1764
  return;
}
}
#line 1769 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_pci_unregister_driver(void *arg0 , struct pci_driver *arg1 ) 
{ 
  struct pci_driver *ldv_18_pci_driver_pci_driver ;

  {
  {
#line 1775
  ldv_18_pci_driver_pci_driver = arg1;
#line 1779
  ldv_dispatch_deregister_18_1(ldv_18_pci_driver_pci_driver);
  }
#line 1783
  return;
#line 1785
  return;
}
}
#line 1790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) 
{ 
  enum irqreturn (*ldv_17_callback_handler)(int  , void * ) ;
  void *ldv_17_data_data ;
  int ldv_17_line_line ;
  enum irqreturn (*ldv_17_thread_thread)(int  , void * ) ;
  int tmp ;

  {
  {
#line 1800
  tmp = ldv_undef_int();
  }
#line 1800
  if (tmp != 0) {
    {
#line 1802
    ldv_assume(arg0 == 0);
#line 1803
    ldv_17_line_line = (int )arg1;
#line 1804
    ldv_17_callback_handler = arg2;
#line 1805
    ldv_17_thread_thread = (enum irqreturn (*)(int  , void * ))0;
#line 1806
    ldv_17_data_data = arg5;
#line 1810
    ldv_dispatch_irq_register_17_2(ldv_17_line_line, ldv_17_callback_handler, ldv_17_thread_thread,
                                   ldv_17_data_data);
    }
#line 1814
    return (arg0);
  } else {
    {
#line 1818
    ldv_assume(arg0 != 0);
    }
#line 1822
    return (arg0);
  }
#line 1825
  return (arg0);
}
}
#line 1830 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_17(unsigned short (*arg0)(int  , int  ) ,
                                                   int arg1 , int arg2 ) 
{ 


  {
  {
#line 1831
  be2iscsi_attr_is_visible(arg1, arg2);
  }
#line 1832
  return;
}
}
#line 1835 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_20(int (*arg0)(struct iscsi_cls_session * ,
                                                               struct iscsi_cls_conn * ,
                                                               unsigned long long  ,
                                                               int  ) , struct iscsi_cls_session *arg1 ,
                                                   struct iscsi_cls_conn *arg2 , unsigned long long arg3 ,
                                                   int arg4 ) 
{ 


  {
  {
#line 1836
  beiscsi_conn_bind(arg1, arg2, arg3, arg4);
  }
#line 1837
  return;
}
}
#line 1840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_23(int (*arg0)(struct bsg_job * ) ,
                                                   struct bsg_job *arg1 ) 
{ 


  {
  {
#line 1841
  beiscsi_bsg_request(arg1);
  }
#line 1842
  return;
}
}
#line 1845 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_24(int (*arg0)(struct scsi_device * ,
                                                               int  ) , struct scsi_device *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 1846
  scsi_change_queue_depth(arg1, arg2);
  }
#line 1847
  return;
}
}
#line 1850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_27(void (*arg0)(struct iscsi_task * ) ,
                                                   struct iscsi_task *arg1 ) 
{ 


  {
  {
#line 1851
  beiscsi_cleanup_task(arg1);
  }
#line 1852
  return;
}
}
#line 1855 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_28(struct iscsi_cls_conn *(*arg0)(struct iscsi_cls_session * ,
                                                                                  unsigned int  ) ,
                                                   struct iscsi_cls_session *arg1 ,
                                                   unsigned int arg2 ) 
{ 


  {
  {
#line 1856
  beiscsi_conn_create(arg1, arg2);
  }
#line 1857
  return;
}
}
#line 1860 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_31(struct iscsi_cls_session *(*arg0)(struct iscsi_endpoint * ,
                                                                                     unsigned short  ,
                                                                                     unsigned short  ,
                                                                                     unsigned int  ) ,
                                                   struct iscsi_endpoint *arg1 , unsigned short arg2 ,
                                                   unsigned short arg3 , unsigned int arg4 ) 
{ 


  {
  {
#line 1861
  beiscsi_session_create(arg1, (int )arg2, (int )arg3, arg4);
  }
#line 1862
  return;
}
}
#line 1865 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_34(void (*arg0)(struct iscsi_cls_conn * ) ,
                                                   struct iscsi_cls_conn *arg1 ) 
{ 


  {
  {
#line 1866
  iscsi_conn_teardown(arg1);
  }
#line 1867
  return;
}
}
#line 1870 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_35(void (*arg0)(struct iscsi_cls_session * ) ,
                                                   struct iscsi_cls_session *arg1 ) 
{ 


  {
  {
#line 1871
  be2iscsi_fail_session(arg1);
  }
#line 1872
  return;
}
}
#line 1875 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_36(int (*arg0)(struct scsi_cmnd * ) ,
                                                   struct scsi_cmnd *arg1 ) 
{ 


  {
  {
#line 1876
  beiscsi_eh_abort(arg1);
  }
#line 1877
  return;
}
}
#line 1880 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_37(int (*arg0)(struct scsi_cmnd * ) ,
                                                   struct scsi_cmnd *arg1 ) 
{ 


  {
  {
#line 1881
  beiscsi_eh_device_reset(arg1);
  }
#line 1882
  return;
}
}
#line 1885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_38(int (*arg0)(struct scsi_cmnd * ) ,
                                                   struct scsi_cmnd *arg1 ) 
{ 


  {
  {
#line 1886
  iscsi_eh_session_reset(arg1);
  }
#line 1887
  return;
}
}
#line 1890 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_39(struct iscsi_endpoint *(*arg0)(struct Scsi_Host * ,
                                                                                  struct sockaddr * ,
                                                                                  int  ) ,
                                                   struct Scsi_Host *arg1 , struct sockaddr *arg2 ,
                                                   int arg3 ) 
{ 


  {
  {
#line 1891
  beiscsi_ep_connect(arg1, arg2, arg3);
  }
#line 1892
  return;
}
}
#line 1895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_4(int (*arg0)(struct iscsi_task * ,
                                                              unsigned char  ) , struct iscsi_task *arg1 ,
                                                  unsigned char arg2 ) 
{ 


  {
  {
#line 1896
  beiscsi_alloc_pdu(arg1, (int )arg2);
  }
#line 1897
  return;
}
}
#line 1900 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_42(void (*arg0)(struct iscsi_endpoint * ) ,
                                                   struct iscsi_endpoint *arg1 ) 
{ 


  {
  {
#line 1901
  beiscsi_ep_disconnect(arg1);
  }
#line 1902
  return;
}
}
#line 1905 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_43(int (*arg0)(struct iscsi_endpoint * ,
                                                               int  ) , struct iscsi_endpoint *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 1906
  beiscsi_ep_poll(arg1, arg2);
  }
#line 1907
  return;
}
}
#line 1910 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_46(int (*arg0)(struct iscsi_cls_conn * ,
                                                               enum iscsi_param  ,
                                                               char * ) , struct iscsi_cls_conn *arg1 ,
                                                   enum iscsi_param *arg2 , char *arg3 ) 
{ 


  {
  {
#line 1911
  iscsi_conn_get_param(arg1, *arg2, arg3);
  }
#line 1912
  return;
}
}
#line 1915 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_49(int (*arg0)(struct iscsi_endpoint * ,
                                                               enum iscsi_param  ,
                                                               char * ) , struct iscsi_endpoint *arg1 ,
                                                   enum iscsi_param *arg2 , char *arg3 ) 
{ 


  {
  {
#line 1916
  beiscsi_ep_get_param(arg1, *arg2, arg3);
  }
#line 1917
  return;
}
}
#line 1920 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_52(int (*arg0)(struct Scsi_Host * ,
                                                               enum iscsi_host_param  ,
                                                               char * ) , struct Scsi_Host *arg1 ,
                                                   enum iscsi_host_param *arg2 , char *arg3 ) 
{ 


  {
  {
#line 1921
  beiscsi_get_host_param(arg1, *arg2, arg3);
  }
#line 1922
  return;
}
}
#line 1925 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_55(int (*arg0)(struct iscsi_iface * ,
                                                               enum iscsi_param_type  ,
                                                               int  , char * ) , struct iscsi_iface *arg1 ,
                                                   enum iscsi_param_type *arg2 , int arg3 ,
                                                   char *arg4 ) 
{ 


  {
  {
#line 1926
  be2iscsi_iface_get_param(arg1, *arg2, arg3, arg4);
  }
#line 1927
  return;
}
}
#line 1930 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_58(int (*arg0)(struct iscsi_cls_session * ,
                                                               enum iscsi_param  ,
                                                               char * ) , struct iscsi_cls_session *arg1 ,
                                                   enum iscsi_param *arg2 , char *arg3 ) 
{ 


  {
  {
#line 1931
  iscsi_session_get_param(arg1, *arg2, arg3);
  }
#line 1932
  return;
}
}
#line 1935 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_61(void (*arg0)(struct iscsi_cls_conn * ,
                                                                struct iscsi_stats * ) ,
                                                   struct iscsi_cls_conn *arg1 , struct iscsi_stats *arg2 ) 
{ 


  {
  {
#line 1936
  beiscsi_conn_get_stats(arg1, arg2);
  }
#line 1937
  return;
}
}
#line 1940 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_64(void (*arg0)(struct iscsi_conn * ,
                                                                unsigned int  , int * ,
                                                                int * ) , struct iscsi_conn *arg1 ,
                                                   unsigned int arg2 , int *arg3 ,
                                                   int *arg4 ) 
{ 


  {
  {
#line 1941
  beiscsi_parse_pdu(arg1, arg2, arg3, arg4);
  }
#line 1942
  return;
}
}
#line 1945 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_67(int (*arg0)(struct Scsi_Host * ,
                                                               struct scsi_cmnd * ) ,
                                                   struct Scsi_Host *arg1 , struct scsi_cmnd *arg2 ) 
{ 


  {
  {
#line 1946
  iscsi_queuecommand(arg1, arg2);
  }
#line 1947
  return;
}
}
#line 1950 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_68(int (*arg0)(struct iscsi_cls_conn * ,
                                                               struct iscsi_hdr * ,
                                                               char * , unsigned int  ) ,
                                                   struct iscsi_cls_conn *arg1 , struct iscsi_hdr *arg2 ,
                                                   char *arg3 , unsigned int arg4 ) 
{ 


  {
  {
#line 1951
  iscsi_conn_send_pdu(arg1, arg2, arg3, arg4);
  }
#line 1952
  return;
}
}
#line 1955 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_71(void (*arg0)(struct iscsi_cls_session * ) ,
                                                   struct iscsi_cls_session *arg1 ) 
{ 


  {
  {
#line 1956
  iscsi_session_recovery_timedout(arg1);
  }
#line 1957
  return;
}
}
#line 1960 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_72(int (*arg0)(struct Scsi_Host * ,
                                                               void * , unsigned int  ) ,
                                                   struct Scsi_Host *arg1 , void *arg2 ,
                                                   unsigned int arg3 ) 
{ 


  {
  {
#line 1961
  be2iscsi_iface_set_param(arg1, arg2, arg3);
  }
#line 1962
  return;
}
}
#line 1965 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_75(int (*arg0)(struct iscsi_cls_conn * ,
                                                               enum iscsi_param  ,
                                                               char * , int  ) , struct iscsi_cls_conn *arg1 ,
                                                   enum iscsi_param *arg2 , char *arg3 ,
                                                   int arg4 ) 
{ 


  {
  {
#line 1966
  beiscsi_set_param(arg1, *arg2, arg3, arg4);
  }
#line 1967
  return;
}
}
#line 1970 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_78(int (*arg0)(struct scsi_device * ) ,
                                                   struct scsi_device *arg1 ) 
{ 


  {
  {
#line 1971
  beiscsi_slave_configure(arg1);
  }
#line 1972
  return;
}
}
#line 1975 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_79(int (*arg0)(struct iscsi_cls_conn * ) ,
                                                   struct iscsi_cls_conn *arg1 ) 
{ 


  {
  {
#line 1976
  beiscsi_conn_start(arg1);
  }
#line 1977
  return;
}
}
#line 1980 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_80(void (*arg0)(struct iscsi_cls_conn * ,
                                                                int  ) , struct iscsi_cls_conn *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 1981
  iscsi_conn_stop(arg1, arg2);
  }
#line 1982
  return;
}
}
#line 1985 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_83(int (*arg0)(struct scsi_target * ) ,
                                                   struct scsi_target *arg1 ) 
{ 


  {
  {
#line 1986
  iscsi_target_alloc(arg1);
  }
#line 1987
  return;
}
}
#line 1990 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_callback_4_84(int (*arg0)(struct iscsi_task * ) ,
                                                   struct iscsi_task *arg1 ) 
{ 


  {
  {
#line 1991
  beiscsi_task_xmit(arg1);
  }
#line 1992
  return;
}
}
#line 1995 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
int ldv_scsi_host_template_instance_probe_4_10(int (*arg0)(struct Scsi_Host * ) ,
                                               struct Scsi_Host *arg1 ) 
{ 
  int tmp ;

  {
  {
#line 1996
  tmp = (*arg0)(arg1);
  }
#line 1996
  return (tmp);
}
}
#line 2000 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_instance_release_4_2(int (*arg0)(struct Scsi_Host * ) ,
                                                 struct Scsi_Host *arg1 ) 
{ 


  {
  {
#line 2001
  (*arg0)(arg1);
  }
#line 2002
  return;
}
}
#line 2005 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_scsi_host_template_scsi_host_template_instance_4(void *arg0 ) 
{ 
  int (*ldv_4_callback_alloc_pdu)(struct iscsi_task * , unsigned char  ) ;
  unsigned short (*ldv_4_callback_attr_is_visible)(int  , int  ) ;
  int (*ldv_4_callback_bind_conn)(struct iscsi_cls_session * , struct iscsi_cls_conn * ,
                                  unsigned long long  , int  ) ;
  int (*ldv_4_callback_bsg_request)(struct bsg_job * ) ;
  int (*ldv_4_callback_change_queue_depth)(struct scsi_device * , int  ) ;
  void (*ldv_4_callback_cleanup_task)(struct iscsi_task * ) ;
  struct iscsi_cls_conn *(*ldv_4_callback_create_conn)(struct iscsi_cls_session * ,
                                                       unsigned int  ) ;
  struct iscsi_cls_session *(*ldv_4_callback_create_session)(struct iscsi_endpoint * ,
                                                             unsigned short  , unsigned short  ,
                                                             unsigned int  ) ;
  void (*ldv_4_callback_destroy_conn)(struct iscsi_cls_conn * ) ;
  void (*ldv_4_callback_destroy_session)(struct iscsi_cls_session * ) ;
  int (*ldv_4_callback_eh_abort_handler)(struct scsi_cmnd * ) ;
  int (*ldv_4_callback_eh_device_reset_handler)(struct scsi_cmnd * ) ;
  int (*ldv_4_callback_eh_target_reset_handler)(struct scsi_cmnd * ) ;
  struct iscsi_endpoint *(*ldv_4_callback_ep_connect)(struct Scsi_Host * , struct sockaddr * ,
                                                      int  ) ;
  void (*ldv_4_callback_ep_disconnect)(struct iscsi_endpoint * ) ;
  int (*ldv_4_callback_ep_poll)(struct iscsi_endpoint * , int  ) ;
  int (*ldv_4_callback_get_conn_param)(struct iscsi_cls_conn * , enum iscsi_param  ,
                                       char * ) ;
  int (*ldv_4_callback_get_ep_param)(struct iscsi_endpoint * , enum iscsi_param  ,
                                     char * ) ;
  int (*ldv_4_callback_get_host_param)(struct Scsi_Host * , enum iscsi_host_param  ,
                                       char * ) ;
  int (*ldv_4_callback_get_iface_param)(struct iscsi_iface * , enum iscsi_param_type  ,
                                        int  , char * ) ;
  int (*ldv_4_callback_get_session_param)(struct iscsi_cls_session * , enum iscsi_param  ,
                                          char * ) ;
  void (*ldv_4_callback_get_stats)(struct iscsi_cls_conn * , struct iscsi_stats * ) ;
  void (*ldv_4_callback_parse_pdu_itt)(struct iscsi_conn * , unsigned int  , int * ,
                                       int * ) ;
  int (*ldv_4_callback_queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
  int (*ldv_4_callback_send_pdu)(struct iscsi_cls_conn * , struct iscsi_hdr * , char * ,
                                 unsigned int  ) ;
  void (*ldv_4_callback_session_recovery_timedout)(struct iscsi_cls_session * ) ;
  int (*ldv_4_callback_set_iface_param)(struct Scsi_Host * , void * , unsigned int  ) ;
  int (*ldv_4_callback_set_param)(struct iscsi_cls_conn * , enum iscsi_param  , char * ,
                                  int  ) ;
  int (*ldv_4_callback_slave_configure)(struct scsi_device * ) ;
  int (*ldv_4_callback_start_conn)(struct iscsi_cls_conn * ) ;
  void (*ldv_4_callback_stop_conn)(struct iscsi_cls_conn * , int  ) ;
  int (*ldv_4_callback_target_alloc)(struct scsi_target * ) ;
  int (*ldv_4_callback_xmit_task)(struct iscsi_task * ) ;
  struct Scsi_Host *ldv_4_host_host ;
  struct bsg_job *ldv_4_host_struct_bsg_job_ptr ;
  struct iscsi_cls_conn *ldv_4_host_struct_iscsi_cls_conn_ptr ;
  struct iscsi_cls_session *ldv_4_host_struct_iscsi_cls_session_ptr ;
  struct iscsi_conn *ldv_4_host_struct_iscsi_conn_ptr ;
  struct iscsi_endpoint *ldv_4_host_struct_iscsi_endpoint_ptr ;
  struct iscsi_task *ldv_4_host_struct_iscsi_task_ptr ;
  struct scsi_cmnd *ldv_4_host_struct_scsi_cmnd_ptr ;
  struct scsi_device *ldv_4_host_struct_scsi_device_ptr ;
  struct scsi_target *ldv_4_host_struct_scsi_target_ptr ;
  int ldv_4_ldv_param_17_0_default ;
  int ldv_4_ldv_param_17_1_default ;
  unsigned long long ldv_4_ldv_param_20_2_default ;
  int ldv_4_ldv_param_20_3_default ;
  int ldv_4_ldv_param_24_1_default ;
  unsigned int ldv_4_ldv_param_28_1_default ;
  unsigned short ldv_4_ldv_param_31_1_default ;
  unsigned short ldv_4_ldv_param_31_2_default ;
  unsigned int ldv_4_ldv_param_31_3_default ;
  struct sockaddr *ldv_4_ldv_param_39_1_default ;
  int ldv_4_ldv_param_39_2_default ;
  int ldv_4_ldv_param_43_1_default ;
  enum iscsi_param *ldv_4_ldv_param_46_1_default ;
  char *ldv_4_ldv_param_46_2_default ;
  enum iscsi_param *ldv_4_ldv_param_49_1_default ;
  char *ldv_4_ldv_param_49_2_default ;
  unsigned char ldv_4_ldv_param_4_1_default ;
  enum iscsi_host_param *ldv_4_ldv_param_52_1_default ;
  char *ldv_4_ldv_param_52_2_default ;
  struct iscsi_iface *ldv_4_ldv_param_55_0_default ;
  enum iscsi_param_type *ldv_4_ldv_param_55_1_default ;
  int ldv_4_ldv_param_55_2_default ;
  char *ldv_4_ldv_param_55_3_default ;
  enum iscsi_param *ldv_4_ldv_param_58_1_default ;
  char *ldv_4_ldv_param_58_2_default ;
  struct iscsi_stats *ldv_4_ldv_param_61_1_default ;
  unsigned int ldv_4_ldv_param_64_1_default ;
  int *ldv_4_ldv_param_64_2_default ;
  int *ldv_4_ldv_param_64_3_default ;
  struct iscsi_hdr *ldv_4_ldv_param_68_1_default ;
  char *ldv_4_ldv_param_68_2_default ;
  unsigned int ldv_4_ldv_param_68_3_default ;
  unsigned int ldv_4_ldv_param_72_2_default ;
  enum iscsi_param *ldv_4_ldv_param_75_1_default ;
  char *ldv_4_ldv_param_75_2_default ;
  int ldv_4_ldv_param_75_3_default ;
  int ldv_4_ldv_param_80_1_default ;
  int ldv_4_ret_default ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;

  {
#line 2091
  ldv_4_ret_default = 1;
#line 2099
  goto ldv_main_4;
#line 2101
  return;
  ldv_main_4: 
  {
#line 2107
  tmp___0 = ldv_undef_int();
  }
#line 2107
  if (tmp___0 != 0) {
    {
#line 2110
    ldv_ldv_pre_probe_183();
    }
#line 2111
    if ((unsigned long )(ldv_4_host_host->hostt)->detect != (unsigned long )((int (*)(struct scsi_host_template * ))0)) {
      {
#line 2113
      ldv_4_ret_default = ldv_scsi_host_template_instance_probe_4_10((int (*)(struct Scsi_Host * ))(ldv_4_host_host->hostt)->detect,
                                                                     ldv_4_host_host);
      }
    } else {

    }
    {
#line 2116
    ldv_4_ret_default = ldv_ldv_post_probe_184(ldv_4_ret_default);
#line 2119
    tmp = ldv_undef_int();
    }
#line 2119
    if (tmp != 0) {
      {
#line 2121
      ldv_assume(ldv_4_ret_default == 0);
      }
#line 2128
      goto ldv_call_4;
    } else {
      {
#line 2132
      ldv_assume(ldv_4_ret_default != 0);
      }
#line 2139
      goto ldv_main_4;
    }
  } else {
#line 2148
    return;
  }
#line 2151
  return;
  ldv_call_4: 
  {
#line 2157
  tmp___21 = ldv_undef_int();
  }
#line 2157
  if (tmp___21 != 0) {
#line 2159
    if ((unsigned long )(ldv_4_host_host->hostt)->release != (unsigned long )((int (*)(struct Scsi_Host * ))0)) {
      {
#line 2161
      ldv_scsi_host_template_instance_release_4_2((ldv_4_host_host->hostt)->release,
                                                  ldv_4_host_host);
      }
    } else {

    }
#line 2169
    goto ldv_main_4;
  } else {
    {
#line 2175
    tmp___1 = ldv_undef_int();
    }
    {
#line 2176
    if (tmp___1 == 1) {
#line 2176
      goto case_1;
    } else {

    }
#line 2184
    if (tmp___1 == 2) {
#line 2184
      goto case_2;
    } else {

    }
#line 2192
    if (tmp___1 == 3) {
#line 2192
      goto case_3;
    } else {

    }
#line 2206
    if (tmp___1 == 4) {
#line 2206
      goto case_4;
    } else {

    }
#line 2214
    if (tmp___1 == 5) {
#line 2214
      goto case_5;
    } else {

    }
#line 2222
    if (tmp___1 == 6) {
#line 2222
      goto case_6;
    } else {

    }
#line 2240
    if (tmp___1 == 7) {
#line 2240
      goto case_7;
    } else {

    }
#line 2254
    if (tmp___1 == 8) {
#line 2254
      goto case_8;
    } else {

    }
#line 2262
    if (tmp___1 == 9) {
#line 2262
      goto case_9;
    } else {

    }
#line 2280
    if (tmp___1 == 10) {
#line 2280
      goto case_10;
    } else {

    }
#line 2288
    if (tmp___1 == 11) {
#line 2288
      goto case_11;
    } else {

    }
#line 2306
    if (tmp___1 == 12) {
#line 2306
      goto case_12;
    } else {

    }
#line 2322
    if (tmp___1 == 13) {
#line 2322
      goto case_13;
    } else {

    }
#line 2340
    if (tmp___1 == 14) {
#line 2340
      goto case_14;
    } else {

    }
#line 2360
    if (tmp___1 == 15) {
#line 2360
      goto case_15;
    } else {

    }
#line 2378
    if (tmp___1 == 16) {
#line 2378
      goto case_16;
    } else {

    }
#line 2396
    if (tmp___1 == 17) {
#line 2396
      goto case_17;
    } else {

    }
#line 2414
    if (tmp___1 == 18) {
#line 2414
      goto case_18;
    } else {

    }
#line 2428
    if (tmp___1 == 19) {
#line 2428
      goto case_19;
    } else {

    }
#line 2436
    if (tmp___1 == 20) {
#line 2436
      goto case_20;
    } else {

    }
#line 2452
    if (tmp___1 == 21) {
#line 2452
      goto case_21;
    } else {

    }
#line 2460
    if (tmp___1 == 22) {
#line 2460
      goto case_22;
    } else {

    }
#line 2468
    if (tmp___1 == 23) {
#line 2468
      goto case_23;
    } else {

    }
#line 2476
    if (tmp___1 == 24) {
#line 2476
      goto case_24;
    } else {

    }
#line 2484
    if (tmp___1 == 25) {
#line 2484
      goto case_25;
    } else {

    }
#line 2492
    if (tmp___1 == 26) {
#line 2492
      goto case_26;
    } else {

    }
#line 2506
    if (tmp___1 == 27) {
#line 2506
      goto case_27;
    } else {

    }
#line 2520
    if (tmp___1 == 28) {
#line 2520
      goto case_28;
    } else {

    }
#line 2528
    if (tmp___1 == 29) {
#line 2528
      goto case_29;
    } else {

    }
#line 2542
    if (tmp___1 == 30) {
#line 2542
      goto case_30;
    } else {

    }
#line 2550
    if (tmp___1 == 31) {
#line 2550
      goto case_31;
    } else {

    }
#line 2564
    if (tmp___1 == 32) {
#line 2564
      goto case_32;
    } else {

    }
#line 2578
    if (tmp___1 == 33) {
#line 2578
      goto case_33;
    } else {

    }
#line 2586
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 2179
    ldv_scsi_host_template_instance_callback_4_84(ldv_4_callback_xmit_task, ldv_4_host_struct_iscsi_task_ptr);
    }
#line 2182
    goto ldv_59962;
    case_2: /* CIL Label */ 
    {
#line 2187
    ldv_scsi_host_template_instance_callback_4_83(ldv_4_callback_target_alloc, ldv_4_host_struct_scsi_target_ptr);
    }
#line 2190
    goto ldv_59962;
    case_3: /* CIL Label */ 
    {
#line 2198
    ldv_scsi_host_template_instance_callback_4_80(ldv_4_callback_stop_conn, ldv_4_host_struct_iscsi_cls_conn_ptr,
                                                  ldv_4_ldv_param_80_1_default);
    }
#line 2204
    goto ldv_59962;
    case_4: /* CIL Label */ 
    {
#line 2209
    ldv_scsi_host_template_instance_callback_4_79(ldv_4_callback_start_conn, ldv_4_host_struct_iscsi_cls_conn_ptr);
    }
#line 2212
    goto ldv_59962;
    case_5: /* CIL Label */ 
    {
#line 2217
    ldv_scsi_host_template_instance_callback_4_78(ldv_4_callback_slave_configure,
                                                  ldv_4_host_struct_scsi_device_ptr);
    }
#line 2220
    goto ldv_59962;
    case_6: /* CIL Label */ 
    {
#line 2224
    tmp___2 = ldv_xmalloc(4UL);
#line 2224
    ldv_4_ldv_param_75_1_default = (enum iscsi_param *)tmp___2;
#line 2225
    tmp___3 = ldv_xmalloc(1UL);
#line 2225
    ldv_4_ldv_param_75_2_default = (char *)tmp___3;
#line 2230
    ldv_scsi_host_template_instance_callback_4_75(ldv_4_callback_set_param, ldv_4_host_struct_iscsi_cls_conn_ptr,
                                                  ldv_4_ldv_param_75_1_default, ldv_4_ldv_param_75_2_default,
                                                  ldv_4_ldv_param_75_3_default);
#line 2234
    ldv_free((void *)ldv_4_ldv_param_75_1_default);
#line 2235
    ldv_free((void *)ldv_4_ldv_param_75_2_default);
    }
#line 2238
    goto ldv_59962;
    case_7: /* CIL Label */ 
    {
#line 2246
    ldv_scsi_host_template_instance_callback_4_72(ldv_4_callback_set_iface_param,
                                                  ldv_4_host_host, (void *)ldv_4_host_struct_bsg_job_ptr,
                                                  ldv_4_ldv_param_72_2_default);
    }
#line 2252
    goto ldv_59962;
    case_8: /* CIL Label */ 
    {
#line 2257
    ldv_scsi_host_template_instance_callback_4_71(ldv_4_callback_session_recovery_timedout,
                                                  ldv_4_host_struct_iscsi_cls_session_ptr);
    }
#line 2260
    goto ldv_59962;
    case_9: /* CIL Label */ 
    {
#line 2264
    tmp___4 = ldv_xmalloc(48UL);
#line 2264
    ldv_4_ldv_param_68_1_default = (struct iscsi_hdr *)tmp___4;
#line 2265
    tmp___5 = ldv_xmalloc(1UL);
#line 2265
    ldv_4_ldv_param_68_2_default = (char *)tmp___5;
#line 2270
    ldv_scsi_host_template_instance_callback_4_68(ldv_4_callback_send_pdu, ldv_4_host_struct_iscsi_cls_conn_ptr,
                                                  ldv_4_ldv_param_68_1_default, ldv_4_ldv_param_68_2_default,
                                                  ldv_4_ldv_param_68_3_default);
#line 2274
    ldv_free((void *)ldv_4_ldv_param_68_1_default);
#line 2275
    ldv_free((void *)ldv_4_ldv_param_68_2_default);
    }
#line 2278
    goto ldv_59962;
    case_10: /* CIL Label */ 
    {
#line 2283
    ldv_scsi_host_template_instance_callback_4_67(ldv_4_callback_queuecommand, ldv_4_host_host,
                                                  ldv_4_host_struct_scsi_cmnd_ptr);
    }
#line 2286
    goto ldv_59962;
    case_11: /* CIL Label */ 
    {
#line 2290
    tmp___6 = ldv_xmalloc(4UL);
#line 2290
    ldv_4_ldv_param_64_2_default = (int *)tmp___6;
#line 2291
    tmp___7 = ldv_xmalloc(4UL);
#line 2291
    ldv_4_ldv_param_64_3_default = (int *)tmp___7;
#line 2296
    ldv_scsi_host_template_instance_callback_4_64(ldv_4_callback_parse_pdu_itt, ldv_4_host_struct_iscsi_conn_ptr,
                                                  ldv_4_ldv_param_64_1_default, ldv_4_ldv_param_64_2_default,
                                                  ldv_4_ldv_param_64_3_default);
#line 2300
    ldv_free((void *)ldv_4_ldv_param_64_2_default);
#line 2301
    ldv_free((void *)ldv_4_ldv_param_64_3_default);
    }
#line 2304
    goto ldv_59962;
    case_12: /* CIL Label */ 
    {
#line 2308
    tmp___8 = ldv_xmalloc(96UL);
#line 2308
    ldv_4_ldv_param_61_1_default = (struct iscsi_stats *)tmp___8;
#line 2313
    ldv_scsi_host_template_instance_callback_4_61(ldv_4_callback_get_stats, ldv_4_host_struct_iscsi_cls_conn_ptr,
                                                  ldv_4_ldv_param_61_1_default);
#line 2317
    ldv_free((void *)ldv_4_ldv_param_61_1_default);
    }
#line 2320
    goto ldv_59962;
    case_13: /* CIL Label */ 
    {
#line 2324
    tmp___9 = ldv_xmalloc(4UL);
#line 2324
    ldv_4_ldv_param_58_1_default = (enum iscsi_param *)tmp___9;
#line 2325
    tmp___10 = ldv_xmalloc(1UL);
#line 2325
    ldv_4_ldv_param_58_2_default = (char *)tmp___10;
#line 2330
    ldv_scsi_host_template_instance_callback_4_58(ldv_4_callback_get_session_param,
                                                  ldv_4_host_struct_iscsi_cls_session_ptr,
                                                  ldv_4_ldv_param_58_1_default, ldv_4_ldv_param_58_2_default);
#line 2334
    ldv_free((void *)ldv_4_ldv_param_58_1_default);
#line 2335
    ldv_free((void *)ldv_4_ldv_param_58_2_default);
    }
#line 2338
    goto ldv_59962;
    case_14: /* CIL Label */ 
    {
#line 2342
    tmp___11 = ldv_xmalloc(1432UL);
#line 2342
    ldv_4_ldv_param_55_0_default = (struct iscsi_iface *)tmp___11;
#line 2343
    tmp___12 = ldv_xmalloc(4UL);
#line 2343
    ldv_4_ldv_param_55_1_default = (enum iscsi_param_type *)tmp___12;
#line 2344
    tmp___13 = ldv_xmalloc(1UL);
#line 2344
    ldv_4_ldv_param_55_3_default = (char *)tmp___13;
#line 2349
    ldv_scsi_host_template_instance_callback_4_55(ldv_4_callback_get_iface_param,
                                                  ldv_4_ldv_param_55_0_default, ldv_4_ldv_param_55_1_default,
                                                  ldv_4_ldv_param_55_2_default, ldv_4_ldv_param_55_3_default);
#line 2353
    ldv_free((void *)ldv_4_ldv_param_55_0_default);
#line 2354
    ldv_free((void *)ldv_4_ldv_param_55_1_default);
#line 2355
    ldv_free((void *)ldv_4_ldv_param_55_3_default);
    }
#line 2358
    goto ldv_59962;
    case_15: /* CIL Label */ 
    {
#line 2362
    tmp___14 = ldv_xmalloc(4UL);
#line 2362
    ldv_4_ldv_param_52_1_default = (enum iscsi_host_param *)tmp___14;
#line 2363
    tmp___15 = ldv_xmalloc(1UL);
#line 2363
    ldv_4_ldv_param_52_2_default = (char *)tmp___15;
#line 2368
    ldv_scsi_host_template_instance_callback_4_52(ldv_4_callback_get_host_param, ldv_4_host_host,
                                                  ldv_4_ldv_param_52_1_default, ldv_4_ldv_param_52_2_default);
#line 2372
    ldv_free((void *)ldv_4_ldv_param_52_1_default);
#line 2373
    ldv_free((void *)ldv_4_ldv_param_52_2_default);
    }
#line 2376
    goto ldv_59962;
    case_16: /* CIL Label */ 
    {
#line 2380
    tmp___16 = ldv_xmalloc(4UL);
#line 2380
    ldv_4_ldv_param_49_1_default = (enum iscsi_param *)tmp___16;
#line 2381
    tmp___17 = ldv_xmalloc(1UL);
#line 2381
    ldv_4_ldv_param_49_2_default = (char *)tmp___17;
#line 2386
    ldv_scsi_host_template_instance_callback_4_49(ldv_4_callback_get_ep_param, ldv_4_host_struct_iscsi_endpoint_ptr,
                                                  ldv_4_ldv_param_49_1_default, ldv_4_ldv_param_49_2_default);
#line 2390
    ldv_free((void *)ldv_4_ldv_param_49_1_default);
#line 2391
    ldv_free((void *)ldv_4_ldv_param_49_2_default);
    }
#line 2394
    goto ldv_59962;
    case_17: /* CIL Label */ 
    {
#line 2398
    tmp___18 = ldv_xmalloc(4UL);
#line 2398
    ldv_4_ldv_param_46_1_default = (enum iscsi_param *)tmp___18;
#line 2399
    tmp___19 = ldv_xmalloc(1UL);
#line 2399
    ldv_4_ldv_param_46_2_default = (char *)tmp___19;
#line 2404
    ldv_scsi_host_template_instance_callback_4_46(ldv_4_callback_get_conn_param, ldv_4_host_struct_iscsi_cls_conn_ptr,
                                                  ldv_4_ldv_param_46_1_default, ldv_4_ldv_param_46_2_default);
#line 2408
    ldv_free((void *)ldv_4_ldv_param_46_1_default);
#line 2409
    ldv_free((void *)ldv_4_ldv_param_46_2_default);
    }
#line 2412
    goto ldv_59962;
    case_18: /* CIL Label */ 
    {
#line 2420
    ldv_scsi_host_template_instance_callback_4_43(ldv_4_callback_ep_poll, ldv_4_host_struct_iscsi_endpoint_ptr,
                                                  ldv_4_ldv_param_43_1_default);
    }
#line 2426
    goto ldv_59962;
    case_19: /* CIL Label */ 
    {
#line 2431
    ldv_scsi_host_template_instance_callback_4_42(ldv_4_callback_ep_disconnect, ldv_4_host_struct_iscsi_endpoint_ptr);
    }
#line 2434
    goto ldv_59962;
    case_20: /* CIL Label */ 
    {
#line 2438
    tmp___20 = ldv_xmalloc(16UL);
#line 2438
    ldv_4_ldv_param_39_1_default = (struct sockaddr *)tmp___20;
#line 2443
    ldv_scsi_host_template_instance_callback_4_39(ldv_4_callback_ep_connect, ldv_4_host_host,
                                                  ldv_4_ldv_param_39_1_default, ldv_4_ldv_param_39_2_default);
#line 2447
    ldv_free((void *)ldv_4_ldv_param_39_1_default);
    }
#line 2450
    goto ldv_59962;
    case_21: /* CIL Label */ 
    {
#line 2455
    ldv_scsi_host_template_instance_callback_4_38(ldv_4_callback_eh_target_reset_handler,
                                                  ldv_4_host_struct_scsi_cmnd_ptr);
    }
#line 2458
    goto ldv_59962;
    case_22: /* CIL Label */ 
    {
#line 2463
    ldv_scsi_host_template_instance_callback_4_37(ldv_4_callback_eh_device_reset_handler,
                                                  ldv_4_host_struct_scsi_cmnd_ptr);
    }
#line 2466
    goto ldv_59962;
    case_23: /* CIL Label */ 
    {
#line 2471
    ldv_scsi_host_template_instance_callback_4_36(ldv_4_callback_eh_abort_handler,
                                                  ldv_4_host_struct_scsi_cmnd_ptr);
    }
#line 2474
    goto ldv_59962;
    case_24: /* CIL Label */ 
    {
#line 2479
    ldv_scsi_host_template_instance_callback_4_35(ldv_4_callback_destroy_session,
                                                  ldv_4_host_struct_iscsi_cls_session_ptr);
    }
#line 2482
    goto ldv_59962;
    case_25: /* CIL Label */ 
    {
#line 2487
    ldv_scsi_host_template_instance_callback_4_34(ldv_4_callback_destroy_conn, ldv_4_host_struct_iscsi_cls_conn_ptr);
    }
#line 2490
    goto ldv_59962;
    case_26: /* CIL Label */ 
    {
#line 2498
    ldv_scsi_host_template_instance_callback_4_31(ldv_4_callback_create_session, ldv_4_host_struct_iscsi_endpoint_ptr,
                                                  (int )ldv_4_ldv_param_31_1_default,
                                                  (int )ldv_4_ldv_param_31_2_default,
                                                  ldv_4_ldv_param_31_3_default);
    }
#line 2504
    goto ldv_59962;
    case_27: /* CIL Label */ 
    {
#line 2512
    ldv_scsi_host_template_instance_callback_4_28(ldv_4_callback_create_conn, ldv_4_host_struct_iscsi_cls_session_ptr,
                                                  ldv_4_ldv_param_28_1_default);
    }
#line 2518
    goto ldv_59962;
    case_28: /* CIL Label */ 
    {
#line 2523
    ldv_scsi_host_template_instance_callback_4_27(ldv_4_callback_cleanup_task, ldv_4_host_struct_iscsi_task_ptr);
    }
#line 2526
    goto ldv_59962;
    case_29: /* CIL Label */ 
    {
#line 2534
    ldv_scsi_host_template_instance_callback_4_24(ldv_4_callback_change_queue_depth,
                                                  ldv_4_host_struct_scsi_device_ptr,
                                                  ldv_4_ldv_param_24_1_default);
    }
#line 2540
    goto ldv_59962;
    case_30: /* CIL Label */ 
    {
#line 2545
    ldv_scsi_host_template_instance_callback_4_23(ldv_4_callback_bsg_request, ldv_4_host_struct_bsg_job_ptr);
    }
#line 2548
    goto ldv_59962;
    case_31: /* CIL Label */ 
    {
#line 2556
    ldv_scsi_host_template_instance_callback_4_20(ldv_4_callback_bind_conn, ldv_4_host_struct_iscsi_cls_session_ptr,
                                                  ldv_4_host_struct_iscsi_cls_conn_ptr,
                                                  ldv_4_ldv_param_20_2_default, ldv_4_ldv_param_20_3_default);
    }
#line 2562
    goto ldv_59962;
    case_32: /* CIL Label */ 
    {
#line 2570
    ldv_scsi_host_template_instance_callback_4_17(ldv_4_callback_attr_is_visible,
                                                  ldv_4_ldv_param_17_0_default, ldv_4_ldv_param_17_1_default);
    }
#line 2576
    goto ldv_59962;
    case_33: /* CIL Label */ 
    {
#line 2581
    ldv_scsi_host_template_instance_callback_4_4(ldv_4_callback_alloc_pdu, ldv_4_host_struct_iscsi_task_ptr,
                                                 (int )ldv_4_ldv_param_4_1_default);
    }
#line 2584
    goto ldv_59962;
    switch_default: /* CIL Label */ 
    {
#line 2586
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_59962: ;
  }
#line 2596
  goto ldv_call_4;
#line 2598
  return;
}
}
#line 2603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_10(void *arg0 ) 
{ 
  long (*ldv_10_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_10_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_10_container_struct_device_attribute ;
  struct device *ldv_10_container_struct_device_ptr ;
  char *ldv_10_ldv_param_3_2_default ;
  char *ldv_10_ldv_param_9_2_default ;
  unsigned long ldv_10_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2621
  goto ldv_call_10;
#line 2623
  return;
  ldv_call_10: 
  {
#line 2629
  tmp___2 = ldv_undef_int();
  }
#line 2629
  if (tmp___2 != 0) {
    {
#line 2631
    tmp = ldv_xmalloc(1UL);
#line 2631
    ldv_10_ldv_param_3_2_default = (char *)tmp;
#line 2634
    tmp___1 = ldv_undef_int();
    }
#line 2634
    if (tmp___1 != 0) {
      {
#line 2636
      tmp___0 = ldv_xmalloc(1UL);
#line 2636
      ldv_10_ldv_param_9_2_default = (char *)tmp___0;
#line 2641
      ldv_dummy_resourceless_instance_callback_10_9(ldv_10_callback_store, ldv_10_container_struct_device_ptr,
                                                    ldv_10_container_struct_device_attribute,
                                                    ldv_10_ldv_param_9_2_default,
                                                    ldv_10_ldv_param_9_3_default);
#line 2645
      ldv_free((void *)ldv_10_ldv_param_9_2_default);
      }
    } else {
      {
#line 2652
      ldv_dummy_resourceless_instance_callback_10_3(ldv_10_callback_show, ldv_10_container_struct_device_ptr,
                                                    ldv_10_container_struct_device_attribute,
                                                    ldv_10_ldv_param_3_2_default);
      }
    }
    {
#line 2657
    ldv_free((void *)ldv_10_ldv_param_3_2_default);
    }
#line 2664
    goto ldv_call_10;
  } else {
#line 2672
    return;
  }
#line 2675
  return;
}
}
#line 2680 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_11(void *arg0 ) 
{ 
  long (*ldv_11_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_11_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_11_container_struct_device_attribute ;
  struct device *ldv_11_container_struct_device_ptr ;
  char *ldv_11_ldv_param_3_2_default ;
  char *ldv_11_ldv_param_9_2_default ;
  unsigned long ldv_11_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2698
  goto ldv_call_11;
#line 2700
  return;
  ldv_call_11: 
  {
#line 2706
  tmp___2 = ldv_undef_int();
  }
#line 2706
  if (tmp___2 != 0) {
    {
#line 2708
    tmp = ldv_xmalloc(1UL);
#line 2708
    ldv_11_ldv_param_3_2_default = (char *)tmp;
#line 2711
    tmp___1 = ldv_undef_int();
    }
#line 2711
    if (tmp___1 != 0) {
      {
#line 2713
      tmp___0 = ldv_xmalloc(1UL);
#line 2713
      ldv_11_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 2717
      if ((unsigned long )ldv_11_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                              struct device_attribute * ,
                                                                              char * ,
                                                                              unsigned long  ))0)) {
        {
#line 2719
        ldv_dummy_resourceless_instance_callback_11_9(ldv_11_callback_store, ldv_11_container_struct_device_ptr,
                                                      ldv_11_container_struct_device_attribute,
                                                      ldv_11_ldv_param_9_2_default,
                                                      ldv_11_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 2724
      ldv_free((void *)ldv_11_ldv_param_9_2_default);
      }
    } else {
      {
#line 2731
      ldv_dummy_resourceless_instance_callback_11_3(ldv_11_callback_show, ldv_11_container_struct_device_ptr,
                                                    ldv_11_container_struct_device_attribute,
                                                    ldv_11_ldv_param_3_2_default);
      }
    }
    {
#line 2736
    ldv_free((void *)ldv_11_ldv_param_3_2_default);
    }
#line 2743
    goto ldv_call_11;
  } else {
#line 2751
    return;
  }
#line 2754
  return;
}
}
#line 2759 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_5(void *arg0 ) 
{ 
  long (*ldv_5_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_5_callback_store)(struct device * , struct device_attribute * , char * ,
                               unsigned long  ) ;
  struct device_attribute *ldv_5_container_struct_device_attribute ;
  struct device *ldv_5_container_struct_device_ptr ;
  char *ldv_5_ldv_param_3_2_default ;
  char *ldv_5_ldv_param_9_2_default ;
  unsigned long ldv_5_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2777
  goto ldv_call_5;
#line 2779
  return;
  ldv_call_5: 
  {
#line 2785
  tmp___2 = ldv_undef_int();
  }
#line 2785
  if (tmp___2 != 0) {
    {
#line 2787
    tmp = ldv_xmalloc(1UL);
#line 2787
    ldv_5_ldv_param_3_2_default = (char *)tmp;
#line 2790
    tmp___1 = ldv_undef_int();
    }
#line 2790
    if (tmp___1 != 0) {
      {
#line 2792
      tmp___0 = ldv_xmalloc(1UL);
#line 2792
      ldv_5_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 2796
      if ((unsigned long )ldv_5_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                             struct device_attribute * ,
                                                                             char * ,
                                                                             unsigned long  ))0)) {
        {
#line 2798
        ldv_dummy_resourceless_instance_callback_5_9(ldv_5_callback_store, ldv_5_container_struct_device_ptr,
                                                     ldv_5_container_struct_device_attribute,
                                                     ldv_5_ldv_param_9_2_default,
                                                     ldv_5_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 2803
      ldv_free((void *)ldv_5_ldv_param_9_2_default);
      }
    } else {
      {
#line 2810
      ldv_dummy_resourceless_instance_callback_5_3(ldv_5_callback_show, ldv_5_container_struct_device_ptr,
                                                   ldv_5_container_struct_device_attribute,
                                                   ldv_5_ldv_param_3_2_default);
      }
    }
    {
#line 2815
    ldv_free((void *)ldv_5_ldv_param_3_2_default);
    }
#line 2822
    goto ldv_call_5;
  } else {
#line 2830
    return;
  }
#line 2833
  return;
}
}
#line 2838 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_6(void *arg0 ) 
{ 
  long (*ldv_6_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_6_callback_store)(struct device * , struct device_attribute * , char * ,
                               unsigned long  ) ;
  struct device_attribute *ldv_6_container_struct_device_attribute ;
  struct device *ldv_6_container_struct_device_ptr ;
  char *ldv_6_ldv_param_3_2_default ;
  char *ldv_6_ldv_param_9_2_default ;
  unsigned long ldv_6_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2856
  goto ldv_call_6;
#line 2858
  return;
  ldv_call_6: 
  {
#line 2864
  tmp___2 = ldv_undef_int();
  }
#line 2864
  if (tmp___2 != 0) {
    {
#line 2866
    tmp = ldv_xmalloc(1UL);
#line 2866
    ldv_6_ldv_param_3_2_default = (char *)tmp;
#line 2869
    tmp___1 = ldv_undef_int();
    }
#line 2869
    if (tmp___1 != 0) {
      {
#line 2871
      tmp___0 = ldv_xmalloc(1UL);
#line 2871
      ldv_6_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 2875
      if ((unsigned long )ldv_6_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                             struct device_attribute * ,
                                                                             char * ,
                                                                             unsigned long  ))0)) {
        {
#line 2877
        ldv_dummy_resourceless_instance_callback_6_9(ldv_6_callback_store, ldv_6_container_struct_device_ptr,
                                                     ldv_6_container_struct_device_attribute,
                                                     ldv_6_ldv_param_9_2_default,
                                                     ldv_6_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 2882
      ldv_free((void *)ldv_6_ldv_param_9_2_default);
      }
    } else {
      {
#line 2889
      ldv_dummy_resourceless_instance_callback_6_3(ldv_6_callback_show, ldv_6_container_struct_device_ptr,
                                                   ldv_6_container_struct_device_attribute,
                                                   ldv_6_ldv_param_3_2_default);
      }
    }
    {
#line 2894
    ldv_free((void *)ldv_6_ldv_param_3_2_default);
    }
#line 2901
    goto ldv_call_6;
  } else {
#line 2909
    return;
  }
#line 2912
  return;
}
}
#line 2917 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_7(void *arg0 ) 
{ 
  long (*ldv_7_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_7_callback_store)(struct device * , struct device_attribute * , char * ,
                               unsigned long  ) ;
  struct device_attribute *ldv_7_container_struct_device_attribute ;
  struct device *ldv_7_container_struct_device_ptr ;
  char *ldv_7_ldv_param_3_2_default ;
  char *ldv_7_ldv_param_9_2_default ;
  unsigned long ldv_7_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2935
  goto ldv_call_7;
#line 2937
  return;
  ldv_call_7: 
  {
#line 2943
  tmp___2 = ldv_undef_int();
  }
#line 2943
  if (tmp___2 != 0) {
    {
#line 2945
    tmp = ldv_xmalloc(1UL);
#line 2945
    ldv_7_ldv_param_3_2_default = (char *)tmp;
#line 2948
    tmp___1 = ldv_undef_int();
    }
#line 2948
    if (tmp___1 != 0) {
      {
#line 2950
      tmp___0 = ldv_xmalloc(1UL);
#line 2950
      ldv_7_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 2954
      if ((unsigned long )ldv_7_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                             struct device_attribute * ,
                                                                             char * ,
                                                                             unsigned long  ))0)) {
        {
#line 2956
        ldv_dummy_resourceless_instance_callback_7_9(ldv_7_callback_store, ldv_7_container_struct_device_ptr,
                                                     ldv_7_container_struct_device_attribute,
                                                     ldv_7_ldv_param_9_2_default,
                                                     ldv_7_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 2961
      ldv_free((void *)ldv_7_ldv_param_9_2_default);
      }
    } else {
      {
#line 2968
      ldv_dummy_resourceless_instance_callback_7_3(ldv_7_callback_show, ldv_7_container_struct_device_ptr,
                                                   ldv_7_container_struct_device_attribute,
                                                   ldv_7_ldv_param_3_2_default);
      }
    }
    {
#line 2973
    ldv_free((void *)ldv_7_ldv_param_3_2_default);
    }
#line 2980
    goto ldv_call_7;
  } else {
#line 2988
    return;
  }
#line 2991
  return;
}
}
#line 2996 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_8(void *arg0 ) 
{ 
  long (*ldv_8_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_8_callback_store)(struct device * , struct device_attribute * , char * ,
                               unsigned long  ) ;
  struct device_attribute *ldv_8_container_struct_device_attribute ;
  struct device *ldv_8_container_struct_device_ptr ;
  char *ldv_8_ldv_param_3_2_default ;
  char *ldv_8_ldv_param_9_2_default ;
  unsigned long ldv_8_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3014
  goto ldv_call_8;
#line 3016
  return;
  ldv_call_8: 
  {
#line 3022
  tmp___2 = ldv_undef_int();
  }
#line 3022
  if (tmp___2 != 0) {
    {
#line 3024
    tmp = ldv_xmalloc(1UL);
#line 3024
    ldv_8_ldv_param_3_2_default = (char *)tmp;
#line 3027
    tmp___1 = ldv_undef_int();
    }
#line 3027
    if (tmp___1 != 0) {
      {
#line 3029
      tmp___0 = ldv_xmalloc(1UL);
#line 3029
      ldv_8_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 3033
      if ((unsigned long )ldv_8_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                             struct device_attribute * ,
                                                                             char * ,
                                                                             unsigned long  ))0)) {
        {
#line 3035
        ldv_dummy_resourceless_instance_callback_8_9(ldv_8_callback_store, ldv_8_container_struct_device_ptr,
                                                     ldv_8_container_struct_device_attribute,
                                                     ldv_8_ldv_param_9_2_default,
                                                     ldv_8_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 3040
      ldv_free((void *)ldv_8_ldv_param_9_2_default);
      }
    } else {
      {
#line 3047
      ldv_dummy_resourceless_instance_callback_8_3(ldv_8_callback_show, ldv_8_container_struct_device_ptr,
                                                   ldv_8_container_struct_device_attribute,
                                                   ldv_8_ldv_param_3_2_default);
      }
    }
    {
#line 3052
    ldv_free((void *)ldv_8_ldv_param_3_2_default);
    }
#line 3059
    goto ldv_call_8;
  } else {
#line 3067
    return;
  }
#line 3070
  return;
}
}
#line 3075 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_9(void *arg0 ) 
{ 
  long (*ldv_9_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_9_callback_store)(struct device * , struct device_attribute * , char * ,
                               unsigned long  ) ;
  struct device_attribute *ldv_9_container_struct_device_attribute ;
  struct device *ldv_9_container_struct_device_ptr ;
  char *ldv_9_ldv_param_3_2_default ;
  char *ldv_9_ldv_param_9_2_default ;
  unsigned long ldv_9_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3093
  goto ldv_call_9;
#line 3095
  return;
  ldv_call_9: 
  {
#line 3101
  tmp___2 = ldv_undef_int();
  }
#line 3101
  if (tmp___2 != 0) {
    {
#line 3103
    tmp = ldv_xmalloc(1UL);
#line 3103
    ldv_9_ldv_param_3_2_default = (char *)tmp;
#line 3106
    tmp___1 = ldv_undef_int();
    }
#line 3106
    if (tmp___1 != 0) {
      {
#line 3108
      tmp___0 = ldv_xmalloc(1UL);
#line 3108
      ldv_9_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 3112
      if ((unsigned long )ldv_9_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                             struct device_attribute * ,
                                                                             char * ,
                                                                             unsigned long  ))0)) {
        {
#line 3114
        ldv_dummy_resourceless_instance_callback_9_9(ldv_9_callback_store, ldv_9_container_struct_device_ptr,
                                                     ldv_9_container_struct_device_attribute,
                                                     ldv_9_ldv_param_9_2_default,
                                                     ldv_9_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 3119
      ldv_free((void *)ldv_9_ldv_param_9_2_default);
      }
    } else {
      {
#line 3126
      ldv_dummy_resourceless_instance_callback_9_3(ldv_9_callback_show, ldv_9_container_struct_device_ptr,
                                                   ldv_9_container_struct_device_attribute,
                                                   ldv_9_ldv_param_3_2_default);
      }
    }
    {
#line 3131
    ldv_free((void *)ldv_9_ldv_param_3_2_default);
    }
#line 3138
    goto ldv_call_9;
  } else {
#line 3146
    return;
  }
#line 3149
  return;
}
}
#line 3154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_timer_dummy_factory_13(void *arg0 ) 
{ 
  struct timer_list *ldv_13_container_timer_list ;

  {
  {
#line 3163
  ldv_dispatch_instance_register_13_3(ldv_13_container_timer_list);
#line 3167
  ldv_dispatch_instance_deregister_13_2(ldv_13_container_timer_list);
  }
#line 3175
  return;
#line 3177
  return;
}
}
#line 3182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_timer_instance_callback_12_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) 
{ 


  {
  {
#line 3183
  (*arg0)(arg1);
  }
#line 3184
  return;
}
}
#line 3187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
void ldv_timer_timer_instance_12(void *arg0 ) 
{ 
  struct timer_list *ldv_12_container_timer_list ;
  struct ldv_struct_timer_instance_12 *data ;

  {
#line 3192
  data = (struct ldv_struct_timer_instance_12 *)arg0;
#line 3197
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_timer_instance_12 *)0)) {
    {
#line 3198
    ldv_12_container_timer_list = data->arg0;
#line 3199
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 3205
  ldv_switch_to_interrupt_context();
  }
#line 3206
  if ((unsigned long )ldv_12_container_timer_list->function != (unsigned long )((void (*)(unsigned long  ))0)) {
    {
#line 3208
    ldv_timer_instance_callback_12_2(ldv_12_container_timer_list->function, ldv_12_container_timer_list->data);
    }
  } else {

  }
  {
#line 3211
  ldv_switch_to_process_context();
  }
#line 3219
  return;
#line 3221
  return;
}
}
#line 3298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void atomic_dec(atomic_t *v ) 
{ 


  {
  {
#line 3301
  ldv_linux_usb_dev_atomic_dec(v);
  }
#line 3302
  return;
}
}
#line 3721 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 3725
  ldv_check_alloc_flags(flags);
#line 3726
  res = ldv_malloc_unknown_size();
#line 3727
  ldv_after_alloc(res);
  }
#line 3728
  return (res);
}
}
#line 3738 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 3742
  ldv_check_alloc_flags(flags);
#line 3743
  res = ldv_malloc_unknown_size();
#line 3744
  ldv_after_alloc(res);
  }
#line 3745
  return (res);
}
}
#line 3772 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3775
  tmp = ldv_kzalloc(size, flags);
  }
#line 3775
  return (tmp);
}
}
#line 3796 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3799
  ldv_check_alloc_flags(flags);
#line 3800
  tmp = ldv_malloc_unknown_size();
  }
#line 3800
  return (tmp);
}
}
#line 4105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_lock_bh_121(spinlock_t *lock ) 
{ 


  {
  {
#line 4108
  ldv_linux_kernel_locking_spinlock_spin_lock_frwd_lock_of_iscsi_session();
#line 4110
  spin_lock_bh(lock);
  }
#line 4111
  return;
}
}
#line 4113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_unlock_bh_122(spinlock_t *lock ) 
{ 


  {
  {
#line 4116
  ldv_linux_kernel_locking_spinlock_spin_unlock_frwd_lock_of_iscsi_session();
#line 4118
  spin_unlock_bh(lock);
  }
#line 4119
  return;
}
}
#line 4161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_iounmap_128(void volatile   *ldv_func_arg1 ) 
{ 


  {
  {
#line 4164
  ldv_linux_arch_io_io_mem_unmap();
  }
#line 4165
  return;
}
}
#line 4167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_iounmap_129(void volatile   *ldv_func_arg1 ) 
{ 


  {
  {
#line 4170
  ldv_linux_arch_io_io_mem_unmap();
  }
#line 4171
  return;
}
}
#line 4173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_iounmap_130(void volatile   *ldv_func_arg1 ) 
{ 


  {
  {
#line 4176
  ldv_linux_arch_io_io_mem_unmap();
  }
#line 4177
  return;
}
}
#line 4179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void *ldv_ioremap_nocache_131(resource_size_t ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  void *tmp ;

  {
  {
#line 4182
  tmp = ldv_linux_arch_io_io_mem_remap();
  }
#line 4182
  return (tmp);
}
}
#line 4185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void *ldv_ioremap_nocache_132(resource_size_t ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  void *tmp ;

  {
  {
#line 4188
  tmp = ldv_linux_arch_io_io_mem_remap();
  }
#line 4188
  return (tmp);
}
}
#line 4191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void *ldv_ioremap_nocache_133(resource_size_t ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  void *tmp ;

  {
  {
#line 4194
  tmp = ldv_linux_arch_io_io_mem_remap();
  }
#line 4194
  return (tmp);
}
}
#line 4197 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_134(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 4200
  ldv_linux_kernel_locking_spinlock_spin_lock_isr_lock_of_beiscsi_hba();
#line 4202
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 4203
  return;
}
}
#line 4205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_unlock_irqrestore_135(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 4208
  ldv_linux_kernel_locking_spinlock_spin_unlock_isr_lock_of_beiscsi_hba();
#line 4210
  spin_unlock_irqrestore(lock, flags);
  }
#line 4211
  return;
}
}
#line 4213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_136(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 4216
  ldv_linux_kernel_locking_spinlock_spin_lock_isr_lock_of_beiscsi_hba();
#line 4218
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 4219
  return;
}
}
#line 4229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static int ldv_request_irq_138(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                  void * ) ,
                                        unsigned long flags , char const   *name ,
                                        void *dev ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 4233
  tmp = request_irq(irq, handler, flags, name, dev);
#line 4233
  ldv_func_res = tmp;
#line 4236
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 4236
  return (tmp___0);
#line 4238
  return (ldv_func_res);
}
}
#line 4241 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static int ldv_request_irq_139(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                  void * ) ,
                                        unsigned long flags , char const   *name ,
                                        void *dev ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 4245
  tmp = request_irq(irq, handler, flags, name, dev);
#line 4245
  ldv_func_res = tmp;
#line 4248
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 4248
  return (tmp___0);
#line 4250
  return (ldv_func_res);
}
}
#line 4253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static int ldv_request_irq_140(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                  void * ) ,
                                        unsigned long flags , char const   *name ,
                                        void *dev ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 4257
  tmp = request_irq(irq, handler, flags, name, dev);
#line 4257
  ldv_func_res = tmp;
#line 4260
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 4260
  return (tmp___0);
#line 4262
  return (ldv_func_res);
}
}
#line 4265 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_free_irq_141(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 4268
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 4271
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 4272
  return;
}
}
#line 4274 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_lock_bh_142(spinlock_t *lock ) 
{ 


  {
  {
#line 4277
  ldv_linux_kernel_locking_spinlock_spin_lock_back_lock_of_iscsi_session();
#line 4279
  spin_lock_bh(lock);
  }
#line 4280
  return;
}
}
#line 4282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_unlock_bh_143(spinlock_t *lock ) 
{ 


  {
  {
#line 4285
  ldv_linux_kernel_locking_spinlock_spin_unlock_back_lock_of_iscsi_session();
#line 4287
  spin_unlock_bh(lock);
  }
#line 4288
  return;
}
}
#line 4306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_lock_bh_146(spinlock_t *lock ) 
{ 


  {
  {
#line 4309
  ldv_linux_kernel_locking_spinlock_spin_lock_async_pdu_lock_of_beiscsi_hba();
#line 4311
  spin_lock_bh(lock);
  }
#line 4312
  return;
}
}
#line 4314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_unlock_bh_147(spinlock_t *lock ) 
{ 


  {
  {
#line 4317
  ldv_linux_kernel_locking_spinlock_spin_unlock_async_pdu_lock_of_beiscsi_hba();
#line 4319
  spin_unlock_bh(lock);
  }
#line 4320
  return;
}
}
#line 4354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_152(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 4357
  ldv_linux_kernel_locking_spinlock_spin_lock_isr_lock_of_beiscsi_hba();
#line 4359
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 4360
  return;
}
}
#line 4370 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_154(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 4373
  ldv_linux_kernel_locking_spinlock_spin_lock_isr_lock_of_beiscsi_hba();
#line 4375
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 4376
  return;
}
}
#line 4386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_lock_bh_156(spinlock_t *lock ) 
{ 


  {
  {
#line 4389
  ldv_linux_kernel_locking_spinlock_spin_lock_mgmt_sgl_lock_of_beiscsi_hba();
#line 4391
  spin_lock_bh(lock);
  }
#line 4392
  return;
}
}
#line 4394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_unlock_bh_157(spinlock_t *lock ) 
{ 


  {
  {
#line 4397
  ldv_linux_kernel_locking_spinlock_spin_unlock_mgmt_sgl_lock_of_beiscsi_hba();
#line 4399
  spin_unlock_bh(lock);
  }
#line 4400
  return;
}
}
#line 4402 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_lock_158(spinlock_t *lock ) 
{ 


  {
  {
#line 4405
  ldv_linux_kernel_locking_spinlock_spin_lock_io_sgl_lock_of_beiscsi_hba();
#line 4407
  spin_lock(lock);
  }
#line 4408
  return;
}
}
#line 4410 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_unlock_159(spinlock_t *lock ) 
{ 


  {
  {
#line 4413
  ldv_linux_kernel_locking_spinlock_spin_unlock_io_sgl_lock_of_beiscsi_hba();
#line 4415
  spin_unlock(lock);
  }
#line 4416
  return;
}
}
#line 4434 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void *ldv_dma_pool_alloc_162(struct dma_pool *ldv_func_arg1 , gfp_t flags ,
                                    dma_addr_t *ldv_func_arg3 ) 
{ 
  void *tmp ;

  {
  {
#line 4437
  ldv_check_alloc_flags(flags);
#line 4438
  tmp = ldv_malloc_unknown_size();
  }
#line 4438
  return (tmp);
}
}
#line 4457 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_lock_165(spinlock_t *lock ) 
{ 


  {
  {
#line 4460
  ldv_linux_kernel_locking_spinlock_spin_lock_mgmt_sgl_lock_of_beiscsi_hba();
#line 4462
  spin_lock(lock);
  }
#line 4463
  return;
}
}
#line 4465 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
__inline static void ldv_spin_unlock_166(spinlock_t *lock ) 
{ 


  {
  {
#line 4468
  ldv_linux_kernel_locking_spinlock_spin_unlock_mgmt_sgl_lock_of_beiscsi_hba();
#line 4470
  spin_unlock(lock);
  }
#line 4471
  return;
}
}
#line 4521 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_free_irq_173(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 4524
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 4527
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 4528
  return;
}
}
#line 4530 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_free_irq_174(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 4533
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 4536
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 4537
  return;
}
}
#line 4539 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static int ldv___pci_register_driver_175(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                         char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 4543
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
#line 4543
  ldv_func_res = tmp;
#line 4546
  tmp___0 = ldv___pci_register_driver(ldv_func_res, ldv_func_arg1, ldv_func_arg2,
                                      (char *)ldv_func_arg3);
  }
#line 4546
  return (tmp___0);
#line 4548
  return (ldv_func_res);
}
}
#line 4551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_pci_unregister_driver_176(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
  {
#line 4554
  pci_unregister_driver(ldv_func_arg1);
#line 4557
  ldv_pci_unregister_driver((void *)0, ldv_func_arg1);
  }
#line 4558
  return;
}
}
#line 4560 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static int ldv_ldv_post_init_177(int ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 4564
  ldv_linux_net_register_reset_error_counter();
#line 4568
  ldv_linux_usb_register_reset_error_counter();
#line 4571
  tmp = ldv_post_init(ldv_func_arg1);
  }
#line 4571
  return (tmp);
}
}
#line 4574 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_ldv_check_final_state_178(void) 
{ 


  {
  {
#line 4578
  ldv_linux_arch_io_check_final_state();
#line 4582
  ldv_linux_block_genhd_check_final_state();
#line 4586
  ldv_linux_block_queue_check_final_state();
#line 4590
  ldv_linux_block_request_check_final_state();
#line 4594
  ldv_linux_drivers_base_class_check_final_state();
#line 4602
  ldv_linux_fs_char_dev_check_final_state();
#line 4606
  ldv_linux_fs_sysfs_check_final_state();
#line 4610
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 4614
  ldv_linux_kernel_module_check_final_state();
#line 4618
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 4622
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 4626
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 4630
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 4634
  ldv_linux_lib_idr_check_final_state();
#line 4638
  ldv_linux_mmc_sdio_func_check_final_state();
#line 4642
  ldv_linux_net_rtnetlink_check_final_state();
#line 4646
  ldv_linux_net_sock_check_final_state();
#line 4650
  ldv_linux_usb_coherent_check_final_state();
#line 4654
  ldv_linux_usb_gadget_check_final_state();
#line 4658
  ldv_linux_usb_urb_check_final_state();
  }
#line 4659
  return;
}
}
#line 4662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_ldv_check_final_state_179(void) 
{ 


  {
  {
#line 4666
  ldv_linux_arch_io_check_final_state();
#line 4670
  ldv_linux_block_genhd_check_final_state();
#line 4674
  ldv_linux_block_queue_check_final_state();
#line 4678
  ldv_linux_block_request_check_final_state();
#line 4682
  ldv_linux_drivers_base_class_check_final_state();
#line 4690
  ldv_linux_fs_char_dev_check_final_state();
#line 4694
  ldv_linux_fs_sysfs_check_final_state();
#line 4698
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 4702
  ldv_linux_kernel_module_check_final_state();
#line 4706
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 4710
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 4714
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 4718
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 4722
  ldv_linux_lib_idr_check_final_state();
#line 4726
  ldv_linux_mmc_sdio_func_check_final_state();
#line 4730
  ldv_linux_net_rtnetlink_check_final_state();
#line 4734
  ldv_linux_net_sock_check_final_state();
#line 4738
  ldv_linux_usb_coherent_check_final_state();
#line 4742
  ldv_linux_usb_gadget_check_final_state();
#line 4746
  ldv_linux_usb_urb_check_final_state();
  }
#line 4747
  return;
}
}
#line 4750 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_ldv_initialize_180(void) 
{ 


  {
  {
#line 4754
  ldv_linux_lib_find_bit_initialize();
  }
#line 4755
  return;
}
}
#line 4758 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_ldv_pre_probe_181(void) 
{ 


  {
  {
#line 4762
  ldv_linux_net_register_reset_error_counter();
#line 4766
  ldv_linux_usb_register_reset_error_counter();
#line 4769
  ldv_pre_probe();
  }
#line 4770
  return;
}
}
#line 4772 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static int ldv_ldv_post_probe_182(int retval ) 
{ 
  int tmp ;

  {
  {
#line 4776
  ldv_linux_net_register_check_return_value_probe(retval);
#line 4780
  ldv_linux_usb_register_check_return_value_probe(retval);
#line 4783
  tmp = ldv_post_probe(retval);
  }
#line 4783
  return (tmp);
}
}
#line 4786 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static void ldv_ldv_pre_probe_183(void) 
{ 


  {
  {
#line 4790
  ldv_linux_net_register_reset_error_counter();
#line 4794
  ldv_linux_usb_register_reset_error_counter();
#line 4797
  ldv_pre_probe();
  }
#line 4798
  return;
}
}
#line 4800 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_main.c.aux"
static int ldv_ldv_post_probe_184(int retval ) 
{ 
  int tmp ;

  {
  {
#line 4804
  ldv_linux_net_register_check_return_value_probe(retval);
#line 4808
  ldv_linux_usb_register_check_return_value_probe(retval);
#line 4811
  tmp = ldv_post_probe(retval);
  }
#line 4811
  return (tmp);
}
}
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 568 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_mgmt.c.aux"
void ldv_linux_kernel_locking_spinlock_spin_lock_mbox_lock_of_be_ctrl_info(void) ;
#line 569
void ldv_linux_kernel_locking_spinlock_spin_unlock_mbox_lock_of_be_ctrl_info(void) ;
#line 362 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 366
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 370
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 374
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 378
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 382
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 386
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 390
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 394
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 398
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 402
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 406
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 410
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 414
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 418
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 422
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 411
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 415
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 419
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 423
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 427
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 431
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 435
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 439
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 443
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 447
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 451
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 455
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 459
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 463
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 467
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 471
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 475
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 479
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 483
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 487
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 491
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 495
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 499
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 503
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 507
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 511
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 515
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 519
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 523
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 527
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 852 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
extern int pci_bus_read_config_dword(struct pci_bus * , unsigned int  , int  , u32 * ) ;
#line 880 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev  const  *dev , int where ,
                                          u32 *val ) 
{ 
  int tmp ;

  {
  {
#line 883
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
  }
#line 883
  return (tmp);
}
}
#line 244 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
extern size_t sg_copy_to_buffer(struct scatterlist * , unsigned int  , void * , size_t  ) ;
#line 179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-mapping.h"
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flags ) ;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static void *pci_zalloc_consistent___0(struct pci_dev *hwdev , size_t size ,
                                                dma_addr_t *dma_handle ) 
{ 
  void *tmp ;

  {
  {
#line 26
  tmp = dma_zalloc_coherent((unsigned long )hwdev != (unsigned long )((struct pci_dev *)0) ? & hwdev->dev : (struct device *)0,
                            size, dma_handle, 32U);
  }
#line 26
  return (tmp);
}
}
#line 627 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
__inline static struct be_sge *nonembedded_sgl(struct be_mcc_wrb *wrb ) 
{ 


  {
#line 629
  return ((struct be_sge *)(& wrb->payload.sgl));
}
}
#line 735
struct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem ) ;
#line 736
struct be_mcc_wrb *wrb_from_mccq(struct beiscsi_hba *phba ) ;
#line 737
int be_mcc_notify_wait(struct beiscsi_hba *phba ) ;
#line 738
void be_mcc_notify(struct beiscsi_hba *phba ) ;
#line 739
unsigned int alloc_mcc_tag(struct beiscsi_hba *phba ) ;
#line 745
int be_mbox_notify(struct be_ctrl_info *ctrl ) ;
#line 772
int be_cmd_set_vlan(struct beiscsi_hba *phba , uint16_t vlan_tag ) ;
#line 1352
void be_wrb_hdr_prepare(struct be_mcc_wrb *wrb , int payload_len , bool embedded ,
                        u8 sge_cnt ) ;
#line 1355
void be_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr , u8 subsystem , u8 opcode ,
                        int cmd_len ) ;
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.h"
unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba ) ;
#line 285
unsigned int mgmt_reopen_session(struct beiscsi_hba *phba , unsigned int reopen_type ,
                                 unsigned int sess_handle ) ;
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
static char const   * const  desc_ue_status_low[32U]  = 
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
  {      "CEV",      "CTX",      "DBUF",      "ERX", 
        "Host",      "MPU",      "NDMA",      "PTC ", 
        "RDMA ",      "RXF ",      "RXIPS ",      "RXULP0 ", 
        "RXULP1 ",      "RXULP2 ",      "TIM ",      "TPOST ", 
        "TPRE ",      "TXIPS ",      "TXULP0 ",      "TXULP1 ", 
        "UC ",      "WDMA ",      "TXULP2 ",      "HOST1 ", 
        "P0_OB_LINK ",      "P1_OB_LINK ",      "HOST_GPIO ",      "MBOX ", 
        "AXGMAC0",      "AXGMAC1",      "JTAG",      "MPU_INTPEND"};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
static char const   * const  desc_ue_status_hi[32U]  = 
#line 64
  {      "LPCMEMHOST",      "MGMT_MAC",      "PCS0ONLINE",      "MPU_IRAM", 
        "PCS1ONLINE",      "PCTL0",      "PCTL1",      "PMEM", 
        "RR",      "TXPB",      "RXPP",      "XAUI", 
        "TXP",      "ARM",      "IPC",      "HOST2", 
        "HOST3",      "HOST4",      "HOST5",      "HOST6", 
        "HOST7",      "HOST8",      "HOST9",      "NETC", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown", 
        "Unknown",      "Unknown",      "Unknown",      "Unknown"};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
void beiscsi_ue_detect(struct beiscsi_hba *phba ) 
{ 
  uint32_t ue_hi ;
  uint32_t ue_lo ;
  uint32_t ue_mask_hi ;
  uint32_t ue_mask_lo ;
  uint8_t i ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
#line 107
  ue_hi = 0U;
#line 107
  ue_lo = 0U;
#line 108
  ue_mask_hi = 0U;
#line 108
  ue_mask_lo = 0U;
#line 109
  i = 0U;
#line 111
  if ((int )phba->ue_detected) {
#line 112
    return;
  } else {

  }
  {
#line 114
  pci_read_config_dword((struct pci_dev  const  *)phba->pcidev, 160, & ue_lo);
#line 116
  pci_read_config_dword((struct pci_dev  const  *)phba->pcidev, 168, & ue_mask_lo);
#line 119
  pci_read_config_dword((struct pci_dev  const  *)phba->pcidev, 164, & ue_hi);
#line 122
  pci_read_config_dword((struct pci_dev  const  *)phba->pcidev, 172, & ue_mask_hi);
#line 126
  ue_lo = ue_lo & ~ ue_mask_lo;
#line 127
  ue_hi = ue_hi & ~ ue_mask_hi;
  }
#line 130
  if (ue_lo != 0U || ue_hi != 0U) {
#line 131
    phba->ue_detected = 1;
#line 132
    log_value = phba->attr_log_enable;
#line 132
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 132
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Error detected on the adapter\n",
                 134);
      }
    } else {

    }
  } else {

  }
#line 137
  if (ue_lo != 0U) {
#line 138
    i = 0U;
#line 138
    goto ldv_56226;
    ldv_56225: ;
#line 139
    if ((int )ue_lo & 1) {
#line 140
      log_value___0 = phba->attr_log_enable;
#line 140
      if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 140
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : UE_LOW %s bit set\n", 143, desc_ue_status_low[(int )i]);
        }
      } else {

      }
    } else {

    }
#line 138
    ue_lo = ue_lo >> 1;
#line 138
    i = (uint8_t )((int )i + 1);
    ldv_56226: ;
#line 138
    if (ue_lo != 0U) {
#line 140
      goto ldv_56225;
    } else {

    }

  } else {

  }
#line 147
  if (ue_hi != 0U) {
#line 148
    i = 0U;
#line 148
    goto ldv_56230;
    ldv_56229: ;
#line 149
    if ((int )ue_hi & 1) {
#line 150
      log_value___1 = phba->attr_log_enable;
#line 150
      if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 150
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : UE_HIGH %s bit set\n", 153, desc_ue_status_hi[(int )i]);
        }
      } else {

      }
    } else {

    }
#line 148
    ue_hi = ue_hi >> 1;
#line 148
    i = (uint8_t )((int )i + 1);
    ldv_56230: ;
#line 148
    if (ue_hi != 0U) {
#line 150
      goto ldv_56229;
    } else {

    }

  } else {

  }
#line 156
  return;
}
}
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int be_cmd_modify_eq_delay(struct beiscsi_hba *phba , struct be_set_eqd *set_eqd ,
                           int num ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_modify_eq_delay *req ;
  unsigned int tag ;
  int i ;
  void *tmp ;

  {
  {
#line 161
  ctrl = & phba->ctrl;
#line 164
  tag = 0U;
#line 167
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 168
  tag = alloc_mcc_tag(phba);
  }
#line 169
  if (tag == 0U) {
    {
#line 170
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 171
    return ((int )tag);
  } else {

  }
  {
#line 174
  wrb = wrb_from_mccq(phba);
#line 175
  tmp = embedded_payload(wrb);
#line 175
  req = (struct be_cmd_req_modify_eq_delay *)tmp;
#line 177
  wrb->tag0 = wrb->tag0 | tag;
#line 178
  be_wrb_hdr_prepare(wrb, 788, 1, 0);
#line 179
  be_cmd_hdr_prepare(& req->hdr, 1, 41, 788);
#line 182
  req->num_eq = (unsigned int )num;
#line 183
  i = 0;
  }
#line 183
  goto ldv_56243;
  ldv_56242: 
#line 184
  req->delay[i].eq_id = (set_eqd + (unsigned long )i)->eq_id;
#line 185
  req->delay[i].phase = 0U;
#line 186
  req->delay[i].delay_multiplier = (set_eqd + (unsigned long )i)->delay_multiplier;
#line 183
  i = i + 1;
  ldv_56243: ;
#line 183
  if (i < num) {
#line 185
    goto ldv_56242;
  } else {

  }
  {
#line 190
  be_mcc_notify(phba);
#line 191
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 192
  return ((int )tag);
}
}
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_reopen_session(struct beiscsi_hba *phba , unsigned int reopen_type ,
                                 unsigned int sess_handle ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_reopen_session_req *req ;
  unsigned int tag ;
  uint32_t log_value ;
  void *tmp ;

  {
#line 209
  ctrl = & phba->ctrl;
#line 212
  tag = 0U;
#line 214
  log_value = phba->attr_log_enable;
#line 214
  if ((log_value & 34U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 214
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : In bescsi_get_boot_target\n",
               216);
    }
  } else {

  }
  {
#line 218
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 219
  tag = alloc_mcc_tag(phba);
  }
#line 220
  if (tag == 0U) {
    {
#line 221
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 222
    return (tag);
  } else {

  }
  {
#line 225
  wrb = wrb_from_mccq(phba);
#line 226
  tmp = embedded_payload(wrb);
#line 226
  req = (struct be_cmd_reopen_session_req *)tmp;
#line 227
  wrb->tag0 = wrb->tag0 | tag;
#line 228
  be_wrb_hdr_prepare(wrb, 24, 1, 0);
#line 229
  be_cmd_hdr_prepare(& req->hdr, 6, 36, 24);
#line 234
  req->reopen_type = (u16 )reopen_type;
#line 235
  req->session_handle = sess_handle;
#line 237
  be_mcc_notify(phba);
#line 238
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 239
  return (tag);
}
}
#line 242 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_get_boot_target_req *req ;
  unsigned int tag ;
  uint32_t log_value ;
  void *tmp ;

  {
#line 244
  ctrl = & phba->ctrl;
#line 247
  tag = 0U;
#line 249
  log_value = phba->attr_log_enable;
#line 249
  if ((log_value & 34U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 249
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : In bescsi_get_boot_target\n",
               251);
    }
  } else {

  }
  {
#line 253
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 254
  tag = alloc_mcc_tag(phba);
  }
#line 255
  if (tag == 0U) {
    {
#line 256
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 257
    return (tag);
  } else {

  }
  {
#line 260
  wrb = wrb_from_mccq(phba);
#line 261
  tmp = embedded_payload(wrb);
#line 261
  req = (struct be_cmd_get_boot_target_req *)tmp;
#line 262
  wrb->tag0 = wrb->tag0 | tag;
#line 263
  be_wrb_hdr_prepare(wrb, 16, 1, 0);
#line 264
  be_cmd_hdr_prepare(& req->hdr, 6, 52, 24);
#line 268
  be_mcc_notify(phba);
#line 269
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 270
  return (tag);
}
}
#line 273 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_get_session_info(struct beiscsi_hba *phba , u32 boot_session_handle ,
                                   struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  unsigned int tag ;
  struct be_cmd_get_session_req *req ;
  struct be_sge *sge ;
  uint32_t log_value ;

  {
#line 277
  ctrl = & phba->ctrl;
#line 279
  tag = 0U;
#line 284
  log_value = phba->attr_log_enable;
#line 284
  if ((log_value & 34U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 284
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : In beiscsi_get_session_info\n",
               286);
    }
  } else {

  }
  {
#line 288
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 289
  tag = alloc_mcc_tag(phba);
  }
#line 290
  if (tag == 0U) {
    {
#line 291
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 292
    return (tag);
  } else {

  }
  {
#line 295
  nonemb_cmd->size = 1180U;
#line 296
  req = (struct be_cmd_get_session_req *)nonemb_cmd->va;
#line 297
  __memset((void *)req, 0, 20UL);
#line 298
  wrb = wrb_from_mccq(phba);
#line 299
  sge = nonembedded_sgl(wrb);
#line 300
  wrb->tag0 = wrb->tag0 | tag;
#line 303
  wrb->tag0 = wrb->tag0 | tag;
#line 304
  be_wrb_hdr_prepare(wrb, 20, 0, 1);
#line 305
  be_cmd_hdr_prepare(& req->hdr, 6, 14, 1180);
#line 308
  req->session_handle = boot_session_handle;
#line 309
  sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 310
  sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 311
  sge->len = nonemb_cmd->size;
#line 313
  be_mcc_notify(phba);
#line 314
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 315
  return (tag);
}
}
#line 330 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_get_fw_config(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_fw_cfg *req ;
  void *tmp___0 ;
  int status ;
  uint8_t ulp_num ;
  struct be_fw_cfg *pfw_cfg ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  int tmp___2 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
  {
#line 333
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 333
  wrb = tmp;
#line 334
  tmp___0 = embedded_payload(wrb);
#line 334
  req = (struct be_fw_cfg *)tmp___0;
#line 335
  status = 0;
#line 337
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 338
  __memset((void *)wrb, 0, 256UL);
#line 340
  be_wrb_hdr_prepare(wrb, 172, 1, 0);
#line 342
  be_cmd_hdr_prepare(& req->hdr, 1, 58, 220);
#line 345
  status = be_mbox_notify(ctrl);
  }
#line 346
  if (status == 0) {
#line 347
    ulp_num = 0U;
#line 349
    pfw_cfg = req;
#line 351
    if (phba->generation - 2U > 1U) {
#line 352
      phba->fw_config.eqid_count = pfw_cfg->eqid_count;
#line 353
      phba->fw_config.cqid_count = pfw_cfg->cqid_count;
#line 355
      log_value = phba->attr_log_enable;
#line 355
      if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
        {
#line 355
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : EQ_Count : %d CQ_Count : %d\n", 359, phba->fw_config.eqid_count,
                   phba->fw_config.cqid_count);
        }
      } else {

      }
    } else {

    }
#line 362
    ulp_num = 0U;
#line 362
    goto ldv_56286;
    ldv_56285: ;
#line 363
    if ((pfw_cfg->ulp[(int )ulp_num].ulp_mode & 16U) != 0U) {
      {
#line 365
      set_bit((long )ulp_num, (unsigned long volatile   *)(& phba->fw_config.ulp_supported));
      }
    } else {

    }
#line 362
    ulp_num = (uint8_t )((int )ulp_num + 1);
    ldv_56286: ;
#line 362
    if ((unsigned int )ulp_num <= 1U) {
#line 364
      goto ldv_56285;
    } else {

    }
#line 368
    phba->fw_config.phys_port = pfw_cfg->phys_port;
#line 369
    ulp_num = 0U;
#line 369
    goto ldv_56290;
    ldv_56289: 
    {
#line 370
    tmp___2 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
    }
#line 370
    if (tmp___2 != 0) {
#line 372
      phba->fw_config.iscsi_cid_start[(int )ulp_num] = pfw_cfg->ulp[(int )ulp_num].sq_base;
#line 374
      phba->fw_config.iscsi_cid_count[(int )ulp_num] = pfw_cfg->ulp[(int )ulp_num].sq_count;
#line 377
      phba->fw_config.iscsi_icd_start[(int )ulp_num] = pfw_cfg->ulp[(int )ulp_num].icd_base;
#line 379
      phba->fw_config.iscsi_icd_count[(int )ulp_num] = pfw_cfg->ulp[(int )ulp_num].icd_count;
#line 382
      phba->fw_config.iscsi_chain_start[(int )ulp_num] = pfw_cfg->chain_icd[(int )ulp_num].chain_base;
#line 384
      phba->fw_config.iscsi_chain_count[(int )ulp_num] = pfw_cfg->chain_icd[(int )ulp_num].chain_count;
#line 387
      log_value___0 = phba->attr_log_enable;
#line 387
      if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
        {
#line 387
        dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : Function loaded on ULP : %d\n\tiscsi_cid_count : %d\n\tiscsi_cid_start : %d\n\t iscsi_icd_count : %d\n\t iscsi_icd_start : %d\n",
                   401, (int )ulp_num, phba->fw_config.iscsi_cid_count[(int )ulp_num],
                   phba->fw_config.iscsi_cid_start[(int )ulp_num], phba->fw_config.iscsi_icd_count[(int )ulp_num],
                   phba->fw_config.iscsi_icd_start[(int )ulp_num]);
        }
      } else {

      }
    } else {

    }
#line 369
    ulp_num = (uint8_t )((int )ulp_num + 1);
    ldv_56290: ;
#line 369
    if ((unsigned int )ulp_num <= 1U) {
#line 371
      goto ldv_56289;
    } else {

    }
#line 405
    phba->fw_config.dual_ulp_aware = (unsigned int )((uint16_t )pfw_cfg->function_mode) & 2048U;
#line 408
    log_value___1 = phba->attr_log_enable;
#line 408
    if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 408
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BG_%d : DUA Mode : 0x%x\n", 410, (int )phba->fw_config.dual_ulp_aware);
      }
    } else {

    }
  } else {
#line 413
    log_value___2 = phba->attr_log_enable;
#line 413
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 413
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed in mgmt_get_fw_config\n",
                 414);
      }
    } else {

    }
#line 415
    status = -22;
  }
  {
#line 418
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 419
  return (status);
}
}
#line 422 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_check_supported_fw(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ) 
{ 
  struct be_dma_mem nonemb_cmd ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_mgmt_controller_attributes *req ;
  struct be_sge *sge ;
  struct be_sge *tmp___0 ;
  int status ;
  uint32_t log_value ;
  struct be_mgmt_controller_attributes_resp *resp ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
  {
#line 426
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 426
  wrb = tmp;
#line 428
  tmp___0 = nonembedded_sgl(wrb);
#line 428
  sge = tmp___0;
#line 429
  status = 0;
#line 431
  nonemb_cmd.va = pci_alloc_consistent(ctrl->pdev, 556UL, & nonemb_cmd.dma);
  }
#line 434
  if ((unsigned long )nonemb_cmd.va == (unsigned long )((void *)0)) {
#line 435
    log_value = phba->attr_log_enable;
#line 435
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 435
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to allocate memory for mgmt_check_supported_fw\n",
                 437);
      }
    } else {

    }
#line 438
    return (-12);
  } else {

  }
  {
#line 440
  nonemb_cmd.size = 556U;
#line 441
  req = (struct be_mgmt_controller_attributes *)nonemb_cmd.va;
#line 442
  __memset((void *)req, 0, 556UL);
#line 443
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 444
  __memset((void *)wrb, 0, 256UL);
#line 445
  be_wrb_hdr_prepare(wrb, 556, 0, 1);
#line 446
  be_cmd_hdr_prepare(& req->hdr, 1, 32, 556);
#line 448
  sge->pa_hi = (unsigned int )(nonemb_cmd.dma >> 32ULL);
#line 449
  sge->pa_lo = (unsigned int )nonemb_cmd.dma;
#line 450
  sge->len = nonemb_cmd.size;
#line 451
  status = be_mbox_notify(ctrl);
  }
#line 452
  if (status == 0) {
#line 453
    resp = (struct be_mgmt_controller_attributes_resp *)nonemb_cmd.va;
#line 454
    log_value___0 = phba->attr_log_enable;
#line 454
    if ((int )log_value___0 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 454
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BG_%d : Firmware Version of CMD : %s\nFirmware Version is : %s\nDeveloper Build, not performing version check...\n",
                 461, (u8 *)(& resp->params.hba_attribs.flashrom_version_string),
                 (u8 *)(& resp->params.hba_attribs.firmware_version_string));
      }
    } else {

    }
#line 463
    phba->fw_config.iscsi_features = (unsigned short )resp->params.hba_attribs.iscsi_features;
#line 465
    log_value___1 = phba->attr_log_enable;
#line 465
    if ((int )log_value___1 & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 465
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BM_%d : phba->fw_config.iscsi_features = %d\n", 467, (int )phba->fw_config.iscsi_features);
      }
    } else {

    }
    {
#line 468
    __memcpy((void *)(& phba->fw_ver_str), (void const   *)(& resp->params.hba_attribs.firmware_version_string),
             32UL);
    }
  } else {
#line 471
    log_value___2 = phba->attr_log_enable;
#line 471
    if ((int )log_value___2 & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 471
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d :  Failed in mgmt_check_supported_fw\n",
                 472);
      }
    } else {

    }
  }
  {
#line 473
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 474
  if ((unsigned long )nonemb_cmd.va != (unsigned long )((void *)0)) {
    {
#line 475
    pci_free_consistent(ctrl->pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va, nonemb_cmd.dma);
    }
  } else {

  }
#line 478
  return (status);
}
}
#line 481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl , struct beiscsi_hba *phba ,
                                         struct bsg_job *job , struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_cmd_resp_hdr *resp ;
  struct be_mcc_wrb *wrb ;
  struct be_sge *mcc_sge ;
  unsigned int tag ;
  struct iscsi_bsg_request *bsg_req ;
  struct be_bsg_vendor_cmd *req ;
  unsigned short region ;
  unsigned short sector_size ;
  unsigned short sector ;
  unsigned short offset ;
  uint32_t log_value ;

  {
  {
#line 489
  tag = 0U;
#line 490
  bsg_req = (struct iscsi_bsg_request *)job->request;
#line 491
  req = (struct be_bsg_vendor_cmd *)nonemb_cmd->va;
#line 494
  nonemb_cmd->size = job->request_payload.payload_len;
#line 495
  __memset(nonemb_cmd->va, 0, (size_t )nonemb_cmd->size);
#line 496
  resp = (struct be_cmd_resp_hdr *)nonemb_cmd->va;
#line 497
  region = (unsigned short )bsg_req->rqst_data.h_vendor.vendor_cmd[1];
#line 498
  sector_size = (unsigned short )bsg_req->rqst_data.h_vendor.vendor_cmd[2];
#line 499
  sector = (unsigned short )bsg_req->rqst_data.h_vendor.vendor_cmd[3];
#line 500
  offset = (unsigned short )bsg_req->rqst_data.h_vendor.vendor_cmd[4];
#line 501
  req->region = region;
#line 502
  req->sector = sector;
#line 503
  req->offset = offset;
#line 504
  ldv_spin_lock_121(& ctrl->mbox_lock);
  }
  {
#line 507
  if (bsg_req->rqst_data.h_vendor.vendor_cmd[0] == 0U) {
#line 507
    goto case_0;
  } else {

  }
#line 515
  if (bsg_req->rqst_data.h_vendor.vendor_cmd[0] == 1U) {
#line 515
    goto case_1;
  } else {

  }
#line 519
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 508
  offset = (int )sector * (int )sector_size + (int )offset;
#line 509
  be_cmd_hdr_prepare(& req->hdr, 2, 96, 22);
#line 511
  sg_copy_to_buffer(job->request_payload.sg_list, (unsigned int )job->request_payload.sg_cnt,
                    nonemb_cmd->va + (unsigned long )offset, (size_t )job->request_len);
  }
#line 514
  goto ldv_56325;
  case_1: /* CIL Label */ 
  {
#line 516
  be_cmd_hdr_prepare(& req->hdr, 2, 97, 22);
  }
#line 518
  goto ldv_56325;
  switch_default: /* CIL Label */ 
#line 520
  log_value = phba->attr_log_enable;
#line 520
  if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
    {
#line 520
    dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Unsupported cmd = 0x%x\n\n",
               522, bsg_req->rqst_data.h_vendor.vendor_cmd[0]);
    }
  } else {

  }
  {
#line 524
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 525
  return (4294967258U);
  switch_break: /* CIL Label */ ;
  }
  ldv_56325: 
  {
#line 528
  tag = alloc_mcc_tag(phba);
  }
#line 529
  if (tag == 0U) {
    {
#line 530
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 531
    return (tag);
  } else {

  }
  {
#line 534
  wrb = wrb_from_mccq(phba);
#line 535
  mcc_sge = nonembedded_sgl(wrb);
#line 536
  be_wrb_hdr_prepare(wrb, (int )nonemb_cmd->size, 0, (int )((u8 )job->request_payload.sg_cnt));
#line 538
  mcc_sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 539
  mcc_sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 540
  mcc_sge->len = nonemb_cmd->size;
#line 541
  wrb->tag0 = wrb->tag0 | tag;
#line 543
  be_mcc_notify(phba);
#line 545
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 546
  return (tag);
}
}
#line 558 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_epfw_cleanup(struct beiscsi_hba *phba , unsigned short ulp_num ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct iscsi_cleanup_req *req ;
  void *tmp___0 ;
  int status ;
  uint32_t log_value ;

  {
  {
#line 560
  ctrl = & phba->ctrl;
#line 561
  tmp = wrb_from_mccq(phba);
#line 561
  wrb = tmp;
#line 562
  tmp___0 = embedded_payload(wrb);
#line 562
  req = (struct iscsi_cleanup_req *)tmp___0;
#line 563
  status = 0;
#line 565
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 567
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
#line 568
  be_cmd_hdr_prepare(& req->hdr, 2, 59, 20);
#line 571
  req->chute = (u16 )(1 << (int )ulp_num);
#line 572
  req->hdr_ring_id = (u8 )(phba->phwi_ctrlr)->default_pdu_hdr[(int )ulp_num].id;
#line 573
  req->data_ring_id = (u8 )(phba->phwi_ctrlr)->default_pdu_data[(int )ulp_num].id;
#line 575
  status = be_mcc_notify_wait(phba);
  }
#line 576
  if (status != 0) {
#line 577
    log_value = phba->attr_log_enable;
#line 577
    if ((int )log_value & 1 || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 577
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : mgmt_epfw_cleanup , FAILED\n",
                 578);
      }
    } else {

    }
  } else {

  }
  {
#line 579
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 580
  return (status);
}
}
#line 583 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_invalidate_icds(struct beiscsi_hba *phba , struct invalidate_command_table *inv_tbl ,
                                  unsigned int num_invalidate , unsigned int cid ,
                                  struct be_dma_mem *nonemb_cmd ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_sge *sge ;
  struct invalidate_commands_params_in *req ;
  unsigned int i ;
  unsigned int tag ;

  {
  {
#line 589
  ctrl = & phba->ctrl;
#line 593
  tag = 0U;
#line 595
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 596
  tag = alloc_mcc_tag(phba);
  }
#line 597
  if (tag == 0U) {
    {
#line 598
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 599
    return (tag);
  } else {

  }
  {
#line 602
  req = (struct invalidate_commands_params_in *)nonemb_cmd->va;
#line 603
  __memset((void *)req, 0, 540UL);
#line 604
  wrb = wrb_from_mccq(phba);
#line 605
  sge = nonembedded_sgl(wrb);
#line 606
  wrb->tag0 = wrb->tag0 | tag;
#line 608
  be_wrb_hdr_prepare(wrb, 540, 0, 1);
#line 609
  be_cmd_hdr_prepare(& req->hdr, 2, 1, 540);
#line 612
  req->ref_handle = 0U;
#line 613
  req->cleanup_type = 1U;
#line 614
  i = 0U;
  }
#line 614
  goto ldv_56352;
  ldv_56351: 
#line 615
  req->table[i].icd = inv_tbl->icd;
#line 616
  req->table[i].cid = inv_tbl->cid;
#line 617
  req->icd_count = req->icd_count + 1U;
#line 618
  inv_tbl = inv_tbl + 1;
#line 614
  i = i + 1U;
  ldv_56352: ;
#line 614
  if (i < num_invalidate) {
#line 616
    goto ldv_56351;
  } else {

  }
  {
#line 620
  sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 621
  sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 622
  sge->len = nonemb_cmd->size;
#line 624
  be_mcc_notify(phba);
#line 625
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 626
  return (tag);
}
}
#line 629 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba , struct beiscsi_endpoint *beiscsi_ep ,
                                        unsigned short cid , unsigned short issue_reset ,
                                        unsigned short savecfg_flag ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct iscsi_invalidate_connection_params_in *req ;
  unsigned int tag ;
  void *tmp ;

  {
  {
#line 635
  ctrl = & phba->ctrl;
#line 638
  tag = 0U;
#line 640
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 641
  tag = alloc_mcc_tag(phba);
  }
#line 642
  if (tag == 0U) {
    {
#line 643
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 644
    return (tag);
  } else {

  }
  {
#line 646
  wrb = wrb_from_mccq(phba);
#line 647
  wrb->tag0 = wrb->tag0 | tag;
#line 648
  tmp = embedded_payload(wrb);
#line 648
  req = (struct iscsi_invalidate_connection_params_in *)tmp;
#line 650
  be_wrb_hdr_prepare(wrb, 28, 1, 0);
#line 651
  be_cmd_hdr_prepare(& req->hdr, 6, 42, 28);
#line 654
  req->session_handle = beiscsi_ep->fw_handle;
#line 655
  req->cid = cid;
  }
#line 656
  if ((unsigned int )issue_reset != 0U) {
#line 657
    req->cleanup_type = 32770U;
  } else {
#line 659
    req->cleanup_type = 32769U;
  }
  {
#line 660
  req->save_cfg = savecfg_flag;
#line 661
  be_mcc_notify(phba);
#line 662
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 663
  return (tag);
}
}
#line 666 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_upload_connection(struct beiscsi_hba *phba , unsigned short cid ,
                                    unsigned int upload_flag ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct tcp_upload_params_in *req ;
  unsigned int tag ;
  void *tmp ;

  {
  {
#line 669
  ctrl = & phba->ctrl;
#line 672
  tag = 0U;
#line 674
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 675
  tag = alloc_mcc_tag(phba);
  }
#line 676
  if (tag == 0U) {
    {
#line 677
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 678
    return (tag);
  } else {

  }
  {
#line 680
  wrb = wrb_from_mccq(phba);
#line 681
  tmp = embedded_payload(wrb);
#line 681
  req = (struct tcp_upload_params_in *)tmp;
#line 682
  wrb->tag0 = wrb->tag0 | tag;
#line 684
  be_wrb_hdr_prepare(wrb, 24, 1, 0);
#line 685
  be_cmd_hdr_prepare(& req->hdr, 1, 56, 24);
#line 687
  req->id = cid;
#line 688
  req->upload_type = (u16 )((unsigned char )upload_flag);
#line 689
  be_mcc_notify(phba);
#line 690
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 691
  return (tag);
}
}
#line 704 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_open_connection(struct beiscsi_hba *phba , struct sockaddr *dst_addr , struct beiscsi_endpoint *beiscsi_ep ,
                         struct be_dma_mem *nonemb_cmd ) 
{ 
  struct hwi_controller *phwi_ctrlr ;
  struct hwi_context_memory *phwi_context ;
  struct sockaddr_in *daddr_in ;
  struct sockaddr_in6 *daddr_in6 ;
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct tcp_connect_and_offload_in_v1 *req ;
  unsigned short def_hdr_id ;
  unsigned short def_data_id ;
  struct phys_addr template_address ;
  struct phys_addr *ptemplate_address ;
  unsigned int tag ;
  unsigned int i ;
  unsigned int ulp_num ;
  unsigned short cid ;
  struct be_sge *sge ;
  __be32 s_addr ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  uint32_t log_value ;
  unsigned int tmp___3 ;
  uint32_t log_value___0 ;

  {
  {
#line 711
  daddr_in = (struct sockaddr_in *)dst_addr;
#line 712
  daddr_in6 = (struct sockaddr_in6 *)dst_addr;
#line 713
  ctrl = & phba->ctrl;
#line 718
  template_address.lo = 0U;
#line 718
  template_address.hi = 0U;
#line 720
  tag = 0U;
#line 722
  cid = beiscsi_ep->ep_cid;
#line 725
  phwi_ctrlr = phba->phwi_ctrlr;
#line 726
  phwi_context = phwi_ctrlr->phwi_ctxt;
#line 728
  ulp_num = (unsigned int )(phwi_ctrlr->wrb_context + (unsigned long )phba->cid_to_cri_map[(int )cid])->ulp_num;
#line 730
  def_hdr_id = (unsigned short )(phba->phwi_ctrlr)->default_pdu_hdr[ulp_num].id;
#line 731
  def_data_id = (unsigned short )(phba->phwi_ctrlr)->default_pdu_data[ulp_num].id;
#line 733
  ptemplate_address = & template_address;
#line 734
  ptemplate_address->lo = ((phba->init_mem + 21UL)->mem_array)->bus_address.u.a32.address_lo;
#line 734
  ptemplate_address->hi = ((phba->init_mem + 21UL)->mem_array)->bus_address.u.a32.address_hi;
#line 735
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 736
  tag = alloc_mcc_tag(phba);
  }
#line 737
  if (tag == 0U) {
    {
#line 738
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 739
    return ((int )tag);
  } else {

  }
  {
#line 741
  wrb = wrb_from_mccq(phba);
#line 742
  sge = nonembedded_sgl(wrb);
#line 744
  req = (struct tcp_connect_and_offload_in_v1 *)nonemb_cmd->va;
#line 745
  __memset((void *)req, 0, 72UL);
#line 746
  wrb->tag0 = wrb->tag0 | tag;
#line 748
  be_wrb_hdr_prepare(wrb, (int )nonemb_cmd->size, 0, 1);
#line 749
  be_cmd_hdr_prepare(& req->hdr, 2, 70, (int )nonemb_cmd->size);
  }
#line 752
  if ((unsigned int )dst_addr->sa_family == 2U) {
    {
#line 753
    s_addr = daddr_in->sin_addr.s_addr;
#line 754
    req->ip_address.ip_type = 1U;
#line 755
    req->ip_address.addr[0] = (u8 )s_addr;
#line 756
    req->ip_address.addr[1] = (u8 )((s_addr & 65280U) >> 8);
#line 757
    req->ip_address.addr[2] = (u8 )((s_addr & 16711680U) >> 16);
#line 758
    req->ip_address.addr[3] = (u8 )(s_addr >> 24);
#line 759
    tmp = __fswab16((int )daddr_in->sin_port);
#line 759
    req->tcp_port = tmp;
#line 760
    beiscsi_ep->dst_addr = (unsigned long )daddr_in->sin_addr.s_addr;
#line 761
    tmp___0 = __fswab16((int )daddr_in->sin_port);
#line 761
    beiscsi_ep->dst_tcpport = tmp___0;
#line 762
    beiscsi_ep->ip_type = 1U;
    }
  } else
#line 763
  if ((unsigned int )dst_addr->sa_family == 10U) {
    {
#line 764
    req->ip_address.ip_type = 16U;
#line 765
    __memcpy((void *)(& req->ip_address.addr), (void const   *)(& daddr_in6->sin6_addr.in6_u.u6_addr8),
             16UL);
#line 767
    tmp___1 = __fswab16((int )daddr_in6->sin6_port);
#line 767
    req->tcp_port = tmp___1;
#line 768
    tmp___2 = __fswab16((int )daddr_in6->sin6_port);
#line 768
    beiscsi_ep->dst_tcpport = tmp___2;
#line 769
    __memcpy((void *)(& beiscsi_ep->dst6_addr), (void const   *)(& daddr_in6->sin6_addr.in6_u.u6_addr8),
             16UL);
#line 771
    beiscsi_ep->ip_type = 16U;
    }
  } else {
#line 773
    log_value = phba->attr_log_enable;
#line 773
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 773
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : unknown addr family %d\n",
                 775, (int )dst_addr->sa_family);
      }
    } else {

    }
    {
#line 776
    ldv_spin_unlock_122(& ctrl->mbox_lock);
#line 777
    free_mcc_tag(& phba->ctrl, tag);
    }
#line 778
    return (-22);
  }
#line 781
  req->cid = cid;
#line 782
  tmp___3 = phba->nxt_cqid;
#line 782
  phba->nxt_cqid = phba->nxt_cqid + 1U;
#line 782
  i = tmp___3;
#line 783
  if (phba->nxt_cqid == phba->num_cpus) {
#line 784
    phba->nxt_cqid = 0U;
  } else {

  }
#line 785
  req->cq_id = phwi_context->be_cq[i].id;
#line 786
  log_value___0 = phba->attr_log_enable;
#line 786
  if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 786
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : i=%d cq_id=%d\n",
               787, i, (int )req->cq_id);
    }
  } else {

  }
#line 788
  req->defq_id = def_hdr_id;
#line 789
  req->hdr_ring_id = def_hdr_id;
#line 790
  req->data_ring_id = def_data_id;
#line 791
  req->do_offload = 1U;
#line 792
  req->dataout_template_pa.lo = ptemplate_address->lo;
#line 793
  req->dataout_template_pa.hi = ptemplate_address->hi;
#line 794
  sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 795
  sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 796
  sge->len = nonemb_cmd->size;
#line 798
  if (phba->generation - 2U > 1U) {
#line 799
    req->hdr.version = 1U;
#line 800
    req->tcp_window_size = 0U;
#line 801
    req->tcp_window_scale_count = 2U;
  } else {

  }
  {
#line 804
  be_mcc_notify(phba);
#line 805
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 806
  return ((int )tag);
}
}
#line 809 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_cmd_get_all_if_id_req *req ;
  void *tmp___0 ;
  struct be_cmd_get_all_if_id_req *pbe_allid ;
  int status ;
  uint32_t log_value ;

  {
  {
#line 811
  ctrl = & phba->ctrl;
#line 812
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 812
  wrb = tmp;
#line 813
  tmp___0 = embedded_payload(wrb);
#line 813
  req = (struct be_cmd_get_all_if_id_req *)tmp___0;
#line 814
  pbe_allid = req;
#line 815
  status = 0;
#line 817
  __memset((void *)wrb, 0, 256UL);
#line 819
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 821
  be_wrb_hdr_prepare(wrb, 24, 1, 0);
#line 822
  be_cmd_hdr_prepare(& req->hdr, 2, 24, 24);
#line 825
  status = be_mbox_notify(ctrl);
  }
#line 826
  if (status == 0) {
#line 827
    phba->interface_handle = pbe_allid->if_hndl_list[0];
  } else {
#line 829
    log_value = phba->attr_log_enable;
#line 829
    if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 829
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed in mgmt_get_all_if_id\n",
                 830);
      }
    } else {

    }
  }
  {
#line 832
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 834
  return ((unsigned int )status);
}
}
#line 845 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
static int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba , struct be_dma_mem *nonemb_cmd ,
                                void *resp_buf , int resp_buf_len ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_sge *sge ;
  unsigned int tag ;
  int rc ;
  uint32_t log_value ;

  {
  {
#line 849
  ctrl = & phba->ctrl;
#line 853
  rc = 0;
#line 855
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 856
  tag = alloc_mcc_tag(phba);
  }
#line 857
  if (tag == 0U) {
    {
#line 858
    ldv_spin_unlock_122(& ctrl->mbox_lock);
#line 859
    rc = -12;
    }
#line 860
    goto free_cmd;
  } else {

  }
  {
#line 863
  wrb = wrb_from_mccq(phba);
#line 864
  wrb->tag0 = wrb->tag0 | tag;
#line 865
  sge = nonembedded_sgl(wrb);
#line 867
  be_wrb_hdr_prepare(wrb, (int )nonemb_cmd->size, 0, 1);
#line 868
  sge->pa_hi = (unsigned int )(nonemb_cmd->dma >> 32ULL);
#line 869
  sge->pa_lo = (unsigned int )nonemb_cmd->dma;
#line 870
  sge->len = nonemb_cmd->size;
#line 872
  be_mcc_notify(phba);
#line 873
  ldv_spin_unlock_122(& ctrl->mbox_lock);
#line 875
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, nonemb_cmd);
  }
#line 877
  if ((unsigned long )resp_buf != (unsigned long )((void *)0)) {
    {
#line 878
    __memcpy(resp_buf, (void const   *)nonemb_cmd->va, (size_t )resp_buf_len);
    }
  } else {

  }
#line 880
  if (rc != 0) {
#line 882
    if (rc == -11) {
#line 883
      return (rc);
    } else {

    }
#line 885
    log_value = phba->attr_log_enable;
#line 885
    if ((log_value & 34U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 885
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : mgmt_exec_nonemb_cmd Failed status\n",
                 887);
      }
    } else {

    }
#line 889
    if (rc != -16) {
#line 890
      goto free_cmd;
    } else {
#line 892
      return (rc);
    }
  } else {

  }
  free_cmd: 
  {
#line 895
  pci_free_consistent(ctrl->pdev, (size_t )nonemb_cmd->size, nonemb_cmd->va, nonemb_cmd->dma);
  }
#line 897
  return (rc);
}
}
#line 900 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
static int mgmt_alloc_cmd_data(struct beiscsi_hba *phba , struct be_dma_mem *cmd ,
                               int iscsi_cmd , int size ) 
{ 
  uint32_t log_value ;

  {
  {
#line 903
  cmd->va = pci_zalloc_consistent___0(phba->ctrl.pdev, (size_t )size, & cmd->dma);
  }
#line 904
  if ((unsigned long )cmd->va == (unsigned long )((void *)0)) {
#line 905
    log_value = phba->attr_log_enable;
#line 905
    if ((log_value & 32U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 905
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to allocate memory for if info\n",
                 906);
      }
    } else {

    }
#line 907
    return (-12);
  } else {

  }
  {
#line 909
  cmd->size = (u32 )size;
#line 910
  be_cmd_hdr_prepare((struct be_cmd_req_hdr *)cmd->va, 2, (int )((u8 )iscsi_cmd),
                     size);
  }
#line 911
  return (0);
}
}
#line 915 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
static int mgmt_static_ip_modify(struct beiscsi_hba *phba , struct be_cmd_get_if_info_resp *if_info ,
                                 struct iscsi_iface_param_info *ip_param , struct iscsi_iface_param_info *subnet_param ,
                                 uint32_t ip_action ) 
{ 
  struct be_cmd_set_ip_addr_req *req ;
  struct be_dma_mem nonemb_cmd ;
  uint32_t ip_type ;
  int rc ;
  uint32_t log_value ;

  {
  {
#line 926
  rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 21, 72);
  }
#line 929
  if (rc != 0) {
#line 930
    return (rc);
  } else {

  }
#line 932
  ip_type = (unsigned int )ip_param->param == 7U ? 16U : 1U;
#line 935
  req = (struct be_cmd_set_ip_addr_req *)nonemb_cmd.va;
#line 936
  req->ip_params.record_entry_count = 1U;
#line 937
  req->ip_params.ip_record.action = ip_action;
#line 938
  req->ip_params.ip_record.interface_hndl = phba->interface_handle;
#line 940
  req->ip_params.ip_record.ip_addr.size_of_structure = 40U;
#line 942
  req->ip_params.ip_record.ip_addr.ip_type = (u8 )ip_type;
#line 944
  if (ip_action == 1U) {
    {
#line 945
    __memcpy((void *)(& req->ip_params.ip_record.ip_addr.addr), (void const   *)(& ip_param->value),
             16UL);
    }
#line 948
    if ((unsigned long )subnet_param != (unsigned long )((struct iscsi_iface_param_info *)0)) {
      {
#line 949
      __memcpy((void *)(& req->ip_params.ip_record.ip_addr.subnet_mask), (void const   *)(& subnet_param->value),
               16UL);
      }
    } else {

    }
  } else {
    {
#line 953
    __memcpy((void *)(& req->ip_params.ip_record.ip_addr.addr), (void const   *)(& if_info->ip_addr.addr),
             16UL);
#line 957
    __memcpy((void *)(& req->ip_params.ip_record.ip_addr.subnet_mask), (void const   *)(& if_info->ip_addr.subnet_mask),
             16UL);
    }
  }
  {
#line 962
  rc = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)0, 0);
  }
#line 963
  if (rc < 0) {
#line 964
    log_value = phba->attr_log_enable;
#line 964
    if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 964
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to Modify existing IP Address\n",
                 965);
      }
    } else {

    }
  } else {

  }
#line 966
  return (rc);
}
}
#line 969 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
static int mgmt_modify_gateway(struct beiscsi_hba *phba , uint8_t *gt_addr , uint32_t gtway_action ,
                               uint32_t param_len ) 
{ 
  struct be_cmd_set_def_gateway_req *req ;
  struct be_dma_mem nonemb_cmd ;
  int rt_val ;
  int tmp ;

  {
  {
#line 977
  rt_val = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 23, 44);
  }
#line 980
  if (rt_val != 0) {
#line 981
    return (rt_val);
  } else {

  }
  {
#line 983
  req = (struct be_cmd_set_def_gateway_req *)nonemb_cmd.va;
#line 984
  req->action = gtway_action;
#line 985
  req->ip_addr.ip_type = 1U;
#line 987
  __memcpy((void *)(& req->ip_addr.addr), (void const   *)gt_addr, 16UL);
#line 989
  tmp = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)0, 0);
  }
#line 989
  return (tmp);
}
}
#line 992 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_set_ip(struct beiscsi_hba *phba , struct iscsi_iface_param_info *ip_param ,
                struct iscsi_iface_param_info *subnet_param , uint32_t boot_proto ) 
{ 
  struct be_cmd_get_def_gateway_resp gtway_addr_set ;
  struct be_cmd_get_if_info_resp *if_info ;
  struct be_cmd_set_dhcp_req *dhcpreq ;
  struct be_cmd_rel_dhcp_req *reldhcp ;
  struct be_dma_mem nonemb_cmd ;
  uint8_t *gtway_addr ;
  uint32_t ip_type ;
  int rc ;
  unsigned int tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;

  {
  {
#line 1006
  tmp = mgmt_get_all_if_id(phba);
  }
#line 1006
  if (tmp != 0U) {
#line 1007
    return (-5);
  } else {

  }
  {
#line 1009
  ip_type = (unsigned int )ip_param->param == 7U ? 16U : 1U;
#line 1012
  rc = mgmt_get_if_info(phba, (int )ip_type, & if_info);
  }
#line 1013
  if (rc != 0) {
#line 1014
    return (rc);
  } else {

  }
#line 1016
  if (boot_proto == 2U) {
#line 1017
    if (if_info->dhcp_state != 0U) {
#line 1018
      log_value = phba->attr_log_enable;
#line 1018
      if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 1018
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : DHCP Already Enabled\n", 1019);
        }
      } else {

      }
#line 1020
      goto exit;
    } else {

    }
#line 1026
    ip_param->len = (unsigned int )ip_param->param == 7U ? 16U : 4U;
  } else
#line 1030
  if (if_info->dhcp_state != 0U) {
    {
#line 1032
    __memset((void *)if_info, 0, 72UL);
#line 1033
    rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 18, 24);
    }
#line 1037
    if (rc != 0) {
#line 1038
      goto exit;
    } else {

    }
    {
#line 1040
    reldhcp = (struct be_cmd_rel_dhcp_req *)nonemb_cmd.va;
#line 1041
    reldhcp->interface_hndl = phba->interface_handle;
#line 1042
    reldhcp->ip_type = ip_type;
#line 1044
    rc = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)0, 0);
    }
#line 1045
    if (rc < 0) {
#line 1046
      log_value___0 = phba->attr_log_enable;
#line 1046
      if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 1046
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : Failed to Delete existing dhcp\n", 1048);
        }
      } else {

      }
#line 1049
      goto exit;
    } else {

    }
  } else {

  }
#line 1055
  if ((unsigned int )if_info->ip_addr.addr[0] != 0U) {
    {
#line 1056
    rc = mgmt_static_ip_modify(phba, if_info, ip_param, (struct iscsi_iface_param_info *)0,
                               2U);
    }
#line 1058
    if (rc != 0) {
#line 1059
      goto exit;
    } else {

    }
  } else {

  }
#line 1063
  if (boot_proto == 2U) {
    {
#line 1064
    __memset((void *)(& gtway_addr_set), 0, 40UL);
#line 1065
    rc = mgmt_get_gateway(phba, 1, & gtway_addr_set);
    }
#line 1066
    if (rc != 0) {
#line 1067
      log_value___1 = phba->attr_log_enable;
#line 1067
      if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 1067
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : Failed to Get Gateway Addr\n", 1068);
        }
      } else {

      }
#line 1069
      goto exit;
    } else {

    }
#line 1072
    if ((unsigned int )gtway_addr_set.ip_addr.addr[0] != 0U) {
      {
#line 1073
      gtway_addr = (uint8_t *)(& gtway_addr_set.ip_addr.addr);
#line 1074
      rc = mgmt_modify_gateway(phba, gtway_addr, 2U, 4U);
      }
#line 1077
      if (rc != 0) {
#line 1078
        log_value___2 = phba->attr_log_enable;
#line 1078
        if ((log_value___2 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
          {
#line 1078
          dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BG_%d : Failed to clear Gateway Addr Set\n", 1080);
          }
        } else {

        }
#line 1081
        goto exit;
      } else {

      }
    } else {

    }
  } else {

  }
#line 1087
  if (boot_proto == 2U) {
    {
#line 1088
    rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 17, 32);
    }
#line 1091
    if (rc != 0) {
#line 1092
      goto exit;
    } else {

    }
    {
#line 1094
    dhcpreq = (struct be_cmd_set_dhcp_req *)nonemb_cmd.va;
#line 1095
    dhcpreq->flags = 1U;
#line 1096
    dhcpreq->retry_count = 1U;
#line 1097
    dhcpreq->interface_hndl = phba->interface_handle;
#line 1098
    dhcpreq->ip_type = 5U;
#line 1100
    rc = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)0, 0);
    }
  } else {
    {
#line 1102
    rc = mgmt_static_ip_modify(phba, if_info, ip_param, subnet_param, 1U);
    }
  }
  exit: 
  {
#line 1107
  kfree((void const   *)if_info);
  }
#line 1108
  return (rc);
}
}
#line 1111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_set_gateway(struct beiscsi_hba *phba , struct iscsi_iface_param_info *gateway_param ) 
{ 
  struct be_cmd_get_def_gateway_resp gtway_addr_set ;
  uint8_t *gtway_addr ;
  int rt_val ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
  {
#line 1118
  __memset((void *)(& gtway_addr_set), 0, 40UL);
#line 1119
  rt_val = mgmt_get_gateway(phba, 1, & gtway_addr_set);
  }
#line 1120
  if (rt_val != 0) {
#line 1121
    log_value = phba->attr_log_enable;
#line 1121
    if ((log_value & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 1121
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to Get Gateway Addr\n",
                 1122);
      }
    } else {

    }
#line 1123
    return (rt_val);
  } else {

  }
#line 1126
  if ((unsigned int )gtway_addr_set.ip_addr.addr[0] != 0U) {
    {
#line 1127
    gtway_addr = (uint8_t *)(& gtway_addr_set.ip_addr.addr);
#line 1128
    rt_val = mgmt_modify_gateway(phba, gtway_addr, 2U, gateway_param->len);
    }
#line 1130
    if (rt_val != 0) {
#line 1131
      log_value___0 = phba->attr_log_enable;
#line 1131
      if ((log_value___0 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 1131
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BG_%d : Failed to clear Gateway Addr Set\n", 1132);
        }
      } else {

      }
#line 1133
      return (rt_val);
    } else {

    }
  } else {

  }
  {
#line 1137
  gtway_addr = (uint8_t *)(& gateway_param->value);
#line 1138
  rt_val = mgmt_modify_gateway(phba, gtway_addr, 1U, gateway_param->len);
  }
#line 1141
  if (rt_val != 0) {
#line 1142
    log_value___1 = phba->attr_log_enable;
#line 1142
    if ((log_value___1 & 32U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 1142
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Failed to Set Gateway Addr\n",
                 1143);
      }
    } else {

    }
  } else {

  }
#line 1145
  return (rt_val);
}
}
#line 1148 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_get_gateway(struct beiscsi_hba *phba , int ip_type , struct be_cmd_get_def_gateway_resp *gateway ) 
{ 
  struct be_cmd_get_def_gateway_req *req ;
  struct be_dma_mem nonemb_cmd ;
  int rc ;
  int tmp ;

  {
  {
#line 1155
  rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 22, 40);
  }
#line 1158
  if (rc != 0) {
#line 1159
    return (rc);
  } else {

  }
  {
#line 1161
  req = (struct be_cmd_get_def_gateway_req *)nonemb_cmd.va;
#line 1162
  req->ip_type = (u32 )ip_type;
#line 1164
  tmp = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)gateway, 40);
  }
#line 1164
  return (tmp);
}
}
#line 1168 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_get_if_info(struct beiscsi_hba *phba , int ip_type , struct be_cmd_get_if_info_resp **if_info ) 
{ 
  struct be_cmd_get_if_info_req *req ;
  struct be_dma_mem nonemb_cmd ;
  uint32_t ioctl_size ;
  int rc ;
  unsigned int tmp ;
  void *tmp___0 ;
  uint32_t log_value ;

  {
  {
#line 1173
  ioctl_size = 72U;
#line 1176
  tmp = mgmt_get_all_if_id(phba);
  }
#line 1176
  if (tmp != 0U) {
#line 1177
    return (-5);
  } else {

  }
  ldv_56497: 
  {
#line 1180
  rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 25, (int )ioctl_size);
  }
#line 1183
  if (rc != 0) {
#line 1184
    return (rc);
  } else {

  }
  {
#line 1186
  req = (struct be_cmd_get_if_info_req *)nonemb_cmd.va;
#line 1187
  req->interface_hndl = phba->interface_handle;
#line 1188
  req->ip_type = (u32 )ip_type;
#line 1191
  tmp___0 = kzalloc((size_t )ioctl_size, 208U);
#line 1191
  *if_info = (struct be_cmd_get_if_info_resp *)tmp___0;
  }
#line 1192
  if ((unsigned long )*if_info == (unsigned long )((struct be_cmd_get_if_info_resp *)0)) {
#line 1193
    log_value = phba->attr_log_enable;
#line 1193
    if ((log_value & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1193
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Memory Allocation Failure\n",
                 1195);
      }
    } else {

    }
    {
#line 1198
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
    }
#line 1202
    return (-12);
  } else {

  }
  {
#line 1205
  rc = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)*if_info, (int )ioctl_size);
  }
#line 1209
  if (rc == -11) {
    {
#line 1212
    ioctl_size = ((struct be_cmd_resp_hdr *)nonemb_cmd.va)->actual_resp_len;
#line 1214
    ioctl_size = ioctl_size + 16U;
#line 1217
    pci_free_consistent(phba->ctrl.pdev, (size_t )nonemb_cmd.size, nonemb_cmd.va,
                        nonemb_cmd.dma);
#line 1222
    kfree((void const   *)*if_info);
    }
  } else {
#line 1224
    goto ldv_56496;
  }
#line 1225
  goto ldv_56497;
  ldv_56496: ;
#line 1226
  return (rc);
}
}
#line 1229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_get_nic_conf(struct beiscsi_hba *phba , struct be_cmd_get_nic_conf_resp *nic ) 
{ 
  struct be_dma_mem nonemb_cmd ;
  int rc ;
  int tmp ;

  {
  {
#line 1235
  rc = mgmt_alloc_cmd_data(phba, & nonemb_cmd, 7, 136);
  }
#line 1238
  if (rc != 0) {
#line 1239
    return (rc);
  } else {

  }
  {
#line 1241
  tmp = mgmt_exec_nonemb_cmd(phba, & nonemb_cmd, (void *)nic, 136);
  }
#line 1241
  return (tmp);
}
}
#line 1246 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int be_cmd_get_initname(struct beiscsi_hba *phba ) 
{ 
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_hba_name *req ;
  struct be_ctrl_info *ctrl ;
  void *tmp ;

  {
  {
#line 1248
  tag = 0U;
#line 1251
  ctrl = & phba->ctrl;
#line 1253
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1254
  tag = alloc_mcc_tag(phba);
  }
#line 1255
  if (tag == 0U) {
    {
#line 1256
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 1257
    return (tag);
  } else {

  }
  {
#line 1260
  wrb = wrb_from_mccq(phba);
#line 1261
  tmp = embedded_payload(wrb);
#line 1261
  req = (struct be_cmd_hba_name *)tmp;
#line 1262
  wrb->tag0 = wrb->tag0 | tag;
#line 1263
  be_wrb_hdr_prepare(wrb, 276, 1, 0);
#line 1264
  be_cmd_hdr_prepare(& req->hdr, 6, 6, 276);
#line 1268
  be_mcc_notify(phba);
#line 1269
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1270
  return (tag);
}
}
#line 1273 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
unsigned int be_cmd_get_port_speed(struct beiscsi_hba *phba ) 
{ 
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_ntwk_link_status_req *req ;
  struct be_ctrl_info *ctrl ;
  void *tmp ;

  {
  {
#line 1275
  tag = 0U;
#line 1278
  ctrl = & phba->ctrl;
#line 1280
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1281
  tag = alloc_mcc_tag(phba);
  }
#line 1282
  if (tag == 0U) {
    {
#line 1283
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 1284
    return (tag);
  } else {

  }
  {
#line 1287
  wrb = wrb_from_mccq(phba);
#line 1288
  tmp = embedded_payload(wrb);
#line 1288
  req = (struct be_cmd_ntwk_link_status_req *)tmp;
#line 1289
  wrb->tag0 = wrb->tag0 | tag;
#line 1290
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
#line 1291
  be_cmd_hdr_prepare(& req->hdr, 1, 5, 20);
#line 1295
  be_mcc_notify(phba);
#line 1296
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1297
  return (tag);
}
}
#line 1314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba , unsigned int *s_handle ) 
{ 
  struct be_cmd_get_boot_target_resp *boot_resp ;
  struct be_mcc_wrb *wrb ;
  unsigned int tag ;
  uint8_t boot_retry ;
  int rc ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  void *tmp ;
  uint32_t log_value___1 ;
  uint32_t log_value___2 ;
  uint32_t log_value___3 ;
  uint32_t log_value___4 ;

  {
#line 1320
  boot_retry = 3U;
  ldv_56532: 
  {
#line 1325
  tag = mgmt_get_boot_target(phba);
  }
#line 1326
  if (tag == 0U) {
#line 1327
    log_value = phba->attr_log_enable;
#line 1327
    if ((log_value & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1327
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Getting Boot Target Info Failed\n",
                 1329);
      }
    } else {

    }
#line 1330
    return (-11);
  } else {

  }
  {
#line 1333
  rc = beiscsi_mccq_compl(phba, tag, & wrb, (struct be_dma_mem *)0);
  }
#line 1334
  if (rc != 0) {
#line 1335
    log_value___0 = phba->attr_log_enable;
#line 1335
    if ((log_value___0 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1335
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : MBX CMD get_boot_target Failed\n",
                 1337);
      }
    } else {

    }
#line 1338
    return (-16);
  } else {

  }
  {
#line 1341
  tmp = embedded_payload(wrb);
#line 1341
  boot_resp = (struct be_cmd_get_boot_target_resp *)tmp;
  }
#line 1344
  if (boot_resp->boot_session_count == 0U) {
#line 1345
    log_value___1 = phba->attr_log_enable;
#line 1345
    if ((log_value___1 & 33U) != 0U || (int )((signed char )*("\016" + 1)) <= 51) {
      {
#line 1345
      dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev),
                 "BG_%d  ;No boot targets configured\n", 1347);
      }
    } else {

    }
#line 1348
    return (-6);
  } else {

  }
#line 1352
  if (boot_resp->boot_session_handle != -1) {
#line 1353
    *s_handle = (unsigned int )boot_resp->boot_session_handle;
#line 1354
    return (0);
  } else {

  }
  {
#line 1358
  tag = mgmt_reopen_session(phba, 1U, 4294967295U);
  }
#line 1360
  if (tag == 0U) {
#line 1361
    log_value___2 = phba->attr_log_enable;
#line 1361
    if ((log_value___2 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1361
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : mgmt_reopen_session Failed\n",
                 1363);
      }
    } else {

    }
#line 1364
    return (-11);
  } else {

  }
  {
#line 1367
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
  }
#line 1368
  if (rc != 0) {
#line 1369
    log_value___3 = phba->attr_log_enable;
#line 1369
    if ((log_value___3 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1369
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : mgmt_reopen_session Failed",
                 1371);
      }
    } else {

    }
#line 1372
    return (rc);
  } else {

  }
#line 1374
  boot_retry = (uint8_t )((int )boot_retry - 1);
#line 1374
  if ((unsigned int )boot_retry != 0U) {
#line 1376
    goto ldv_56532;
  } else {

  }
#line 1377
  log_value___4 = phba->attr_log_enable;
#line 1377
  if ((log_value___4 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
    {
#line 1377
    dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : Login to Boot Target Failed\n",
               1379);
    }
  } else {

  }
#line 1380
  return (-6);
}
}
#line 1395 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
int mgmt_set_vlan(struct beiscsi_hba *phba , uint16_t vlan_tag ) 
{ 
  int rc ;
  unsigned int tag ;
  int tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
  {
#line 1401
  tmp = be_cmd_set_vlan(phba, (int )vlan_tag);
#line 1401
  tag = (unsigned int )tmp;
  }
#line 1402
  if (tag == 0U) {
#line 1403
    log_value = phba->attr_log_enable;
#line 1403
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1403
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BG_%d : VLAN Setting Failed\n",
                 1405);
      }
    } else {

    }
#line 1406
    return (-16);
  } else {

  }
  {
#line 1409
  rc = beiscsi_mccq_compl(phba, tag, (struct be_mcc_wrb **)0, (struct be_dma_mem *)0);
  }
#line 1410
  if (rc != 0) {
#line 1411
    log_value___0 = phba->attr_log_enable;
#line 1411
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1411
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BS_%d : VLAN MBX Cmd Failed\n",
                 1413);
      }
    } else {

    }
#line 1414
    return (rc);
  } else {

  }
#line 1416
  return (rc);
}
}
#line 1429 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_drvr_ver_disp(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  int tmp ;

  {
  {
#line 1432
  tmp = snprintf(buf, 4096UL, "Emulex OneConnectOpen-iSCSI Driver version10.4.114.0\n");
  }
#line 1432
  return ((ssize_t )tmp);
}
}
#line 1445 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_fw_ver_disp(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1448
  __mptr = (struct device  const  *)dev;
#line 1448
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c8UL;
#line 1449
  tmp = shost_priv(shost);
#line 1449
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1451
  tmp___0 = snprintf(buf, 4096UL, "%s\n", (char *)(& phba->fw_ver_str));
  }
#line 1451
  return ((ssize_t )tmp___0);
}
}
#line 1464 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_active_session_disp(struct device *dev , struct device_attribute *attr ,
                                    char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint16_t avlbl_cids ;
  uint16_t ulp_num ;
  uint16_t len ;
  uint16_t total_cids ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  {
#line 1467
  __mptr = (struct device  const  *)dev;
#line 1467
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c8UL;
#line 1468
  tmp = shost_priv(shost);
#line 1468
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1469
  avlbl_cids = 0U;
#line 1469
  len = 0U;
#line 1469
  total_cids = 0U;
#line 1471
  ulp_num = 0U;
  }
#line 1471
  goto ldv_56571;
  ldv_56570: 
  {
#line 1472
  tmp___3 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 1472
  if (tmp___3 != 0) {
    {
#line 1473
    avlbl_cids = (phba->cid_array_info[(int )ulp_num])->avlbl_cids;
#line 1474
    total_cids = (uint16_t )phba->fw_config.iscsi_cid_count[(int )ulp_num];
#line 1475
    tmp___0 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "ULP%d : %d\n",
                       (int )ulp_num, (int )total_cids - (int )avlbl_cids);
#line 1475
    len = (int )len + (int )((uint16_t )tmp___0);
    }
  } else {
    {
#line 1479
    tmp___1 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "ULP%d : %d\n",
                       (int )ulp_num, 0);
#line 1479
    len = (int )len + (int )((uint16_t )tmp___1);
    }
  }
#line 1471
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_56571: ;
#line 1471
  if ((unsigned int )ulp_num <= 1U) {
#line 1473
    goto ldv_56570;
  } else {

  }

#line 1483
  return ((ssize_t )len);
}
}
#line 1496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_free_session_disp(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint16_t ulp_num ;
  uint16_t len ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;

  {
  {
#line 1499
  __mptr = (struct device  const  *)dev;
#line 1499
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c8UL;
#line 1500
  tmp = shost_priv(shost);
#line 1500
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1501
  len = 0U;
#line 1503
  ulp_num = 0U;
  }
#line 1503
  goto ldv_56585;
  ldv_56584: 
  {
#line 1504
  tmp___3 = variable_test_bit((long )ulp_num, (unsigned long const volatile   *)(& phba->fw_config.ulp_supported));
  }
#line 1504
  if (tmp___3 != 0) {
    {
#line 1505
    tmp___0 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "ULP%d : %d\n",
                       (int )ulp_num, (int )(phba->cid_array_info[(int )ulp_num])->avlbl_cids);
#line 1505
    len = (int )len + (int )((uint16_t )tmp___0);
    }
  } else {
    {
#line 1509
    tmp___1 = snprintf(buf + (unsigned long )len, 4096UL - (unsigned long )len, "ULP%d : %d\n",
                       (int )ulp_num, 0);
#line 1509
    len = (int )len + (int )((uint16_t )tmp___1);
    }
  }
#line 1503
  ulp_num = (uint16_t )((int )ulp_num + 1);
  ldv_56585: ;
#line 1503
  if ((unsigned int )ulp_num <= 1U) {
#line 1505
    goto ldv_56584;
  } else {

  }

#line 1513
  return ((ssize_t )len);
}
}
#line 1526 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_adap_family_disp(struct device *dev , struct device_attribute *attr ,
                                 char *buf ) 
{ 
  uint16_t dev_id ;
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1529
  dev_id = 0U;
#line 1530
  __mptr = (struct device  const  *)dev;
#line 1530
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c8UL;
#line 1531
  tmp = shost_priv(shost);
#line 1531
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1533
  dev_id = (phba->pcidev)->device;
  }
  {
#line 1535
  if ((int )dev_id == 530) {
#line 1535
    goto case_530;
  } else {

  }
#line 1536
  if ((int )dev_id == 1794) {
#line 1536
    goto case_1794;
  } else {

  }
#line 1537
  if ((int )dev_id == 1795) {
#line 1537
    goto case_1795;
  } else {

  }
#line 1540
  if ((int )dev_id == 546) {
#line 1540
    goto case_546;
  } else {

  }
#line 1541
  if ((int )dev_id == 1810) {
#line 1541
    goto case_1810;
  } else {

  }
#line 1544
  if ((int )dev_id == 1826) {
#line 1544
    goto case_1826;
  } else {

  }
#line 1547
  goto switch_default;
  case_530: /* CIL Label */ ;
  case_1794: /* CIL Label */ ;
  case_1795: /* CIL Label */ 
  {
#line 1538
  tmp___0 = snprintf(buf, 4096UL, "BE2 Adapter Family\n");
  }
#line 1538
  return ((ssize_t )tmp___0);
  case_546: /* CIL Label */ ;
  case_1810: /* CIL Label */ 
  {
#line 1542
  tmp___1 = snprintf(buf, 4096UL, "BE3-R Adapter Family\n");
  }
#line 1542
  return ((ssize_t )tmp___1);
  case_1826: /* CIL Label */ 
  {
#line 1545
  tmp___2 = snprintf(buf, 4096UL, "Skyhawk-R Adapter Family\n");
  }
#line 1545
  return ((ssize_t )tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 1548
  tmp___3 = snprintf(buf, 4096UL, "Unknown Adapter Family: 0x%x\n", (int )dev_id);
  }
#line 1548
  return ((ssize_t )tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1564 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
ssize_t beiscsi_phys_port_disp(struct device *dev , struct device_attribute *attr ,
                               char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1567
  __mptr = (struct device  const  *)dev;
#line 1567
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c8UL;
#line 1568
  tmp = shost_priv(shost);
#line 1568
  phba = (struct beiscsi_hba *)tmp + 224U;
#line 1570
  tmp___0 = snprintf(buf, 4096UL, "Port Identifier : %d\n", phba->fw_config.phys_port);
  }
#line 1570
  return ((ssize_t )tmp___0);
}
}
#line 1574 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
void beiscsi_offload_cxn_v0(struct beiscsi_offload_params *params , struct wrb_handle *pwrb_handle ,
                            struct be_mem_descriptor *mem_descr ) 
{ 
  struct iscsi_wrb *pwrb ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;
  u32 tmp___16 ;

  {
  {
#line 1578
  pwrb = pwrb_handle->pwrb;
#line 1580
  __memset((void *)pwrb, 0, 64UL);
#line 1581
  tmp = amap_mask(17U);
#line 1581
  amap_set((void *)pwrb, 2U, tmp, 15U, params->dw[1UL]);
#line 1585
  tmp___0 = amap_mask(4U);
#line 1585
  amap_set((void *)pwrb, 0U, tmp___0, 28U, 7U);
#line 1587
  tmp___1 = amap_mask(14U);
#line 1587
  amap_set((void *)pwrb, 3U, tmp___1, 0U, params->dw[2UL]);
#line 1592
  tmp___2 = amap_mask(2U);
#line 1592
  amap_set((void *)pwrb, 4U, tmp___2, 19U, params->dw[3UL] & 3U);
#line 1595
  tmp___3 = amap_mask(1U);
#line 1595
  amap_set((void *)pwrb, 4U, tmp___3, 18U, (params->dw[3UL] & 4U) >> 2);
#line 1598
  tmp___4 = amap_mask(1U);
#line 1598
  amap_set((void *)pwrb, 4U, tmp___4, 17U, (params->dw[3UL] & 8U) >> 3);
#line 1601
  tmp___5 = amap_mask(1U);
#line 1601
  amap_set((void *)pwrb, 4U, tmp___5, 28U, (params->dw[3UL] & 16U) >> 4);
#line 1604
  tmp___6 = amap_mask(1U);
#line 1604
  amap_set((void *)pwrb, 4U, tmp___6, 27U, (params->dw[3UL] & 32U) >> 5);
#line 1607
  tmp___7 = amap_mask(32U);
#line 1607
  amap_set((void *)pwrb, 5U, tmp___7, 0U, params->dw[4UL] + 1U);
#line 1611
  tmp___8 = amap_mask(8U);
#line 1611
  amap_set((void *)pwrb, 0U, tmp___8, 16U, (u32 )pwrb_handle->wrb_index);
#line 1614
  tmp___9 = amap_mask(19U);
#line 1614
  amap_set((void *)pwrb, 1U, tmp___9, 8U, params->dw[0UL]);
#line 1619
  tmp___10 = amap_mask(8U);
#line 1619
  amap_set((void *)pwrb, 1U, tmp___10, 0U, (u32 )pwrb_handle->nxt_wrb_index);
#line 1621
  tmp___11 = amap_mask(3U);
#line 1621
  amap_set((void *)pwrb, 3U, tmp___11, 29U, 0U);
#line 1623
  tmp___12 = amap_mask(1U);
#line 1623
  amap_set((void *)pwrb, 4U, tmp___12, 31U, 1U);
#line 1625
  tmp___13 = amap_mask(2U);
#line 1625
  amap_set((void *)pwrb, 4U, tmp___13, 29U, 0U);
#line 1627
  tmp___14 = amap_mask(1U);
#line 1627
  amap_set((void *)pwrb, 4U, tmp___14, 26U, 0U);
#line 1630
  mem_descr = mem_descr + 21UL;
#line 1631
  tmp___15 = amap_mask(32U);
#line 1631
  amap_set((void *)pwrb, 6U, tmp___15, 0U, (mem_descr->mem_array)->bus_address.u.a32.address_hi);
#line 1634
  tmp___16 = amap_mask(32U);
#line 1634
  amap_set((void *)pwrb, 7U, tmp___16, 0U, (mem_descr->mem_array)->bus_address.u.a32.address_lo);
  }
#line 1635
  return;
}
}
#line 1639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_mgmt.c"
void beiscsi_offload_cxn_v2(struct beiscsi_offload_params *params , struct wrb_handle *pwrb_handle ) 
{ 
  struct iscsi_wrb *pwrb ;
  u32 tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  u32 tmp___15 ;

  {
  {
#line 1642
  pwrb = pwrb_handle->pwrb;
#line 1644
  __memset((void *)pwrb, 0, 64UL);
#line 1646
  tmp = amap_mask(24U);
#line 1646
  amap_set((void *)pwrb, 0U, tmp, 0U, params->dw[0UL]);
#line 1650
  tmp___0 = amap_mask(5U);
#line 1650
  amap_set((void *)pwrb, 0U, tmp___0, 27U, 7U);
#line 1653
  tmp___1 = amap_mask(8U);
#line 1653
  amap_set((void *)pwrb, 1U, tmp___1, 0U, (u32 )pwrb_handle->nxt_wrb_index);
#line 1656
  tmp___2 = amap_mask(8U);
#line 1656
  amap_set((void *)pwrb, 1U, tmp___2, 8U, (u32 )pwrb_handle->wrb_index);
#line 1658
  tmp___3 = amap_mask(24U);
#line 1658
  amap_set((void *)pwrb, 2U, tmp___3, 0U, params->dw[1UL]);
#line 1662
  tmp___4 = amap_mask(24U);
#line 1662
  amap_set((void *)pwrb, 3U, tmp___4, 0U, params->dw[2UL]);
#line 1666
  tmp___5 = amap_mask(24U);
#line 1666
  amap_set((void *)pwrb, 8U, tmp___5, 0U, params->dw[5UL]);
#line 1670
  tmp___6 = amap_mask(16U);
#line 1670
  amap_set((void *)pwrb, 11U, tmp___6, 0U, 1U);
#line 1672
  tmp___7 = amap_mask(2U);
#line 1672
  amap_set((void *)pwrb, 4U, tmp___7, 19U, params->dw[3UL] & 3U);
#line 1675
  tmp___8 = amap_mask(1U);
#line 1675
  amap_set((void *)pwrb, 4U, tmp___8, 18U, (params->dw[3UL] & 4U) >> 2);
#line 1678
  tmp___9 = amap_mask(1U);
#line 1678
  amap_set((void *)pwrb, 4U, tmp___9, 17U, (params->dw[3UL] & 8U) >> 3);
#line 1681
  tmp___10 = amap_mask(1U);
#line 1681
  amap_set((void *)pwrb, 4U, tmp___10, 28U, (params->dw[3UL] & 16U) >> 4);
#line 1685
  tmp___11 = amap_mask(1U);
#line 1685
  amap_set((void *)pwrb, 4U, tmp___11, 27U, (params->dw[3UL] & 32U) >> 5);
#line 1688
  tmp___12 = amap_mask(1U);
#line 1688
  amap_set((void *)pwrb, 11U, tmp___12, 30U, (params->dw[3UL] & 64U) >> 6);
#line 1694
  tmp___13 = amap_mask(1U);
#line 1694
  amap_set((void *)pwrb, 11U, tmp___13, 31U, (params->dw[3UL] & 128U) >> 7);
#line 1700
  tmp___14 = amap_mask(16U);
#line 1700
  amap_set((void *)pwrb, 4U, tmp___14, 0U, (params->dw[3UL] & 16776960U) >> 8);
#line 1705
  tmp___15 = amap_mask(32U);
#line 1705
  amap_set((void *)pwrb, 5U, tmp___15, 0U, params->dw[4UL] + 1U);
  }
#line 1706
  return;
}
}
#line 1572 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_mgmt.c.aux"
__inline static void ldv_spin_lock_121(spinlock_t *lock ) 
{ 


  {
  {
#line 1575
  ldv_linux_kernel_locking_spinlock_spin_lock_mbox_lock_of_be_ctrl_info();
#line 1577
  spin_lock(lock);
  }
#line 1578
  return;
}
}
#line 1580 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_mgmt.c.aux"
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) 
{ 


  {
  {
#line 1583
  ldv_linux_kernel_locking_spinlock_spin_unlock_mbox_lock_of_be_ctrl_info();
#line 1585
  spin_unlock(lock);
  }
#line 1586
  return;
}
}
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_cmds.c.aux"
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) ;
#line 437 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/log2.h"
__inline static int __ilog2_u32(u32 n ) 
{ 
  int tmp ;

  {
  {
#line 34
  tmp = fls((int )n);
  }
#line 34
  return (tmp + -1);
}
}
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 98
__inline static void atomic_inc(atomic_t *v ) ;
#line 114
__inline static void atomic_dec(atomic_t *v ) ;
#line 576 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_cmds.c.aux"
void ldv_linux_kernel_locking_spinlock_spin_lock_mcc_cq_lock_of_be_ctrl_info(void) ;
#line 577
void ldv_linux_kernel_locking_spinlock_spin_unlock_mcc_cq_lock_of_be_ctrl_info(void) ;
#line 362 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 366
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 370
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 374
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 378
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 382
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 386
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 390
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 394
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 398
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 402
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 406
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 410
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 414
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 418
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 422
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 426
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 430
__inline static void ldv_spin_lock_121(spinlock_t *lock ) ;
#line 455
__inline static void ldv_spin_lock_bh_131(spinlock_t *lock ) ;
#line 411
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 415
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 419
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 423
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 427
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 431
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 435
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 439
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 443
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 447
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 451
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 455
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 459
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 463
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 467
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 471
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 475
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 479
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 483
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 487
__inline static void ldv_spin_unlock_122(spinlock_t *lock ) ;
#line 512
__inline static void ldv_spin_unlock_bh_132(spinlock_t *lock ) ;
#line 149 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 56
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 56
  return (ret);
}
}
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 64
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 65
  return;
}
}
#line 761 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi_host.h"
__inline static struct Scsi_Host *dev_to_shost___1(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
#line 763
  goto ldv_36197;
  ldv_36196: ;
#line 764
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
#line 765
    return ((struct Scsi_Host *)0);
  } else {

  }
#line 766
  dev = dev->parent;
  ldv_36197: 
  {
#line 763
  tmp = scsi_is_host_device((struct device  const  *)dev);
  }
#line 763
  if (tmp == 0) {
#line 765
    goto ldv_36196;
  } else {

  }
#line 768
  __mptr = (struct device  const  *)dev;
#line 768
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffc48UL);
}
}
#line 433 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/libiscsi.h"
extern void iscsi_session_failure(struct iscsi_session * , enum iscsi_err  ) ;
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static void *queue_head_node(struct be_queue_info *q ) 
{ 


  {
#line 61
  return (q->dma_mem.va + (unsigned long )((int )q->head * (int )q->entry_size));
}
}
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static void *queue_get_wrb(struct be_queue_info *q , unsigned int wrb_num ) 
{ 


  {
#line 66
  return (q->dma_mem.va + (unsigned long )(wrb_num * (unsigned int )q->entry_size));
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be.h"
__inline static void queue_head_inc(struct be_queue_info *q ) 
{ 


  {
  {
#line 76
  index_inc(& q->head, (int )q->len);
  }
#line 77
  return;
}
}
#line 1349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.h"
int beiscsi_pci_soft_reset(struct beiscsi_hba *phba ) ;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_pci_soft_reset(struct beiscsi_hba *phba ) 
{ 
  u32 sreset ;
  u8 *pci_reset_offset ;
  u8 *pci_online0_offset ;
  u8 *pci_online1_offset ;
  u32 pconline0 ;
  u32 pconline1 ;
  u32 i ;

  {
  {
#line 27
  pci_reset_offset = (u8 *)0U;
#line 28
  pci_online0_offset = (u8 *)0U;
#line 29
  pci_online1_offset = (u8 *)0U;
#line 30
  pconline0 = 0U;
#line 31
  pconline1 = 0U;
#line 34
  pci_reset_offset = phba->pci_va + 92UL;
#line 35
  pci_online0_offset = phba->pci_va + 176UL;
#line 36
  pci_online1_offset = phba->pci_va + 180UL;
#line 37
  sreset = readl((void const volatile   *)pci_reset_offset);
#line 38
  sreset = sreset | 128U;
#line 39
  writel(sreset, (void volatile   *)pci_reset_offset);
#line 41
  i = 0U;
  }
#line 42
  goto ldv_56170;
  ldv_56169: ;
#line 43
  if (i > 64U) {
#line 44
    goto ldv_56168;
  } else {

  }
  {
#line 45
  msleep(100U);
#line 46
  sreset = readl((void const volatile   *)pci_reset_offset);
#line 47
  i = i + 1U;
  }
  ldv_56170: ;
#line 42
  if ((sreset & 128U) != 0U) {
#line 44
    goto ldv_56169;
  } else {

  }
  ldv_56168: ;
#line 50
  if ((sreset & 128U) != 0U) {
    {
#line 51
    printk("\vbe2iscsi Soft Reset  did not deassert\n");
    }
#line 53
    return (-5);
  } else {

  }
  {
#line 55
  pconline1 = 128U;
#line 56
  writel(pconline0, (void volatile   *)pci_online0_offset);
#line 57
  writel(pconline1, (void volatile   *)pci_online1_offset);
#line 59
  sreset = sreset | 128U;
#line 60
  writel(sreset, (void volatile   *)pci_reset_offset);
#line 62
  i = 0U;
  }
#line 63
  goto ldv_56173;
  ldv_56172: ;
#line 64
  if (i > 64U) {
#line 65
    goto ldv_56171;
  } else {

  }
  {
#line 66
  msleep(1U);
#line 67
  sreset = readl((void const volatile   *)pci_reset_offset);
#line 68
  i = i + 1U;
  }
  ldv_56173: ;
#line 63
  if ((sreset & 128U) != 0U) {
#line 65
    goto ldv_56172;
  } else {

  }
  ldv_56171: ;
#line 70
  if ((sreset & 128U) != 0U) {
    {
#line 71
    printk("\vbe2iscsi MPU Online Soft Reset did not deassert\n");
    }
#line 73
    return (-5);
  } else {

  }
#line 75
  return (0);
}
}
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_chk_reset_complete(struct beiscsi_hba *phba ) 
{ 
  unsigned int num_loop ;
  u8 *mpu_sem ;
  u32 status ;
  uint32_t log_value ;

  {
  {
#line 81
  mpu_sem = (u8 *)0U;
#line 84
  num_loop = 1000U;
#line 85
  mpu_sem = phba->csr_va + 172UL;
#line 86
  msleep(5000U);
  }
#line 88
  goto ldv_56182;
  ldv_56181: 
  {
#line 89
  status = readl((void const volatile   *)mpu_sem);
  }
#line 91
  if ((int )status < 0 || (status & 65535U) == 49152U) {
#line 92
    goto ldv_56180;
  } else {

  }
  {
#line 93
  msleep(60U);
#line 94
  num_loop = num_loop - 1U;
  }
  ldv_56182: ;
#line 88
  if (num_loop != 0U) {
#line 90
    goto ldv_56181;
  } else {

  }
  ldv_56180: ;
#line 97
  if ((int )status < 0 || num_loop == 0U) {
#line 98
    log_value = phba->attr_log_enable;
#line 98
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 98
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : Failed in be_chk_reset_completestatus = 0x%x\n",
                 100, status);
      }
    } else {

    }
#line 101
    return (-5);
  } else {

  }
#line 104
  return (0);
}
}
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
void be_mcc_notify(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *mccq ;
  u32 val ;

  {
  {
#line 109
  mccq = & phba->ctrl.mcc_obj.q;
#line 110
  val = 0U;
#line 112
  val = val | (u32 )mccq->id;
#line 113
  val = val | 65536U;
#line 114
  iowrite32(val, (void *)phba->db_va + 320U);
  }
#line 115
  return;
}
}
#line 117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
unsigned int alloc_mcc_tag(struct beiscsi_hba *phba ) 
{ 
  unsigned int tag ;

  {
#line 119
  tag = 0U;
#line 121
  if (phba->ctrl.mcc_tag_available != 0U) {
#line 122
    tag = phba->ctrl.mcc_tag[(int )phba->ctrl.mcc_alloc_index];
#line 123
    phba->ctrl.mcc_tag[(int )phba->ctrl.mcc_alloc_index] = 0U;
#line 124
    phba->ctrl.mcc_numtag[tag] = 0U;
  } else {

  }
#line 126
  if (tag != 0U) {
#line 127
    phba->ctrl.mcc_tag_available = phba->ctrl.mcc_tag_available - 1U;
#line 128
    if ((unsigned int )phba->ctrl.mcc_alloc_index == 15U) {
#line 129
      phba->ctrl.mcc_alloc_index = 0U;
    } else {
#line 131
      phba->ctrl.mcc_alloc_index = (unsigned short )((int )phba->ctrl.mcc_alloc_index + 1);
    }
  } else {

  }
#line 133
  return (tag);
}
}
#line 149 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_mccq_compl(struct beiscsi_hba *phba , uint32_t tag , struct be_mcc_wrb **wrb ,
                       struct be_dma_mem *mbx_cmd_mem ) 
{ 
  int rc ;
  uint32_t mcc_tag_response ;
  uint16_t status ;
  uint16_t addl_status ;
  uint16_t wrb_num ;
  struct be_mcc_wrb *temp_wrb ;
  struct be_cmd_req_hdr *mbx_hdr ;
  struct be_cmd_resp_hdr *mbx_resp_hdr ;
  struct be_queue_info *mccq ;
  bool tmp ;
  long __ret ;
  unsigned long tmp___0 ;
  wait_queue_t __wait ;
  long __ret___0 ;
  unsigned long tmp___1 ;
  long __int ;
  long tmp___2 ;
  bool __cond ;
  bool __cond___0 ;
  struct be_dma_mem *tag_mem ;
  uint32_t log_value ;
  void *tmp___3 ;
  void *tmp___4 ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;

  {
  {
#line 153
  rc = 0;
#line 155
  status = 0U;
#line 155
  addl_status = 0U;
#line 155
  wrb_num = 0U;
#line 159
  mccq = & phba->ctrl.mcc_obj.q;
#line 161
  tmp = beiscsi_error(phba);
  }
#line 161
  if ((int )tmp) {
    {
#line 162
    free_mcc_tag(& phba->ctrl, tag);
    }
#line 163
    return (-1);
  } else {

  }
  {
#line 167
  ldv_spin_lock_121(& phba->ctrl.mbox_lock);
#line 168
  phba->ctrl.ptag_state[tag].tag_state = 1U;
#line 169
  ldv_spin_unlock_122(& phba->ctrl.mbox_lock);
#line 172
  tmp___0 = msecs_to_jiffies(110000U);
#line 172
  __ret = (long )tmp___0;
#line 172
  __might_sleep("drivers/scsi/be2iscsi/be_cmds.c", 176, 0);
#line 172
  __cond___0 = phba->ctrl.mcc_numtag[tag] != 0U;
  }
#line 172
  if ((int )__cond___0 && __ret == 0L) {
#line 172
    __ret = 1L;
  } else {

  }
#line 172
  if (((int )__cond___0 || __ret == 0L) == 0) {
    {
#line 172
    tmp___1 = msecs_to_jiffies(110000U);
#line 172
    __ret___0 = (long )tmp___1;
#line 172
    INIT_LIST_HEAD(& __wait.task_list);
#line 172
    __wait.flags = 0U;
    }
    ldv_56218: 
    {
#line 172
    tmp___2 = prepare_to_wait_event((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + (unsigned long )tag,
                                    & __wait, 1);
#line 172
    __int = tmp___2;
#line 172
    __cond = phba->ctrl.mcc_numtag[tag] != 0U;
    }
#line 172
    if ((int )__cond && __ret___0 == 0L) {
#line 172
      __ret___0 = 1L;
    } else {

    }
#line 172
    if (((int )__cond || __ret___0 == 0L) != 0) {
#line 172
      goto ldv_56217;
    } else {

    }
#line 172
    if (__int != 0L) {
#line 172
      __ret___0 = __int;
#line 172
      goto ldv_56217;
    } else {

    }
    {
#line 172
    __ret___0 = schedule_timeout(__ret___0);
    }
#line 172
    goto ldv_56218;
    ldv_56217: 
    {
#line 172
    finish_wait((wait_queue_head_t *)(& phba->ctrl.mcc_wait) + (unsigned long )tag,
                & __wait);
    }
#line 172
    __ret = __ret___0;
  } else {

  }
#line 172
  rc = (int )__ret;
#line 178
  if (rc <= 0) {
    {
#line 181
    ldv_spin_lock_121(& phba->ctrl.mbox_lock);
#line 182
    phba->ctrl.ptag_state[tag].tag_state = 2U;
#line 183
    ldv_spin_unlock_122(& phba->ctrl.mbox_lock);
#line 186
    tag_mem = & phba->ctrl.ptag_state[tag].tag_mem_state;
    }
#line 187
    if ((unsigned long )mbx_cmd_mem != (unsigned long )((struct be_dma_mem *)0)) {
#line 188
      tag_mem->size = mbx_cmd_mem->size;
#line 189
      tag_mem->va = mbx_cmd_mem->va;
#line 190
      tag_mem->dma = mbx_cmd_mem->dma;
    } else {
#line 192
      tag_mem->size = 0U;
    }
#line 194
    log_value = phba->attr_log_enable;
#line 194
    if ((log_value & 41U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 194
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : MBX Cmd Completion timed out\n",
                 197);
      }
    } else {

    }
#line 198
    return (-16);
  } else {
    {
#line 200
    rc = 0;
#line 202
    ldv_spin_lock_121(& phba->ctrl.mbox_lock);
#line 203
    phba->ctrl.ptag_state[tag].tag_state = 0U;
#line 204
    ldv_spin_unlock_122(& phba->ctrl.mbox_lock);
    }
  }
#line 207
  mcc_tag_response = phba->ctrl.mcc_numtag[tag];
#line 208
  status = (unsigned int )((uint16_t )mcc_tag_response) & 255U;
#line 209
  addl_status = (uint16_t )((mcc_tag_response & 65280U) >> 8);
#line 212
  if ((unsigned long )mbx_cmd_mem != (unsigned long )((struct be_dma_mem *)0)) {
#line 213
    mbx_hdr = (struct be_cmd_req_hdr *)mbx_cmd_mem->va;
  } else {
    {
#line 215
    wrb_num = (uint16_t )((mcc_tag_response & 16711680U) >> 16);
#line 217
    tmp___3 = queue_get_wrb(mccq, (unsigned int )wrb_num);
#line 217
    temp_wrb = (struct be_mcc_wrb *)tmp___3;
#line 218
    tmp___4 = embedded_payload(temp_wrb);
#line 218
    mbx_hdr = (struct be_cmd_req_hdr *)tmp___4;
    }
#line 220
    if ((unsigned long )wrb != (unsigned long )((struct be_mcc_wrb **)0)) {
#line 221
      *wrb = temp_wrb;
    } else {

    }
  }
#line 224
  if ((unsigned int )((int )status | (int )addl_status) != 0U) {
#line 225
    log_value___0 = phba->attr_log_enable;
#line 225
    if ((log_value___0 & 41U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 225
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : MBX Cmd Failed for Subsys : %d Opcode : %d with Status : %d and Extd_Status : %d\n",
                 233, (int )mbx_hdr->subsystem, (int )mbx_hdr->opcode, (int )status,
                 (int )addl_status);
      }
    } else {

    }
#line 235
    if ((unsigned int )status == 4U) {
#line 236
      mbx_resp_hdr = (struct be_cmd_resp_hdr *)mbx_hdr;
#line 237
      log_value___1 = phba->attr_log_enable;
#line 237
      if ((log_value___1 & 41U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
        {
#line 237
        dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BC_%d : Insufficent Buffer Error Resp_Len : %d Actual_Resp_Len : %d\n",
                   243, mbx_resp_hdr->response_length, mbx_resp_hdr->actual_resp_len);
        }
      } else {

      }
#line 245
      rc = -11;
#line 246
      goto release_mcc_tag;
    } else {

    }
#line 248
    rc = -5;
  } else {

  }
  release_mcc_tag: 
  {
#line 253
  free_mcc_tag(& phba->ctrl, tag);
  }
#line 255
  return (rc);
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
void free_mcc_tag(struct be_ctrl_info *ctrl , unsigned int tag ) 
{ 


  {
  {
#line 260
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 261
  tag = tag & 255U;
#line 262
  ctrl->mcc_tag[(int )ctrl->mcc_free_index] = tag;
  }
#line 263
  if ((unsigned int )ctrl->mcc_free_index == 15U) {
#line 264
    ctrl->mcc_free_index = 0U;
  } else {
#line 266
    ctrl->mcc_free_index = (unsigned short )((int )ctrl->mcc_free_index + 1);
  }
  {
#line 267
  ctrl->mcc_tag_available = ctrl->mcc_tag_available + 1U;
#line 268
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 269
  return;
}
}
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
bool is_link_state_evt(u32 trailer ) 
{ 


  {
#line 273
  return (((trailer >> 8) & 255U) == 1U);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static bool is_iscsi_evt(u32 trailer ) 
{ 


  {
#line 280
  return (((trailer >> 8) & 255U) == 4U);
}
}
#line 285 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static int iscsi_evt_type(u32 trailer ) 
{ 


  {
#line 287
  return ((int )(trailer >> 16) & 15);
}
}
#line 291 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
__inline static bool be_mcc_compl_is_new(struct be_mcc_compl *compl ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
#line 293
  if (compl->flags != 0U) {
    {
#line 294
    compl->flags = compl->flags;
#line 295
    __ret_warn_on = (int )compl->flags >= 0;
#line 295
    tmp = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 295
    if (tmp != 0L) {
      {
#line 295
      warn_slowpath_null("drivers/scsi/be2iscsi/be_cmds.c", 295);
      }
    } else {

    }
    {
#line 295
    __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 296
    return (1);
  } else {
#line 298
    return (0);
  }
}
}
#line 301 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
__inline static void be_mcc_compl_use(struct be_mcc_compl *compl ) 
{ 


  {
#line 303
  compl->flags = 0U;
#line 304
  return;
}
}
#line 317 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static int be_mcc_compl_process(struct be_ctrl_info *ctrl , struct be_mcc_compl *compl ) 
{ 
  u16 compl_status ;
  u16 extd_status ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  struct be_cmd_req_hdr *hdr ;
  void *tmp___1 ;
  struct be_cmd_resp_hdr *resp_hdr ;
  uint32_t log_value ;

  {
  {
#line 321
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 321
  wrb = tmp;
#line 322
  tmp___0 = pci_get_drvdata(ctrl->pdev);
#line 322
  phba = (struct beiscsi_hba *)tmp___0;
#line 323
  tmp___1 = embedded_payload(wrb);
#line 323
  hdr = (struct be_cmd_req_hdr *)tmp___1;
#line 326
  swap_dws((void *)compl, 4);
#line 328
  compl_status = (u16 )compl->status;
  }
#line 330
  if ((unsigned int )compl_status != 0U) {
#line 331
    extd_status = (u16 )(compl->status >> 16);
#line 334
    log_value = phba->attr_log_enable;
#line 334
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 334
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : error in cmd completion: Subsystem : %d Opcode : %d status(compl/extd)=%d/%d\n",
                 340, (int )hdr->subsystem, (int )hdr->opcode, (int )compl_status,
                 (int )extd_status);
      }
    } else {

    }
#line 342
    if ((unsigned int )compl_status == 4U) {
#line 343
      resp_hdr = (struct be_cmd_resp_hdr *)hdr;
#line 344
      if (resp_hdr->response_length != 0U) {
#line 345
        return (0);
      } else {

      }
    } else {

    }
#line 347
    return (-16);
  } else {

  }
#line 349
  return (0);
}
}
#line 352 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_mcc_compl_process_isr(struct be_ctrl_info *ctrl , struct be_mcc_compl *compl ) 
{ 
  struct beiscsi_hba *phba ;
  void *tmp ;
  u16 compl_status ;
  u16 extd_status ;
  unsigned short tag ;
  struct be_dma_mem *tag_mem ;
  uint32_t log_value ;

  {
  {
#line 355
  tmp = pci_get_drvdata(ctrl->pdev);
#line 355
  phba = (struct beiscsi_hba *)tmp;
#line 359
  swap_dws((void *)compl, 4);
#line 361
  compl_status = (u16 )compl->status;
#line 367
  tag = (unsigned int )((unsigned short )compl->tag0) & 255U;
#line 368
  extd_status = (u16 )(compl->status >> 16);
#line 371
  ctrl->mcc_numtag[(int )tag] = 2147483648U;
#line 372
  ctrl->mcc_numtag[(int )tag] = ctrl->mcc_numtag[(int )tag] | (compl->tag0 & 16711680U);
#line 373
  ctrl->mcc_numtag[(int )tag] = ctrl->mcc_numtag[(int )tag] | ((unsigned int )((int )extd_status << 8) & 65535U);
#line 374
  ctrl->mcc_numtag[(int )tag] = ctrl->mcc_numtag[(int )tag] | ((unsigned int )compl_status & 255U);
  }
#line 376
  if ((unsigned int )ctrl->ptag_state[(int )tag].tag_state == 1U) {
    {
#line 377
    __wake_up((wait_queue_head_t *)(& ctrl->mcc_wait) + (unsigned long )tag, 1U, 1,
              (void *)0);
    }
  } else
#line 378
  if ((unsigned int )ctrl->ptag_state[(int )tag].tag_state == 2U) {
#line 380
    tag_mem = & ctrl->ptag_state[(int )tag].tag_mem_state;
#line 382
    log_value = phba->attr_log_enable;
#line 382
    if ((log_value & 35U) != 0U || (int )((signed char )*("\f" + 1)) <= 51) {
      {
#line 382
      dev_printk("\f", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : MBX Completion for timeout Command from FW\n",
                 386);
      }
    } else {

    }
#line 388
    if (tag_mem->size != 0U) {
      {
#line 389
      pci_free_consistent(ctrl->pdev, (size_t )tag_mem->size, tag_mem->va, tag_mem->dma);
      }
    } else {

    }
    {
#line 393
    ldv_spin_lock_121(& phba->ctrl.mbox_lock);
#line 394
    ctrl->ptag_state[(int )tag].tag_state = 0U;
#line 395
    ldv_spin_unlock_122(& phba->ctrl.mbox_lock);
#line 398
    free_mcc_tag(ctrl, (unsigned int )tag);
    }
  } else {

  }
#line 401
  return (0);
}
}
#line 404 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static struct be_mcc_compl *be_mcc_compl_get(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *mcc_cq ;
  struct be_mcc_compl *compl ;
  void *tmp ;
  bool tmp___0 ;

  {
  {
#line 406
  mcc_cq = & phba->ctrl.mcc_obj.cq;
#line 407
  tmp = queue_tail_node(mcc_cq);
#line 407
  compl = (struct be_mcc_compl *)tmp;
#line 409
  tmp___0 = be_mcc_compl_is_new(compl);
  }
#line 409
  if ((int )tmp___0) {
    {
#line 410
    queue_tail_inc(mcc_cq);
    }
#line 411
    return (compl);
  } else {

  }
#line 413
  return ((struct be_mcc_compl *)0);
}
}
#line 422 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
void be2iscsi_fail_session(struct iscsi_cls_session *cls_session ) 
{ 
  struct Scsi_Host *shost ;
  struct Scsi_Host *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  uint32_t iscsi_err_flag ;

  {
  {
#line 424
  tmp = dev_to_shost___1(cls_session->dev.parent);
#line 424
  shost = tmp;
#line 425
  tmp___0 = shost_priv(shost);
#line 425
  phba = (struct beiscsi_hba *)tmp___0 + 224U;
  }
#line 428
  if ((phba->state & 8U) != 0U) {
#line 429
    iscsi_err_flag = 1018U;
  } else {
#line 431
    iscsi_err_flag = 1011U;
  }
  {
#line 433
  iscsi_session_failure((struct iscsi_session *)cls_session->dd_data, 1011);
  }
#line 434
  return;
}
}
#line 436 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
void beiscsi_async_link_state_process(struct beiscsi_hba *phba , struct be_async_event_link_state *evt ) 
{ 
  uint32_t log_value ;
  uint32_t log_value___0 ;

  {
#line 439
  if ((unsigned int )evt->port_link_status == 0U || (((int )evt->port_link_status & 2) != 0 && (unsigned int )evt->port_fault != 0U)) {
#line 442
    phba->state = 2U;
#line 444
    log_value = phba->attr_log_enable;
#line 444
    if ((log_value & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 444
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : Link Down on Port %d\n",
                 447, (int )evt->physical_port);
      }
    } else {

    }
    {
#line 449
    iscsi_host_for_each_session(phba->shost, & be2iscsi_fail_session);
    }
  } else
#line 451
  if ((int )evt->port_link_status & 1 || (((int )evt->port_link_status & 2) != 0 && (unsigned int )evt->port_fault == 0U)) {
#line 454
    phba->state = 17U;
#line 456
    log_value___0 = phba->attr_log_enable;
#line 456
    if ((log_value___0 & 33U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 456
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : Link UP on Port %d\n",
                 459, (int )evt->physical_port);
      }
    } else {

    }
  } else {

  }
#line 459
  return;
}
}
#line 463 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_process_mcc(struct beiscsi_hba *phba ) 
{ 
  struct be_mcc_compl *compl ;
  int num ;
  int status ;
  struct be_ctrl_info *ctrl ;
  int tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  uint32_t log_value___1 ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 466
  num = 0;
#line 466
  status = 0;
#line 467
  ctrl = & phba->ctrl;
#line 469
  ldv_spin_lock_bh_131(& phba->ctrl.mcc_cq_lock);
  }
#line 470
  goto ldv_56301;
  ldv_56300: ;
#line 471
  if ((compl->flags & 1073741824U) != 0U) {
    {
#line 473
    tmp___1 = is_link_state_evt(compl->flags);
    }
#line 473
    if ((int )tmp___1) {
      {
#line 475
      beiscsi_async_link_state_process(phba, (struct be_async_event_link_state *)compl);
      }
    } else {
      {
#line 477
      tmp___0 = is_iscsi_evt(compl->flags);
      }
#line 477
      if ((int )tmp___0) {
        {
#line 478
        tmp = iscsi_evt_type(compl->flags);
        }
        {
#line 479
        if (tmp == 4) {
#line 479
          goto case_4;
        } else {

        }
#line 480
        if (tmp == 5) {
#line 480
          goto case_5;
        } else {

        }
#line 481
        if (tmp == 7) {
#line 481
          goto case_7;
        } else {

        }
#line 490
        goto switch_default;
        case_4: /* CIL Label */ ;
        case_5: /* CIL Label */ ;
        case_7: /* CIL Label */ 
#line 482
        phba->state = phba->state | 16U;
#line 483
        log_value = phba->attr_log_enable;
#line 483
        if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
          {
#line 483
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BC_%d : Async iscsi Event, flags handled = 0x%08x\n", 488, compl->flags);
          }
        } else {

        }
#line 489
        goto ldv_56296;
        switch_default: /* CIL Label */ 
#line 491
        log_value___0 = phba->attr_log_enable;
#line 491
        if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
          {
#line 491
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BC_%d : Unsupported Async Event, flags = 0x%08x\n", 496, compl->flags);
          }
        } else {

        }
        switch_break: /* CIL Label */ ;
        }
        ldv_56296: ;
      } else {
#line 499
        log_value___1 = phba->attr_log_enable;
#line 499
        if ((log_value___1 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
          {
#line 499
          dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                     "BC_%d : Unsupported Async Event, flags = 0x%08x\n", 503, compl->flags);
          }
        } else {

        }
      }
    }
  } else
#line 505
  if ((compl->flags & 268435456U) != 0U) {
    {
#line 506
    status = be_mcc_compl_process(ctrl, compl);
#line 507
    atomic_dec(& phba->ctrl.mcc_obj.q.used);
    }
  } else {

  }
  {
#line 509
  be_mcc_compl_use(compl);
#line 510
  num = num + 1;
  }
  ldv_56301: 
  {
#line 470
  compl = be_mcc_compl_get(phba);
  }
#line 470
  if ((unsigned long )compl != (unsigned long )((struct be_mcc_compl *)0)) {
#line 472
    goto ldv_56300;
  } else {

  }

#line 513
  if (num != 0) {
    {
#line 514
    hwi_ring_cq_db(phba, (unsigned int )phba->ctrl.mcc_obj.cq.id, (unsigned int )num,
                   1, 0);
    }
  } else {

  }
  {
#line 516
  ldv_spin_unlock_bh_132(& phba->ctrl.mcc_cq_lock);
  }
#line 517
  return (status);
}
}
#line 531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static int be_mcc_wait_compl(struct beiscsi_hba *phba ) 
{ 
  int i ;
  int status ;
  bool tmp ;
  int tmp___0 ;
  uint32_t log_value ;

  {
#line 534
  i = 0;
#line 534
  goto ldv_56310;
  ldv_56309: 
  {
#line 535
  tmp = beiscsi_error(phba);
  }
#line 535
  if ((int )tmp) {
#line 536
    return (-5);
  } else {

  }
  {
#line 538
  status = beiscsi_process_mcc(phba);
  }
#line 539
  if (status != 0) {
#line 540
    return (status);
  } else {

  }
  {
#line 542
  tmp___0 = atomic_read((atomic_t const   *)(& phba->ctrl.mcc_obj.q.used));
  }
#line 542
  if (tmp___0 == 0) {
#line 543
    goto ldv_56308;
  } else {

  }
  {
#line 544
  __const_udelay(429500UL);
#line 534
  i = i + 1;
  }
  ldv_56310: ;
#line 534
  if (i <= 119999) {
#line 536
    goto ldv_56309;
  } else {

  }
  ldv_56308: ;
#line 546
  if (i == 120000) {
#line 547
    log_value = phba->attr_log_enable;
#line 547
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 547
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : FW Timed Out\n",
                 549);
      }
    } else {

    }
    {
#line 550
    phba->fw_timeout = 1;
#line 551
    beiscsi_ue_detect(phba);
    }
#line 552
    return (-16);
  } else {

  }
#line 554
  return (0);
}
}
#line 567 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_mcc_notify_wait(struct beiscsi_hba *phba ) 
{ 
  int tmp ;

  {
  {
#line 569
  be_mcc_notify(phba);
#line 570
  tmp = be_mcc_wait_compl(phba);
  }
#line 570
  return (tmp);
}
}
#line 584 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static int be_mbox_db_ready_wait(struct be_ctrl_info *ctrl ) 
{ 
  void *db ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  unsigned long timeout ;
  bool read_flag ;
  int ret ;
  int i ;
  u32 ready ;
  wait_queue_head_t rdybit_check_q ;
  struct lock_class_key __key ;
  bool tmp___0 ;
  unsigned int tmp___1 ;
  unsigned long __ms ;
  unsigned long tmp___2 ;
  long __ret ;
  wait_queue_t __wait ;
  long __ret___0 ;
  long __int ;
  long tmp___3 ;
  bool __cond ;
  bool __cond___0 ;
  uint32_t log_value ;

  {
  {
#line 587
  db = (void *)ctrl->db + 352U;
#line 588
  tmp = pci_get_drvdata(ctrl->pdev);
#line 588
  phba = (struct beiscsi_hba *)tmp;
#line 590
  read_flag = 0;
#line 591
  ret = 0;
#line 593
  __init_waitqueue_head(& rdybit_check_q, "&rdybit_check_q", & __key);
#line 593
  rdybit_check_q = rdybit_check_q;
#line 595
  tmp___0 = beiscsi_error(phba);
  }
#line 595
  if ((int )tmp___0) {
#line 596
    return (-5);
  } else {

  }
#line 598
  timeout = (unsigned long )jiffies + 27500UL;
  ldv_56354: 
#line 601
  i = 0;
#line 601
  goto ldv_56334;
  ldv_56333: 
  {
#line 602
  tmp___1 = ioread32(db);
#line 602
  ready = tmp___1 & 1U;
  }
#line 603
  if (ready != 0U) {
#line 604
    read_flag = 1;
#line 605
    goto ldv_56328;
  } else {

  }
#line 607
  if (1) {
    {
#line 607
    __const_udelay(4295000UL);
    }
  } else {
#line 607
    __ms = 1UL;
#line 607
    goto ldv_56331;
    ldv_56330: 
    {
#line 607
    __const_udelay(4295000UL);
    }
    ldv_56331: 
#line 607
    tmp___2 = __ms;
#line 607
    __ms = __ms - 1UL;
#line 607
    if (tmp___2 != 0UL) {
#line 609
      goto ldv_56330;
    } else {

    }

  }
#line 601
  i = i + 1;
  ldv_56334: ;
#line 601
  if (i <= 3999) {
#line 603
    goto ldv_56333;
  } else {

  }
  ldv_56328: ;
#line 610
  if (! read_flag) {
    {
#line 611
    __ret = 1250L;
#line 611
    __might_sleep("drivers/scsi/be2iscsi/be_cmds.c", 613, 0);
#line 611
    __cond___0 = (bool )(! ((int )read_flag != 0));
    }
#line 611
    if ((int )__cond___0 && __ret == 0L) {
#line 611
      __ret = 1L;
    } else {

    }
#line 611
    if (((int )__cond___0 || __ret == 0L) == 0) {
      {
#line 611
      __ret___0 = 1250L;
#line 611
      INIT_LIST_HEAD(& __wait.task_list);
#line 611
      __wait.flags = 0U;
      }
      ldv_56345: 
      {
#line 611
      tmp___3 = prepare_to_wait_event(& rdybit_check_q, & __wait, 2);
#line 611
      __int = tmp___3;
#line 611
      __cond = (bool )(! ((int )read_flag != 0));
      }
#line 611
      if ((int )__cond && __ret___0 == 0L) {
#line 611
        __ret___0 = 1L;
      } else {

      }
#line 611
      if (((int )__cond || __ret___0 == 0L) != 0) {
#line 611
        goto ldv_56344;
      } else {

      }
      {
#line 611
      __ret___0 = schedule_timeout(__ret___0);
      }
#line 611
      goto ldv_56345;
      ldv_56344: 
      {
#line 611
      finish_wait(& rdybit_check_q, & __wait);
      }
#line 611
      __ret = __ret___0;
    } else {

    }
  } else {

  }
#line 615
  if ((long )((unsigned long )jiffies - timeout) < 0L && ! read_flag) {
#line 617
    goto ldv_56354;
  } else {

  }

#line 617
  if (! read_flag) {
#line 618
    log_value = phba->attr_log_enable;
#line 618
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 618
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : FW Timed Out\n",
                 620);
      }
    } else {

    }
    {
#line 621
    phba->fw_timeout = 1;
#line 622
    beiscsi_ue_detect(phba);
#line 623
    ret = -16;
    }
  } else {

  }
#line 626
  return (ret);
}
}
#line 640 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_mbox_notify(struct be_ctrl_info *ctrl ) 
{ 
  int status ;
  u32 val ;
  void *db ;
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_mailbox *mbox ;
  struct be_mcc_compl *compl ;
  struct beiscsi_hba *phba ;
  void *tmp ;
  uint32_t log_value ;
  uint32_t log_value___0 ;
  bool tmp___0 ;

  {
  {
#line 643
  val = 0U;
#line 644
  db = (void *)ctrl->db + 352U;
#line 645
  mbox_mem = & ctrl->mbox_mem;
#line 646
  mbox = (struct be_mcc_mailbox *)mbox_mem->va;
#line 647
  compl = & mbox->compl;
#line 648
  tmp = pci_get_drvdata(ctrl->pdev);
#line 648
  phba = (struct beiscsi_hba *)tmp;
#line 650
  status = be_mbox_db_ready_wait(ctrl);
  }
#line 651
  if (status != 0) {
#line 652
    return (status);
  } else {

  }
  {
#line 654
  val = val & 4294967294U;
#line 655
  val = val | 2U;
#line 656
  val = val | ((u32 )(mbox_mem->dma >> 32ULL) & 4294967292U);
#line 657
  iowrite32(val, db);
#line 659
  status = be_mbox_db_ready_wait(ctrl);
  }
#line 660
  if (status != 0) {
#line 661
    return (status);
  } else {

  }
  {
#line 663
  val = 0U;
#line 664
  val = val & 4294967294U;
#line 665
  val = val & 4294967293U;
#line 666
  val = val | ((unsigned int )(mbox_mem->dma >> 4) << 2);
#line 667
  iowrite32(val, db);
#line 669
  status = be_mbox_db_ready_wait(ctrl);
  }
#line 670
  if (status != 0) {
#line 671
    return (status);
  } else {

  }
  {
#line 673
  tmp___0 = be_mcc_compl_is_new(compl);
  }
#line 673
  if ((int )tmp___0) {
    {
#line 674
    status = be_mcc_compl_process(ctrl, & mbox->compl);
#line 675
    be_mcc_compl_use(compl);
    }
#line 676
    if (status != 0) {
#line 677
      log_value = phba->attr_log_enable;
#line 677
      if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
        {
#line 677
        dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev),
                   "BC_%d : After be_mcc_compl_process\n", 679);
        }
      } else {

      }
#line 681
      return (status);
    } else {

    }
  } else {
#line 684
    log_value___0 = phba->attr_log_enable;
#line 684
    if ((log_value___0 & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 684
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : Invalid Mailbox Completion\n",
                 686);
      }
    } else {

    }
#line 688
    return (-16);
  }
#line 690
  return (0);
}
}
#line 697 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static int be_mbox_notify_wait(struct beiscsi_hba *phba ) 
{ 
  int status ;
  u32 val ;
  void *db ;
  struct be_dma_mem *mbox_mem ;
  struct be_mcc_mailbox *mbox ;
  struct be_mcc_compl *compl ;
  struct be_ctrl_info *ctrl ;
  uint32_t log_value ;
  bool tmp ;

  {
  {
#line 700
  val = 0U;
#line 701
  db = (void *)phba->ctrl.db + 352U;
#line 702
  mbox_mem = & phba->ctrl.mbox_mem;
#line 703
  mbox = (struct be_mcc_mailbox *)mbox_mem->va;
#line 704
  compl = & mbox->compl;
#line 705
  ctrl = & phba->ctrl;
#line 707
  status = be_mbox_db_ready_wait(ctrl);
  }
#line 708
  if (status != 0) {
#line 709
    return (status);
  } else {

  }
  {
#line 711
  val = val | 2U;
#line 713
  val = val | ((u32 )(mbox_mem->dma >> 32ULL) & 4294967292U);
#line 714
  iowrite32(val, db);
#line 717
  status = be_mbox_db_ready_wait(ctrl);
  }
#line 718
  if (status != 0) {
#line 719
    return (status);
  } else {

  }
  {
#line 721
  val = 0U;
#line 723
  val = val | ((unsigned int )(mbox_mem->dma >> 4) << 2);
#line 724
  iowrite32(val, db);
#line 726
  status = be_mbox_db_ready_wait(ctrl);
  }
#line 727
  if (status != 0) {
#line 728
    return (status);
  } else {

  }
  {
#line 731
  tmp = be_mcc_compl_is_new(compl);
  }
#line 731
  if ((int )tmp) {
    {
#line 732
    status = be_mcc_compl_process(ctrl, & mbox->compl);
#line 733
    be_mcc_compl_use(compl);
    }
#line 734
    if (status != 0) {
#line 735
      return (status);
    } else {

    }
  } else {
#line 737
    log_value = phba->attr_log_enable;
#line 737
    if ((log_value & 34U) != 0U || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 737
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : invalid mailbox completion\n",
                 739);
      }
    } else {

    }
#line 741
    return (-16);
  }
#line 743
  return (0);
}
}
#line 746 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
void be_wrb_hdr_prepare(struct be_mcc_wrb *wrb , int payload_len , bool embedded ,
                        u8 sge_cnt ) 
{ 


  {
#line 749
  if ((int )embedded) {
#line 750
    wrb->embedded = wrb->embedded | 1U;
  } else {
#line 752
    wrb->embedded = wrb->embedded | ((u32 )((int )sge_cnt << 3) & 255U);
  }
  {
#line 754
  wrb->payload_length = (u32 )payload_len;
#line 755
  swap_dws((void *)wrb, 8);
  }
#line 756
  return;
}
}
#line 758 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
void be_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr , u8 subsystem , u8 opcode ,
                        int cmd_len ) 
{ 


  {
#line 761
  req_hdr->opcode = opcode;
#line 762
  req_hdr->subsystem = subsystem;
#line 763
  req_hdr->request_length = (unsigned int )cmd_len - 16U;
#line 764
  req_hdr->timeout = 100U;
#line 765
  return;
}
}
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static void be_cmd_page_addrs_prepare(struct phys_addr *pages , u32 max_pages , struct be_dma_mem *mem ) 
{ 
  int i ;
  int buf_pages ;
  u64 dma ;
  unsigned int _min1 ;
  u32 _min2 ;

  {
#line 771
  dma = mem->dma;
#line 773
  _min1 = (unsigned int )(((((unsigned long )mem->va & 4095UL) + (unsigned long )mem->size) + 4095UL) >> 12);
#line 773
  _min2 = max_pages;
#line 773
  buf_pages = (int )(_min1 < _min2 ? _min1 : _min2);
#line 774
  i = 0;
#line 774
  goto ldv_56404;
  ldv_56403: 
#line 775
  (pages + (unsigned long )i)->lo = (unsigned int )dma;
#line 776
  (pages + (unsigned long )i)->hi = (unsigned int )(dma >> 32ULL);
#line 777
  dma = dma + 4096ULL;
#line 774
  i = i + 1;
  ldv_56404: ;
#line 774
  if (i < buf_pages) {
#line 776
    goto ldv_56403;
  } else {

  }

#line 781
  return;
}
}
#line 781 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static u32 eq_delay_to_mult(u32 usec_delay ) 
{ 
  u32 round ;
  u32 multiplier ;
  u32 interrupt_rate ;
  u32 _min1 ;
  unsigned int _min2 ;

  {
#line 784
  round = 10U;
#line 787
  if (usec_delay == 0U) {
#line 788
    multiplier = 0U;
  } else {
#line 790
    interrupt_rate = 1000000U / usec_delay;
#line 791
    if (interrupt_rate == 0U) {
#line 792
      multiplier = 1023U;
    } else {
#line 794
      multiplier = - interrupt_rate * 10U + 6510420U;
#line 795
      multiplier = multiplier / interrupt_rate;
#line 796
      multiplier = (multiplier + 5U) / 10U;
#line 797
      _min1 = multiplier;
#line 797
      _min2 = 1023U;
#line 797
      multiplier = _min1 < _min2 ? _min1 : _min2;
    }
  }
#line 800
  return (multiplier);
}
}
#line 803 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
struct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem ) 
{ 


  {
#line 805
  return (& ((struct be_mcc_mailbox *)mbox_mem->va)->wrb);
}
}
#line 808 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
struct be_mcc_wrb *wrb_from_mccq(struct beiscsi_hba *phba ) 
{ 
  struct be_queue_info *mccq ;
  struct be_mcc_wrb *wrb ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 810
  mccq = & phba->ctrl.mcc_obj.q;
#line 813
  tmp = atomic_read((atomic_t const   *)(& mccq->used));
#line 813
  __ret_warn_on = tmp >= (int )mccq->len;
#line 813
  tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 813
  if (tmp___0 != 0L) {
    {
#line 813
    warn_slowpath_null("drivers/scsi/be2iscsi/be_cmds.c", 813);
    }
  } else {

  }
  {
#line 813
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 814
  tmp___1 = queue_head_node(mccq);
#line 814
  wrb = (struct be_mcc_wrb *)tmp___1;
#line 815
  __memset((void *)wrb, 0, 256UL);
#line 816
  wrb->tag0 = (u32 )(((int )mccq->head & 255) << 16);
#line 817
  queue_head_inc(mccq);
#line 818
  atomic_inc(& mccq->used);
  }
#line 819
  return (wrb);
}
}
#line 823 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl , struct be_queue_info *eq , int eq_delay ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_cmd_req_eq_create *req ;
  void *tmp___0 ;
  struct be_cmd_resp_eq_create *resp ;
  void *tmp___1 ;
  struct be_dma_mem *q_mem ;
  int status ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;

  {
  {
#line 826
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 826
  wrb = tmp;
#line 827
  tmp___0 = embedded_payload(wrb);
#line 827
  req = (struct be_cmd_req_eq_create *)tmp___0;
#line 828
  tmp___1 = embedded_payload(wrb);
#line 828
  resp = (struct be_cmd_resp_eq_create *)tmp___1;
#line 829
  q_mem = & eq->dma_mem;
#line 832
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 833
  __memset((void *)wrb, 0, 256UL);
#line 835
  be_wrb_hdr_prepare(wrb, 100, 1, 0);
#line 837
  be_cmd_hdr_prepare(& req->hdr, 1, 13, 100);
#line 840
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 842
  tmp___2 = amap_mask(8U);
#line 842
  amap_set((void *)(& req->context), 2U, tmp___2, 4U, (ctrl->pdev)->devfn & 7U);
#line 844
  tmp___3 = amap_mask(1U);
#line 844
  amap_set((void *)(& req->context), 0U, tmp___3, 29U, 1U);
#line 845
  tmp___4 = amap_mask(1U);
#line 845
  amap_set((void *)(& req->context), 0U, tmp___4, 31U, 0U);
#line 846
  tmp___5 = __ilog2_u32((unsigned int )eq->len / 256U);
#line 846
  tmp___6 = amap_mask(3U);
#line 846
  amap_set((void *)(& req->context), 1U, tmp___6, 26U, (u32 )tmp___5);
#line 848
  tmp___7 = eq_delay_to_mult((u32 )eq_delay);
#line 848
  tmp___8 = amap_mask(10U);
#line 848
  amap_set((void *)(& req->context), 2U, tmp___8, 13U, tmp___7);
#line 850
  swap_dws((void *)(& req->context), 16);
#line 852
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 854
  status = be_mbox_notify(ctrl);
  }
#line 855
  if (status == 0) {
#line 856
    eq->id = resp->eq_id;
#line 857
    eq->created = 1;
  } else {

  }
  {
#line 859
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 860
  return (status);
}
}
#line 873 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_fw_initialize(struct be_ctrl_info *ctrl ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  int status ;
  u8 *endian_check ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  uint32_t log_value ;

  {
  {
#line 875
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 875
  wrb = tmp;
#line 876
  tmp___0 = pci_get_drvdata(ctrl->pdev);
#line 876
  phba = (struct beiscsi_hba *)tmp___0;
#line 880
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 881
  __memset((void *)wrb, 0, 256UL);
#line 883
  endian_check = (u8 *)wrb;
#line 884
  tmp___1 = endian_check;
#line 884
  endian_check = endian_check + 1;
#line 884
  *tmp___1 = 255U;
#line 885
  tmp___2 = endian_check;
#line 885
  endian_check = endian_check + 1;
#line 885
  *tmp___2 = 18U;
#line 886
  tmp___3 = endian_check;
#line 886
  endian_check = endian_check + 1;
#line 886
  *tmp___3 = 52U;
#line 887
  tmp___4 = endian_check;
#line 887
  endian_check = endian_check + 1;
#line 887
  *tmp___4 = 255U;
#line 888
  tmp___5 = endian_check;
#line 888
  endian_check = endian_check + 1;
#line 888
  *tmp___5 = 255U;
#line 889
  tmp___6 = endian_check;
#line 889
  endian_check = endian_check + 1;
#line 889
  *tmp___6 = 86U;
#line 890
  tmp___7 = endian_check;
#line 890
  endian_check = endian_check + 1;
#line 890
  *tmp___7 = 120U;
#line 891
  tmp___8 = endian_check;
#line 891
  endian_check = endian_check + 1;
#line 891
  *tmp___8 = 255U;
#line 892
  swap_dws((void *)wrb, 256);
#line 894
  status = be_mbox_notify(ctrl);
  }
#line 895
  if (status != 0) {
#line 896
    log_value = phba->attr_log_enable;
#line 896
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 896
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : be_cmd_fw_initialize Failed\n",
                 897);
      }
    } else {

    }
  } else {

  }
  {
#line 899
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 900
  return (status);
}
}
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_fw_uninit(struct be_ctrl_info *ctrl ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct beiscsi_hba *phba ;
  void *tmp___0 ;
  int status ;
  u8 *endian_check ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  uint32_t log_value ;

  {
  {
#line 915
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 915
  wrb = tmp;
#line 916
  tmp___0 = pci_get_drvdata(ctrl->pdev);
#line 916
  phba = (struct beiscsi_hba *)tmp___0;
#line 920
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 921
  __memset((void *)wrb, 0, 256UL);
#line 923
  endian_check = (u8 *)wrb;
#line 924
  tmp___1 = endian_check;
#line 924
  endian_check = endian_check + 1;
#line 924
  *tmp___1 = 255U;
#line 925
  tmp___2 = endian_check;
#line 925
  endian_check = endian_check + 1;
#line 925
  *tmp___2 = 170U;
#line 926
  tmp___3 = endian_check;
#line 926
  endian_check = endian_check + 1;
#line 926
  *tmp___3 = 187U;
#line 927
  tmp___4 = endian_check;
#line 927
  endian_check = endian_check + 1;
#line 927
  *tmp___4 = 255U;
#line 928
  tmp___5 = endian_check;
#line 928
  endian_check = endian_check + 1;
#line 928
  *tmp___5 = 255U;
#line 929
  tmp___6 = endian_check;
#line 929
  endian_check = endian_check + 1;
#line 929
  *tmp___6 = 204U;
#line 930
  tmp___7 = endian_check;
#line 930
  endian_check = endian_check + 1;
#line 930
  *tmp___7 = 221U;
#line 931
  *endian_check = 255U;
#line 933
  swap_dws((void *)wrb, 256);
#line 935
  status = be_mbox_notify(ctrl);
  }
#line 936
  if (status != 0) {
#line 937
    log_value = phba->attr_log_enable;
#line 937
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 937
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : be_cmd_fw_uninit Failed\n",
                 938);
      }
    } else {

    }
  } else {

  }
  {
#line 940
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 941
  return (status);
}
}
#line 944 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl , struct be_queue_info *cq , struct be_queue_info *eq ,
                          bool sol_evts , bool no_delay , int coalesce_wm ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_cmd_req_cq_create *req ;
  void *tmp___0 ;
  struct be_cmd_resp_cq_create *resp ;
  void *tmp___1 ;
  struct beiscsi_hba *phba ;
  void *tmp___2 ;
  struct be_dma_mem *q_mem ;
  void *ctxt ;
  int status ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  int tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  int tmp___15 ;
  u32 tmp___16 ;
  u32 tmp___17 ;
  u32 tmp___18 ;
  u32 tmp___19 ;
  u32 tmp___20 ;
  uint32_t log_value ;

  {
  {
#line 948
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 948
  wrb = tmp;
#line 949
  tmp___0 = embedded_payload(wrb);
#line 949
  req = (struct be_cmd_req_cq_create *)tmp___0;
#line 950
  tmp___1 = embedded_payload(wrb);
#line 950
  resp = (struct be_cmd_resp_cq_create *)tmp___1;
#line 951
  tmp___2 = pci_get_drvdata(ctrl->pdev);
#line 951
  phba = (struct beiscsi_hba *)tmp___2;
#line 952
  q_mem = & cq->dma_mem;
#line 953
  ctxt = (void *)(& req->context);
#line 956
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 957
  __memset((void *)wrb, 0, 256UL);
#line 959
  be_wrb_hdr_prepare(wrb, 68, 1, 0);
#line 961
  be_cmd_hdr_prepare(& req->hdr, 1, 12, 68);
#line 964
  req->num_pages = (unsigned short )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
  }
#line 965
  if (phba->generation - 2U <= 1U) {
    {
#line 966
    tmp___3 = amap_mask(2U);
#line 966
    amap_set(ctxt, 0U, tmp___3, 12U, (u32 )coalesce_wm);
#line 968
    tmp___4 = amap_mask(1U);
#line 968
    amap_set(ctxt, 0U, tmp___4, 14U, (u32 )no_delay);
#line 969
    tmp___5 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 969
    tmp___6 = amap_mask(2U);
#line 969
    amap_set(ctxt, 0U, tmp___6, 27U, (u32 )tmp___5);
#line 971
    tmp___7 = amap_mask(1U);
#line 971
    amap_set(ctxt, 0U, tmp___7, 29U, 1U);
#line 972
    tmp___8 = amap_mask(1U);
#line 972
    amap_set(ctxt, 0U, tmp___8, 30U, (u32 )sol_evts);
#line 973
    tmp___9 = amap_mask(1U);
#line 973
    amap_set(ctxt, 0U, tmp___9, 31U, 1U);
#line 974
    tmp___10 = amap_mask(8U);
#line 974
    amap_set(ctxt, 1U, tmp___10, 22U, (u32 )eq->id);
#line 975
    tmp___11 = amap_mask(1U);
#line 975
    amap_set(ctxt, 1U, tmp___11, 31U, 1U);
#line 976
    tmp___12 = amap_mask(8U);
#line 976
    amap_set(ctxt, 2U, tmp___12, 4U, (ctrl->pdev)->devfn & 7U);
    }
  } else {
    {
#line 979
    req->hdr.version = 2U;
#line 980
    req->page_size = 1U;
#line 981
    tmp___13 = amap_mask(2U);
#line 981
    amap_set(ctxt, 0U, tmp___13, 12U, (u32 )coalesce_wm);
#line 983
    tmp___14 = amap_mask(1U);
#line 983
    amap_set(ctxt, 0U, tmp___14, 14U, (u32 )no_delay);
#line 985
    tmp___15 = __ilog2_u32((unsigned int )cq->len / 256U);
#line 985
    tmp___16 = amap_mask(2U);
#line 985
    amap_set(ctxt, 0U, tmp___16, 27U, (u32 )tmp___15);
#line 987
    tmp___17 = amap_mask(1U);
#line 987
    amap_set(ctxt, 0U, tmp___17, 29U, 1U);
#line 988
    tmp___18 = amap_mask(1U);
#line 988
    amap_set(ctxt, 0U, tmp___18, 31U, 1U);
#line 989
    tmp___19 = amap_mask(16U);
#line 989
    amap_set(ctxt, 1U, tmp___19, 0U, (u32 )eq->id);
#line 990
    tmp___20 = amap_mask(1U);
#line 990
    amap_set(ctxt, 1U, tmp___20, 31U, 1U);
    }
  }
  {
#line 993
  swap_dws(ctxt, 16);
#line 995
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 4U, q_mem);
#line 997
  status = be_mbox_notify(ctrl);
  }
#line 998
  if (status == 0) {
#line 999
    cq->id = resp->cq_id;
#line 1000
    cq->created = 1;
  } else {
#line 1002
    log_value = phba->attr_log_enable;
#line 1002
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1002
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : In be_cmd_cq_create, status=ox%08x\n",
                 1004, status);
      }
    } else {

    }
  }
  {
#line 1006
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1008
  return (status);
}
}
#line 1011 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
static u32 be_encoded_q_len(int q_len ) 
{ 
  u32 len_encoded ;
  int tmp ;

  {
  {
#line 1013
  tmp = fls(q_len);
#line 1013
  len_encoded = (u32 )tmp;
  }
#line 1014
  if (len_encoded == 16U) {
#line 1015
    len_encoded = 0U;
  } else {

  }
#line 1016
  return (len_encoded);
}
}
#line 1019 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_mccq_create(struct beiscsi_hba *phba , struct be_queue_info *mccq ,
                            struct be_queue_info *cq ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_cmd_req_mcc_create *req ;
  struct be_dma_mem *q_mem ;
  struct be_ctrl_info *ctrl ;
  void *ctxt ;
  int status ;
  void *tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  struct be_cmd_resp_mcc_create *resp ;
  void *tmp___5 ;

  {
  {
#line 1025
  q_mem = & mccq->dma_mem;
#line 1030
  ldv_spin_lock_121(& phba->ctrl.mbox_lock);
#line 1031
  ctrl = & phba->ctrl;
#line 1032
  wrb = wrb_from_mbox(& ctrl->mbox_mem);
#line 1033
  __memset((void *)wrb, 0, 256UL);
#line 1034
  tmp = embedded_payload(wrb);
#line 1034
  req = (struct be_cmd_req_mcc_create *)tmp;
#line 1035
  ctxt = (void *)(& req->context);
#line 1037
  be_wrb_hdr_prepare(wrb, 100, 1, 0);
#line 1039
  be_cmd_hdr_prepare(& req->hdr, 1, 21, 100);
#line 1042
  req->num_pages = (u16 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1044
  tmp___0 = amap_mask(8U);
#line 1044
  amap_set(ctxt, 1U, tmp___0, 14U, (phba->pcidev)->devfn & 7U);
#line 1046
  tmp___1 = amap_mask(1U);
#line 1046
  amap_set(ctxt, 1U, tmp___1, 31U, 1U);
#line 1047
  tmp___2 = be_encoded_q_len((int )mccq->len);
#line 1047
  tmp___3 = amap_mask(4U);
#line 1047
  amap_set(ctxt, 0U, tmp___3, 16U, tmp___2);
#line 1049
  tmp___4 = amap_mask(10U);
#line 1049
  amap_set(ctxt, 0U, tmp___4, 22U, (u32 )cq->id);
#line 1051
  swap_dws(ctxt, 16);
#line 1053
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1055
  status = be_mbox_notify_wait(phba);
  }
#line 1056
  if (status == 0) {
    {
#line 1057
    tmp___5 = embedded_payload(wrb);
#line 1057
    resp = (struct be_cmd_resp_mcc_create *)tmp___5;
#line 1058
    mccq->id = resp->id;
#line 1059
    mccq->created = 1;
    }
  } else {

  }
  {
#line 1061
  ldv_spin_unlock_122(& phba->ctrl.mbox_lock);
  }
#line 1063
  return (status);
}
}
#line 1066 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_q_destroy(struct be_ctrl_info *ctrl , struct be_queue_info *q , int queue_type ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_cmd_req_q_destroy *req ;
  void *tmp___0 ;
  struct beiscsi_hba *phba ;
  void *tmp___1 ;
  u8 subsys ;
  u8 opcode ;
  int status ;
  uint32_t log_value ;

  {
  {
#line 1069
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1069
  wrb = tmp;
#line 1070
  tmp___0 = embedded_payload(wrb);
#line 1070
  req = (struct be_cmd_req_q_destroy *)tmp___0;
#line 1071
  tmp___1 = pci_get_drvdata(ctrl->pdev);
#line 1071
  phba = (struct beiscsi_hba *)tmp___1;
#line 1072
  subsys = 0U;
#line 1072
  opcode = 0U;
#line 1075
  log_value = phba->attr_log_enable;
  }
#line 1075
  if ((int )log_value & 1 || (int )((signed char )*("\016" + 1)) <= 51) {
    {
#line 1075
    dev_printk("\016", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : In beiscsi_cmd_q_destroy queue_type : %d\n",
               1077, queue_type);
    }
  } else {

  }
  {
#line 1079
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1080
  __memset((void *)wrb, 0, 256UL);
#line 1081
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
  }
  {
#line 1084
  if (queue_type == 1) {
#line 1084
    goto case_1;
  } else {

  }
#line 1088
  if (queue_type == 2) {
#line 1088
    goto case_2;
  } else {

  }
#line 1092
  if (queue_type == 3) {
#line 1092
    goto case_3;
  } else {

  }
#line 1096
  if (queue_type == 4) {
#line 1096
    goto case_4;
  } else {

  }
#line 1100
  if (queue_type == 5) {
#line 1100
    goto case_5;
  } else {

  }
#line 1104
  if (queue_type == 6) {
#line 1104
    goto case_6;
  } else {

  }
#line 1108
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1085
  subsys = 1U;
#line 1086
  opcode = 55U;
#line 1087
  goto ldv_56502;
  case_2: /* CIL Label */ 
#line 1089
  subsys = 1U;
#line 1090
  opcode = 54U;
#line 1091
  goto ldv_56502;
  case_3: /* CIL Label */ 
#line 1093
  subsys = 1U;
#line 1094
  opcode = 53U;
#line 1095
  goto ldv_56502;
  case_4: /* CIL Label */ 
#line 1097
  subsys = 2U;
#line 1098
  opcode = 67U;
#line 1099
  goto ldv_56502;
  case_5: /* CIL Label */ 
#line 1101
  subsys = 2U;
#line 1102
  opcode = 65U;
#line 1103
  goto ldv_56502;
  case_6: /* CIL Label */ 
#line 1105
  subsys = 2U;
#line 1106
  opcode = 3U;
#line 1107
  goto ldv_56502;
  switch_default: /* CIL Label */ 
  {
#line 1109
  ldv_spin_unlock_122(& ctrl->mbox_lock);
#line 1110
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/scsi/be2iscsi/be_cmds.c"),
                       "i" (1110), "i" (12UL));
#line 1110
  __builtin_unreachable();
  }
#line 1111
  return (-6);
  switch_break: /* CIL Label */ ;
  }
  ldv_56502: 
  {
#line 1113
  be_cmd_hdr_prepare(& req->hdr, (int )subsys, (int )opcode, 20);
  }
#line 1114
  if (queue_type != 6) {
#line 1115
    req->id = q->id;
  } else {

  }
  {
#line 1117
  status = be_mbox_notify(ctrl);
#line 1119
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1120
  return (status);
}
}
#line 1141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_create_default_pdu_queue(struct be_ctrl_info *ctrl , struct be_queue_info *cq ,
                                    struct be_queue_info *dq , int length , int entry_size ,
                                    uint8_t is_header , uint8_t ulp_num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_defq_create_req *req ;
  void *tmp___0 ;
  struct be_dma_mem *q_mem ;
  struct beiscsi_hba *phba ;
  void *tmp___1 ;
  void *ctxt ;
  int status ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  u32 tmp___8 ;
  u32 tmp___9 ;
  u32 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  struct be_ring *defq_ring ;
  struct be_defq_create_resp *resp ;
  void *tmp___15 ;

  {
  {
#line 1147
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1147
  wrb = tmp;
#line 1148
  tmp___0 = embedded_payload(wrb);
#line 1148
  req = (struct be_defq_create_req *)tmp___0;
#line 1149
  q_mem = & dq->dma_mem;
#line 1150
  tmp___1 = pci_get_drvdata(ctrl->pdev);
#line 1150
  phba = (struct beiscsi_hba *)tmp___1;
#line 1151
  ctxt = (void *)(& req->context);
#line 1154
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1155
  __memset((void *)wrb, 0, 256UL);
#line 1157
  be_wrb_hdr_prepare(wrb, 100, 1, 0);
#line 1159
  be_cmd_hdr_prepare(& req->hdr, 2, 64, 100);
#line 1162
  req->num_pages = (u16 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
  }
#line 1163
  if ((unsigned int )phba->fw_config.dual_ulp_aware != 0U) {
#line 1164
    req->ulp_num = ulp_num;
#line 1165
    req->dua_feature = (u8 )((unsigned int )req->dua_feature | 1U);
#line 1166
    req->dua_feature = (u8 )((unsigned int )req->dua_feature | 2U);
  } else {

  }
#line 1169
  if (phba->generation - 2U <= 1U) {
    {
#line 1170
    tmp___2 = amap_mask(9U);
#line 1170
    amap_set(ctxt, 1U, tmp___2, 22U, 0U);
#line 1172
    tmp___3 = amap_mask(1U);
#line 1172
    amap_set(ctxt, 1U, tmp___3, 31U, 1U);
#line 1174
    tmp___4 = amap_mask(8U);
#line 1174
    amap_set(ctxt, 1U, tmp___4, 14U, (ctrl->pdev)->devfn & 7U);
#line 1176
    tmp___5 = be_encoded_q_len((int )((unsigned long )length / 8UL));
#line 1176
    tmp___6 = amap_mask(4U);
#line 1176
    amap_set(ctxt, 0U, tmp___6, 16U, tmp___5);
#line 1180
    tmp___7 = amap_mask(16U);
#line 1180
    amap_set(ctxt, 2U, tmp___7, 0U, (u32 )entry_size);
#line 1182
    tmp___8 = amap_mask(10U);
#line 1182
    amap_set(ctxt, 2U, tmp___8, 16U, (u32 )cq->id);
    }
  } else {
    {
#line 1185
    tmp___9 = amap_mask(9U);
#line 1185
    amap_set(ctxt, 1U, tmp___9, 22U, 0U);
#line 1187
    tmp___10 = amap_mask(1U);
#line 1187
    amap_set(ctxt, 1U, tmp___10, 31U, 1U);
#line 1189
    tmp___11 = be_encoded_q_len((int )((unsigned long )length / 8UL));
#line 1189
    tmp___12 = amap_mask(4U);
#line 1189
    amap_set(ctxt, 0U, tmp___12, 16U, tmp___11);
#line 1193
    tmp___13 = amap_mask(16U);
#line 1193
    amap_set(ctxt, 2U, tmp___13, 0U, (u32 )entry_size);
#line 1195
    tmp___14 = amap_mask(16U);
#line 1195
    amap_set(ctxt, 2U, tmp___14, 16U, (u32 )cq->id);
    }
  }
  {
#line 1199
  swap_dws(ctxt, 16);
#line 1201
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1203
  status = be_mbox_notify(ctrl);
  }
#line 1204
  if (status == 0) {
    {
#line 1206
    tmp___15 = embedded_payload(wrb);
#line 1206
    resp = (struct be_defq_create_resp *)tmp___15;
#line 1208
    dq->id = resp->id;
#line 1209
    dq->created = 1;
    }
#line 1210
    if ((unsigned int )is_header != 0U) {
#line 1211
      defq_ring = (struct be_ring *)(& (phba->phwi_ctrlr)->default_pdu_hdr) + (unsigned long )ulp_num;
    } else {
#line 1213
      defq_ring = (struct be_ring *)(& (phba->phwi_ctrlr)->default_pdu_data) + (unsigned long )ulp_num;
    }
#line 1216
    defq_ring->id = (u32 )dq->id;
#line 1218
    if ((unsigned int )phba->fw_config.dual_ulp_aware == 0U) {
#line 1219
      defq_ring->ulp_num = 0U;
#line 1220
      defq_ring->doorbell_offset = 160U;
    } else {
#line 1222
      defq_ring->ulp_num = resp->ulp_num;
#line 1223
      defq_ring->doorbell_offset = resp->doorbell_offset;
    }
  } else {

  }
  {
#line 1226
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1228
  return (status);
}
}
#line 1242 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_wrbq_create(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem , struct be_queue_info *wrbq ,
                       struct hwi_wrb_context *pwrb_context , uint8_t ulp_num ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_wrbq_create_req *req ;
  void *tmp___0 ;
  struct be_wrbq_create_resp *resp ;
  void *tmp___1 ;
  struct beiscsi_hba *phba ;
  void *tmp___2 ;
  int status ;

  {
  {
#line 1248
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1248
  wrb = tmp;
#line 1249
  tmp___0 = embedded_payload(wrb);
#line 1249
  req = (struct be_wrbq_create_req *)tmp___0;
#line 1250
  tmp___1 = embedded_payload(wrb);
#line 1250
  resp = (struct be_wrbq_create_resp *)tmp___1;
#line 1251
  tmp___2 = pci_get_drvdata(ctrl->pdev);
#line 1251
  phba = (struct beiscsi_hba *)tmp___2;
#line 1254
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1255
  __memset((void *)wrb, 0, 256UL);
#line 1257
  be_wrb_hdr_prepare(wrb, 84, 1, 0);
#line 1259
  be_cmd_hdr_prepare(& req->hdr, 2, 66, 84);
#line 1261
  req->num_pages = (u16 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
  }
#line 1263
  if ((unsigned int )phba->fw_config.dual_ulp_aware != 0U) {
#line 1264
    req->ulp_num = ulp_num;
#line 1265
    req->dua_feature = (u8 )((unsigned int )req->dua_feature | 1U);
#line 1266
    req->dua_feature = (u8 )((unsigned int )req->dua_feature | 2U);
  } else {

  }
  {
#line 1269
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 8U, q_mem);
#line 1271
  status = be_mbox_notify(ctrl);
  }
#line 1272
  if (status == 0) {
#line 1273
    wrbq->id = resp->cid;
#line 1274
    wrbq->created = 1;
#line 1276
    pwrb_context->cid = wrbq->id;
#line 1277
    if ((unsigned int )phba->fw_config.dual_ulp_aware == 0U) {
#line 1278
      pwrb_context->doorbell_offset = 64U;
#line 1279
      pwrb_context->ulp_num = 0U;
    } else {
#line 1281
      pwrb_context->ulp_num = resp->ulp_num;
#line 1282
      pwrb_context->doorbell_offset = resp->doorbell_offset;
    }
  } else {

  }
  {
#line 1285
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1286
  return (status);
}
}
#line 1289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_iscsi_post_template_hdr(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_post_template_pages_req *req ;
  void *tmp___0 ;
  int status ;

  {
  {
#line 1292
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1292
  wrb = tmp;
#line 1293
  tmp___0 = embedded_payload(wrb);
#line 1293
  req = (struct be_post_template_pages_req *)tmp___0;
#line 1296
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1298
  __memset((void *)wrb, 0, 256UL);
#line 1299
  be_wrb_hdr_prepare(wrb, 172, 1, 0);
#line 1300
  be_cmd_hdr_prepare(& req->hdr, 1, 24, 172);
#line 1304
  req->num_pages = (u16 )(((((unsigned long )q_mem->va & 4095UL) + (unsigned long )q_mem->size) + 4095UL) >> 12);
#line 1305
  req->type = 1U;
#line 1306
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), 16U, q_mem);
#line 1308
  status = be_mbox_notify(ctrl);
#line 1309
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1310
  return (status);
}
}
#line 1313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_iscsi_remove_template_hdr(struct be_ctrl_info *ctrl ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_remove_template_pages_req *req ;
  void *tmp___0 ;
  int status ;

  {
  {
#line 1315
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1315
  wrb = tmp;
#line 1316
  tmp___0 = embedded_payload(wrb);
#line 1316
  req = (struct be_remove_template_pages_req *)tmp___0;
#line 1319
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1321
  __memset((void *)wrb, 0, 256UL);
#line 1322
  be_wrb_hdr_prepare(wrb, 20, 1, 0);
#line 1323
  be_cmd_hdr_prepare(& req->hdr, 1, 25, 20);
#line 1327
  req->type = 1U;
#line 1329
  status = be_mbox_notify(ctrl);
#line 1330
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1331
  return (status);
}
}
#line 1334 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl , struct be_dma_mem *q_mem ,
                                u32 page_offset___0 , u32 num_pages ) 
{ 
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_post_sgl_pages_req *req ;
  void *tmp___0 ;
  struct beiscsi_hba *phba ;
  void *tmp___1 ;
  int status ;
  unsigned int curr_pages ;
  u32 internal_page_offset ;
  u32 temp_num_pages ;
  u32 _min1 ;
  unsigned int _min2 ;
  uint32_t log_value ;

  {
  {
#line 1338
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1338
  wrb = tmp;
#line 1339
  tmp___0 = embedded_payload(wrb);
#line 1339
  req = (struct be_post_sgl_pages_req *)tmp___0;
#line 1340
  tmp___1 = pci_get_drvdata(ctrl->pdev);
#line 1340
  phba = (struct beiscsi_hba *)tmp___1;
#line 1343
  internal_page_offset = 0U;
#line 1344
  temp_num_pages = num_pages;
  }
#line 1346
  if (num_pages == 255U) {
#line 1347
    num_pages = 1U;
  } else {

  }
  {
#line 1349
  ldv_spin_lock_121(& ctrl->mbox_lock);
  }
  ldv_56575: 
  {
#line 1351
  __memset((void *)wrb, 0, 256UL);
#line 1352
  be_wrb_hdr_prepare(wrb, 236, 1, 0);
#line 1353
  be_cmd_hdr_prepare(& req->hdr, 2, 2, 236);
#line 1356
  curr_pages = 26U;
#line 1358
  _min1 = num_pages;
#line 1358
  _min2 = curr_pages;
#line 1358
  req->num_pages = (u16 )(_min1 < _min2 ? _min1 : _min2);
#line 1359
  req->page_offset = (u16 )page_offset___0;
#line 1360
  be_cmd_page_addrs_prepare((struct phys_addr *)(& req->pages), (u32 )req->num_pages,
                            q_mem);
#line 1361
  q_mem->dma = q_mem->dma + (unsigned long long )((unsigned long )req->num_pages * 4096UL);
#line 1362
  internal_page_offset = internal_page_offset + (u32 )req->num_pages;
#line 1363
  page_offset___0 = page_offset___0 + (u32 )req->num_pages;
#line 1364
  num_pages = num_pages - (u32 )req->num_pages;
  }
#line 1366
  if (temp_num_pages == 255U) {
#line 1367
    req->num_pages = (u16 )temp_num_pages;
  } else {

  }
  {
#line 1369
  status = be_mbox_notify(ctrl);
  }
#line 1370
  if (status != 0) {
#line 1371
    log_value = phba->attr_log_enable;
#line 1371
    if ((int )log_value & 1 || (int )((signed char )*("\v" + 1)) <= 51) {
      {
#line 1371
      dev_printk("\v", (struct device  const  *)(& (phba->shost)->shost_gendev), "BC_%d : FW CMD to map iscsi frags failed.\n",
                 1372);
      }
    } else {

    }
#line 1374
    goto error;
  } else {

  }
#line 1376
  if (num_pages != 0U) {
#line 1378
    goto ldv_56575;
  } else {

  }

  error: 
  {
#line 1378
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1379
  if (status != 0) {
    {
#line 1380
    beiscsi_cmd_q_destroy(ctrl, (struct be_queue_info *)0, 6);
    }
  } else {

  }
#line 1381
  return (status);
}
}
#line 1384 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int beiscsi_cmd_reset_function(struct beiscsi_hba *phba ) 
{ 
  struct be_ctrl_info *ctrl ;
  struct be_mcc_wrb *wrb ;
  struct be_mcc_wrb *tmp ;
  struct be_post_sgl_pages_req *req ;
  void *tmp___0 ;
  int status ;
  void *tmp___1 ;

  {
  {
#line 1386
  ctrl = & phba->ctrl;
#line 1387
  tmp = wrb_from_mbox(& ctrl->mbox_mem);
#line 1387
  wrb = tmp;
#line 1388
  tmp___0 = embedded_payload(wrb);
#line 1388
  req = (struct be_post_sgl_pages_req *)tmp___0;
#line 1391
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1393
  tmp___1 = embedded_payload(wrb);
#line 1393
  req = (struct be_post_sgl_pages_req *)tmp___1;
#line 1394
  be_wrb_hdr_prepare(wrb, 236, 1, 0);
#line 1395
  be_cmd_hdr_prepare(& req->hdr, 1, 61, 236);
#line 1397
  status = be_mbox_notify_wait(phba);
#line 1399
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1400
  return (status);
}
}
#line 1413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/scsi/be2iscsi/be_cmds.c"
int be_cmd_set_vlan(struct beiscsi_hba *phba , uint16_t vlan_tag ) 
{ 
  unsigned int tag ;
  struct be_mcc_wrb *wrb ;
  struct be_cmd_set_vlan_req *req ;
  struct be_ctrl_info *ctrl ;
  void *tmp ;

  {
  {
#line 1416
  tag = 0U;
#line 1419
  ctrl = & phba->ctrl;
#line 1421
  ldv_spin_lock_121(& ctrl->mbox_lock);
#line 1422
  tag = alloc_mcc_tag(phba);
  }
#line 1423
  if (tag == 0U) {
    {
#line 1424
    ldv_spin_unlock_122(& ctrl->mbox_lock);
    }
#line 1425
    return ((int )tag);
  } else {

  }
  {
#line 1428
  wrb = wrb_from_mccq(phba);
#line 1429
  tmp = embedded_payload(wrb);
#line 1429
  req = (struct be_cmd_set_vlan_req *)tmp;
#line 1430
  wrb->tag0 = wrb->tag0 | tag;
#line 1431
  be_wrb_hdr_prepare(wrb, 256, 1, 0);
#line 1432
  be_cmd_hdr_prepare(& req->hdr, 2, 14, 24);
#line 1436
  req->interface_hndl = phba->interface_handle;
#line 1437
  req->vlan_priority = (u32 )vlan_tag;
#line 1439
  be_mcc_notify(phba);
#line 1440
  ldv_spin_unlock_122(& ctrl->mbox_lock);
  }
#line 1442
  return ((int )tag);
}
}
#line 759 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_cmds.c.aux"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
  {
#line 762
  ldv_linux_usb_dev_atomic_inc(v);
  }
#line 763
  return;
}
}
#line 1652 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_cmds.c.aux"
__inline static void ldv_spin_lock_bh_131(spinlock_t *lock ) 
{ 


  {
  {
#line 1655
  ldv_linux_kernel_locking_spinlock_spin_lock_mcc_cq_lock_of_be_ctrl_info();
#line 1657
  spin_lock_bh(lock);
  }
#line 1658
  return;
}
}
#line 1660 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/weaver/.tmp_be_cmds.c.aux"
__inline static void ldv_spin_unlock_bh_132(spinlock_t *lock ) 
{ 


  {
  {
#line 1663
  ldv_linux_kernel_locking_spinlock_spin_unlock_mcc_cq_lock_of_be_ctrl_info();
#line 1665
  spin_unlock_bh(lock);
  }
#line 1666
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/irq.linux_alloc_irq.bk.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) ;
#line 50 "/home/ubuntu/klever-work/linux/ldv/irq.h"
bool ldv_in_interrupt_context(void) ;
#line 24 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 27
  tmp = ldv_in_interrupt_context();
  }
#line 27
  if (tmp) {
#line 27
    tmp___0 = 0;
  } else {
#line 27
    tmp___0 = 1;
  }
  {
#line 27
  ldv_assert_linux_alloc_irq__wrong_flags(tmp___0 || flags == 32U);
  }
#line 28
  return;
}
}
#line 31 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) 
{ 
  bool tmp ;

  {
  {
#line 33
  tmp = ldv_in_interrupt_context();
  }
#line 33
  if ((int )tmp) {
    {
#line 36
    ldv_assert_linux_alloc_irq__nonatomic(0);
    }
  } else {

  }
#line 37
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/spinlock.linux_alloc_spinlock.bk.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
int ldv_exclusive_spin_is_locked(void) ;
#line 25 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_flags(gfp_t flags ) 
{ 
  int tmp ;

  {
#line 27
  if (flags != 32U && flags != 0U) {
    {
#line 29
    tmp = ldv_exclusive_spin_is_locked();
#line 29
    ldv_assert_linux_alloc_spinlock__wrong_flags(tmp == 0);
    }
  } else {

  }
#line 30
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_nonatomic(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_exclusive_spin_is_locked();
#line 37
  ldv_assert_linux_alloc_spinlock__nonatomic(tmp == 0);
  }
#line 38
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/usb lock.linux_alloc_usb_lock.bk.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_lock  =    1;
#line 26 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 28
  if (ldv_linux_alloc_usb_lock_lock == 2) {
    {
#line 31
    ldv_assert_linux_alloc_usb_lock__wrong_flags(flags == 16U || flags == 32U);
    }
  } else {

  }
#line 32
  return;
}
}
#line 36 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_alloc_usb_lock__nonatomic(ldv_linux_alloc_usb_lock_lock == 1);
  }
#line 40
  return;
}
}
#line 43 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_lock_device(void) 
{ 


  {
#line 46
  ldv_linux_alloc_usb_lock_lock = 2;
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_trylock_device(void) 
{ 
  int tmp ;

  {
#line 52
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 52
    tmp = ldv_undef_int();
    }
#line 52
    if (tmp != 0) {
#line 55
      ldv_linux_alloc_usb_lock_lock = 2;
#line 57
      return (1);
    } else {
#line 62
      return (0);
    }
  } else {
#line 62
    return (0);
  }
}
}
#line 67 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_lock_device_for_reset(void) 
{ 
  int tmp ;

  {
#line 69
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 69
    tmp = ldv_undef_int();
    }
#line 69
    if (tmp != 0) {
#line 72
      ldv_linux_alloc_usb_lock_lock = 2;
#line 74
      return (0);
    } else {
#line 79
      return (-1);
    }
  } else {
#line 79
    return (-1);
  }
}
}
#line 84 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_unlock_device(void) 
{ 


  {
#line 87
  ldv_linux_alloc_usb_lock_lock = 1;
#line 88
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 23
  v->counter = v->counter + i;
#line 24
  return;
}
}
#line 27 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 29
  v->counter = v->counter - i;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_sub_and_test(int i , atomic_t *v ) 
{ 


  {
#line 35
  v->counter = v->counter - i;
#line 36
  if (v->counter != 0) {
#line 37
    return (0);
  } else {

  }
#line 39
  return (1);
}
}
#line 43 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) 
{ 


  {
#line 45
  v->counter = v->counter + 1;
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_dec(atomic_t *v ) 
{ 


  {
#line 51
  v->counter = v->counter - 1;
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_dec_and_test(atomic_t *v ) 
{ 


  {
#line 57
  v->counter = v->counter - 1;
#line 58
  if (v->counter != 0) {
#line 59
    return (0);
  } else {

  }
#line 61
  return (1);
}
}
#line 65 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_and_test(atomic_t *v ) 
{ 


  {
#line 67
  v->counter = v->counter + 1;
#line 68
  if (v->counter != 0) {
#line 69
    return (0);
  } else {

  }
#line 71
  return (1);
}
}
#line 75 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) 
{ 


  {
#line 77
  v->counter = v->counter + i;
#line 78
  return (v->counter);
}
}
#line 82 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_negative(int i , atomic_t *v ) 
{ 


  {
#line 84
  v->counter = v->counter + i;
#line 85
  return (v->counter < 0);
}
}
#line 89 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_short(short *v ) 
{ 


  {
#line 91
  *v = (short )((unsigned int )((unsigned short )*v) + 1U);
#line 92
  return ((int )*v);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/io.linux_arch_io.bk.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/verifier/nondet.h"
void *ldv_undef_ptr(void) ;
#line 22 "/home/ubuntu/klever-work/linux/arch/io.c"
int ldv_linux_arch_io_iomem  =    0;
#line 25 "/home/ubuntu/klever-work/linux/arch/io.c"
void *ldv_linux_arch_io_io_mem_remap(void) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_undef_ptr();
#line 27
  ptr = tmp;
  }
#line 29
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 31
    ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem + 1;
#line 33
    return (ptr);
  } else {

  }
#line 36
  return (ptr);
}
}
#line 40 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_io_mem_unmap(void) 
{ 


  {
  {
#line 43
  ldv_assert_linux_arch_io__less_initial_decrement(ldv_linux_arch_io_iomem > 0);
#line 45
  ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem - 1;
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_arch_io__more_initial_at_exit(ldv_linux_arch_io_iomem == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/genhd.linux_block_genhd.bk.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) ;
#line 2
void ldv_assert_linux_block_genhd__double_allocation(int expr ) ;
#line 3
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) ;
#line 4
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) ;
#line 31 "/home/ubuntu/klever-work/linux/block/genhd.c"
static int ldv_linux_block_genhd_disk_state  =    0;
#line 34 "/home/ubuntu/klever-work/linux/block/genhd.c"
struct gendisk *ldv_linux_block_genhd_alloc_disk(void) 
{ 
  struct gendisk *res ;
  void *tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ptr();
#line 39
  res = (struct gendisk *)tmp;
#line 37
  ldv_assert_linux_block_genhd__double_allocation(ldv_linux_block_genhd_disk_state == 0);
  }
#line 41
  if ((unsigned long )res != (unsigned long )((struct gendisk *)0)) {
#line 43
    ldv_linux_block_genhd_disk_state = 1;
#line 45
    return (res);
  } else {

  }
#line 48
  return (res);
}
}
#line 52 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_add_disk(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_block_genhd__use_before_allocation(ldv_linux_block_genhd_disk_state == 1);
#line 57
  ldv_linux_block_genhd_disk_state = 2;
  }
#line 58
  return;
}
}
#line 61 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_del_gendisk(void) 
{ 


  {
  {
#line 64
  ldv_assert_linux_block_genhd__delete_before_add(ldv_linux_block_genhd_disk_state == 2);
#line 66
  ldv_linux_block_genhd_disk_state = 1;
  }
#line 67
  return;
}
}
#line 70 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_put_disk(struct gendisk *disk ) 
{ 


  {
#line 72
  if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
    {
#line 74
    ldv_assert_linux_block_genhd__free_before_allocation(ldv_linux_block_genhd_disk_state > 0);
#line 76
    ldv_linux_block_genhd_disk_state = 0;
    }
  } else {

  }
#line 78
  return;
}
}
#line 81 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_check_final_state(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_block_genhd__more_initial_at_exit(ldv_linux_block_genhd_disk_state == 0);
  }
#line 85
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/queue.linux_block_queue.bk.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) ;
#line 2
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/block/queue.c"
static int ldv_linux_block_queue_queue_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/block/queue.c"
struct request_queue *ldv_linux_block_queue_request_queue(void) 
{ 
  struct request_queue *res ;
  void *tmp ;

  {
  {
#line 38
  tmp = ldv_undef_ptr();
#line 38
  res = (struct request_queue *)tmp;
#line 36
  ldv_assert_linux_block_queue__double_allocation(ldv_linux_block_queue_queue_state == 0);
  }
#line 40
  if ((unsigned long )res != (unsigned long )((struct request_queue *)0)) {
#line 42
    ldv_linux_block_queue_queue_state = 1;
#line 44
    return (res);
  } else {

  }
#line 47
  return (res);
}
}
#line 51 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_blk_cleanup_queue(void) 
{ 


  {
  {
#line 54
  ldv_assert_linux_block_queue__use_before_allocation(ldv_linux_block_queue_queue_state == 1);
#line 56
  ldv_linux_block_queue_queue_state = 0;
  }
#line 57
  return;
}
}
#line 60 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_check_final_state(void) 
{ 


  {
  {
#line 63
  ldv_assert_linux_block_queue__more_initial_at_exit(ldv_linux_block_queue_queue_state == 0);
  }
#line 64
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/request.linux_block_request.bk.c"
void ldv_assert_linux_block_request__double_get(int expr ) ;
#line 2
void ldv_assert_linux_block_request__double_put(int expr ) ;
#line 3
void ldv_assert_linux_block_request__get_at_exit(int expr ) ;
#line 21 "/home/ubuntu/klever-work/linux/ldv/err.h"
long ldv_is_err(void const   *ptr ) ;
#line 32 "/home/ubuntu/klever-work/linux/block/request.c"
int ldv_linux_block_request_blk_rq  =    0;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_get_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;

  {
  {
#line 40
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 43
  tmp = ldv_undef_ptr();
#line 43
  res = (struct request *)tmp;
  }
#line 46
  if ((mask == 16U || mask == 208U) || mask == 16U) {
    {
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
    }
  } else {

  }
#line 49
  if ((unsigned long )res != (unsigned long )((struct request *)0)) {
#line 51
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 54
  return (res);
}
}
#line 58 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_make_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 63
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 66
  tmp = ldv_undef_ptr();
#line 66
  res = (struct request *)tmp;
#line 67
  ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
  }
#line 70
  if (tmp___0 == 0L) {
#line 72
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 75
  return (res);
}
}
#line 79 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_put_blk_rq(void) 
{ 


  {
  {
#line 82
  ldv_assert_linux_block_request__double_put(ldv_linux_block_request_blk_rq == 1);
#line 84
  ldv_linux_block_request_blk_rq = 0;
  }
#line 85
  return;
}
}
#line 88 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_block_request__get_at_exit(ldv_linux_block_request_blk_rq == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/class.linux_drivers_base_class.bk.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_nonpositive(void) ;
#line 33 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_usb_gadget_class  =    0;
#line 36 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void *ldv_linux_drivers_base_class_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 41
  is_got = ldv_undef_ptr();
#line 44
  ldv_assume((int )((long )is_got));
#line 47
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 47
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 52
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 56
  return (is_got);
}
}
#line 60 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 65
  is_reg = ldv_undef_int_nonpositive();
  }
#line 68
  if (is_reg == 0) {
    {
#line 71
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 73
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 77
  return (is_reg);
}
}
#line 81 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_unregister_class(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_drivers_base_class__double_deregistration(ldv_linux_drivers_base_class_usb_gadget_class == 1);
#line 86
  ldv_linux_drivers_base_class_usb_gadget_class = 0;
  }
#line 87
  return;
}
}
#line 89 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 91
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 92
    return;
  } else {
    {
#line 91
    tmp = ldv_is_err((void const   *)cls);
    }
#line 91
    if (tmp != 0L) {
#line 92
      return;
    } else {

    }
  }
  {
#line 93
  ldv_linux_drivers_base_class_unregister_class();
  }
#line 94
  return;
}
}
#line 97 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_check_final_state(void) 
{ 


  {
  {
#line 100
  ldv_assert_linux_drivers_base_class__registered_at_exit(ldv_linux_drivers_base_class_usb_gadget_class == 0);
  }
#line 101
  return;
}
}
#line 35 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 26 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 28
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 29
    return ((dev->p)->driver_data);
  } else {

  }
#line 30
  return ((void *)0);
}
}
#line 39 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 41
  tmp = ldv_xzalloc(8UL);
#line 41
  dev->p = (struct device_private *)tmp;
#line 42
  (dev->p)->driver_data = data;
  }
#line 43
  return (0);
}
}
#line 31 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/ubuntu/klever-work/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 2176UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)master + 1U);
  }
#line 34
  return (master);
}
}
#line 20 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/ubuntu/klever-work/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/ubuntu/klever-work/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/char_dev.linux_fs_char_dev.bk.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_usb_gadget_chrdev  =    0;
#line 33 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 38
  is_reg = ldv_undef_int_nonpositive();
  }
#line 41
  if (is_reg == 0) {
    {
#line 43
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 45
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
#line 46
    if (major == 0) {
      {
#line 48
      is_reg = ldv_undef_int();
#line 49
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 54
  return (is_reg);
}
}
#line 58 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 70
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
  } else {

  }
#line 74
  return (is_reg);
}
}
#line 78 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_unregister_chrdev_region(void) 
{ 


  {
  {
#line 81
  ldv_assert_linux_fs_char_dev__double_deregistration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 1);
#line 83
  ldv_linux_fs_char_dev_usb_gadget_chrdev = 0;
  }
#line 84
  return;
}
}
#line 87 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_check_final_state(void) 
{ 


  {
  {
#line 90
  ldv_assert_linux_fs_char_dev__registered_at_exit(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
  }
#line 91
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/sysfs.linux_fs_sysfs.bk.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs  =    0;
#line 25 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs_create_group(void) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 28
  tmp = ldv_undef_int_nonpositive();
#line 28
  res = tmp;
  }
#line 30
  if (res == 0) {
#line 32
    ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs + 1;
#line 34
    return (0);
  } else {

  }
#line 37
  return (res);
}
}
#line 41 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_sysfs_remove_group(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_fs_sysfs__less_initial_decrement(ldv_linux_fs_sysfs_sysfs > 0);
#line 46
  ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs - 1;
  }
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_check_final_state(void) 
{ 


  {
  {
#line 53
  ldv_assert_linux_fs_sysfs__more_initial_at_exit(ldv_linux_fs_sysfs_sysfs == 0);
  }
#line 54
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/rwlock.linux_kernel_locking_rwlock.bk.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) ;
#line 6
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_rlock  =    1;
#line 25 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_wlock  =    1;
#line 28 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_lock(void) 
{ 


  {
  {
#line 31
  ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 33
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
  }
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_unlock(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(ldv_linux_kernel_locking_rwlock_rlock > 1);
#line 42
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + -1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_lock(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_locking_rwlock__double_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 51
  ldv_linux_kernel_locking_rwlock_wlock = 2;
  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_unlock(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(ldv_linux_kernel_locking_rwlock_wlock != 1);
#line 60
  ldv_linux_kernel_locking_rwlock_wlock = 1;
  }
#line 61
  return;
}
}
#line 64 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_read_trylock(void) 
{ 
  int tmp ;

  {
#line 67
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 67
    tmp = ldv_undef_int();
    }
#line 67
    if (tmp != 0) {
#line 69
      ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
#line 71
      return (1);
    } else {
#line 75
      return (0);
    }
  } else {
#line 75
    return (0);
  }
}
}
#line 80 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_write_trylock(void) 
{ 
  int tmp ;

  {
#line 83
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 83
    tmp = ldv_undef_int();
    }
#line 83
    if (tmp != 0) {
#line 85
      ldv_linux_kernel_locking_rwlock_wlock = 2;
#line 87
      return (1);
    } else {
#line 91
      return (0);
    }
  } else {
#line 91
    return (0);
  }
}
}
#line 96 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_check_final_state(void) 
{ 


  {
  {
#line 99
  ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(ldv_linux_kernel_locking_rwlock_rlock == 1);
#line 101
  ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(ldv_linux_kernel_locking_rwlock_wlock == 1);
  }
#line 102
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/module.linux_kernel_module.bk.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_module_refcounter  =    1;
#line 27 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_get(struct module *module ) 
{ 


  {
#line 30
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 32
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
  } else {

  }
#line 33
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_try_module_get(struct module *module ) 
{ 
  int tmp ;

  {
#line 40
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 42
    tmp = ldv_undef_int();
    }
#line 42
    if (tmp == 1) {
#line 44
      ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
#line 46
      return (1);
    } else {
#line 50
      return (0);
    }
  } else {

  }
#line 51
  return (0);
}
}
#line 56 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put(struct module *module ) 
{ 


  {
#line 59
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 61
    ldv_assert_linux_kernel_module__less_initial_decrement(ldv_linux_kernel_module_module_refcounter > 1);
#line 63
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter - 1;
    }
  } else {

  }
#line 65
  return;
}
}
#line 68 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put_and_exit(void) 
{ 


  {
  {
#line 71
  ldv_linux_kernel_module_module_put((struct module *)1);
  }
  LDV_LINUX_KERNEL_MODULE_STOP: ;
#line 73
  goto LDV_LINUX_KERNEL_MODULE_STOP;
}
}
#line 77 "/home/ubuntu/klever-work/linux/kernel/module.c"
unsigned int ldv_linux_kernel_module_module_refcount(void) 
{ 


  {
#line 80
  return ((unsigned int )(ldv_linux_kernel_module_module_refcounter + -1));
}
}
#line 84 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_check_final_state(void) 
{ 


  {
  {
#line 87
  ldv_assert_linux_kernel_module__more_initial_at_exit(ldv_linux_kernel_module_module_refcounter == 1);
  }
#line 88
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/srcu.linux_kernel_rcu_srcu.bk.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
int ldv_linux_kernel_rcu_srcu_srcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_srcu__more_unlocks(ldv_linux_kernel_rcu_srcu_srcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/lock bh.linux_kernel_rcu_update_lock_bh.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
int ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_lock_bh(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_unlock_bh(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/lock sched.linux_kernel_rcu_update_lock_sched.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
int ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_lock_sched(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_unlock_sched(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/lock.linux_kernel_rcu_update_lock.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
int ldv_linux_kernel_rcu_update_lock_rcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(ldv_linux_kernel_rcu_update_lock_rcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 53
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 23
  ldv_assume(val <= 0);
  }
#line 24
  return (val);
}
}
#line 31 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 45
  return (tmp);
}
}
#line 25 "/home/ubuntu/klever-work/linux/ldv/irq.c"
static bool __ldv_in_interrupt_context  =    0;
#line 27 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_interrupt_context(void) 
{ 


  {
#line 29
  __ldv_in_interrupt_context = 1;
#line 30
  return;
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_process_context(void) 
{ 


  {
#line 34
  __ldv_in_interrupt_context = 0;
#line 35
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/irq.c"
bool ldv_in_interrupt_context(void) 
{ 


  {
#line 39
  return (__ldv_in_interrupt_context);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/find_bit.linux_lib_find_bit.bk.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.h"
unsigned long ldv_undef_ulong(void) ;
#line 24 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_next_bit(unsigned long size , unsigned long offset ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 29
  tmp = ldv_undef_ulong();
#line 29
  nondet = tmp;
#line 27
  ldv_assert_linux_lib_find_bit__offset_out_of_range(offset <= size);
#line 30
  ldv_assume(nondet <= size);
#line 31
  ldv_assume(1);
  }
#line 32
  return (nondet);
}
}
#line 36 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_first_bit(unsigned long size ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ulong();
#line 39
  nondet = tmp;
#line 40
  ldv_assume(nondet <= size);
#line 41
  ldv_assume(1);
  }
#line 42
  return (nondet);
}
}
#line 46 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
void ldv_linux_lib_find_bit_initialize(void) 
{ 


  {
  {
#line 48
  ldv_assume(nr_cpu_ids > 0);
  }
#line 49
  return;
}
}
#line 24 "/home/ubuntu/klever-work/linux/mm/kzalloc.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 28
  ldv_check_alloc_flags(flags);
#line 29
  res = ldv_zalloc(size);
#line 30
  ldv_after_alloc(res);
  }
#line 32
  return (res);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/sdio_func.linux_mmc_sdio_func.bk.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) ;
#line 2
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) ;
#line 3
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) ;
#line 25 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
unsigned short ldv_linux_mmc_sdio_func_sdio_element  =    0U;
#line 28 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_context(struct sdio_func *func ) 
{ 


  {
  {
#line 31
  ldv_assert_linux_mmc_sdio_func__wrong_params((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
  }
#line 32
  return;
}
}
#line 35 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_claim_host(struct sdio_func *func ) 
{ 


  {
  {
#line 38
  ldv_assert_linux_mmc_sdio_func__double_claim((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
#line 41
  ldv_linux_mmc_sdio_func_sdio_element = (unsigned short )((func->card)->host)->index;
  }
#line 42
  return;
}
}
#line 45 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_release_host(struct sdio_func *func ) 
{ 


  {
  {
#line 48
  ldv_assert_linux_mmc_sdio_func__release_without_claim((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
#line 51
  ldv_linux_mmc_sdio_func_sdio_element = 0U;
  }
#line 52
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_mmc_sdio_func__unreleased_at_exit((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/register.linux_net_register.bk.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) ;
#line 105 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_register_netdev(void) ;
#line 30 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_linux_net_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_pre_register_netdev(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_net_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_net_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_net_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_net_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_net_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/rtnetlink.linux_net_rtnetlink.bk.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) ;
#line 2
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) ;
#line 3
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int rtnllocknumber  =    0;
#line 29 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_unlock(void) 
{ 


  {
  {
#line 32
  ldv_assert_linux_net_rtnetlink__double_unlock(rtnllocknumber == 1);
#line 34
  rtnllocknumber = 0;
  }
#line 35
  return;
}
}
#line 38 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_lock(void) 
{ 


  {
  {
#line 41
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 43
  rtnllocknumber = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_before_ieee80211_unregister_hw(void) 
{ 


  {
  {
#line 50
  ldv_linux_net_rtnetlink_past_rtnl_lock();
#line 52
  ldv_linux_net_rtnetlink_past_rtnl_unlock();
  }
#line 53
  return;
}
}
#line 56 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_is_locked(void) 
{ 
  int tmp ;

  {
#line 59
  if (rtnllocknumber != 0) {
#line 61
    return (rtnllocknumber);
  } else {
    {
#line 63
    tmp = ldv_undef_int();
    }
#line 63
    if (tmp != 0) {
#line 65
      return (1);
    } else {
#line 68
      return (0);
    }
  }
}
}
#line 72 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_trylock(void) 
{ 
  int tmp ;

  {
  {
#line 75
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 77
  tmp = ldv_linux_net_rtnetlink_rtnl_is_locked();
  }
#line 77
  if (tmp == 0) {
#line 79
    rtnllocknumber = 1;
#line 81
    return (1);
  } else {
#line 84
    return (0);
  }
}
}
#line 88 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_net_rtnetlink__lock_on_exit(rtnllocknumber == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/sock.linux_net_sock.bk.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) ;
#line 2
void ldv_assert_linux_net_sock__double_release(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/net/sock.c"
int locksocknumber  =    0;
#line 27 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_past_lock_sock_nested(void) 
{ 


  {
#line 30
  locksocknumber = locksocknumber + 1;
#line 31
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/net/sock.c"
bool ldv_linux_net_sock_lock_sock_fast(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_undef_int();
  }
#line 37
  if (tmp != 0) {
#line 39
    locksocknumber = locksocknumber + 1;
#line 41
    return (1);
  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_unlock_sock_fast(void) 
{ 


  {
  {
#line 51
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 53
  locksocknumber = locksocknumber - 1;
  }
#line 54
  return;
}
}
#line 57 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_before_release_sock(void) 
{ 


  {
  {
#line 60
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 62
  locksocknumber = locksocknumber - 1;
  }
#line 63
  return;
}
}
#line 66 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_check_final_state(void) 
{ 


  {
  {
#line 69
  ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(locksocknumber == 0);
  }
#line 70
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/coherent.linux_usb_coherent.bk.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/coherent.c"
int ldv_linux_usb_coherent_coherent_state  =    0;
#line 27 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void *ldv_linux_usb_coherent_usb_alloc_coherent(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 30
  tmp = ldv_undef_ptr();
#line 30
  arbitrary_memory = tmp;
  }
#line 32
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 34
    return (arbitrary_memory);
  } else {

  }
#line 37
  ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + 1;
#line 39
  return (arbitrary_memory);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_usb_free_coherent(void *addr ) 
{ 


  {
#line 45
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 47
    ldv_assert_linux_usb_coherent__less_initial_decrement(ldv_linux_usb_coherent_coherent_state > 0);
#line 49
    ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + -1;
    }
  } else {

  }
#line 51
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_usb_coherent__more_initial_at_exit(ldv_linux_usb_coherent_coherent_state == 0);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/dev.linux_usb_dev.bk.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_usb_dev__probe_failed(int expr ) ;
#line 4
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/dev.c"
ldv_map LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS  ;
#line 27 "/home/ubuntu/klever-work/linux/usb/dev.c"
struct usb_device *ldv_linux_usb_dev_usb_get_dev(struct usb_device *dev ) 
{ 


  {
#line 30
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
#line 32
    LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0 ? LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + 1 : 1;
  } else {

  }
#line 39
  return (dev);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_usb_put_dev(struct usb_device *dev ) 
{ 


  {
#line 46
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
    {
#line 48
    ldv_assert_linux_usb_dev__unincremented_counter_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0);
#line 50
    ldv_assert_linux_usb_dev__less_initial_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 0);
    }
#line 54
    if (LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 1) {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + -1;
    } else {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
    }
  } else {

  }
#line 56
  return;
}
}
#line 59 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_return_value_probe(int retval ) 
{ 


  {
#line 62
  if (retval != 0) {
    {
#line 64
    ldv_assert_linux_usb_dev__probe_failed(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
    }
  } else {

  }
#line 65
  return;
}
}
#line 69 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_initialize(void) 
{ 


  {
#line 72
  LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
#line 73
  return;
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_final_state(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_dev__more_initial_at_exit(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
  }
#line 80
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/gadget.linux_usb_gadget.bk.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) ;
#line 2
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) ;
#line 3
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) ;
#line 4
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) ;
#line 5
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) ;
#line 6
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) ;
#line 7
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) ;
#line 33 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_usb_gadget  =    0;
#line 37 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void *ldv_linux_usb_gadget_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 42
  is_got = ldv_undef_ptr();
#line 45
  ldv_assume((int )((long )is_got));
#line 48
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 48
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 54
  return (is_got);
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 72
  return (is_reg);
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_class(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 80
  return;
}
}
#line 82 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 84
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 85
    return;
  } else {
    {
#line 84
    tmp = ldv_is_err((void const   *)cls);
    }
#line 84
    if (tmp != 0L) {
#line 85
      return;
    } else {

    }
  }
  {
#line 86
  ldv_linux_usb_gadget_unregister_class();
  }
#line 87
  return;
}
}
#line 90 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 95
  is_reg = ldv_undef_int_nonpositive();
  }
#line 98
  if (is_reg == 0) {
    {
#line 100
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
#line 101
    if (major == 0) {
      {
#line 103
      is_reg = ldv_undef_int();
#line 104
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 109
  return (is_reg);
}
}
#line 113 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 118
  is_reg = ldv_undef_int_nonpositive();
  }
#line 121
  if (is_reg == 0) {
    {
#line 123
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 127
  return (is_reg);
}
}
#line 131 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_chrdev_region(void) 
{ 


  {
  {
#line 134
  ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 135
  return;
}
}
#line 138 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_usb_gadget(void) 
{ 
  int is_reg ;

  {
  {
#line 143
  is_reg = ldv_undef_int_nonpositive();
  }
#line 146
  if (is_reg == 0) {
    {
#line 148
    ldv_assert_linux_usb_gadget__double_usb_gadget_registration(ldv_linux_usb_gadget_usb_gadget == 0);
#line 150
    ldv_linux_usb_gadget_usb_gadget = 1;
    }
  } else {

  }
#line 154
  return (is_reg);
}
}
#line 158 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_usb_gadget(void) 
{ 


  {
  {
#line 161
  ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(ldv_linux_usb_gadget_usb_gadget == 1);
#line 163
  ldv_linux_usb_gadget_usb_gadget = 0;
  }
#line 164
  return;
}
}
#line 167 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_check_final_state(void) 
{ 


  {
  {
#line 170
  ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 171
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/register.linux_usb_register.bk.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) ;
#line 90 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_usb_register_driver(void) ;
#line 30 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_linux_usb_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_pre_usb_register_driver(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_usb_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_usb_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_usb_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_usb_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_usb_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/urb.linux_usb_urb.bk.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/usb/urb.c"
int ldv_linux_usb_urb_urb_state  =    0;
#line 29 "/home/ubuntu/klever-work/linux/usb/urb.c"
struct urb *ldv_linux_usb_urb_usb_alloc_urb(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 32
  tmp = ldv_undef_ptr();
#line 32
  arbitrary_memory = tmp;
  }
#line 34
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 36
    return ((struct urb *)arbitrary_memory);
  } else {

  }
#line 39
  ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + 1;
#line 41
  return ((struct urb *)arbitrary_memory);
}
}
#line 45 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_usb_free_urb(struct urb *urb ) 
{ 


  {
#line 46
  if ((unsigned long )urb != (unsigned long )((struct urb *)0)) {
    {
#line 48
    ldv_assert_linux_usb_urb__less_initial_decrement(ldv_linux_usb_urb_urb_state > 0);
#line 50
    ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + -1;
    }
  } else {

  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_check_final_state(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_usb_urb__more_initial_at_exit(ldv_linux_usb_urb_urb_state == 0);
  }
#line 59
  return;
}
}
#line 24 "/home/ubuntu/klever-work/verifier/common.h"
extern void ldv_assert(char const   * , int  ) ;
#line 45
void __builtin_trap(void) ;
#line 23 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_assume(int expression ) 
{ 


  {
#line 25
  if (expression == 0) {
    ldv_assume_label: ;
#line 29
    goto ldv_assume_label;
  } else {

  }
#line 31
  return;
}
}
#line 33 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_stop(void) 
{ 


  {
  ldv_stop_label: ;
#line 36
  goto ldv_stop_label;
}
}
#line 43 "/home/ubuntu/klever-work/verifier/common.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 45
  return (exp);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/common.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 56
  ldv_assert("", 0);
  }
#line 57
  return;
}
}
#line 29 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 30
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 37
extern void *external_allocated_data(void) ;
#line 40
void *ldv_calloc_unknown_size(void) ;
#line 41
void *ldv_zalloc_unknown_size(void) ;
#line 47
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 25 "/home/ubuntu/klever-work/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 26
extern void *calloc(size_t  , size_t  ) ;
#line 27
extern void free(void * ) ;
#line 28
extern void *memset(void * , int  , size_t  ) ;
#line 30 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp___1 = ldv_undef_int();
  }
#line 32
  if (tmp___1 != 0) {
    {
#line 33
    tmp = malloc(size);
#line 33
    res = tmp;
#line 34
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    ldv_assume(tmp___0 == 0L);
    }
#line 36
    return (res);
  } else {
#line 39
    return ((void *)0);
  }
}
}
#line 43 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 48
    tmp___0 = ldv_is_err((void const   *)res);
#line 48
    ldv_assume(tmp___0 == 0L);
    }
#line 49
    return (res);
  } else {
#line 52
    return ((void *)0);
  }
}
}
#line 56 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = ldv_calloc(1UL, size);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/ubuntu/klever-work/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 63
  free(s);
  }
#line 64
  return;
}
}
#line 66 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 68
  tmp = malloc(size);
#line 68
  res = tmp;
#line 69
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
#line 70
  ldv_assume(tmp___0 == 0L);
  }
#line 71
  return (res);
}
}
#line 74 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 76
  tmp = calloc(1UL, size);
#line 76
  res = tmp;
#line 77
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 78
  tmp___0 = ldv_is_err((void const   *)res);
#line 78
  ldv_assume(tmp___0 == 0L);
  }
#line 79
  return (res);
}
}
#line 82 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = ldv_undef_int();
  }
#line 84
  if (tmp___1 != 0) {
    {
#line 85
    tmp = external_allocated_data();
#line 85
    res = tmp;
#line 86
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 87
    tmp___0 = ldv_is_err((void const   *)res);
#line 87
    ldv_assume(tmp___0 == 0L);
    }
#line 88
    return (res);
  } else {
#line 91
    return ((void *)0);
  }
}
}
#line 95 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 97
  tmp___1 = ldv_undef_int();
  }
#line 97
  if (tmp___1 != 0) {
    {
#line 98
    tmp = external_allocated_data();
#line 98
    res = tmp;
#line 99
    memset(res, 0, 8UL);
#line 100
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 101
    tmp___0 = ldv_is_err((void const   *)res);
#line 101
    ldv_assume(tmp___0 == 0L);
    }
#line 102
    return (res);
  } else {
#line 105
    return ((void *)0);
  }
}
}
#line 109 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 111
  tmp = ldv_calloc_unknown_size();
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 116
  tmp = external_allocated_data();
#line 116
  res = tmp;
#line 117
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 118
  tmp___0 = ldv_is_err((void const   *)res);
#line 118
  ldv_assume(tmp___0 == 0L);
  }
#line 119
  return (res);
}
}
#line 27 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_negative(void) ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern void *__VERIFIER_nondet_pointer(void) ;
#line 40 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = __VERIFIER_nondet_int();
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/ubuntu/klever-work/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = __VERIFIER_nondet_pointer();
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 49
  tmp = __VERIFIER_nondet_ulong();
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 54
  tmp = ldv_undef_int();
#line 54
  ret = tmp;
#line 55
  ldv_assume(ret < 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 61
  tmp = ldv_undef_int();
#line 61
  ret = tmp;
#line 62
  ldv_assume(ret <= 0);
  }
#line 63
  return (ret);
}
}
#line 32 "/home/ubuntu/klever-work/verifier/thread.h"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) ;
#line 35
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) ;
#line 38
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) ;
#line 41
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) ;
#line 27 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) 
{ 


  {
#line 29
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
    {
#line 30
    (*function)(data);
    }
  } else {

  }
#line 31
  return (0);
}
}
#line 35 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) 
{ 
  int i ;

  {
#line 39
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
#line 40
    i = 0;
#line 40
    goto ldv_1179;
    ldv_1178: 
    {
#line 41
    (*function)(data);
#line 40
    i = i + 1;
    }
    ldv_1179: ;
#line 40
    if (i < ldv_thread_set->number) {
#line 42
      goto ldv_1178;
    } else {

    }

  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) 
{ 


  {
#line 56
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/mutex.linux_kernel_locking_mutex.bk.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode  ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 33
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 35
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
  }
#line 36
  return;
}
}
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 42
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 44
  tmp = ldv_undef_int();
  }
#line 44
  if (tmp != 0) {
#line 46
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 48
    return (0);
  } else {
#line 52
    return (-4);
  }
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 60
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode) {
#line 62
    return (1);
  } else {
    {
#line 65
    tmp = ldv_undef_int();
    }
#line 65
    if (tmp != 0) {
#line 67
      return (1);
    } else {
#line 71
      return (0);
    }
  }
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 79
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 82
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(lock);
  }
#line 82
  if (tmp != 0) {
#line 84
    return (0);
  } else {
#line 88
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 90
    return (1);
  }
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt ,
                                                                              struct mutex *lock ) 
{ 


  {
#line 98
  cnt->counter = cnt->counter - 1;
#line 101
  if (cnt->counter != 0) {
#line 103
    return (0);
  } else {
    {
#line 106
    ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(lock);
    }
#line 108
    return (1);
  }
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 116
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 118
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
  }
#line 119
  return;
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock  ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 126
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 128
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
  }
#line 129
  return;
}
}
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 135
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 137
  tmp = ldv_undef_int();
  }
#line 137
  if (tmp != 0) {
#line 139
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 141
    return (0);
  } else {
#line 145
    return (-4);
  }
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 153
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock) {
#line 155
    return (1);
  } else {
    {
#line 158
    tmp = ldv_undef_int();
    }
#line 158
    if (tmp != 0) {
#line 160
      return (1);
    } else {
#line 164
      return (0);
    }
  }
}
}
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 172
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 175
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(lock);
  }
#line 175
  if (tmp != 0) {
#line 177
    return (0);
  } else {
#line 181
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 183
    return (1);
  }
}
}
#line 188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_lock(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ 


  {
#line 191
  cnt->counter = cnt->counter - 1;
#line 194
  if (cnt->counter != 0) {
#line 196
    return (0);
  } else {
    {
#line 199
    ldv_linux_kernel_locking_mutex_mutex_lock_lock(lock);
    }
#line 201
    return (1);
  }
}
}
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 209
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 211
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
  }
#line 212
  return;
}
}
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device  ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 219
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 221
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
  }
#line 222
  return;
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 228
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 230
  tmp = ldv_undef_int();
  }
#line 230
  if (tmp != 0) {
#line 232
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 234
    return (0);
  } else {
#line 238
    return (-4);
  }
}
}
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 246
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device) {
#line 248
    return (1);
  } else {
    {
#line 251
    tmp = ldv_undef_int();
    }
#line 251
    if (tmp != 0) {
#line 253
      return (1);
    } else {
#line 257
      return (0);
    }
  }
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 265
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 268
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(lock);
  }
#line 268
  if (tmp != 0) {
#line 270
    return (0);
  } else {
#line 274
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 276
    return (1);
  }
}
}
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt ,
                                                                             struct mutex *lock ) 
{ 


  {
#line 284
  cnt->counter = cnt->counter - 1;
#line 287
  if (cnt->counter != 0) {
#line 289
    return (0);
  } else {
    {
#line 292
    ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(lock);
    }
#line 294
    return (1);
  }
}
}
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 302
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 304
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
  }
#line 305
  return;
}
}
#line 307 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_initialize(void) 
{ 


  {
#line 310
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
#line 312
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
#line 314
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
#line 315
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_check_final_state(void) 
{ 


  {
  {
#line 321
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 323
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 325
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
  }
#line 326
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/spinlock.linux_kernel_locking_spinlock.bk.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue  =    1;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock__xmit_lock_of_netdev_queue(void) 
{ 


  {
  {
#line 28
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
#line 30
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
#line 32
  ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue = 2;
  }
#line 33
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock__xmit_lock_of_netdev_queue(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 2);
#line 41
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 2);
#line 43
  ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock__xmit_lock_of_netdev_queue(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 52
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
#line 54
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
#line 57
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 60
  if (is_spin_held_by_another_thread != 0) {
#line 62
    return (0);
  } else {
#line 66
    ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue = 2;
#line 68
    return (1);
  }
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait__xmit_lock_of_netdev_queue(void) 
{ 


  {
  {
#line 76
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
#line 78
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
  }
#line 79
  return;
}
}
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked__xmit_lock_of_netdev_queue(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 87
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 90
  if (ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1 && is_spin_held_by_another_thread == 0) {
#line 92
    return (0);
  } else {
#line 96
    return (1);
  }
}
}
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock__xmit_lock_of_netdev_queue(void) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked__xmit_lock_of_netdev_queue();
  }
#line 104
  return (tmp == 0);
}
}
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended__xmit_lock_of_netdev_queue(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 113
  is_spin_contended = ldv_undef_int();
  }
#line 116
  if (is_spin_contended != 0) {
#line 118
    return (0);
  } else {
#line 122
    return (1);
  }
}
}
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock__xmit_lock_of_netdev_queue(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 132
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
#line 134
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
#line 137
  atomic_value_after_dec = ldv_undef_int();
  }
#line 140
  if (atomic_value_after_dec == 0) {
#line 142
    ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue = 2;
#line 144
    return (1);
  } else {

  }
#line 148
  return (0);
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device  =    1;
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_addr_list_lock_of_net_device(void) 
{ 


  {
  {
#line 156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
#line 158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
#line 160
  ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device = 2;
  }
#line 161
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_addr_list_lock_of_net_device(void) 
{ 


  {
  {
#line 167
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 2);
#line 169
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 2);
#line 171
  ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device = 1;
  }
#line 172
  return;
}
}
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_addr_list_lock_of_net_device(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
#line 182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
#line 185
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 188
  if (is_spin_held_by_another_thread != 0) {
#line 190
    return (0);
  } else {
#line 194
    ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device = 2;
#line 196
    return (1);
  }
}
}
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_addr_list_lock_of_net_device(void) 
{ 


  {
  {
#line 204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
#line 206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
  }
#line 207
  return;
}
}
#line 210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_addr_list_lock_of_net_device(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 215
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 218
  if (ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1 && is_spin_held_by_another_thread == 0) {
#line 220
    return (0);
  } else {
#line 224
    return (1);
  }
}
}
#line 229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_addr_list_lock_of_net_device(void) 
{ 
  int tmp ;

  {
  {
#line 232
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_addr_list_lock_of_net_device();
  }
#line 232
  return (tmp == 0);
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_addr_list_lock_of_net_device(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 241
  is_spin_contended = ldv_undef_int();
  }
#line 244
  if (is_spin_contended != 0) {
#line 246
    return (0);
  } else {
#line 250
    return (1);
  }
}
}
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_addr_list_lock_of_net_device(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 260
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
#line 262
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
#line 265
  atomic_value_after_dec = ldv_undef_int();
  }
#line 268
  if (atomic_value_after_dec == 0) {
#line 270
    ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device = 2;
#line 272
    return (1);
  } else {

  }
#line 276
  return (0);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct  =    1;
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 288
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
  }
#line 289
  return;
}
}
#line 292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 295
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 297
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 299
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 1;
  }
#line 300
  return;
}
}
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 313
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 316
  if (is_spin_held_by_another_thread != 0) {
#line 318
    return (0);
  } else {
#line 322
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 324
    return (1);
  }
}
}
#line 329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
  }
#line 335
  return;
}
}
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 343
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 346
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 348
    return (0);
  } else {
#line 352
    return (1);
  }
}
}
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_alloc_lock_of_task_struct(void) 
{ 
  int tmp ;

  {
  {
#line 360
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct();
  }
#line 360
  return (tmp == 0);
}
}
#line 364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 369
  is_spin_contended = ldv_undef_int();
  }
#line 372
  if (is_spin_contended != 0) {
#line 374
    return (0);
  } else {
#line 378
    return (1);
  }
}
}
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_alloc_lock_of_task_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 388
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 390
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 393
  atomic_value_after_dec = ldv_undef_int();
  }
#line 396
  if (atomic_value_after_dec == 0) {
#line 398
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 400
    return (1);
  } else {

  }
#line 404
  return (0);
}
}
#line 406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba  =    1;
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_async_pdu_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
#line 414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
#line 416
  ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba = 2;
  }
#line 417
  return;
}
}
#line 420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_async_pdu_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 423
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 2);
#line 425
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 2);
#line 427
  ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba = 1;
  }
#line 428
  return;
}
}
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_async_pdu_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
#line 438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
#line 441
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 444
  if (is_spin_held_by_another_thread != 0) {
#line 446
    return (0);
  } else {
#line 450
    ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba = 2;
#line 452
    return (1);
  }
}
}
#line 457 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_async_pdu_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
#line 462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
  }
#line 463
  return;
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_async_pdu_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 471
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 474
  if (ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1 && is_spin_held_by_another_thread == 0) {
#line 476
    return (0);
  } else {
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_async_pdu_lock_of_beiscsi_hba(void) 
{ 
  int tmp ;

  {
  {
#line 488
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_async_pdu_lock_of_beiscsi_hba();
  }
#line 488
  return (tmp == 0);
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_async_pdu_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 497
  is_spin_contended = ldv_undef_int();
  }
#line 500
  if (is_spin_contended != 0) {
#line 502
    return (0);
  } else {
#line 506
    return (1);
  }
}
}
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_async_pdu_lock_of_beiscsi_hba(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 516
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
#line 518
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
#line 521
  atomic_value_after_dec = ldv_undef_int();
  }
#line 524
  if (atomic_value_after_dec == 0) {
#line 526
    ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba = 2;
#line 528
    return (1);
  } else {

  }
#line 532
  return (0);
}
}
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session  =    1;
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_back_lock_of_iscsi_session(void) 
{ 


  {
  {
#line 540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
#line 542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
#line 544
  ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session = 2;
  }
#line 545
  return;
}
}
#line 548 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_back_lock_of_iscsi_session(void) 
{ 


  {
  {
#line 551
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 2);
#line 553
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 2);
#line 555
  ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session = 1;
  }
#line 556
  return;
}
}
#line 559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_back_lock_of_iscsi_session(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
#line 566
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
#line 569
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 572
  if (is_spin_held_by_another_thread != 0) {
#line 574
    return (0);
  } else {
#line 578
    ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session = 2;
#line 580
    return (1);
  }
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_back_lock_of_iscsi_session(void) 
{ 


  {
  {
#line 588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
#line 590
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
  }
#line 591
  return;
}
}
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_back_lock_of_iscsi_session(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 599
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 602
  if (ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1 && is_spin_held_by_another_thread == 0) {
#line 604
    return (0);
  } else {
#line 608
    return (1);
  }
}
}
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_back_lock_of_iscsi_session(void) 
{ 
  int tmp ;

  {
  {
#line 616
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_back_lock_of_iscsi_session();
  }
#line 616
  return (tmp == 0);
}
}
#line 620 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_back_lock_of_iscsi_session(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 625
  is_spin_contended = ldv_undef_int();
  }
#line 628
  if (is_spin_contended != 0) {
#line 630
    return (0);
  } else {
#line 634
    return (1);
  }
}
}
#line 639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_back_lock_of_iscsi_session(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 644
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
#line 646
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
#line 649
  atomic_value_after_dec = ldv_undef_int();
  }
#line 652
  if (atomic_value_after_dec == 0) {
#line 654
    ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session = 2;
#line 656
    return (1);
  } else {

  }
#line 660
  return (0);
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session  =    1;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_frwd_lock_of_iscsi_session(void) 
{ 


  {
  {
#line 668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
#line 670
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
#line 672
  ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session = 2;
  }
#line 673
  return;
}
}
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_frwd_lock_of_iscsi_session(void) 
{ 


  {
  {
#line 679
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 2);
#line 681
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 2);
#line 683
  ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session = 1;
  }
#line 684
  return;
}
}
#line 687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_frwd_lock_of_iscsi_session(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
#line 694
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
#line 697
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 700
  if (is_spin_held_by_another_thread != 0) {
#line 702
    return (0);
  } else {
#line 706
    ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session = 2;
#line 708
    return (1);
  }
}
}
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_frwd_lock_of_iscsi_session(void) 
{ 


  {
  {
#line 716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
#line 718
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
  }
#line 719
  return;
}
}
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_frwd_lock_of_iscsi_session(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 727
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 730
  if (ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1 && is_spin_held_by_another_thread == 0) {
#line 732
    return (0);
  } else {
#line 736
    return (1);
  }
}
}
#line 741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_frwd_lock_of_iscsi_session(void) 
{ 
  int tmp ;

  {
  {
#line 744
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_frwd_lock_of_iscsi_session();
  }
#line 744
  return (tmp == 0);
}
}
#line 748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_frwd_lock_of_iscsi_session(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 753
  is_spin_contended = ldv_undef_int();
  }
#line 756
  if (is_spin_contended != 0) {
#line 758
    return (0);
  } else {
#line 762
    return (1);
  }
}
}
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_frwd_lock_of_iscsi_session(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 772
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
#line 774
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
#line 777
  atomic_value_after_dec = ldv_undef_int();
  }
#line 780
  if (atomic_value_after_dec == 0) {
#line 782
    ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session = 2;
#line 784
    return (1);
  } else {

  }
#line 788
  return (0);
}
}
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode  =    1;
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_i_lock_of_inode(void) 
{ 


  {
  {
#line 796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 798
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 800
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
  }
#line 801
  return;
}
}
#line 804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_i_lock_of_inode(void) 
{ 


  {
  {
#line 807
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 809
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 811
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 1;
  }
#line 812
  return;
}
}
#line 815 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 822
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 825
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 828
  if (is_spin_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 834
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 836
    return (1);
  }
}
}
#line 841 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_i_lock_of_inode(void) 
{ 


  {
  {
#line 844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 846
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
  }
#line 847
  return;
}
}
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 855
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 858
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1 && is_spin_held_by_another_thread == 0) {
#line 860
    return (0);
  } else {
#line 864
    return (1);
  }
}
}
#line 869 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_i_lock_of_inode(void) 
{ 
  int tmp ;

  {
  {
#line 872
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode();
  }
#line 872
  return (tmp == 0);
}
}
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_i_lock_of_inode(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 881
  is_spin_contended = ldv_undef_int();
  }
#line 884
  if (is_spin_contended != 0) {
#line 886
    return (0);
  } else {
#line 890
    return (1);
  }
}
}
#line 895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_i_lock_of_inode(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 900
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 902
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 905
  atomic_value_after_dec = ldv_undef_int();
  }
#line 908
  if (atomic_value_after_dec == 0) {
#line 910
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 912
    return (1);
  } else {

  }
#line 916
  return (0);
}
}
#line 918 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba  =    1;
#line 921 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_io_sgl_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
#line 926
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
#line 928
  ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba = 2;
  }
#line 929
  return;
}
}
#line 932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_io_sgl_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 935
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 2);
#line 937
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 2);
#line 939
  ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba = 1;
  }
#line 940
  return;
}
}
#line 943 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_io_sgl_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 948
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
#line 950
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
#line 953
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 956
  if (is_spin_held_by_another_thread != 0) {
#line 958
    return (0);
  } else {
#line 962
    ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba = 2;
#line 964
    return (1);
  }
}
}
#line 969 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_io_sgl_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 972
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
#line 974
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
  }
#line 975
  return;
}
}
#line 978 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_io_sgl_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 983
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 986
  if (ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1 && is_spin_held_by_another_thread == 0) {
#line 988
    return (0);
  } else {
#line 992
    return (1);
  }
}
}
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_io_sgl_lock_of_beiscsi_hba(void) 
{ 
  int tmp ;

  {
  {
#line 1000
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_io_sgl_lock_of_beiscsi_hba();
  }
#line 1000
  return (tmp == 0);
}
}
#line 1004 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_io_sgl_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1009
  is_spin_contended = ldv_undef_int();
  }
#line 1012
  if (is_spin_contended != 0) {
#line 1014
    return (0);
  } else {
#line 1018
    return (1);
  }
}
}
#line 1023 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_io_sgl_lock_of_beiscsi_hba(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1028
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
#line 1030
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
#line 1033
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1036
  if (atomic_value_after_dec == 0) {
#line 1038
    ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba = 2;
#line 1040
    return (1);
  } else {

  }
#line 1044
  return (0);
}
}
#line 1046 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba  =    1;
#line 1049 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_isr_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 1052
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
#line 1054
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
#line 1056
  ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba = 2;
  }
#line 1057
  return;
}
}
#line 1060 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_isr_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 1063
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 2);
#line 1065
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 2);
#line 1067
  ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba = 1;
  }
#line 1068
  return;
}
}
#line 1071 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_isr_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1076
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
#line 1078
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
#line 1081
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1084
  if (is_spin_held_by_another_thread != 0) {
#line 1086
    return (0);
  } else {
#line 1090
    ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba = 2;
#line 1092
    return (1);
  }
}
}
#line 1097 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_isr_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 1100
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
#line 1102
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
  }
#line 1103
  return;
}
}
#line 1106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_isr_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1111
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1114
  if (ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1 && is_spin_held_by_another_thread == 0) {
#line 1116
    return (0);
  } else {
#line 1120
    return (1);
  }
}
}
#line 1125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_isr_lock_of_beiscsi_hba(void) 
{ 
  int tmp ;

  {
  {
#line 1128
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_isr_lock_of_beiscsi_hba();
  }
#line 1128
  return (tmp == 0);
}
}
#line 1132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_isr_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1137
  is_spin_contended = ldv_undef_int();
  }
#line 1140
  if (is_spin_contended != 0) {
#line 1142
    return (0);
  } else {
#line 1146
    return (1);
  }
}
}
#line 1151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_isr_lock_of_beiscsi_hba(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
#line 1158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
#line 1161
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1164
  if (atomic_value_after_dec == 0) {
#line 1166
    ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba = 2;
#line 1168
    return (1);
  } else {

  }
#line 1172
  return (0);
}
}
#line 1174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock  =    1;
#line 1177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock(void) 
{ 


  {
  {
#line 1180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1184
  ldv_linux_kernel_locking_spinlock_spin_lock = 2;
  }
#line 1185
  return;
}
}
#line 1188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock(void) 
{ 


  {
  {
#line 1191
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 1193
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 1195
  ldv_linux_kernel_locking_spinlock_spin_lock = 1;
  }
#line 1196
  return;
}
}
#line 1199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1209
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1212
  if (is_spin_held_by_another_thread != 0) {
#line 1214
    return (0);
  } else {
#line 1218
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 1220
    return (1);
  }
}
}
#line 1225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock(void) 
{ 


  {
  {
#line 1228
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1230
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
  }
#line 1231
  return;
}
}
#line 1234 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1239
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1242
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 1 && is_spin_held_by_another_thread == 0) {
#line 1244
    return (0);
  } else {
#line 1248
    return (1);
  }
}
}
#line 1253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock(void) 
{ 
  int tmp ;

  {
  {
#line 1256
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock();
  }
#line 1256
  return (tmp == 0);
}
}
#line 1260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1265
  is_spin_contended = ldv_undef_int();
  }
#line 1268
  if (is_spin_contended != 0) {
#line 1270
    return (0);
  } else {
#line 1274
    return (1);
  }
}
}
#line 1279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1289
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1292
  if (atomic_value_after_dec == 0) {
#line 1294
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 1296
    return (1);
  } else {

  }
#line 1300
  return (0);
}
}
#line 1302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN  =    1;
#line 1305 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 1308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1312
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
  }
#line 1313
  return;
}
}
#line 1316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 1319
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 1321
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 1323
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 1;
  }
#line 1324
  return;
}
}
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1337
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1340
  if (is_spin_held_by_another_thread != 0) {
#line 1342
    return (0);
  } else {
#line 1346
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 1348
    return (1);
  }
}
}
#line 1353 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 1356
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1358
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
  }
#line 1359
  return;
}
}
#line 1362 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1367
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1370
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1 && is_spin_held_by_another_thread == 0) {
#line 1372
    return (0);
  } else {
#line 1376
    return (1);
  }
}
}
#line 1381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int tmp ;

  {
  {
#line 1384
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN();
  }
#line 1384
  return (tmp == 0);
}
}
#line 1388 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1393
  is_spin_contended = ldv_undef_int();
  }
#line 1396
  if (is_spin_contended != 0) {
#line 1398
    return (0);
  } else {
#line 1402
    return (1);
  }
}
}
#line 1407 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1417
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1420
  if (atomic_value_after_dec == 0) {
#line 1422
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 1424
    return (1);
  } else {

  }
#line 1428
  return (0);
}
}
#line 1430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info  =    1;
#line 1433 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_mbox_lock_of_be_ctrl_info(void) 
{ 


  {
  {
#line 1436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
#line 1438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
#line 1440
  ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info = 2;
  }
#line 1441
  return;
}
}
#line 1444 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_mbox_lock_of_be_ctrl_info(void) 
{ 


  {
  {
#line 1447
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 2);
#line 1449
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 2);
#line 1451
  ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info = 1;
  }
#line 1452
  return;
}
}
#line 1455 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_mbox_lock_of_be_ctrl_info(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
#line 1462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
#line 1465
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1468
  if (is_spin_held_by_another_thread != 0) {
#line 1470
    return (0);
  } else {
#line 1474
    ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info = 2;
#line 1476
    return (1);
  }
}
}
#line 1481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_mbox_lock_of_be_ctrl_info(void) 
{ 


  {
  {
#line 1484
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
#line 1486
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
  }
#line 1487
  return;
}
}
#line 1490 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_mbox_lock_of_be_ctrl_info(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1495
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1498
  if (ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1 && is_spin_held_by_another_thread == 0) {
#line 1500
    return (0);
  } else {
#line 1504
    return (1);
  }
}
}
#line 1509 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_mbox_lock_of_be_ctrl_info(void) 
{ 
  int tmp ;

  {
  {
#line 1512
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_mbox_lock_of_be_ctrl_info();
  }
#line 1512
  return (tmp == 0);
}
}
#line 1516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_mbox_lock_of_be_ctrl_info(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1521
  is_spin_contended = ldv_undef_int();
  }
#line 1524
  if (is_spin_contended != 0) {
#line 1526
    return (0);
  } else {
#line 1530
    return (1);
  }
}
}
#line 1535 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_mbox_lock_of_be_ctrl_info(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
#line 1542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
#line 1545
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1548
  if (atomic_value_after_dec == 0) {
#line 1550
    ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info = 2;
#line 1552
    return (1);
  } else {

  }
#line 1556
  return (0);
}
}
#line 1558 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info  =    1;
#line 1561 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_mcc_cq_lock_of_be_ctrl_info(void) 
{ 


  {
  {
#line 1564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
#line 1566
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
#line 1568
  ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info = 2;
  }
#line 1569
  return;
}
}
#line 1572 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_mcc_cq_lock_of_be_ctrl_info(void) 
{ 


  {
  {
#line 1575
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 2);
#line 1577
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 2);
#line 1579
  ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info = 1;
  }
#line 1580
  return;
}
}
#line 1583 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_mcc_cq_lock_of_be_ctrl_info(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
#line 1590
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
#line 1593
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1596
  if (is_spin_held_by_another_thread != 0) {
#line 1598
    return (0);
  } else {
#line 1602
    ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info = 2;
#line 1604
    return (1);
  }
}
}
#line 1609 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_mcc_cq_lock_of_be_ctrl_info(void) 
{ 


  {
  {
#line 1612
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
#line 1614
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
  }
#line 1615
  return;
}
}
#line 1618 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_mcc_cq_lock_of_be_ctrl_info(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1623
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1626
  if (ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1 && is_spin_held_by_another_thread == 0) {
#line 1628
    return (0);
  } else {
#line 1632
    return (1);
  }
}
}
#line 1637 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_mcc_cq_lock_of_be_ctrl_info(void) 
{ 
  int tmp ;

  {
  {
#line 1640
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_mcc_cq_lock_of_be_ctrl_info();
  }
#line 1640
  return (tmp == 0);
}
}
#line 1644 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_mcc_cq_lock_of_be_ctrl_info(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1649
  is_spin_contended = ldv_undef_int();
  }
#line 1652
  if (is_spin_contended != 0) {
#line 1654
    return (0);
  } else {
#line 1658
    return (1);
  }
}
}
#line 1663 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_mcc_cq_lock_of_be_ctrl_info(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
#line 1670
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
#line 1673
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1676
  if (atomic_value_after_dec == 0) {
#line 1678
    ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info = 2;
#line 1680
    return (1);
  } else {

  }
#line 1684
  return (0);
}
}
#line 1686 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba  =    1;
#line 1689 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_mgmt_sgl_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 1692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
#line 1694
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
#line 1696
  ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba = 2;
  }
#line 1697
  return;
}
}
#line 1700 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_mgmt_sgl_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 1703
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 2);
#line 1705
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 2);
#line 1707
  ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba = 1;
  }
#line 1708
  return;
}
}
#line 1711 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_mgmt_sgl_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
#line 1718
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
#line 1721
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1724
  if (is_spin_held_by_another_thread != 0) {
#line 1726
    return (0);
  } else {
#line 1730
    ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba = 2;
#line 1732
    return (1);
  }
}
}
#line 1737 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_mgmt_sgl_lock_of_beiscsi_hba(void) 
{ 


  {
  {
#line 1740
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
#line 1742
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
  }
#line 1743
  return;
}
}
#line 1746 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_mgmt_sgl_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1751
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1754
  if (ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1 && is_spin_held_by_another_thread == 0) {
#line 1756
    return (0);
  } else {
#line 1760
    return (1);
  }
}
}
#line 1765 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_mgmt_sgl_lock_of_beiscsi_hba(void) 
{ 
  int tmp ;

  {
  {
#line 1768
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_mgmt_sgl_lock_of_beiscsi_hba();
  }
#line 1768
  return (tmp == 0);
}
}
#line 1772 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_mgmt_sgl_lock_of_beiscsi_hba(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1777
  is_spin_contended = ldv_undef_int();
  }
#line 1780
  if (is_spin_contended != 0) {
#line 1782
    return (0);
  } else {
#line 1786
    return (1);
  }
}
}
#line 1791 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_mgmt_sgl_lock_of_beiscsi_hba(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
#line 1798
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
#line 1801
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1804
  if (atomic_value_after_dec == 0) {
#line 1806
    ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba = 2;
#line 1808
    return (1);
  } else {

  }
#line 1812
  return (0);
}
}
#line 1814 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data  =    1;
#line 1817 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1822
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1824
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
  }
#line 1825
  return;
}
}
#line 1828 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1831
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 1833
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 1835
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 1;
  }
#line 1836
  return;
}
}
#line 1839 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1846
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1849
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1852
  if (is_spin_held_by_another_thread != 0) {
#line 1854
    return (0);
  } else {
#line 1858
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 1860
    return (1);
  }
}
}
#line 1865 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1868
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1870
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
  }
#line 1871
  return;
}
}
#line 1874 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1879
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1882
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1 && is_spin_held_by_another_thread == 0) {
#line 1884
    return (0);
  } else {
#line 1888
    return (1);
  }
}
}
#line 1893 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_node_size_lock_of_pglist_data(void) 
{ 
  int tmp ;

  {
  {
#line 1896
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data();
  }
#line 1896
  return (tmp == 0);
}
}
#line 1900 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1905
  is_spin_contended = ldv_undef_int();
  }
#line 1908
  if (is_spin_contended != 0) {
#line 1910
    return (0);
  } else {
#line 1914
    return (1);
  }
}
}
#line 1919 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_node_size_lock_of_pglist_data(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1926
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1929
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1932
  if (atomic_value_after_dec == 0) {
#line 1934
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 1936
    return (1);
  } else {

  }
#line 1940
  return (0);
}
}
#line 1942 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_ptl  =    1;
#line 1945 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_ptl(void) 
{ 


  {
  {
#line 1948
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1950
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1952
  ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
  }
#line 1953
  return;
}
}
#line 1956 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_ptl(void) 
{ 


  {
  {
#line 1959
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 1961
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 1963
  ldv_linux_kernel_locking_spinlock_spin_ptl = 1;
  }
#line 1964
  return;
}
}
#line 1967 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1972
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1974
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1977
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1980
  if (is_spin_held_by_another_thread != 0) {
#line 1982
    return (0);
  } else {
#line 1986
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 1988
    return (1);
  }
}
}
#line 1993 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_ptl(void) 
{ 


  {
  {
#line 1996
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1998
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
  }
#line 1999
  return;
}
}
#line 2002 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 2007
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 2010
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 1 && is_spin_held_by_another_thread == 0) {
#line 2012
    return (0);
  } else {
#line 2016
    return (1);
  }
}
}
#line 2021 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_ptl(void) 
{ 
  int tmp ;

  {
  {
#line 2024
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl();
  }
#line 2024
  return (tmp == 0);
}
}
#line 2028 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_ptl(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 2033
  is_spin_contended = ldv_undef_int();
  }
#line 2036
  if (is_spin_contended != 0) {
#line 2038
    return (0);
  } else {
#line 2042
    return (1);
  }
}
}
#line 2047 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_ptl(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 2052
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 2054
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 2057
  atomic_value_after_dec = ldv_undef_int();
  }
#line 2060
  if (atomic_value_after_dec == 0) {
#line 2062
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 2064
    return (1);
  } else {

  }
#line 2068
  return (0);
}
}
#line 2070 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct  =    1;
#line 2073 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 2076
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 2078
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 2080
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
  }
#line 2081
  return;
}
}
#line 2084 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 2087
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 2089
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 2091
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 1;
  }
#line 2092
  return;
}
}
#line 2095 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 2100
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 2102
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 2105
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 2108
  if (is_spin_held_by_another_thread != 0) {
#line 2110
    return (0);
  } else {
#line 2114
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 2116
    return (1);
  }
}
}
#line 2121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 2124
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 2126
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
  }
#line 2127
  return;
}
}
#line 2130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 2135
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 2138
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 2140
    return (0);
  } else {
#line 2144
    return (1);
  }
}
}
#line 2149 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_siglock_of_sighand_struct(void) 
{ 
  int tmp ;

  {
  {
#line 2152
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct();
  }
#line 2152
  return (tmp == 0);
}
}
#line 2156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_siglock_of_sighand_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 2161
  is_spin_contended = ldv_undef_int();
  }
#line 2164
  if (is_spin_contended != 0) {
#line 2166
    return (0);
  } else {
#line 2170
    return (1);
  }
}
}
#line 2175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_siglock_of_sighand_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 2180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 2182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 2185
  atomic_value_after_dec = ldv_undef_int();
  }
#line 2188
  if (atomic_value_after_dec == 0) {
#line 2190
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 2192
    return (1);
  } else {

  }
#line 2196
  return (0);
}
}
#line 2198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device  =    1;
#line 2201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_tx_global_lock_of_net_device(void) 
{ 


  {
  {
#line 2204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
#line 2206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
#line 2208
  ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device = 2;
  }
#line 2209
  return;
}
}
#line 2212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_tx_global_lock_of_net_device(void) 
{ 


  {
  {
#line 2215
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 2);
#line 2217
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 2);
#line 2219
  ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device = 1;
  }
#line 2220
  return;
}
}
#line 2223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_tx_global_lock_of_net_device(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 2228
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
#line 2230
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
#line 2233
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 2236
  if (is_spin_held_by_another_thread != 0) {
#line 2238
    return (0);
  } else {
#line 2242
    ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device = 2;
#line 2244
    return (1);
  }
}
}
#line 2249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_tx_global_lock_of_net_device(void) 
{ 


  {
  {
#line 2252
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
#line 2254
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
  }
#line 2255
  return;
}
}
#line 2258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_tx_global_lock_of_net_device(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 2263
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 2266
  if (ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1 && is_spin_held_by_another_thread == 0) {
#line 2268
    return (0);
  } else {
#line 2272
    return (1);
  }
}
}
#line 2277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_tx_global_lock_of_net_device(void) 
{ 
  int tmp ;

  {
  {
#line 2280
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_tx_global_lock_of_net_device();
  }
#line 2280
  return (tmp == 0);
}
}
#line 2284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_tx_global_lock_of_net_device(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 2289
  is_spin_contended = ldv_undef_int();
  }
#line 2292
  if (is_spin_contended != 0) {
#line 2294
    return (0);
  } else {
#line 2298
    return (1);
  }
}
}
#line 2303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_tx_global_lock_of_net_device(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 2308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
#line 2310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
#line 2313
  atomic_value_after_dec = ldv_undef_int();
  }
#line 2316
  if (atomic_value_after_dec == 0) {
#line 2318
    ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device = 2;
#line 2320
    return (1);
  } else {

  }
#line 2324
  return (0);
}
}
#line 2327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_check_final_state(void) 
{ 


  {
  {
#line 2330
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 1);
#line 2332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 1);
#line 2334
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 2336
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 1);
#line 2338
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 1);
#line 2340
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 1);
#line 2342
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 2344
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 1);
#line 2346
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 1);
#line 2348
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 2350
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 2352
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 1);
#line 2354
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 1);
#line 2356
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 1);
#line 2358
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 2360
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 2362
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 2364
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 1);
  }
#line 2365
  return;
}
}
#line 2368 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_exclusive_spin_is_locked(void) 
{ 


  {
#line 2371
  if (ldv_linux_kernel_locking_spinlock_spin__xmit_lock_of_netdev_queue == 2) {
#line 2373
    return (1);
  } else {

  }
#line 2376
  if (ldv_linux_kernel_locking_spinlock_spin_addr_list_lock_of_net_device == 2) {
#line 2378
    return (1);
  } else {

  }
#line 2381
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2) {
#line 2383
    return (1);
  } else {

  }
#line 2386
  if (ldv_linux_kernel_locking_spinlock_spin_async_pdu_lock_of_beiscsi_hba == 2) {
#line 2388
    return (1);
  } else {

  }
#line 2391
  if (ldv_linux_kernel_locking_spinlock_spin_back_lock_of_iscsi_session == 2) {
#line 2393
    return (1);
  } else {

  }
#line 2396
  if (ldv_linux_kernel_locking_spinlock_spin_frwd_lock_of_iscsi_session == 2) {
#line 2398
    return (1);
  } else {

  }
#line 2401
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2) {
#line 2403
    return (1);
  } else {

  }
#line 2406
  if (ldv_linux_kernel_locking_spinlock_spin_io_sgl_lock_of_beiscsi_hba == 2) {
#line 2408
    return (1);
  } else {

  }
#line 2411
  if (ldv_linux_kernel_locking_spinlock_spin_isr_lock_of_beiscsi_hba == 2) {
#line 2413
    return (1);
  } else {

  }
#line 2416
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 2) {
#line 2418
    return (1);
  } else {

  }
#line 2421
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2) {
#line 2423
    return (1);
  } else {

  }
#line 2426
  if (ldv_linux_kernel_locking_spinlock_spin_mbox_lock_of_be_ctrl_info == 2) {
#line 2428
    return (1);
  } else {

  }
#line 2431
  if (ldv_linux_kernel_locking_spinlock_spin_mcc_cq_lock_of_be_ctrl_info == 2) {
#line 2433
    return (1);
  } else {

  }
#line 2436
  if (ldv_linux_kernel_locking_spinlock_spin_mgmt_sgl_lock_of_beiscsi_hba == 2) {
#line 2438
    return (1);
  } else {

  }
#line 2441
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2) {
#line 2443
    return (1);
  } else {

  }
#line 2446
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 2) {
#line 2448
    return (1);
  } else {

  }
#line 2451
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2) {
#line 2453
    return (1);
  } else {

  }
#line 2456
  if (ldv_linux_kernel_locking_spinlock_spin_tx_global_lock_of_net_device == 2) {
#line 2458
    return (1);
  } else {

  }
#line 2461
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/completion.linux_kernel_sched_completion.bk.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) ;
#line 2
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/sched/completion.c"
static int ldv_linux_kernel_sched_completion_completion  =    0;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion(void) 
{ 


  {
#line 33
  ldv_linux_kernel_sched_completion_completion = 1;
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_macro(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_sched_completion__double_init(ldv_linux_kernel_sched_completion_completion != 0);
#line 42
  ldv_linux_kernel_sched_completion_completion = 1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_wait_for_completion(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_sched_completion__wait_without_init(ldv_linux_kernel_sched_completion_completion != 0);
#line 51
  ldv_linux_kernel_sched_completion_completion = 2;
  }
#line 52
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/rsg/models/idr.linux_lib_idr.bk.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) ;
#line 2
void ldv_assert_linux_lib_idr__double_init(int expr ) ;
#line 3
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_lib_idr__not_initialized(int expr ) ;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/lib/idr.c"
static int ldv_linux_lib_idr_idr  =    0;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_init(void) 
{ 


  {
  {
#line 35
  ldv_assert_linux_lib_idr__double_init(ldv_linux_lib_idr_idr == 0);
#line 37
  ldv_linux_lib_idr_idr = 1;
  }
#line 38
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_alloc(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 46
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 48
  ldv_linux_lib_idr_idr = 2;
  }
#line 49
  return;
}
}
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_find(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 57
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 59
  ldv_linux_lib_idr_idr = 2;
  }
#line 60
  return;
}
}
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_remove(void) 
{ 


  {
  {
#line 66
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 68
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 70
  ldv_linux_lib_idr_idr = 2;
  }
#line 71
  return;
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_destroy(void) 
{ 


  {
  {
#line 77
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 79
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 81
  ldv_linux_lib_idr_idr = 3;
  }
#line 82
  return;
}
}
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_check_final_state(void) 
{ 


  {
  {
#line 88
  ldv_assert_linux_lib_idr__more_at_exit(ldv_linux_lib_idr_idr == 0 || ldv_linux_lib_idr_idr == 3);
  }
#line 89
  return;
}
}
#line 2 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
extern void __VERIFIER_error_linux_net_rtnetlink(void) ;
#line 3 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 6
  return;
}
}
#line 7 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) 
{ 


  {
#line 8
  if (! expr) {
    {
#line 9
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 10
  return;
}
}
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) 
{ 


  {
#line 12
  if (! expr) {
    {
#line 13
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 14
  return;
}
}
#line 15
extern void __VERIFIER_error_linux_kernel_locking_rwlock(void) ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) 
{ 


  {
#line 17
  if (! expr) {
    {
#line 18
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 19
  return;
}
}
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) 
{ 


  {
#line 21
  if (! expr) {
    {
#line 22
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 23
  return;
}
}
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) 
{ 


  {
#line 25
  if (! expr) {
    {
#line 26
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 27
  return;
}
}
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) 
{ 


  {
#line 29
  if (! expr) {
    {
#line 30
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 31
  return;
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) 
{ 


  {
#line 33
  if (! expr) {
    {
#line 34
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 35
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) 
{ 


  {
#line 37
  if (! expr) {
    {
#line 38
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 39
  return;
}
}
#line 40
extern void __VERIFIER_error_linux_lib_idr(void) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__double_init(int expr ) 
{ 


  {
#line 42
  if (! expr) {
    {
#line 43
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 44
  return;
}
}
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__not_initialized(int expr ) 
{ 


  {
#line 46
  if (! expr) {
    {
#line 47
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 48
  return;
}
}
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) 
{ 


  {
#line 50
  if (! expr) {
    {
#line 51
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 52
  return;
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) 
{ 


  {
#line 54
  if (! expr) {
    {
#line 55
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 56
  return;
}
}
#line 57
extern void __VERIFIER_error_linux_kernel_sched_completion(void) ;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) 
{ 


  {
#line 59
  if (! expr) {
    {
#line 60
    __VERIFIER_error_linux_kernel_sched_completion();
    }
  } else {

  }
#line 61
  return;
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) 
{ 


  {
#line 63
  if (! expr) {
    {
#line 64
    __VERIFIER_error_linux_kernel_sched_completion();
    }
  } else {

  }
#line 65
  return;
}
}
#line 66
extern void __VERIFIER_error_linux_net_register(void) ;
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) 
{ 


  {
#line 68
  if (! expr) {
    {
#line 69
    __VERIFIER_error_linux_net_register();
    }
  } else {

  }
#line 70
  return;
}
}
#line 71
extern void __VERIFIER_error_linux_fs_char_dev(void) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) 
{ 


  {
#line 73
  if (! expr) {
    {
#line 74
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 75
  return;
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) 
{ 


  {
#line 77
  if (! expr) {
    {
#line 78
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 79
  return;
}
}
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) 
{ 


  {
#line 81
  if (! expr) {
    {
#line 82
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 83
  return;
}
}
#line 84
extern void __VERIFIER_error_linux_kernel_rcu_srcu(void) ;
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) 
{ 


  {
#line 86
  if (! expr) {
    {
#line 87
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 88
  return;
}
}
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) 
{ 


  {
#line 90
  if (! expr) {
    {
#line 91
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 92
  return;
}
}
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) 
{ 


  {
#line 94
  if (! expr) {
    {
#line 95
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 96
  return;
}
}
#line 97
extern void __VERIFIER_error_linux_kernel_module(void) ;
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) 
{ 


  {
#line 99
  if (! expr) {
    {
#line 100
    __VERIFIER_error_linux_kernel_module();
    }
  } else {

  }
#line 101
  return;
}
}
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) 
{ 


  {
#line 103
  if (! expr) {
    {
#line 104
    __VERIFIER_error_linux_kernel_module();
    }
  } else {

  }
#line 105
  return;
}
}
#line 106
extern void __VERIFIER_error_linux_alloc_spinlock(void) ;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) 
{ 


  {
#line 108
  if (! expr) {
    {
#line 109
    __VERIFIER_error_linux_alloc_spinlock();
    }
  } else {

  }
#line 110
  return;
}
}
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) 
{ 


  {
#line 112
  if (! expr) {
    {
#line 113
    __VERIFIER_error_linux_alloc_spinlock();
    }
  } else {

  }
#line 114
  return;
}
}
#line 115
extern void __VERIFIER_error_linux_lib_find_bit(void) ;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) 
{ 


  {
#line 117
  if (! expr) {
    {
#line 118
    __VERIFIER_error_linux_lib_find_bit();
    }
  } else {

  }
#line 119
  return;
}
}
#line 120
extern void __VERIFIER_error_linux_mmc_sdio_func(void) ;
#line 121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) 
{ 


  {
#line 122
  if (! expr) {
    {
#line 123
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 124
  return;
}
}
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) 
{ 


  {
#line 126
  if (! expr) {
    {
#line 127
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 128
  return;
}
}
#line 129 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) 
{ 


  {
#line 130
  if (! expr) {
    {
#line 131
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 132
  return;
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) 
{ 


  {
#line 134
  if (! expr) {
    {
#line 135
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 136
  return;
}
}
#line 137
extern void __VERIFIER_error_linux_usb_coherent(void) ;
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) 
{ 


  {
#line 139
  if (! expr) {
    {
#line 140
    __VERIFIER_error_linux_usb_coherent();
    }
  } else {

  }
#line 141
  return;
}
}
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) 
{ 


  {
#line 143
  if (! expr) {
    {
#line 144
    __VERIFIER_error_linux_usb_coherent();
    }
  } else {

  }
#line 145
  return;
}
}
#line 146
extern void __VERIFIER_error_linux_kernel_rcu_update_lock(void) ;
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) 
{ 


  {
#line 148
  if (! expr) {
    {
#line 149
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 150
  return;
}
}
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) 
{ 


  {
#line 152
  if (! expr) {
    {
#line 153
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 154
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) 
{ 


  {
#line 156
  if (! expr) {
    {
#line 157
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 158
  return;
}
}
#line 159
extern void __VERIFIER_error_linux_net_sock(void) ;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) 
{ 


  {
#line 161
  if (! expr) {
    {
#line 162
    __VERIFIER_error_linux_net_sock();
    }
  } else {

  }
#line 163
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__double_release(int expr ) 
{ 


  {
#line 165
  if (! expr) {
    {
#line 166
    __VERIFIER_error_linux_net_sock();
    }
  } else {

  }
#line 167
  return;
}
}
#line 168
extern void __VERIFIER_error_linux_kernel_rcu_update_lock_bh(void) ;
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) 
{ 


  {
#line 170
  if (! expr) {
    {
#line 171
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 172
  return;
}
}
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) 
{ 


  {
#line 174
  if (! expr) {
    {
#line 175
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 176
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) 
{ 


  {
#line 178
  if (! expr) {
    {
#line 179
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 180
  return;
}
}
#line 181
extern void __VERIFIER_error_linux_usb_dev(void) ;
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) 
{ 


  {
#line 183
  if (! expr) {
    {
#line 184
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 185
  return;
}
}
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) 
{ 


  {
#line 187
  if (! expr) {
    {
#line 188
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 189
  return;
}
}
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) 
{ 


  {
#line 191
  if (! expr) {
    {
#line 192
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 193
  return;
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__probe_failed(int expr ) 
{ 


  {
#line 195
  if (! expr) {
    {
#line 196
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 197
  return;
}
}
#line 198
extern void __VERIFIER_error_linux_kernel_locking_mutex(void) ;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) 
{ 


  {
#line 200
  if (! expr) {
    {
#line 201
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 202
  return;
}
}
#line 203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 204
  if (! expr) {
    {
#line 205
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 206
  return;
}
}
#line 207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) 
{ 


  {
#line 208
  if (! expr) {
    {
#line 209
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 210
  return;
}
}
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 212
  if (! expr) {
    {
#line 213
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 214
  return;
}
}
#line 215
extern void __VERIFIER_error_linux_usb_gadget(void) ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 217
  if (! expr) {
    {
#line 218
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 219
  return;
}
}
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 221
  if (! expr) {
    {
#line 222
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 223
  return;
}
}
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 225
  if (! expr) {
    {
#line 226
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 227
  return;
}
}
#line 228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 229
  if (! expr) {
    {
#line 230
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 231
  return;
}
}
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) 
{ 


  {
#line 233
  if (! expr) {
    {
#line 234
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 235
  return;
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) 
{ 


  {
#line 237
  if (! expr) {
    {
#line 238
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 239
  return;
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) 
{ 


  {
#line 241
  if (! expr) {
    {
#line 242
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 243
  return;
}
}
#line 244
extern void __VERIFIER_error_linux_alloc_usb_lock(void) ;
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) 
{ 


  {
#line 246
  if (! expr) {
    {
#line 247
    __VERIFIER_error_linux_alloc_usb_lock();
    }
  } else {

  }
#line 248
  return;
}
}
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) 
{ 


  {
#line 250
  if (! expr) {
    {
#line 251
    __VERIFIER_error_linux_alloc_usb_lock();
    }
  } else {

  }
#line 252
  return;
}
}
#line 253
extern void __VERIFIER_error_linux_block_request(void) ;
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_get(int expr ) 
{ 


  {
#line 255
  if (! expr) {
    {
#line 256
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 257
  return;
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_put(int expr ) 
{ 


  {
#line 259
  if (! expr) {
    {
#line 260
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 261
  return;
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__get_at_exit(int expr ) 
{ 


  {
#line 263
  if (! expr) {
    {
#line 264
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 265
  return;
}
}
#line 266
extern void __VERIFIER_error_linux_alloc_irq(void) ;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) 
{ 


  {
#line 268
  if (! expr) {
    {
#line 269
    __VERIFIER_error_linux_alloc_irq();
    }
  } else {

  }
#line 270
  return;
}
}
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) 
{ 


  {
#line 272
  if (! expr) {
    {
#line 273
    __VERIFIER_error_linux_alloc_irq();
    }
  } else {

  }
#line 274
  return;
}
}
#line 275
extern void __VERIFIER_error_linux_drivers_base_class(void) ;
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) 
{ 


  {
#line 277
  if (! expr) {
    {
#line 278
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 279
  return;
}
}
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) 
{ 


  {
#line 281
  if (! expr) {
    {
#line 282
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 283
  return;
}
}
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) 
{ 


  {
#line 285
  if (! expr) {
    {
#line 286
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 287
  return;
}
}
#line 288
extern void __VERIFIER_error_linux_block_queue(void) ;
#line 289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) 
{ 


  {
#line 290
  if (! expr) {
    {
#line 291
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 292
  return;
}
}
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) 
{ 


  {
#line 294
  if (! expr) {
    {
#line 295
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 296
  return;
}
}
#line 297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) 
{ 


  {
#line 298
  if (! expr) {
    {
#line 299
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 300
  return;
}
}
#line 301
extern void __VERIFIER_error_linux_block_genhd(void) ;
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__double_allocation(int expr ) 
{ 


  {
#line 303
  if (! expr) {
    {
#line 304
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) 
{ 


  {
#line 307
  if (! expr) {
    {
#line 308
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 309
  return;
}
}
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) 
{ 


  {
#line 311
  if (! expr) {
    {
#line 312
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 313
  return;
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) 
{ 


  {
#line 315
  if (! expr) {
    {
#line 316
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 317
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) 
{ 


  {
#line 319
  if (! expr) {
    {
#line 320
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 321
  return;
}
}
#line 322
extern void __VERIFIER_error_linux_arch_io(void) ;
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) 
{ 


  {
#line 324
  if (! expr) {
    {
#line 325
    __VERIFIER_error_linux_arch_io();
    }
  } else {

  }
#line 326
  return;
}
}
#line 327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) 
{ 


  {
#line 328
  if (! expr) {
    {
#line 329
    __VERIFIER_error_linux_arch_io();
    }
  } else {

  }
#line 330
  return;
}
}
#line 331
extern void __VERIFIER_error_linux_usb_register(void) ;
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) 
{ 


  {
#line 333
  if (! expr) {
    {
#line 334
    __VERIFIER_error_linux_usb_register();
    }
  } else {

  }
#line 335
  return;
}
}
#line 336
extern void __VERIFIER_error_linux_fs_sysfs(void) ;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) 
{ 


  {
#line 338
  if (! expr) {
    {
#line 339
    __VERIFIER_error_linux_fs_sysfs();
    }
  } else {

  }
#line 340
  return;
}
}
#line 341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) 
{ 


  {
#line 342
  if (! expr) {
    {
#line 343
    __VERIFIER_error_linux_fs_sysfs();
    }
  } else {

  }
#line 344
  return;
}
}
#line 345
extern void __VERIFIER_error_linux_kernel_locking_spinlock(void) ;
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) 
{ 


  {
#line 347
  if (! expr) {
    {
#line 348
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 349
  return;
}
}
#line 350 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 351
  if (! expr) {
    {
#line 352
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 353
  return;
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) 
{ 


  {
#line 355
  if (! expr) {
    {
#line 356
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 357
  return;
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 359
  if (! expr) {
    {
#line 360
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 361
  return;
}
}
#line 362
extern void __VERIFIER_error_linux_usb_urb(void) ;
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) 
{ 


  {
#line 364
  if (! expr) {
    {
#line 365
    __VERIFIER_error_linux_usb_urb();
    }
  } else {

  }
#line 366
  return;
}
}
#line 367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) 
{ 


  {
#line 368
  if (! expr) {
    {
#line 369
    __VERIFIER_error_linux_usb_urb();
    }
  } else {

  }
#line 370
  return;
}
}
#line 371
extern void __VERIFIER_error_linux_kernel_rcu_update_lock_sched(void) ;
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) 
{ 


  {
#line 373
  if (! expr) {
    {
#line 374
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 375
  return;
}
}
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) 
{ 


  {
#line 377
  if (! expr) {
    {
#line 378
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 379
  return;
}
}
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/scsi/be2iscsi/be2iscsi.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) 
{ 


  {
#line 381
  if (! expr) {
    {
#line 382
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 383
  return;
}
}
