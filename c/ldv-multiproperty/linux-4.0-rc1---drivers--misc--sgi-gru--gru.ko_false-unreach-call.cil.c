/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 186
struct hlist_node;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct class;
#line 199
struct device;
#line 245
struct completion;
#line 277
struct gendisk;
#line 338
struct module;
#line 346
struct mutex;
#line 400
struct request_queue;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 15
struct task_struct;
#line 16
struct lockdep_map;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_11 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_9 {
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
   struct __anonstruct____missing_field_name_11 __annonCompField6 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_9 __annonCompField7 ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_12 {
   pteval_t pte ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_12 pte_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_13 pgd_t;
#line 361
struct page;
#line 361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 369
struct file;
#line 382
struct seq_file;
#line 420
struct thread_struct;
#line 422
struct mm_struct;
#line 423
struct cpumask;
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
struct file_operations;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_16 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_16 __annonCompField8 ;
};
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_21 {
   u64 rip ;
   u64 rdp ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_22 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_20 {
   struct __anonstruct____missing_field_name_21 __annonCompField12 ;
   struct __anonstruct____missing_field_name_22 __annonCompField13 ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_23 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_20 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_23 __annonCompField15 ;
};
#line 345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndreg {
   u64 lower_bound ;
   u64 upper_bound ;
};
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndcsr {
   u64 bndcfgu ;
   u64 bndstatus ;
};
#line 386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndreg bndreg[4U] ;
   struct bndcsr bndcsr ;
};
#line 401 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_27 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_26 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_27 __annonCompField17 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_26 __annonCompField18 ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_28 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_28 rwlock_t;
#line 51 "/home/ubuntu/klever-work/linux/ldv/irq.h"
struct ldv_thread;
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 197
struct timespec;
#line 198
struct compat_timespec;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_futex_30 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_nanosleep_31 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 199
struct pollfd;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_poll_32 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
union __anonunion____missing_field_name_29 {
   struct __anonstruct_futex_30 futex ;
   struct __anonstruct_nanosleep_31 nanosleep ;
   struct __anonstruct_poll_32 poll ;
};
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_29 __annonCompField19 ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jump_label.h"
struct jump_entry;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
union __anonunion____missing_field_name_46 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_46 __annonCompField20 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct dentry;
#line 88
struct iattr;
#line 89
struct vm_area_struct;
#line 90
struct super_block;
#line 91
struct file_system_type;
#line 92
struct kernfs_open_node;
#line 93
struct kernfs_iattrs;
#line 115
struct kernfs_root;
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 88
struct kernfs_ops;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
union __anonunion____missing_field_name_47 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_47 __annonCompField21 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170
struct vm_operations_struct;
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 469
struct sock;
#line 470
struct kobject;
#line 471
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 135 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/highuid.h"
struct user_namespace;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kuid_t_48 {
   uid_t val ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_48 kuid_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kgid_t_49 {
   gid_t val ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_49 kgid_t;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct bin_attribute;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct tvec_base;
#line 268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kdev_t.h"
struct inode;
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kdev_t.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_51 {
   spinlock_t lock ;
   int count ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
union __anonunion____missing_field_name_50 {
   struct __anonstruct____missing_field_name_51 __annonCompField22 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_50 __annonCompField23 ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct path;
#line 51
struct vfsmount;
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct __anonstruct____missing_field_name_53 {
   u32 hash ;
   u32 len ;
};
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
union __anonunion____missing_field_name_52 {
   struct __anonstruct____missing_field_name_53 __annonCompField24 ;
   u64 hash_len ;
};
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_52 __annonCompField25 ;
   unsigned char const   *name ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
union __anonunion_d_u_54 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_54 d_u ;
};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 555 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_55 {
   unsigned long bits[16U] ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_55 nodemask_t;
#line 357
enum node_states {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_NORMAL_MEMORY = 2,
    N_HIGH_MEMORY = 2,
    N_MEMORY = 3,
    N_CPU = 4,
    NR_NODE_STATES = 5
} ;
#line 520
struct mem_cgroup;
#line 520 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 189
struct llist_node;
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_57 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
union __anonunion____missing_field_name_56 {
   struct __anonstruct____missing_field_name_57 __annonCompField26 ;
   struct callback_head callback_head ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_56 __annonCompField27 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 428
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 435
struct pid_namespace;
#line 435 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174
struct rw_semaphore;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 540
struct dev_pm_qos;
#line 540 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_123 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_123 mm_context_t;
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io_apic.h"
struct device_node;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 32
struct cgroup_subsys_state;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fs.h"
struct backing_dev_info;
#line 61
struct export_operations;
#line 63
struct iovec;
#line 64
struct nameidata;
#line 65
struct kiocb;
#line 66
struct pipe_inode_info;
#line 67
struct poll_table_struct;
#line 68
struct kstatfs;
#line 69
struct cred;
#line 70
struct swap_info_struct;
#line 71
struct iov_iter;
#line 72
struct vm_fault;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct free_area {
   struct list_head free_list[6U] ;
   unsigned long nr_free ;
};
#line 96
struct pglist_data;
#line 97 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct zone_padding {
   char x[0U] ;
};
#line 202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct zone_reclaim_stat {
   unsigned long recent_rotated[2U] ;
   unsigned long recent_scanned[2U] ;
};
#line 215
struct zone;
#line 215 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct lruvec {
   struct list_head lists[5U] ;
   struct zone_reclaim_stat reclaim_stat ;
   struct zone *zone ;
};
#line 247 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct per_cpu_pages {
   int count ;
   int high ;
   int batch ;
   struct list_head lists[3U] ;
};
#line 260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct per_cpu_pageset {
   struct per_cpu_pages pcp ;
   s8 expire ;
   s8 stat_threshold ;
   s8 vm_stat_diff[39U] ;
};
#line 270
enum zone_type {
    ZONE_DMA = 0,
    ZONE_DMA32 = 1,
    ZONE_NORMAL = 2,
    ZONE_MOVABLE = 3,
    __MAX_NR_ZONES = 4
} ;
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct zone {
   unsigned long watermark[3U] ;
   long lowmem_reserve[4U] ;
   int node ;
   unsigned int inactive_ratio ;
   struct pglist_data *zone_pgdat ;
   struct per_cpu_pageset *pageset ;
   unsigned long dirty_balance_reserve ;
   unsigned long min_unmapped_pages ;
   unsigned long min_slab_pages ;
   unsigned long zone_start_pfn ;
   unsigned long managed_pages ;
   unsigned long spanned_pages ;
   unsigned long present_pages ;
   char const   *name ;
   int nr_migrate_reserve_block ;
   unsigned long nr_isolate_pageblock ;
   seqlock_t span_seqlock ;
   wait_queue_head_t *wait_table ;
   unsigned long wait_table_hash_nr_entries ;
   unsigned long wait_table_bits ;
   struct zone_padding _pad1_ ;
   spinlock_t lock ;
   struct free_area free_area[11U] ;
   unsigned long flags ;
   struct zone_padding _pad2_ ;
   spinlock_t lru_lock ;
   struct lruvec lruvec ;
   atomic_long_t inactive_age ;
   unsigned long percpu_drift_mark ;
   unsigned long compact_cached_free_pfn ;
   unsigned long compact_cached_migrate_pfn[2U] ;
   unsigned int compact_considered ;
   unsigned int compact_defer_shift ;
   int compact_order_failed ;
   bool compact_blockskip_flush ;
   struct zone_padding _pad3_ ;
   atomic_long_t vm_stat[39U] ;
};
#line 568 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct zonelist_cache {
   unsigned short z_to_n[4096U] ;
   unsigned long fullzones[64U] ;
   unsigned long last_full_zap ;
};
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct zoneref {
   struct zone *zone ;
   int zone_idx ;
};
#line 668 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct zonelist {
   struct zonelist_cache *zlcache_ptr ;
   struct zoneref _zonerefs[4097U] ;
   struct zonelist_cache zlcache ;
};
#line 706 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct pglist_data {
   struct zone node_zones[4U] ;
   struct zonelist node_zonelists[2U] ;
   int nr_zones ;
   spinlock_t node_size_lock ;
   unsigned long node_start_pfn ;
   unsigned long node_present_pages ;
   unsigned long node_spanned_pages ;
   int node_id ;
   wait_queue_head_t kswapd_wait ;
   wait_queue_head_t pfmemalloc_wait ;
   struct task_struct *kswapd ;
   int kswapd_max_order ;
   enum zone_type classzone_idx ;
   spinlock_t numabalancing_migrate_lock ;
   unsigned long numabalancing_migrate_next_window ;
   unsigned long numabalancing_migrate_nr_pages ;
};
#line 766 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
typedef struct pglist_data pg_data_t;
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
struct __anonstruct_kprojid_t_151 {
   projid_t val ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_151 kprojid_t;
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 164
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
union __anonunion____missing_field_name_152 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_152 __annonCompField39 ;
   enum quota_type type ;
};
#line 183 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 205
struct quota_format_type;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 384 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 460
struct address_space;
#line 461
struct writeback_control;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 414
struct hd_struct;
#line 414 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 531
struct posix_acl;
#line 532
struct inode_operations;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_155 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_156 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 532
struct file_lock_context;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_157 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_155 __annonCompField40 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_156 __annonCompField41 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_157 __annonCompField42 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 776 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion_f_u_158 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_158 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
typedef void *fl_owner_t;
#line 884
struct file_lock;
#line 885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 891 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_get_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_put_owner)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 912
struct nlm_lockowner;
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_160 {
   struct list_head link ;
   int state ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_159 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_160 afs ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_159 fl_u ;
};
#line 965 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1021 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1223
struct super_operations;
#line 1223
struct xattr_handler;
#line 1223
struct mtd_info;
#line 1223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1475
struct dir_context;
#line 1500 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   void (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
   int (*dentry_open)(struct dentry * , struct file * , struct cred  const  * ) ;
};
#line 1624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1856 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_166 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_167 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_165 {
   struct __anonstruct____missing_field_name_166 __annonCompField45 ;
   struct __anonstruct____missing_field_name_167 __annonCompField46 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_165 __annonCompField47 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct xol_area;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_168 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_170 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_174 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_173 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_174 __annonCompField50 ;
   int units ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_172 {
   union __anonunion____missing_field_name_173 __annonCompField51 ;
   atomic_t _count ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_171 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_172 __annonCompField52 ;
   unsigned int active ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_169 {
   union __anonunion____missing_field_name_170 __annonCompField49 ;
   union __anonunion____missing_field_name_171 __annonCompField53 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_176 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_177 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_175 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_176 __annonCompField55 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_177 __annonCompField56 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_178 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_168 __annonCompField48 ;
   struct __anonstruct____missing_field_name_169 __annonCompField54 ;
   union __anonunion____missing_field_name_175 __annonCompField57 ;
   union __anonunion____missing_field_name_178 __annonCompField58 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct_shared_179 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 248
struct anon_vma;
#line 248
struct mempolicy;
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_179 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 335 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 348
struct kioctx_table;
#line 349
struct linux_binfmt;
#line 349
struct mmu_notifier_mm;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/page_ext.h"
struct user_struct;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqhandler.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_191 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_191 __annonCompField64 ;
};
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212
struct module_sect_attrs;
#line 212
struct module_notes_attrs;
#line 212
struct tracepoint;
#line 212
struct ftrace_event_call;
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 4 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_192 {
   unsigned long sig[1U] ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_192 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_194 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_195 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_196 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_197 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_199 {
   void *_lower ;
   void *_upper ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_198 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_199 _addr_bnd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_200 {
   long _band ;
   int _fd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_201 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_193 {
   int _pad[28U] ;
   struct __anonstruct__kill_194 _kill ;
   struct __anonstruct__timer_195 _timer ;
   struct __anonstruct__rt_196 _rt ;
   struct __anonstruct__sigchld_197 _sigchld ;
   struct __anonstruct__sigfault_198 _sigfault ;
   struct __anonstruct__sigpoll_200 _sigpoll ;
   struct __anonstruct__sigsys_201 _sigsys ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_193 _sifields ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rtmutex.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int in_hrtirq ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/latencytop.h"
struct assoc_array_ptr;
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/latencytop.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_204 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_205 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct __anonstruct____missing_field_name_207 {
   struct key_type *type ;
   char *description ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_206 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_207 __annonCompField67 ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_type_data_208 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_payload_210 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_209 {
   union __anonunion_payload_210 payload ;
   struct assoc_array keys ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_204 __annonCompField65 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_205 __annonCompField66 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_206 __annonCompField68 ;
   union __anonunion_type_data_208 type_data ;
   union __anonunion____missing_field_name_209 __annonCompField69 ;
};
#line 358
struct audit_context;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct futex_pi_state;
#line 128
struct robust_list_head;
#line 129
struct bio_list;
#line 130
struct fs_struct;
#line 131
struct perf_event_context;
#line 132
struct blk_plug;
#line 182
struct cfs_rq;
#line 183
struct task_group;
#line 471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 518 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 525 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 599
struct autogroup;
#line 600
struct tty_struct;
#line 600
struct taskstats;
#line 600
struct tty_audit_buf;
#line 600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 781 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 824
struct reclaim_state;
#line 825 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1195
struct rt_rq;
#line 1195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1702
struct sched_class;
#line 1702
struct files_struct;
#line 1702
struct css_set;
#line 1702
struct compat_robust_list_head;
#line 1702
struct numa_group;
#line 1702
struct ftrace_ret_stack;
#line 1702 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
};
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
struct klist_node;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 186
struct pinctrl;
#line 187
struct pinctrl_state;
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct iommu_ops;
#line 20
struct iommu_group;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 196
struct of_device_id;
#line 196
struct acpi_device_id;
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 322
struct class_attribute;
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 483 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 652
struct acpi_device;
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 659
struct dma_coherent_mem;
#line 659
struct cma;
#line 659 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 806 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 1239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations  const  *fops ;
   struct list_head list ;
   struct device *parent ;
   struct device *this_device ;
   char const   *nodename ;
   umode_t mode ;
};
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru.h"
struct gru_gseg_statistics {
   unsigned long fmm_tlbmiss ;
   unsigned long upm_tlbmiss ;
   unsigned long tlbdropin ;
   unsigned long context_stolen ;
   unsigned long reserved[10U] ;
};
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grulib.h"
struct gru_create_context_req {
   unsigned long gseg ;
   unsigned int data_segment_bytes ;
   unsigned int control_blocks ;
   unsigned int maximum_thread_count ;
   unsigned int options ;
   unsigned char tlb_preload_count ;
};
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grulib.h"
struct gru_config_info {
   int cpus ;
   int blades ;
   int nodes ;
   int chiplets ;
   int fill[16U] ;
};
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grulib.h"
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/cgroupstats.h"
struct percpu_ref;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 327
struct cgroup_root;
#line 328
struct cgroup_subsys;
#line 329
struct cgroup;
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
#line 192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
   struct kernfs_node *kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
   unsigned int child_subsys_mask ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
#line 277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
   int hierarchy_id ;
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
#line 399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
#line 614
struct cgroup_taskset;
#line 622 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cgroup.h"
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
   int early_init ;
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
};
#line 547 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/memcontrol.h"
struct anon_vma {
   struct anon_vma *root ;
   struct rw_semaphore rwsem ;
   atomic_t refcount ;
   unsigned int degree ;
   struct anon_vma *parent ;
   struct rb_root rb_root ;
};
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rmap.h"
struct mmu_notifier;
#line 263
struct mmu_notifier_ops;
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rmap.h"
struct mmu_notifier_mm {
   struct hlist_head list ;
   spinlock_t lock ;
};
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmu_notifier.h"
struct mmu_notifier_ops {
   void (*release)(struct mmu_notifier * , struct mm_struct * ) ;
   int (*clear_flush_young)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
   int (*test_young)(struct mmu_notifier * , struct mm_struct * , unsigned long  ) ;
   void (*change_pte)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                      pte_t  ) ;
   void (*invalidate_page)(struct mmu_notifier * , struct mm_struct * , unsigned long  ) ;
   void (*invalidate_range_start)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                                  unsigned long  ) ;
   void (*invalidate_range_end)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                                unsigned long  ) ;
   void (*invalidate_range)(struct mmu_notifier * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
};
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmu_notifier.h"
struct mmu_notifier {
   struct hlist_node hlist ;
   struct mmu_notifier_ops  const  *ops ;
};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_stats_s;
#line 155
struct gru_blade_state;
#line 159 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_stats_s {
   atomic_long_t vdata_alloc ;
   atomic_long_t vdata_free ;
   atomic_long_t gts_alloc ;
   atomic_long_t gts_free ;
   atomic_long_t gms_alloc ;
   atomic_long_t gms_free ;
   atomic_long_t gts_double_allocate ;
   atomic_long_t assign_context ;
   atomic_long_t assign_context_failed ;
   atomic_long_t free_context ;
   atomic_long_t load_user_context ;
   atomic_long_t load_kernel_context ;
   atomic_long_t lock_kernel_context ;
   atomic_long_t unlock_kernel_context ;
   atomic_long_t steal_user_context ;
   atomic_long_t steal_kernel_context ;
   atomic_long_t steal_context_failed ;
   atomic_long_t nopfn ;
   atomic_long_t asid_new ;
   atomic_long_t asid_next ;
   atomic_long_t asid_wrap ;
   atomic_long_t asid_reuse ;
   atomic_long_t intr ;
   atomic_long_t intr_cbr ;
   atomic_long_t intr_tfh ;
   atomic_long_t intr_spurious ;
   atomic_long_t intr_mm_lock_failed ;
   atomic_long_t call_os ;
   atomic_long_t call_os_wait_queue ;
   atomic_long_t user_flush_tlb ;
   atomic_long_t user_unload_context ;
   atomic_long_t user_exception ;
   atomic_long_t set_context_option ;
   atomic_long_t check_context_retarget_intr ;
   atomic_long_t check_context_unload ;
   atomic_long_t tlb_dropin ;
   atomic_long_t tlb_preload_page ;
   atomic_long_t tlb_dropin_fail_no_asid ;
   atomic_long_t tlb_dropin_fail_upm ;
   atomic_long_t tlb_dropin_fail_invalid ;
   atomic_long_t tlb_dropin_fail_range_active ;
   atomic_long_t tlb_dropin_fail_idle ;
   atomic_long_t tlb_dropin_fail_fmm ;
   atomic_long_t tlb_dropin_fail_no_exception ;
   atomic_long_t tfh_stale_on_fault ;
   atomic_long_t mmu_invalidate_range ;
   atomic_long_t mmu_invalidate_page ;
   atomic_long_t flush_tlb ;
   atomic_long_t flush_tlb_gru ;
   atomic_long_t flush_tlb_gru_tgh ;
   atomic_long_t flush_tlb_gru_zero_asid ;
   atomic_long_t copy_gpa ;
   atomic_long_t read_gpa ;
   atomic_long_t mesq_receive ;
   atomic_long_t mesq_receive_none ;
   atomic_long_t mesq_send ;
   atomic_long_t mesq_send_failed ;
   atomic_long_t mesq_noop ;
   atomic_long_t mesq_send_unexpected_error ;
   atomic_long_t mesq_send_lb_overflow ;
   atomic_long_t mesq_send_qlimit_reached ;
   atomic_long_t mesq_send_amo_nacked ;
   atomic_long_t mesq_send_put_nacked ;
   atomic_long_t mesq_page_overflow ;
   atomic_long_t mesq_qf_locked ;
   atomic_long_t mesq_qf_noop_not_full ;
   atomic_long_t mesq_qf_switch_head_failed ;
   atomic_long_t mesq_qf_unexpected_error ;
   atomic_long_t mesq_noop_unexpected_error ;
   atomic_long_t mesq_noop_lb_overflow ;
   atomic_long_t mesq_noop_qlimit_reached ;
   atomic_long_t mesq_noop_amo_nacked ;
   atomic_long_t mesq_noop_put_nacked ;
   atomic_long_t mesq_noop_page_overflow ;
};
#line 260
struct gru_state;
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_mm_tracker {
   unsigned int mt_asid_gen : 24 ;
   unsigned int mt_asid : 24 ;
   unsigned short mt_ctxbitmap ;
};
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_mm_struct {
   struct mmu_notifier ms_notifier ;
   atomic_t ms_refcnt ;
   spinlock_t ms_asid_lock ;
   atomic_t ms_range_active ;
   char ms_released ;
   wait_queue_head_t ms_wait_queue ;
   unsigned long ms_asidmap[32U] ;
   struct gru_mm_tracker ms_asids[2048U] ;
};
#line 330 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_vma_data {
   spinlock_t vd_lock ;
   struct list_head vd_head ;
   long vd_user_options ;
   int vd_cbr_au_count ;
   int vd_dsr_au_count ;
   unsigned char vd_tlb_preload_count ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_thread_state {
   struct list_head ts_next ;
   struct mutex ts_ctxlock ;
   struct mm_struct *ts_mm ;
   struct vm_area_struct *ts_vma ;
   struct gru_state *ts_gru ;
   struct gru_mm_struct *ts_gms ;
   unsigned char ts_tlb_preload_count ;
   unsigned long ts_cbr_map ;
   unsigned long ts_dsr_map ;
   unsigned long ts_steal_jiffies ;
   long ts_user_options ;
   pid_t ts_tgid_owner ;
   short ts_user_blade_id ;
   char ts_user_chiplet_id ;
   unsigned short ts_sizeavail ;
   int ts_tsid ;
   int ts_tlb_int_select ;
   int ts_ctxnum ;
   atomic_t ts_refcnt ;
   unsigned char ts_dsr_au_count ;
   unsigned char ts_cbr_au_count ;
   char ts_cch_req_slice ;
   char ts_blade ;
   char ts_force_cch_reload ;
   char ts_cbr_idx[64U] ;
   int ts_data_valid ;
   struct gru_gseg_statistics ustats ;
   unsigned long ts_gdata[0U] ;
};
#line 391 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_state {
   struct gru_blade_state *gs_blade ;
   unsigned long gs_gru_base_paddr ;
   void *gs_gru_base_vaddr ;
   unsigned short gs_gid ;
   unsigned short gs_blade_id ;
   unsigned char gs_chiplet_id ;
   unsigned char gs_tgh_local_shift ;
   unsigned char gs_tgh_first_remote ;
   spinlock_t gs_asid_lock ;
   spinlock_t gs_lock ;
   unsigned int gs_asid ;
   unsigned int gs_asid_limit ;
   unsigned int gs_asid_gen ;
   unsigned long gs_context_map ;
   unsigned long gs_cbr_map ;
   unsigned long gs_dsr_map ;
   unsigned int gs_reserved_cbrs ;
   unsigned int gs_reserved_dsr_bytes ;
   unsigned short gs_active_contexts ;
   struct gru_thread_state *gs_gts[16U] ;
   int gs_irq[16U] ;
};
#line 454 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_blade_state {
   void *kernel_cb ;
   void *kernel_dsr ;
   struct rw_semaphore bs_kgts_sema ;
   struct gru_thread_state *bs_kgts ;
   int bs_async_dsr_bytes ;
   int bs_async_cbrs ;
   struct completion *bs_async_wq ;
   spinlock_t bs_lock ;
   int bs_lru_ctxnum ;
   struct gru_state *bs_lru_gru ;
   struct gru_state bs_grus[2U] ;
};
#line 2926 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_mmrs.h"
struct uv_scir_s {
   struct timer_list timer ;
   unsigned long offset ;
   unsigned long last ;
   unsigned long idle_on ;
   unsigned long idle_off ;
   unsigned char state ;
   unsigned char enabled ;
};
#line 139 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
struct uv_hub_info_s {
   unsigned long global_mmr_base ;
   unsigned long gpa_mask ;
   unsigned int gnode_extra ;
   unsigned char hub_revision ;
   unsigned char apic_pnode_shift ;
   unsigned char m_shift ;
   unsigned char n_lshift ;
   unsigned long gnode_upper ;
   unsigned long lowmem_remap_top ;
   unsigned long lowmem_remap_base ;
   unsigned short pnode ;
   unsigned short pnode_mask ;
   unsigned short coherency_domain_number ;
   unsigned short numa_blade_id ;
   unsigned char blade_processor_id ;
   unsigned char m_val ;
   unsigned char n_val ;
   struct uv_scir_s scir ;
};
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
struct uv_blade_info {
   unsigned short nr_possible_cpus ;
   unsigned short nr_online_cpus ;
   unsigned short pnode ;
   short memory_nid ;
   spinlock_t nmi_lock ;
   unsigned long nmi_count ;
};
#line 623 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
struct ldv_struct_EMGentry_20 {
   int signal_pending ;
};
#line 619 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct ldv_struct_dummy_resourceless_instance_11 {
   struct mmu_notifier *arg0 ;
   int signal_pending ;
};
#line 624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct ldv_struct_file_operations_instance_0 {
   struct file_operations *arg0 ;
   int signal_pending ;
};
#line 629 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct ldv_struct_free_irq_13 {
   int arg0 ;
   int signal_pending ;
};
#line 634 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct ldv_struct_interrupt_instance_5 {
   int arg0 ;
   enum irqreturn (*arg1)(int  , void * ) ;
   enum irqreturn (*arg2)(int  , void * ) ;
   void *arg3 ;
   int signal_pending ;
};
#line 2081 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
typedef int ldv_func_ret_type___0;
#line 2102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
typedef int ldv_func_ret_type___1;
#line 2114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
typedef int ldv_func_ret_type___2;
#line 2126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
typedef int ldv_func_ret_type___3;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
struct gru_context_configuration_handle;
#line 348 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
struct gru_context_configuration_handle {
   unsigned char cmd : 1 ;
   unsigned char delresp : 1 ;
   unsigned char opc : 3 ;
   unsigned char unmap_enable : 1 ;
   unsigned char req_slice_set_enable : 1 ;
   unsigned char req_slice : 2 ;
   unsigned char cb_int_enable : 1 ;
   unsigned char tlb_int_enable : 1 ;
   unsigned char tfm_fault_bit_enable : 1 ;
   unsigned char tlb_int_select : 4 ;
   unsigned char status : 2 ;
   unsigned char state : 2 ;
   unsigned char reserved2 : 4 ;
   unsigned char cause : 4 ;
   unsigned char tfm_done_bit_enable : 1 ;
   unsigned char unused : 3 ;
   unsigned int dsr_allocation_map ;
   unsigned long cbr_allocation_map ;
   unsigned int asid[8U] ;
   unsigned short sizeavail[8U] ;
};
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 phys_addr_t;
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pmdval_t;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pudval_t;
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pud_t_14 {
   pudval_t pud ;
};
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pud_t_14 pud_t;
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pmd_t_15 {
   pmdval_t pmd ;
};
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pmd_t_15 pmd_t;
#line 424 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
struct pv_lazy_ops {
   void (*enter)(void) ;
   void (*leave)(void) ;
   void (*flush)(void) ;
};
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
struct pv_mmu_ops {
   unsigned long (*read_cr2)(void) ;
   void (*write_cr2)(unsigned long  ) ;
   unsigned long (*read_cr3)(void) ;
   void (*write_cr3)(unsigned long  ) ;
   void (*activate_mm)(struct mm_struct * , struct mm_struct * ) ;
   void (*dup_mmap)(struct mm_struct * , struct mm_struct * ) ;
   void (*exit_mmap)(struct mm_struct * ) ;
   void (*flush_tlb_user)(void) ;
   void (*flush_tlb_kernel)(void) ;
   void (*flush_tlb_single)(unsigned long  ) ;
   void (*flush_tlb_others)(struct cpumask  const  * , struct mm_struct * , unsigned long  ,
                            unsigned long  ) ;
   int (*pgd_alloc)(struct mm_struct * ) ;
   void (*pgd_free)(struct mm_struct * , pgd_t * ) ;
   void (*alloc_pte)(struct mm_struct * , unsigned long  ) ;
   void (*alloc_pmd)(struct mm_struct * , unsigned long  ) ;
   void (*alloc_pud)(struct mm_struct * , unsigned long  ) ;
   void (*release_pte)(unsigned long  ) ;
   void (*release_pmd)(unsigned long  ) ;
   void (*release_pud)(unsigned long  ) ;
   void (*set_pte)(pte_t * , pte_t  ) ;
   void (*set_pte_at)(struct mm_struct * , unsigned long  , pte_t * , pte_t  ) ;
   void (*set_pmd)(pmd_t * , pmd_t  ) ;
   void (*set_pmd_at)(struct mm_struct * , unsigned long  , pmd_t * , pmd_t  ) ;
   void (*pte_update)(struct mm_struct * , unsigned long  , pte_t * ) ;
   void (*pte_update_defer)(struct mm_struct * , unsigned long  , pte_t * ) ;
   void (*pmd_update)(struct mm_struct * , unsigned long  , pmd_t * ) ;
   void (*pmd_update_defer)(struct mm_struct * , unsigned long  , pmd_t * ) ;
   pte_t (*ptep_modify_prot_start)(struct mm_struct * , unsigned long  , pte_t * ) ;
   void (*ptep_modify_prot_commit)(struct mm_struct * , unsigned long  , pte_t * ,
                                   pte_t  ) ;
   struct paravirt_callee_save pte_val ;
   struct paravirt_callee_save make_pte ;
   struct paravirt_callee_save pgd_val ;
   struct paravirt_callee_save make_pgd ;
   void (*set_pud)(pud_t * , pud_t  ) ;
   struct paravirt_callee_save pmd_val ;
   struct paravirt_callee_save make_pmd ;
   struct paravirt_callee_save pud_val ;
   struct paravirt_callee_save make_pud ;
   void (*set_pgd)(pgd_t * , pgd_t  ) ;
   struct pv_lazy_ops lazy_mode ;
   void (*set_fixmap)(unsigned int  , phys_addr_t  , pgprot_t  ) ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 627 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
union __anonunion_v_210 {
   short preferred_node ;
   nodemask_t nodes ;
};
#line 627 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
union __anonunion_w_211 {
   nodemask_t cpuset_mems_allowed ;
   nodemask_t user_nodemask ;
};
#line 627 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
struct mempolicy {
   atomic_t refcnt ;
   unsigned short mode ;
   unsigned short flags ;
   union __anonunion_v_210 v ;
   union __anonunion_w_211 w ;
};
#line 375 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmu_notifier.h"
struct gru_get_gseg_statistics_req {
   unsigned long gseg ;
   struct gru_gseg_statistics stats ;
};
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grulib.h"
struct gru_unload_context_req {
   unsigned long gseg ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grulib.h"
struct gru_set_context_option_req {
   unsigned long gseg ;
   int op ;
   int val0 ;
   long val1 ;
};
#line 100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grulib.h"
struct gru_flush_tlb_req {
   unsigned long gseg ;
   unsigned long vaddr ;
   size_t len ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
struct control_block_extended_exc_detail {
   unsigned long cb ;
   int opc ;
   int ecause ;
   int exopc ;
   long exceptdet0 ;
   int exceptdet1 ;
   int cbrstate ;
   int cbrexecstatus ;
};
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
struct gru_instruction_bits {
   unsigned char icmd : 1 ;
   unsigned char ima : 3 ;
   unsigned char reserved0 : 4 ;
   unsigned char xtype : 3 ;
   unsigned char iaa0 : 2 ;
   unsigned char iaa1 : 2 ;
   unsigned char reserved1 : 1 ;
   unsigned char opc ;
   unsigned char exopc ;
   unsigned int idef2 : 22 ;
   unsigned char reserved2 : 2 ;
   unsigned char istatus : 2 ;
   unsigned char isubstatus : 4 ;
   unsigned char reserved3 : 1 ;
   unsigned char tlb_fault_color : 1 ;
   unsigned long idef4 ;
   unsigned long idef1 ;
   unsigned long idef5 ;
   unsigned long idef6 ;
   unsigned long idef3 ;
   unsigned long reserved4 ;
   unsigned long avalue ;
};
#line 118 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_fault_map;
#line 130
struct gru_control_block_extended;
#line 136
struct gru_tlb_fault_handle;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_fault_map {
   unsigned long fault_bits[2U] ;
   unsigned long fill0[2U] ;
   unsigned long done_bits[2U] ;
   unsigned long fill1[2U] ;
};
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_fault_handle {
   unsigned char cmd : 1 ;
   unsigned char delresp : 1 ;
   unsigned char fill0 : 2 ;
   unsigned char opc : 3 ;
   unsigned short fill1 : 9 ;
   unsigned char status : 2 ;
   unsigned char fill2 : 2 ;
   unsigned char state : 3 ;
   unsigned char fill3 : 1 ;
   unsigned char cause : 6 ;
   unsigned char cb_int : 1 ;
   unsigned char fill4 : 1 ;
   unsigned short indexway : 12 ;
   unsigned char fill5 : 4 ;
   unsigned char ctxnum : 4 ;
   unsigned short fill6 : 12 ;
   unsigned long missvaddr ;
   unsigned int missasid : 24 ;
   unsigned char fill7 ;
   unsigned int fillasid : 24 ;
   unsigned char dirty : 1 ;
   unsigned char gaa : 2 ;
   unsigned char fill8 : 5 ;
   unsigned long pfn : 41 ;
   unsigned char fill9 : 7 ;
   unsigned char pagesize : 5 ;
   unsigned short fill10 : 11 ;
   unsigned long fillvaddr ;
   unsigned long fill11[3U] ;
};
#line 427 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
struct gru_control_block_extended {
   unsigned char reserved0 : 1 ;
   unsigned char imacpy : 3 ;
   unsigned char reserved1 : 4 ;
   unsigned char xtypecpy : 3 ;
   unsigned char iaa0cpy : 2 ;
   unsigned char iaa1cpy : 2 ;
   unsigned char reserved2 : 1 ;
   unsigned char opccpy ;
   unsigned char exopccpy ;
   unsigned int idef2cpy : 22 ;
   unsigned short reserved3 : 10 ;
   unsigned int idef4cpy : 22 ;
   unsigned short reserved4 : 10 ;
   unsigned int idef4upd : 22 ;
   unsigned short reserved5 : 10 ;
   unsigned long idef1upd ;
   unsigned long idef5cpy ;
   unsigned long idef6cpy ;
   unsigned long idef3upd ;
   unsigned long idef5upd ;
   unsigned int idef2upd : 22 ;
   unsigned short reserved6 : 10 ;
   unsigned int ecause : 20 ;
   unsigned char cbrstate : 4 ;
   unsigned char cbrexecstatus ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/desc_defs.h"
struct gate_struct64 {
   u16 offset_low ;
   u16 segment ;
   unsigned char ist : 3 ;
   unsigned char zero0 : 5 ;
   unsigned char type : 5 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   u16 offset_middle ;
   u32 offset_high ;
   u32 zero1 ;
};
#line 81 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/desc_defs.h"
typedef struct gate_struct64 gate_desc;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/desc_defs.h"
struct desc_ptr {
   unsigned short size ;
   unsigned long address ;
};
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct tss_struct;
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
struct pv_cpu_ops {
   unsigned long (*get_debugreg)(int  ) ;
   void (*set_debugreg)(int  , unsigned long  ) ;
   void (*clts)(void) ;
   unsigned long (*read_cr0)(void) ;
   void (*write_cr0)(unsigned long  ) ;
   unsigned long (*read_cr4_safe)(void) ;
   unsigned long (*read_cr4)(void) ;
   void (*write_cr4)(unsigned long  ) ;
   unsigned long (*read_cr8)(void) ;
   void (*write_cr8)(unsigned long  ) ;
   void (*load_tr_desc)(void) ;
   void (*load_gdt)(struct desc_ptr  const  * ) ;
   void (*load_idt)(struct desc_ptr  const  * ) ;
   void (*store_idt)(struct desc_ptr * ) ;
   void (*set_ldt)(void const   * , unsigned int  ) ;
   unsigned long (*store_tr)(void) ;
   void (*load_tls)(struct thread_struct * , unsigned int  ) ;
   void (*load_gs_index)(unsigned int  ) ;
   void (*write_ldt_entry)(struct desc_struct * , int  , void const   * ) ;
   void (*write_gdt_entry)(struct desc_struct * , int  , void const   * , int  ) ;
   void (*write_idt_entry)(gate_desc * , int  , gate_desc const   * ) ;
   void (*alloc_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*free_ldt)(struct desc_struct * , unsigned int  ) ;
   void (*load_sp0)(struct tss_struct * , struct thread_struct * ) ;
   void (*set_iopl_mask)(unsigned int  ) ;
   void (*wbinvd)(void) ;
   void (*io_delay)(void) ;
   void (*cpuid)(unsigned int * , unsigned int * , unsigned int * , unsigned int * ) ;
   u64 (*read_msr)(unsigned int  , int * ) ;
   int (*write_msr)(unsigned int  , unsigned int  , unsigned int  ) ;
   u64 (*read_tsc)(void) ;
   u64 (*read_pmc)(int  ) ;
   unsigned long long (*read_tscp)(unsigned int * ) ;
   void (*irq_enable_sysexit)(void) ;
   void (*usergs_sysret64)(void) ;
   void (*usergs_sysret32)(void) ;
   void (*iret)(void) ;
   void (*swapgs)(void) ;
   void (*start_context_switch)(struct task_struct * ) ;
   void (*end_context_switch)(struct task_struct * ) ;
};
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct x86_hw_tss {
   u32 reserved1 ;
   u64 sp0 ;
   u64 sp1 ;
   u64 sp2 ;
   u64 reserved2 ;
   u64 ist[7U] ;
   u32 reserved3 ;
   u32 reserved4 ;
   u16 reserved5 ;
   u16 io_bitmap_base ;
};
#line 252 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct tss_struct {
   struct x86_hw_tss x86_tss ;
   unsigned long io_bitmap[1025U] ;
   unsigned long stack[64U] ;
};
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/tsc.h"
typedef unsigned long long cycles_t;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_global_handle;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
struct gru_tlb_global_handle {
   unsigned char cmd : 1 ;
   unsigned char delresp : 1 ;
   unsigned char opc : 1 ;
   unsigned char fill1 : 5 ;
   unsigned char fill2 ;
   unsigned char status : 2 ;
   unsigned char fill3 : 2 ;
   unsigned char state : 3 ;
   unsigned char fill4 : 1 ;
   unsigned char cause : 3 ;
   unsigned long fill5 : 37 ;
   unsigned long vaddr ;
   unsigned int asid : 24 ;
   unsigned char fill6 ;
   unsigned char pagesize : 5 ;
   unsigned short fill7 : 11 ;
   unsigned char global : 1 ;
   unsigned short fill8 : 15 ;
   unsigned long vaddrmask : 39 ;
   unsigned short fill9 : 9 ;
   unsigned short n : 10 ;
   unsigned char fill10 : 6 ;
   unsigned short ctxbitmap ;
   unsigned long fill11[3U] ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 379 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irq.h"
struct proc_dir_entry;
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct mcs_op_statistic {
   atomic_long_t count ;
   atomic_long_t total ;
   unsigned long max ;
};
#line 319 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
struct proc_entry {
   char *name ;
   umode_t mode ;
   struct file_operations  const  *fops ;
   struct proc_dir_entry *entry ;
};
#line 642 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_struct_seq_instance_6 {
   struct seq_file *arg0 ;
   struct seq_operations *arg1 ;
   int signal_pending ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
struct __anonstruct____missing_field_name_211 {
   unsigned int op32 ;
   unsigned int tri0 ;
};
#line 126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
union __anonunion____missing_field_name_210 {
   unsigned long op64 ;
   struct __anonstruct____missing_field_name_211 __annonCompField72 ;
};
#line 126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
struct gru_instruction {
   union __anonunion____missing_field_name_210 __annonCompField73 ;
   unsigned long tri1_bufsize ;
   unsigned long baddr0 ;
   unsigned long nelem ;
   unsigned long op1_stride ;
   unsigned long op2_value_baddr1 ;
   unsigned long reserved0 ;
   unsigned long avalue ;
};
#line 148 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
struct __anonstruct____missing_field_name_212 {
   unsigned int head ;
   unsigned int limit ;
};
#line 148 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
union gru_mesqhead {
   unsigned long val ;
   struct __anonstruct____missing_field_name_212 __annonCompField74 ;
};
#line 616 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
struct gru_control_block_status {
   unsigned char icmd : 1 ;
   unsigned char ima : 3 ;
   unsigned char reserved0 : 4 ;
   unsigned int unused1 : 24 ;
   unsigned int unused2 : 24 ;
   unsigned char istatus : 2 ;
   unsigned char isubstatus : 4 ;
   unsigned char unused3 : 2 ;
};
#line 677 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_message_queue_desc {
   void *mq ;
   unsigned long mq_gpa ;
   int qlines ;
   int interrupt_vector ;
   int interrupt_pnode ;
   int interrupt_apicid ;
};
#line 678 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
struct message_queue {
   union gru_mesqhead head ;
   int qlines ;
   long hstatus[2U] ;
   void *next ;
   void *limit ;
   void *start ;
   void *start2 ;
   char data ;
};
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
struct message_header {
   char present ;
   char present2 ;
   char lines ;
   char fill ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 247 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
enum mcs_op {
    cchop_allocate = 0,
    cchop_start = 1,
    cchop_interrupt = 2,
    cchop_interrupt_sync = 3,
    cchop_deallocate = 4,
    tfhop_write_only = 5,
    tfhop_write_restart = 6,
    tghop_invalidate = 7,
    mcsop_last = 8
} ;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grulib.h"
struct gru_dump_chiplet_state_req {
   unsigned int op ;
   unsigned int gid ;
   int ctxnum ;
   char data_opt ;
   char lock_cch ;
   char flush_cbrs ;
   char fill[10U] ;
   pid_t pid ;
   void *buf ;
   size_t buflen ;
   unsigned int num_contexts ;
};
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grulib.h"
struct gru_dump_context_header {
   unsigned int magic ;
   unsigned int gid ;
   unsigned char ctxnum ;
   unsigned char cbrcnt ;
   unsigned char dsrcnt ;
   pid_t pid ;
   unsigned long vaddr ;
   int cch_locked ;
   unsigned long data[0U] ;
};
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request;
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   struct kthread_worker *worker ;
};
#line 2279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
struct dma_chan;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};
#line 151
struct spi_message;
#line 152
struct spi_transfer;
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
   bool (*can_dma)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master * ) ;
   int (*transfer_one_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_transfer_hardware)(struct spi_master * ) ;
   int (*prepare_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_message)(struct spi_master * , struct spi_message * ) ;
   void (*set_cs)(struct spi_device * , bool  ) ;
   int (*transfer_one)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};
#line 506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_transfer {
   void const   *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned char cs_change : 1 ;
   unsigned char tx_nbits : 3 ;
   unsigned char rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};
#line 630 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned char is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct notifier_block;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 720 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/pm.h"
typedef unsigned int mmc_pm_flag_t;
#line 26
struct mmc_card;
#line 27
struct sdio_func;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
typedef void sdio_irq_handler_t(struct sdio_func * );
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func_tuple {
   struct sdio_func_tuple *next ;
   unsigned char code ;
   unsigned char size ;
   unsigned char data[0U] ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func {
   struct mmc_card *card ;
   struct device dev ;
   sdio_irq_handler_t *irq_handler ;
   unsigned int num ;
   unsigned char class ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned int max_blksize ;
   unsigned int cur_blksize ;
   unsigned int enable_timeout ;
   unsigned int state ;
   u8 tmpbuf[4U] ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
};
#line 161
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
} ;
#line 167
struct led_trigger;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct led_classdev {
   char const   *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev * , enum led_brightness  ) ;
   int (*brightness_set_sync)(struct led_classdev * , enum led_brightness  ) ;
   enum led_brightness (*brightness_get)(struct led_classdev * ) ;
   int (*blink_set)(struct led_classdev * , unsigned long * , unsigned long * ) ;
   struct device *dev ;
   struct attribute_group  const  **groups ;
   struct list_head node ;
   char const   *default_trigger ;
   unsigned long blink_delay_on ;
   unsigned long blink_delay_off ;
   struct timer_list blink_timer ;
   int blink_brightness ;
   void (*flash_resume)(struct led_classdev * ) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/leds.h"
struct led_trigger {
   char const   *name ;
   void (*activate)(struct led_classdev * ) ;
   void (*deactivate)(struct led_classdev * ) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debugfs.h"
struct fault_attr {
   unsigned long probability ;
   unsigned long interval ;
   atomic_t times ;
   atomic_t space ;
   unsigned long verbose ;
   u32 task_filter ;
   unsigned long stacktrace_depth ;
   unsigned long require_start ;
   unsigned long require_end ;
   unsigned long reject_start ;
   unsigned long reject_end ;
   unsigned long count ;
   struct ratelimit_state ratelimit_state ;
   struct dentry *dname ;
};
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_data;
#line 654
struct mmc_request;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_command {
   u32 opcode ;
   u32 arg ;
   u32 resp[4U] ;
   unsigned int flags ;
   unsigned int retries ;
   unsigned int error ;
   unsigned int busy_timeout ;
   bool sanitize_busy ;
   struct mmc_data *data ;
   struct mmc_request *mrq ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_data {
   unsigned int timeout_ns ;
   unsigned int timeout_clks ;
   unsigned int blksz ;
   unsigned int blocks ;
   unsigned int error ;
   unsigned int flags ;
   unsigned int bytes_xfered ;
   struct mmc_command *stop ;
   struct mmc_request *mrq ;
   unsigned int sg_len ;
   struct scatterlist *sg ;
   s32 host_cookie ;
};
#line 127
struct mmc_host;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_request {
   struct mmc_command *sbc ;
   struct mmc_command *cmd ;
   struct mmc_data *data ;
   struct mmc_command *stop ;
   struct completion completion ;
   void (*done)(struct mmc_request * ) ;
   struct mmc_host *host ;
};
#line 139
struct mmc_async_req;
#line 214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_cid {
   unsigned int manfid ;
   char prod_name[8U] ;
   unsigned char prv ;
   unsigned int serial ;
   unsigned short oemid ;
   unsigned short year ;
   unsigned char hwrev ;
   unsigned char fwrev ;
   unsigned char month ;
};
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_csd {
   unsigned char structure ;
   unsigned char mmca_vsn ;
   unsigned short cmdclass ;
   unsigned short tacc_clks ;
   unsigned int tacc_ns ;
   unsigned int c_size ;
   unsigned int r2w_factor ;
   unsigned int max_dtr ;
   unsigned int erase_size ;
   unsigned int read_blkbits ;
   unsigned int write_blkbits ;
   unsigned int capacity ;
   unsigned char read_partial : 1 ;
   unsigned char read_misalign : 1 ;
   unsigned char write_partial : 1 ;
   unsigned char write_misalign : 1 ;
   unsigned char dsr_imp : 1 ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ext_csd {
   u8 rev ;
   u8 erase_group_def ;
   u8 sec_feature_support ;
   u8 rel_sectors ;
   u8 rel_param ;
   u8 part_config ;
   u8 cache_ctrl ;
   u8 rst_n_function ;
   u8 max_packed_writes ;
   u8 max_packed_reads ;
   u8 packed_event_en ;
   unsigned int part_time ;
   unsigned int sa_timeout ;
   unsigned int generic_cmd6_time ;
   unsigned int power_off_longtime ;
   u8 power_off_notification ;
   unsigned int hs_max_dtr ;
   unsigned int hs200_max_dtr ;
   unsigned int sectors ;
   unsigned int hc_erase_size ;
   unsigned int hc_erase_timeout ;
   unsigned int sec_trim_mult ;
   unsigned int sec_erase_mult ;
   unsigned int trim_timeout ;
   bool partition_setting_completed ;
   unsigned long long enhanced_area_offset ;
   unsigned int enhanced_area_size ;
   unsigned int cache_size ;
   bool hpi_en ;
   bool hpi ;
   unsigned int hpi_cmd ;
   bool bkops ;
   bool man_bkops_en ;
   unsigned int data_sector_size ;
   unsigned int data_tag_unit_size ;
   unsigned int boot_ro_lock ;
   bool boot_ro_lockable ;
   bool ffu_capable ;
   u8 fwrev[8U] ;
   u8 raw_exception_status ;
   u8 raw_partition_support ;
   u8 raw_rpmb_size_mult ;
   u8 raw_erased_mem_count ;
   u8 raw_ext_csd_structure ;
   u8 raw_card_type ;
   u8 out_of_int_time ;
   u8 raw_pwr_cl_52_195 ;
   u8 raw_pwr_cl_26_195 ;
   u8 raw_pwr_cl_52_360 ;
   u8 raw_pwr_cl_26_360 ;
   u8 raw_s_a_timeout ;
   u8 raw_hc_erase_gap_size ;
   u8 raw_erase_timeout_mult ;
   u8 raw_hc_erase_grp_size ;
   u8 raw_sec_trim_mult ;
   u8 raw_sec_erase_mult ;
   u8 raw_sec_feature_support ;
   u8 raw_trim_mult ;
   u8 raw_pwr_cl_200_195 ;
   u8 raw_pwr_cl_200_360 ;
   u8 raw_pwr_cl_ddr_52_195 ;
   u8 raw_pwr_cl_ddr_52_360 ;
   u8 raw_pwr_cl_ddr_200_360 ;
   u8 raw_bkops_status ;
   u8 raw_sectors[4U] ;
   unsigned int feature_support ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_scr {
   unsigned char sda_vsn ;
   unsigned char sda_spec3 ;
   unsigned char bus_widths ;
   unsigned char cmds ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_ssr {
   unsigned int au ;
   unsigned int erase_timeout ;
   unsigned int erase_offset ;
};
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_switch_caps {
   unsigned int hs_max_dtr ;
   unsigned int uhs_max_dtr ;
   unsigned int sd3_bus_mode ;
   unsigned int sd3_drv_type ;
   unsigned int sd3_curr_limit ;
};
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cccr {
   unsigned int sdio_vsn ;
   unsigned int sd_vsn ;
   unsigned char multi_block : 1 ;
   unsigned char low_speed : 1 ;
   unsigned char wide_bus : 1 ;
   unsigned char high_power : 1 ;
   unsigned char high_speed : 1 ;
   unsigned char disable_cd : 1 ;
};
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cis {
   unsigned short vendor ;
   unsigned short device ;
   unsigned short blksize ;
   unsigned int max_dtr ;
};
#line 200
struct mmc_ios;
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_part {
   unsigned int size ;
   unsigned int part_cfg ;
   char name[20U] ;
   bool force_ro ;
   unsigned int area_type ;
};
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_card {
   struct mmc_host *host ;
   struct device dev ;
   u32 ocr ;
   unsigned int rca ;
   unsigned int type ;
   unsigned int state ;
   unsigned int quirks ;
   unsigned int erase_size ;
   unsigned int erase_shift ;
   unsigned int pref_erase ;
   u8 erased_byte ;
   u32 raw_cid[4U] ;
   u32 raw_csd[4U] ;
   u32 raw_scr[2U] ;
   struct mmc_cid cid ;
   struct mmc_csd csd ;
   struct mmc_ext_csd ext_csd ;
   struct sd_scr scr ;
   struct sd_ssr ssr ;
   struct sd_switch_caps sw_caps ;
   unsigned int sdio_funcs ;
   struct sdio_cccr cccr ;
   struct sdio_cis cis ;
   struct sdio_func *sdio_func[7U] ;
   struct sdio_func *sdio_single_irq ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
   unsigned int sd_bus_speed ;
   unsigned int mmc_avail_type ;
   struct dentry *debugfs_root ;
   struct mmc_part part[7U] ;
   unsigned int nr_parts ;
};
#line 519 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ios {
   unsigned int clock ;
   unsigned short vdd ;
   unsigned char bus_mode ;
   unsigned char chip_select ;
   unsigned char power_mode ;
   unsigned char bus_width ;
   unsigned char timing ;
   unsigned char signal_voltage ;
   unsigned char drv_type ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host_ops {
   int (*enable)(struct mmc_host * ) ;
   int (*disable)(struct mmc_host * ) ;
   void (*post_req)(struct mmc_host * , struct mmc_request * , int  ) ;
   void (*pre_req)(struct mmc_host * , struct mmc_request * , bool  ) ;
   void (*request)(struct mmc_host * , struct mmc_request * ) ;
   void (*set_ios)(struct mmc_host * , struct mmc_ios * ) ;
   int (*get_ro)(struct mmc_host * ) ;
   int (*get_cd)(struct mmc_host * ) ;
   void (*enable_sdio_irq)(struct mmc_host * , int  ) ;
   void (*init_card)(struct mmc_host * , struct mmc_card * ) ;
   int (*start_signal_voltage_switch)(struct mmc_host * , struct mmc_ios * ) ;
   int (*card_busy)(struct mmc_host * ) ;
   int (*execute_tuning)(struct mmc_host * , u32  ) ;
   int (*prepare_hs400_tuning)(struct mmc_host * , struct mmc_ios * ) ;
   int (*select_drive_strength)(unsigned int  , int  , int  ) ;
   void (*hw_reset)(struct mmc_host * ) ;
   void (*card_event)(struct mmc_host * ) ;
   int (*multi_io_quirk)(struct mmc_card * , unsigned int  , int  ) ;
};
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_async_req {
   struct mmc_request *mrq ;
   int (*err_check)(struct mmc_card * , struct mmc_async_req * ) ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_slot {
   int cd_irq ;
   void *handler_priv ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_context_info {
   bool is_done_rcv ;
   bool is_new_req ;
   bool is_waiting_last_req ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
};
#line 196
struct regulator;
#line 197
struct mmc_pwrseq;
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_supply {
   struct regulator *vmmc ;
   struct regulator *vqmmc ;
};
#line 204
struct mmc_bus_ops;
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host {
   struct device *parent ;
   struct device class_dev ;
   int index ;
   struct mmc_host_ops  const  *ops ;
   struct mmc_pwrseq *pwrseq ;
   unsigned int f_min ;
   unsigned int f_max ;
   unsigned int f_init ;
   u32 ocr_avail ;
   u32 ocr_avail_sdio ;
   u32 ocr_avail_sd ;
   u32 ocr_avail_mmc ;
   struct notifier_block pm_notify ;
   u32 max_current_330 ;
   u32 max_current_300 ;
   u32 max_current_180 ;
   u32 caps ;
   u32 caps2 ;
   mmc_pm_flag_t pm_caps ;
   int clk_requests ;
   unsigned int clk_delay ;
   bool clk_gated ;
   struct delayed_work clk_gate_work ;
   unsigned int clk_old ;
   spinlock_t clk_lock ;
   struct mutex clk_gate_mutex ;
   struct device_attribute clkgate_delay_attr ;
   unsigned long clkgate_delay ;
   unsigned int max_seg_size ;
   unsigned short max_segs ;
   unsigned short unused ;
   unsigned int max_req_size ;
   unsigned int max_blk_size ;
   unsigned int max_blk_count ;
   unsigned int max_busy_timeout ;
   spinlock_t lock ;
   struct mmc_ios ios ;
   unsigned char use_spi_crc : 1 ;
   unsigned char claimed : 1 ;
   unsigned char bus_dead : 1 ;
   unsigned char removed : 1 ;
   int rescan_disable ;
   int rescan_entered ;
   bool trigger_card_event ;
   struct mmc_card *card ;
   wait_queue_head_t wq ;
   struct task_struct *claimer ;
   int claim_cnt ;
   struct delayed_work detect ;
   int detect_change ;
   struct mmc_slot slot ;
   struct mmc_bus_ops  const  *bus_ops ;
   unsigned int bus_refs ;
   unsigned int sdio_irqs ;
   struct task_struct *sdio_irq_thread ;
   bool sdio_irq_pending ;
   atomic_t sdio_irq_thread_abort ;
   mmc_pm_flag_t pm_flags ;
   struct led_trigger *led ;
   bool regulator_enabled ;
   struct mmc_supply supply ;
   struct dentry *debugfs_root ;
   struct mmc_async_req *areq ;
   struct mmc_context_info context_info ;
   struct fault_attr fail_mmc_request ;
   unsigned int actual_clock ;
   unsigned int slotno ;
   int dsr_req ;
   u32 dsr ;
   unsigned long private[0U] ;
};
#line 24 "/home/ubuntu/klever-work/verifier/map.h"
typedef int ldv_map;
#line 27
struct usb_device;
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct urb;
#line 8 "thread.c"
struct ldv_thread_set {
   int number ;
   struct ldv_thread **threads ;
};
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct ldv_thread {
   int identifier ;
   void (*function)(void * ) ;
};
#line 22 "/home/ubuntu/klever-work/verifier/set.h"
typedef _Bool ldv_set;
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 28 "/home/ubuntu/klever-work/verifier/common.h"
void ldv_assume(int expression ) ;
#line 31
void ldv_stop(void) ;
#line 6 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) ;
#line 7
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) ;
#line 11
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) ;
#line 16
void ldv_linux_arch_io_check_final_state(void) ;
#line 20
void ldv_linux_block_genhd_check_final_state(void) ;
#line 24
void ldv_linux_block_queue_check_final_state(void) ;
#line 28
void ldv_linux_block_request_check_final_state(void) ;
#line 32
void *ldv_linux_drivers_base_class_create_class(void) ;
#line 33
int ldv_linux_drivers_base_class_register_class(void) ;
#line 37
void ldv_linux_drivers_base_class_check_final_state(void) ;
#line 48
void ldv_linux_fs_char_dev_check_final_state(void) ;
#line 52
void ldv_linux_fs_sysfs_check_final_state(void) ;
#line 56
void ldv_linux_kernel_locking_rwlock_check_final_state(void) ;
#line 60
void ldv_linux_kernel_module_check_final_state(void) ;
#line 64
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) ;
#line 65
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) ;
#line 69
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) ;
#line 70
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) ;
#line 74
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) ;
#line 75
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) ;
#line 79
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) ;
#line 80
void ldv_linux_kernel_rcu_srcu_check_final_state(void) ;
#line 84
void ldv_linux_lib_find_bit_initialize(void) ;
#line 88
void ldv_linux_lib_idr_check_final_state(void) ;
#line 92
void ldv_linux_mmc_sdio_func_check_final_state(void) ;
#line 96
void ldv_linux_net_register_reset_error_counter(void) ;
#line 101
void ldv_linux_net_rtnetlink_check_final_state(void) ;
#line 105
void ldv_linux_net_sock_check_final_state(void) ;
#line 110
void ldv_linux_usb_coherent_check_final_state(void) ;
#line 114
void *ldv_linux_usb_gadget_create_class(void) ;
#line 115
int ldv_linux_usb_gadget_register_class(void) ;
#line 122
void ldv_linux_usb_gadget_check_final_state(void) ;
#line 126
void ldv_linux_usb_register_reset_error_counter(void) ;
#line 132
void ldv_linux_usb_urb_check_final_state(void) ;
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 139
  ldv_linux_alloc_irq_check_alloc_nonatomic();
#line 143
  ldv_linux_alloc_usb_lock_check_alloc_nonatomic();
  }
#line 144
  return;
}
}
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
  {
#line 150
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 154
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 155
  return;
}
}
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_check_for_read_section(void) 
{ 


  {
  {
#line 161
  ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section();
#line 165
  ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section();
#line 169
  ldv_linux_kernel_rcu_update_lock_check_for_read_section();
#line 173
  ldv_linux_kernel_rcu_srcu_check_for_read_section();
  }
#line 174
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void *ldv_create_class(void) 
{ 
  void *res1 ;
  void *tmp ;
  void *res2 ;
  void *tmp___0 ;

  {
  {
#line 180
  tmp = ldv_linux_drivers_base_class_create_class();
#line 180
  res1 = tmp;
#line 181
  tmp___0 = ldv_linux_usb_gadget_create_class();
#line 181
  res2 = tmp___0;
#line 182
  ldv_assume((unsigned long )res1 == (unsigned long )res2);
  }
#line 183
  return (res1);
}
}
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
int ldv_register_class(void) 
{ 
  int res1 ;
  int tmp ;
  int res2 ;
  int tmp___0 ;

  {
  {
#line 194
  tmp = ldv_linux_drivers_base_class_register_class();
#line 194
  res1 = tmp;
#line 195
  tmp___0 = ldv_linux_usb_gadget_register_class();
#line 195
  res2 = tmp___0;
#line 196
  ldv_assume(res1 == res2);
  }
#line 197
  return (res1);
}
}
#line 261
unsigned long ldv_linux_lib_find_bit_find_next_bit(unsigned long size , unsigned long offset ) ;
#line 22 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 34 "/home/ubuntu/klever-work/linux/ldv/common.h"
static void ldv_ldv_initialize_105(void) ;
#line 47
int ldv_post_init(int init_ret_val ) ;
#line 50
static int ldv_ldv_post_init_102(int ldv_func_arg1 ) ;
#line 122
static void ldv_ldv_check_final_state_103(void) ;
#line 126
static void ldv_ldv_check_final_state_104(void) ;
#line 32 "/home/ubuntu/klever-work/verifier/memory.h"
void ldv_free(void *s ) ;
#line 34
void *ldv_xmalloc(size_t size ) ;
#line 39
void *ldv_malloc_unknown_size(void) ;
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void *ldv_alloc_macro(gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 312
  ldv_check_alloc_flags(flags);
#line 313
  tmp = ldv_malloc_unknown_size();
  }
#line 313
  return (tmp);
}
}
#line 366
static void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) ;
#line 395
void ldv_linux_kernel_locking_mutex_mutex_lock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) ;
#line 399
void ldv_linux_kernel_locking_mutex_mutex_unlock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) ;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/export.h"
extern struct module __this_module ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bitops/find.h"
static unsigned long ldv_find_next_bit_5(unsigned long const   *addr , unsigned long size ,
                                         unsigned long offset ) ;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned long __arch_hweight64(__u64 w ) 
{ 
  unsigned long res ;

  {
#line 47
  res = 0UL;
#line 53
  __asm__  ("661:\n\tcall __sw_hweight64\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 4*32+23)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0xf3,0x48,0x0f,0xb8,0xc7\n6641:\n\t.popsection": "=a" (res): "D" (w));
#line 58
  return (res);
}
}
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void might_fault(void) ;
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
extern void list_del(struct list_head * ) ;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 295 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-defs.h"
extern void __bad_size_call_parameter(void) ;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/percpu.h"
extern unsigned long __per_cpu_offset[8192U] ;
#line 554 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/percpu.h"
extern unsigned long this_cpu_off ;
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  {
#line 14
  if (8UL == 1UL) {
#line 14
    goto case_1;
  } else {

  }
#line 14
  if (8UL == 2UL) {
#line 14
    goto case_2;
  } else {

  }
#line 14
  if (8UL == 4UL) {
#line 14
    goto case_4;
  } else {

  }
#line 14
  if (8UL == 8UL) {
#line 14
    goto case_8;
  } else {

  }
#line 14
  goto switch_default;
  case_1: /* CIL Label */ 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3550;
  case_2: /* CIL Label */ 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3550;
  case_4: /* CIL Label */ 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3550;
  case_8: /* CIL Label */ 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3550;
  switch_default: /* CIL Label */ 
  {
#line 14
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_3550: ;
#line 14
  return (pfo_ret__);
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern void *__memset(void * , int  , size_t  ) ;
#line 112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
extern int __bitmap_weight(unsigned long const   * , unsigned int  ) ;
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
__inline static int bitmap_weight(unsigned long const   *src , unsigned int nbits ) 
{ 
  int tmp___0 ;

  {
  {
#line 306
  tmp___0 = __bitmap_weight(src, nbits);
  }
#line 306
  return (tmp___0);
}
}
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 88
extern struct cpumask  const  * const  cpu_online_mask ;
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
__inline static unsigned int cpumask_check(unsigned int cpu ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 116
  __ret_warn_once = cpu >= (unsigned int )nr_cpu_ids;
#line 116
  tmp___1 = __builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 116
  if (tmp___1 != 0L) {
    {
#line 116
    __ret_warn_on = ! __warned;
#line 116
    tmp = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 116
    if (tmp != 0L) {
      {
#line 116
      warn_slowpath_null("include/linux/cpumask.h", 116);
      }
    } else {

    }
    {
#line 116
    tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
    }
#line 116
    if (tmp___0 != 0L) {
#line 116
      __warned = 1;
    } else {

    }
  } else {

  }
  {
#line 116
  __builtin_expect(__ret_warn_once != 0, 0L);
  }
#line 118
  return (cpu);
}
}
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
__inline static unsigned int cpumask_next(int n , struct cpumask  const  *srcp ) 
{ 
  unsigned long tmp ;

  {
#line 188
  if (n != -1) {
    {
#line 189
    cpumask_check((unsigned int )n);
    }
  } else {

  }
  {
#line 190
  tmp = ldv_find_next_bit_5((unsigned long const   *)(& srcp->bits), (unsigned long )nr_cpu_ids,
                            (unsigned long )(n + 1));
  }
#line 190
  return ((unsigned int )tmp);
}
}
#line 475 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
__inline static unsigned int cpumask_weight(struct cpumask  const  *srcp ) 
{ 
  int tmp ;

  {
  {
#line 477
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), (unsigned int )nr_cpu_ids);
  }
#line 477
  return ((unsigned int )tmp);
}
}
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
extern int ( /* missing proto */  __builtin_unreachable)() ;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_inc(atomic64_t *v ) 
{ 


  {
#line 86
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incq %0": "=m" (v->counter): "m" (v->counter));
#line 89
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
__inline static void atomic_long_inc(atomic_long_t *l ) 
{ 
  atomic64_t *v ;

  {
  {
#line 43
  v = l;
#line 45
  atomic64_inc(v);
  }
#line 46
  return;
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.h"
void ldv_switch_to_interrupt_context(void) ;
#line 42
void ldv_switch_to_process_context(void) ;
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
static void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) ;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 226 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
__inline static int __nodes_weight(nodemask_t const   *srcp , unsigned int nbits ) 
{ 
  int tmp ;

  {
  {
#line 228
  tmp = bitmap_weight((unsigned long const   *)(& srcp->bits), nbits);
  }
#line 228
  return (tmp);
}
}
#line 395
extern nodemask_t node_states[5U] ;
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
__inline static int num_node_state(enum node_states state ) 
{ 
  int tmp ;

  {
  {
#line 415
  tmp = __nodes_weight((nodemask_t const   *)(& node_states) + (unsigned long )state,
                       1024U);
  }
#line 415
  return (tmp);
}
}
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwsem.h"
extern void __init_rwsem(struct rw_semaphore * , char const   * , struct lock_class_key * ) ;
#line 118
extern void down_write(struct rw_semaphore * ) ;
#line 133
extern void up_write(struct rw_semaphore * ) ;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned long readq(void const volatile   *addr ) 
{ 
  unsigned long ret ;

  {
#line 88
  __asm__  volatile   ("movq %1,%0": "=r" (ret): "m" (*((unsigned long volatile   *)addr)): "memory");
#line 88
  return (ret);
}
}
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/smp.h"
extern int cpu_number ;
#line 55
extern u16 x86_cpu_to_apicid ;
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/memory_hotplug.h"
extern pg_data_t *node_data[] ;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/topology.h"
extern int numa_node ;
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/topology.h"
__inline static int numa_node_id(void) 
{ 
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 77
  __vpp_verify = (void const   *)0;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2___0;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4___1;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8___2;
  } else {

  }
#line 77
  goto switch_default___3;
  case_1: /* CIL Label */ ;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1___0;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8;
  } else {

  }
#line 77
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_16154;
  case_2: /* CIL Label */ 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_16154;
  case_4: /* CIL Label */ 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_16154;
  case_8: /* CIL Label */ 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (numa_node));
#line 77
  goto ldv_16154;
  switch_default: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_16154: 
#line 77
  pscr_ret__ = pfo_ret__;
#line 77
  goto ldv_16160;
  case_2___0: /* CIL Label */ ;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1___1;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2___1;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4___0;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8___0;
  } else {

  }
#line 77
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_16164;
  case_2___1: /* CIL Label */ 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_16164;
  case_4___0: /* CIL Label */ 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_16164;
  case_8___0: /* CIL Label */ 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (numa_node));
#line 77
  goto ldv_16164;
  switch_default___0: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  ldv_16164: 
#line 77
  pscr_ret__ = pfo_ret_____0;
#line 77
  goto ldv_16160;
  case_4___1: /* CIL Label */ ;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1___2;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2___2;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4___2;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8___1;
  } else {

  }
#line 77
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_16173;
  case_2___2: /* CIL Label */ 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_16173;
  case_4___2: /* CIL Label */ 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_16173;
  case_8___1: /* CIL Label */ 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (numa_node));
#line 77
  goto ldv_16173;
  switch_default___1: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  ldv_16173: 
#line 77
  pscr_ret__ = pfo_ret_____1;
#line 77
  goto ldv_16160;
  case_8___2: /* CIL Label */ ;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1___3;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2___3;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4___3;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8___3;
  } else {

  }
#line 77
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
#line 77
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_16182;
  case_2___3: /* CIL Label */ 
#line 77
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_16182;
  case_4___3: /* CIL Label */ 
#line 77
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_16182;
  case_8___3: /* CIL Label */ 
#line 77
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (numa_node));
#line 77
  goto ldv_16182;
  switch_default___2: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  ldv_16182: 
#line 77
  pscr_ret__ = pfo_ret_____2;
#line 77
  goto ldv_16160;
  switch_default___3: /* CIL Label */ 
  {
#line 77
  __bad_size_call_parameter();
  }
#line 77
  goto ldv_16160;
  switch_break: /* CIL Label */ ;
  }
  ldv_16160: ;
#line 77
  return (pscr_ret__);
}
}
#line 269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
__inline static int gfp_zonelist(gfp_t flags ) 
{ 
  long tmp ;

  {
  {
#line 271
  tmp = __builtin_expect((flags & 262144U) != 0U, 0L);
  }
#line 271
  if (tmp != 0L) {
#line 272
    return (1);
  } else {

  }
#line 274
  return (0);
}
}
#line 286 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
__inline static struct zonelist *node_zonelist(int nid , gfp_t flags ) 
{ 
  int tmp ;

  {
  {
#line 288
  tmp = gfp_zonelist(flags);
  }
#line 288
  return ((struct zonelist *)(& (node_data[nid])->node_zonelists) + (unsigned long )tmp);
}
}
#line 299
extern struct page *__alloc_pages_nodemask(gfp_t  , unsigned int  , struct zonelist * ,
                                           nodemask_t * ) ;
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
__inline static struct page *__alloc_pages(gfp_t gfp_mask , unsigned int order , struct zonelist *zonelist ) 
{ 
  struct page *tmp ;

  {
  {
#line 306
  tmp = __alloc_pages_nodemask(gfp_mask, order, zonelist, (nodemask_t *)0);
  }
#line 306
  return (tmp);
}
}
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
__inline static struct page *alloc_pages_node(int nid , gfp_t gfp_mask , unsigned int order ) 
{ 
  struct zonelist *tmp ;
  struct page *tmp___0 ;

  {
#line 313
  if (nid < 0) {
    {
#line 314
    nid = numa_node_id();
    }
  } else {

  }
  {
#line 316
  tmp = node_zonelist(nid, gfp_mask);
#line 316
  tmp___0 = __alloc_pages(gfp_mask, order, tmp);
  }
#line 316
  return (tmp___0);
}
}
#line 373
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 2583 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
extern loff_t noop_llseek(struct file * , loff_t  , int  ) ;
#line 976 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 978
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 645 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 647
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 667
extern void __copy_from_user_overflow(void) ;
#line 672
extern void __copy_to_user_overflow(void) ;
#line 688 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 690
  sz = -1;
#line 692
  might_fault();
#line 712
  tmp = __builtin_expect(sz < 0, 1L);
  }
#line 712
  if (tmp != 0L) {
    {
#line 713
    n = _copy_from_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 712
    tmp___0 = __builtin_expect((unsigned long )sz >= n, 1L);
    }
#line 712
    if (tmp___0 != 0L) {
      {
#line 713
      n = _copy_from_user(to, from, (unsigned int )n);
      }
    } else {
      {
#line 717
      __copy_from_user_overflow();
      }
    }
  }
#line 719
  return (n);
}
}
#line 723 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 725
  sz = -1;
#line 727
  might_fault();
#line 730
  tmp = __builtin_expect(sz < 0, 1L);
  }
#line 730
  if (tmp != 0L) {
    {
#line 731
    n = _copy_to_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 730
    tmp___0 = __builtin_expect((unsigned long )sz >= n, 1L);
    }
#line 730
    if (tmp___0 != 0L) {
      {
#line 731
      n = _copy_to_user(to, from, (unsigned int )n);
      }
    } else {
      {
#line 735
      __copy_to_user_overflow();
      }
    }
  }
#line 737
  return (n);
}
}
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/miscdevice.h"
extern int misc_register(struct miscdevice * ) ;
#line 70
static int ldv_misc_register_99(struct miscdevice *ldv_func_arg1 ) ;
#line 72
extern int misc_deregister(struct miscdevice * ) ;
#line 75
static int ldv_misc_deregister_100(struct miscdevice *ldv_func_arg1 ) ;
#line 79
static int ldv_misc_deregister_101(struct miscdevice *ldv_func_arg1 ) ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
  }
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_97(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 149
static void ldv_free_irq_98(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_irq.h"
extern int uv_setup_irq(char * , int  , int  , unsigned long  , int  ) ;
#line 36
extern void uv_teardown_irq(unsigned int  ) ;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv.h"
extern int is_uv_system(void) ;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static unsigned long gru_chiplet_paddr(unsigned long paddr , int pnode ,
                                                int chiplet ) 
{ 


  {
#line 159
  return (paddr + (unsigned long )(pnode * 2 + chiplet) * 134217728UL);
}
}
#line 162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static void *gru_chiplet_vaddr(void *vaddr , int pnode , int chiplet ) 
{ 


  {
#line 164
  return (vaddr + (unsigned long )(pnode * 2 + chiplet) * 134217728UL);
}
}
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_stats_s gru_stats  ;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct gru_blade_state *gru_base[1024U]  ;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
unsigned long gru_start_paddr  ;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
unsigned long gru_end_paddr  ;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
void *gru_start_vaddr  ;
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
unsigned int gru_max_gids  ;
#line 626
struct vm_operations_struct  const  gru_vm_ops ;
#line 629
struct gru_vma_data *gru_alloc_vma_data(struct vm_area_struct *vma , int tsid ) ;
#line 638
void gru_unload_context(struct gru_thread_state *gts , int savestate ) ;
#line 640
void gts_drop(struct gru_thread_state *gts ) ;
#line 641
void gru_tgh_flush_init(struct gru_state *gru ) ;
#line 642
int gru_kservices_init(void) ;
#line 643
void gru_kservices_exit(void) ;
#line 644
irqreturn_t gru0_intr(int irq , void *dev_id ) ;
#line 645
irqreturn_t gru1_intr(int irq , void *dev_id ) ;
#line 646
irqreturn_t gru_intr_mblade(int irq , void *dev_id ) ;
#line 647
int gru_dump_chiplet_request(unsigned long arg ) ;
#line 648
long gru_get_gseg_statistics(unsigned long arg ) ;
#line 649
int gru_handle_user_call_os(unsigned long cb ) ;
#line 650
int gru_user_flush_tlb(unsigned long arg ) ;
#line 651
int gru_user_unload_context(unsigned long arg ) ;
#line 652
int gru_get_exception_detail(unsigned long arg ) ;
#line 653
int gru_set_context_option(unsigned long arg ) ;
#line 656
struct vm_area_struct *gru_find_vma(unsigned long vaddr ) ;
#line 658
int gru_proc_init(void) ;
#line 659
void gru_proc_exit(void) ;
#line 668
int gru_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
#line 672
int gru_ktest(unsigned long arg ) ;
#line 676
unsigned long gru_options ;
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
extern struct uv_hub_info_s __uv_hub_info ;
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int is_uv1_hub(void) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 182
  __vpp_verify = (void const   *)0;
#line 182
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 182
  return ((unsigned int )((struct uv_hub_info_s *)tcp_ptr__)->hub_revision <= 2U);
}
}
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int is_uv2_hub(void) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;
  void const   *__vpp_verify___0 ;
  unsigned long tcp_ptr_____0 ;
  int tmp ;

  {
#line 187
  __vpp_verify = (void const   *)0;
#line 187
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 188
  if ((unsigned int )((struct uv_hub_info_s *)tcp_ptr__)->hub_revision > 2U) {
#line 188
    __vpp_verify___0 = (void const   *)0;
#line 188
    __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____0): "m" (this_cpu_off),
                         "0" (& __uv_hub_info));
#line 188
    if ((unsigned int )((struct uv_hub_info_s *)tcp_ptr_____0)->hub_revision <= 4U) {
#line 188
      tmp = 1;
    } else {
#line 188
      tmp = 0;
    }
  } else {
#line 188
    tmp = 0;
  }
#line 187
  return (tmp);
}
}
#line 461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long *uv_local_mmr_address(unsigned long offset ) 
{ 
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 463
  tmp___1 = is_uv1_hub();
  }
#line 463
  if (tmp___1 == 0) {
    {
#line 463
    is_uv2_hub();
#line 463
    tmp___0 = 4194304000UL;
    }
  } else {
#line 463
    tmp___0 = 4093640704UL;
  }
#line 463
  return ((unsigned long *)((tmp___0 | offset) + 0xffff880000000000UL));
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_read_local_mmr(unsigned long offset ) 
{ 
  unsigned long *tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 468
  tmp = uv_local_mmr_address(offset);
#line 468
  tmp___0 = readq((void const volatile   *)tmp);
  }
#line 468
  return (tmp___0);
}
}
#line 498
extern struct uv_blade_info *uv_blade_info ;
#line 499
extern short *uv_node_to_blade ;
#line 500
extern short *uv_cpu_to_blade ;
#line 501
extern short uv_possible_blades ;
#line 516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_cpu_to_blade_id(int cpu ) 
{ 


  {
#line 518
  return ((int )*(uv_cpu_to_blade + (unsigned long )cpu));
}
}
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_node_to_blade_id(int nid ) 
{ 


  {
#line 524
  return ((int )*(uv_node_to_blade + (unsigned long )nid));
}
}
#line 528 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_to_pnode(int bid ) 
{ 


  {
#line 530
  return ((int )(uv_blade_info + (unsigned long )bid)->pnode);
}
}
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_to_memory_nid(int bid ) 
{ 


  {
#line 536
  return ((int )(uv_blade_info + (unsigned long )bid)->memory_nid);
}
}
#line 540 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_nr_possible_cpus(int bid ) 
{ 


  {
#line 542
  return ((int )(uv_blade_info + (unsigned long )bid)->nr_possible_cpus);
}
}
#line 564 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_num_possible_blades(void) 
{ 


  {
#line 566
  return ((int )uv_possible_blades);
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int max_user_cbrs  ;
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int max_user_dsr_bytes  ;
#line 59
static struct miscdevice gru_miscdev ;
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int gru_supported(void) 
{ 
  int tmp ;
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;
  int tmp___0 ;

  {
  {
#line 63
  tmp = is_uv_system();
  }
#line 64
  if (tmp != 0) {
#line 64
    __vpp_verify = (void const   *)0;
#line 64
    __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off),
                         "0" (& __uv_hub_info));
#line 64
    if ((unsigned int )((struct uv_hub_info_s *)tcp_ptr__)->hub_revision <= 4U) {
#line 64
      tmp___0 = 1;
    } else {
#line 64
      tmp___0 = 0;
    }
  } else {
#line 64
    tmp___0 = 0;
  }
#line 63
  return (tmp___0);
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static void gru_vma_close(struct vm_area_struct *vma ) 
{ 
  struct gru_vma_data *vdata ;
  struct gru_thread_state *gts ;
  struct list_head *entry ;
  struct list_head *next ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct list_head  const  *__mptr ;

  {
#line 79
  if ((unsigned long )vma->vm_private_data == (unsigned long )((void *)0)) {
#line 80
    return;
  } else {

  }
#line 82
  vdata = (struct gru_vma_data *)vma->vm_private_data;
#line 83
  vma->vm_private_data = (void *)0;
#line 84
  if ((int )gru_options & 1) {
#line 84
    __vpp_verify = (void const   *)0;
    {
#line 84
    if (4UL == 1UL) {
#line 84
      goto case_1;
    } else {

    }
#line 85
    if (4UL == 2UL) {
#line 85
      goto case_2___0;
    } else {

    }
#line 85
    if (4UL == 4UL) {
#line 85
      goto case_4___1;
    } else {

    }
#line 85
    if (4UL == 8UL) {
#line 85
      goto case_8___2;
    } else {

    }
#line 85
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 85
    if (4UL == 1UL) {
#line 85
      goto case_1___0;
    } else {

    }
#line 85
    if (4UL == 2UL) {
#line 85
      goto case_2;
    } else {

    }
#line 85
    if (4UL == 4UL) {
#line 85
      goto case_4;
    } else {

    }
#line 85
    if (4UL == 8UL) {
#line 85
      goto case_8;
    } else {

    }
#line 85
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 85
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 85
    goto ldv_34503;
    case_2: /* CIL Label */ 
#line 85
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 85
    goto ldv_34503;
    case_4: /* CIL Label */ 
#line 85
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 85
    goto ldv_34503;
    case_8: /* CIL Label */ 
#line 85
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 85
    goto ldv_34503;
    switch_default: /* CIL Label */ 
    {
#line 85
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34503: 
#line 85
    pscr_ret__ = pfo_ret__;
#line 85
    goto ldv_34509;
    case_2___0: /* CIL Label */ ;
    {
#line 85
    if (4UL == 1UL) {
#line 85
      goto case_1___1;
    } else {

    }
#line 85
    if (4UL == 2UL) {
#line 85
      goto case_2___1;
    } else {

    }
#line 85
    if (4UL == 4UL) {
#line 85
      goto case_4___0;
    } else {

    }
#line 85
    if (4UL == 8UL) {
#line 85
      goto case_8___0;
    } else {

    }
#line 85
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 85
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 85
    goto ldv_34513;
    case_2___1: /* CIL Label */ 
#line 85
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 85
    goto ldv_34513;
    case_4___0: /* CIL Label */ 
#line 85
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 85
    goto ldv_34513;
    case_8___0: /* CIL Label */ 
#line 85
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 85
    goto ldv_34513;
    switch_default___0: /* CIL Label */ 
    {
#line 85
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34513: 
#line 85
    pscr_ret__ = pfo_ret_____0;
#line 85
    goto ldv_34509;
    case_4___1: /* CIL Label */ ;
    {
#line 85
    if (4UL == 1UL) {
#line 85
      goto case_1___2;
    } else {

    }
#line 85
    if (4UL == 2UL) {
#line 85
      goto case_2___2;
    } else {

    }
#line 85
    if (4UL == 4UL) {
#line 85
      goto case_4___2;
    } else {

    }
#line 85
    if (4UL == 8UL) {
#line 85
      goto case_8___1;
    } else {

    }
#line 85
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 85
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 85
    goto ldv_34522;
    case_2___2: /* CIL Label */ 
#line 85
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 85
    goto ldv_34522;
    case_4___2: /* CIL Label */ 
#line 85
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 85
    goto ldv_34522;
    case_8___1: /* CIL Label */ 
#line 85
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 85
    goto ldv_34522;
    switch_default___1: /* CIL Label */ 
    {
#line 85
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34522: 
#line 85
    pscr_ret__ = pfo_ret_____1;
#line 85
    goto ldv_34509;
    case_8___2: /* CIL Label */ ;
    {
#line 85
    if (4UL == 1UL) {
#line 85
      goto case_1___3;
    } else {

    }
#line 85
    if (4UL == 2UL) {
#line 85
      goto case_2___3;
    } else {

    }
#line 85
    if (4UL == 4UL) {
#line 85
      goto case_4___3;
    } else {

    }
#line 85
    if (4UL == 8UL) {
#line 85
      goto case_8___3;
    } else {

    }
#line 85
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 85
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 85
    goto ldv_34531;
    case_2___3: /* CIL Label */ 
#line 85
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 85
    goto ldv_34531;
    case_4___3: /* CIL Label */ 
#line 85
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 85
    goto ldv_34531;
    case_8___3: /* CIL Label */ 
#line 85
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 85
    goto ldv_34531;
    switch_default___2: /* CIL Label */ 
    {
#line 85
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34531: 
#line 85
    pscr_ret__ = pfo_ret_____2;
#line 85
    goto ldv_34509;
    switch_default___3: /* CIL Label */ 
    {
#line 85
    __bad_size_call_parameter();
    }
#line 85
    goto ldv_34509;
    switch_break: /* CIL Label */ ;
    }
    ldv_34509: 
    {
#line 85
    printk("\017GRU:%d %s: vma %p, file %p, vdata %p\n", pscr_ret__, "gru_vma_close",
           vma, vma->vm_file, vdata);
    }
  } else {

  }
#line 86
  entry = vdata->vd_head.next;
#line 86
  next = entry->next;
#line 86
  goto ldv_34543;
  ldv_34542: 
  {
#line 88
  __mptr = (struct list_head  const  *)entry;
#line 88
  gts = (struct gru_thread_state *)__mptr;
#line 89
  list_del(& gts->ts_next);
#line 90
  ldv_mutex_lock_95(& gts->ts_ctxlock);
  }
#line 91
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0)) {
    {
#line 92
    gru_unload_context(gts, 0);
    }
  } else {

  }
  {
#line 93
  ldv_mutex_unlock_96(& gts->ts_ctxlock);
#line 94
  gts_drop(gts);
#line 86
  entry = next;
#line 86
  next = entry->next;
  }
  ldv_34543: ;
#line 86
  if ((unsigned long )entry != (unsigned long )(& vdata->vd_head)) {
#line 88
    goto ldv_34542;
  } else {

  }
  {
#line 96
  kfree((void const   *)vdata);
  }
#line 97
  if ((gru_options & 2UL) != 0UL) {
    {
#line 97
    atomic_long_inc(& gru_stats.vdata_free);
    }
  } else {

  }
#line 98
  return;
}
}
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int gru_file_mmap(struct file *file , struct vm_area_struct *vma ) 
{ 
  pgprot_t __constr_expr_0 ;
  struct gru_vma_data *tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 109
  if ((vma->vm_flags & 10UL) != 10UL) {
#line 110
    return (-1);
  } else {

  }
#line 112
  if ((vma->vm_start & 262143UL) != 0UL || (vma->vm_end & 262143UL) != 0UL) {
#line 114
    return (-22);
  } else {

  }
  {
#line 116
  vma->vm_flags = vma->vm_flags | 67527680UL;
#line 118
  __constr_expr_0.pgprot = 0x8000000000000027UL;
#line 118
  vma->vm_page_prot = __constr_expr_0;
#line 119
  vma->vm_ops = & gru_vm_ops;
#line 121
  tmp = gru_alloc_vma_data(vma, 0);
#line 121
  vma->vm_private_data = (void *)tmp;
  }
#line 122
  if ((unsigned long )vma->vm_private_data == (unsigned long )((void *)0)) {
#line 123
    return (-12);
  } else {

  }
#line 125
  if ((int )gru_options & 1) {
#line 125
    __vpp_verify = (void const   *)0;
    {
#line 125
    if (4UL == 1UL) {
#line 125
      goto case_1;
    } else {

    }
#line 126
    if (4UL == 2UL) {
#line 126
      goto case_2___0;
    } else {

    }
#line 126
    if (4UL == 4UL) {
#line 126
      goto case_4___1;
    } else {

    }
#line 126
    if (4UL == 8UL) {
#line 126
      goto case_8___2;
    } else {

    }
#line 126
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 126
    if (4UL == 1UL) {
#line 126
      goto case_1___0;
    } else {

    }
#line 126
    if (4UL == 2UL) {
#line 126
      goto case_2;
    } else {

    }
#line 126
    if (4UL == 4UL) {
#line 126
      goto case_4;
    } else {

    }
#line 126
    if (4UL == 8UL) {
#line 126
      goto case_8;
    } else {

    }
#line 126
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 126
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 126
    goto ldv_34555;
    case_2: /* CIL Label */ 
#line 126
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 126
    goto ldv_34555;
    case_4: /* CIL Label */ 
#line 126
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 126
    goto ldv_34555;
    case_8: /* CIL Label */ 
#line 126
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 126
    goto ldv_34555;
    switch_default: /* CIL Label */ 
    {
#line 126
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34555: 
#line 126
    pscr_ret__ = pfo_ret__;
#line 126
    goto ldv_34561;
    case_2___0: /* CIL Label */ ;
    {
#line 126
    if (4UL == 1UL) {
#line 126
      goto case_1___1;
    } else {

    }
#line 126
    if (4UL == 2UL) {
#line 126
      goto case_2___1;
    } else {

    }
#line 126
    if (4UL == 4UL) {
#line 126
      goto case_4___0;
    } else {

    }
#line 126
    if (4UL == 8UL) {
#line 126
      goto case_8___0;
    } else {

    }
#line 126
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 126
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 126
    goto ldv_34565;
    case_2___1: /* CIL Label */ 
#line 126
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 126
    goto ldv_34565;
    case_4___0: /* CIL Label */ 
#line 126
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 126
    goto ldv_34565;
    case_8___0: /* CIL Label */ 
#line 126
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 126
    goto ldv_34565;
    switch_default___0: /* CIL Label */ 
    {
#line 126
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34565: 
#line 126
    pscr_ret__ = pfo_ret_____0;
#line 126
    goto ldv_34561;
    case_4___1: /* CIL Label */ ;
    {
#line 126
    if (4UL == 1UL) {
#line 126
      goto case_1___2;
    } else {

    }
#line 126
    if (4UL == 2UL) {
#line 126
      goto case_2___2;
    } else {

    }
#line 126
    if (4UL == 4UL) {
#line 126
      goto case_4___2;
    } else {

    }
#line 126
    if (4UL == 8UL) {
#line 126
      goto case_8___1;
    } else {

    }
#line 126
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 126
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 126
    goto ldv_34574;
    case_2___2: /* CIL Label */ 
#line 126
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 126
    goto ldv_34574;
    case_4___2: /* CIL Label */ 
#line 126
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 126
    goto ldv_34574;
    case_8___1: /* CIL Label */ 
#line 126
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 126
    goto ldv_34574;
    switch_default___1: /* CIL Label */ 
    {
#line 126
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34574: 
#line 126
    pscr_ret__ = pfo_ret_____1;
#line 126
    goto ldv_34561;
    case_8___2: /* CIL Label */ ;
    {
#line 126
    if (4UL == 1UL) {
#line 126
      goto case_1___3;
    } else {

    }
#line 126
    if (4UL == 2UL) {
#line 126
      goto case_2___3;
    } else {

    }
#line 126
    if (4UL == 4UL) {
#line 126
      goto case_4___3;
    } else {

    }
#line 126
    if (4UL == 8UL) {
#line 126
      goto case_8___3;
    } else {

    }
#line 126
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 126
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 126
    goto ldv_34583;
    case_2___3: /* CIL Label */ 
#line 126
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 126
    goto ldv_34583;
    case_4___3: /* CIL Label */ 
#line 126
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 126
    goto ldv_34583;
    case_8___3: /* CIL Label */ 
#line 126
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 126
    goto ldv_34583;
    switch_default___2: /* CIL Label */ 
    {
#line 126
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34583: 
#line 126
    pscr_ret__ = pfo_ret_____2;
#line 126
    goto ldv_34561;
    switch_default___3: /* CIL Label */ 
    {
#line 126
    __bad_size_call_parameter();
    }
#line 126
    goto ldv_34561;
    switch_break: /* CIL Label */ ;
    }
    ldv_34561: 
    {
#line 126
    printk("\017GRU:%d %s: file %p, vaddr 0x%lx, vma %p, vdata %p\n", pscr_ret__,
           "gru_file_mmap", file, vma->vm_start, vma, vma->vm_private_data);
    }
  } else {

  }
#line 127
  return (0);
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int gru_create_new_context(unsigned long arg ) 
{ 
  struct gru_create_context_req req ;
  struct vm_area_struct *vma ;
  struct gru_vma_data *vdata ;
  int ret ;
  unsigned long tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;

  {
  {
#line 138
  ret = -22;
#line 140
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 32UL);
  }
#line 140
  if (tmp != 0UL) {
#line 141
    return (-14);
  } else {

  }
#line 143
  if (req.data_segment_bytes > (unsigned int )max_user_dsr_bytes) {
#line 144
    return (-22);
  } else {

  }
#line 145
  if (req.control_blocks > (unsigned int )max_user_cbrs || req.maximum_thread_count == 0U) {
#line 146
    return (-22);
  } else {

  }
#line 148
  if ((req.options & 3U) == 0U) {
#line 149
    req.options = req.options | 2U;
  } else {

  }
  {
#line 151
  tmp___0 = get_current();
#line 151
  down_write(& (tmp___0->mm)->mmap_sem);
#line 152
  vma = gru_find_vma(req.gseg);
  }
#line 153
  if ((unsigned long )vma != (unsigned long )((struct vm_area_struct *)0)) {
#line 154
    vdata = (struct gru_vma_data *)vma->vm_private_data;
#line 155
    vdata->vd_user_options = (long )req.options;
#line 156
    vdata->vd_dsr_au_count = (int )((req.data_segment_bytes + 1023U) / 1024U);
#line 158
    vdata->vd_cbr_au_count = (int )((req.control_blocks + 1U) / 2U);
#line 159
    vdata->vd_tlb_preload_count = req.tlb_preload_count;
#line 160
    ret = 0;
  } else {

  }
  {
#line 162
  tmp___1 = get_current();
#line 162
  up_write(& (tmp___1->mm)->mmap_sem);
  }
#line 164
  return (ret);
}
}
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static long gru_get_config_info(unsigned long arg ) 
{ 
  struct gru_config_info info ;
  int nodesperblade ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 175
  tmp = num_node_state(1);
  }
#line 175
  if (tmp > 1) {
    {
#line 175
    tmp___0 = uv_node_to_blade_id(1);
#line 175
    tmp___1 = uv_node_to_blade_id(0);
    }
#line 175
    if (tmp___0 == tmp___1) {
#line 177
      nodesperblade = 2;
    } else {
#line 179
      nodesperblade = 1;
    }
  } else {
#line 179
    nodesperblade = 1;
  }
  {
#line 180
  __memset((void *)(& info), 0, 80UL);
#line 181
  tmp___2 = cpumask_weight(cpu_online_mask);
#line 181
  info.cpus = (int )tmp___2;
#line 182
  info.nodes = num_node_state(1);
#line 183
  info.blades = info.nodes / nodesperblade;
#line 184
  info.chiplets = info.blades * 2;
#line 186
  tmp___3 = copy_to_user((void *)arg, (void const   *)(& info), 80UL);
  }
#line 186
  if (tmp___3 != 0UL) {
#line 187
    return (-14L);
  } else {

  }
#line 188
  return (0L);
}
}
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static long gru_file_unlocked_ioctl(struct file *file , unsigned int req , unsigned long arg ) 
{ 
  int err ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  long tmp ;
  long tmp___0 ;

  {
#line 199
  err = -56;
#line 201
  if ((int )gru_options & 1) {
#line 201
    __vpp_verify = (void const   *)0;
    {
#line 201
    if (4UL == 1UL) {
#line 201
      goto case_1;
    } else {

    }
#line 201
    if (4UL == 2UL) {
#line 201
      goto case_2___0;
    } else {

    }
#line 201
    if (4UL == 4UL) {
#line 201
      goto case_4___1;
    } else {

    }
#line 201
    if (4UL == 8UL) {
#line 201
      goto case_8___2;
    } else {

    }
#line 201
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 201
    if (4UL == 1UL) {
#line 201
      goto case_1___0;
    } else {

    }
#line 201
    if (4UL == 2UL) {
#line 201
      goto case_2;
    } else {

    }
#line 201
    if (4UL == 4UL) {
#line 201
      goto case_4;
    } else {

    }
#line 201
    if (4UL == 8UL) {
#line 201
      goto case_8;
    } else {

    }
#line 201
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 201
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 201
    goto ldv_34615;
    case_2: /* CIL Label */ 
#line 201
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 201
    goto ldv_34615;
    case_4: /* CIL Label */ 
#line 201
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 201
    goto ldv_34615;
    case_8: /* CIL Label */ 
#line 201
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 201
    goto ldv_34615;
    switch_default: /* CIL Label */ 
    {
#line 201
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34615: 
#line 201
    pscr_ret__ = pfo_ret__;
#line 201
    goto ldv_34621;
    case_2___0: /* CIL Label */ ;
    {
#line 201
    if (4UL == 1UL) {
#line 201
      goto case_1___1;
    } else {

    }
#line 201
    if (4UL == 2UL) {
#line 201
      goto case_2___1;
    } else {

    }
#line 201
    if (4UL == 4UL) {
#line 201
      goto case_4___0;
    } else {

    }
#line 201
    if (4UL == 8UL) {
#line 201
      goto case_8___0;
    } else {

    }
#line 201
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 201
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 201
    goto ldv_34625;
    case_2___1: /* CIL Label */ 
#line 201
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 201
    goto ldv_34625;
    case_4___0: /* CIL Label */ 
#line 201
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 201
    goto ldv_34625;
    case_8___0: /* CIL Label */ 
#line 201
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 201
    goto ldv_34625;
    switch_default___0: /* CIL Label */ 
    {
#line 201
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34625: 
#line 201
    pscr_ret__ = pfo_ret_____0;
#line 201
    goto ldv_34621;
    case_4___1: /* CIL Label */ ;
    {
#line 201
    if (4UL == 1UL) {
#line 201
      goto case_1___2;
    } else {

    }
#line 201
    if (4UL == 2UL) {
#line 201
      goto case_2___2;
    } else {

    }
#line 201
    if (4UL == 4UL) {
#line 201
      goto case_4___2;
    } else {

    }
#line 201
    if (4UL == 8UL) {
#line 201
      goto case_8___1;
    } else {

    }
#line 201
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 201
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 201
    goto ldv_34634;
    case_2___2: /* CIL Label */ 
#line 201
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 201
    goto ldv_34634;
    case_4___2: /* CIL Label */ 
#line 201
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 201
    goto ldv_34634;
    case_8___1: /* CIL Label */ 
#line 201
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 201
    goto ldv_34634;
    switch_default___1: /* CIL Label */ 
    {
#line 201
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34634: 
#line 201
    pscr_ret__ = pfo_ret_____1;
#line 201
    goto ldv_34621;
    case_8___2: /* CIL Label */ ;
    {
#line 201
    if (4UL == 1UL) {
#line 201
      goto case_1___3;
    } else {

    }
#line 201
    if (4UL == 2UL) {
#line 201
      goto case_2___3;
    } else {

    }
#line 201
    if (4UL == 4UL) {
#line 201
      goto case_4___3;
    } else {

    }
#line 201
    if (4UL == 8UL) {
#line 201
      goto case_8___3;
    } else {

    }
#line 201
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 201
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 201
    goto ldv_34643;
    case_2___3: /* CIL Label */ 
#line 201
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 201
    goto ldv_34643;
    case_4___3: /* CIL Label */ 
#line 201
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 201
    goto ldv_34643;
    case_8___3: /* CIL Label */ 
#line 201
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 201
    goto ldv_34643;
    switch_default___2: /* CIL Label */ 
    {
#line 201
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34643: 
#line 201
    pscr_ret__ = pfo_ret_____2;
#line 201
    goto ldv_34621;
    switch_default___3: /* CIL Label */ 
    {
#line 201
    __bad_size_call_parameter();
    }
#line 201
    goto ldv_34621;
    switch_break: /* CIL Label */ ;
    }
    ldv_34621: 
    {
#line 201
    printk("\017GRU:%d %s: file %p, req 0x%x, 0x%lx\n", pscr_ret__, "gru_file_unlocked_ioctl",
           file, req, arg);
    }
  } else {

  }
  {
#line 204
  if (req == 3221767937U) {
#line 204
    goto case_3221767937;
  } else {

  }
#line 207
  if (req == 3221767940U) {
#line 207
    goto case_3221767940;
  } else {

  }
#line 210
  if (req == 3221767942U) {
#line 210
    goto case_3221767942;
  } else {

  }
#line 213
  if (req == 3221767945U) {
#line 213
    goto case_3221767945;
  } else {

  }
#line 216
  if (req == 3221767986U) {
#line 216
    goto case_3221767986;
  } else {

  }
#line 219
  if (req == 3221767944U) {
#line 219
    goto case_3221767944;
  } else {

  }
#line 222
  if (req == 3221767948U) {
#line 222
    goto case_3221767948;
  } else {

  }
#line 225
  if (req == 3221767988U) {
#line 225
    goto case_3221767988;
  } else {

  }
#line 228
  if (req == 3221767987U) {
#line 228
    goto case_3221767987;
  } else {

  }
#line 231
  if (req == 3221767947U) {
#line 231
    goto case_3221767947;
  } else {

  }
#line 203
  goto switch_break___4;
  case_3221767937: /* CIL Label */ 
  {
#line 205
  err = gru_create_new_context(arg);
  }
#line 206
  goto ldv_34653;
  case_3221767940: /* CIL Label */ 
  {
#line 208
  err = gru_set_context_option(arg);
  }
#line 209
  goto ldv_34653;
  case_3221767942: /* CIL Label */ 
  {
#line 211
  err = gru_get_exception_detail(arg);
  }
#line 212
  goto ldv_34653;
  case_3221767945: /* CIL Label */ 
  {
#line 214
  err = gru_user_unload_context(arg);
  }
#line 215
  goto ldv_34653;
  case_3221767986: /* CIL Label */ 
  {
#line 217
  err = gru_user_flush_tlb(arg);
  }
#line 218
  goto ldv_34653;
  case_3221767944: /* CIL Label */ 
  {
#line 220
  err = gru_handle_user_call_os(arg);
  }
#line 221
  goto ldv_34653;
  case_3221767948: /* CIL Label */ 
  {
#line 223
  tmp = gru_get_gseg_statistics(arg);
#line 223
  err = (int )tmp;
  }
#line 224
  goto ldv_34653;
  case_3221767988: /* CIL Label */ 
  {
#line 226
  err = gru_ktest(arg);
  }
#line 227
  goto ldv_34653;
  case_3221767987: /* CIL Label */ 
  {
#line 229
  tmp___0 = gru_get_config_info(arg);
#line 229
  err = (int )tmp___0;
  }
#line 230
  goto ldv_34653;
  case_3221767947: /* CIL Label */ 
  {
#line 232
  err = gru_dump_chiplet_request(arg);
  }
#line 233
  goto ldv_34653;
  switch_break___4: /* CIL Label */ ;
  }
  ldv_34653: ;
#line 235
  return ((long )err);
}
}
#line 242 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static void gru_init_chiplet(struct gru_state *gru , unsigned long paddr , void *vaddr ,
                             int blade_id , int chiplet_id ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 245
  spinlock_check(& gru->gs_lock);
#line 245
  __raw_spin_lock_init(& gru->gs_lock.__annonCompField18.rlock, "&(&gru->gs_lock)->rlock",
                       & __key);
#line 246
  spinlock_check(& gru->gs_asid_lock);
#line 246
  __raw_spin_lock_init(& gru->gs_asid_lock.__annonCompField18.rlock, "&(&gru->gs_asid_lock)->rlock",
                       & __key___0);
#line 247
  gru->gs_gru_base_paddr = paddr;
#line 248
  gru->gs_gru_base_vaddr = vaddr;
#line 249
  gru->gs_gid = (unsigned int )((unsigned short )blade_id) * 2U + (unsigned int )((unsigned short )chiplet_id);
#line 250
  gru->gs_blade = gru_base[blade_id];
#line 251
  gru->gs_blade_id = (unsigned short )blade_id;
#line 252
  gru->gs_chiplet_id = (unsigned char )chiplet_id;
#line 253
  gru->gs_cbr_map = 0xffffffffffffffffUL;
#line 254
  gru->gs_dsr_map = 4294967295UL;
#line 255
  gru->gs_asid_limit = 16777200U;
#line 256
  gru_tgh_flush_init(gru);
  }
#line 257
  if ((unsigned int )gru->gs_gid >= gru_max_gids) {
#line 258
    gru_max_gids = (unsigned int )((int )gru->gs_gid + 1);
  } else {

  }
#line 259
  if ((int )gru_options & 1) {
#line 259
    __vpp_verify = (void const   *)0;
    {
#line 259
    if (4UL == 1UL) {
#line 259
      goto case_1;
    } else {

    }
#line 261
    if (4UL == 2UL) {
#line 261
      goto case_2___0;
    } else {

    }
#line 261
    if (4UL == 4UL) {
#line 261
      goto case_4___1;
    } else {

    }
#line 261
    if (4UL == 8UL) {
#line 261
      goto case_8___2;
    } else {

    }
#line 261
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 261
    if (4UL == 1UL) {
#line 261
      goto case_1___0;
    } else {

    }
#line 261
    if (4UL == 2UL) {
#line 261
      goto case_2;
    } else {

    }
#line 261
    if (4UL == 4UL) {
#line 261
      goto case_4;
    } else {

    }
#line 261
    if (4UL == 8UL) {
#line 261
      goto case_8;
    } else {

    }
#line 261
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 261
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 261
    goto ldv_34677;
    case_2: /* CIL Label */ 
#line 261
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 261
    goto ldv_34677;
    case_4: /* CIL Label */ 
#line 261
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 261
    goto ldv_34677;
    case_8: /* CIL Label */ 
#line 261
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 261
    goto ldv_34677;
    switch_default: /* CIL Label */ 
    {
#line 261
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34677: 
#line 261
    pscr_ret__ = pfo_ret__;
#line 261
    goto ldv_34683;
    case_2___0: /* CIL Label */ ;
    {
#line 261
    if (4UL == 1UL) {
#line 261
      goto case_1___1;
    } else {

    }
#line 261
    if (4UL == 2UL) {
#line 261
      goto case_2___1;
    } else {

    }
#line 261
    if (4UL == 4UL) {
#line 261
      goto case_4___0;
    } else {

    }
#line 261
    if (4UL == 8UL) {
#line 261
      goto case_8___0;
    } else {

    }
#line 261
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 261
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 261
    goto ldv_34687;
    case_2___1: /* CIL Label */ 
#line 261
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 261
    goto ldv_34687;
    case_4___0: /* CIL Label */ 
#line 261
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 261
    goto ldv_34687;
    case_8___0: /* CIL Label */ 
#line 261
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 261
    goto ldv_34687;
    switch_default___0: /* CIL Label */ 
    {
#line 261
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34687: 
#line 261
    pscr_ret__ = pfo_ret_____0;
#line 261
    goto ldv_34683;
    case_4___1: /* CIL Label */ ;
    {
#line 261
    if (4UL == 1UL) {
#line 261
      goto case_1___2;
    } else {

    }
#line 261
    if (4UL == 2UL) {
#line 261
      goto case_2___2;
    } else {

    }
#line 261
    if (4UL == 4UL) {
#line 261
      goto case_4___2;
    } else {

    }
#line 261
    if (4UL == 8UL) {
#line 261
      goto case_8___1;
    } else {

    }
#line 261
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 261
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 261
    goto ldv_34696;
    case_2___2: /* CIL Label */ 
#line 261
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 261
    goto ldv_34696;
    case_4___2: /* CIL Label */ 
#line 261
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 261
    goto ldv_34696;
    case_8___1: /* CIL Label */ 
#line 261
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 261
    goto ldv_34696;
    switch_default___1: /* CIL Label */ 
    {
#line 261
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34696: 
#line 261
    pscr_ret__ = pfo_ret_____1;
#line 261
    goto ldv_34683;
    case_8___2: /* CIL Label */ ;
    {
#line 261
    if (4UL == 1UL) {
#line 261
      goto case_1___3;
    } else {

    }
#line 261
    if (4UL == 2UL) {
#line 261
      goto case_2___3;
    } else {

    }
#line 261
    if (4UL == 4UL) {
#line 261
      goto case_4___3;
    } else {

    }
#line 261
    if (4UL == 8UL) {
#line 261
      goto case_8___3;
    } else {

    }
#line 261
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 261
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 261
    goto ldv_34705;
    case_2___3: /* CIL Label */ 
#line 261
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 261
    goto ldv_34705;
    case_4___3: /* CIL Label */ 
#line 261
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 261
    goto ldv_34705;
    case_8___3: /* CIL Label */ 
#line 261
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 261
    goto ldv_34705;
    switch_default___2: /* CIL Label */ 
    {
#line 261
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34705: 
#line 261
    pscr_ret__ = pfo_ret_____2;
#line 261
    goto ldv_34683;
    switch_default___3: /* CIL Label */ 
    {
#line 261
    __bad_size_call_parameter();
    }
#line 261
    goto ldv_34683;
    switch_break: /* CIL Label */ ;
    }
    ldv_34683: 
    {
#line 261
    printk("\017GRU:%d %s: bid %d, gid %d, vaddr %p (0x%lx)\n", pscr_ret__, "gru_init_chiplet",
           blade_id, (int )gru->gs_gid, gru->gs_gru_base_vaddr, gru->gs_gru_base_paddr);
    }
  } else {

  }
#line 262
  return;
}
}
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int gru_init_tables(unsigned long gru_base_paddr , void *gru_base_vaddr ) 
{ 
  int pnode ;
  int nid ;
  int bid ;
  int chip ;
  int cbrs ;
  int dsrbytes ;
  int n ;
  int order ;
  struct page *page ;
  struct gru_state *gru ;
  unsigned long paddr ;
  void *vaddr ;
  void *tmp ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  unsigned long tmp___0 ;
  int _max1 ;
  int _max2 ;
  unsigned long tmp___1 ;
  int _max1___0 ;
  int _max2___0 ;
  int _min1 ;
  int _min2 ;
  int _min1___0 ;
  int _min2___0 ;
  int tmp___2 ;

  {
#line 268
  order = 0;
#line 274
  max_user_cbrs = 128;
#line 275
  max_user_dsr_bytes = 32768;
#line 276
  bid = 0;
#line 276
  goto ldv_34749;
  ldv_34748: 
  {
#line 277
  pnode = uv_blade_to_pnode(bid);
#line 278
  nid = uv_blade_to_memory_nid(bid);
#line 279
  page = alloc_pages_node(nid, 208U, (unsigned int )order);
  }
#line 280
  if ((unsigned long )page == (unsigned long )((struct page *)0)) {
#line 281
    goto fail;
  } else {

  }
  {
#line 282
  tmp = lowmem_page_address((struct page  const  *)page);
#line 282
  gru_base[bid] = (struct gru_blade_state *)tmp;
#line 283
  __memset((void *)gru_base[bid], 0, 1136UL);
#line 284
  (gru_base[bid])->bs_lru_gru = (struct gru_state *)(& (gru_base[bid])->bs_grus);
#line 285
  spinlock_check(& (gru_base[bid])->bs_lock);
#line 285
  __raw_spin_lock_init(& (gru_base[bid])->bs_lock.__annonCompField18.rlock, "&(&gru_base[bid]->bs_lock)->rlock",
                       & __key);
#line 286
  __init_rwsem(& (gru_base[bid])->bs_kgts_sema, "&gru_base[bid]->bs_kgts_sema", & __key___0);
#line 288
  dsrbytes = 0;
#line 289
  cbrs = 0;
#line 290
  gru = (struct gru_state *)(& (gru_base[bid])->bs_grus);
#line 290
  chip = 0;
  }
#line 290
  goto ldv_34740;
  ldv_34739: 
  {
#line 293
  paddr = gru_chiplet_paddr(gru_base_paddr, pnode, chip);
#line 294
  vaddr = gru_chiplet_vaddr(gru_base_vaddr, pnode, chip);
#line 295
  gru_init_chiplet(gru, paddr, vaddr, bid, chip);
#line 296
  tmp___0 = __arch_hweight64((__u64 )gru->gs_cbr_map);
#line 296
  n = (int )((unsigned int )tmp___0 * 2U);
#line 297
  _max1 = cbrs;
#line 297
  _max2 = n;
#line 297
  cbrs = _max1 > _max2 ? _max1 : _max2;
#line 298
  tmp___1 = __arch_hweight64((__u64 )gru->gs_dsr_map);
#line 298
  n = (int )((unsigned int )tmp___1 * 1024U);
#line 299
  _max1___0 = dsrbytes;
#line 299
  _max2___0 = n;
#line 299
  dsrbytes = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
#line 292
  chip = chip + 1;
#line 292
  gru = gru + 1;
  }
  ldv_34740: ;
#line 290
  if (chip <= 1) {
#line 293
    goto ldv_34739;
  } else {

  }
#line 301
  _min1 = max_user_cbrs;
#line 301
  _min2 = cbrs;
#line 301
  max_user_cbrs = _min1 < _min2 ? _min1 : _min2;
#line 302
  _min1___0 = max_user_dsr_bytes;
#line 302
  _min2___0 = dsrbytes;
#line 302
  max_user_dsr_bytes = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
#line 276
  bid = bid + 1;
  ldv_34749: 
  {
#line 276
  tmp___2 = uv_num_possible_blades();
  }
#line 276
  if (bid < tmp___2) {
#line 278
    goto ldv_34748;
  } else {

  }

#line 305
  return (0);
  fail: 
#line 308
  bid = bid - 1;
#line 308
  goto ldv_34752;
  ldv_34751: 
  {
#line 309
  free_pages((unsigned long )gru_base[bid], (unsigned int )order);
#line 308
  bid = bid - 1;
  }
  ldv_34752: ;
#line 308
  if (bid >= 0) {
#line 310
    goto ldv_34751;
  } else {

  }

#line 310
  return (-12);
}
}
#line 313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static void gru_free_tables(void) 
{ 
  int bid ;
  int order ;

  {
#line 316
  order = 0;
#line 319
  bid = 0;
#line 319
  goto ldv_34760;
  ldv_34759: 
  {
#line 320
  free_pages((unsigned long )gru_base[bid], (unsigned int )order);
#line 319
  bid = bid + 1;
  }
  ldv_34760: ;
#line 319
  if (bid <= 1023) {
#line 321
    goto ldv_34759;
  } else {

  }

#line 326
  return;
}
}
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static unsigned long gru_chiplet_cpu_to_mmr(int chiplet , int cpu , int *corep ) 
{ 
  unsigned long mmr ;
  int core ;
  void const   *__vpp_verify ;
  unsigned long __ptr ;
  void const   *__vpp_verify___0 ;
  unsigned long __ptr___0 ;
  void const   *__vpp_verify___1 ;
  unsigned long __ptr___1 ;
  void const   *__vpp_verify___2 ;
  unsigned long __ptr___2 ;

  {
#line 325
  mmr = 0UL;
#line 334
  __vpp_verify = (void const   *)0;
#line 334
  __asm__  ("": "=r" (__ptr): "0" (& x86_cpu_to_apicid));
#line 334
  __vpp_verify___0 = (void const   *)0;
#line 334
  __asm__  ("": "=r" (__ptr___0): "0" (& x86_cpu_to_apicid));
#line 334
  __vpp_verify___1 = (void const   *)0;
#line 334
  __asm__  ("": "=r" (__ptr___1): "0" (& x86_cpu_to_apicid));
#line 334
  core = ((((int )*((u16 *)(__ptr + __per_cpu_offset[cpu])) >> 2) & 4) | (((int )*((u16 *)(__ptr___0 + __per_cpu_offset[cpu])) >> 1) & 3)) + (((int )*((u16 *)(__ptr___1 + __per_cpu_offset[cpu])) >> 5) & 1) * 8;
#line 335
  if (core > 15) {
#line 336
    return (0UL);
  } else {
#line 335
    __vpp_verify___2 = (void const   *)0;
#line 335
    __asm__  ("": "=r" (__ptr___2): "0" (& x86_cpu_to_apicid));
#line 335
    if ((int )*((u16 *)(__ptr___2 + __per_cpu_offset[cpu])) & 1) {
#line 336
      return (0UL);
    } else {

    }
  }
#line 338
  if (chiplet == 0) {
#line 339
    mmr = ((unsigned long )core + 6252UL) * 64UL;
  } else
#line 341
  if (chiplet == 1) {
#line 342
    mmr = ((unsigned long )core + 6268UL) * 64UL;
  } else {
    {
#line 345
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grufile.c"),
                         "i" (345), "i" (12UL));
#line 345
    __builtin_unreachable();
    }
  }
#line 348
  *corep = core;
#line 349
  return (mmr);
}
}
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int gru_chiplet_setup_tlb_irq(int chiplet , char *irq_name , irqreturn_t (*irq_handler)(int  ,
                                                                                               void * ) ,
                                     int cpu , int blade ) 
{ 
  unsigned long mmr ;
  int irq ;
  int core ;
  int ret ;

  {
  {
#line 425
  mmr = gru_chiplet_cpu_to_mmr(chiplet, cpu, & core);
  }
#line 426
  if (mmr == 0UL) {
#line 427
    return (0);
  } else {

  }
  {
#line 429
  irq = uv_setup_irq(irq_name, cpu, blade, mmr, 2);
  }
#line 430
  if (irq < 0) {
    {
#line 431
    printk("\v%s: uv_setup_irq failed, errno=%d\n", (char *)"SGI GRU Device Driver",
           - irq);
    }
#line 433
    return (irq);
  } else {

  }
  {
#line 436
  ret = ldv_request_irq_97((unsigned int )irq, irq_handler, 0UL, (char const   *)irq_name,
                           (void *)0);
  }
#line 437
  if (ret != 0) {
    {
#line 438
    uv_teardown_irq((unsigned int )irq);
#line 439
    printk("\v%s: request_irq failed, errno=%d\n", (char *)"SGI GRU Device Driver",
           - ret);
    }
#line 441
    return (ret);
  } else {

  }
#line 443
  (gru_base[blade])->bs_grus[chiplet].gs_irq[core] = irq;
#line 444
  return (0);
}
}
#line 447 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static void gru_chiplet_teardown_tlb_irq(int chiplet , int cpu , int blade ) 
{ 
  int irq ;
  int core ;
  unsigned long mmr ;

  {
  {
#line 452
  mmr = gru_chiplet_cpu_to_mmr(chiplet, cpu, & core);
  }
#line 453
  if (mmr != 0UL) {
#line 454
    irq = (gru_base[blade])->bs_grus[chiplet].gs_irq[core];
#line 455
    if (irq != 0) {
      {
#line 456
      ldv_free_irq_98((unsigned int )irq, (void *)0);
#line 457
      uv_teardown_irq((unsigned int )irq);
      }
    } else {

    }
  } else {

  }
#line 460
  return;
}
}
#line 464 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static void gru_teardown_tlb_irqs(void) 
{ 
  int blade ;
  int cpu ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 469
  cpu = -1;
#line 469
  goto ldv_34810;
  ldv_34809: 
  {
#line 470
  blade = uv_cpu_to_blade_id(cpu);
#line 471
  gru_chiplet_teardown_tlb_irq(0, cpu, blade);
#line 472
  gru_chiplet_teardown_tlb_irq(1, cpu, blade);
  }
  ldv_34810: 
  {
#line 469
  tmp = cpumask_next(cpu, cpu_online_mask);
#line 469
  cpu = (int )tmp;
  }
#line 469
  if (cpu < nr_cpu_ids) {
#line 471
    goto ldv_34809;
  } else {

  }
#line 474
  blade = 0;
#line 474
  goto ldv_34814;
  ldv_34813: 
  {
#line 475
  tmp___0 = uv_blade_nr_possible_cpus(blade);
  }
#line 475
  if (tmp___0 != 0) {
#line 476
    goto ldv_34812;
  } else {

  }
  {
#line 477
  gru_chiplet_teardown_tlb_irq(0, 0, blade);
#line 478
  gru_chiplet_teardown_tlb_irq(1, 0, blade);
  }
  ldv_34812: 
#line 474
  blade = blade + 1;
  ldv_34814: 
  {
#line 474
  tmp___1 = uv_num_possible_blades();
  }
#line 474
  if (blade < tmp___1) {
#line 476
    goto ldv_34813;
  } else {

  }

#line 481
  return;
}
}
#line 482 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int gru_setup_tlb_irqs(void) 
{ 
  int blade ;
  int cpu ;
  int ret ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 488
  cpu = -1;
#line 488
  goto ldv_34824;
  ldv_34823: 
  {
#line 489
  blade = uv_cpu_to_blade_id(cpu);
#line 490
  ret = gru_chiplet_setup_tlb_irq(0, (char *)"GRU0_TLB", & gru0_intr, cpu, blade);
  }
#line 491
  if (ret != 0) {
#line 492
    goto exit1;
  } else {

  }
  {
#line 494
  ret = gru_chiplet_setup_tlb_irq(1, (char *)"GRU1_TLB", & gru1_intr, cpu, blade);
  }
#line 495
  if (ret != 0) {
#line 496
    goto exit1;
  } else {

  }
  ldv_34824: 
  {
#line 488
  tmp = cpumask_next(cpu, cpu_online_mask);
#line 488
  cpu = (int )tmp;
  }
#line 488
  if (cpu < nr_cpu_ids) {
#line 490
    goto ldv_34823;
  } else {

  }
#line 498
  blade = 0;
#line 498
  goto ldv_34828;
  ldv_34827: 
  {
#line 499
  tmp___0 = uv_blade_nr_possible_cpus(blade);
  }
#line 499
  if (tmp___0 != 0) {
#line 500
    goto ldv_34826;
  } else {

  }
  {
#line 501
  ret = gru_chiplet_setup_tlb_irq(0, (char *)"GRU0_TLB", & gru_intr_mblade, 0, blade);
  }
#line 502
  if (ret != 0) {
#line 503
    goto exit1;
  } else {

  }
  {
#line 505
  ret = gru_chiplet_setup_tlb_irq(1, (char *)"GRU1_TLB", & gru_intr_mblade, 0, blade);
  }
#line 506
  if (ret != 0) {
#line 507
    goto exit1;
  } else {

  }
  ldv_34826: 
#line 498
  blade = blade + 1;
  ldv_34828: 
  {
#line 498
  tmp___1 = uv_num_possible_blades();
  }
#line 498
  if (blade < tmp___1) {
#line 500
    goto ldv_34827;
  } else {

  }

#line 510
  return (0);
  exit1: 
  {
#line 513
  gru_teardown_tlb_irqs();
  }
#line 514
  return (ret);
}
}
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static int gru_init(void) 
{ 
  int ret ;
  int tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 526
  tmp = gru_supported();
  }
#line 526
  if (tmp == 0) {
#line 527
    return (0);
  } else {

  }
  {
#line 532
  tmp___0 = uv_read_local_mmr(23068688UL);
#line 532
  gru_start_paddr = tmp___0 & 140737488355327UL;
#line 535
  gru_start_vaddr = (void *)(gru_start_paddr + 0xffff880000000000UL);
#line 536
  gru_end_paddr = gru_start_paddr + 137438953472UL;
#line 537
  printk("\016GRU space: 0x%lx - 0x%lx\n", gru_start_paddr, gru_end_paddr);
#line 539
  ret = ldv_misc_register_99(& gru_miscdev);
  }
#line 540
  if (ret != 0) {
    {
#line 541
    printk("\v%s: misc_register failed\n", (char *)"SGI GRU Device Driver");
    }
#line 543
    goto exit0;
  } else {

  }
  {
#line 546
  ret = gru_proc_init();
  }
#line 547
  if (ret != 0) {
    {
#line 548
    printk("\v%s: proc init failed\n", (char *)"SGI GRU Device Driver");
    }
#line 549
    goto exit1;
  } else {

  }
  {
#line 552
  ret = gru_init_tables(gru_start_paddr, gru_start_vaddr);
  }
#line 553
  if (ret != 0) {
    {
#line 554
    printk("\v%s: init tables failed\n", (char *)"SGI GRU Device Driver");
    }
#line 555
    goto exit2;
  } else {

  }
  {
#line 558
  ret = gru_setup_tlb_irqs();
  }
#line 559
  if (ret != 0) {
#line 560
    goto exit3;
  } else {

  }
  {
#line 562
  gru_kservices_init();
#line 564
  printk("\016%s: v%s\n", (char *)"SGI GRU Device Driver", (char *)"0.85");
  }
#line 566
  return (0);
  exit3: 
  {
#line 569
  gru_free_tables();
  }
  exit2: 
  {
#line 571
  gru_proc_exit();
  }
  exit1: 
  {
#line 573
  ldv_misc_deregister_100(& gru_miscdev);
  }
  exit0: ;
#line 575
  return (ret);
}
}
#line 579 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static void gru_exit(void) 
{ 
  int tmp ;

  {
  {
#line 581
  tmp = gru_supported();
  }
#line 581
  if (tmp == 0) {
#line 582
    return;
  } else {

  }
  {
#line 584
  gru_teardown_tlb_irqs();
#line 585
  gru_kservices_exit();
#line 586
  gru_free_tables();
#line 587
  ldv_misc_deregister_101(& gru_miscdev);
#line 588
  gru_proc_exit();
  }
#line 589
  return;
}
}
#line 591 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static struct file_operations  const  gru_fops  = 
#line 591
     {& __this_module, & noop_llseek, 0, 0, 0, 0, 0, 0, 0, 0, & gru_file_unlocked_ioctl,
    0, & gru_file_mmap, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 598 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
static struct miscdevice gru_miscdev  = 
#line 598
     {255, "gru", & gru_fops, {0, 0}, 0, 0, 0, (unsigned short)0};
#line 604 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufile.c"
struct vm_operations_struct  const  gru_vm_ops  = 
#line 604
     {0, & gru_vma_close, & gru_fault, 0, 0, 0, 0, 0, 0, 0};
#line 650 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_EMGentry_exit_gru_exit_20_2(void (*arg0)(void) ) ;
#line 651
int ldv_EMGentry_init_gru_init_20_10(int (*arg0)(void) ) ;
#line 653
void ldv_dispatch_deregister_14_1(struct file_operations *arg0 ) ;
#line 654
void ldv_dispatch_deregister_dummy_resourceless_instance_12_20_4(void) ;
#line 655
void ldv_dispatch_deregister_seq_instance_8_20_5(void) ;
#line 656
void ldv_dispatch_irq_deregister_13_1(int arg0 ) ;
#line 657
void ldv_dispatch_irq_register_16_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 658
void ldv_dispatch_register_15_2(struct file_operations *arg0 ) ;
#line 659
void ldv_dispatch_register_dummy_resourceless_instance_12_20_6(void) ;
#line 660
void ldv_dummy_resourceless_instance_callback_11_12(void (*arg0)(struct mmu_notifier * ,
                                                                 struct mm_struct * ,
                                                                 unsigned long  ,
                                                                 unsigned long  ) ,
                                                    struct mmu_notifier *arg1 , struct mm_struct *arg2 ,
                                                    unsigned long arg3 , unsigned long arg4 ) ;
#line 661
void ldv_dummy_resourceless_instance_callback_11_15(void (*arg0)(struct mmu_notifier * ,
                                                                 struct mm_struct * ) ,
                                                    struct mmu_notifier *arg1 , struct mm_struct *arg2 ) ;
#line 662
void ldv_dummy_resourceless_instance_callback_11_3(void (*arg0)(struct mmu_notifier * ,
                                                                struct mm_struct * ,
                                                                unsigned long  ) ,
                                                   struct mmu_notifier *arg1 , struct mm_struct *arg2 ,
                                                   unsigned long arg3 ) ;
#line 663
void ldv_dummy_resourceless_instance_callback_11_9(void (*arg0)(struct mmu_notifier * ,
                                                                struct mm_struct * ,
                                                                unsigned long  , unsigned long  ) ,
                                                   struct mmu_notifier *arg1 , struct mm_struct *arg2 ,
                                                   unsigned long arg3 , unsigned long arg4 ) ;
#line 664
void ldv_dummy_resourceless_instance_callback_12_3(void (*arg0)(struct vm_area_struct * ) ,
                                                   struct vm_area_struct *arg1 ) ;
#line 665
void ldv_dummy_resourceless_instance_callback_12_7(int (*arg0)(struct vm_area_struct * ,
                                                               struct vm_fault * ) ,
                                                   struct vm_area_struct *arg1 , struct vm_fault *arg2 ) ;
#line 666
void ldv_entry_EMGentry_20(void *arg0 ) ;
#line 667
void main(void) ;
#line 668
void ldv_file_operations_file_operations_instance_0(void *arg0 ) ;
#line 669
void ldv_file_operations_file_operations_instance_1(void *arg0 ) ;
#line 670
void ldv_file_operations_file_operations_instance_2(void *arg0 ) ;
#line 671
void ldv_file_operations_file_operations_instance_3(void *arg0 ) ;
#line 672
void ldv_file_operations_file_operations_instance_4(void *arg0 ) ;
#line 673
void ldv_file_operations_instance_callback_0_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) ;
#line 674
void ldv_file_operations_instance_callback_0_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) ;
#line 675
void ldv_file_operations_instance_callback_1_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) ;
#line 676
void ldv_file_operations_instance_callback_1_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) ;
#line 677
void ldv_file_operations_instance_callback_1_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 678
void ldv_file_operations_instance_callback_2_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) ;
#line 679
void ldv_file_operations_instance_callback_2_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) ;
#line 680
void ldv_file_operations_instance_callback_3_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) ;
#line 681
void ldv_file_operations_instance_callback_3_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) ;
#line 682
void ldv_file_operations_instance_callback_4_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) ;
#line 683
void ldv_file_operations_instance_callback_4_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) ;
#line 684
void ldv_file_operations_instance_write_0_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 685
void ldv_file_operations_instance_write_1_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 686
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) ;
#line 687
enum irqreturn ldv_interrupt_instance_handler_5_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) ;
#line 688
void ldv_interrupt_instance_thread_5_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) ;
#line 689
void ldv_interrupt_interrupt_instance_5(void *arg0 ) ;
#line 690
void ldv_misc_deregister(void *arg0 , struct miscdevice *arg1 ) ;
#line 691
int ldv_misc_register(int arg0 , struct miscdevice *arg1 ) ;
#line 693
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) ;
#line 700
void ldv_struct_mmu_notifier_ops_dummy_resourceless_instance_11(void *arg0 ) ;
#line 701
void ldv_struct_vm_operations_struct_dummy_resourceless_instance_12(void *arg0 ) ;
#line 704 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct ldv_thread ldv_thread_11  ;
#line 705 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct ldv_thread ldv_thread_12  ;
#line 706 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct ldv_thread ldv_thread_20  ;
#line 707 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
struct ldv_thread ldv_thread_5  ;
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_EMGentry_exit_gru_exit_20_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 714
  gru_exit();
  }
#line 715
  return;
}
}
#line 718 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
int ldv_EMGentry_init_gru_init_20_10(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 719
  tmp = gru_init();
  }
#line 719
  return (tmp);
}
}
#line 723 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dispatch_deregister_14_1(struct file_operations *arg0 ) 
{ 
  int tmp ;

  {
  {
#line 730
  tmp = ldv_undef_int();
  }
  {
#line 731
  if (tmp == 0) {
#line 731
    goto case_0;
  } else {

  }
#line 735
  if (tmp == 1) {
#line 735
    goto case_1;
  } else {

  }
#line 739
  if (tmp == 2) {
#line 739
    goto case_2;
  } else {

  }
#line 743
  if (tmp == 3) {
#line 743
    goto case_3;
  } else {

  }
#line 747
  if (tmp == 4) {
#line 747
    goto case_4;
  } else {

  }
#line 751
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 733
  goto ldv_35164;
  case_1: /* CIL Label */ ;
#line 737
  goto ldv_35164;
  case_2: /* CIL Label */ ;
#line 741
  goto ldv_35164;
  case_3: /* CIL Label */ ;
#line 745
  goto ldv_35164;
  case_4: /* CIL Label */ ;
#line 749
  goto ldv_35164;
  switch_default: /* CIL Label */ 
  {
#line 751
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_35164: ;
#line 753
  return;
}
}
#line 757 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_12_20_4(void) 
{ 


  {
#line 761
  return;
}
}
#line 765 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dispatch_deregister_seq_instance_8_20_5(void) 
{ 


  {
#line 777
  return;
}
}
#line 781 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dispatch_irq_deregister_13_1(int arg0 ) 
{ 


  {
#line 785
  return;
}
}
#line 789 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dispatch_irq_register_16_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_5 *cf_arg_5 ;
  void *tmp ;

  {
  {
#line 792
  tmp = ldv_xmalloc(40UL);
#line 792
  cf_arg_5 = (struct ldv_struct_interrupt_instance_5 *)tmp;
#line 793
  cf_arg_5->arg0 = arg0;
#line 794
  cf_arg_5->arg1 = arg1;
#line 795
  cf_arg_5->arg2 = arg2;
#line 796
  cf_arg_5->arg3 = arg3;
#line 797
  ldv_interrupt_interrupt_instance_5((void *)cf_arg_5);
  }
#line 798
  return;
}
}
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dispatch_register_15_2(struct file_operations *arg0 ) 
{ 
  struct ldv_struct_file_operations_instance_0 *cf_arg_0 ;
  struct ldv_struct_file_operations_instance_0 *cf_arg_1 ;
  struct ldv_struct_file_operations_instance_0 *cf_arg_2 ;
  struct ldv_struct_file_operations_instance_0 *cf_arg_3 ;
  struct ldv_struct_file_operations_instance_0 *cf_arg_4 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 809
  tmp = ldv_undef_int();
  }
  {
#line 810
  if (tmp == 0) {
#line 810
    goto case_0;
  } else {

  }
#line 816
  if (tmp == 1) {
#line 816
    goto case_1;
  } else {

  }
#line 822
  if (tmp == 2) {
#line 822
    goto case_2;
  } else {

  }
#line 828
  if (tmp == 3) {
#line 828
    goto case_3;
  } else {

  }
#line 834
  if (tmp == 4) {
#line 834
    goto case_4;
  } else {

  }
#line 840
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 811
  tmp___0 = ldv_xmalloc(16UL);
#line 811
  cf_arg_0 = (struct ldv_struct_file_operations_instance_0 *)tmp___0;
#line 812
  cf_arg_0->arg0 = arg0;
#line 813
  ldv_file_operations_file_operations_instance_0((void *)cf_arg_0);
  }
#line 814
  goto ldv_35209;
  case_1: /* CIL Label */ 
  {
#line 817
  tmp___1 = ldv_xmalloc(16UL);
#line 817
  cf_arg_1 = (struct ldv_struct_file_operations_instance_0 *)tmp___1;
#line 818
  cf_arg_1->arg0 = arg0;
#line 819
  ldv_file_operations_file_operations_instance_1((void *)cf_arg_1);
  }
#line 820
  goto ldv_35209;
  case_2: /* CIL Label */ 
  {
#line 823
  tmp___2 = ldv_xmalloc(16UL);
#line 823
  cf_arg_2 = (struct ldv_struct_file_operations_instance_0 *)tmp___2;
#line 824
  cf_arg_2->arg0 = arg0;
#line 825
  ldv_file_operations_file_operations_instance_2((void *)cf_arg_2);
  }
#line 826
  goto ldv_35209;
  case_3: /* CIL Label */ 
  {
#line 829
  tmp___3 = ldv_xmalloc(16UL);
#line 829
  cf_arg_3 = (struct ldv_struct_file_operations_instance_0 *)tmp___3;
#line 830
  cf_arg_3->arg0 = arg0;
#line 831
  ldv_file_operations_file_operations_instance_3((void *)cf_arg_3);
  }
#line 832
  goto ldv_35209;
  case_4: /* CIL Label */ 
  {
#line 835
  tmp___4 = ldv_xmalloc(16UL);
#line 835
  cf_arg_4 = (struct ldv_struct_file_operations_instance_0 *)tmp___4;
#line 836
  cf_arg_4->arg0 = arg0;
#line 837
  ldv_file_operations_file_operations_instance_4((void *)cf_arg_4);
  }
#line 838
  goto ldv_35209;
  switch_default: /* CIL Label */ 
  {
#line 840
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_35209: ;
#line 842
  return;
}
}
#line 846 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_12_20_6(void) 
{ 
  struct ldv_struct_EMGentry_20 *cf_arg_12 ;
  void *tmp ;

  {
  {
#line 849
  tmp = ldv_xmalloc(4UL);
#line 849
  cf_arg_12 = (struct ldv_struct_EMGentry_20 *)tmp;
#line 850
  ldv_struct_vm_operations_struct_dummy_resourceless_instance_12((void *)cf_arg_12);
  }
#line 851
  return;
}
}
#line 855 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dummy_resourceless_instance_callback_12_3(void (*arg0)(struct vm_area_struct * ) ,
                                                   struct vm_area_struct *arg1 ) 
{ 


  {
  {
#line 856
  gru_vma_close(arg1);
  }
#line 857
  return;
}
}
#line 860 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_dummy_resourceless_instance_callback_12_7(int (*arg0)(struct vm_area_struct * ,
                                                               struct vm_fault * ) ,
                                                   struct vm_area_struct *arg1 , struct vm_fault *arg2 ) 
{ 


  {
  {
#line 861
  gru_fault(arg1, arg2);
  }
#line 862
  return;
}
}
#line 865 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_entry_EMGentry_20(void *arg0 ) 
{ 
  void (*ldv_20_exit_gru_exit_default)(void) ;
  int (*ldv_20_init_gru_init_default)(void) ;
  int ldv_20_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 874
  ldv_20_ret_default = ldv_EMGentry_init_gru_init_20_10(ldv_20_init_gru_init_default);
#line 876
  ldv_20_ret_default = ldv_ldv_post_init_102(ldv_20_ret_default);
#line 879
  tmp___0 = ldv_undef_int();
  }
#line 879
  if (tmp___0 != 0) {
    {
#line 881
    ldv_assume(ldv_20_ret_default != 0);
#line 885
    ldv_ldv_check_final_state_103();
#line 886
    ldv_stop();
    }
#line 890
    return;
  } else {
    {
#line 894
    ldv_assume(ldv_20_ret_default == 0);
#line 897
    tmp = ldv_undef_int();
    }
#line 897
    if (tmp != 0) {
      {
#line 899
      ldv_dispatch_register_dummy_resourceless_instance_12_20_6();
#line 903
      ldv_dispatch_deregister_seq_instance_8_20_5();
#line 907
      ldv_dispatch_deregister_dummy_resourceless_instance_12_20_4();
      }
    } else {

    }
    {
#line 918
    ldv_EMGentry_exit_gru_exit_20_2(ldv_20_exit_gru_exit_default);
#line 922
    ldv_ldv_check_final_state_104();
#line 923
    ldv_stop();
    }
#line 927
    return;
  }
#line 930
  return;
}
}
#line 935 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void main(void) 
{ 


  {
  {
#line 936
  ldv_ldv_initialize_105();
#line 937
  ldv_entry_EMGentry_20((void *)0);
  }
#line 938
  return;
}
}
#line 942 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_0_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) 
{ 


  {
  {
#line 943
  (*arg0)(arg1, arg2);
  }
#line 944
  return;
}
}
#line 947 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_0_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) 
{ 


  {
  {
#line 948
  (*arg0)(arg1, arg2, arg3);
  }
#line 949
  return;
}
}
#line 952 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_1_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) 
{ 


  {
  {
#line 953
  gru_file_mmap(arg1, arg2);
  }
#line 954
  return;
}
}
#line 957 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_1_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) 
{ 


  {
  {
#line 958
  gru_file_unlocked_ioctl(arg1, arg2, arg3);
  }
#line 959
  return;
}
}
#line 962 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_1_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 963
  noop_llseek(arg1, arg2, arg3);
  }
#line 964
  return;
}
}
#line 967 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_2_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) 
{ 


  {
  {
#line 968
  (*arg0)(arg1, arg2);
  }
#line 969
  return;
}
}
#line 972 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_2_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) 
{ 


  {
  {
#line 973
  (*arg0)(arg1, arg2, arg3);
  }
#line 974
  return;
}
}
#line 977 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_3_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) 
{ 


  {
  {
#line 978
  (*arg0)(arg1, arg2);
  }
#line 979
  return;
}
}
#line 982 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_3_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) 
{ 


  {
  {
#line 983
  (*arg0)(arg1, arg2, arg3);
  }
#line 984
  return;
}
}
#line 987 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_4_22(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                                struct file *arg1 , struct vm_area_struct *arg2 ) 
{ 


  {
  {
#line 988
  (*arg0)(arg1, arg2);
  }
#line 989
  return;
}
}
#line 992 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_callback_4_26(long (*arg0)(struct file * , unsigned int  ,
                                                             unsigned long  ) , struct file *arg1 ,
                                                unsigned int arg2 , unsigned long arg3 ) 
{ 


  {
  {
#line 993
  (*arg0)(arg1, arg2, arg3);
  }
#line 994
  return;
}
}
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_write_0_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 998
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 999
  return;
}
}
#line 1002 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_file_operations_instance_write_1_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1003
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1004
  return;
}
}
#line 1007 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) 
{ 
  int ldv_13_line_line ;

  {
  {
#line 1013
  ldv_13_line_line = arg1;
#line 1017
  ldv_dispatch_irq_deregister_13_1(ldv_13_line_line);
  }
#line 1021
  return;
#line 1023
  return;
}
}
#line 1028 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
enum irqreturn ldv_interrupt_instance_handler_5_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                  int arg1 , void *arg2 ) 
{ 
  enum irqreturn tmp ;

  {
  {
#line 1029
  tmp = (*arg0)(arg1, arg2);
  }
#line 1029
  return (tmp);
}
}
#line 1033 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_interrupt_instance_thread_5_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                       void *arg2 ) 
{ 


  {
  {
#line 1034
  (*arg0)(arg1, arg2);
  }
#line 1035
  return;
}
}
#line 1038 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_interrupt_interrupt_instance_5(void *arg0 ) 
{ 
  enum irqreturn (*ldv_5_callback_handler)(int  , void * ) ;
  void *ldv_5_data_data ;
  int ldv_5_line_line ;
  enum irqreturn ldv_5_ret_val_default ;
  enum irqreturn (*ldv_5_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_5 *data ;
  int tmp ;

  {
#line 1047
  data = (struct ldv_struct_interrupt_instance_5 *)arg0;
#line 1052
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_5 *)0)) {
    {
#line 1053
    ldv_5_line_line = data->arg0;
#line 1054
    ldv_5_callback_handler = data->arg1;
#line 1055
    ldv_5_thread_thread = data->arg2;
#line 1056
    ldv_5_data_data = data->arg3;
#line 1057
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1063
  ldv_switch_to_interrupt_context();
  }
#line 1064
  if ((unsigned long )ldv_5_callback_handler != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                     void * ))0)) {
    {
#line 1066
    ldv_5_ret_val_default = ldv_interrupt_instance_handler_5_5(ldv_5_callback_handler,
                                                               ldv_5_line_line, ldv_5_data_data);
    }
  } else {

  }
  {
#line 1069
  ldv_switch_to_process_context();
#line 1072
  tmp = ldv_undef_int();
  }
#line 1072
  if (tmp != 0) {
    {
#line 1074
    ldv_assume((unsigned int )ldv_5_ret_val_default == 2U);
    }
#line 1078
    if ((unsigned long )ldv_5_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                    void * ))0)) {
      {
#line 1080
      ldv_interrupt_instance_thread_5_3(ldv_5_thread_thread, ldv_5_line_line, ldv_5_data_data);
      }
    } else {

    }
  } else {
    {
#line 1087
    ldv_assume((unsigned int )ldv_5_ret_val_default != 2U);
    }
  }
#line 1096
  return;
#line 1098
  return;
}
}
#line 1103 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_misc_deregister(void *arg0 , struct miscdevice *arg1 ) 
{ 
  struct file_operations *ldv_14_file_operations_file_operations ;
  struct miscdevice *ldv_14_miscdevice_miscdevice ;

  {
  {
#line 1110
  ldv_14_miscdevice_miscdevice = arg1;
#line 1111
  ldv_14_file_operations_file_operations = (struct file_operations *)ldv_14_miscdevice_miscdevice->fops;
#line 1115
  ldv_dispatch_deregister_14_1(ldv_14_file_operations_file_operations);
  }
#line 1119
  return;
#line 1121
  return;
}
}
#line 1126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
int ldv_misc_register(int arg0 , struct miscdevice *arg1 ) 
{ 
  struct file_operations *ldv_15_file_operations_file_operations ;
  struct miscdevice *ldv_15_miscdevice_miscdevice ;
  int tmp ;

  {
  {
#line 1134
  tmp = ldv_undef_int();
  }
#line 1134
  if (tmp != 0) {
    {
#line 1136
    ldv_assume(arg0 == 0);
#line 1137
    ldv_15_miscdevice_miscdevice = arg1;
#line 1138
    ldv_15_file_operations_file_operations = (struct file_operations *)ldv_15_miscdevice_miscdevice->fops;
#line 1142
    ldv_dispatch_register_15_2(ldv_15_file_operations_file_operations);
    }
#line 1146
    return (arg0);
  } else {
    {
#line 1150
    ldv_assume(arg0 != 0);
    }
#line 1154
    return (arg0);
  }
#line 1157
  return (arg0);
}
}
#line 1162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) 
{ 
  enum irqreturn (*ldv_16_callback_handler)(int  , void * ) ;
  void *ldv_16_data_data ;
  int ldv_16_line_line ;
  enum irqreturn (*ldv_16_thread_thread)(int  , void * ) ;
  int tmp ;

  {
  {
#line 1172
  tmp = ldv_undef_int();
  }
#line 1172
  if (tmp != 0) {
    {
#line 1174
    ldv_assume(arg0 == 0);
#line 1175
    ldv_16_line_line = (int )arg1;
#line 1176
    ldv_16_callback_handler = arg2;
#line 1177
    ldv_16_thread_thread = (enum irqreturn (*)(int  , void * ))0;
#line 1178
    ldv_16_data_data = arg5;
#line 1182
    ldv_dispatch_irq_register_16_2(ldv_16_line_line, ldv_16_callback_handler, ldv_16_thread_thread,
                                   ldv_16_data_data);
    }
#line 1186
    return (arg0);
  } else {
    {
#line 1190
    ldv_assume(arg0 != 0);
    }
#line 1194
    return (arg0);
  }
#line 1197
  return (arg0);
}
}
#line 1202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_struct_mmu_notifier_ops_dummy_resourceless_instance_11(void *arg0 ) 
{ 
  void (*ldv_11_callback_invalidate_page)(struct mmu_notifier * , struct mm_struct * ,
                                          unsigned long  ) ;
  void (*ldv_11_callback_invalidate_range_end)(struct mmu_notifier * , struct mm_struct * ,
                                               unsigned long  , unsigned long  ) ;
  void (*ldv_11_callback_invalidate_range_start)(struct mmu_notifier * , struct mm_struct * ,
                                                 unsigned long  , unsigned long  ) ;
  void (*ldv_11_callback_release)(struct mmu_notifier * , struct mm_struct * ) ;
  struct mm_struct *ldv_11_container_struct_mm_struct_ptr ;
  struct mmu_notifier *ldv_11_container_struct_mmu_notifier_ptr ;
  unsigned long ldv_11_ldv_param_12_2_default ;
  unsigned long ldv_11_ldv_param_12_3_default ;
  unsigned long ldv_11_ldv_param_3_2_default ;
  unsigned long ldv_11_ldv_param_9_2_default ;
  unsigned long ldv_11_ldv_param_9_3_default ;
  struct ldv_struct_dummy_resourceless_instance_11 *data ;
  int tmp ;
  int tmp___0 ;

  {
#line 1217
  data = (struct ldv_struct_dummy_resourceless_instance_11 *)arg0;
#line 1222
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_dummy_resourceless_instance_11 *)0)) {
    {
#line 1223
    ldv_11_container_struct_mmu_notifier_ptr = data->arg0;
#line 1224
    ldv_free((void *)data);
    }
  } else {

  }
#line 1232
  goto ldv_call_11;
#line 1234
  return;
  ldv_call_11: 
  {
#line 1240
  tmp___0 = ldv_undef_int();
  }
#line 1240
  if (tmp___0 != 0) {
    {
#line 1244
    tmp = ldv_undef_int();
    }
    {
#line 1245
    if (tmp == 1) {
#line 1245
      goto case_1;
    } else {

    }
#line 1253
    if (tmp == 2) {
#line 1253
      goto case_2;
    } else {

    }
#line 1267
    if (tmp == 3) {
#line 1267
      goto case_3;
    } else {

    }
#line 1281
    if (tmp == 4) {
#line 1281
      goto case_4;
    } else {

    }
#line 1289
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1248
    ldv_dummy_resourceless_instance_callback_11_15(ldv_11_callback_release, ldv_11_container_struct_mmu_notifier_ptr,
                                                   ldv_11_container_struct_mm_struct_ptr);
    }
#line 1251
    goto ldv_35445;
    case_2: /* CIL Label */ 
    {
#line 1259
    ldv_dummy_resourceless_instance_callback_11_12(ldv_11_callback_invalidate_range_start,
                                                   ldv_11_container_struct_mmu_notifier_ptr,
                                                   ldv_11_container_struct_mm_struct_ptr,
                                                   ldv_11_ldv_param_12_2_default,
                                                   ldv_11_ldv_param_12_3_default);
    }
#line 1265
    goto ldv_35445;
    case_3: /* CIL Label */ 
    {
#line 1273
    ldv_dummy_resourceless_instance_callback_11_9(ldv_11_callback_invalidate_range_end,
                                                  ldv_11_container_struct_mmu_notifier_ptr,
                                                  ldv_11_container_struct_mm_struct_ptr,
                                                  ldv_11_ldv_param_9_2_default, ldv_11_ldv_param_9_3_default);
    }
#line 1279
    goto ldv_35445;
    case_4: /* CIL Label */ 
    {
#line 1284
    ldv_dummy_resourceless_instance_callback_11_3(ldv_11_callback_invalidate_page,
                                                  ldv_11_container_struct_mmu_notifier_ptr,
                                                  ldv_11_container_struct_mm_struct_ptr,
                                                  ldv_11_ldv_param_3_2_default);
    }
#line 1287
    goto ldv_35445;
    switch_default: /* CIL Label */ 
    {
#line 1289
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_35445: ;
#line 1298
    goto ldv_call_11;
  } else {
#line 1306
    return;
  }
#line 1309
  return;
}
}
#line 1314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
void ldv_struct_vm_operations_struct_dummy_resourceless_instance_12(void *arg0 ) 
{ 
  void (*ldv_12_callback_close)(struct vm_area_struct * ) ;
  int (*ldv_12_callback_fault)(struct vm_area_struct * , struct vm_fault * ) ;
  struct vm_area_struct *ldv_12_container_struct_vm_area_struct_ptr ;
  struct vm_fault *ldv_12_container_struct_vm_fault_ptr ;
  int tmp ;

  {
#line 1329
  goto ldv_call_12;
#line 1331
  return;
  ldv_call_12: 
  {
#line 1337
  tmp = ldv_undef_int();
  }
  {
#line 1338
  if (tmp == 1) {
#line 1338
    goto case_1;
  } else {

  }
#line 1351
  if (tmp == 2) {
#line 1351
    goto case_2;
  } else {

  }
#line 1366
  if (tmp == 3) {
#line 1366
    goto case_3;
  } else {

  }
#line 1375
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1341
  ldv_dummy_resourceless_instance_callback_12_7(ldv_12_callback_fault, ldv_12_container_struct_vm_area_struct_ptr,
                                                ldv_12_container_struct_vm_fault_ptr);
  }
#line 1348
  goto ldv_call_12;
  case_2: /* CIL Label */ 
  {
#line 1354
  ldv_dummy_resourceless_instance_callback_12_3(ldv_12_callback_close, ldv_12_container_struct_vm_area_struct_ptr);
  }
#line 1361
  goto ldv_call_12;
#line 1363
  goto ldv_call_12;
  case_3: /* CIL Label */ ;
#line 1372
  return;
  switch_default: /* CIL Label */ 
  {
#line 1375
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1378
  return;
}
}
#line 1407 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static unsigned long ldv_find_next_bit_5(unsigned long const   *addr , unsigned long size ,
                                         unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1410
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1410
  return (tmp);
}
}
#line 2065 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2069
  ldv_linux_kernel_locking_mutex_mutex_lock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 2070
  return;
}
}
#line 2072 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 2076
  ldv_linux_kernel_locking_mutex_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 2077
  return;
}
}
#line 2079 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
__inline static int ldv_request_irq_97(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2083
  tmp = request_irq(irq, handler, flags, name, dev);
#line 2083
  ldv_func_res = tmp;
#line 2086
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 2086
  return (tmp___0);
#line 2088
  return (ldv_func_res);
}
}
#line 2091 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static void ldv_free_irq_98(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 2094
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 2097
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 2098
  return;
}
}
#line 2100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static int ldv_misc_register_99(struct miscdevice *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 2104
  tmp = misc_register(ldv_func_arg1);
#line 2104
  ldv_func_res = tmp;
#line 2107
  tmp___0 = ldv_misc_register(ldv_func_res, ldv_func_arg1);
  }
#line 2107
  return (tmp___0);
#line 2109
  return (ldv_func_res);
}
}
#line 2112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static int ldv_misc_deregister_100(struct miscdevice *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  int tmp ;

  {
  {
#line 2116
  tmp = misc_deregister(ldv_func_arg1);
#line 2116
  ldv_func_res = tmp;
#line 2119
  ldv_misc_deregister((void *)0, ldv_func_arg1);
  }
#line 2121
  return (ldv_func_res);
}
}
#line 2124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static int ldv_misc_deregister_101(struct miscdevice *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
  {
#line 2128
  tmp = misc_deregister(ldv_func_arg1);
#line 2128
  ldv_func_res = tmp;
#line 2131
  ldv_misc_deregister((void *)0, ldv_func_arg1);
  }
#line 2133
  return (ldv_func_res);
}
}
#line 2136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static int ldv_ldv_post_init_102(int ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 2140
  ldv_linux_net_register_reset_error_counter();
#line 2144
  ldv_linux_usb_register_reset_error_counter();
#line 2147
  tmp = ldv_post_init(ldv_func_arg1);
  }
#line 2147
  return (tmp);
}
}
#line 2150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static void ldv_ldv_check_final_state_103(void) 
{ 


  {
  {
#line 2154
  ldv_linux_arch_io_check_final_state();
#line 2158
  ldv_linux_block_genhd_check_final_state();
#line 2162
  ldv_linux_block_queue_check_final_state();
#line 2166
  ldv_linux_block_request_check_final_state();
#line 2170
  ldv_linux_drivers_base_class_check_final_state();
#line 2178
  ldv_linux_fs_char_dev_check_final_state();
#line 2182
  ldv_linux_fs_sysfs_check_final_state();
#line 2186
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 2190
  ldv_linux_kernel_module_check_final_state();
#line 2194
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 2198
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 2202
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 2206
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 2210
  ldv_linux_lib_idr_check_final_state();
#line 2214
  ldv_linux_mmc_sdio_func_check_final_state();
#line 2218
  ldv_linux_net_rtnetlink_check_final_state();
#line 2222
  ldv_linux_net_sock_check_final_state();
#line 2226
  ldv_linux_usb_coherent_check_final_state();
#line 2230
  ldv_linux_usb_gadget_check_final_state();
#line 2234
  ldv_linux_usb_urb_check_final_state();
  }
#line 2235
  return;
}
}
#line 2238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static void ldv_ldv_check_final_state_104(void) 
{ 


  {
  {
#line 2242
  ldv_linux_arch_io_check_final_state();
#line 2246
  ldv_linux_block_genhd_check_final_state();
#line 2250
  ldv_linux_block_queue_check_final_state();
#line 2254
  ldv_linux_block_request_check_final_state();
#line 2258
  ldv_linux_drivers_base_class_check_final_state();
#line 2266
  ldv_linux_fs_char_dev_check_final_state();
#line 2270
  ldv_linux_fs_sysfs_check_final_state();
#line 2274
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 2278
  ldv_linux_kernel_module_check_final_state();
#line 2282
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 2286
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 2290
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 2294
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 2298
  ldv_linux_lib_idr_check_final_state();
#line 2302
  ldv_linux_mmc_sdio_func_check_final_state();
#line 2306
  ldv_linux_net_rtnetlink_check_final_state();
#line 2310
  ldv_linux_net_sock_check_final_state();
#line 2314
  ldv_linux_usb_coherent_check_final_state();
#line 2318
  ldv_linux_usb_gadget_check_final_state();
#line 2322
  ldv_linux_usb_urb_check_final_state();
  }
#line 2323
  return;
}
}
#line 2326 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufile.c.aux"
static void ldv_ldv_initialize_105(void) 
{ 


  {
  {
#line 2330
  ldv_linux_lib_find_bit_initialize();
  }
#line 2331
  return;
}
}
#line 23 "/home/ubuntu/klever-work/linux/ldv/err.h"
void *ldv_err_ptr(long error ) ;
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) ;
#line 228
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) ;
#line 262
unsigned long ldv_linux_lib_find_bit_find_first_bit(unsigned long size ) ;
#line 308
extern void ldv_after_alloc(void * ) ;
#line 366
static void ldv_mutex_lock_128(struct mutex *ldv_func_arg1 ) ;
#line 396
int ldv_linux_kernel_locking_mutex_mutex_trylock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) ;
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static void __set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 96
  __asm__  volatile   ("bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 97
  return;
}
}
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static void __clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 139
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 140
  return;
}
}
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 206
  __asm__  volatile   ("":);
#line 206
  return (0);

#line 206
  return (1);
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
#line 318
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
#line 323
  return (oldbit);
}
}
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bitops/find.h"
static unsigned long ldv_find_next_bit_111(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) ;
#line 34
static unsigned long ldv_find_next_bit_113(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) ;
#line 38
static unsigned long ldv_find_next_bit_115(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) ;
#line 42
static unsigned long ldv_find_next_bit_117(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) ;
#line 54
static unsigned long ldv_find_first_bit_95(unsigned long const   *addr , unsigned long size ) ;
#line 58
static unsigned long ldv_find_first_bit_110(unsigned long const   *addr , unsigned long size ) ;
#line 62
static unsigned long ldv_find_first_bit_112(unsigned long const   *addr , unsigned long size ) ;
#line 66
static unsigned long ldv_find_first_bit_114(unsigned long const   *addr , unsigned long size ) ;
#line 70
static unsigned long ldv_find_first_bit_116(unsigned long const   *addr , unsigned long size ) ;
#line 65
static unsigned long ldv_find_first_zero_bit_124(unsigned long const   *addr , unsigned long size ) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 48
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
  {
#line 63
  __list_add(new, head, head->next);
  }
#line 64
  return;
}
}
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current___0(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  {
#line 14
  if (8UL == 1UL) {
#line 14
    goto case_1;
  } else {

  }
#line 14
  if (8UL == 2UL) {
#line 14
    goto case_2;
  } else {

  }
#line 14
  if (8UL == 4UL) {
#line 14
    goto case_4;
  } else {

  }
#line 14
  if (8UL == 8UL) {
#line 14
    goto case_8;
  } else {

  }
#line 14
  goto switch_default;
  case_1: /* CIL Label */ 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3602;
  case_2: /* CIL Label */ 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3602;
  case_4: /* CIL Label */ 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3602;
  case_8: /* CIL Label */ 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3602;
  switch_default: /* CIL Label */ 
  {
#line 14
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_3602: ;
#line 14
  return (pfo_ret__);
}
}
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 189 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/special_insns.h"
__inline static void clflush(void volatile   *__p ) 
{ 


  {
#line 191
  __asm__  volatile   ("clflush %0": "+m" (*((char volatile   *)__p)));
#line 192
  return;
}
}
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 43
  tmp = __builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
  }
#line 43
  return (tmp != 0L);
}
}
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static void *ERR_CAST(void const   *ptr ) 
{ 


  {
#line 53
  return ((void *)ptr);
}
}
#line 656 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
__inline static void rep_nop(void) 
{ 


  {
#line 658
  __asm__  volatile   ("rep; nop": : : "memory");
#line 659
  return;
}
}
#line 661 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
__inline static void cpu_relax(void) 
{ 


  {
  {
#line 663
  rep_nop();
  }
#line 664
  return;
}
}
#line 789 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
__inline static void prefetchw(void const   *x ) 
{ 


  {
#line 791
  __asm__  volatile   ("661:\n\tprefetcht0 (%1)\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 1*32+31)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\tprefetchw (%1)\n6641:\n\t.popsection": : "i" (0),
                       "r" (x));
#line 792
  return;
}
}
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/cmpxchg.h"
extern void __xchg_wrong_size(void) ;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 98
__inline static void atomic_inc(atomic_t *v ) ;
#line 159
__inline static int atomic_add_return(int i , atomic_t *v ) ;
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 173
  tmp = atomic_add_return(- i, v);
  }
#line 173
  return (tmp);
}
}
#line 491 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
void ldv_linux_kernel_locking_spinlock_spin_lock_bs_lock_of_gru_blade_state(void) ;
#line 492
void ldv_linux_kernel_locking_spinlock_spin_unlock_bs_lock_of_gru_blade_state(void) ;
#line 499
void ldv_linux_kernel_locking_spinlock_spin_lock_gs_asid_lock_of_gru_state(void) ;
#line 500
void ldv_linux_kernel_locking_spinlock_spin_unlock_gs_asid_lock_of_gru_state(void) ;
#line 507
void ldv_linux_kernel_locking_spinlock_spin_lock_gs_lock_of_gru_state(void) ;
#line 508
void ldv_linux_kernel_locking_spinlock_spin_unlock_gs_lock_of_gru_state(void) ;
#line 539
void ldv_linux_kernel_locking_spinlock_spin_lock_ms_asid_lock_of_gru_mm_struct(void) ;
#line 540
void ldv_linux_kernel_locking_spinlock_spin_unlock_ms_asid_lock_of_gru_mm_struct(void) ;
#line 571
void ldv_linux_kernel_locking_spinlock_spin_lock_vd_lock_of_gru_vma_data(void) ;
#line 572
void ldv_linux_kernel_locking_spinlock_spin_unlock_vd_lock_of_gru_vma_data(void) ;
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 180
static int ldv_mutex_trylock_118(struct mutex *ldv_func_arg1 ) ;
#line 197
static void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) ;
#line 201
static void ldv_mutex_unlock_129(struct mutex *ldv_func_arg1 ) ;
#line 205
static void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) ;
#line 8 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
  {
#line 72
  if (4UL == 1UL) {
#line 72
    goto case_1;
  } else {

  }
#line 72
  if (4UL == 2UL) {
#line 72
    goto case_2;
  } else {

  }
#line 72
  if (4UL == 4UL) {
#line 72
    goto case_4;
  } else {

  }
#line 72
  if (4UL == 8UL) {
#line 72
    goto case_8;
  } else {

  }
#line 72
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_7262;
  case_2: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_7262;
  case_4: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_7262;
  case_8: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_7262;
  switch_default: /* CIL Label */ 
  {
#line 72
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7262: ;
#line 74
  return;
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8;
  } else {

  }
#line 77
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_7274;
  case_2: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_7274;
  case_4: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_7274;
  case_8: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_7274;
  switch_default: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7274: ;
#line 79
  return;
}
}
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  {
#line 312
  _raw_spin_lock(& lock->__annonCompField18.rlock);
  }
#line 313
  return;
}
}
#line 350
__inline static void ldv_spin_lock_96(spinlock_t *lock ) ;
#line 354
__inline static void ldv_spin_lock_97(spinlock_t *lock ) ;
#line 358
__inline static void ldv_spin_lock_96(spinlock_t *lock ) ;
#line 362
__inline static void ldv_spin_lock_97(spinlock_t *lock ) ;
#line 366
__inline static void ldv_spin_lock_104(spinlock_t *lock ) ;
#line 370
__inline static void ldv_spin_lock_104(spinlock_t *lock ) ;
#line 374
__inline static void ldv_spin_lock_108(spinlock_t *lock ) ;
#line 378
__inline static void ldv_spin_lock_120(spinlock_t *lock ) ;
#line 382
__inline static void ldv_spin_lock_108(spinlock_t *lock ) ;
#line 386
__inline static void ldv_spin_lock_108(spinlock_t *lock ) ;
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  {
#line 365
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
  }
#line 366
  return;
}
}
#line 399
__inline static void ldv_spin_unlock_98(spinlock_t *lock ) ;
#line 403
__inline static void ldv_spin_unlock_99(spinlock_t *lock ) ;
#line 407
__inline static void ldv_spin_unlock_98(spinlock_t *lock ) ;
#line 411
__inline static void ldv_spin_unlock_99(spinlock_t *lock ) ;
#line 415
__inline static void ldv_spin_unlock_105(spinlock_t *lock ) ;
#line 419
__inline static void ldv_spin_unlock_105(spinlock_t *lock ) ;
#line 423
__inline static void ldv_spin_unlock_109(spinlock_t *lock ) ;
#line 427
__inline static void ldv_spin_unlock_109(spinlock_t *lock ) ;
#line 431
__inline static void ldv_spin_unlock_123(spinlock_t *lock ) ;
#line 435
__inline static void ldv_spin_unlock_109(spinlock_t *lock ) ;
#line 439
__inline static void ldv_spin_unlock_109(spinlock_t *lock ) ;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwsem.h"
extern int down_write_trylock(struct rw_semaphore * ) ;
#line 1159 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
extern int zap_vma_ptes(struct vm_area_struct * , unsigned long  , unsigned long  ) ;
#line 2084
extern int remap_pfn_range(struct vm_area_struct * , unsigned long  , unsigned long  ,
                           unsigned long  , pgprot_t  ) ;
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_numa_blade_id(void) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 512
  __vpp_verify = (void const   *)0;
#line 512
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 512
  return ((int )((struct uv_hub_info_s *)tcp_ptr__)->numa_blade_id);
}
}
#line 331 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_flush_cache(void *p ) 
{ 


  {
  {
#line 333
  clflush((void volatile   *)p);
  }
#line 334
  return;
}
}
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_context_configuration_handle *get_cch(void *base , int ctxnum ) 
{ 


  {
#line 145
  return ((struct gru_context_configuration_handle *)(base + ((unsigned long )(ctxnum * 256) + 67239936UL)));
}
}
#line 515
int cch_allocate(struct gru_context_configuration_handle *cch ) ;
#line 516
int cch_start(struct gru_context_configuration_handle *cch ) ;
#line 517
int cch_interrupt(struct gru_context_configuration_handle *cch ) ;
#line 518
int cch_deallocate(struct gru_context_configuration_handle *cch ) ;
#line 519
int cch_interrupt_sync(struct gru_context_configuration_handle *cch ) ;
#line 570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static void __lock_handle(void *h ) 
{ 
  int tmp ;

  {
#line 572
  goto ldv_33599;
  ldv_33598: 
  {
#line 573
  cpu_relax();
  }
  ldv_33599: 
  {
#line 572
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)h);
  }
#line 572
  if (tmp != 0) {
#line 574
    goto ldv_33598;
  } else {

  }

#line 579
  return;
}
}
#line 576 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static void __unlock_handle(void *h ) 
{ 


  {
  {
#line 578
  clear_bit(1L, (unsigned long volatile   *)h);
  }
#line 579
  return;
}
}
#line 586 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static void lock_cch_handle(struct gru_context_configuration_handle *cch ) 
{ 


  {
  {
#line 588
  __lock_handle((void *)cch);
  }
#line 589
  return;
}
}
#line 591 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static void unlock_cch_handle(struct gru_context_configuration_handle *cch ) 
{ 


  {
  {
#line 594
  __unlock_handle((void *)cch);
  }
#line 595
  return;
}
}
#line 607 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static int is_kernel_context(struct gru_thread_state *gts ) 
{ 


  {
#line 609
  return ((unsigned long )gts->ts_mm == (unsigned long )((struct mm_struct *)0));
}
}
#line 627
struct device *grudev ;
#line 631
struct gru_thread_state *gru_find_thread_state(struct vm_area_struct *vma , int tsid ) ;
#line 633
struct gru_thread_state *gru_alloc_thread_state(struct vm_area_struct *vma , int tsid ) ;
#line 635
struct gru_state *gru_assign_gru_context(struct gru_thread_state *gts ) ;
#line 636
void gru_load_context(struct gru_thread_state *gts ) ;
#line 637
void gru_steal_context(struct gru_thread_state *gts ) ;
#line 639
int gru_update_cch(struct gru_thread_state *gts ) ;
#line 654
void gru_check_context_placement(struct gru_thread_state *gts ) ;
#line 655
int gru_cpu_fault_map_id(void) ;
#line 657
void gru_flush_all_tlb(struct gru_state *gru ) ;
#line 661
struct gru_thread_state *gru_alloc_gts(struct vm_area_struct *vma , int cbr_au_count ,
                                       int dsr_au_count , unsigned char tlb_preload_count ,
                                       int options , int tsid ) ;
#line 664
unsigned long gru_reserve_cb_resources(struct gru_state *gru , int cbr_au_count ,
                                       char *cbmap ) ;
#line 666
unsigned long gru_reserve_ds_resources(struct gru_state *gru , int dsr_au_count ,
                                       char *dsmap ) ;
#line 669
struct gru_mm_struct *gru_register_mmu_notifier(void) ;
#line 670
void gru_drop_mmu_notifier(struct gru_mm_struct *gms ) ;
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
unsigned long gru_options  ;
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static struct device_driver gru_driver  = 
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
     {"gru", 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static struct device gru_device  = 
#line 43
     {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                          {{0, 0}, 0UL, 0, 0, 0UL, 0, 0, 0, {(char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0,
                                                                             (char)0},
                                           {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
           (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
    "", 0, {{0}, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
    0, & gru_driver, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0,
                            (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0U}},
                                                                                 0U,
                                                                                 0U,
                                                                                 0,
                                                                                 {0,
                                                                                  {0,
                                                                                   0},
                                                                                  0,
                                                                                  0,
                                                                                  0UL}}}},
                            {0, 0}, {0U, {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0,
                                                                 0UL}}}}, {0, 0}}},
                            0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL, 0, 0, 0UL, 0, 0,
                                                    0, {(char)0, (char)0, (char)0,
                                                        (char)0, (char)0, (char)0,
                                                        (char)0, (char)0, (char)0,
                                                        (char)0, (char)0, (char)0,
                                                        (char)0, (char)0, (char)0,
                                                        (char)0}, {0, {0, 0}, 0, 0,
                                                                   0UL}}, 0UL, {{0L},
                                                                                {0,
                                                                                 0},
                                                                                0,
                                                                                {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
                            {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                               0}},
                            {0}, {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, (unsigned char)0,
                            (unsigned char)0, (unsigned char)0, 0, 0, 0, 0, 0UL, 0UL,
                            0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0, 0},
    0, 0, {0, 0}, 0, {0}, 0U, 0U, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}},
    {0, 0}, {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
struct device *grudev  =    & gru_device;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
int gru_cpu_fault_map_id(void) 
{ 
  int cpu ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int id ;
  int core ;
  void const   *__vpp_verify___0 ;
  unsigned long __ptr ;
  void const   *__vpp_verify___1 ;
  unsigned long __ptr___0 ;
  void const   *__vpp_verify___2 ;
  unsigned long __ptr___1 ;

  {
#line 60
  __vpp_verify = (void const   *)0;
  {
#line 60
  if (4UL == 1UL) {
#line 60
    goto case_1;
  } else {

  }
#line 60
  if (4UL == 2UL) {
#line 60
    goto case_2___0;
  } else {

  }
#line 60
  if (4UL == 4UL) {
#line 60
    goto case_4___1;
  } else {

  }
#line 60
  if (4UL == 8UL) {
#line 60
    goto case_8___2;
  } else {

  }
#line 60
  goto switch_default___3;
  case_1: /* CIL Label */ ;
  {
#line 60
  if (4UL == 1UL) {
#line 60
    goto case_1___0;
  } else {

  }
#line 60
  if (4UL == 2UL) {
#line 60
    goto case_2;
  } else {

  }
#line 60
  if (4UL == 4UL) {
#line 60
    goto case_4;
  } else {

  }
#line 60
  if (4UL == 8UL) {
#line 60
    goto case_8;
  } else {

  }
#line 60
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 60
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 60
  goto ldv_33729;
  case_2: /* CIL Label */ 
#line 60
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 60
  goto ldv_33729;
  case_4: /* CIL Label */ 
#line 60
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 60
  goto ldv_33729;
  case_8: /* CIL Label */ 
#line 60
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 60
  goto ldv_33729;
  switch_default: /* CIL Label */ 
  {
#line 60
  __bad_percpu_size();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_33729: 
#line 60
  pscr_ret__ = pfo_ret__;
#line 60
  goto ldv_33735;
  case_2___0: /* CIL Label */ ;
  {
#line 60
  if (4UL == 1UL) {
#line 60
    goto case_1___1;
  } else {

  }
#line 60
  if (4UL == 2UL) {
#line 60
    goto case_2___1;
  } else {

  }
#line 60
  if (4UL == 4UL) {
#line 60
    goto case_4___0;
  } else {

  }
#line 60
  if (4UL == 8UL) {
#line 60
    goto case_8___0;
  } else {

  }
#line 60
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
#line 60
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 60
  goto ldv_33739;
  case_2___1: /* CIL Label */ 
#line 60
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 60
  goto ldv_33739;
  case_4___0: /* CIL Label */ 
#line 60
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 60
  goto ldv_33739;
  case_8___0: /* CIL Label */ 
#line 60
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 60
  goto ldv_33739;
  switch_default___0: /* CIL Label */ 
  {
#line 60
  __bad_percpu_size();
  }
  switch_break___1: /* CIL Label */ ;
  }
  ldv_33739: 
#line 60
  pscr_ret__ = pfo_ret_____0;
#line 60
  goto ldv_33735;
  case_4___1: /* CIL Label */ ;
  {
#line 60
  if (4UL == 1UL) {
#line 60
    goto case_1___2;
  } else {

  }
#line 60
  if (4UL == 2UL) {
#line 60
    goto case_2___2;
  } else {

  }
#line 60
  if (4UL == 4UL) {
#line 60
    goto case_4___2;
  } else {

  }
#line 60
  if (4UL == 8UL) {
#line 60
    goto case_8___1;
  } else {

  }
#line 60
  goto switch_default___1;
  case_1___2: /* CIL Label */ 
#line 60
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 60
  goto ldv_33748;
  case_2___2: /* CIL Label */ 
#line 60
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 60
  goto ldv_33748;
  case_4___2: /* CIL Label */ 
#line 60
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 60
  goto ldv_33748;
  case_8___1: /* CIL Label */ 
#line 60
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 60
  goto ldv_33748;
  switch_default___1: /* CIL Label */ 
  {
#line 60
  __bad_percpu_size();
  }
  switch_break___2: /* CIL Label */ ;
  }
  ldv_33748: 
#line 60
  pscr_ret__ = pfo_ret_____1;
#line 60
  goto ldv_33735;
  case_8___2: /* CIL Label */ ;
  {
#line 60
  if (4UL == 1UL) {
#line 60
    goto case_1___3;
  } else {

  }
#line 60
  if (4UL == 2UL) {
#line 60
    goto case_2___3;
  } else {

  }
#line 60
  if (4UL == 4UL) {
#line 60
    goto case_4___3;
  } else {

  }
#line 60
  if (4UL == 8UL) {
#line 60
    goto case_8___3;
  } else {

  }
#line 60
  goto switch_default___2;
  case_1___3: /* CIL Label */ 
#line 60
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 60
  goto ldv_33757;
  case_2___3: /* CIL Label */ 
#line 60
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 60
  goto ldv_33757;
  case_4___3: /* CIL Label */ 
#line 60
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 60
  goto ldv_33757;
  case_8___3: /* CIL Label */ 
#line 60
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 60
  goto ldv_33757;
  switch_default___2: /* CIL Label */ 
  {
#line 60
  __bad_percpu_size();
  }
  switch_break___3: /* CIL Label */ ;
  }
  ldv_33757: 
#line 60
  pscr_ret__ = pfo_ret_____2;
#line 60
  goto ldv_33735;
  switch_default___3: /* CIL Label */ 
  {
#line 60
  __bad_size_call_parameter();
  }
#line 60
  goto ldv_33735;
  switch_break: /* CIL Label */ ;
  }
  ldv_33735: 
#line 60
  cpu = pscr_ret__;
#line 63
  __vpp_verify___0 = (void const   *)0;
#line 63
  __asm__  ("": "=r" (__ptr): "0" (& x86_cpu_to_apicid));
#line 63
  __vpp_verify___1 = (void const   *)0;
#line 63
  __asm__  ("": "=r" (__ptr___0): "0" (& x86_cpu_to_apicid));
#line 63
  core = (((int )*((u16 *)(__ptr + __per_cpu_offset[cpu])) >> 2) & 4) | (((int )*((u16 *)(__ptr___0 + __per_cpu_offset[cpu])) >> 1) & 3);
#line 64
  __vpp_verify___2 = (void const   *)0;
#line 64
  __asm__  ("": "=r" (__ptr___1): "0" (& x86_cpu_to_apicid));
#line 64
  id = core + (((int )*((u16 *)(__ptr___1 + __per_cpu_offset[cpu])) >> 5) & 1) * 8;
#line 65
  return (id);
}
}
#line 97 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int gru_wrap_asid(struct gru_state *gru ) 
{ 
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 99
  if ((int )gru_options & 1) {
#line 99
    __vpp_verify = (void const   *)0;
    {
#line 99
    if (4UL == 1UL) {
#line 99
      goto case_1;
    } else {

    }
#line 99
    if (4UL == 2UL) {
#line 99
      goto case_2___0;
    } else {

    }
#line 99
    if (4UL == 4UL) {
#line 99
      goto case_4___1;
    } else {

    }
#line 99
    if (4UL == 8UL) {
#line 99
      goto case_8___2;
    } else {

    }
#line 99
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 99
    if (4UL == 1UL) {
#line 99
      goto case_1___0;
    } else {

    }
#line 99
    if (4UL == 2UL) {
#line 99
      goto case_2;
    } else {

    }
#line 99
    if (4UL == 4UL) {
#line 99
      goto case_4;
    } else {

    }
#line 99
    if (4UL == 8UL) {
#line 99
      goto case_8;
    } else {

    }
#line 99
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 99
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 99
    goto ldv_33787;
    case_2: /* CIL Label */ 
#line 99
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 99
    goto ldv_33787;
    case_4: /* CIL Label */ 
#line 99
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 99
    goto ldv_33787;
    case_8: /* CIL Label */ 
#line 99
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 99
    goto ldv_33787;
    switch_default: /* CIL Label */ 
    {
#line 99
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_33787: 
#line 99
    pscr_ret__ = pfo_ret__;
#line 99
    goto ldv_33793;
    case_2___0: /* CIL Label */ ;
    {
#line 99
    if (4UL == 1UL) {
#line 99
      goto case_1___1;
    } else {

    }
#line 99
    if (4UL == 2UL) {
#line 99
      goto case_2___1;
    } else {

    }
#line 99
    if (4UL == 4UL) {
#line 99
      goto case_4___0;
    } else {

    }
#line 99
    if (4UL == 8UL) {
#line 99
      goto case_8___0;
    } else {

    }
#line 99
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 99
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 99
    goto ldv_33797;
    case_2___1: /* CIL Label */ 
#line 99
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 99
    goto ldv_33797;
    case_4___0: /* CIL Label */ 
#line 99
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 99
    goto ldv_33797;
    case_8___0: /* CIL Label */ 
#line 99
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 99
    goto ldv_33797;
    switch_default___0: /* CIL Label */ 
    {
#line 99
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_33797: 
#line 99
    pscr_ret__ = pfo_ret_____0;
#line 99
    goto ldv_33793;
    case_4___1: /* CIL Label */ ;
    {
#line 99
    if (4UL == 1UL) {
#line 99
      goto case_1___2;
    } else {

    }
#line 99
    if (4UL == 2UL) {
#line 99
      goto case_2___2;
    } else {

    }
#line 99
    if (4UL == 4UL) {
#line 99
      goto case_4___2;
    } else {

    }
#line 99
    if (4UL == 8UL) {
#line 99
      goto case_8___1;
    } else {

    }
#line 99
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 99
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 99
    goto ldv_33806;
    case_2___2: /* CIL Label */ 
#line 99
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 99
    goto ldv_33806;
    case_4___2: /* CIL Label */ 
#line 99
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 99
    goto ldv_33806;
    case_8___1: /* CIL Label */ 
#line 99
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 99
    goto ldv_33806;
    switch_default___1: /* CIL Label */ 
    {
#line 99
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_33806: 
#line 99
    pscr_ret__ = pfo_ret_____1;
#line 99
    goto ldv_33793;
    case_8___2: /* CIL Label */ ;
    {
#line 99
    if (4UL == 1UL) {
#line 99
      goto case_1___3;
    } else {

    }
#line 99
    if (4UL == 2UL) {
#line 99
      goto case_2___3;
    } else {

    }
#line 99
    if (4UL == 4UL) {
#line 99
      goto case_4___3;
    } else {

    }
#line 99
    if (4UL == 8UL) {
#line 99
      goto case_8___3;
    } else {

    }
#line 99
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 99
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 99
    goto ldv_33815;
    case_2___3: /* CIL Label */ 
#line 99
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 99
    goto ldv_33815;
    case_4___3: /* CIL Label */ 
#line 99
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 99
    goto ldv_33815;
    case_8___3: /* CIL Label */ 
#line 99
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 99
    goto ldv_33815;
    switch_default___2: /* CIL Label */ 
    {
#line 99
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_33815: 
#line 99
    pscr_ret__ = pfo_ret_____2;
#line 99
    goto ldv_33793;
    switch_default___3: /* CIL Label */ 
    {
#line 99
    __bad_size_call_parameter();
    }
#line 99
    goto ldv_33793;
    switch_break: /* CIL Label */ ;
    }
    ldv_33793: 
    {
#line 99
    printk("\017GRU:%d %s: gid %d\n", pscr_ret__, "gru_wrap_asid", (int )gru->gs_gid);
    }
  } else {

  }
#line 100
  if ((gru_options & 2UL) != 0UL) {
    {
#line 100
    atomic_long_inc(& gru_stats.asid_wrap);
    }
  } else {

  }
#line 101
  gru->gs_asid_gen = gru->gs_asid_gen + 1U;
#line 102
  return (8);
}
}
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int gru_reset_asid_limit(struct gru_state *gru , int asid ) 
{ 
  int i ;
  int gid ;
  int inuse_asid ;
  int limit ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;

  {
#line 110
  if ((int )gru_options & 1) {
#line 110
    __vpp_verify = (void const   *)0;
    {
#line 110
    if (4UL == 1UL) {
#line 110
      goto case_1;
    } else {

    }
#line 110
    if (4UL == 2UL) {
#line 110
      goto case_2___0;
    } else {

    }
#line 110
    if (4UL == 4UL) {
#line 110
      goto case_4___1;
    } else {

    }
#line 110
    if (4UL == 8UL) {
#line 110
      goto case_8___2;
    } else {

    }
#line 110
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 110
    if (4UL == 1UL) {
#line 110
      goto case_1___0;
    } else {

    }
#line 110
    if (4UL == 2UL) {
#line 110
      goto case_2;
    } else {

    }
#line 110
    if (4UL == 4UL) {
#line 110
      goto case_4;
    } else {

    }
#line 110
    if (4UL == 8UL) {
#line 110
      goto case_8;
    } else {

    }
#line 110
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 110
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 110
    goto ldv_33837;
    case_2: /* CIL Label */ 
#line 110
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 110
    goto ldv_33837;
    case_4: /* CIL Label */ 
#line 110
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 110
    goto ldv_33837;
    case_8: /* CIL Label */ 
#line 110
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 110
    goto ldv_33837;
    switch_default: /* CIL Label */ 
    {
#line 110
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_33837: 
#line 110
    pscr_ret__ = pfo_ret__;
#line 110
    goto ldv_33843;
    case_2___0: /* CIL Label */ ;
    {
#line 110
    if (4UL == 1UL) {
#line 110
      goto case_1___1;
    } else {

    }
#line 110
    if (4UL == 2UL) {
#line 110
      goto case_2___1;
    } else {

    }
#line 110
    if (4UL == 4UL) {
#line 110
      goto case_4___0;
    } else {

    }
#line 110
    if (4UL == 8UL) {
#line 110
      goto case_8___0;
    } else {

    }
#line 110
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 110
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 110
    goto ldv_33847;
    case_2___1: /* CIL Label */ 
#line 110
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 110
    goto ldv_33847;
    case_4___0: /* CIL Label */ 
#line 110
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 110
    goto ldv_33847;
    case_8___0: /* CIL Label */ 
#line 110
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 110
    goto ldv_33847;
    switch_default___0: /* CIL Label */ 
    {
#line 110
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_33847: 
#line 110
    pscr_ret__ = pfo_ret_____0;
#line 110
    goto ldv_33843;
    case_4___1: /* CIL Label */ ;
    {
#line 110
    if (4UL == 1UL) {
#line 110
      goto case_1___2;
    } else {

    }
#line 110
    if (4UL == 2UL) {
#line 110
      goto case_2___2;
    } else {

    }
#line 110
    if (4UL == 4UL) {
#line 110
      goto case_4___2;
    } else {

    }
#line 110
    if (4UL == 8UL) {
#line 110
      goto case_8___1;
    } else {

    }
#line 110
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 110
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 110
    goto ldv_33856;
    case_2___2: /* CIL Label */ 
#line 110
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 110
    goto ldv_33856;
    case_4___2: /* CIL Label */ 
#line 110
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 110
    goto ldv_33856;
    case_8___1: /* CIL Label */ 
#line 110
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 110
    goto ldv_33856;
    switch_default___1: /* CIL Label */ 
    {
#line 110
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_33856: 
#line 110
    pscr_ret__ = pfo_ret_____1;
#line 110
    goto ldv_33843;
    case_8___2: /* CIL Label */ ;
    {
#line 110
    if (4UL == 1UL) {
#line 110
      goto case_1___3;
    } else {

    }
#line 110
    if (4UL == 2UL) {
#line 110
      goto case_2___3;
    } else {

    }
#line 110
    if (4UL == 4UL) {
#line 110
      goto case_4___3;
    } else {

    }
#line 110
    if (4UL == 8UL) {
#line 110
      goto case_8___3;
    } else {

    }
#line 110
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 110
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 110
    goto ldv_33865;
    case_2___3: /* CIL Label */ 
#line 110
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 110
    goto ldv_33865;
    case_4___3: /* CIL Label */ 
#line 110
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 110
    goto ldv_33865;
    case_8___3: /* CIL Label */ 
#line 110
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 110
    goto ldv_33865;
    switch_default___2: /* CIL Label */ 
    {
#line 110
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_33865: 
#line 110
    pscr_ret__ = pfo_ret_____2;
#line 110
    goto ldv_33843;
    switch_default___3: /* CIL Label */ 
    {
#line 110
    __bad_size_call_parameter();
    }
#line 110
    goto ldv_33843;
    switch_break: /* CIL Label */ ;
    }
    ldv_33843: 
    {
#line 110
    printk("\017GRU:%d %s: gid %d, asid 0x%x\n", pscr_ret__, "gru_reset_asid_limit",
           (int )gru->gs_gid, asid);
    }
  } else {

  }
#line 111
  if ((gru_options & 2UL) != 0UL) {
    {
#line 111
    atomic_long_inc(& gru_stats.asid_next);
    }
  } else {

  }
#line 112
  limit = 16777200;
#line 113
  if (asid >= limit) {
    {
#line 114
    asid = gru_wrap_asid(gru);
    }
  } else {

  }
  {
#line 115
  gru_flush_all_tlb(gru);
#line 116
  gid = (int )gru->gs_gid;
  }
  again: 
#line 118
  i = 0;
#line 118
  goto ldv_33918;
  ldv_33917: ;
#line 119
  if ((unsigned long )gru->gs_gts[i] == (unsigned long )((struct gru_thread_state *)0)) {
#line 120
    goto ldv_33875;
  } else {
    {
#line 119
    tmp = is_kernel_context(gru->gs_gts[i]);
    }
#line 119
    if (tmp != 0) {
#line 120
      goto ldv_33875;
    } else {

    }
  }
#line 121
  inuse_asid = (int )((gru->gs_gts[i])->ts_gms)->ms_asids[gid].mt_asid;
#line 122
  if ((int )gru_options & 1) {
#line 122
    __vpp_verify___0 = (void const   *)0;
    {
#line 122
    if (4UL == 1UL) {
#line 122
      goto case_1___4;
    } else {

    }
#line 124
    if (4UL == 2UL) {
#line 124
      goto case_2___5;
    } else {

    }
#line 124
    if (4UL == 4UL) {
#line 124
      goto case_4___6;
    } else {

    }
#line 124
    if (4UL == 8UL) {
#line 124
      goto case_8___7;
    } else {

    }
#line 124
    goto switch_default___8;
    case_1___4: /* CIL Label */ ;
    {
#line 124
    if (4UL == 1UL) {
#line 124
      goto case_1___5;
    } else {

    }
#line 124
    if (4UL == 2UL) {
#line 124
      goto case_2___4;
    } else {

    }
#line 124
    if (4UL == 4UL) {
#line 124
      goto case_4___4;
    } else {

    }
#line 124
    if (4UL == 8UL) {
#line 124
      goto case_8___4;
    } else {

    }
#line 124
    goto switch_default___4;
    case_1___5: /* CIL Label */ 
#line 124
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 124
    goto ldv_33881;
    case_2___4: /* CIL Label */ 
#line 124
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 124
    goto ldv_33881;
    case_4___4: /* CIL Label */ 
#line 124
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 124
    goto ldv_33881;
    case_8___4: /* CIL Label */ 
#line 124
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 124
    goto ldv_33881;
    switch_default___4: /* CIL Label */ 
    {
#line 124
    __bad_percpu_size();
    }
    switch_break___5: /* CIL Label */ ;
    }
    ldv_33881: 
#line 124
    pscr_ret_____0 = pfo_ret_____3;
#line 124
    goto ldv_33887;
    case_2___5: /* CIL Label */ ;
    {
#line 124
    if (4UL == 1UL) {
#line 124
      goto case_1___6;
    } else {

    }
#line 124
    if (4UL == 2UL) {
#line 124
      goto case_2___6;
    } else {

    }
#line 124
    if (4UL == 4UL) {
#line 124
      goto case_4___5;
    } else {

    }
#line 124
    if (4UL == 8UL) {
#line 124
      goto case_8___5;
    } else {

    }
#line 124
    goto switch_default___5;
    case_1___6: /* CIL Label */ 
#line 124
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 124
    goto ldv_33891;
    case_2___6: /* CIL Label */ 
#line 124
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 124
    goto ldv_33891;
    case_4___5: /* CIL Label */ 
#line 124
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 124
    goto ldv_33891;
    case_8___5: /* CIL Label */ 
#line 124
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 124
    goto ldv_33891;
    switch_default___5: /* CIL Label */ 
    {
#line 124
    __bad_percpu_size();
    }
    switch_break___6: /* CIL Label */ ;
    }
    ldv_33891: 
#line 124
    pscr_ret_____0 = pfo_ret_____4;
#line 124
    goto ldv_33887;
    case_4___6: /* CIL Label */ ;
    {
#line 124
    if (4UL == 1UL) {
#line 124
      goto case_1___7;
    } else {

    }
#line 124
    if (4UL == 2UL) {
#line 124
      goto case_2___7;
    } else {

    }
#line 124
    if (4UL == 4UL) {
#line 124
      goto case_4___7;
    } else {

    }
#line 124
    if (4UL == 8UL) {
#line 124
      goto case_8___6;
    } else {

    }
#line 124
    goto switch_default___6;
    case_1___7: /* CIL Label */ 
#line 124
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 124
    goto ldv_33900;
    case_2___7: /* CIL Label */ 
#line 124
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 124
    goto ldv_33900;
    case_4___7: /* CIL Label */ 
#line 124
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 124
    goto ldv_33900;
    case_8___6: /* CIL Label */ 
#line 124
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 124
    goto ldv_33900;
    switch_default___6: /* CIL Label */ 
    {
#line 124
    __bad_percpu_size();
    }
    switch_break___7: /* CIL Label */ ;
    }
    ldv_33900: 
#line 124
    pscr_ret_____0 = pfo_ret_____5;
#line 124
    goto ldv_33887;
    case_8___7: /* CIL Label */ ;
    {
#line 124
    if (4UL == 1UL) {
#line 124
      goto case_1___8;
    } else {

    }
#line 124
    if (4UL == 2UL) {
#line 124
      goto case_2___8;
    } else {

    }
#line 124
    if (4UL == 4UL) {
#line 124
      goto case_4___8;
    } else {

    }
#line 124
    if (4UL == 8UL) {
#line 124
      goto case_8___8;
    } else {

    }
#line 124
    goto switch_default___7;
    case_1___8: /* CIL Label */ 
#line 124
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 124
    goto ldv_33909;
    case_2___8: /* CIL Label */ 
#line 124
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 124
    goto ldv_33909;
    case_4___8: /* CIL Label */ 
#line 124
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 124
    goto ldv_33909;
    case_8___8: /* CIL Label */ 
#line 124
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 124
    goto ldv_33909;
    switch_default___7: /* CIL Label */ 
    {
#line 124
    __bad_percpu_size();
    }
    switch_break___8: /* CIL Label */ ;
    }
    ldv_33909: 
#line 124
    pscr_ret_____0 = pfo_ret_____6;
#line 124
    goto ldv_33887;
    switch_default___8: /* CIL Label */ 
    {
#line 124
    __bad_size_call_parameter();
    }
#line 124
    goto ldv_33887;
    switch_break___4: /* CIL Label */ ;
    }
    ldv_33887: 
    {
#line 124
    printk("\017GRU:%d %s: gid %d, gts %p, gms %p, inuse 0x%x, cxt %d\n", pscr_ret_____0,
           "gru_reset_asid_limit", (int )gru->gs_gid, gru->gs_gts[i], (gru->gs_gts[i])->ts_gms,
           inuse_asid, i);
    }
  } else {

  }
#line 125
  if (inuse_asid == asid) {
#line 126
    asid = asid + 8;
#line 127
    if (asid >= limit) {
#line 132
      limit = 16777200;
#line 133
      if (asid > 16777199) {
        {
#line 134
        asid = gru_wrap_asid(gru);
        }
      } else {

      }
#line 135
      goto again;
    } else {

    }
  } else {

  }
#line 139
  if (inuse_asid > asid && inuse_asid < limit) {
#line 140
    limit = inuse_asid;
  } else {

  }
  ldv_33875: 
#line 118
  i = i + 1;
  ldv_33918: ;
#line 118
  if (i <= 15) {
#line 120
    goto ldv_33917;
  } else {

  }
#line 142
  gru->gs_asid_limit = (unsigned int )limit;
#line 143
  gru->gs_asid = (unsigned int )asid;
#line 144
  if ((int )gru_options & 1) {
#line 144
    __vpp_verify___1 = (void const   *)0;
    {
#line 144
    if (4UL == 1UL) {
#line 144
      goto case_1___9;
    } else {

    }
#line 145
    if (4UL == 2UL) {
#line 145
      goto case_2___10;
    } else {

    }
#line 145
    if (4UL == 4UL) {
#line 145
      goto case_4___11;
    } else {

    }
#line 145
    if (4UL == 8UL) {
#line 145
      goto case_8___12;
    } else {

    }
#line 145
    goto switch_default___13;
    case_1___9: /* CIL Label */ ;
    {
#line 145
    if (4UL == 1UL) {
#line 145
      goto case_1___10;
    } else {

    }
#line 145
    if (4UL == 2UL) {
#line 145
      goto case_2___9;
    } else {

    }
#line 145
    if (4UL == 4UL) {
#line 145
      goto case_4___9;
    } else {

    }
#line 145
    if (4UL == 8UL) {
#line 145
      goto case_8___9;
    } else {

    }
#line 145
    goto switch_default___9;
    case_1___10: /* CIL Label */ 
#line 145
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 145
    goto ldv_33925;
    case_2___9: /* CIL Label */ 
#line 145
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 145
    goto ldv_33925;
    case_4___9: /* CIL Label */ 
#line 145
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 145
    goto ldv_33925;
    case_8___9: /* CIL Label */ 
#line 145
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 145
    goto ldv_33925;
    switch_default___9: /* CIL Label */ 
    {
#line 145
    __bad_percpu_size();
    }
    switch_break___10: /* CIL Label */ ;
    }
    ldv_33925: 
#line 145
    pscr_ret_____1 = pfo_ret_____7;
#line 145
    goto ldv_33931;
    case_2___10: /* CIL Label */ ;
    {
#line 145
    if (4UL == 1UL) {
#line 145
      goto case_1___11;
    } else {

    }
#line 145
    if (4UL == 2UL) {
#line 145
      goto case_2___11;
    } else {

    }
#line 145
    if (4UL == 4UL) {
#line 145
      goto case_4___10;
    } else {

    }
#line 145
    if (4UL == 8UL) {
#line 145
      goto case_8___10;
    } else {

    }
#line 145
    goto switch_default___10;
    case_1___11: /* CIL Label */ 
#line 145
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 145
    goto ldv_33935;
    case_2___11: /* CIL Label */ 
#line 145
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 145
    goto ldv_33935;
    case_4___10: /* CIL Label */ 
#line 145
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 145
    goto ldv_33935;
    case_8___10: /* CIL Label */ 
#line 145
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 145
    goto ldv_33935;
    switch_default___10: /* CIL Label */ 
    {
#line 145
    __bad_percpu_size();
    }
    switch_break___11: /* CIL Label */ ;
    }
    ldv_33935: 
#line 145
    pscr_ret_____1 = pfo_ret_____8;
#line 145
    goto ldv_33931;
    case_4___11: /* CIL Label */ ;
    {
#line 145
    if (4UL == 1UL) {
#line 145
      goto case_1___12;
    } else {

    }
#line 145
    if (4UL == 2UL) {
#line 145
      goto case_2___12;
    } else {

    }
#line 145
    if (4UL == 4UL) {
#line 145
      goto case_4___12;
    } else {

    }
#line 145
    if (4UL == 8UL) {
#line 145
      goto case_8___11;
    } else {

    }
#line 145
    goto switch_default___11;
    case_1___12: /* CIL Label */ 
#line 145
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 145
    goto ldv_33944;
    case_2___12: /* CIL Label */ 
#line 145
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 145
    goto ldv_33944;
    case_4___12: /* CIL Label */ 
#line 145
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 145
    goto ldv_33944;
    case_8___11: /* CIL Label */ 
#line 145
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 145
    goto ldv_33944;
    switch_default___11: /* CIL Label */ 
    {
#line 145
    __bad_percpu_size();
    }
    switch_break___12: /* CIL Label */ ;
    }
    ldv_33944: 
#line 145
    pscr_ret_____1 = pfo_ret_____9;
#line 145
    goto ldv_33931;
    case_8___12: /* CIL Label */ ;
    {
#line 145
    if (4UL == 1UL) {
#line 145
      goto case_1___13;
    } else {

    }
#line 145
    if (4UL == 2UL) {
#line 145
      goto case_2___13;
    } else {

    }
#line 145
    if (4UL == 4UL) {
#line 145
      goto case_4___13;
    } else {

    }
#line 145
    if (4UL == 8UL) {
#line 145
      goto case_8___13;
    } else {

    }
#line 145
    goto switch_default___12;
    case_1___13: /* CIL Label */ 
#line 145
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 145
    goto ldv_33953;
    case_2___13: /* CIL Label */ 
#line 145
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 145
    goto ldv_33953;
    case_4___13: /* CIL Label */ 
#line 145
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 145
    goto ldv_33953;
    case_8___13: /* CIL Label */ 
#line 145
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 145
    goto ldv_33953;
    switch_default___12: /* CIL Label */ 
    {
#line 145
    __bad_percpu_size();
    }
    switch_break___13: /* CIL Label */ ;
    }
    ldv_33953: 
#line 145
    pscr_ret_____1 = pfo_ret_____10;
#line 145
    goto ldv_33931;
    switch_default___13: /* CIL Label */ 
    {
#line 145
    __bad_size_call_parameter();
    }
#line 145
    goto ldv_33931;
    switch_break___9: /* CIL Label */ ;
    }
    ldv_33931: 
    {
#line 145
    printk("\017GRU:%d %s: gid %d, new asid 0x%x, new_limit 0x%x\n", pscr_ret_____1,
           "gru_reset_asid_limit", (int )gru->gs_gid, asid, limit);
    }
  } else {

  }
#line 146
  return (asid);
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int gru_assign_asid(struct gru_state *gru ) 
{ 
  int asid ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 154
  gru->gs_asid = gru->gs_asid + 8U;
#line 155
  asid = (int )gru->gs_asid;
#line 156
  if ((unsigned int )asid >= gru->gs_asid_limit) {
    {
#line 157
    asid = gru_reset_asid_limit(gru, asid);
    }
  } else {

  }
#line 159
  if ((int )gru_options & 1) {
#line 159
    __vpp_verify = (void const   *)0;
    {
#line 159
    if (4UL == 1UL) {
#line 159
      goto case_1;
    } else {

    }
#line 159
    if (4UL == 2UL) {
#line 159
      goto case_2___0;
    } else {

    }
#line 159
    if (4UL == 4UL) {
#line 159
      goto case_4___1;
    } else {

    }
#line 159
    if (4UL == 8UL) {
#line 159
      goto case_8___2;
    } else {

    }
#line 159
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 159
    if (4UL == 1UL) {
#line 159
      goto case_1___0;
    } else {

    }
#line 159
    if (4UL == 2UL) {
#line 159
      goto case_2;
    } else {

    }
#line 159
    if (4UL == 4UL) {
#line 159
      goto case_4;
    } else {

    }
#line 159
    if (4UL == 8UL) {
#line 159
      goto case_8;
    } else {

    }
#line 159
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 159
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 159
    goto ldv_33970;
    case_2: /* CIL Label */ 
#line 159
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 159
    goto ldv_33970;
    case_4: /* CIL Label */ 
#line 159
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 159
    goto ldv_33970;
    case_8: /* CIL Label */ 
#line 159
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 159
    goto ldv_33970;
    switch_default: /* CIL Label */ 
    {
#line 159
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_33970: 
#line 159
    pscr_ret__ = pfo_ret__;
#line 159
    goto ldv_33976;
    case_2___0: /* CIL Label */ ;
    {
#line 159
    if (4UL == 1UL) {
#line 159
      goto case_1___1;
    } else {

    }
#line 159
    if (4UL == 2UL) {
#line 159
      goto case_2___1;
    } else {

    }
#line 159
    if (4UL == 4UL) {
#line 159
      goto case_4___0;
    } else {

    }
#line 159
    if (4UL == 8UL) {
#line 159
      goto case_8___0;
    } else {

    }
#line 159
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 159
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 159
    goto ldv_33980;
    case_2___1: /* CIL Label */ 
#line 159
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 159
    goto ldv_33980;
    case_4___0: /* CIL Label */ 
#line 159
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 159
    goto ldv_33980;
    case_8___0: /* CIL Label */ 
#line 159
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 159
    goto ldv_33980;
    switch_default___0: /* CIL Label */ 
    {
#line 159
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_33980: 
#line 159
    pscr_ret__ = pfo_ret_____0;
#line 159
    goto ldv_33976;
    case_4___1: /* CIL Label */ ;
    {
#line 159
    if (4UL == 1UL) {
#line 159
      goto case_1___2;
    } else {

    }
#line 159
    if (4UL == 2UL) {
#line 159
      goto case_2___2;
    } else {

    }
#line 159
    if (4UL == 4UL) {
#line 159
      goto case_4___2;
    } else {

    }
#line 159
    if (4UL == 8UL) {
#line 159
      goto case_8___1;
    } else {

    }
#line 159
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 159
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 159
    goto ldv_33989;
    case_2___2: /* CIL Label */ 
#line 159
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 159
    goto ldv_33989;
    case_4___2: /* CIL Label */ 
#line 159
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 159
    goto ldv_33989;
    case_8___1: /* CIL Label */ 
#line 159
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 159
    goto ldv_33989;
    switch_default___1: /* CIL Label */ 
    {
#line 159
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_33989: 
#line 159
    pscr_ret__ = pfo_ret_____1;
#line 159
    goto ldv_33976;
    case_8___2: /* CIL Label */ ;
    {
#line 159
    if (4UL == 1UL) {
#line 159
      goto case_1___3;
    } else {

    }
#line 159
    if (4UL == 2UL) {
#line 159
      goto case_2___3;
    } else {

    }
#line 159
    if (4UL == 4UL) {
#line 159
      goto case_4___3;
    } else {

    }
#line 159
    if (4UL == 8UL) {
#line 159
      goto case_8___3;
    } else {

    }
#line 159
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 159
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 159
    goto ldv_33998;
    case_2___3: /* CIL Label */ 
#line 159
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 159
    goto ldv_33998;
    case_4___3: /* CIL Label */ 
#line 159
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 159
    goto ldv_33998;
    case_8___3: /* CIL Label */ 
#line 159
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 159
    goto ldv_33998;
    switch_default___2: /* CIL Label */ 
    {
#line 159
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_33998: 
#line 159
    pscr_ret__ = pfo_ret_____2;
#line 159
    goto ldv_33976;
    switch_default___3: /* CIL Label */ 
    {
#line 159
    __bad_size_call_parameter();
    }
#line 159
    goto ldv_33976;
    switch_break: /* CIL Label */ ;
    }
    ldv_33976: 
    {
#line 159
    printk("\017GRU:%d %s: gid %d, asid 0x%x\n", pscr_ret__, "gru_assign_asid", (int )gru->gs_gid,
           asid);
    }
  } else {

  }
#line 160
  return (asid);
}
}
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static unsigned long reserve_resources(unsigned long *p , int n , int mmax , char *idx ) 
{ 
  unsigned long bits ;
  int i ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 170
  bits = 0UL;
#line 173
  goto ldv_34016;
  ldv_34015: 
  {
#line 174
  tmp = ldv_find_first_bit_95((unsigned long const   *)p, (unsigned long )mmax);
#line 174
  i = (int )tmp;
  }
#line 175
  if (i == mmax) {
    {
#line 176
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                         "i" (176), "i" (12UL));
#line 176
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 177
  __clear_bit((long )i, (unsigned long volatile   *)p);
#line 178
  __set_bit((long )i, (unsigned long volatile   *)(& bits));
  }
#line 179
  if ((unsigned long )idx != (unsigned long )((char *)0)) {
#line 180
    tmp___0 = idx;
#line 180
    idx = idx + 1;
#line 180
    *tmp___0 = (char )i;
  } else {

  }
  ldv_34016: 
#line 173
  tmp___1 = n;
#line 173
  n = n - 1;
#line 173
  if (tmp___1 != 0) {
#line 175
    goto ldv_34015;
  } else {

  }

#line 182
  return (bits);
}
}
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
unsigned long gru_reserve_cb_resources(struct gru_state *gru , int cbr_au_count ,
                                       char *cbmap ) 
{ 
  unsigned long tmp ;

  {
  {
#line 188
  tmp = reserve_resources(& gru->gs_cbr_map, cbr_au_count, 64, cbmap);
  }
#line 188
  return (tmp);
}
}
#line 192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
unsigned long gru_reserve_ds_resources(struct gru_state *gru , int dsr_au_count ,
                                       char *dsmap ) 
{ 
  unsigned long tmp ;

  {
  {
#line 195
  tmp = reserve_resources(& gru->gs_dsr_map, dsr_au_count, 32, dsmap);
  }
#line 195
  return (tmp);
}
}
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void reserve_gru_resources(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 


  {
  {
#line 202
  gru->gs_active_contexts = (unsigned short )((int )gru->gs_active_contexts + 1);
#line 203
  gts->ts_cbr_map = gru_reserve_cb_resources(gru, (int )gts->ts_cbr_au_count, (char *)(& gts->ts_cbr_idx));
#line 206
  gts->ts_dsr_map = gru_reserve_ds_resources(gru, (int )gts->ts_dsr_au_count, (char *)0);
  }
#line 208
  return;
}
}
#line 210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void free_gru_resources(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 


  {
#line 213
  gru->gs_active_contexts = (unsigned short )((int )gru->gs_active_contexts - 1);
#line 214
  gru->gs_cbr_map = gru->gs_cbr_map | gts->ts_cbr_map;
#line 215
  gru->gs_dsr_map = gru->gs_dsr_map | gts->ts_dsr_map;
#line 216
  return;
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int check_gru_resources(struct gru_state *gru , int cbr_au_count , int dsr_au_count ,
                               int max_active_contexts ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 228
  tmp = __arch_hweight64((__u64 )gru->gs_cbr_map);
  }
#line 228
  if (tmp >= (unsigned long )cbr_au_count) {
    {
#line 228
    tmp___0 = __arch_hweight64((__u64 )gru->gs_dsr_map);
    }
#line 228
    if (tmp___0 >= (unsigned long )dsr_au_count) {
#line 228
      if ((int )gru->gs_active_contexts < max_active_contexts) {
#line 228
        tmp___1 = 1;
      } else {
#line 228
        tmp___1 = 0;
      }
    } else {
#line 228
      tmp___1 = 0;
    }
  } else {
#line 228
    tmp___1 = 0;
  }
#line 228
  return (tmp___1);
}
}
#line 237 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int gru_load_mm_tracker(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 
  struct gru_mm_struct *gms ;
  struct gru_mm_tracker *asids ;
  unsigned short ctxbitmap ;
  int asid ;
  long tmp ;
  int tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 240
  gms = gts->ts_gms;
#line 241
  asids = (struct gru_mm_tracker *)(& gms->ms_asids) + (unsigned long )gru->gs_gid;
#line 242
  ctxbitmap = (unsigned short )(1 << gts->ts_ctxnum);
#line 245
  ldv_spin_lock_96(& gms->ms_asid_lock);
#line 246
  asid = (int )asids->mt_asid;
#line 248
  ldv_spin_lock_97(& gru->gs_asid_lock);
  }
#line 249
  if (asid == 0 || ((unsigned int )asids->mt_ctxbitmap == 0U && asids->mt_asid_gen != gru->gs_asid_gen)) {
    {
#line 251
    asid = gru_assign_asid(gru);
#line 252
    asids->mt_asid = (unsigned int )asid;
#line 253
    asids->mt_asid_gen = gru->gs_asid_gen;
    }
#line 254
    if ((gru_options & 2UL) != 0UL) {
      {
#line 254
      atomic_long_inc(& gru_stats.asid_new);
      }
    } else {

    }
  } else
#line 256
  if ((gru_options & 2UL) != 0UL) {
    {
#line 256
    atomic_long_inc(& gru_stats.asid_reuse);
    }
  } else {

  }
  {
#line 258
  ldv_spin_unlock_98(& gru->gs_asid_lock);
#line 260
  tmp = __builtin_expect((unsigned int )((int )asids->mt_ctxbitmap & (int )ctxbitmap) != 0U,
                         0L);
  }
#line 260
  if (tmp != 0L) {
    {
#line 260
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                         "i" (260), "i" (12UL));
#line 260
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 261
  asids->mt_ctxbitmap = (int )asids->mt_ctxbitmap | (int )ctxbitmap;
#line 262
  tmp___1 = variable_test_bit((long )gru->gs_gid, (unsigned long const volatile   *)(& gms->ms_asidmap));
  }
#line 262
  if (tmp___1 == 0) {
    {
#line 263
    __set_bit((long )gru->gs_gid, (unsigned long volatile   *)(& gms->ms_asidmap));
    }
  } else {

  }
  {
#line 264
  ldv_spin_unlock_99(& gms->ms_asid_lock);
  }
#line 266
  if ((int )gru_options & 1) {
#line 266
    __vpp_verify = (void const   *)0;
    {
#line 266
    if (4UL == 1UL) {
#line 266
      goto case_1;
    } else {

    }
#line 269
    if (4UL == 2UL) {
#line 269
      goto case_2___0;
    } else {

    }
#line 269
    if (4UL == 4UL) {
#line 269
      goto case_4___1;
    } else {

    }
#line 269
    if (4UL == 8UL) {
#line 269
      goto case_8___2;
    } else {

    }
#line 269
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 269
    if (4UL == 1UL) {
#line 269
      goto case_1___0;
    } else {

    }
#line 269
    if (4UL == 2UL) {
#line 269
      goto case_2;
    } else {

    }
#line 269
    if (4UL == 4UL) {
#line 269
      goto case_4;
    } else {

    }
#line 269
    if (4UL == 8UL) {
#line 269
      goto case_8;
    } else {

    }
#line 269
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 269
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 269
    goto ldv_34055;
    case_2: /* CIL Label */ 
#line 269
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 269
    goto ldv_34055;
    case_4: /* CIL Label */ 
#line 269
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 269
    goto ldv_34055;
    case_8: /* CIL Label */ 
#line 269
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 269
    goto ldv_34055;
    switch_default: /* CIL Label */ 
    {
#line 269
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34055: 
#line 269
    pscr_ret__ = pfo_ret__;
#line 269
    goto ldv_34061;
    case_2___0: /* CIL Label */ ;
    {
#line 269
    if (4UL == 1UL) {
#line 269
      goto case_1___1;
    } else {

    }
#line 269
    if (4UL == 2UL) {
#line 269
      goto case_2___1;
    } else {

    }
#line 269
    if (4UL == 4UL) {
#line 269
      goto case_4___0;
    } else {

    }
#line 269
    if (4UL == 8UL) {
#line 269
      goto case_8___0;
    } else {

    }
#line 269
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 269
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 269
    goto ldv_34065;
    case_2___1: /* CIL Label */ 
#line 269
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 269
    goto ldv_34065;
    case_4___0: /* CIL Label */ 
#line 269
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 269
    goto ldv_34065;
    case_8___0: /* CIL Label */ 
#line 269
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 269
    goto ldv_34065;
    switch_default___0: /* CIL Label */ 
    {
#line 269
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34065: 
#line 269
    pscr_ret__ = pfo_ret_____0;
#line 269
    goto ldv_34061;
    case_4___1: /* CIL Label */ ;
    {
#line 269
    if (4UL == 1UL) {
#line 269
      goto case_1___2;
    } else {

    }
#line 269
    if (4UL == 2UL) {
#line 269
      goto case_2___2;
    } else {

    }
#line 269
    if (4UL == 4UL) {
#line 269
      goto case_4___2;
    } else {

    }
#line 269
    if (4UL == 8UL) {
#line 269
      goto case_8___1;
    } else {

    }
#line 269
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 269
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 269
    goto ldv_34074;
    case_2___2: /* CIL Label */ 
#line 269
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 269
    goto ldv_34074;
    case_4___2: /* CIL Label */ 
#line 269
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 269
    goto ldv_34074;
    case_8___1: /* CIL Label */ 
#line 269
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 269
    goto ldv_34074;
    switch_default___1: /* CIL Label */ 
    {
#line 269
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34074: 
#line 269
    pscr_ret__ = pfo_ret_____1;
#line 269
    goto ldv_34061;
    case_8___2: /* CIL Label */ ;
    {
#line 269
    if (4UL == 1UL) {
#line 269
      goto case_1___3;
    } else {

    }
#line 269
    if (4UL == 2UL) {
#line 269
      goto case_2___3;
    } else {

    }
#line 269
    if (4UL == 4UL) {
#line 269
      goto case_4___3;
    } else {

    }
#line 269
    if (4UL == 8UL) {
#line 269
      goto case_8___3;
    } else {

    }
#line 269
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 269
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 269
    goto ldv_34083;
    case_2___3: /* CIL Label */ 
#line 269
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 269
    goto ldv_34083;
    case_4___3: /* CIL Label */ 
#line 269
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 269
    goto ldv_34083;
    case_8___3: /* CIL Label */ 
#line 269
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 269
    goto ldv_34083;
    switch_default___2: /* CIL Label */ 
    {
#line 269
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34083: 
#line 269
    pscr_ret__ = pfo_ret_____2;
#line 269
    goto ldv_34061;
    switch_default___3: /* CIL Label */ 
    {
#line 269
    __bad_size_call_parameter();
    }
#line 269
    goto ldv_34061;
    switch_break: /* CIL Label */ ;
    }
    ldv_34061: 
    {
#line 269
    printk("\017GRU:%d %s: gid %d, gts %p, gms %p, ctxnum %d, asid 0x%x, asidmap 0x%lx\n",
           pscr_ret__, "gru_load_mm_tracker", (int )gru->gs_gid, gts, gms, gts->ts_ctxnum,
           asid, gms->ms_asidmap[0]);
    }
  } else {

  }
#line 270
  return (asid);
}
}
#line 273 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void gru_unload_mm_tracker(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 
  struct gru_mm_struct *gms ;
  struct gru_mm_tracker *asids ;
  unsigned short ctxbitmap ;
  long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 276
  gms = gts->ts_gms;
#line 280
  asids = (struct gru_mm_tracker *)(& gms->ms_asids) + (unsigned long )gru->gs_gid;
#line 281
  ctxbitmap = (unsigned short )(1 << gts->ts_ctxnum);
#line 282
  ldv_spin_lock_96(& gms->ms_asid_lock);
#line 283
  ldv_spin_lock_97(& gru->gs_asid_lock);
#line 284
  tmp = __builtin_expect(((int )asids->mt_ctxbitmap & (int )ctxbitmap) != (int )ctxbitmap,
                         0L);
  }
#line 284
  if (tmp != 0L) {
    {
#line 284
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                         "i" (284), "i" (12UL));
#line 284
    __builtin_unreachable();
    }
  } else {

  }
#line 285
  asids->mt_ctxbitmap = (int )asids->mt_ctxbitmap ^ (int )ctxbitmap;
#line 286
  if ((int )gru_options & 1) {
#line 286
    __vpp_verify = (void const   *)0;
    {
#line 286
    if (4UL == 1UL) {
#line 286
      goto case_1;
    } else {

    }
#line 287
    if (4UL == 2UL) {
#line 287
      goto case_2___0;
    } else {

    }
#line 287
    if (4UL == 4UL) {
#line 287
      goto case_4___1;
    } else {

    }
#line 287
    if (4UL == 8UL) {
#line 287
      goto case_8___2;
    } else {

    }
#line 287
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 287
    if (4UL == 1UL) {
#line 287
      goto case_1___0;
    } else {

    }
#line 287
    if (4UL == 2UL) {
#line 287
      goto case_2;
    } else {

    }
#line 287
    if (4UL == 4UL) {
#line 287
      goto case_4;
    } else {

    }
#line 287
    if (4UL == 8UL) {
#line 287
      goto case_8;
    } else {

    }
#line 287
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 287
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 287
    goto ldv_34104;
    case_2: /* CIL Label */ 
#line 287
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 287
    goto ldv_34104;
    case_4: /* CIL Label */ 
#line 287
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 287
    goto ldv_34104;
    case_8: /* CIL Label */ 
#line 287
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 287
    goto ldv_34104;
    switch_default: /* CIL Label */ 
    {
#line 287
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34104: 
#line 287
    pscr_ret__ = pfo_ret__;
#line 287
    goto ldv_34110;
    case_2___0: /* CIL Label */ ;
    {
#line 287
    if (4UL == 1UL) {
#line 287
      goto case_1___1;
    } else {

    }
#line 287
    if (4UL == 2UL) {
#line 287
      goto case_2___1;
    } else {

    }
#line 287
    if (4UL == 4UL) {
#line 287
      goto case_4___0;
    } else {

    }
#line 287
    if (4UL == 8UL) {
#line 287
      goto case_8___0;
    } else {

    }
#line 287
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 287
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 287
    goto ldv_34114;
    case_2___1: /* CIL Label */ 
#line 287
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 287
    goto ldv_34114;
    case_4___0: /* CIL Label */ 
#line 287
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 287
    goto ldv_34114;
    case_8___0: /* CIL Label */ 
#line 287
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 287
    goto ldv_34114;
    switch_default___0: /* CIL Label */ 
    {
#line 287
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34114: 
#line 287
    pscr_ret__ = pfo_ret_____0;
#line 287
    goto ldv_34110;
    case_4___1: /* CIL Label */ ;
    {
#line 287
    if (4UL == 1UL) {
#line 287
      goto case_1___2;
    } else {

    }
#line 287
    if (4UL == 2UL) {
#line 287
      goto case_2___2;
    } else {

    }
#line 287
    if (4UL == 4UL) {
#line 287
      goto case_4___2;
    } else {

    }
#line 287
    if (4UL == 8UL) {
#line 287
      goto case_8___1;
    } else {

    }
#line 287
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 287
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 287
    goto ldv_34123;
    case_2___2: /* CIL Label */ 
#line 287
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 287
    goto ldv_34123;
    case_4___2: /* CIL Label */ 
#line 287
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 287
    goto ldv_34123;
    case_8___1: /* CIL Label */ 
#line 287
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 287
    goto ldv_34123;
    switch_default___1: /* CIL Label */ 
    {
#line 287
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34123: 
#line 287
    pscr_ret__ = pfo_ret_____1;
#line 287
    goto ldv_34110;
    case_8___2: /* CIL Label */ ;
    {
#line 287
    if (4UL == 1UL) {
#line 287
      goto case_1___3;
    } else {

    }
#line 287
    if (4UL == 2UL) {
#line 287
      goto case_2___3;
    } else {

    }
#line 287
    if (4UL == 4UL) {
#line 287
      goto case_4___3;
    } else {

    }
#line 287
    if (4UL == 8UL) {
#line 287
      goto case_8___3;
    } else {

    }
#line 287
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 287
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 287
    goto ldv_34132;
    case_2___3: /* CIL Label */ 
#line 287
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 287
    goto ldv_34132;
    case_4___3: /* CIL Label */ 
#line 287
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 287
    goto ldv_34132;
    case_8___3: /* CIL Label */ 
#line 287
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 287
    goto ldv_34132;
    switch_default___2: /* CIL Label */ 
    {
#line 287
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34132: 
#line 287
    pscr_ret__ = pfo_ret_____2;
#line 287
    goto ldv_34110;
    switch_default___3: /* CIL Label */ 
    {
#line 287
    __bad_size_call_parameter();
    }
#line 287
    goto ldv_34110;
    switch_break: /* CIL Label */ ;
    }
    ldv_34110: 
    {
#line 287
    printk("\017GRU:%d %s: gid %d, gts %p, gms %p, ctxnum 0x%d, asidmap 0x%lx\n",
           pscr_ret__, "gru_unload_mm_tracker", (int )gru->gs_gid, gts, gms, gts->ts_ctxnum,
           gms->ms_asidmap[0]);
    }
  } else {

  }
  {
#line 288
  ldv_spin_unlock_98(& gru->gs_asid_lock);
#line 289
  ldv_spin_unlock_99(& gms->ms_asid_lock);
  }
#line 290
  return;
}
}
#line 296 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
void gts_drop(struct gru_thread_state *gts ) 
{ 
  int tmp ;

  {
#line 298
  if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 298
    tmp = atomic_sub_return(1, & gts->ts_refcnt);
    }
#line 298
    if (tmp == 0) {
#line 299
      if ((unsigned long )gts->ts_gms != (unsigned long )((struct gru_mm_struct *)0)) {
        {
#line 300
        gru_drop_mmu_notifier(gts->ts_gms);
        }
      } else {

      }
      {
#line 301
      kfree((void const   *)gts);
      }
#line 302
      if ((gru_options & 2UL) != 0UL) {
        {
#line 302
        atomic_long_inc(& gru_stats.gts_free);
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 304
  return;
}
}
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static struct gru_thread_state *gru_find_current_gts_nolock(struct gru_vma_data *vdata ,
                                                            int tsid ) 
{ 
  struct gru_thread_state *gts ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
#line 314
  __mptr = (struct list_head  const  *)vdata->vd_head.next;
#line 314
  gts = (struct gru_thread_state *)__mptr;
#line 314
  goto ldv_34154;
  ldv_34153: ;
#line 315
  if (gts->ts_tsid == tsid) {
#line 316
    return (gts);
  } else {

  }
#line 314
  __mptr___0 = (struct list_head  const  *)gts->ts_next.next;
#line 314
  gts = (struct gru_thread_state *)__mptr___0;
  ldv_34154: ;
#line 314
  if ((unsigned long )(& gts->ts_next) != (unsigned long )(& vdata->vd_head)) {
#line 316
    goto ldv_34153;
  } else {

  }

#line 317
  return ((struct gru_thread_state *)0);
}
}
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
struct gru_thread_state *gru_alloc_gts(struct vm_area_struct *vma , int cbr_au_count ,
                                       int dsr_au_count , unsigned char tlb_preload_count ,
                                       int options , int tsid ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_mm_struct *gms ;
  int bytes ;
  void *tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct task_struct *tmp___1 ;
  bool tmp___2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  void *tmp___3 ;

  {
  {
#line 331
  bytes = (dsr_au_count * 4 + cbr_au_count) * 256;
#line 332
  bytes = (int )((unsigned int )bytes + 464U);
#line 333
  tmp = kmalloc((size_t )bytes, 208U);
#line 333
  gts = (struct gru_thread_state *)tmp;
  }
#line 334
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 335
    tmp___0 = ERR_PTR(-12L);
    }
#line 335
    return ((struct gru_thread_state *)tmp___0);
  } else {

  }
#line 337
  if ((gru_options & 2UL) != 0UL) {
    {
#line 337
    atomic_long_inc(& gru_stats.gts_alloc);
    }
  } else {

  }
  {
#line 338
  __memset((void *)gts, 0, 464UL);
#line 339
  atomic_set(& gts->ts_refcnt, 1);
#line 340
  __mutex_init(& gts->ts_ctxlock, "&gts->ts_ctxlock", & __key);
#line 341
  gts->ts_cbr_au_count = (unsigned char )cbr_au_count;
#line 342
  gts->ts_dsr_au_count = (unsigned char )dsr_au_count;
#line 343
  gts->ts_tlb_preload_count = tlb_preload_count;
#line 344
  gts->ts_user_options = (long )options;
#line 345
  gts->ts_user_blade_id = -1;
#line 346
  gts->ts_user_chiplet_id = -1;
#line 347
  gts->ts_tsid = tsid;
#line 348
  gts->ts_ctxnum = -1;
#line 349
  gts->ts_tlb_int_select = -1;
#line 350
  gts->ts_cch_req_slice = -1;
#line 351
  gts->ts_sizeavail = 1U;
  }
#line 352
  if ((unsigned long )vma != (unsigned long )((struct vm_area_struct *)0)) {
    {
#line 353
    tmp___1 = get_current___0();
#line 353
    gts->ts_mm = tmp___1->mm;
#line 354
    gts->ts_vma = vma;
#line 355
    gms = gru_register_mmu_notifier();
#line 356
    tmp___2 = IS_ERR((void const   *)gms);
    }
#line 356
    if ((int )tmp___2) {
#line 357
      goto err;
    } else {

    }
#line 358
    gts->ts_gms = gms;
  } else {

  }
#line 361
  if ((int )gru_options & 1) {
#line 361
    __vpp_verify = (void const   *)0;
    {
#line 361
    if (4UL == 1UL) {
#line 361
      goto case_1;
    } else {

    }
#line 361
    if (4UL == 2UL) {
#line 361
      goto case_2___0;
    } else {

    }
#line 361
    if (4UL == 4UL) {
#line 361
      goto case_4___1;
    } else {

    }
#line 361
    if (4UL == 8UL) {
#line 361
      goto case_8___2;
    } else {

    }
#line 361
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 361
    if (4UL == 1UL) {
#line 361
      goto case_1___0;
    } else {

    }
#line 361
    if (4UL == 2UL) {
#line 361
      goto case_2;
    } else {

    }
#line 361
    if (4UL == 4UL) {
#line 361
      goto case_4;
    } else {

    }
#line 361
    if (4UL == 8UL) {
#line 361
      goto case_8;
    } else {

    }
#line 361
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 361
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 361
    goto ldv_34174;
    case_2: /* CIL Label */ 
#line 361
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 361
    goto ldv_34174;
    case_4: /* CIL Label */ 
#line 361
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 361
    goto ldv_34174;
    case_8: /* CIL Label */ 
#line 361
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 361
    goto ldv_34174;
    switch_default: /* CIL Label */ 
    {
#line 361
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34174: 
#line 361
    pscr_ret__ = pfo_ret__;
#line 361
    goto ldv_34180;
    case_2___0: /* CIL Label */ ;
    {
#line 361
    if (4UL == 1UL) {
#line 361
      goto case_1___1;
    } else {

    }
#line 361
    if (4UL == 2UL) {
#line 361
      goto case_2___1;
    } else {

    }
#line 361
    if (4UL == 4UL) {
#line 361
      goto case_4___0;
    } else {

    }
#line 361
    if (4UL == 8UL) {
#line 361
      goto case_8___0;
    } else {

    }
#line 361
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 361
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 361
    goto ldv_34184;
    case_2___1: /* CIL Label */ 
#line 361
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 361
    goto ldv_34184;
    case_4___0: /* CIL Label */ 
#line 361
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 361
    goto ldv_34184;
    case_8___0: /* CIL Label */ 
#line 361
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 361
    goto ldv_34184;
    switch_default___0: /* CIL Label */ 
    {
#line 361
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34184: 
#line 361
    pscr_ret__ = pfo_ret_____0;
#line 361
    goto ldv_34180;
    case_4___1: /* CIL Label */ ;
    {
#line 361
    if (4UL == 1UL) {
#line 361
      goto case_1___2;
    } else {

    }
#line 361
    if (4UL == 2UL) {
#line 361
      goto case_2___2;
    } else {

    }
#line 361
    if (4UL == 4UL) {
#line 361
      goto case_4___2;
    } else {

    }
#line 361
    if (4UL == 8UL) {
#line 361
      goto case_8___1;
    } else {

    }
#line 361
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 361
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 361
    goto ldv_34193;
    case_2___2: /* CIL Label */ 
#line 361
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 361
    goto ldv_34193;
    case_4___2: /* CIL Label */ 
#line 361
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 361
    goto ldv_34193;
    case_8___1: /* CIL Label */ 
#line 361
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 361
    goto ldv_34193;
    switch_default___1: /* CIL Label */ 
    {
#line 361
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34193: 
#line 361
    pscr_ret__ = pfo_ret_____1;
#line 361
    goto ldv_34180;
    case_8___2: /* CIL Label */ ;
    {
#line 361
    if (4UL == 1UL) {
#line 361
      goto case_1___3;
    } else {

    }
#line 361
    if (4UL == 2UL) {
#line 361
      goto case_2___3;
    } else {

    }
#line 361
    if (4UL == 4UL) {
#line 361
      goto case_4___3;
    } else {

    }
#line 361
    if (4UL == 8UL) {
#line 361
      goto case_8___3;
    } else {

    }
#line 361
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 361
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 361
    goto ldv_34202;
    case_2___3: /* CIL Label */ 
#line 361
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 361
    goto ldv_34202;
    case_4___3: /* CIL Label */ 
#line 361
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 361
    goto ldv_34202;
    case_8___3: /* CIL Label */ 
#line 361
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 361
    goto ldv_34202;
    switch_default___2: /* CIL Label */ 
    {
#line 361
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34202: 
#line 361
    pscr_ret__ = pfo_ret_____2;
#line 361
    goto ldv_34180;
    switch_default___3: /* CIL Label */ 
    {
#line 361
    __bad_size_call_parameter();
    }
#line 361
    goto ldv_34180;
    switch_break: /* CIL Label */ ;
    }
    ldv_34180: 
    {
#line 361
    printk("\017GRU:%d %s: alloc gts %p\n", pscr_ret__, "gru_alloc_gts", gts);
    }
  } else {

  }
#line 362
  return (gts);
  err: 
  {
#line 365
  gts_drop(gts);
#line 366
  tmp___3 = ERR_CAST((void const   *)gms);
  }
#line 366
  return ((struct gru_thread_state *)tmp___3);
}
}
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
struct gru_vma_data *gru_alloc_vma_data(struct vm_area_struct *vma , int tsid ) 
{ 
  struct gru_vma_data *vdata ;
  void *tmp ;
  struct lock_class_key __key ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 374
  vdata = (struct gru_vma_data *)0;
#line 376
  tmp = kmalloc(112UL, 208U);
#line 376
  vdata = (struct gru_vma_data *)tmp;
  }
#line 377
  if ((unsigned long )vdata == (unsigned long )((struct gru_vma_data *)0)) {
#line 378
    return ((struct gru_vma_data *)0);
  } else {

  }
#line 380
  if ((gru_options & 2UL) != 0UL) {
    {
#line 380
    atomic_long_inc(& gru_stats.vdata_alloc);
    }
  } else {

  }
  {
#line 381
  INIT_LIST_HEAD(& vdata->vd_head);
#line 382
  spinlock_check(& vdata->vd_lock);
#line 382
  __raw_spin_lock_init(& vdata->vd_lock.__annonCompField18.rlock, "&(&vdata->vd_lock)->rlock",
                       & __key);
  }
#line 383
  if ((int )gru_options & 1) {
#line 383
    __vpp_verify = (void const   *)0;
    {
#line 383
    if (4UL == 1UL) {
#line 383
      goto case_1;
    } else {

    }
#line 383
    if (4UL == 2UL) {
#line 383
      goto case_2___0;
    } else {

    }
#line 383
    if (4UL == 4UL) {
#line 383
      goto case_4___1;
    } else {

    }
#line 383
    if (4UL == 8UL) {
#line 383
      goto case_8___2;
    } else {

    }
#line 383
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 383
    if (4UL == 1UL) {
#line 383
      goto case_1___0;
    } else {

    }
#line 383
    if (4UL == 2UL) {
#line 383
      goto case_2;
    } else {

    }
#line 383
    if (4UL == 4UL) {
#line 383
      goto case_4;
    } else {

    }
#line 383
    if (4UL == 8UL) {
#line 383
      goto case_8;
    } else {

    }
#line 383
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 383
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 383
    goto ldv_34222;
    case_2: /* CIL Label */ 
#line 383
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 383
    goto ldv_34222;
    case_4: /* CIL Label */ 
#line 383
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 383
    goto ldv_34222;
    case_8: /* CIL Label */ 
#line 383
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 383
    goto ldv_34222;
    switch_default: /* CIL Label */ 
    {
#line 383
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34222: 
#line 383
    pscr_ret__ = pfo_ret__;
#line 383
    goto ldv_34228;
    case_2___0: /* CIL Label */ ;
    {
#line 383
    if (4UL == 1UL) {
#line 383
      goto case_1___1;
    } else {

    }
#line 383
    if (4UL == 2UL) {
#line 383
      goto case_2___1;
    } else {

    }
#line 383
    if (4UL == 4UL) {
#line 383
      goto case_4___0;
    } else {

    }
#line 383
    if (4UL == 8UL) {
#line 383
      goto case_8___0;
    } else {

    }
#line 383
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 383
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 383
    goto ldv_34232;
    case_2___1: /* CIL Label */ 
#line 383
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 383
    goto ldv_34232;
    case_4___0: /* CIL Label */ 
#line 383
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 383
    goto ldv_34232;
    case_8___0: /* CIL Label */ 
#line 383
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 383
    goto ldv_34232;
    switch_default___0: /* CIL Label */ 
    {
#line 383
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34232: 
#line 383
    pscr_ret__ = pfo_ret_____0;
#line 383
    goto ldv_34228;
    case_4___1: /* CIL Label */ ;
    {
#line 383
    if (4UL == 1UL) {
#line 383
      goto case_1___2;
    } else {

    }
#line 383
    if (4UL == 2UL) {
#line 383
      goto case_2___2;
    } else {

    }
#line 383
    if (4UL == 4UL) {
#line 383
      goto case_4___2;
    } else {

    }
#line 383
    if (4UL == 8UL) {
#line 383
      goto case_8___1;
    } else {

    }
#line 383
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 383
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 383
    goto ldv_34241;
    case_2___2: /* CIL Label */ 
#line 383
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 383
    goto ldv_34241;
    case_4___2: /* CIL Label */ 
#line 383
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 383
    goto ldv_34241;
    case_8___1: /* CIL Label */ 
#line 383
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 383
    goto ldv_34241;
    switch_default___1: /* CIL Label */ 
    {
#line 383
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34241: 
#line 383
    pscr_ret__ = pfo_ret_____1;
#line 383
    goto ldv_34228;
    case_8___2: /* CIL Label */ ;
    {
#line 383
    if (4UL == 1UL) {
#line 383
      goto case_1___3;
    } else {

    }
#line 383
    if (4UL == 2UL) {
#line 383
      goto case_2___3;
    } else {

    }
#line 383
    if (4UL == 4UL) {
#line 383
      goto case_4___3;
    } else {

    }
#line 383
    if (4UL == 8UL) {
#line 383
      goto case_8___3;
    } else {

    }
#line 383
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 383
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 383
    goto ldv_34250;
    case_2___3: /* CIL Label */ 
#line 383
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 383
    goto ldv_34250;
    case_4___3: /* CIL Label */ 
#line 383
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 383
    goto ldv_34250;
    case_8___3: /* CIL Label */ 
#line 383
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 383
    goto ldv_34250;
    switch_default___2: /* CIL Label */ 
    {
#line 383
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34250: 
#line 383
    pscr_ret__ = pfo_ret_____2;
#line 383
    goto ldv_34228;
    switch_default___3: /* CIL Label */ 
    {
#line 383
    __bad_size_call_parameter();
    }
#line 383
    goto ldv_34228;
    switch_break: /* CIL Label */ ;
    }
    ldv_34228: 
    {
#line 383
    printk("\017GRU:%d %s: alloc vdata %p\n", pscr_ret__, "gru_alloc_vma_data", vdata);
    }
  } else {

  }
#line 384
  return (vdata);
}
}
#line 390 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
struct gru_thread_state *gru_find_thread_state(struct vm_area_struct *vma , int tsid ) 
{ 
  struct gru_vma_data *vdata ;
  struct gru_thread_state *gts ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 393
  vdata = (struct gru_vma_data *)vma->vm_private_data;
#line 396
  ldv_spin_lock_104(& vdata->vd_lock);
#line 397
  gts = gru_find_current_gts_nolock(vdata, tsid);
#line 398
  ldv_spin_unlock_105(& vdata->vd_lock);
  }
#line 399
  if ((int )gru_options & 1) {
#line 399
    __vpp_verify = (void const   *)0;
    {
#line 399
    if (4UL == 1UL) {
#line 399
      goto case_1;
    } else {

    }
#line 399
    if (4UL == 2UL) {
#line 399
      goto case_2___0;
    } else {

    }
#line 399
    if (4UL == 4UL) {
#line 399
      goto case_4___1;
    } else {

    }
#line 399
    if (4UL == 8UL) {
#line 399
      goto case_8___2;
    } else {

    }
#line 399
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 399
    if (4UL == 1UL) {
#line 399
      goto case_1___0;
    } else {

    }
#line 399
    if (4UL == 2UL) {
#line 399
      goto case_2;
    } else {

    }
#line 399
    if (4UL == 4UL) {
#line 399
      goto case_4;
    } else {

    }
#line 399
    if (4UL == 8UL) {
#line 399
      goto case_8;
    } else {

    }
#line 399
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 399
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 399
    goto ldv_34270;
    case_2: /* CIL Label */ 
#line 399
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 399
    goto ldv_34270;
    case_4: /* CIL Label */ 
#line 399
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 399
    goto ldv_34270;
    case_8: /* CIL Label */ 
#line 399
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 399
    goto ldv_34270;
    switch_default: /* CIL Label */ 
    {
#line 399
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34270: 
#line 399
    pscr_ret__ = pfo_ret__;
#line 399
    goto ldv_34276;
    case_2___0: /* CIL Label */ ;
    {
#line 399
    if (4UL == 1UL) {
#line 399
      goto case_1___1;
    } else {

    }
#line 399
    if (4UL == 2UL) {
#line 399
      goto case_2___1;
    } else {

    }
#line 399
    if (4UL == 4UL) {
#line 399
      goto case_4___0;
    } else {

    }
#line 399
    if (4UL == 8UL) {
#line 399
      goto case_8___0;
    } else {

    }
#line 399
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 399
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 399
    goto ldv_34280;
    case_2___1: /* CIL Label */ 
#line 399
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 399
    goto ldv_34280;
    case_4___0: /* CIL Label */ 
#line 399
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 399
    goto ldv_34280;
    case_8___0: /* CIL Label */ 
#line 399
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 399
    goto ldv_34280;
    switch_default___0: /* CIL Label */ 
    {
#line 399
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34280: 
#line 399
    pscr_ret__ = pfo_ret_____0;
#line 399
    goto ldv_34276;
    case_4___1: /* CIL Label */ ;
    {
#line 399
    if (4UL == 1UL) {
#line 399
      goto case_1___2;
    } else {

    }
#line 399
    if (4UL == 2UL) {
#line 399
      goto case_2___2;
    } else {

    }
#line 399
    if (4UL == 4UL) {
#line 399
      goto case_4___2;
    } else {

    }
#line 399
    if (4UL == 8UL) {
#line 399
      goto case_8___1;
    } else {

    }
#line 399
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 399
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 399
    goto ldv_34289;
    case_2___2: /* CIL Label */ 
#line 399
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 399
    goto ldv_34289;
    case_4___2: /* CIL Label */ 
#line 399
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 399
    goto ldv_34289;
    case_8___1: /* CIL Label */ 
#line 399
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 399
    goto ldv_34289;
    switch_default___1: /* CIL Label */ 
    {
#line 399
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34289: 
#line 399
    pscr_ret__ = pfo_ret_____1;
#line 399
    goto ldv_34276;
    case_8___2: /* CIL Label */ ;
    {
#line 399
    if (4UL == 1UL) {
#line 399
      goto case_1___3;
    } else {

    }
#line 399
    if (4UL == 2UL) {
#line 399
      goto case_2___3;
    } else {

    }
#line 399
    if (4UL == 4UL) {
#line 399
      goto case_4___3;
    } else {

    }
#line 399
    if (4UL == 8UL) {
#line 399
      goto case_8___3;
    } else {

    }
#line 399
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 399
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 399
    goto ldv_34298;
    case_2___3: /* CIL Label */ 
#line 399
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 399
    goto ldv_34298;
    case_4___3: /* CIL Label */ 
#line 399
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 399
    goto ldv_34298;
    case_8___3: /* CIL Label */ 
#line 399
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 399
    goto ldv_34298;
    switch_default___2: /* CIL Label */ 
    {
#line 399
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34298: 
#line 399
    pscr_ret__ = pfo_ret_____2;
#line 399
    goto ldv_34276;
    switch_default___3: /* CIL Label */ 
    {
#line 399
    __bad_size_call_parameter();
    }
#line 399
    goto ldv_34276;
    switch_break: /* CIL Label */ ;
    }
    ldv_34276: 
    {
#line 399
    printk("\017GRU:%d %s: vma %p, gts %p\n", pscr_ret__, "gru_find_thread_state",
           vma, gts);
    }
  } else {

  }
#line 400
  return (gts);
}
}
#line 407 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
struct gru_thread_state *gru_alloc_thread_state(struct vm_area_struct *vma , int tsid ) 
{ 
  struct gru_vma_data *vdata ;
  struct gru_thread_state *gts ;
  struct gru_thread_state *ngts ;
  bool tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 410
  vdata = (struct gru_vma_data *)vma->vm_private_data;
#line 413
  gts = gru_alloc_gts(vma, vdata->vd_cbr_au_count, vdata->vd_dsr_au_count, (int )vdata->vd_tlb_preload_count,
                      (int )vdata->vd_user_options, tsid);
#line 417
  tmp = IS_ERR((void const   *)gts);
  }
#line 417
  if ((int )tmp) {
#line 418
    return (gts);
  } else {

  }
  {
#line 420
  ldv_spin_lock_104(& vdata->vd_lock);
#line 421
  ngts = gru_find_current_gts_nolock(vdata, tsid);
  }
#line 422
  if ((unsigned long )ngts != (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 423
    gts_drop(gts);
#line 424
    gts = ngts;
    }
#line 425
    if ((gru_options & 2UL) != 0UL) {
      {
#line 425
      atomic_long_inc(& gru_stats.gts_double_allocate);
      }
    } else {

    }
  } else {
    {
#line 427
    list_add(& gts->ts_next, & vdata->vd_head);
    }
  }
  {
#line 429
  ldv_spin_unlock_105(& vdata->vd_lock);
  }
#line 430
  if ((int )gru_options & 1) {
#line 430
    __vpp_verify = (void const   *)0;
    {
#line 430
    if (4UL == 1UL) {
#line 430
      goto case_1;
    } else {

    }
#line 430
    if (4UL == 2UL) {
#line 430
      goto case_2___0;
    } else {

    }
#line 430
    if (4UL == 4UL) {
#line 430
      goto case_4___1;
    } else {

    }
#line 430
    if (4UL == 8UL) {
#line 430
      goto case_8___2;
    } else {

    }
#line 430
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 430
    if (4UL == 1UL) {
#line 430
      goto case_1___0;
    } else {

    }
#line 430
    if (4UL == 2UL) {
#line 430
      goto case_2;
    } else {

    }
#line 430
    if (4UL == 4UL) {
#line 430
      goto case_4;
    } else {

    }
#line 430
    if (4UL == 8UL) {
#line 430
      goto case_8;
    } else {

    }
#line 430
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 430
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 430
    goto ldv_34319;
    case_2: /* CIL Label */ 
#line 430
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 430
    goto ldv_34319;
    case_4: /* CIL Label */ 
#line 430
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 430
    goto ldv_34319;
    case_8: /* CIL Label */ 
#line 430
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 430
    goto ldv_34319;
    switch_default: /* CIL Label */ 
    {
#line 430
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34319: 
#line 430
    pscr_ret__ = pfo_ret__;
#line 430
    goto ldv_34325;
    case_2___0: /* CIL Label */ ;
    {
#line 430
    if (4UL == 1UL) {
#line 430
      goto case_1___1;
    } else {

    }
#line 430
    if (4UL == 2UL) {
#line 430
      goto case_2___1;
    } else {

    }
#line 430
    if (4UL == 4UL) {
#line 430
      goto case_4___0;
    } else {

    }
#line 430
    if (4UL == 8UL) {
#line 430
      goto case_8___0;
    } else {

    }
#line 430
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 430
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 430
    goto ldv_34329;
    case_2___1: /* CIL Label */ 
#line 430
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 430
    goto ldv_34329;
    case_4___0: /* CIL Label */ 
#line 430
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 430
    goto ldv_34329;
    case_8___0: /* CIL Label */ 
#line 430
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 430
    goto ldv_34329;
    switch_default___0: /* CIL Label */ 
    {
#line 430
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34329: 
#line 430
    pscr_ret__ = pfo_ret_____0;
#line 430
    goto ldv_34325;
    case_4___1: /* CIL Label */ ;
    {
#line 430
    if (4UL == 1UL) {
#line 430
      goto case_1___2;
    } else {

    }
#line 430
    if (4UL == 2UL) {
#line 430
      goto case_2___2;
    } else {

    }
#line 430
    if (4UL == 4UL) {
#line 430
      goto case_4___2;
    } else {

    }
#line 430
    if (4UL == 8UL) {
#line 430
      goto case_8___1;
    } else {

    }
#line 430
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 430
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 430
    goto ldv_34338;
    case_2___2: /* CIL Label */ 
#line 430
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 430
    goto ldv_34338;
    case_4___2: /* CIL Label */ 
#line 430
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 430
    goto ldv_34338;
    case_8___1: /* CIL Label */ 
#line 430
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 430
    goto ldv_34338;
    switch_default___1: /* CIL Label */ 
    {
#line 430
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34338: 
#line 430
    pscr_ret__ = pfo_ret_____1;
#line 430
    goto ldv_34325;
    case_8___2: /* CIL Label */ ;
    {
#line 430
    if (4UL == 1UL) {
#line 430
      goto case_1___3;
    } else {

    }
#line 430
    if (4UL == 2UL) {
#line 430
      goto case_2___3;
    } else {

    }
#line 430
    if (4UL == 4UL) {
#line 430
      goto case_4___3;
    } else {

    }
#line 430
    if (4UL == 8UL) {
#line 430
      goto case_8___3;
    } else {

    }
#line 430
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 430
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 430
    goto ldv_34347;
    case_2___3: /* CIL Label */ 
#line 430
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 430
    goto ldv_34347;
    case_4___3: /* CIL Label */ 
#line 430
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 430
    goto ldv_34347;
    case_8___3: /* CIL Label */ 
#line 430
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 430
    goto ldv_34347;
    switch_default___2: /* CIL Label */ 
    {
#line 430
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34347: 
#line 430
    pscr_ret__ = pfo_ret_____2;
#line 430
    goto ldv_34325;
    switch_default___3: /* CIL Label */ 
    {
#line 430
    __bad_size_call_parameter();
    }
#line 430
    goto ldv_34325;
    switch_break: /* CIL Label */ ;
    }
    ldv_34325: 
    {
#line 430
    printk("\017GRU:%d %s: vma %p, gts %p\n", pscr_ret__, "gru_alloc_thread_state",
           vma, gts);
    }
  } else {

  }
#line 431
  return (gts);
}
}
#line 437 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void gru_free_gru_context(struct gru_thread_state *gts ) 
{ 
  struct gru_state *gru ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 441
  gru = gts->ts_gru;
#line 442
  if ((int )gru_options & 1) {
#line 442
    __vpp_verify = (void const   *)0;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2___0;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4___1;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8___2;
    } else {

    }
#line 442
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1___0;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8;
    } else {

    }
#line 442
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_34365;
    case_2: /* CIL Label */ 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_34365;
    case_4: /* CIL Label */ 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_34365;
    case_8: /* CIL Label */ 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_34365;
    switch_default: /* CIL Label */ 
    {
#line 442
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34365: 
#line 442
    pscr_ret__ = pfo_ret__;
#line 442
    goto ldv_34371;
    case_2___0: /* CIL Label */ ;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1___1;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2___1;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4___0;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8___0;
    } else {

    }
#line 442
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_34375;
    case_2___1: /* CIL Label */ 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_34375;
    case_4___0: /* CIL Label */ 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_34375;
    case_8___0: /* CIL Label */ 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_34375;
    switch_default___0: /* CIL Label */ 
    {
#line 442
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34375: 
#line 442
    pscr_ret__ = pfo_ret_____0;
#line 442
    goto ldv_34371;
    case_4___1: /* CIL Label */ ;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1___2;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2___2;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4___2;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8___1;
    } else {

    }
#line 442
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_34384;
    case_2___2: /* CIL Label */ 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_34384;
    case_4___2: /* CIL Label */ 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_34384;
    case_8___1: /* CIL Label */ 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_34384;
    switch_default___1: /* CIL Label */ 
    {
#line 442
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34384: 
#line 442
    pscr_ret__ = pfo_ret_____1;
#line 442
    goto ldv_34371;
    case_8___2: /* CIL Label */ ;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1___3;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2___3;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4___3;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8___3;
    } else {

    }
#line 442
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_34393;
    case_2___3: /* CIL Label */ 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_34393;
    case_4___3: /* CIL Label */ 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_34393;
    case_8___3: /* CIL Label */ 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_34393;
    switch_default___2: /* CIL Label */ 
    {
#line 442
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34393: 
#line 442
    pscr_ret__ = pfo_ret_____2;
#line 442
    goto ldv_34371;
    switch_default___3: /* CIL Label */ 
    {
#line 442
    __bad_size_call_parameter();
    }
#line 442
    goto ldv_34371;
    switch_break: /* CIL Label */ ;
    }
    ldv_34371: 
    {
#line 442
    printk("\017GRU:%d %s: gts %p, gid %d\n", pscr_ret__, "gru_free_gru_context",
           gts, (int )gru->gs_gid);
    }
  } else {

  }
  {
#line 444
  ldv_spin_lock_108(& gru->gs_lock);
#line 445
  gru->gs_gts[gts->ts_ctxnum] = (struct gru_thread_state *)0;
#line 446
  free_gru_resources(gru, gts);
#line 447
  tmp___0 = variable_test_bit((long )gts->ts_ctxnum, (unsigned long const volatile   *)(& gru->gs_context_map));
#line 447
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 447
  if (tmp___1 != 0L) {
    {
#line 447
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                         "i" (447), "i" (12UL));
#line 447
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 448
  __clear_bit((long )gts->ts_ctxnum, (unsigned long volatile   *)(& gru->gs_context_map));
#line 449
  gts->ts_ctxnum = -1;
#line 450
  gts->ts_gru = (struct gru_state *)0;
#line 451
  gts->ts_blade = -1;
#line 452
  ldv_spin_unlock_109(& gru->gs_lock);
#line 454
  gts_drop(gts);
  }
#line 455
  if ((gru_options & 2UL) != 0UL) {
    {
#line 455
    atomic_long_inc(& gru_stats.free_context);
    }
  } else {

  }
#line 456
  return;
}
}
#line 462 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void prefetch_data(void *p , int num , int stride ) 
{ 
  int tmp ;

  {
#line 464
  goto ldv_34408;
  ldv_34407: 
  {
#line 465
  prefetchw((void const   *)p);
#line 466
  p = p + (unsigned long )stride;
  }
  ldv_34408: 
#line 464
  tmp = num;
#line 464
  num = num - 1;
#line 464
  if (tmp > 0) {
#line 466
    goto ldv_34407;
  } else {

  }

#line 471
  return;
}
}
#line 470 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
__inline static long gru_copy_handle(void *d , void *s ) 
{ 


  {
  {
#line 472
  __memcpy(d, (void const   *)s, 64UL);
  }
#line 473
  return (64L);
}
}
#line 476 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void gru_prefetch_context(void *gseg , void *cb , void *cbe , unsigned long cbrmap ,
                                 unsigned long length ) 
{ 
  int i ;
  int scr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 481
  prefetch_data(gseg + 131072UL, (int )(length / 64UL), 64);
#line 484
  tmp = ldv_find_first_bit_110((unsigned long const   *)(& cbrmap), 64UL);
#line 484
  scr = (int )tmp;
  }
#line 484
  goto ldv_34427;
  ldv_34426: 
#line 484
  i = scr * 2;
#line 484
  goto ldv_34424;
  ldv_34423: 
  {
#line 485
  prefetch_data(cb, 1, 64);
#line 486
  prefetch_data(cbe + (unsigned long )(i * 256), 1, 64);
#line 488
  cb = cb + 256UL;
#line 484
  i = i + 1;
  }
  ldv_34424: ;
#line 484
  if (i < (scr + 1) * 2) {
#line 486
    goto ldv_34423;
  } else {

  }
  {
#line 484
  tmp___0 = ldv_find_next_bit_111((unsigned long const   *)(& cbrmap), 64UL, (unsigned long )(scr + 1));
#line 484
  scr = (int )tmp___0;
  }
  ldv_34427: ;
#line 484
  if (scr <= 63) {
#line 486
    goto ldv_34426;
  } else {

  }

#line 491
  return;
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void gru_load_context_data(void *save , void *grubase , int ctxnum , unsigned long cbrmap ,
                                  unsigned long dsrmap , int data_valid ) 
{ 
  void *gseg ;
  void *cb ;
  void *cbe ;
  unsigned long length ;
  int i ;
  int scr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 500
  gseg = grubase + (unsigned long )(ctxnum * 4194304);
#line 501
  cb = gseg;
#line 502
  cbe = grubase + 67174400UL;
#line 503
  tmp = __arch_hweight64((__u64 )dsrmap);
#line 503
  length = tmp * 1024UL;
#line 504
  gru_prefetch_context(gseg, cb, cbe, cbrmap, length);
#line 506
  tmp___0 = ldv_find_first_bit_112((unsigned long const   *)(& cbrmap), 64UL);
#line 506
  scr = (int )tmp___0;
  }
#line 506
  goto ldv_34447;
  ldv_34446: 
#line 506
  i = scr * 2;
#line 506
  goto ldv_34444;
  ldv_34443: ;
#line 507
  if (data_valid != 0) {
    {
#line 508
    tmp___1 = gru_copy_handle(cb, save);
#line 508
    save = save + (unsigned long )tmp___1;
#line 509
    tmp___2 = gru_copy_handle(cbe + (unsigned long )(i * 256), save);
#line 509
    save = save + (unsigned long )tmp___2;
    }
  } else {
    {
#line 512
    __memset(cb, 0, 64UL);
#line 513
    __memset(cbe + (unsigned long )(i * 256), 0, 64UL);
    }
  }
  {
#line 517
  __asm__  volatile   ("mfence": : : "memory");
#line 518
  gru_flush_cache(cbe + (unsigned long )(i * 256));
#line 519
  cb = cb + 256UL;
#line 506
  i = i + 1;
  }
  ldv_34444: ;
#line 506
  if (i < (scr + 1) * 2) {
#line 508
    goto ldv_34443;
  } else {

  }
  {
#line 506
  tmp___3 = ldv_find_next_bit_113((unsigned long const   *)(& cbrmap), 64UL, (unsigned long )(scr + 1));
#line 506
  scr = (int )tmp___3;
  }
  ldv_34447: ;
#line 506
  if (scr <= 63) {
#line 508
    goto ldv_34446;
  } else {

  }

#line 522
  if (data_valid != 0) {
    {
#line 523
    __memcpy(gseg + 131072UL, (void const   *)save, length);
    }
  } else {
    {
#line 525
    __memset(gseg + 131072UL, 0, length);
    }
  }
#line 526
  return;
}
}
#line 528 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void gru_unload_context_data(void *save , void *grubase , int ctxnum , unsigned long cbrmap ,
                                    unsigned long dsrmap ) 
{ 
  void *gseg ;
  void *cb ;
  void *cbe ;
  unsigned long length ;
  int i ;
  int scr ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  unsigned long tmp___5 ;

  {
  {
#line 535
  gseg = grubase + (unsigned long )(ctxnum * 4194304);
#line 536
  cb = gseg;
#line 537
  cbe = grubase + 67174400UL;
#line 538
  tmp = __arch_hweight64((__u64 )dsrmap);
#line 538
  length = tmp * 1024UL;
#line 541
  tmp___0 = ldv_find_first_bit_114((unsigned long const   *)(& cbrmap), 64UL);
#line 541
  scr = (int )tmp___0;
  }
#line 541
  goto ldv_34466;
  ldv_34465: 
#line 541
  i = scr * 2;
#line 541
  goto ldv_34463;
  ldv_34462: 
  {
#line 542
  gru_flush_cache(cbe + (unsigned long )(i * 256));
#line 541
  i = i + 1;
  }
  ldv_34463: ;
#line 541
  if (i < (scr + 1) * 2) {
#line 543
    goto ldv_34462;
  } else {

  }
  {
#line 541
  tmp___1 = ldv_find_next_bit_115((unsigned long const   *)(& cbrmap), 64UL, (unsigned long )(scr + 1));
#line 541
  scr = (int )tmp___1;
  }
  ldv_34466: ;
#line 541
  if (scr <= 63) {
#line 543
    goto ldv_34465;
  } else {

  }
  {
#line 543
  __asm__  volatile   ("mfence": : : "memory");
#line 545
  gru_prefetch_context(gseg, cb, cbe, cbrmap, length);
#line 547
  tmp___2 = ldv_find_first_bit_116((unsigned long const   *)(& cbrmap), 64UL);
#line 547
  scr = (int )tmp___2;
  }
#line 547
  goto ldv_34472;
  ldv_34471: 
#line 547
  i = scr * 2;
#line 547
  goto ldv_34469;
  ldv_34468: 
  {
#line 548
  tmp___3 = gru_copy_handle(save, cb);
#line 548
  save = save + (unsigned long )tmp___3;
#line 549
  tmp___4 = gru_copy_handle(save, cbe + (unsigned long )(i * 256));
#line 549
  save = save + (unsigned long )tmp___4;
#line 550
  cb = cb + 256UL;
#line 547
  i = i + 1;
  }
  ldv_34469: ;
#line 547
  if (i < (scr + 1) * 2) {
#line 549
    goto ldv_34468;
  } else {

  }
  {
#line 547
  tmp___5 = ldv_find_next_bit_117((unsigned long const   *)(& cbrmap), 64UL, (unsigned long )(scr + 1));
#line 547
  scr = (int )tmp___5;
  }
  ldv_34472: ;
#line 547
  if (scr <= 63) {
#line 549
    goto ldv_34471;
  } else {

  }
  {
#line 552
  __memcpy(save, (void const   *)gseg + 131072U, length);
  }
#line 553
  return;
}
}
#line 555 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
void gru_unload_context(struct gru_thread_state *gts , int savestate ) 
{ 
  struct gru_state *gru ;
  struct gru_context_configuration_handle *cch ;
  int ctxnum ;
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 557
  gru = gts->ts_gru;
#line 559
  ctxnum = gts->ts_ctxnum;
#line 561
  tmp = is_kernel_context(gts);
  }
#line 561
  if (tmp == 0) {
    {
#line 562
    zap_vma_ptes(gts->ts_vma, (gts->ts_vma)->vm_start + (unsigned long )gts->ts_tsid * 262144UL,
                 262144UL);
    }
  } else {

  }
  {
#line 563
  cch = get_cch(gru->gs_gru_base_vaddr, ctxnum);
  }
#line 565
  if ((int )gru_options & 1) {
#line 565
    __vpp_verify = (void const   *)0;
    {
#line 565
    if (4UL == 1UL) {
#line 565
      goto case_1;
    } else {

    }
#line 566
    if (4UL == 2UL) {
#line 566
      goto case_2___0;
    } else {

    }
#line 566
    if (4UL == 4UL) {
#line 566
      goto case_4___1;
    } else {

    }
#line 566
    if (4UL == 8UL) {
#line 566
      goto case_8___2;
    } else {

    }
#line 566
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 566
    if (4UL == 1UL) {
#line 566
      goto case_1___0;
    } else {

    }
#line 566
    if (4UL == 2UL) {
#line 566
      goto case_2;
    } else {

    }
#line 566
    if (4UL == 4UL) {
#line 566
      goto case_4;
    } else {

    }
#line 566
    if (4UL == 8UL) {
#line 566
      goto case_8;
    } else {

    }
#line 566
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 566
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 566
    goto ldv_34486;
    case_2: /* CIL Label */ 
#line 566
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 566
    goto ldv_34486;
    case_4: /* CIL Label */ 
#line 566
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 566
    goto ldv_34486;
    case_8: /* CIL Label */ 
#line 566
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 566
    goto ldv_34486;
    switch_default: /* CIL Label */ 
    {
#line 566
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34486: 
#line 566
    pscr_ret__ = pfo_ret__;
#line 566
    goto ldv_34492;
    case_2___0: /* CIL Label */ ;
    {
#line 566
    if (4UL == 1UL) {
#line 566
      goto case_1___1;
    } else {

    }
#line 566
    if (4UL == 2UL) {
#line 566
      goto case_2___1;
    } else {

    }
#line 566
    if (4UL == 4UL) {
#line 566
      goto case_4___0;
    } else {

    }
#line 566
    if (4UL == 8UL) {
#line 566
      goto case_8___0;
    } else {

    }
#line 566
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 566
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 566
    goto ldv_34496;
    case_2___1: /* CIL Label */ 
#line 566
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 566
    goto ldv_34496;
    case_4___0: /* CIL Label */ 
#line 566
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 566
    goto ldv_34496;
    case_8___0: /* CIL Label */ 
#line 566
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 566
    goto ldv_34496;
    switch_default___0: /* CIL Label */ 
    {
#line 566
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34496: 
#line 566
    pscr_ret__ = pfo_ret_____0;
#line 566
    goto ldv_34492;
    case_4___1: /* CIL Label */ ;
    {
#line 566
    if (4UL == 1UL) {
#line 566
      goto case_1___2;
    } else {

    }
#line 566
    if (4UL == 2UL) {
#line 566
      goto case_2___2;
    } else {

    }
#line 566
    if (4UL == 4UL) {
#line 566
      goto case_4___2;
    } else {

    }
#line 566
    if (4UL == 8UL) {
#line 566
      goto case_8___1;
    } else {

    }
#line 566
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 566
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 566
    goto ldv_34505;
    case_2___2: /* CIL Label */ 
#line 566
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 566
    goto ldv_34505;
    case_4___2: /* CIL Label */ 
#line 566
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 566
    goto ldv_34505;
    case_8___1: /* CIL Label */ 
#line 566
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 566
    goto ldv_34505;
    switch_default___1: /* CIL Label */ 
    {
#line 566
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34505: 
#line 566
    pscr_ret__ = pfo_ret_____1;
#line 566
    goto ldv_34492;
    case_8___2: /* CIL Label */ ;
    {
#line 566
    if (4UL == 1UL) {
#line 566
      goto case_1___3;
    } else {

    }
#line 566
    if (4UL == 2UL) {
#line 566
      goto case_2___3;
    } else {

    }
#line 566
    if (4UL == 4UL) {
#line 566
      goto case_4___3;
    } else {

    }
#line 566
    if (4UL == 8UL) {
#line 566
      goto case_8___3;
    } else {

    }
#line 566
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 566
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 566
    goto ldv_34514;
    case_2___3: /* CIL Label */ 
#line 566
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 566
    goto ldv_34514;
    case_4___3: /* CIL Label */ 
#line 566
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 566
    goto ldv_34514;
    case_8___3: /* CIL Label */ 
#line 566
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 566
    goto ldv_34514;
    switch_default___2: /* CIL Label */ 
    {
#line 566
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34514: 
#line 566
    pscr_ret__ = pfo_ret_____2;
#line 566
    goto ldv_34492;
    switch_default___3: /* CIL Label */ 
    {
#line 566
    __bad_size_call_parameter();
    }
#line 566
    goto ldv_34492;
    switch_break: /* CIL Label */ ;
    }
    ldv_34492: 
    {
#line 566
    printk("\017GRU:%d %s: gts %p, cbrmap 0x%lx, dsrmap 0x%lx\n", pscr_ret__, "gru_unload_context",
           gts, gts->ts_cbr_map, gts->ts_dsr_map);
    }
  } else {

  }
  {
#line 567
  lock_cch_handle(cch);
#line 568
  tmp___0 = cch_interrupt_sync(cch);
  }
#line 568
  if (tmp___0 != 0) {
    {
#line 569
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                         "i" (569), "i" (12UL));
#line 569
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 571
  tmp___1 = is_kernel_context(gts);
  }
#line 571
  if (tmp___1 == 0) {
    {
#line 572
    gru_unload_mm_tracker(gru, gts);
    }
  } else {

  }
#line 573
  if (savestate != 0) {
    {
#line 574
    gru_unload_context_data((void *)(& gts->ts_gdata), gru->gs_gru_base_vaddr, ctxnum,
                            gts->ts_cbr_map, gts->ts_dsr_map);
#line 577
    gts->ts_data_valid = 1;
    }
  } else {

  }
  {
#line 580
  tmp___2 = cch_deallocate(cch);
  }
#line 580
  if (tmp___2 != 0) {
    {
#line 581
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                         "i" (581), "i" (12UL));
#line 581
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 582
  unlock_cch_handle(cch);
#line 584
  gru_free_gru_context(gts);
  }
#line 585
  return;
}
}
#line 591 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
void gru_load_context(struct gru_thread_state *gts ) 
{ 
  struct gru_state *gru ;
  struct gru_context_configuration_handle *cch ;
  int i ;
  int err ;
  int asid ;
  int ctxnum ;
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;

  {
  {
#line 593
  gru = gts->ts_gru;
#line 595
  ctxnum = gts->ts_ctxnum;
#line 597
  cch = get_cch(gru->gs_gru_base_vaddr, ctxnum);
#line 598
  lock_cch_handle(cch);
#line 599
  cch->tfm_fault_bit_enable = (unsigned long )gts->ts_user_options - 2UL <= 1UL;
#line 602
  cch->tlb_int_enable = gts->ts_user_options == 2L;
  }
#line 603
  if ((unsigned int )*((unsigned char *)cch + 1UL) != 0U) {
    {
#line 604
    gts->ts_tlb_int_select = gru_cpu_fault_map_id();
#line 605
    cch->tlb_int_select = (unsigned char )gts->ts_tlb_int_select;
    }
  } else {

  }
#line 607
  if ((int )((signed char )gts->ts_cch_req_slice) >= 0) {
#line 608
    cch->req_slice_set_enable = 1U;
#line 609
    cch->req_slice = (unsigned char )gts->ts_cch_req_slice;
  } else {
#line 611
    cch->req_slice_set_enable = 0U;
  }
  {
#line 613
  cch->tfm_done_bit_enable = 0U;
#line 614
  cch->dsr_allocation_map = (unsigned int )gts->ts_dsr_map;
#line 615
  cch->cbr_allocation_map = gts->ts_cbr_map;
#line 617
  tmp = is_kernel_context(gts);
  }
#line 617
  if (tmp != 0) {
#line 618
    cch->unmap_enable = 1U;
#line 619
    cch->tfm_done_bit_enable = 1U;
#line 620
    cch->cb_int_enable = 1U;
#line 621
    cch->tlb_int_select = 0U;
  } else {
    {
#line 623
    cch->unmap_enable = 0U;
#line 624
    cch->tfm_done_bit_enable = 0U;
#line 625
    cch->cb_int_enable = 0U;
#line 626
    asid = gru_load_mm_tracker(gru, gts);
#line 627
    i = 0;
    }
#line 627
    goto ldv_34533;
    ldv_34532: 
#line 628
    cch->asid[i] = (unsigned int )(asid + i);
#line 629
    cch->sizeavail[i] = gts->ts_sizeavail;
#line 627
    i = i + 1;
    ldv_34533: ;
#line 627
    if (i <= 7) {
#line 629
      goto ldv_34532;
    } else {

    }

  }
  {
#line 633
  err = cch_allocate(cch);
  }
#line 634
  if (err != 0) {
#line 635
    if ((int )gru_options & 1) {
#line 635
      __vpp_verify = (void const   *)0;
      {
#line 635
      if (4UL == 1UL) {
#line 635
        goto case_1;
      } else {

      }
#line 637
      if (4UL == 2UL) {
#line 637
        goto case_2___0;
      } else {

      }
#line 637
      if (4UL == 4UL) {
#line 637
        goto case_4___1;
      } else {

      }
#line 637
      if (4UL == 8UL) {
#line 637
        goto case_8___2;
      } else {

      }
#line 637
      goto switch_default___3;
      case_1: /* CIL Label */ ;
      {
#line 637
      if (4UL == 1UL) {
#line 637
        goto case_1___0;
      } else {

      }
#line 637
      if (4UL == 2UL) {
#line 637
        goto case_2;
      } else {

      }
#line 637
      if (4UL == 4UL) {
#line 637
        goto case_4;
      } else {

      }
#line 637
      if (4UL == 8UL) {
#line 637
        goto case_8;
      } else {

      }
#line 637
      goto switch_default;
      case_1___0: /* CIL Label */ 
#line 637
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 637
      goto ldv_34540;
      case_2: /* CIL Label */ 
#line 637
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 637
      goto ldv_34540;
      case_4: /* CIL Label */ 
#line 637
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 637
      goto ldv_34540;
      case_8: /* CIL Label */ 
#line 637
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 637
      goto ldv_34540;
      switch_default: /* CIL Label */ 
      {
#line 637
      __bad_percpu_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
      ldv_34540: 
#line 637
      pscr_ret__ = pfo_ret__;
#line 637
      goto ldv_34546;
      case_2___0: /* CIL Label */ ;
      {
#line 637
      if (4UL == 1UL) {
#line 637
        goto case_1___1;
      } else {

      }
#line 637
      if (4UL == 2UL) {
#line 637
        goto case_2___1;
      } else {

      }
#line 637
      if (4UL == 4UL) {
#line 637
        goto case_4___0;
      } else {

      }
#line 637
      if (4UL == 8UL) {
#line 637
        goto case_8___0;
      } else {

      }
#line 637
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
#line 637
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 637
      goto ldv_34550;
      case_2___1: /* CIL Label */ 
#line 637
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 637
      goto ldv_34550;
      case_4___0: /* CIL Label */ 
#line 637
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 637
      goto ldv_34550;
      case_8___0: /* CIL Label */ 
#line 637
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 637
      goto ldv_34550;
      switch_default___0: /* CIL Label */ 
      {
#line 637
      __bad_percpu_size();
      }
      switch_break___1: /* CIL Label */ ;
      }
      ldv_34550: 
#line 637
      pscr_ret__ = pfo_ret_____0;
#line 637
      goto ldv_34546;
      case_4___1: /* CIL Label */ ;
      {
#line 637
      if (4UL == 1UL) {
#line 637
        goto case_1___2;
      } else {

      }
#line 637
      if (4UL == 2UL) {
#line 637
        goto case_2___2;
      } else {

      }
#line 637
      if (4UL == 4UL) {
#line 637
        goto case_4___2;
      } else {

      }
#line 637
      if (4UL == 8UL) {
#line 637
        goto case_8___1;
      } else {

      }
#line 637
      goto switch_default___1;
      case_1___2: /* CIL Label */ 
#line 637
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 637
      goto ldv_34559;
      case_2___2: /* CIL Label */ 
#line 637
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 637
      goto ldv_34559;
      case_4___2: /* CIL Label */ 
#line 637
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 637
      goto ldv_34559;
      case_8___1: /* CIL Label */ 
#line 637
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 637
      goto ldv_34559;
      switch_default___1: /* CIL Label */ 
      {
#line 637
      __bad_percpu_size();
      }
      switch_break___2: /* CIL Label */ ;
      }
      ldv_34559: 
#line 637
      pscr_ret__ = pfo_ret_____1;
#line 637
      goto ldv_34546;
      case_8___2: /* CIL Label */ ;
      {
#line 637
      if (4UL == 1UL) {
#line 637
        goto case_1___3;
      } else {

      }
#line 637
      if (4UL == 2UL) {
#line 637
        goto case_2___3;
      } else {

      }
#line 637
      if (4UL == 4UL) {
#line 637
        goto case_4___3;
      } else {

      }
#line 637
      if (4UL == 8UL) {
#line 637
        goto case_8___3;
      } else {

      }
#line 637
      goto switch_default___2;
      case_1___3: /* CIL Label */ 
#line 637
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 637
      goto ldv_34568;
      case_2___3: /* CIL Label */ 
#line 637
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 637
      goto ldv_34568;
      case_4___3: /* CIL Label */ 
#line 637
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 637
      goto ldv_34568;
      case_8___3: /* CIL Label */ 
#line 637
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 637
      goto ldv_34568;
      switch_default___2: /* CIL Label */ 
      {
#line 637
      __bad_percpu_size();
      }
      switch_break___3: /* CIL Label */ ;
      }
      ldv_34568: 
#line 637
      pscr_ret__ = pfo_ret_____2;
#line 637
      goto ldv_34546;
      switch_default___3: /* CIL Label */ 
      {
#line 637
      __bad_size_call_parameter();
      }
#line 637
      goto ldv_34546;
      switch_break: /* CIL Label */ ;
      }
      ldv_34546: 
      {
#line 637
      printk("\017GRU:%d %s: err %d: cch %p, gts %p, cbr 0x%lx, dsr 0x%lx\n", pscr_ret__,
             "gru_load_context", err, cch, gts, gts->ts_cbr_map, gts->ts_dsr_map);
      }
    } else {

    }
    {
#line 638
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                         "i" (638), "i" (12UL));
#line 638
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 641
  gru_load_context_data((void *)(& gts->ts_gdata), gru->gs_gru_base_vaddr, ctxnum,
                        gts->ts_cbr_map, gts->ts_dsr_map, gts->ts_data_valid);
#line 644
  tmp___0 = cch_start(cch);
  }
#line 644
  if (tmp___0 != 0) {
    {
#line 645
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                         "i" (645), "i" (12UL));
#line 645
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 646
  unlock_cch_handle(cch);
  }
#line 648
  if ((int )gru_options & 1) {
#line 648
    __vpp_verify___0 = (void const   *)0;
    {
#line 648
    if (4UL == 1UL) {
#line 648
      goto case_1___4;
    } else {

    }
#line 650
    if (4UL == 2UL) {
#line 650
      goto case_2___5;
    } else {

    }
#line 650
    if (4UL == 4UL) {
#line 650
      goto case_4___6;
    } else {

    }
#line 650
    if (4UL == 8UL) {
#line 650
      goto case_8___7;
    } else {

    }
#line 650
    goto switch_default___8;
    case_1___4: /* CIL Label */ ;
    {
#line 650
    if (4UL == 1UL) {
#line 650
      goto case_1___5;
    } else {

    }
#line 650
    if (4UL == 2UL) {
#line 650
      goto case_2___4;
    } else {

    }
#line 650
    if (4UL == 4UL) {
#line 650
      goto case_4___4;
    } else {

    }
#line 650
    if (4UL == 8UL) {
#line 650
      goto case_8___4;
    } else {

    }
#line 650
    goto switch_default___4;
    case_1___5: /* CIL Label */ 
#line 650
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 650
    goto ldv_34582;
    case_2___4: /* CIL Label */ 
#line 650
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 650
    goto ldv_34582;
    case_4___4: /* CIL Label */ 
#line 650
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 650
    goto ldv_34582;
    case_8___4: /* CIL Label */ 
#line 650
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 650
    goto ldv_34582;
    switch_default___4: /* CIL Label */ 
    {
#line 650
    __bad_percpu_size();
    }
    switch_break___5: /* CIL Label */ ;
    }
    ldv_34582: 
#line 650
    pscr_ret_____0 = pfo_ret_____3;
#line 650
    goto ldv_34588;
    case_2___5: /* CIL Label */ ;
    {
#line 650
    if (4UL == 1UL) {
#line 650
      goto case_1___6;
    } else {

    }
#line 650
    if (4UL == 2UL) {
#line 650
      goto case_2___6;
    } else {

    }
#line 650
    if (4UL == 4UL) {
#line 650
      goto case_4___5;
    } else {

    }
#line 650
    if (4UL == 8UL) {
#line 650
      goto case_8___5;
    } else {

    }
#line 650
    goto switch_default___5;
    case_1___6: /* CIL Label */ 
#line 650
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 650
    goto ldv_34592;
    case_2___6: /* CIL Label */ 
#line 650
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 650
    goto ldv_34592;
    case_4___5: /* CIL Label */ 
#line 650
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 650
    goto ldv_34592;
    case_8___5: /* CIL Label */ 
#line 650
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 650
    goto ldv_34592;
    switch_default___5: /* CIL Label */ 
    {
#line 650
    __bad_percpu_size();
    }
    switch_break___6: /* CIL Label */ ;
    }
    ldv_34592: 
#line 650
    pscr_ret_____0 = pfo_ret_____4;
#line 650
    goto ldv_34588;
    case_4___6: /* CIL Label */ ;
    {
#line 650
    if (4UL == 1UL) {
#line 650
      goto case_1___7;
    } else {

    }
#line 650
    if (4UL == 2UL) {
#line 650
      goto case_2___7;
    } else {

    }
#line 650
    if (4UL == 4UL) {
#line 650
      goto case_4___7;
    } else {

    }
#line 650
    if (4UL == 8UL) {
#line 650
      goto case_8___6;
    } else {

    }
#line 650
    goto switch_default___6;
    case_1___7: /* CIL Label */ 
#line 650
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 650
    goto ldv_34601;
    case_2___7: /* CIL Label */ 
#line 650
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 650
    goto ldv_34601;
    case_4___7: /* CIL Label */ 
#line 650
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 650
    goto ldv_34601;
    case_8___6: /* CIL Label */ 
#line 650
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 650
    goto ldv_34601;
    switch_default___6: /* CIL Label */ 
    {
#line 650
    __bad_percpu_size();
    }
    switch_break___7: /* CIL Label */ ;
    }
    ldv_34601: 
#line 650
    pscr_ret_____0 = pfo_ret_____5;
#line 650
    goto ldv_34588;
    case_8___7: /* CIL Label */ ;
    {
#line 650
    if (4UL == 1UL) {
#line 650
      goto case_1___8;
    } else {

    }
#line 650
    if (4UL == 2UL) {
#line 650
      goto case_2___8;
    } else {

    }
#line 650
    if (4UL == 4UL) {
#line 650
      goto case_4___8;
    } else {

    }
#line 650
    if (4UL == 8UL) {
#line 650
      goto case_8___8;
    } else {

    }
#line 650
    goto switch_default___7;
    case_1___8: /* CIL Label */ 
#line 650
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 650
    goto ldv_34610;
    case_2___8: /* CIL Label */ 
#line 650
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 650
    goto ldv_34610;
    case_4___8: /* CIL Label */ 
#line 650
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 650
    goto ldv_34610;
    case_8___8: /* CIL Label */ 
#line 650
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 650
    goto ldv_34610;
    switch_default___7: /* CIL Label */ 
    {
#line 650
    __bad_percpu_size();
    }
    switch_break___8: /* CIL Label */ ;
    }
    ldv_34610: 
#line 650
    pscr_ret_____0 = pfo_ret_____6;
#line 650
    goto ldv_34588;
    switch_default___8: /* CIL Label */ 
    {
#line 650
    __bad_size_call_parameter();
    }
#line 650
    goto ldv_34588;
    switch_break___4: /* CIL Label */ ;
    }
    ldv_34588: 
    {
#line 650
    printk("\017GRU:%d %s: gid %d, gts %p, cbrmap 0x%lx, dsrmap 0x%lx, tie %d, tis %d\n",
           pscr_ret_____0, "gru_load_context", (int )(gts->ts_gru)->gs_gid, gts, gts->ts_cbr_map,
           gts->ts_dsr_map, gts->ts_user_options == 2L, gts->ts_tlb_int_select);
    }
  } else {

  }
#line 651
  return;
}
}
#line 658 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
int gru_update_cch(struct gru_thread_state *gts ) 
{ 
  struct gru_context_configuration_handle *cch ;
  struct gru_state *gru ;
  int i ;
  int ctxnum ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 661
  gru = gts->ts_gru;
#line 662
  ctxnum = gts->ts_ctxnum;
#line 662
  ret = 0;
#line 664
  cch = get_cch(gru->gs_gru_base_vaddr, ctxnum);
#line 666
  lock_cch_handle(cch);
  }
#line 667
  if ((unsigned int )*((unsigned char *)cch + 2UL) == 8U) {
#line 668
    if ((unsigned long )gru->gs_gts[gts->ts_ctxnum] != (unsigned long )gts) {
#line 669
      goto exit;
    } else {

    }
    {
#line 670
    tmp = cch_interrupt(cch);
    }
#line 670
    if (tmp != 0) {
      {
#line 671
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                           "i" (671), "i" (12UL));
#line 671
      __builtin_unreachable();
      }
    } else {

    }
#line 672
    i = 0;
#line 672
    goto ldv_34628;
    ldv_34627: 
#line 673
    cch->sizeavail[i] = gts->ts_sizeavail;
#line 672
    i = i + 1;
    ldv_34628: ;
#line 672
    if (i <= 7) {
#line 674
      goto ldv_34627;
    } else {

    }
    {
#line 674
    gts->ts_tlb_int_select = gru_cpu_fault_map_id();
#line 675
    tmp___0 = gru_cpu_fault_map_id();
#line 675
    cch->tlb_int_select = (unsigned char )tmp___0;
#line 676
    cch->tfm_fault_bit_enable = (unsigned long )gts->ts_user_options - 2UL <= 1UL;
#line 679
    tmp___1 = cch_start(cch);
    }
#line 679
    if (tmp___1 != 0) {
      {
#line 680
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grumain.c"),
                           "i" (680), "i" (12UL));
#line 680
      __builtin_unreachable();
      }
    } else {

    }
#line 681
    ret = 1;
  } else {

  }
  exit: 
  {
#line 684
  unlock_cch_handle(cch);
  }
#line 685
  return (ret);
}
}
#line 695 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int gru_retarget_intr(struct gru_thread_state *gts ) 
{ 
  int tmp ;
  int tmp___0 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___1 ;

  {
#line 697
  if (gts->ts_tlb_int_select < 0) {
#line 699
    return (0);
  } else {
    {
#line 697
    tmp = gru_cpu_fault_map_id();
    }
#line 697
    if (gts->ts_tlb_int_select == tmp) {
#line 699
      return (0);
    } else {

    }
  }
#line 701
  if ((int )gru_options & 1) {
    {
#line 701
    tmp___0 = gru_cpu_fault_map_id();
#line 701
    __vpp_verify = (void const   *)0;
    }
    {
#line 701
    if (4UL == 1UL) {
#line 701
      goto case_1;
    } else {

    }
#line 702
    if (4UL == 2UL) {
#line 702
      goto case_2___0;
    } else {

    }
#line 702
    if (4UL == 4UL) {
#line 702
      goto case_4___1;
    } else {

    }
#line 702
    if (4UL == 8UL) {
#line 702
      goto case_8___2;
    } else {

    }
#line 702
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 702
    if (4UL == 1UL) {
#line 702
      goto case_1___0;
    } else {

    }
#line 702
    if (4UL == 2UL) {
#line 702
      goto case_2;
    } else {

    }
#line 702
    if (4UL == 4UL) {
#line 702
      goto case_4;
    } else {

    }
#line 702
    if (4UL == 8UL) {
#line 702
      goto case_8;
    } else {

    }
#line 702
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 702
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 702
    goto ldv_34638;
    case_2: /* CIL Label */ 
#line 702
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 702
    goto ldv_34638;
    case_4: /* CIL Label */ 
#line 702
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 702
    goto ldv_34638;
    case_8: /* CIL Label */ 
#line 702
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 702
    goto ldv_34638;
    switch_default: /* CIL Label */ 
    {
#line 702
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34638: 
#line 702
    pscr_ret__ = pfo_ret__;
#line 702
    goto ldv_34644;
    case_2___0: /* CIL Label */ ;
    {
#line 702
    if (4UL == 1UL) {
#line 702
      goto case_1___1;
    } else {

    }
#line 702
    if (4UL == 2UL) {
#line 702
      goto case_2___1;
    } else {

    }
#line 702
    if (4UL == 4UL) {
#line 702
      goto case_4___0;
    } else {

    }
#line 702
    if (4UL == 8UL) {
#line 702
      goto case_8___0;
    } else {

    }
#line 702
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 702
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 702
    goto ldv_34648;
    case_2___1: /* CIL Label */ 
#line 702
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 702
    goto ldv_34648;
    case_4___0: /* CIL Label */ 
#line 702
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 702
    goto ldv_34648;
    case_8___0: /* CIL Label */ 
#line 702
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 702
    goto ldv_34648;
    switch_default___0: /* CIL Label */ 
    {
#line 702
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34648: 
#line 702
    pscr_ret__ = pfo_ret_____0;
#line 702
    goto ldv_34644;
    case_4___1: /* CIL Label */ ;
    {
#line 702
    if (4UL == 1UL) {
#line 702
      goto case_1___2;
    } else {

    }
#line 702
    if (4UL == 2UL) {
#line 702
      goto case_2___2;
    } else {

    }
#line 702
    if (4UL == 4UL) {
#line 702
      goto case_4___2;
    } else {

    }
#line 702
    if (4UL == 8UL) {
#line 702
      goto case_8___1;
    } else {

    }
#line 702
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 702
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 702
    goto ldv_34657;
    case_2___2: /* CIL Label */ 
#line 702
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 702
    goto ldv_34657;
    case_4___2: /* CIL Label */ 
#line 702
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 702
    goto ldv_34657;
    case_8___1: /* CIL Label */ 
#line 702
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 702
    goto ldv_34657;
    switch_default___1: /* CIL Label */ 
    {
#line 702
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34657: 
#line 702
    pscr_ret__ = pfo_ret_____1;
#line 702
    goto ldv_34644;
    case_8___2: /* CIL Label */ ;
    {
#line 702
    if (4UL == 1UL) {
#line 702
      goto case_1___3;
    } else {

    }
#line 702
    if (4UL == 2UL) {
#line 702
      goto case_2___3;
    } else {

    }
#line 702
    if (4UL == 4UL) {
#line 702
      goto case_4___3;
    } else {

    }
#line 702
    if (4UL == 8UL) {
#line 702
      goto case_8___3;
    } else {

    }
#line 702
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 702
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 702
    goto ldv_34666;
    case_2___3: /* CIL Label */ 
#line 702
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 702
    goto ldv_34666;
    case_4___3: /* CIL Label */ 
#line 702
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 702
    goto ldv_34666;
    case_8___3: /* CIL Label */ 
#line 702
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 702
    goto ldv_34666;
    switch_default___2: /* CIL Label */ 
    {
#line 702
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34666: 
#line 702
    pscr_ret__ = pfo_ret_____2;
#line 702
    goto ldv_34644;
    switch_default___3: /* CIL Label */ 
    {
#line 702
    __bad_size_call_parameter();
    }
#line 702
    goto ldv_34644;
    switch_break: /* CIL Label */ ;
    }
    ldv_34644: 
    {
#line 702
    printk("\017GRU:%d %s: retarget from %d to %d\n", pscr_ret__, "gru_retarget_intr",
           gts->ts_tlb_int_select, tmp___0);
    }
  } else {

  }
  {
#line 703
  tmp___1 = gru_update_cch(gts);
  }
#line 703
  return (tmp___1);
}
}
#line 712 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int gru_check_chiplet_assignment(struct gru_state *gru , struct gru_thread_state *gts ) 
{ 
  int blade_id ;
  int chiplet_id ;

  {
#line 718
  blade_id = (int )gts->ts_user_blade_id;
#line 719
  if (blade_id < 0) {
    {
#line 720
    blade_id = uv_numa_blade_id();
    }
  } else {

  }
#line 722
  chiplet_id = (int )gts->ts_user_chiplet_id;
#line 723
  return ((int )gru->gs_blade_id == blade_id && (chiplet_id < 0 || chiplet_id == (int )gru->gs_chiplet_id));
}
}
#line 732 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
void gru_check_context_placement(struct gru_thread_state *gts ) 
{ 
  struct gru_state *gru ;
  struct task_struct *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 741
  gru = gts->ts_gru;
#line 742
  if ((unsigned long )gru == (unsigned long )((struct gru_state *)0)) {
#line 743
    return;
  } else {
    {
#line 742
    tmp = get_current___0();
    }
#line 742
    if (gts->ts_tgid_owner != tmp->tgid) {
#line 743
      return;
    } else {

    }
  }
  {
#line 745
  tmp___1 = gru_check_chiplet_assignment(gru, gts);
  }
#line 745
  if (tmp___1 == 0) {
#line 746
    if ((gru_options & 2UL) != 0UL) {
      {
#line 746
      atomic_long_inc(& gru_stats.check_context_unload);
      }
    } else {

    }
    {
#line 747
    gru_unload_context(gts, 1);
    }
  } else {
    {
#line 748
    tmp___0 = gru_retarget_intr(gts);
    }
#line 748
    if (tmp___0 != 0) {
#line 749
      if ((gru_options & 2UL) != 0UL) {
        {
#line 749
        atomic_long_inc(& gru_stats.check_context_retarget_intr);
        }
      } else {

      }
    } else {

    }
  }
#line 750
  return;
}
}
#line 762 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int is_gts_stealable(struct gru_thread_state *gts , struct gru_blade_state *bs ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 765
  tmp___1 = is_kernel_context(gts);
  }
#line 765
  if (tmp___1 != 0) {
    {
#line 766
    tmp = down_write_trylock(& bs->bs_kgts_sema);
    }
#line 766
    return (tmp);
  } else {
    {
#line 768
    tmp___0 = ldv_mutex_trylock_118(& gts->ts_ctxlock);
    }
#line 768
    return (tmp___0);
  }
}
}
#line 771 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static void gts_stolen(struct gru_thread_state *gts , struct gru_blade_state *bs ) 
{ 
  int tmp ;

  {
  {
#line 774
  tmp = is_kernel_context(gts);
  }
#line 774
  if (tmp != 0) {
    {
#line 775
    up_write(& bs->bs_kgts_sema);
    }
#line 776
    if ((gru_options & 2UL) != 0UL) {
      {
#line 776
      atomic_long_inc(& gru_stats.steal_kernel_context);
      }
    } else {

    }
  } else {
    {
#line 778
    ldv_mutex_unlock_119(& gts->ts_ctxlock);
    }
#line 779
    if ((gru_options & 2UL) != 0UL) {
      {
#line 779
      atomic_long_inc(& gru_stats.steal_user_context);
      }
    } else {

    }
  }
#line 781
  return;
}
}
#line 783 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
void gru_steal_context(struct gru_thread_state *gts ) 
{ 
  struct gru_blade_state *blade ;
  struct gru_state *gru ;
  struct gru_state *gru0 ;
  struct gru_thread_state *ngts ;
  int ctxnum ;
  int ctxnum0 ;
  int flag ;
  int cbr ;
  int dsr ;
  int blade_id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 787
  ngts = (struct gru_thread_state *)0;
#line 788
  flag = 0;
#line 791
  blade_id = (int )gts->ts_user_blade_id;
#line 792
  if (blade_id < 0) {
    {
#line 793
    blade_id = uv_numa_blade_id();
    }
  } else {

  }
  {
#line 794
  cbr = (int )gts->ts_cbr_au_count;
#line 795
  dsr = (int )gts->ts_dsr_au_count;
#line 797
  blade = gru_base[blade_id];
#line 798
  ldv_spin_lock_120(& blade->bs_lock);
#line 800
  ctxnum = blade->bs_lru_ctxnum <= 13 ? blade->bs_lru_ctxnum + 1 : 0;
#line 801
  gru = blade->bs_lru_gru;
  }
#line 802
  if (ctxnum == 0) {
#line 803
    gru = (unsigned long )gru < (unsigned long )((struct gru_state *)(& blade->bs_grus) + 1UL) ? gru + 1UL : (struct gru_state *)(& blade->bs_grus);
  } else {

  }
#line 804
  blade->bs_lru_gru = gru;
#line 805
  blade->bs_lru_ctxnum = ctxnum;
#line 806
  ctxnum0 = ctxnum;
#line 807
  gru0 = gru;
  ldv_34710: 
  {
#line 809
  tmp___1 = gru_check_chiplet_assignment(gru, gts);
  }
#line 809
  if (tmp___1 != 0) {
    {
#line 810
    tmp = check_gru_resources(gru, cbr, dsr, 16);
    }
#line 810
    if (tmp != 0) {
#line 811
      goto ldv_34706;
    } else {

    }
    {
#line 812
    ldv_spin_lock_108(& gru->gs_lock);
    }
#line 813
    goto ldv_34709;
    ldv_34708: ;
#line 814
    if ((flag != 0 && (unsigned long )gru == (unsigned long )gru0) && ctxnum == ctxnum0) {
#line 815
      goto ldv_34707;
    } else {

    }
#line 816
    ngts = gru->gs_gts[ctxnum];
#line 823
    if ((unsigned long )ngts != (unsigned long )((struct gru_thread_state *)0)) {
      {
#line 823
      tmp___0 = is_gts_stealable(ngts, blade);
      }
#line 823
      if (tmp___0 != 0) {
#line 824
        goto ldv_34707;
      } else {

      }
    } else {

    }
#line 825
    ngts = (struct gru_thread_state *)0;
#line 813
    ctxnum = ctxnum + 1;
    ldv_34709: ;
#line 813
    if (ctxnum <= 15) {
#line 815
      goto ldv_34708;
    } else {

    }
    ldv_34707: 
    {
#line 827
    ldv_spin_unlock_109(& gru->gs_lock);
    }
#line 828
    if ((unsigned long )ngts != (unsigned long )((struct gru_thread_state *)0) || ((flag != 0 && (unsigned long )gru == (unsigned long )gru0) && ctxnum == ctxnum0)) {
#line 829
      goto ldv_34706;
    } else {

    }
  } else {

  }
#line 831
  if (flag != 0 && (unsigned long )gru == (unsigned long )gru0) {
#line 832
    goto ldv_34706;
  } else {

  }
#line 833
  flag = 1;
#line 834
  ctxnum = 0;
#line 835
  gru = (unsigned long )gru < (unsigned long )((struct gru_state *)(& blade->bs_grus) + 1UL) ? gru + 1UL : (struct gru_state *)(& blade->bs_grus);
#line 836
  goto ldv_34710;
  ldv_34706: 
  {
#line 837
  ldv_spin_unlock_123(& blade->bs_lock);
  }
#line 839
  if ((unsigned long )ngts != (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 840
    gts->ustats.context_stolen = gts->ustats.context_stolen + 1UL;
#line 841
    ngts->ts_steal_jiffies = jiffies;
#line 842
    tmp___2 = is_kernel_context(ngts);
#line 842
    gru_unload_context(ngts, tmp___2 == 0);
#line 843
    gts_stolen(ngts, blade);
    }
  } else
#line 845
  if ((gru_options & 2UL) != 0UL) {
    {
#line 845
    atomic_long_inc(& gru_stats.steal_context_failed);
    }
  } else {

  }
#line 847
  if ((int )gru_options & 1) {
    {
#line 847
    tmp___3 = __arch_hweight64((__u64 )gru->gs_dsr_map);
#line 847
    tmp___4 = __arch_hweight64((__u64 )gru->gs_cbr_map);
#line 847
    __vpp_verify = (void const   *)0;
    }
    {
#line 847
    if (4UL == 1UL) {
#line 847
      goto case_1;
    } else {

    }
#line 851
    if (4UL == 2UL) {
#line 851
      goto case_2___0;
    } else {

    }
#line 851
    if (4UL == 4UL) {
#line 851
      goto case_4___1;
    } else {

    }
#line 851
    if (4UL == 8UL) {
#line 851
      goto case_8___2;
    } else {

    }
#line 851
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 851
    if (4UL == 1UL) {
#line 851
      goto case_1___0;
    } else {

    }
#line 851
    if (4UL == 2UL) {
#line 851
      goto case_2;
    } else {

    }
#line 851
    if (4UL == 4UL) {
#line 851
      goto case_4;
    } else {

    }
#line 851
    if (4UL == 8UL) {
#line 851
      goto case_8;
    } else {

    }
#line 851
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 851
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 851
    goto ldv_34716;
    case_2: /* CIL Label */ 
#line 851
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 851
    goto ldv_34716;
    case_4: /* CIL Label */ 
#line 851
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 851
    goto ldv_34716;
    case_8: /* CIL Label */ 
#line 851
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 851
    goto ldv_34716;
    switch_default: /* CIL Label */ 
    {
#line 851
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34716: 
#line 851
    pscr_ret__ = pfo_ret__;
#line 851
    goto ldv_34722;
    case_2___0: /* CIL Label */ ;
    {
#line 851
    if (4UL == 1UL) {
#line 851
      goto case_1___1;
    } else {

    }
#line 851
    if (4UL == 2UL) {
#line 851
      goto case_2___1;
    } else {

    }
#line 851
    if (4UL == 4UL) {
#line 851
      goto case_4___0;
    } else {

    }
#line 851
    if (4UL == 8UL) {
#line 851
      goto case_8___0;
    } else {

    }
#line 851
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 851
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 851
    goto ldv_34726;
    case_2___1: /* CIL Label */ 
#line 851
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 851
    goto ldv_34726;
    case_4___0: /* CIL Label */ 
#line 851
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 851
    goto ldv_34726;
    case_8___0: /* CIL Label */ 
#line 851
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 851
    goto ldv_34726;
    switch_default___0: /* CIL Label */ 
    {
#line 851
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34726: 
#line 851
    pscr_ret__ = pfo_ret_____0;
#line 851
    goto ldv_34722;
    case_4___1: /* CIL Label */ ;
    {
#line 851
    if (4UL == 1UL) {
#line 851
      goto case_1___2;
    } else {

    }
#line 851
    if (4UL == 2UL) {
#line 851
      goto case_2___2;
    } else {

    }
#line 851
    if (4UL == 4UL) {
#line 851
      goto case_4___2;
    } else {

    }
#line 851
    if (4UL == 8UL) {
#line 851
      goto case_8___1;
    } else {

    }
#line 851
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 851
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 851
    goto ldv_34735;
    case_2___2: /* CIL Label */ 
#line 851
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 851
    goto ldv_34735;
    case_4___2: /* CIL Label */ 
#line 851
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 851
    goto ldv_34735;
    case_8___1: /* CIL Label */ 
#line 851
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 851
    goto ldv_34735;
    switch_default___1: /* CIL Label */ 
    {
#line 851
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34735: 
#line 851
    pscr_ret__ = pfo_ret_____1;
#line 851
    goto ldv_34722;
    case_8___2: /* CIL Label */ ;
    {
#line 851
    if (4UL == 1UL) {
#line 851
      goto case_1___3;
    } else {

    }
#line 851
    if (4UL == 2UL) {
#line 851
      goto case_2___3;
    } else {

    }
#line 851
    if (4UL == 4UL) {
#line 851
      goto case_4___3;
    } else {

    }
#line 851
    if (4UL == 8UL) {
#line 851
      goto case_8___3;
    } else {

    }
#line 851
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 851
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 851
    goto ldv_34744;
    case_2___3: /* CIL Label */ 
#line 851
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 851
    goto ldv_34744;
    case_4___3: /* CIL Label */ 
#line 851
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 851
    goto ldv_34744;
    case_8___3: /* CIL Label */ 
#line 851
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 851
    goto ldv_34744;
    switch_default___2: /* CIL Label */ 
    {
#line 851
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34744: 
#line 851
    pscr_ret__ = pfo_ret_____2;
#line 851
    goto ldv_34722;
    switch_default___3: /* CIL Label */ 
    {
#line 851
    __bad_size_call_parameter();
    }
#line 851
    goto ldv_34722;
    switch_break: /* CIL Label */ ;
    }
    ldv_34722: 
    {
#line 851
    printk("\017GRU:%d %s: stole gid %d, ctxnum %d from gts %p. Need cb %d, ds %d; avail cb %ld, ds %ld\n",
           pscr_ret__, "gru_steal_context", (int )gru->gs_gid, ctxnum, ngts, cbr,
           dsr, tmp___4, tmp___3);
    }
  } else {

  }
#line 852
  return;
}
}
#line 857 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
static int gru_assign_context_number(struct gru_state *gru ) 
{ 
  int ctxnum ;
  unsigned long tmp ;

  {
  {
#line 861
  tmp = ldv_find_first_zero_bit_124((unsigned long const   *)(& gru->gs_context_map),
                                    16UL);
#line 861
  ctxnum = (int )tmp;
#line 862
  __set_bit((long )ctxnum, (unsigned long volatile   *)(& gru->gs_context_map));
  }
#line 863
  return (ctxnum);
}
}
#line 869 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
struct gru_state *gru_assign_gru_context(struct gru_thread_state *gts ) 
{ 
  struct gru_state *gru ;
  struct gru_state *grux ;
  int i ;
  int max_active_contexts ;
  int blade_id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;

  {
#line 873
  blade_id = (int )gts->ts_user_blade_id;
#line 875
  if (blade_id < 0) {
    {
#line 876
    blade_id = uv_numa_blade_id();
    }
  } else {

  }
  again: 
#line 878
  gru = (struct gru_state *)0;
#line 879
  max_active_contexts = 16;
#line 880
  grux = (struct gru_state *)(& (gru_base[blade_id])->bs_grus);
#line 880
  i = 0;
#line 880
  goto ldv_34769;
  ldv_34768: 
  {
#line 881
  tmp = gru_check_chiplet_assignment(grux, gts);
  }
#line 881
  if (tmp == 0) {
#line 882
    goto ldv_34766;
  } else {

  }
  {
#line 883
  tmp___0 = check_gru_resources(grux, (int )gts->ts_cbr_au_count, (int )gts->ts_dsr_au_count,
                                max_active_contexts);
  }
#line 883
  if (tmp___0 != 0) {
#line 886
    gru = grux;
#line 887
    max_active_contexts = (int )grux->gs_active_contexts;
#line 888
    if (max_active_contexts == 0) {
#line 889
      goto ldv_34767;
    } else {

    }
  } else {

  }
  ldv_34766: 
#line 880
  i = i + 1;
#line 880
  grux = grux + 1;
  ldv_34769: ;
#line 880
  if (i <= 1) {
#line 882
    goto ldv_34768;
  } else {

  }
  ldv_34767: ;
#line 893
  if ((unsigned long )gru != (unsigned long )((struct gru_state *)0)) {
    {
#line 894
    ldv_spin_lock_108(& gru->gs_lock);
#line 895
    tmp___1 = check_gru_resources(gru, (int )gts->ts_cbr_au_count, (int )gts->ts_dsr_au_count,
                                  16);
    }
#line 895
    if (tmp___1 == 0) {
      {
#line 897
      ldv_spin_unlock_109(& gru->gs_lock);
      }
#line 898
      goto again;
    } else {

    }
    {
#line 900
    reserve_gru_resources(gru, gts);
#line 901
    gts->ts_gru = gru;
#line 902
    gts->ts_blade = (char )gru->gs_blade_id;
#line 903
    gts->ts_ctxnum = gru_assign_context_number(gru);
#line 904
    atomic_inc(& gts->ts_refcnt);
#line 905
    gru->gs_gts[gts->ts_ctxnum] = gts;
#line 906
    ldv_spin_unlock_109(& gru->gs_lock);
    }
#line 908
    if ((gru_options & 2UL) != 0UL) {
      {
#line 908
      atomic_long_inc(& gru_stats.assign_context);
      }
    } else {

    }
#line 909
    if ((int )gru_options & 1) {
#line 909
      __vpp_verify = (void const   *)0;
      {
#line 909
      if (4UL == 1UL) {
#line 909
        goto case_1;
      } else {

      }
#line 913
      if (4UL == 2UL) {
#line 913
        goto case_2___0;
      } else {

      }
#line 913
      if (4UL == 4UL) {
#line 913
        goto case_4___1;
      } else {

      }
#line 913
      if (4UL == 8UL) {
#line 913
        goto case_8___2;
      } else {

      }
#line 913
      goto switch_default___3;
      case_1: /* CIL Label */ ;
      {
#line 913
      if (4UL == 1UL) {
#line 913
        goto case_1___0;
      } else {

      }
#line 913
      if (4UL == 2UL) {
#line 913
        goto case_2;
      } else {

      }
#line 913
      if (4UL == 4UL) {
#line 913
        goto case_4;
      } else {

      }
#line 913
      if (4UL == 8UL) {
#line 913
        goto case_8;
      } else {

      }
#line 913
      goto switch_default;
      case_1___0: /* CIL Label */ 
#line 913
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 913
      goto ldv_34775;
      case_2: /* CIL Label */ 
#line 913
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 913
      goto ldv_34775;
      case_4: /* CIL Label */ 
#line 913
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 913
      goto ldv_34775;
      case_8: /* CIL Label */ 
#line 913
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 913
      goto ldv_34775;
      switch_default: /* CIL Label */ 
      {
#line 913
      __bad_percpu_size();
      }
      switch_break___0: /* CIL Label */ ;
      }
      ldv_34775: 
#line 913
      pscr_ret__ = pfo_ret__;
#line 913
      goto ldv_34781;
      case_2___0: /* CIL Label */ ;
      {
#line 913
      if (4UL == 1UL) {
#line 913
        goto case_1___1;
      } else {

      }
#line 913
      if (4UL == 2UL) {
#line 913
        goto case_2___1;
      } else {

      }
#line 913
      if (4UL == 4UL) {
#line 913
        goto case_4___0;
      } else {

      }
#line 913
      if (4UL == 8UL) {
#line 913
        goto case_8___0;
      } else {

      }
#line 913
      goto switch_default___0;
      case_1___1: /* CIL Label */ 
#line 913
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 913
      goto ldv_34785;
      case_2___1: /* CIL Label */ 
#line 913
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 913
      goto ldv_34785;
      case_4___0: /* CIL Label */ 
#line 913
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 913
      goto ldv_34785;
      case_8___0: /* CIL Label */ 
#line 913
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 913
      goto ldv_34785;
      switch_default___0: /* CIL Label */ 
      {
#line 913
      __bad_percpu_size();
      }
      switch_break___1: /* CIL Label */ ;
      }
      ldv_34785: 
#line 913
      pscr_ret__ = pfo_ret_____0;
#line 913
      goto ldv_34781;
      case_4___1: /* CIL Label */ ;
      {
#line 913
      if (4UL == 1UL) {
#line 913
        goto case_1___2;
      } else {

      }
#line 913
      if (4UL == 2UL) {
#line 913
        goto case_2___2;
      } else {

      }
#line 913
      if (4UL == 4UL) {
#line 913
        goto case_4___2;
      } else {

      }
#line 913
      if (4UL == 8UL) {
#line 913
        goto case_8___1;
      } else {

      }
#line 913
      goto switch_default___1;
      case_1___2: /* CIL Label */ 
#line 913
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 913
      goto ldv_34794;
      case_2___2: /* CIL Label */ 
#line 913
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 913
      goto ldv_34794;
      case_4___2: /* CIL Label */ 
#line 913
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 913
      goto ldv_34794;
      case_8___1: /* CIL Label */ 
#line 913
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 913
      goto ldv_34794;
      switch_default___1: /* CIL Label */ 
      {
#line 913
      __bad_percpu_size();
      }
      switch_break___2: /* CIL Label */ ;
      }
      ldv_34794: 
#line 913
      pscr_ret__ = pfo_ret_____1;
#line 913
      goto ldv_34781;
      case_8___2: /* CIL Label */ ;
      {
#line 913
      if (4UL == 1UL) {
#line 913
        goto case_1___3;
      } else {

      }
#line 913
      if (4UL == 2UL) {
#line 913
        goto case_2___3;
      } else {

      }
#line 913
      if (4UL == 4UL) {
#line 913
        goto case_4___3;
      } else {

      }
#line 913
      if (4UL == 8UL) {
#line 913
        goto case_8___3;
      } else {

      }
#line 913
      goto switch_default___2;
      case_1___3: /* CIL Label */ 
#line 913
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 913
      goto ldv_34803;
      case_2___3: /* CIL Label */ 
#line 913
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 913
      goto ldv_34803;
      case_4___3: /* CIL Label */ 
#line 913
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 913
      goto ldv_34803;
      case_8___3: /* CIL Label */ 
#line 913
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 913
      goto ldv_34803;
      switch_default___2: /* CIL Label */ 
      {
#line 913
      __bad_percpu_size();
      }
      switch_break___3: /* CIL Label */ ;
      }
      ldv_34803: 
#line 913
      pscr_ret__ = pfo_ret_____2;
#line 913
      goto ldv_34781;
      switch_default___3: /* CIL Label */ 
      {
#line 913
      __bad_size_call_parameter();
      }
#line 913
      goto ldv_34781;
      switch_break: /* CIL Label */ ;
      }
      ldv_34781: 
      {
#line 913
      printk("\017GRU:%d %s: gseg %p, gts %p, gid %d, ctx %d, cbr %d, dsr %d\n", pscr_ret__,
             "gru_assign_gru_context", (gts->ts_gru)->gs_gru_base_vaddr + (unsigned long )(gts->ts_ctxnum * 4194304),
             gts, (int )(gts->ts_gru)->gs_gid, gts->ts_ctxnum, (int )gts->ts_cbr_au_count,
             (int )gts->ts_dsr_au_count);
      }
    } else {

    }
  } else {
#line 915
    if ((int )gru_options & 1) {
#line 915
      __vpp_verify___0 = (void const   *)0;
      {
#line 915
      if (4UL == 1UL) {
#line 915
        goto case_1___4;
      } else {

      }
#line 915
      if (4UL == 2UL) {
#line 915
        goto case_2___5;
      } else {

      }
#line 915
      if (4UL == 4UL) {
#line 915
        goto case_4___6;
      } else {

      }
#line 915
      if (4UL == 8UL) {
#line 915
        goto case_8___7;
      } else {

      }
#line 915
      goto switch_default___8;
      case_1___4: /* CIL Label */ ;
      {
#line 915
      if (4UL == 1UL) {
#line 915
        goto case_1___5;
      } else {

      }
#line 915
      if (4UL == 2UL) {
#line 915
        goto case_2___4;
      } else {

      }
#line 915
      if (4UL == 4UL) {
#line 915
        goto case_4___4;
      } else {

      }
#line 915
      if (4UL == 8UL) {
#line 915
        goto case_8___4;
      } else {

      }
#line 915
      goto switch_default___4;
      case_1___5: /* CIL Label */ 
#line 915
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 915
      goto ldv_34817;
      case_2___4: /* CIL Label */ 
#line 915
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 915
      goto ldv_34817;
      case_4___4: /* CIL Label */ 
#line 915
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 915
      goto ldv_34817;
      case_8___4: /* CIL Label */ 
#line 915
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 915
      goto ldv_34817;
      switch_default___4: /* CIL Label */ 
      {
#line 915
      __bad_percpu_size();
      }
      switch_break___5: /* CIL Label */ ;
      }
      ldv_34817: 
#line 915
      pscr_ret_____0 = pfo_ret_____3;
#line 915
      goto ldv_34823;
      case_2___5: /* CIL Label */ ;
      {
#line 915
      if (4UL == 1UL) {
#line 915
        goto case_1___6;
      } else {

      }
#line 915
      if (4UL == 2UL) {
#line 915
        goto case_2___6;
      } else {

      }
#line 915
      if (4UL == 4UL) {
#line 915
        goto case_4___5;
      } else {

      }
#line 915
      if (4UL == 8UL) {
#line 915
        goto case_8___5;
      } else {

      }
#line 915
      goto switch_default___5;
      case_1___6: /* CIL Label */ 
#line 915
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 915
      goto ldv_34827;
      case_2___6: /* CIL Label */ 
#line 915
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 915
      goto ldv_34827;
      case_4___5: /* CIL Label */ 
#line 915
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 915
      goto ldv_34827;
      case_8___5: /* CIL Label */ 
#line 915
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 915
      goto ldv_34827;
      switch_default___5: /* CIL Label */ 
      {
#line 915
      __bad_percpu_size();
      }
      switch_break___6: /* CIL Label */ ;
      }
      ldv_34827: 
#line 915
      pscr_ret_____0 = pfo_ret_____4;
#line 915
      goto ldv_34823;
      case_4___6: /* CIL Label */ ;
      {
#line 915
      if (4UL == 1UL) {
#line 915
        goto case_1___7;
      } else {

      }
#line 915
      if (4UL == 2UL) {
#line 915
        goto case_2___7;
      } else {

      }
#line 915
      if (4UL == 4UL) {
#line 915
        goto case_4___7;
      } else {

      }
#line 915
      if (4UL == 8UL) {
#line 915
        goto case_8___6;
      } else {

      }
#line 915
      goto switch_default___6;
      case_1___7: /* CIL Label */ 
#line 915
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 915
      goto ldv_34836;
      case_2___7: /* CIL Label */ 
#line 915
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 915
      goto ldv_34836;
      case_4___7: /* CIL Label */ 
#line 915
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 915
      goto ldv_34836;
      case_8___6: /* CIL Label */ 
#line 915
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 915
      goto ldv_34836;
      switch_default___6: /* CIL Label */ 
      {
#line 915
      __bad_percpu_size();
      }
      switch_break___7: /* CIL Label */ ;
      }
      ldv_34836: 
#line 915
      pscr_ret_____0 = pfo_ret_____5;
#line 915
      goto ldv_34823;
      case_8___7: /* CIL Label */ ;
      {
#line 915
      if (4UL == 1UL) {
#line 915
        goto case_1___8;
      } else {

      }
#line 915
      if (4UL == 2UL) {
#line 915
        goto case_2___8;
      } else {

      }
#line 915
      if (4UL == 4UL) {
#line 915
        goto case_4___8;
      } else {

      }
#line 915
      if (4UL == 8UL) {
#line 915
        goto case_8___8;
      } else {

      }
#line 915
      goto switch_default___7;
      case_1___8: /* CIL Label */ 
#line 915
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 915
      goto ldv_34845;
      case_2___8: /* CIL Label */ 
#line 915
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 915
      goto ldv_34845;
      case_4___8: /* CIL Label */ 
#line 915
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 915
      goto ldv_34845;
      case_8___8: /* CIL Label */ 
#line 915
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 915
      goto ldv_34845;
      switch_default___7: /* CIL Label */ 
      {
#line 915
      __bad_percpu_size();
      }
      switch_break___8: /* CIL Label */ ;
      }
      ldv_34845: 
#line 915
      pscr_ret_____0 = pfo_ret_____6;
#line 915
      goto ldv_34823;
      switch_default___8: /* CIL Label */ 
      {
#line 915
      __bad_size_call_parameter();
      }
#line 915
      goto ldv_34823;
      switch_break___4: /* CIL Label */ ;
      }
      ldv_34823: 
      {
#line 915
      printk("\017GRU:%d %s: failed to allocate a GTS %s\n", pscr_ret_____0, "gru_assign_gru_context",
             (char *)"");
      }
    } else {

    }
#line 916
    if ((gru_options & 2UL) != 0UL) {
      {
#line 916
      atomic_long_inc(& gru_stats.assign_context_failed);
      }
    } else {

    }
  }
#line 919
  return (gru);
}
}
#line 929 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grumain.c"
int gru_fault(struct vm_area_struct *vma , struct vm_fault *vmf ) 
{ 
  struct gru_thread_state *gts ;
  unsigned long paddr ;
  unsigned long vaddr ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct gru_state *tmp___4 ;

  {
#line 934
  vaddr = (unsigned long )vmf->virtual_address;
#line 935
  if ((int )gru_options & 1) {
#line 935
    __vpp_verify = (void const   *)0;
    {
#line 935
    if (4UL == 1UL) {
#line 935
      goto case_1;
    } else {

    }
#line 936
    if (4UL == 2UL) {
#line 936
      goto case_2___0;
    } else {

    }
#line 936
    if (4UL == 4UL) {
#line 936
      goto case_4___1;
    } else {

    }
#line 936
    if (4UL == 8UL) {
#line 936
      goto case_8___2;
    } else {

    }
#line 936
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 936
    if (4UL == 1UL) {
#line 936
      goto case_1___0;
    } else {

    }
#line 936
    if (4UL == 2UL) {
#line 936
      goto case_2;
    } else {

    }
#line 936
    if (4UL == 4UL) {
#line 936
      goto case_4;
    } else {

    }
#line 936
    if (4UL == 8UL) {
#line 936
      goto case_8;
    } else {

    }
#line 936
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 936
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 936
    goto ldv_34865;
    case_2: /* CIL Label */ 
#line 936
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 936
    goto ldv_34865;
    case_4: /* CIL Label */ 
#line 936
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 936
    goto ldv_34865;
    case_8: /* CIL Label */ 
#line 936
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 936
    goto ldv_34865;
    switch_default: /* CIL Label */ 
    {
#line 936
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34865: 
#line 936
    pscr_ret__ = pfo_ret__;
#line 936
    goto ldv_34871;
    case_2___0: /* CIL Label */ ;
    {
#line 936
    if (4UL == 1UL) {
#line 936
      goto case_1___1;
    } else {

    }
#line 936
    if (4UL == 2UL) {
#line 936
      goto case_2___1;
    } else {

    }
#line 936
    if (4UL == 4UL) {
#line 936
      goto case_4___0;
    } else {

    }
#line 936
    if (4UL == 8UL) {
#line 936
      goto case_8___0;
    } else {

    }
#line 936
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 936
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 936
    goto ldv_34875;
    case_2___1: /* CIL Label */ 
#line 936
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 936
    goto ldv_34875;
    case_4___0: /* CIL Label */ 
#line 936
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 936
    goto ldv_34875;
    case_8___0: /* CIL Label */ 
#line 936
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 936
    goto ldv_34875;
    switch_default___0: /* CIL Label */ 
    {
#line 936
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34875: 
#line 936
    pscr_ret__ = pfo_ret_____0;
#line 936
    goto ldv_34871;
    case_4___1: /* CIL Label */ ;
    {
#line 936
    if (4UL == 1UL) {
#line 936
      goto case_1___2;
    } else {

    }
#line 936
    if (4UL == 2UL) {
#line 936
      goto case_2___2;
    } else {

    }
#line 936
    if (4UL == 4UL) {
#line 936
      goto case_4___2;
    } else {

    }
#line 936
    if (4UL == 8UL) {
#line 936
      goto case_8___1;
    } else {

    }
#line 936
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 936
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 936
    goto ldv_34884;
    case_2___2: /* CIL Label */ 
#line 936
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 936
    goto ldv_34884;
    case_4___2: /* CIL Label */ 
#line 936
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 936
    goto ldv_34884;
    case_8___1: /* CIL Label */ 
#line 936
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 936
    goto ldv_34884;
    switch_default___1: /* CIL Label */ 
    {
#line 936
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34884: 
#line 936
    pscr_ret__ = pfo_ret_____1;
#line 936
    goto ldv_34871;
    case_8___2: /* CIL Label */ ;
    {
#line 936
    if (4UL == 1UL) {
#line 936
      goto case_1___3;
    } else {

    }
#line 936
    if (4UL == 2UL) {
#line 936
      goto case_2___3;
    } else {

    }
#line 936
    if (4UL == 4UL) {
#line 936
      goto case_4___3;
    } else {

    }
#line 936
    if (4UL == 8UL) {
#line 936
      goto case_8___3;
    } else {

    }
#line 936
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 936
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 936
    goto ldv_34893;
    case_2___3: /* CIL Label */ 
#line 936
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 936
    goto ldv_34893;
    case_4___3: /* CIL Label */ 
#line 936
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 936
    goto ldv_34893;
    case_8___3: /* CIL Label */ 
#line 936
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 936
    goto ldv_34893;
    switch_default___2: /* CIL Label */ 
    {
#line 936
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34893: 
#line 936
    pscr_ret__ = pfo_ret_____2;
#line 936
    goto ldv_34871;
    switch_default___3: /* CIL Label */ 
    {
#line 936
    __bad_size_call_parameter();
    }
#line 936
    goto ldv_34871;
    switch_break: /* CIL Label */ ;
    }
    ldv_34871: 
    {
#line 936
    printk("\017GRU:%d %s: vma %p, vaddr 0x%lx (0x%lx)\n", pscr_ret__, "gru_fault",
           vma, vaddr, vaddr & 0xfffffffffffc0000UL);
    }
  } else {

  }
#line 937
  if ((gru_options & 2UL) != 0UL) {
    {
#line 937
    atomic_long_inc(& gru_stats.nopfn);
    }
  } else {

  }
  {
#line 940
  gts = gru_find_thread_state(vma, (int )((vaddr - vma->vm_start) / 262144UL));
  }
#line 941
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 942
    return (2);
  } else {

  }
  again: 
  {
#line 945
  ldv_mutex_lock_128(& gts->ts_ctxlock);
#line 946
  __preempt_count_add(1);
#line 946
  __asm__  volatile   ("": : : "memory");
#line 948
  gru_check_context_placement(gts);
  }
#line 950
  if ((unsigned long )gts->ts_gru == (unsigned long )((struct gru_state *)0)) {
#line 951
    if ((gru_options & 2UL) != 0UL) {
      {
#line 951
      atomic_long_inc(& gru_stats.load_user_context);
      }
    } else {

    }
    {
#line 952
    tmp___4 = gru_assign_gru_context(gts);
    }
#line 952
    if ((unsigned long )tmp___4 == (unsigned long )((struct gru_state *)0)) {
      {
#line 953
      __asm__  volatile   ("": : : "memory");
#line 953
      __preempt_count_sub(1);
#line 954
      ldv_mutex_unlock_129(& gts->ts_ctxlock);
#line 955
      tmp = get_current___0();
      }
#line 955
      tmp->task_state_change = (unsigned long )((void *)0);
#line 955
      __ret = 1L;
      {
#line 955
      if (8UL == 1UL) {
#line 955
        goto case_1___4;
      } else {

      }
#line 955
      if (8UL == 2UL) {
#line 955
        goto case_2___4;
      } else {

      }
#line 955
      if (8UL == 4UL) {
#line 955
        goto case_4___4;
      } else {

      }
#line 955
      if (8UL == 8UL) {
#line 955
        goto case_8___4;
      } else {

      }
#line 955
      goto switch_default___4;
      case_1___4: /* CIL Label */ 
      {
#line 955
      tmp___0 = get_current___0();
#line 955
      __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                           "cc");
      }
#line 955
      goto ldv_34907;
      case_2___4: /* CIL Label */ 
      {
#line 955
      tmp___1 = get_current___0();
#line 955
      __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                           "cc");
      }
#line 955
      goto ldv_34907;
      case_4___4: /* CIL Label */ 
      {
#line 955
      tmp___2 = get_current___0();
#line 955
      __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                           "cc");
      }
#line 955
      goto ldv_34907;
      case_8___4: /* CIL Label */ 
      {
#line 955
      tmp___3 = get_current___0();
#line 955
      __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                           "cc");
      }
#line 955
      goto ldv_34907;
      switch_default___4: /* CIL Label */ 
      {
#line 955
      __xchg_wrong_size();
      }
      switch_break___4: /* CIL Label */ ;
      }
      ldv_34907: 
      {
#line 956
      schedule_timeout(5L);
      }
#line 957
      if (gts->ts_steal_jiffies + 50UL < (unsigned long )jiffies) {
        {
#line 958
        gru_steal_context(gts);
        }
      } else {

      }
#line 959
      goto again;
    } else {

    }
    {
#line 961
    gru_load_context(gts);
#line 962
    paddr = (gts->ts_gru)->gs_gru_base_paddr + (unsigned long )(gts->ts_ctxnum * 4194304);
#line 963
    remap_pfn_range(vma, vaddr & 0xfffffffffffc0000UL, paddr >> 12, 262144UL, vma->vm_page_prot);
    }
  } else {

  }
  {
#line 968
  __asm__  volatile   ("": : : "memory");
#line 968
  __preempt_count_sub(1);
#line 969
  ldv_mutex_unlock_130(& gts->ts_ctxlock);
  }
#line 971
  return (256);
}
}
#line 693 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void *ERR_PTR(long error ) 
{ 
  void *tmp ;

  {
  {
#line 696
  tmp = ldv_err_ptr(error);
  }
#line 696
  return (tmp);
}
}
#line 723 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
  {
#line 726
  ldv_linux_usb_dev_atomic_inc(v);
  }
#line 727
  return;
}
}
#line 753 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 756
  tmp = ldv_linux_usb_dev_atomic_add_return(i, v);
  }
#line 756
  return (tmp);
}
}
#line 1251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 1255
  ldv_check_alloc_flags(flags);
#line 1256
  res = ldv_malloc_unknown_size();
#line 1257
  ldv_after_alloc(res);
  }
#line 1258
  return (res);
}
}
#line 1339 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_first_bit_95(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1342
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1342
  return (tmp);
}
}
#line 1345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_lock_96(spinlock_t *lock ) 
{ 


  {
  {
#line 1348
  ldv_linux_kernel_locking_spinlock_spin_lock_ms_asid_lock_of_gru_mm_struct();
#line 1350
  spin_lock(lock);
  }
#line 1351
  return;
}
}
#line 1353 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_lock_97(spinlock_t *lock ) 
{ 


  {
  {
#line 1356
  ldv_linux_kernel_locking_spinlock_spin_lock_gs_asid_lock_of_gru_state();
#line 1358
  spin_lock(lock);
  }
#line 1359
  return;
}
}
#line 1361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_unlock_98(spinlock_t *lock ) 
{ 


  {
  {
#line 1364
  ldv_linux_kernel_locking_spinlock_spin_unlock_gs_asid_lock_of_gru_state();
#line 1366
  spin_unlock(lock);
  }
#line 1367
  return;
}
}
#line 1369 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_unlock_99(spinlock_t *lock ) 
{ 


  {
  {
#line 1372
  ldv_linux_kernel_locking_spinlock_spin_unlock_ms_asid_lock_of_gru_mm_struct();
#line 1374
  spin_unlock(lock);
  }
#line 1375
  return;
}
}
#line 1409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_lock_104(spinlock_t *lock ) 
{ 


  {
  {
#line 1412
  ldv_linux_kernel_locking_spinlock_spin_lock_vd_lock_of_gru_vma_data();
#line 1414
  spin_lock(lock);
  }
#line 1415
  return;
}
}
#line 1417 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_unlock_105(spinlock_t *lock ) 
{ 


  {
  {
#line 1420
  ldv_linux_kernel_locking_spinlock_spin_unlock_vd_lock_of_gru_vma_data();
#line 1422
  spin_unlock(lock);
  }
#line 1423
  return;
}
}
#line 1441 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_lock_108(spinlock_t *lock ) 
{ 


  {
  {
#line 1444
  ldv_linux_kernel_locking_spinlock_spin_lock_gs_lock_of_gru_state();
#line 1446
  spin_lock(lock);
  }
#line 1447
  return;
}
}
#line 1449 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_unlock_109(spinlock_t *lock ) 
{ 


  {
  {
#line 1452
  ldv_linux_kernel_locking_spinlock_spin_unlock_gs_lock_of_gru_state();
#line 1454
  spin_unlock(lock);
  }
#line 1455
  return;
}
}
#line 1457 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_first_bit_110(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1460
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1460
  return (tmp);
}
}
#line 1463 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_next_bit_111(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1466
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1466
  return (tmp);
}
}
#line 1469 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_first_bit_112(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1472
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1472
  return (tmp);
}
}
#line 1475 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_next_bit_113(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1478
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1478
  return (tmp);
}
}
#line 1481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_first_bit_114(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1484
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1484
  return (tmp);
}
}
#line 1487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_next_bit_115(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1490
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1490
  return (tmp);
}
}
#line 1493 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_first_bit_116(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1496
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1496
  return (tmp);
}
}
#line 1499 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_next_bit_117(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1502
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1502
  return (tmp);
}
}
#line 1505 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static int ldv_mutex_trylock_118(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 1509
  tmp = ldv_linux_kernel_locking_mutex_mutex_trylock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1509
  return (tmp);
}
}
#line 1512 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1516
  ldv_linux_kernel_locking_mutex_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1517
  return;
}
}
#line 1519 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_lock_120(spinlock_t *lock ) 
{ 


  {
  {
#line 1522
  ldv_linux_kernel_locking_spinlock_spin_lock_bs_lock_of_gru_blade_state();
#line 1524
  spin_lock(lock);
  }
#line 1525
  return;
}
}
#line 1543 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
__inline static void ldv_spin_unlock_123(spinlock_t *lock ) 
{ 


  {
  {
#line 1546
  ldv_linux_kernel_locking_spinlock_spin_unlock_bs_lock_of_gru_blade_state();
#line 1548
  spin_unlock(lock);
  }
#line 1549
  return;
}
}
#line 1551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static unsigned long ldv_find_first_zero_bit_124(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1554
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1554
  return (tmp);
}
}
#line 1581 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static void ldv_mutex_lock_128(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1585
  ldv_linux_kernel_locking_mutex_mutex_lock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1586
  return;
}
}
#line 1588 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static void ldv_mutex_unlock_129(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1592
  ldv_linux_kernel_locking_mutex_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1593
  return;
}
}
#line 1595 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grumain.c.aux"
static void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1599
  ldv_linux_kernel_locking_mutex_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1600
  return;
}
}
#line 24 "/home/ubuntu/klever-work/linux/ldv/err.h"
long ldv_ptr_err(void const   *ptr ) ;
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static void ldv_mutex_lock_96(struct mutex *ldv_func_arg1 ) ;
#line 370
static void ldv_mutex_lock_97(struct mutex *ldv_func_arg1 ) ;
#line 227 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
__inline static pgdval_t native_pgd_val(pgd_t pgd ) 
{ 


  {
#line 229
  return (pgd.pgd);
}
}
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
__inline static pudval_t native_pud_val(pud_t pud ) 
{ 


  {
#line 247
  return (pud.pud);
}
}
#line 266 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t native_pmd_val(pmd_t pmd ) 
{ 


  {
#line 268
  return (pmd.pmd);
}
}
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
__inline static pmdval_t pmd_flags(pmd_t pmd ) 
{ 
  pmdval_t tmp ;

  {
  {
#line 286
  tmp = native_pmd_val(pmd);
  }
#line 286
  return (tmp & 0xffffc00000000fffUL);
}
}
#line 294 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t native_pte_val(pte_t pte ) 
{ 


  {
#line 296
  return (pte.pte);
}
}
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
__inline static pteval_t pte_flags(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
  {
#line 301
  tmp = native_pte_val(pte);
  }
#line 301
  return (tmp & 0xffffc00000000fffUL);
}
}
#line 360 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
extern struct pv_mmu_ops pv_mmu_ops ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bitops/find.h"
static unsigned long ldv_find_next_bit_100(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) ;
#line 34
static unsigned long ldv_find_next_bit_102(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) ;
#line 54
static unsigned long ldv_find_first_bit_99(unsigned long const   *addr , unsigned long size ) ;
#line 58
static unsigned long ldv_find_first_bit_101(unsigned long const   *addr , unsigned long size ) ;
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current___1(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  {
#line 14
  if (8UL == 1UL) {
#line 14
    goto case_1;
  } else {

  }
#line 14
  if (8UL == 2UL) {
#line 14
    goto case_2;
  } else {

  }
#line 14
  if (8UL == 4UL) {
#line 14
    goto case_4;
  } else {

  }
#line 14
  if (8UL == 8UL) {
#line 14
    goto case_8;
  } else {

  }
#line 14
  goto switch_default;
  case_1: /* CIL Label */ 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3566;
  case_2: /* CIL Label */ 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3566;
  case_4: /* CIL Label */ 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3566;
  case_8: /* CIL Label */ 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3566;
  switch_default: /* CIL Label */ 
  {
#line 14
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_3566: ;
#line 14
  return (pfo_ret__);
}
}
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static pteval_t pte_val(pte_t pte ) 
{ 
  pteval_t ret ;
  pteval_t __ret___0 ;
  unsigned long __edi___0 ;
  unsigned long __esi___0 ;
  unsigned long __edx___0 ;
  unsigned long __ecx___0 ;
  unsigned long __eax___0 ;
  long tmp___0 ;

  {
  {
#line 450
  __edi___0 = __edi___0;
#line 450
  __esi___0 = __esi___0;
#line 450
  __edx___0 = __edx___0;
#line 450
  __ecx___0 = __ecx___0;
#line 450
  __eax___0 = __eax___0;
#line 450
  tmp___0 = __builtin_expect((unsigned long )pv_mmu_ops.pte_val.func == (unsigned long )((void *)0),
                             0L);
  }
#line 450
  if (tmp___0 != 0L) {
    {
#line 450
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (451), "i" (12UL));
#line 450
    __builtin_unreachable();
    }
  } else {

  }
#line 450
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax___0): [paravirt_typenum] "i" (81UL),
                       [paravirt_opptr] "i" (& pv_mmu_ops.pte_val.func), [paravirt_clobber] "i" (1),
                       "D" (pte.pte): "memory", "cc");
#line 450
  __ret___0 = __eax___0;
#line 450
  ret = __ret___0;
#line 453
  return (ret);
}
}
#line 470 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static pgdval_t pgd_val(pgd_t pgd ) 
{ 
  pgdval_t ret ;
  pgdval_t __ret___0 ;
  unsigned long __edi___0 ;
  unsigned long __esi___0 ;
  unsigned long __edx___0 ;
  unsigned long __ecx___0 ;
  unsigned long __eax___0 ;
  long tmp___0 ;

  {
  {
#line 478
  __edi___0 = __edi___0;
#line 478
  __esi___0 = __esi___0;
#line 478
  __edx___0 = __edx___0;
#line 478
  __ecx___0 = __ecx___0;
#line 478
  __eax___0 = __eax___0;
#line 478
  tmp___0 = __builtin_expect((unsigned long )pv_mmu_ops.pgd_val.func == (unsigned long )((void *)0),
                             0L);
  }
#line 478
  if (tmp___0 != 0L) {
    {
#line 478
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (479), "i" (12UL));
#line 478
    __builtin_unreachable();
    }
  } else {

  }
#line 478
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax___0): [paravirt_typenum] "i" (83UL),
                       [paravirt_opptr] "i" (& pv_mmu_ops.pgd_val.func), [paravirt_clobber] "i" (1),
                       "D" (pgd.pgd): "memory", "cc");
#line 478
  __ret___0 = __eax___0;
#line 478
  ret = __ret___0;
#line 481
  return (ret);
}
}
#line 563 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static pmdval_t pmd_val(pmd_t pmd ) 
{ 
  pmdval_t ret ;
  pmdval_t __ret___0 ;
  unsigned long __edi___0 ;
  unsigned long __esi___0 ;
  unsigned long __edx___0 ;
  unsigned long __ecx___0 ;
  unsigned long __eax___0 ;
  long tmp___0 ;

  {
  {
#line 571
  __edi___0 = __edi___0;
#line 571
  __esi___0 = __esi___0;
#line 571
  __edx___0 = __edx___0;
#line 571
  __ecx___0 = __ecx___0;
#line 571
  __eax___0 = __eax___0;
#line 571
  tmp___0 = __builtin_expect((unsigned long )pv_mmu_ops.pmd_val.func == (unsigned long )((void *)0),
                             0L);
  }
#line 571
  if (tmp___0 != 0L) {
    {
#line 571
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (572), "i" (12UL));
#line 571
    __builtin_unreachable();
    }
  } else {

  }
#line 571
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax___0): [paravirt_typenum] "i" (86UL),
                       [paravirt_opptr] "i" (& pv_mmu_ops.pmd_val.func), [paravirt_clobber] "i" (1),
                       "D" (pmd.pmd): "memory", "cc");
#line 571
  __ret___0 = __eax___0;
#line 571
  ret = __ret___0;
#line 574
  return (ret);
}
}
#line 603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static pudval_t pud_val(pud_t pud ) 
{ 
  pudval_t ret ;
  pudval_t __ret___0 ;
  unsigned long __edi___0 ;
  unsigned long __esi___0 ;
  unsigned long __edx___0 ;
  unsigned long __ecx___0 ;
  unsigned long __eax___0 ;
  long tmp___0 ;

  {
  {
#line 611
  __edi___0 = __edi___0;
#line 611
  __esi___0 = __esi___0;
#line 611
  __edx___0 = __edx___0;
#line 611
  __ecx___0 = __ecx___0;
#line 611
  __eax___0 = __eax___0;
#line 611
  tmp___0 = __builtin_expect((unsigned long )pv_mmu_ops.pud_val.func == (unsigned long )((void *)0),
                             0L);
  }
#line 611
  if (tmp___0 != 0L) {
    {
#line 611
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (612), "i" (12UL));
#line 611
    __builtin_unreachable();
    }
  } else {

  }
#line 611
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax___0): [paravirt_typenum] "i" (88UL),
                       [paravirt_opptr] "i" (& pv_mmu_ops.pud_val.func), [paravirt_clobber] "i" (1),
                       "D" (pud.pud): "memory", "cc");
#line 611
  __ret___0 = __eax___0;
#line 611
  ret = __ret___0;
#line 614
  return (ret);
}
}
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 32
__inline static long PTR_ERR(void const   *ptr ) ;
#line 669 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
__inline static void sync_core(void) 
{ 
  int tmp ;

  {
#line 691
  __asm__  volatile   ("cpuid": "=a" (tmp): "0" (1): "ebx", "ecx", "edx", "memory");
#line 692
  return;
}
}
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
static int ldv_mutex_trylock_104(struct mutex *ldv_func_arg1 ) ;
#line 197
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) ;
#line 201
static void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1 ) ;
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_lock_108(spinlock_t *lock ) ;
#line 358
__inline static void ldv_spin_lock_108(spinlock_t *lock ) ;
#line 399
__inline static void ldv_spin_unlock_109(spinlock_t *lock ) ;
#line 403
__inline static void ldv_spin_unlock_109(spinlock_t *lock ) ;
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 914
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/completion.h"
extern void complete(struct completion * ) ;
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwsem.h"
extern void down_read(struct rw_semaphore * ) ;
#line 113
extern int down_read_trylock(struct rw_semaphore * ) ;
#line 128
extern void up_read(struct rw_semaphore * ) ;
#line 138
extern void downgrade_write(struct rw_semaphore * ) ;
#line 214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
extern bool capable(int  ) ;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static int pte_dirty(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
  {
#line 95
  tmp = pte_flags(pte);
  }
#line 95
  return ((int )tmp & 64);
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static int pte_write(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
  {
#line 115
  tmp = pte_flags(pte);
  }
#line 115
  return ((int )tmp & 2);
}
}
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pte_pfn(pte_t pte ) 
{ 
  pteval_t tmp ;

  {
  {
#line 140
  tmp = pte_val(pte);
  }
#line 140
  return ((tmp & 70368744173568UL) >> 12);
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static int pmd_large(pmd_t pte ) 
{ 
  pmdval_t tmp ;

  {
  {
#line 157
  tmp = pmd_flags(pte);
  }
#line 157
  return ((int )tmp & 128);
}
}
#line 438 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static int pte_present(pte_t a ) 
{ 
  pteval_t tmp ;

  {
  {
#line 440
  tmp = pte_flags(a);
  }
#line 440
  return ((int )tmp & 257);
}
}
#line 490 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static int pmd_none(pmd_t pmd ) 
{ 
  pmdval_t tmp ;

  {
  {
#line 494
  tmp = native_pmd_val(pmd);
  }
#line 494
  return (tmp == 0UL);
}
}
#line 497 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pmd_page_vaddr(pmd_t pmd ) 
{ 
  pmdval_t tmp ;

  {
  {
#line 499
  tmp = pmd_val(pmd);
  }
#line 499
  return ((tmp & 70368744173568UL) + 0xffff880000000000UL);
}
}
#line 514 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pmd_index(unsigned long address ) 
{ 


  {
#line 516
  return ((address >> 21) & 511UL);
}
}
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pte_index(unsigned long address ) 
{ 


  {
#line 536
  return ((address >> 12) & 511UL);
}
}
#line 539 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static pte_t *pte_offset_kernel(pmd_t *pmd , unsigned long address ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 541
  tmp = pte_index(address);
#line 541
  tmp___0 = pmd_page_vaddr(*pmd);
  }
#line 541
  return ((pte_t *)(tmp + tmp___0));
}
}
#line 555 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static int pud_none(pud_t pud ) 
{ 
  pudval_t tmp ;

  {
  {
#line 557
  tmp = native_pud_val(pud);
  }
#line 557
  return (tmp == 0UL);
}
}
#line 565 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pud_page_vaddr(pud_t pud ) 
{ 
  pudval_t tmp ;

  {
  {
#line 567
  tmp = pud_val(pud);
  }
#line 567
  return ((tmp & 70368744173568UL) + 0xffff880000000000UL);
}
}
#line 577 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static pmd_t *pmd_offset(pud_t *pud , unsigned long address ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 579
  tmp = pmd_index(address);
#line 579
  tmp___0 = pud_page_vaddr(*pud);
  }
#line 579
  return ((pmd_t *)(tmp + tmp___0));
}
}
#line 605 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pgd_page_vaddr(pgd_t pgd ) 
{ 
  pgdval_t tmp ;

  {
  {
#line 607
  tmp = pgd_val(pgd);
  }
#line 607
  return ((tmp & 70368744173568UL) + 0xffff880000000000UL);
}
}
#line 617 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static unsigned long pud_index(unsigned long address ) 
{ 


  {
#line 619
  return ((address >> 30) & 511UL);
}
}
#line 622 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static pud_t *pud_offset(pgd_t *pgd , unsigned long address ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 624
  tmp = pud_index(address);
#line 624
  tmp___0 = pgd_page_vaddr(*pgd);
  }
#line 624
  return ((pud_t *)(tmp + tmp___0));
}
}
#line 632 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable.h"
__inline static int pgd_none(pgd_t pgd ) 
{ 
  pgdval_t tmp ;

  {
  {
#line 634
  tmp = native_pgd_val(pgd);
  }
#line 634
  return (tmp == 0UL);
}
}
#line 621 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
extern void put_page(struct page * ) ;
#line 1265
extern long get_user_pages(struct task_struct * , struct mm_struct * , unsigned long  ,
                           unsigned long  , int  , int  , struct page ** , struct vm_area_struct ** ) ;
#line 2032
extern struct vm_area_struct *find_vma(struct mm_struct * , unsigned long  ) ;
#line 8 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hugetlb_inline.h"
__inline static int is_vm_hugetlb_page(struct vm_area_struct *vma ) 
{ 


  {
#line 10
  return ((vma->vm_flags & 4194304UL) != 0UL);
}
}
#line 419 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
extern void schedule(void) ;
#line 1050 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
extern void dev_err(struct device  const  * , char const   *  , ...) ;
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static void *get_gseg_base_address(void *base , int ctxnum ) 
{ 


  {
#line 103
  return (base + (unsigned long )(ctxnum * 4194304));
}
}
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static void *get_gseg_base_address_cb(void *base , int ctxnum , int line ) 
{ 
  void *tmp ;

  {
  {
#line 108
  tmp = get_gseg_base_address(base, ctxnum);
  }
#line 108
  return (tmp + (unsigned long )(line * 256));
}
}
#line 118 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_tlb_fault_map *get_tfm(void *base , int ctxnum ) 
{ 


  {
#line 120
  return ((struct gru_tlb_fault_map *)(base + ((unsigned long )(ctxnum * 256) + 67108864UL)));
}
}
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_control_block_extended *get_cbe(void *base , int ctxnum ) 
{ 


  {
#line 132
  return ((struct gru_control_block_extended *)(base + ((unsigned long )(ctxnum * 256) + 67174400UL)));
}
}
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_tlb_fault_handle *get_tfh(void *base , int ctxnum ) 
{ 


  {
#line 138
  return ((struct gru_tlb_fault_handle *)(base + ((unsigned long )(ctxnum * 256) + 67207168UL)));
}
}
#line 149 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static unsigned long get_cb_number(void *cb ) 
{ 


  {
#line 151
  return (((unsigned long )cb & 262143UL) / 256UL);
}
}
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_control_block_extended *gru_tfh_to_cbe(struct gru_tlb_fault_handle *tfh ) 
{ 
  unsigned long cbe ;

  {
#line 172
  cbe = (unsigned long )tfh - 32768UL;
#line 173
  return ((struct gru_control_block_extended *)cbe);
}
}
#line 523
int tfh_write_only(struct gru_tlb_fault_handle *tfh , unsigned long paddr , int gaa ,
                   unsigned long vaddr , int asid , int dirty , int pagesize ) ;
#line 525
void tfh_write_restart(struct gru_tlb_fault_handle *tfh , unsigned long paddr , int gaa ,
                       unsigned long vaddr , int asid , int dirty , int pagesize ) ;
#line 528
void tfh_user_polling_mode(struct gru_tlb_fault_handle *tfh ) ;
#line 529
void tfh_exception(struct gru_tlb_fault_handle *tfh ) ;
#line 673 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
void gru_flush_tlb_range(struct gru_mm_struct *gms , unsigned long start , unsigned long len ) ;
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_soc_phys_ram_to_gpa(unsigned long paddr ) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;
  void const   *__vpp_verify___0 ;
  unsigned long tcp_ptr_____0 ;
  void const   *__vpp_verify___1 ;
  unsigned long tcp_ptr_____1 ;
  void const   *__vpp_verify___2 ;
  unsigned long tcp_ptr_____2 ;
  void const   *__vpp_verify___3 ;
  unsigned long tcp_ptr_____3 ;
  void const   *__vpp_verify___4 ;
  unsigned long tcp_ptr_____4 ;
  void const   *__vpp_verify___5 ;
  unsigned long tcp_ptr_____5 ;

  {
#line 313
  __vpp_verify___0 = (void const   *)0;
#line 313
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____0): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 313
  if (paddr < ((struct uv_hub_info_s *)tcp_ptr_____0)->lowmem_remap_top) {
#line 314
    __vpp_verify = (void const   *)0;
#line 314
    __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off),
                         "0" (& __uv_hub_info));
#line 314
    paddr = paddr | ((struct uv_hub_info_s *)tcp_ptr__)->lowmem_remap_base;
  } else {

  }
#line 315
  __vpp_verify___1 = (void const   *)0;
#line 315
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____1): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 315
  paddr = paddr | ((struct uv_hub_info_s *)tcp_ptr_____1)->gnode_upper;
#line 316
  __vpp_verify___2 = (void const   *)0;
#line 316
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____2): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 316
  __vpp_verify___3 = (void const   *)0;
#line 316
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____3): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  __vpp_verify___4 = (void const   *)0;
#line 317
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____4): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  __vpp_verify___5 = (void const   *)0;
#line 317
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr_____5): "m" (this_cpu_off),
                       "0" (& __uv_hub_info));
#line 317
  paddr = ((paddr << (int )((struct uv_hub_info_s *)tcp_ptr_____2)->m_shift) >> (int )((struct uv_hub_info_s *)tcp_ptr_____3)->m_shift) | ((paddr >> (int )((struct uv_hub_info_s *)tcp_ptr_____4)->m_val) << (int )((struct uv_hub_info_s *)tcp_ptr_____5)->n_lshift);
#line 318
  return (paddr);
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
__inline static int is_gru_paddr(unsigned long paddr ) 
{ 


  {
#line 55
  return (paddr >= gru_start_paddr && paddr < gru_end_paddr);
}
}
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
struct vm_area_struct *gru_find_vma(unsigned long vaddr ) 
{ 
  struct vm_area_struct *vma ;
  struct task_struct *tmp ;

  {
  {
#line 65
  tmp = get_current___1();
#line 65
  vma = find_vma(tmp->mm, vaddr);
  }
#line 66
  if (((unsigned long )vma != (unsigned long )((struct vm_area_struct *)0) && vma->vm_start <= vaddr) && (unsigned long )vma->vm_ops == (unsigned long )(& gru_vm_ops)) {
#line 67
    return (vma);
  } else {

  }
#line 68
  return ((struct vm_area_struct *)0);
}
}
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static struct gru_thread_state *gru_find_lock_gts(unsigned long vaddr ) 
{ 
  struct mm_struct *mm ;
  struct task_struct *tmp ;
  struct vm_area_struct *vma ;
  struct gru_thread_state *gts ;

  {
  {
#line 81
  tmp = get_current___1();
#line 81
  mm = tmp->mm;
#line 83
  gts = (struct gru_thread_state *)0;
#line 85
  down_read(& mm->mmap_sem);
#line 86
  vma = gru_find_vma(vaddr);
  }
#line 87
  if ((unsigned long )vma != (unsigned long )((struct vm_area_struct *)0)) {
    {
#line 88
    gts = gru_find_thread_state(vma, (int )((vaddr - vma->vm_start) / 262144UL));
    }
  } else {

  }
#line 89
  if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 90
    ldv_mutex_lock_96(& gts->ts_ctxlock);
    }
  } else {
    {
#line 92
    up_read(& mm->mmap_sem);
    }
  }
#line 93
  return (gts);
}
}
#line 96 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static struct gru_thread_state *gru_alloc_locked_gts(unsigned long vaddr ) 
{ 
  struct mm_struct *mm ;
  struct task_struct *tmp ;
  struct vm_area_struct *vma ;
  struct gru_thread_state *gts ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 98
  tmp = get_current___1();
#line 98
  mm = tmp->mm;
#line 100
  tmp___0 = ERR_PTR(-22L);
#line 100
  gts = (struct gru_thread_state *)tmp___0;
#line 102
  down_write(& mm->mmap_sem);
#line 103
  vma = gru_find_vma(vaddr);
  }
#line 104
  if ((unsigned long )vma == (unsigned long )((struct vm_area_struct *)0)) {
#line 105
    goto err;
  } else {

  }
  {
#line 107
  gts = gru_alloc_thread_state(vma, (int )((vaddr - vma->vm_start) / 262144UL));
#line 108
  tmp___1 = IS_ERR((void const   *)gts);
  }
#line 108
  if ((int )tmp___1) {
#line 109
    goto err;
  } else {

  }
  {
#line 110
  ldv_mutex_lock_97(& gts->ts_ctxlock);
#line 111
  downgrade_write(& mm->mmap_sem);
  }
#line 112
  return (gts);
  err: 
  {
#line 115
  up_write(& mm->mmap_sem);
  }
#line 116
  return (gts);
}
}
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static void gru_unlock_gts(struct gru_thread_state *gts ) 
{ 
  struct task_struct *tmp ;

  {
  {
#line 124
  ldv_mutex_unlock_98(& gts->ts_ctxlock);
#line 125
  tmp = get_current___1();
#line 125
  up_read(& (tmp->mm)->mmap_sem);
  }
#line 126
  return;
}
}
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static void gru_cb_set_istatus_active(struct gru_instruction_bits *cbk ) 
{ 


  {
#line 138
  if ((unsigned long )cbk != (unsigned long )((struct gru_instruction_bits *)0)) {
#line 139
    cbk->istatus = 2U;
  } else {

  }
#line 140
  return;
}
}
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static void get_clear_fault_map(struct gru_state *gru , struct gru_tlb_fault_map *imap ,
                                struct gru_tlb_fault_map *dmap ) 
{ 
  unsigned long i ;
  unsigned long k ;
  struct gru_tlb_fault_map *tfm ;
  int tmp ;
  unsigned long __ret ;
  unsigned long __ret___0 ;

  {
  {
#line 161
  tmp = gru_cpu_fault_map_id();
#line 161
  tfm = get_tfm(gru->gs_gru_base_vaddr, tmp);
#line 162
  prefetchw((void const   *)tfm);
#line 163
  i = 0UL;
  }
#line 163
  goto ldv_36064;
  ldv_36063: 
#line 164
  k = tfm->fault_bits[i];
#line 165
  if (k != 0UL) {
#line 166
    __ret = 0UL;
    {
#line 166
    if (8UL == 1UL) {
#line 166
      goto case_1;
    } else {

    }
#line 166
    if (8UL == 2UL) {
#line 166
      goto case_2;
    } else {

    }
#line 166
    if (8UL == 4UL) {
#line 166
      goto case_4;
    } else {

    }
#line 166
    if (8UL == 8UL) {
#line 166
      goto case_8;
    } else {

    }
#line 166
    goto switch_default;
    case_1: /* CIL Label */ 
#line 166
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (*((unsigned long *)(& tfm->fault_bits) + i)): : "memory",
                         "cc");
#line 166
    goto ldv_36049;
    case_2: /* CIL Label */ 
#line 166
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (*((unsigned long *)(& tfm->fault_bits) + i)): : "memory",
                         "cc");
#line 166
    goto ldv_36049;
    case_4: /* CIL Label */ 
#line 166
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (*((unsigned long *)(& tfm->fault_bits) + i)): : "memory",
                         "cc");
#line 166
    goto ldv_36049;
    case_8: /* CIL Label */ 
#line 166
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (*((unsigned long *)(& tfm->fault_bits) + i)): : "memory",
                         "cc");
#line 166
    goto ldv_36049;
    switch_default: /* CIL Label */ 
    {
#line 166
    __xchg_wrong_size();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_36049: 
#line 166
    k = __ret;
  } else {

  }
#line 167
  imap->fault_bits[i] = k;
#line 168
  k = tfm->done_bits[i];
#line 169
  if (k != 0UL) {
#line 170
    __ret___0 = 0UL;
    {
#line 170
    if (8UL == 1UL) {
#line 170
      goto case_1___0;
    } else {

    }
#line 170
    if (8UL == 2UL) {
#line 170
      goto case_2___0;
    } else {

    }
#line 170
    if (8UL == 4UL) {
#line 170
      goto case_4___0;
    } else {

    }
#line 170
    if (8UL == 8UL) {
#line 170
      goto case_8___0;
    } else {

    }
#line 170
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 170
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (*((unsigned long *)(& tfm->done_bits) + i)): : "memory",
                         "cc");
#line 170
    goto ldv_36057;
    case_2___0: /* CIL Label */ 
#line 170
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (*((unsigned long *)(& tfm->done_bits) + i)): : "memory",
                         "cc");
#line 170
    goto ldv_36057;
    case_4___0: /* CIL Label */ 
#line 170
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (*((unsigned long *)(& tfm->done_bits) + i)): : "memory",
                         "cc");
#line 170
    goto ldv_36057;
    case_8___0: /* CIL Label */ 
#line 170
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (*((unsigned long *)(& tfm->done_bits) + i)): : "memory",
                         "cc");
#line 170
    goto ldv_36057;
    switch_default___0: /* CIL Label */ 
    {
#line 170
    __xchg_wrong_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_36057: 
#line 170
    k = __ret___0;
  } else {

  }
#line 171
  dmap->fault_bits[i] = k;
#line 163
  i = i + 1UL;
  ldv_36064: ;
#line 163
  if (i <= 1UL) {
#line 165
    goto ldv_36063;
  } else {

  }
  {
#line 178
  gru_flush_cache((void *)tfm);
  }
#line 179
  return;
}
}
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static int non_atomic_pte_lookup(struct vm_area_struct *vma , unsigned long vaddr ,
                                 int write , unsigned long *paddr , int *pageshift ) 
{ 
  struct page *page ;
  int tmp ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 197
  tmp = is_vm_hugetlb_page(vma);
#line 197
  *pageshift = tmp != 0 ? 21 : 12;
#line 201
  tmp___0 = get_current___1();
#line 201
  tmp___1 = get_current___1();
#line 201
  tmp___2 = get_user_pages(tmp___1, tmp___0->mm, vaddr, 1UL, write, 0, & page, (struct vm_area_struct **)0);
  }
#line 201
  if (tmp___2 <= 0L) {
#line 203
    return (-14);
  } else {

  }
  {
#line 204
  *paddr = (unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12);
#line 205
  put_page(page);
  }
#line 206
  return (0);
}
}
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static int atomic_pte_lookup(struct vm_area_struct *vma , unsigned long vaddr , int write ,
                             unsigned long *paddr , int *pageshift ) 
{ 
  pgd_t *pgdp ;
  pmd_t *pmdp ;
  pud_t *pudp ;
  pte_t pte ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  pte_t *tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned long tmp___17 ;
  int tmp___18 ;

  {
  {
#line 227
  pgdp = (vma->vm_mm)->pgd + ((vaddr >> 39) & 511UL);
#line 228
  tmp = pgd_none(*pgdp);
#line 228
  tmp___0 = __builtin_expect(tmp != 0, 0L);
  }
#line 228
  if (tmp___0 != 0L) {
#line 229
    goto err;
  } else {

  }
  {
#line 231
  pudp = pud_offset(pgdp, vaddr);
#line 232
  tmp___1 = pud_none(*pudp);
#line 232
  tmp___2 = __builtin_expect(tmp___1 != 0, 0L);
  }
#line 232
  if (tmp___2 != 0L) {
#line 233
    goto err;
  } else {

  }
  {
#line 235
  pmdp = pmd_offset(pudp, vaddr);
#line 236
  tmp___3 = pmd_none(*pmdp);
#line 236
  tmp___4 = __builtin_expect(tmp___3 != 0, 0L);
  }
#line 236
  if (tmp___4 != 0L) {
#line 237
    goto err;
  } else {

  }
  {
#line 239
  tmp___6 = pmd_large(*pmdp);
#line 239
  tmp___7 = __builtin_expect(tmp___6 != 0, 0L);
  }
#line 239
  if (tmp___7 != 0L) {
#line 240
    pte = *((pte_t *)pmdp);
  } else {
    {
#line 243
    tmp___5 = pte_offset_kernel(pmdp, vaddr);
#line 243
    pte = *tmp___5;
    }
  }
  {
#line 245
  tmp___8 = pte_present(pte);
#line 245
  tmp___9 = __builtin_expect(tmp___8 == 0, 0L);
  }
#line 245
  if (tmp___9 != 0L) {
#line 247
    return (1);
  } else {
    {
#line 245
    tmp___10 = __builtin_expect(write != 0, 0L);
    }
#line 245
    if (tmp___10 != 0L) {
      {
#line 245
      tmp___11 = pte_write(pte);
#line 245
      tmp___12 = __builtin_expect(tmp___11 == 0, 0L);
      }
#line 245
      if (tmp___12 != 0L) {
#line 245
        tmp___15 = 1;
      } else {
        {
#line 245
        tmp___13 = pte_dirty(pte);
#line 245
        tmp___14 = __builtin_expect(tmp___13 == 0, 0L);
        }
#line 245
        if (tmp___14 != 0L) {
#line 245
          tmp___15 = 1;
        } else {
#line 245
          tmp___15 = 0;
        }
      }
#line 245
      if (tmp___15 != 0) {
#line 245
        tmp___16 = 1;
      } else {
#line 245
        tmp___16 = 0;
      }
    } else {
#line 245
      tmp___16 = 0;
    }
#line 245
    if (tmp___16 != 0) {
#line 247
      return (1);
    } else {

    }
  }
  {
#line 249
  tmp___17 = pte_pfn(pte);
#line 249
  *paddr = tmp___17 << 12;
#line 251
  tmp___18 = is_vm_hugetlb_page(vma);
#line 251
  *pageshift = tmp___18 != 0 ? 21 : 12;
  }
#line 255
  return (0);
  err: ;
#line 258
  return (1);
}
}
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static int gru_vtop(struct gru_thread_state *gts , unsigned long vaddr , int write ,
                    int atomic , unsigned long *gpa , int *pageshift ) 
{ 
  struct mm_struct *mm ;
  struct vm_area_struct *vma ;
  unsigned long paddr ;
  int ret ;
  int ps ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 264
  mm = gts->ts_mm;
#line 269
  vma = find_vma(mm, vaddr);
  }
#line 270
  if ((unsigned long )vma == (unsigned long )((struct vm_area_struct *)0)) {
#line 271
    goto inval;
  } else {

  }
  {
#line 277
  __asm__  volatile   ("lfence": : : "memory");
#line 278
  ret = atomic_pte_lookup(vma, vaddr, write, & paddr, & ps);
  }
#line 279
  if (ret != 0) {
#line 280
    if (atomic != 0) {
#line 281
      goto upm;
    } else {

    }
    {
#line 282
    tmp = non_atomic_pte_lookup(vma, vaddr, write, & paddr, & ps);
    }
#line 282
    if (tmp != 0) {
#line 283
      goto inval;
    } else {

    }
  } else {

  }
  {
#line 285
  tmp___0 = is_gru_paddr(paddr);
  }
#line 285
  if (tmp___0 != 0) {
#line 286
    goto inval;
  } else {

  }
  {
#line 287
  paddr = paddr & - (1UL << ps);
#line 288
  *gpa = uv_soc_phys_ram_to_gpa(paddr);
#line 289
  *pageshift = ps;
  }
#line 290
  return (0);
  inval: ;
#line 293
  return (-1);
  upm: ;
#line 295
  return (-2);
}
}
#line 305 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static void gru_flush_cache_cbe(struct gru_control_block_extended *cbe ) 
{ 
  long tmp ;

  {
  {
#line 307
  tmp = __builtin_expect((unsigned long )cbe != (unsigned long )((struct gru_control_block_extended *)0),
                         0L);
  }
#line 307
  if (tmp != 0L) {
    {
#line 308
    cbe->cbrexecstatus = 0U;
#line 309
    gru_flush_cache((void *)cbe);
    }
  } else {

  }
#line 311
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static void gru_preload_tlb(struct gru_state *gru , struct gru_thread_state *gts ,
                            int atomic , unsigned long fault_vaddr , int asid , int write ,
                            unsigned char tlb_preload_count , struct gru_tlb_fault_handle *tfh ,
                            struct gru_control_block_extended *cbe ) 
{ 
  unsigned long vaddr ;
  unsigned long gpa ;
  int ret ;
  int pageshift ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 325
  vaddr = 0UL;
#line 328
  if ((unsigned int )cbe->opccpy != 1U) {
#line 329
    return;
  } else {

  }
#line 331
  if (fault_vaddr == cbe->idef1upd) {
#line 332
    vaddr = (fault_vaddr + cbe->idef6cpy * 64UL) - 1UL;
  } else
#line 333
  if (fault_vaddr == cbe->idef3upd) {
#line 334
    vaddr = (fault_vaddr + (unsigned long )(1 << (int )cbe->xtypecpy) * cbe->idef5upd) - 1UL;
  } else {

  }
#line 336
  fault_vaddr = fault_vaddr & 0xfffffffffffff000UL;
#line 337
  vaddr = vaddr & 0xfffffffffffff000UL;
#line 338
  _min1 = vaddr;
#line 338
  _min2 = fault_vaddr + (unsigned long )tlb_preload_count * 4096UL;
#line 338
  vaddr = _min1 < _min2 ? _min1 : _min2;
#line 340
  goto ldv_36165;
  ldv_36164: 
  {
#line 341
  ret = gru_vtop(gts, vaddr, write, atomic, & gpa, & pageshift);
  }
#line 342
  if (ret != 0) {
#line 344
    return;
  } else {
    {
#line 342
    tmp = tfh_write_only(tfh, gpa, 0, vaddr, asid, write, pageshift > 20 ? ((pageshift + 2) >> 1) + -6 : (pageshift >> 1) + -6);
    }
#line 342
    if (tmp != 0) {
#line 344
      return;
    } else {

    }
  }
#line 345
  if ((int )gru_options & 1) {
#line 345
    __vpp_verify = (void const   *)0;
    {
#line 345
    if (4UL == 1UL) {
#line 345
      goto case_1;
    } else {

    }
#line 348
    if (4UL == 2UL) {
#line 348
      goto case_2___0;
    } else {

    }
#line 348
    if (4UL == 4UL) {
#line 348
      goto case_4___1;
    } else {

    }
#line 348
    if (4UL == 8UL) {
#line 348
      goto case_8___2;
    } else {

    }
#line 348
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 348
    if (4UL == 1UL) {
#line 348
      goto case_1___0;
    } else {

    }
#line 348
    if (4UL == 2UL) {
#line 348
      goto case_2;
    } else {

    }
#line 348
    if (4UL == 4UL) {
#line 348
      goto case_4;
    } else {

    }
#line 348
    if (4UL == 8UL) {
#line 348
      goto case_8;
    } else {

    }
#line 348
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 348
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 348
    goto ldv_36127;
    case_2: /* CIL Label */ 
#line 348
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 348
    goto ldv_36127;
    case_4: /* CIL Label */ 
#line 348
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 348
    goto ldv_36127;
    case_8: /* CIL Label */ 
#line 348
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 348
    goto ldv_36127;
    switch_default: /* CIL Label */ 
    {
#line 348
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_36127: 
#line 348
    pscr_ret__ = pfo_ret__;
#line 348
    goto ldv_36133;
    case_2___0: /* CIL Label */ ;
    {
#line 348
    if (4UL == 1UL) {
#line 348
      goto case_1___1;
    } else {

    }
#line 348
    if (4UL == 2UL) {
#line 348
      goto case_2___1;
    } else {

    }
#line 348
    if (4UL == 4UL) {
#line 348
      goto case_4___0;
    } else {

    }
#line 348
    if (4UL == 8UL) {
#line 348
      goto case_8___0;
    } else {

    }
#line 348
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 348
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 348
    goto ldv_36137;
    case_2___1: /* CIL Label */ 
#line 348
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 348
    goto ldv_36137;
    case_4___0: /* CIL Label */ 
#line 348
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 348
    goto ldv_36137;
    case_8___0: /* CIL Label */ 
#line 348
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 348
    goto ldv_36137;
    switch_default___0: /* CIL Label */ 
    {
#line 348
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_36137: 
#line 348
    pscr_ret__ = pfo_ret_____0;
#line 348
    goto ldv_36133;
    case_4___1: /* CIL Label */ ;
    {
#line 348
    if (4UL == 1UL) {
#line 348
      goto case_1___2;
    } else {

    }
#line 348
    if (4UL == 2UL) {
#line 348
      goto case_2___2;
    } else {

    }
#line 348
    if (4UL == 4UL) {
#line 348
      goto case_4___2;
    } else {

    }
#line 348
    if (4UL == 8UL) {
#line 348
      goto case_8___1;
    } else {

    }
#line 348
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 348
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 348
    goto ldv_36146;
    case_2___2: /* CIL Label */ 
#line 348
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 348
    goto ldv_36146;
    case_4___2: /* CIL Label */ 
#line 348
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 348
    goto ldv_36146;
    case_8___1: /* CIL Label */ 
#line 348
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 348
    goto ldv_36146;
    switch_default___1: /* CIL Label */ 
    {
#line 348
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_36146: 
#line 348
    pscr_ret__ = pfo_ret_____1;
#line 348
    goto ldv_36133;
    case_8___2: /* CIL Label */ ;
    {
#line 348
    if (4UL == 1UL) {
#line 348
      goto case_1___3;
    } else {

    }
#line 348
    if (4UL == 2UL) {
#line 348
      goto case_2___3;
    } else {

    }
#line 348
    if (4UL == 4UL) {
#line 348
      goto case_4___3;
    } else {

    }
#line 348
    if (4UL == 8UL) {
#line 348
      goto case_8___3;
    } else {

    }
#line 348
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 348
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 348
    goto ldv_36155;
    case_2___3: /* CIL Label */ 
#line 348
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 348
    goto ldv_36155;
    case_4___3: /* CIL Label */ 
#line 348
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 348
    goto ldv_36155;
    case_8___3: /* CIL Label */ 
#line 348
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 348
    goto ldv_36155;
    switch_default___2: /* CIL Label */ 
    {
#line 348
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_36155: 
#line 348
    pscr_ret__ = pfo_ret_____2;
#line 348
    goto ldv_36133;
    switch_default___3: /* CIL Label */ 
    {
#line 348
    __bad_size_call_parameter();
    }
#line 348
    goto ldv_36133;
    switch_break: /* CIL Label */ ;
    }
    ldv_36133: 
    {
#line 348
    printk("\017GRU:%d %s: %s: gid %d, gts 0x%p, tfh 0x%p, vaddr 0x%lx, asid 0x%x, rw %d, ps %d, gpa 0x%lx\n",
           pscr_ret__, "gru_preload_tlb", atomic != 0 ? (char *)"atomic" : (char *)"non-atomic",
           (int )gru->gs_gid, gts, tfh, vaddr, asid, write, pageshift, gpa);
    }
  } else {

  }
#line 349
  vaddr = vaddr - 4096UL;
#line 350
  if ((gru_options & 2UL) != 0UL) {
    {
#line 350
    atomic_long_inc(& gru_stats.tlb_preload_page);
    }
  } else {

  }
  ldv_36165: ;
#line 340
  if (vaddr > fault_vaddr) {
#line 342
    goto ldv_36164;
  } else {

  }

#line 347
  return;
}
}
#line 364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static int gru_try_dropin(struct gru_state *gru , struct gru_thread_state *gts , struct gru_tlb_fault_handle *tfh ,
                          struct gru_instruction_bits *cbk ) 
{ 
  struct gru_control_block_extended *cbe ;
  unsigned char tlb_preload_count ;
  int pageshift ;
  int asid ;
  int write ;
  int ret ;
  int atomic ;
  int indexway ;
  unsigned long gpa ;
  unsigned long vaddr ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  int pscr_ret_____2 ;
  void const   *__vpp_verify___2 ;
  int pfo_ret_____11 ;
  int pfo_ret_____12 ;
  int pfo_ret_____13 ;
  int pfo_ret_____14 ;
  int pscr_ret_____3 ;
  void const   *__vpp_verify___3 ;
  int pfo_ret_____15 ;
  int pfo_ret_____16 ;
  int pfo_ret_____17 ;
  int pfo_ret_____18 ;
  int pscr_ret_____4 ;
  void const   *__vpp_verify___4 ;
  int pfo_ret_____19 ;
  int pfo_ret_____20 ;
  int pfo_ret_____21 ;
  int pfo_ret_____22 ;
  int pscr_ret_____5 ;
  void const   *__vpp_verify___5 ;
  int pfo_ret_____23 ;
  int pfo_ret_____24 ;
  int pfo_ret_____25 ;
  int pfo_ret_____26 ;
  int pscr_ret_____6 ;
  void const   *__vpp_verify___6 ;
  int pfo_ret_____27 ;
  int pfo_ret_____28 ;
  int pfo_ret_____29 ;
  int pfo_ret_____30 ;

  {
  {
#line 369
  cbe = (struct gru_control_block_extended *)0;
#line 370
  tlb_preload_count = gts->ts_tlb_preload_count;
#line 371
  pageshift = 0;
#line 371
  atomic = (unsigned long )cbk == (unsigned long )((struct gru_instruction_bits *)0);
#line 372
  gpa = 0UL;
#line 372
  vaddr = 0UL;
#line 384
  tmp = __builtin_expect((unsigned int )tlb_preload_count != 0U, 0L);
  }
#line 384
  if (tmp != 0L) {
    {
#line 385
    cbe = gru_tfh_to_cbe(tfh);
#line 386
    prefetchw((void const   *)cbe);
    }
  } else {

  }
#line 394
  if ((unsigned int )*((unsigned char *)tfh + 2UL) != 1U) {
    {
#line 395
    gru_flush_cache((void *)tfh);
#line 396
    sync_core();
    }
#line 397
    if ((unsigned int )*((unsigned char *)tfh + 2UL) != 1U) {
#line 398
      goto failnoexception;
    } else {

    }
#line 399
    if ((gru_options & 2UL) != 0UL) {
      {
#line 399
      atomic_long_inc(& gru_stats.tfh_stale_on_fault);
      }
    } else {

    }
  } else {

  }
#line 401
  if ((unsigned int )*((unsigned char *)tfh + 2UL) == 16U) {
#line 402
    goto failidle;
  } else {

  }
#line 403
  if ((unsigned int )*((unsigned char *)tfh + 2UL) == 48U && (unsigned long )cbk != (unsigned long )((struct gru_instruction_bits *)0)) {
#line 404
    goto failfmm;
  } else {

  }
#line 406
  write = ((int )tfh->cause & 2) != 0;
#line 407
  vaddr = tfh->missvaddr;
#line 408
  asid = (int )tfh->missasid;
#line 409
  indexway = (int )tfh->indexway;
#line 410
  if (asid == 0) {
#line 411
    goto failnoasid;
  } else {

  }
  {
#line 413
  __asm__  volatile   ("lfence": : : "memory");
#line 419
  tmp___0 = atomic_read((atomic_t const   *)(& (gts->ts_gms)->ms_range_active));
  }
#line 419
  if (tmp___0 != 0) {
#line 420
    goto failactive;
  } else {

  }
  {
#line 422
  ret = gru_vtop(gts, vaddr, write, atomic, & gpa, & pageshift);
  }
#line 423
  if (ret == -1) {
#line 424
    goto failinval;
  } else {

  }
#line 425
  if (ret == -2) {
#line 426
    goto failupm;
  } else {

  }
#line 428
  if (((unsigned long )gts->ts_sizeavail & (pageshift > 20 ? 1UL << (((pageshift + 2) >> 1) + -6) : 1UL << ((pageshift >> 1) + -6))) == 0UL) {
#line 429
    gts->ts_sizeavail = (int )gts->ts_sizeavail | (pageshift > 20 ? (unsigned short )(1UL << (((pageshift + 2) >> 1) + -6)) : (unsigned short )(1UL << ((pageshift >> 1) + -6)));
#line 430
    if (atomic != 0) {
#line 431
      gts->ts_force_cch_reload = 1;
#line 432
      goto failupm;
    } else {
      {
#line 430
      tmp___1 = gru_update_cch(gts);
      }
#line 430
      if (tmp___1 == 0) {
#line 431
        gts->ts_force_cch_reload = 1;
#line 432
        goto failupm;
      } else {

      }
    }
  } else {

  }
  {
#line 436
  tmp___2 = __builtin_expect((unsigned long )cbe != (unsigned long )((struct gru_control_block_extended *)0),
                             0L);
  }
#line 436
  if (tmp___2 != 0L && pageshift == 12) {
    {
#line 437
    gru_preload_tlb(gru, gts, atomic, vaddr, asid, write, (int )tlb_preload_count,
                    tfh, cbe);
#line 438
    gru_flush_cache_cbe(cbe);
    }
  } else {

  }
  {
#line 441
  gru_cb_set_istatus_active(cbk);
#line 442
  gts->ustats.tlbdropin = gts->ustats.tlbdropin + 1UL;
#line 443
  tfh_write_restart(tfh, gpa, 0, vaddr, asid, write, pageshift > 20 ? ((pageshift + 2) >> 1) + -6 : (pageshift >> 1) + -6);
  }
#line 445
  if ((int )gru_options & 1) {
#line 445
    __vpp_verify = (void const   *)0;
    {
#line 445
    if (4UL == 1UL) {
#line 445
      goto case_1;
    } else {

    }
#line 449
    if (4UL == 2UL) {
#line 449
      goto case_2___0;
    } else {

    }
#line 449
    if (4UL == 4UL) {
#line 449
      goto case_4___1;
    } else {

    }
#line 449
    if (4UL == 8UL) {
#line 449
      goto case_8___2;
    } else {

    }
#line 449
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 449
    if (4UL == 1UL) {
#line 449
      goto case_1___0;
    } else {

    }
#line 449
    if (4UL == 2UL) {
#line 449
      goto case_2;
    } else {

    }
#line 449
    if (4UL == 4UL) {
#line 449
      goto case_4;
    } else {

    }
#line 449
    if (4UL == 8UL) {
#line 449
      goto case_8;
    } else {

    }
#line 449
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 449
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 449
    goto ldv_36195;
    case_2: /* CIL Label */ 
#line 449
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 449
    goto ldv_36195;
    case_4: /* CIL Label */ 
#line 449
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 449
    goto ldv_36195;
    case_8: /* CIL Label */ 
#line 449
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 449
    goto ldv_36195;
    switch_default: /* CIL Label */ 
    {
#line 449
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_36195: 
#line 449
    pscr_ret__ = pfo_ret__;
#line 449
    goto ldv_36201;
    case_2___0: /* CIL Label */ ;
    {
#line 449
    if (4UL == 1UL) {
#line 449
      goto case_1___1;
    } else {

    }
#line 449
    if (4UL == 2UL) {
#line 449
      goto case_2___1;
    } else {

    }
#line 449
    if (4UL == 4UL) {
#line 449
      goto case_4___0;
    } else {

    }
#line 449
    if (4UL == 8UL) {
#line 449
      goto case_8___0;
    } else {

    }
#line 449
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 449
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 449
    goto ldv_36205;
    case_2___1: /* CIL Label */ 
#line 449
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 449
    goto ldv_36205;
    case_4___0: /* CIL Label */ 
#line 449
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 449
    goto ldv_36205;
    case_8___0: /* CIL Label */ 
#line 449
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 449
    goto ldv_36205;
    switch_default___0: /* CIL Label */ 
    {
#line 449
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_36205: 
#line 449
    pscr_ret__ = pfo_ret_____0;
#line 449
    goto ldv_36201;
    case_4___1: /* CIL Label */ ;
    {
#line 449
    if (4UL == 1UL) {
#line 449
      goto case_1___2;
    } else {

    }
#line 449
    if (4UL == 2UL) {
#line 449
      goto case_2___2;
    } else {

    }
#line 449
    if (4UL == 4UL) {
#line 449
      goto case_4___2;
    } else {

    }
#line 449
    if (4UL == 8UL) {
#line 449
      goto case_8___1;
    } else {

    }
#line 449
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 449
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 449
    goto ldv_36214;
    case_2___2: /* CIL Label */ 
#line 449
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 449
    goto ldv_36214;
    case_4___2: /* CIL Label */ 
#line 449
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 449
    goto ldv_36214;
    case_8___1: /* CIL Label */ 
#line 449
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 449
    goto ldv_36214;
    switch_default___1: /* CIL Label */ 
    {
#line 449
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_36214: 
#line 449
    pscr_ret__ = pfo_ret_____1;
#line 449
    goto ldv_36201;
    case_8___2: /* CIL Label */ ;
    {
#line 449
    if (4UL == 1UL) {
#line 449
      goto case_1___3;
    } else {

    }
#line 449
    if (4UL == 2UL) {
#line 449
      goto case_2___3;
    } else {

    }
#line 449
    if (4UL == 4UL) {
#line 449
      goto case_4___3;
    } else {

    }
#line 449
    if (4UL == 8UL) {
#line 449
      goto case_8___3;
    } else {

    }
#line 449
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 449
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 449
    goto ldv_36223;
    case_2___3: /* CIL Label */ 
#line 449
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 449
    goto ldv_36223;
    case_4___3: /* CIL Label */ 
#line 449
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 449
    goto ldv_36223;
    case_8___3: /* CIL Label */ 
#line 449
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 449
    goto ldv_36223;
    switch_default___2: /* CIL Label */ 
    {
#line 449
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_36223: 
#line 449
    pscr_ret__ = pfo_ret_____2;
#line 449
    goto ldv_36201;
    switch_default___3: /* CIL Label */ 
    {
#line 449
    __bad_size_call_parameter();
    }
#line 449
    goto ldv_36201;
    switch_break: /* CIL Label */ ;
    }
    ldv_36201: 
    {
#line 449
    printk("\017GRU:%d %s: %s: gid %d, gts 0x%p, tfh 0x%p, vaddr 0x%lx, asid 0x%x, indexway 0x%x, rw %d, ps %d, gpa 0x%lx\n",
           pscr_ret__, "gru_try_dropin", atomic != 0 ? (char *)"atomic" : (char *)"non-atomic",
           (int )gru->gs_gid, gts, tfh, vaddr, asid, indexway, write, pageshift, gpa);
    }
  } else {

  }
#line 450
  if ((gru_options & 2UL) != 0UL) {
    {
#line 450
    atomic_long_inc(& gru_stats.tlb_dropin);
    }
  } else {

  }
#line 451
  return (0);
  failnoasid: ;
#line 455
  if ((gru_options & 2UL) != 0UL) {
    {
#line 455
    atomic_long_inc(& gru_stats.tlb_dropin_fail_no_asid);
    }
  } else {

  }
#line 456
  if ((int )gru_options & 1) {
#line 456
    __vpp_verify___0 = (void const   *)0;
    {
#line 456
    if (4UL == 1UL) {
#line 456
      goto case_1___4;
    } else {

    }
#line 456
    if (4UL == 2UL) {
#line 456
      goto case_2___5;
    } else {

    }
#line 456
    if (4UL == 4UL) {
#line 456
      goto case_4___6;
    } else {

    }
#line 456
    if (4UL == 8UL) {
#line 456
      goto case_8___7;
    } else {

    }
#line 456
    goto switch_default___8;
    case_1___4: /* CIL Label */ ;
    {
#line 456
    if (4UL == 1UL) {
#line 456
      goto case_1___5;
    } else {

    }
#line 456
    if (4UL == 2UL) {
#line 456
      goto case_2___4;
    } else {

    }
#line 456
    if (4UL == 4UL) {
#line 456
      goto case_4___4;
    } else {

    }
#line 456
    if (4UL == 8UL) {
#line 456
      goto case_8___4;
    } else {

    }
#line 456
    goto switch_default___4;
    case_1___5: /* CIL Label */ 
#line 456
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 456
    goto ldv_36237;
    case_2___4: /* CIL Label */ 
#line 456
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 456
    goto ldv_36237;
    case_4___4: /* CIL Label */ 
#line 456
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 456
    goto ldv_36237;
    case_8___4: /* CIL Label */ 
#line 456
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 456
    goto ldv_36237;
    switch_default___4: /* CIL Label */ 
    {
#line 456
    __bad_percpu_size();
    }
    switch_break___5: /* CIL Label */ ;
    }
    ldv_36237: 
#line 456
    pscr_ret_____0 = pfo_ret_____3;
#line 456
    goto ldv_36243;
    case_2___5: /* CIL Label */ ;
    {
#line 456
    if (4UL == 1UL) {
#line 456
      goto case_1___6;
    } else {

    }
#line 456
    if (4UL == 2UL) {
#line 456
      goto case_2___6;
    } else {

    }
#line 456
    if (4UL == 4UL) {
#line 456
      goto case_4___5;
    } else {

    }
#line 456
    if (4UL == 8UL) {
#line 456
      goto case_8___5;
    } else {

    }
#line 456
    goto switch_default___5;
    case_1___6: /* CIL Label */ 
#line 456
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 456
    goto ldv_36247;
    case_2___6: /* CIL Label */ 
#line 456
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 456
    goto ldv_36247;
    case_4___5: /* CIL Label */ 
#line 456
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 456
    goto ldv_36247;
    case_8___5: /* CIL Label */ 
#line 456
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 456
    goto ldv_36247;
    switch_default___5: /* CIL Label */ 
    {
#line 456
    __bad_percpu_size();
    }
    switch_break___6: /* CIL Label */ ;
    }
    ldv_36247: 
#line 456
    pscr_ret_____0 = pfo_ret_____4;
#line 456
    goto ldv_36243;
    case_4___6: /* CIL Label */ ;
    {
#line 456
    if (4UL == 1UL) {
#line 456
      goto case_1___7;
    } else {

    }
#line 456
    if (4UL == 2UL) {
#line 456
      goto case_2___7;
    } else {

    }
#line 456
    if (4UL == 4UL) {
#line 456
      goto case_4___7;
    } else {

    }
#line 456
    if (4UL == 8UL) {
#line 456
      goto case_8___6;
    } else {

    }
#line 456
    goto switch_default___6;
    case_1___7: /* CIL Label */ 
#line 456
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 456
    goto ldv_36256;
    case_2___7: /* CIL Label */ 
#line 456
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 456
    goto ldv_36256;
    case_4___7: /* CIL Label */ 
#line 456
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 456
    goto ldv_36256;
    case_8___6: /* CIL Label */ 
#line 456
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 456
    goto ldv_36256;
    switch_default___6: /* CIL Label */ 
    {
#line 456
    __bad_percpu_size();
    }
    switch_break___7: /* CIL Label */ ;
    }
    ldv_36256: 
#line 456
    pscr_ret_____0 = pfo_ret_____5;
#line 456
    goto ldv_36243;
    case_8___7: /* CIL Label */ ;
    {
#line 456
    if (4UL == 1UL) {
#line 456
      goto case_1___8;
    } else {

    }
#line 456
    if (4UL == 2UL) {
#line 456
      goto case_2___8;
    } else {

    }
#line 456
    if (4UL == 4UL) {
#line 456
      goto case_4___8;
    } else {

    }
#line 456
    if (4UL == 8UL) {
#line 456
      goto case_8___8;
    } else {

    }
#line 456
    goto switch_default___7;
    case_1___8: /* CIL Label */ 
#line 456
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 456
    goto ldv_36265;
    case_2___8: /* CIL Label */ 
#line 456
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 456
    goto ldv_36265;
    case_4___8: /* CIL Label */ 
#line 456
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 456
    goto ldv_36265;
    case_8___8: /* CIL Label */ 
#line 456
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 456
    goto ldv_36265;
    switch_default___7: /* CIL Label */ 
    {
#line 456
    __bad_percpu_size();
    }
    switch_break___8: /* CIL Label */ ;
    }
    ldv_36265: 
#line 456
    pscr_ret_____0 = pfo_ret_____6;
#line 456
    goto ldv_36243;
    switch_default___8: /* CIL Label */ 
    {
#line 456
    __bad_size_call_parameter();
    }
#line 456
    goto ldv_36243;
    switch_break___4: /* CIL Label */ ;
    }
    ldv_36243: 
    {
#line 456
    printk("\017GRU:%d %s: FAILED no_asid tfh: 0x%p, vaddr 0x%lx\n", pscr_ret_____0,
           "gru_try_dropin", tfh, vaddr);
    }
  } else {

  }
#line 457
  if ((unsigned long )cbk == (unsigned long )((struct gru_instruction_bits *)0)) {
    {
#line 458
    tfh_user_polling_mode(tfh);
    }
  } else {
    {
#line 460
    gru_flush_cache((void *)tfh);
    }
  }
  {
#line 461
  gru_flush_cache_cbe(cbe);
  }
#line 462
  return (-11);
  failupm: 
  {
#line 466
  tfh_user_polling_mode(tfh);
#line 467
  gru_flush_cache_cbe(cbe);
  }
#line 468
  if ((gru_options & 2UL) != 0UL) {
    {
#line 468
    atomic_long_inc(& gru_stats.tlb_dropin_fail_upm);
    }
  } else {

  }
#line 469
  if ((int )gru_options & 1) {
#line 469
    __vpp_verify___1 = (void const   *)0;
    {
#line 469
    if (4UL == 1UL) {
#line 469
      goto case_1___9;
    } else {

    }
#line 469
    if (4UL == 2UL) {
#line 469
      goto case_2___10;
    } else {

    }
#line 469
    if (4UL == 4UL) {
#line 469
      goto case_4___11;
    } else {

    }
#line 469
    if (4UL == 8UL) {
#line 469
      goto case_8___12;
    } else {

    }
#line 469
    goto switch_default___13;
    case_1___9: /* CIL Label */ ;
    {
#line 469
    if (4UL == 1UL) {
#line 469
      goto case_1___10;
    } else {

    }
#line 469
    if (4UL == 2UL) {
#line 469
      goto case_2___9;
    } else {

    }
#line 469
    if (4UL == 4UL) {
#line 469
      goto case_4___9;
    } else {

    }
#line 469
    if (4UL == 8UL) {
#line 469
      goto case_8___9;
    } else {

    }
#line 469
    goto switch_default___9;
    case_1___10: /* CIL Label */ 
#line 469
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 469
    goto ldv_36278;
    case_2___9: /* CIL Label */ 
#line 469
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 469
    goto ldv_36278;
    case_4___9: /* CIL Label */ 
#line 469
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 469
    goto ldv_36278;
    case_8___9: /* CIL Label */ 
#line 469
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 469
    goto ldv_36278;
    switch_default___9: /* CIL Label */ 
    {
#line 469
    __bad_percpu_size();
    }
    switch_break___10: /* CIL Label */ ;
    }
    ldv_36278: 
#line 469
    pscr_ret_____1 = pfo_ret_____7;
#line 469
    goto ldv_36284;
    case_2___10: /* CIL Label */ ;
    {
#line 469
    if (4UL == 1UL) {
#line 469
      goto case_1___11;
    } else {

    }
#line 469
    if (4UL == 2UL) {
#line 469
      goto case_2___11;
    } else {

    }
#line 469
    if (4UL == 4UL) {
#line 469
      goto case_4___10;
    } else {

    }
#line 469
    if (4UL == 8UL) {
#line 469
      goto case_8___10;
    } else {

    }
#line 469
    goto switch_default___10;
    case_1___11: /* CIL Label */ 
#line 469
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 469
    goto ldv_36288;
    case_2___11: /* CIL Label */ 
#line 469
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 469
    goto ldv_36288;
    case_4___10: /* CIL Label */ 
#line 469
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 469
    goto ldv_36288;
    case_8___10: /* CIL Label */ 
#line 469
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 469
    goto ldv_36288;
    switch_default___10: /* CIL Label */ 
    {
#line 469
    __bad_percpu_size();
    }
    switch_break___11: /* CIL Label */ ;
    }
    ldv_36288: 
#line 469
    pscr_ret_____1 = pfo_ret_____8;
#line 469
    goto ldv_36284;
    case_4___11: /* CIL Label */ ;
    {
#line 469
    if (4UL == 1UL) {
#line 469
      goto case_1___12;
    } else {

    }
#line 469
    if (4UL == 2UL) {
#line 469
      goto case_2___12;
    } else {

    }
#line 469
    if (4UL == 4UL) {
#line 469
      goto case_4___12;
    } else {

    }
#line 469
    if (4UL == 8UL) {
#line 469
      goto case_8___11;
    } else {

    }
#line 469
    goto switch_default___11;
    case_1___12: /* CIL Label */ 
#line 469
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 469
    goto ldv_36297;
    case_2___12: /* CIL Label */ 
#line 469
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 469
    goto ldv_36297;
    case_4___12: /* CIL Label */ 
#line 469
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 469
    goto ldv_36297;
    case_8___11: /* CIL Label */ 
#line 469
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 469
    goto ldv_36297;
    switch_default___11: /* CIL Label */ 
    {
#line 469
    __bad_percpu_size();
    }
    switch_break___12: /* CIL Label */ ;
    }
    ldv_36297: 
#line 469
    pscr_ret_____1 = pfo_ret_____9;
#line 469
    goto ldv_36284;
    case_8___12: /* CIL Label */ ;
    {
#line 469
    if (4UL == 1UL) {
#line 469
      goto case_1___13;
    } else {

    }
#line 469
    if (4UL == 2UL) {
#line 469
      goto case_2___13;
    } else {

    }
#line 469
    if (4UL == 4UL) {
#line 469
      goto case_4___13;
    } else {

    }
#line 469
    if (4UL == 8UL) {
#line 469
      goto case_8___13;
    } else {

    }
#line 469
    goto switch_default___12;
    case_1___13: /* CIL Label */ 
#line 469
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 469
    goto ldv_36306;
    case_2___13: /* CIL Label */ 
#line 469
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 469
    goto ldv_36306;
    case_4___13: /* CIL Label */ 
#line 469
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 469
    goto ldv_36306;
    case_8___13: /* CIL Label */ 
#line 469
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 469
    goto ldv_36306;
    switch_default___12: /* CIL Label */ 
    {
#line 469
    __bad_percpu_size();
    }
    switch_break___13: /* CIL Label */ ;
    }
    ldv_36306: 
#line 469
    pscr_ret_____1 = pfo_ret_____10;
#line 469
    goto ldv_36284;
    switch_default___13: /* CIL Label */ 
    {
#line 469
    __bad_size_call_parameter();
    }
#line 469
    goto ldv_36284;
    switch_break___9: /* CIL Label */ ;
    }
    ldv_36284: 
    {
#line 469
    printk("\017GRU:%d %s: FAILED upm tfh: 0x%p, vaddr 0x%lx\n", pscr_ret_____1, "gru_try_dropin",
           tfh, vaddr);
    }
  } else {

  }
#line 470
  return (1);
  failfmm: 
  {
#line 474
  gru_flush_cache((void *)tfh);
#line 475
  gru_flush_cache_cbe(cbe);
  }
#line 476
  if ((gru_options & 2UL) != 0UL) {
    {
#line 476
    atomic_long_inc(& gru_stats.tlb_dropin_fail_fmm);
    }
  } else {

  }
#line 477
  if ((int )gru_options & 1) {
#line 477
    __vpp_verify___2 = (void const   *)0;
    {
#line 477
    if (4UL == 1UL) {
#line 477
      goto case_1___14;
    } else {

    }
#line 477
    if (4UL == 2UL) {
#line 477
      goto case_2___15;
    } else {

    }
#line 477
    if (4UL == 4UL) {
#line 477
      goto case_4___16;
    } else {

    }
#line 477
    if (4UL == 8UL) {
#line 477
      goto case_8___17;
    } else {

    }
#line 477
    goto switch_default___18;
    case_1___14: /* CIL Label */ ;
    {
#line 477
    if (4UL == 1UL) {
#line 477
      goto case_1___15;
    } else {

    }
#line 477
    if (4UL == 2UL) {
#line 477
      goto case_2___14;
    } else {

    }
#line 477
    if (4UL == 4UL) {
#line 477
      goto case_4___14;
    } else {

    }
#line 477
    if (4UL == 8UL) {
#line 477
      goto case_8___14;
    } else {

    }
#line 477
    goto switch_default___14;
    case_1___15: /* CIL Label */ 
#line 477
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____11): "m" (cpu_number));
#line 477
    goto ldv_36319;
    case_2___14: /* CIL Label */ 
#line 477
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 477
    goto ldv_36319;
    case_4___14: /* CIL Label */ 
#line 477
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 477
    goto ldv_36319;
    case_8___14: /* CIL Label */ 
#line 477
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 477
    goto ldv_36319;
    switch_default___14: /* CIL Label */ 
    {
#line 477
    __bad_percpu_size();
    }
    switch_break___15: /* CIL Label */ ;
    }
    ldv_36319: 
#line 477
    pscr_ret_____2 = pfo_ret_____11;
#line 477
    goto ldv_36325;
    case_2___15: /* CIL Label */ ;
    {
#line 477
    if (4UL == 1UL) {
#line 477
      goto case_1___16;
    } else {

    }
#line 477
    if (4UL == 2UL) {
#line 477
      goto case_2___16;
    } else {

    }
#line 477
    if (4UL == 4UL) {
#line 477
      goto case_4___15;
    } else {

    }
#line 477
    if (4UL == 8UL) {
#line 477
      goto case_8___15;
    } else {

    }
#line 477
    goto switch_default___15;
    case_1___16: /* CIL Label */ 
#line 477
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____12): "m" (cpu_number));
#line 477
    goto ldv_36329;
    case_2___16: /* CIL Label */ 
#line 477
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 477
    goto ldv_36329;
    case_4___15: /* CIL Label */ 
#line 477
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 477
    goto ldv_36329;
    case_8___15: /* CIL Label */ 
#line 477
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 477
    goto ldv_36329;
    switch_default___15: /* CIL Label */ 
    {
#line 477
    __bad_percpu_size();
    }
    switch_break___16: /* CIL Label */ ;
    }
    ldv_36329: 
#line 477
    pscr_ret_____2 = pfo_ret_____12;
#line 477
    goto ldv_36325;
    case_4___16: /* CIL Label */ ;
    {
#line 477
    if (4UL == 1UL) {
#line 477
      goto case_1___17;
    } else {

    }
#line 477
    if (4UL == 2UL) {
#line 477
      goto case_2___17;
    } else {

    }
#line 477
    if (4UL == 4UL) {
#line 477
      goto case_4___17;
    } else {

    }
#line 477
    if (4UL == 8UL) {
#line 477
      goto case_8___16;
    } else {

    }
#line 477
    goto switch_default___16;
    case_1___17: /* CIL Label */ 
#line 477
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____13): "m" (cpu_number));
#line 477
    goto ldv_36338;
    case_2___17: /* CIL Label */ 
#line 477
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 477
    goto ldv_36338;
    case_4___17: /* CIL Label */ 
#line 477
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 477
    goto ldv_36338;
    case_8___16: /* CIL Label */ 
#line 477
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 477
    goto ldv_36338;
    switch_default___16: /* CIL Label */ 
    {
#line 477
    __bad_percpu_size();
    }
    switch_break___17: /* CIL Label */ ;
    }
    ldv_36338: 
#line 477
    pscr_ret_____2 = pfo_ret_____13;
#line 477
    goto ldv_36325;
    case_8___17: /* CIL Label */ ;
    {
#line 477
    if (4UL == 1UL) {
#line 477
      goto case_1___18;
    } else {

    }
#line 477
    if (4UL == 2UL) {
#line 477
      goto case_2___18;
    } else {

    }
#line 477
    if (4UL == 4UL) {
#line 477
      goto case_4___18;
    } else {

    }
#line 477
    if (4UL == 8UL) {
#line 477
      goto case_8___18;
    } else {

    }
#line 477
    goto switch_default___17;
    case_1___18: /* CIL Label */ 
#line 477
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____14): "m" (cpu_number));
#line 477
    goto ldv_36347;
    case_2___18: /* CIL Label */ 
#line 477
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 477
    goto ldv_36347;
    case_4___18: /* CIL Label */ 
#line 477
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 477
    goto ldv_36347;
    case_8___18: /* CIL Label */ 
#line 477
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 477
    goto ldv_36347;
    switch_default___17: /* CIL Label */ 
    {
#line 477
    __bad_percpu_size();
    }
    switch_break___18: /* CIL Label */ ;
    }
    ldv_36347: 
#line 477
    pscr_ret_____2 = pfo_ret_____14;
#line 477
    goto ldv_36325;
    switch_default___18: /* CIL Label */ 
    {
#line 477
    __bad_size_call_parameter();
    }
#line 477
    goto ldv_36325;
    switch_break___14: /* CIL Label */ ;
    }
    ldv_36325: 
    {
#line 477
    printk("\017GRU:%d %s: FAILED fmm tfh: 0x%p, state %d\n", pscr_ret_____2, "gru_try_dropin",
           tfh, (int )tfh->state);
    }
  } else {

  }
#line 478
  return (0);
  failnoexception: 
  {
#line 482
  gru_flush_cache((void *)tfh);
#line 483
  gru_flush_cache_cbe(cbe);
  }
#line 484
  if ((unsigned long )cbk != (unsigned long )((struct gru_instruction_bits *)0)) {
    {
#line 485
    gru_flush_cache((void *)cbk);
    }
  } else {

  }
#line 486
  if ((gru_options & 2UL) != 0UL) {
    {
#line 486
    atomic_long_inc(& gru_stats.tlb_dropin_fail_no_exception);
    }
  } else {

  }
#line 487
  if ((int )gru_options & 1) {
#line 487
    __vpp_verify___3 = (void const   *)0;
    {
#line 487
    if (4UL == 1UL) {
#line 487
      goto case_1___19;
    } else {

    }
#line 488
    if (4UL == 2UL) {
#line 488
      goto case_2___20;
    } else {

    }
#line 488
    if (4UL == 4UL) {
#line 488
      goto case_4___21;
    } else {

    }
#line 488
    if (4UL == 8UL) {
#line 488
      goto case_8___22;
    } else {

    }
#line 488
    goto switch_default___23;
    case_1___19: /* CIL Label */ ;
    {
#line 488
    if (4UL == 1UL) {
#line 488
      goto case_1___20;
    } else {

    }
#line 488
    if (4UL == 2UL) {
#line 488
      goto case_2___19;
    } else {

    }
#line 488
    if (4UL == 4UL) {
#line 488
      goto case_4___19;
    } else {

    }
#line 488
    if (4UL == 8UL) {
#line 488
      goto case_8___19;
    } else {

    }
#line 488
    goto switch_default___19;
    case_1___20: /* CIL Label */ 
#line 488
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____15): "m" (cpu_number));
#line 488
    goto ldv_36360;
    case_2___19: /* CIL Label */ 
#line 488
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____15): "m" (cpu_number));
#line 488
    goto ldv_36360;
    case_4___19: /* CIL Label */ 
#line 488
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____15): "m" (cpu_number));
#line 488
    goto ldv_36360;
    case_8___19: /* CIL Label */ 
#line 488
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____15): "m" (cpu_number));
#line 488
    goto ldv_36360;
    switch_default___19: /* CIL Label */ 
    {
#line 488
    __bad_percpu_size();
    }
    switch_break___20: /* CIL Label */ ;
    }
    ldv_36360: 
#line 488
    pscr_ret_____3 = pfo_ret_____15;
#line 488
    goto ldv_36366;
    case_2___20: /* CIL Label */ ;
    {
#line 488
    if (4UL == 1UL) {
#line 488
      goto case_1___21;
    } else {

    }
#line 488
    if (4UL == 2UL) {
#line 488
      goto case_2___21;
    } else {

    }
#line 488
    if (4UL == 4UL) {
#line 488
      goto case_4___20;
    } else {

    }
#line 488
    if (4UL == 8UL) {
#line 488
      goto case_8___20;
    } else {

    }
#line 488
    goto switch_default___20;
    case_1___21: /* CIL Label */ 
#line 488
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____16): "m" (cpu_number));
#line 488
    goto ldv_36370;
    case_2___21: /* CIL Label */ 
#line 488
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____16): "m" (cpu_number));
#line 488
    goto ldv_36370;
    case_4___20: /* CIL Label */ 
#line 488
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____16): "m" (cpu_number));
#line 488
    goto ldv_36370;
    case_8___20: /* CIL Label */ 
#line 488
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____16): "m" (cpu_number));
#line 488
    goto ldv_36370;
    switch_default___20: /* CIL Label */ 
    {
#line 488
    __bad_percpu_size();
    }
    switch_break___21: /* CIL Label */ ;
    }
    ldv_36370: 
#line 488
    pscr_ret_____3 = pfo_ret_____16;
#line 488
    goto ldv_36366;
    case_4___21: /* CIL Label */ ;
    {
#line 488
    if (4UL == 1UL) {
#line 488
      goto case_1___22;
    } else {

    }
#line 488
    if (4UL == 2UL) {
#line 488
      goto case_2___22;
    } else {

    }
#line 488
    if (4UL == 4UL) {
#line 488
      goto case_4___22;
    } else {

    }
#line 488
    if (4UL == 8UL) {
#line 488
      goto case_8___21;
    } else {

    }
#line 488
    goto switch_default___21;
    case_1___22: /* CIL Label */ 
#line 488
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____17): "m" (cpu_number));
#line 488
    goto ldv_36379;
    case_2___22: /* CIL Label */ 
#line 488
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____17): "m" (cpu_number));
#line 488
    goto ldv_36379;
    case_4___22: /* CIL Label */ 
#line 488
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____17): "m" (cpu_number));
#line 488
    goto ldv_36379;
    case_8___21: /* CIL Label */ 
#line 488
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____17): "m" (cpu_number));
#line 488
    goto ldv_36379;
    switch_default___21: /* CIL Label */ 
    {
#line 488
    __bad_percpu_size();
    }
    switch_break___22: /* CIL Label */ ;
    }
    ldv_36379: 
#line 488
    pscr_ret_____3 = pfo_ret_____17;
#line 488
    goto ldv_36366;
    case_8___22: /* CIL Label */ ;
    {
#line 488
    if (4UL == 1UL) {
#line 488
      goto case_1___23;
    } else {

    }
#line 488
    if (4UL == 2UL) {
#line 488
      goto case_2___23;
    } else {

    }
#line 488
    if (4UL == 4UL) {
#line 488
      goto case_4___23;
    } else {

    }
#line 488
    if (4UL == 8UL) {
#line 488
      goto case_8___23;
    } else {

    }
#line 488
    goto switch_default___22;
    case_1___23: /* CIL Label */ 
#line 488
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____18): "m" (cpu_number));
#line 488
    goto ldv_36388;
    case_2___23: /* CIL Label */ 
#line 488
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____18): "m" (cpu_number));
#line 488
    goto ldv_36388;
    case_4___23: /* CIL Label */ 
#line 488
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____18): "m" (cpu_number));
#line 488
    goto ldv_36388;
    case_8___23: /* CIL Label */ 
#line 488
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____18): "m" (cpu_number));
#line 488
    goto ldv_36388;
    switch_default___22: /* CIL Label */ 
    {
#line 488
    __bad_percpu_size();
    }
    switch_break___23: /* CIL Label */ ;
    }
    ldv_36388: 
#line 488
    pscr_ret_____3 = pfo_ret_____18;
#line 488
    goto ldv_36366;
    switch_default___23: /* CIL Label */ 
    {
#line 488
    __bad_size_call_parameter();
    }
#line 488
    goto ldv_36366;
    switch_break___19: /* CIL Label */ ;
    }
    ldv_36366: 
    {
#line 488
    printk("\017GRU:%d %s: FAILED non-exception tfh: 0x%p, status %d, state %d\n",
           pscr_ret_____3, "gru_try_dropin", tfh, (int )tfh->status, (int )tfh->state);
    }
  } else {

  }
#line 489
  return (0);
  failidle: 
  {
#line 493
  gru_flush_cache((void *)tfh);
#line 494
  gru_flush_cache_cbe(cbe);
  }
#line 495
  if ((unsigned long )cbk != (unsigned long )((struct gru_instruction_bits *)0)) {
    {
#line 496
    gru_flush_cache((void *)cbk);
    }
  } else {

  }
#line 497
  if ((gru_options & 2UL) != 0UL) {
    {
#line 497
    atomic_long_inc(& gru_stats.tlb_dropin_fail_idle);
    }
  } else {

  }
#line 498
  if ((int )gru_options & 1) {
#line 498
    __vpp_verify___4 = (void const   *)0;
    {
#line 498
    if (4UL == 1UL) {
#line 498
      goto case_1___24;
    } else {

    }
#line 498
    if (4UL == 2UL) {
#line 498
      goto case_2___25;
    } else {

    }
#line 498
    if (4UL == 4UL) {
#line 498
      goto case_4___26;
    } else {

    }
#line 498
    if (4UL == 8UL) {
#line 498
      goto case_8___27;
    } else {

    }
#line 498
    goto switch_default___28;
    case_1___24: /* CIL Label */ ;
    {
#line 498
    if (4UL == 1UL) {
#line 498
      goto case_1___25;
    } else {

    }
#line 498
    if (4UL == 2UL) {
#line 498
      goto case_2___24;
    } else {

    }
#line 498
    if (4UL == 4UL) {
#line 498
      goto case_4___24;
    } else {

    }
#line 498
    if (4UL == 8UL) {
#line 498
      goto case_8___24;
    } else {

    }
#line 498
    goto switch_default___24;
    case_1___25: /* CIL Label */ 
#line 498
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____19): "m" (cpu_number));
#line 498
    goto ldv_36401;
    case_2___24: /* CIL Label */ 
#line 498
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____19): "m" (cpu_number));
#line 498
    goto ldv_36401;
    case_4___24: /* CIL Label */ 
#line 498
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____19): "m" (cpu_number));
#line 498
    goto ldv_36401;
    case_8___24: /* CIL Label */ 
#line 498
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____19): "m" (cpu_number));
#line 498
    goto ldv_36401;
    switch_default___24: /* CIL Label */ 
    {
#line 498
    __bad_percpu_size();
    }
    switch_break___25: /* CIL Label */ ;
    }
    ldv_36401: 
#line 498
    pscr_ret_____4 = pfo_ret_____19;
#line 498
    goto ldv_36407;
    case_2___25: /* CIL Label */ ;
    {
#line 498
    if (4UL == 1UL) {
#line 498
      goto case_1___26;
    } else {

    }
#line 498
    if (4UL == 2UL) {
#line 498
      goto case_2___26;
    } else {

    }
#line 498
    if (4UL == 4UL) {
#line 498
      goto case_4___25;
    } else {

    }
#line 498
    if (4UL == 8UL) {
#line 498
      goto case_8___25;
    } else {

    }
#line 498
    goto switch_default___25;
    case_1___26: /* CIL Label */ 
#line 498
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____20): "m" (cpu_number));
#line 498
    goto ldv_36411;
    case_2___26: /* CIL Label */ 
#line 498
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____20): "m" (cpu_number));
#line 498
    goto ldv_36411;
    case_4___25: /* CIL Label */ 
#line 498
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____20): "m" (cpu_number));
#line 498
    goto ldv_36411;
    case_8___25: /* CIL Label */ 
#line 498
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____20): "m" (cpu_number));
#line 498
    goto ldv_36411;
    switch_default___25: /* CIL Label */ 
    {
#line 498
    __bad_percpu_size();
    }
    switch_break___26: /* CIL Label */ ;
    }
    ldv_36411: 
#line 498
    pscr_ret_____4 = pfo_ret_____20;
#line 498
    goto ldv_36407;
    case_4___26: /* CIL Label */ ;
    {
#line 498
    if (4UL == 1UL) {
#line 498
      goto case_1___27;
    } else {

    }
#line 498
    if (4UL == 2UL) {
#line 498
      goto case_2___27;
    } else {

    }
#line 498
    if (4UL == 4UL) {
#line 498
      goto case_4___27;
    } else {

    }
#line 498
    if (4UL == 8UL) {
#line 498
      goto case_8___26;
    } else {

    }
#line 498
    goto switch_default___26;
    case_1___27: /* CIL Label */ 
#line 498
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____21): "m" (cpu_number));
#line 498
    goto ldv_36420;
    case_2___27: /* CIL Label */ 
#line 498
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____21): "m" (cpu_number));
#line 498
    goto ldv_36420;
    case_4___27: /* CIL Label */ 
#line 498
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____21): "m" (cpu_number));
#line 498
    goto ldv_36420;
    case_8___26: /* CIL Label */ 
#line 498
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____21): "m" (cpu_number));
#line 498
    goto ldv_36420;
    switch_default___26: /* CIL Label */ 
    {
#line 498
    __bad_percpu_size();
    }
    switch_break___27: /* CIL Label */ ;
    }
    ldv_36420: 
#line 498
    pscr_ret_____4 = pfo_ret_____21;
#line 498
    goto ldv_36407;
    case_8___27: /* CIL Label */ ;
    {
#line 498
    if (4UL == 1UL) {
#line 498
      goto case_1___28;
    } else {

    }
#line 498
    if (4UL == 2UL) {
#line 498
      goto case_2___28;
    } else {

    }
#line 498
    if (4UL == 4UL) {
#line 498
      goto case_4___28;
    } else {

    }
#line 498
    if (4UL == 8UL) {
#line 498
      goto case_8___28;
    } else {

    }
#line 498
    goto switch_default___27;
    case_1___28: /* CIL Label */ 
#line 498
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____22): "m" (cpu_number));
#line 498
    goto ldv_36429;
    case_2___28: /* CIL Label */ 
#line 498
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____22): "m" (cpu_number));
#line 498
    goto ldv_36429;
    case_4___28: /* CIL Label */ 
#line 498
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____22): "m" (cpu_number));
#line 498
    goto ldv_36429;
    case_8___28: /* CIL Label */ 
#line 498
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____22): "m" (cpu_number));
#line 498
    goto ldv_36429;
    switch_default___27: /* CIL Label */ 
    {
#line 498
    __bad_percpu_size();
    }
    switch_break___28: /* CIL Label */ ;
    }
    ldv_36429: 
#line 498
    pscr_ret_____4 = pfo_ret_____22;
#line 498
    goto ldv_36407;
    switch_default___28: /* CIL Label */ 
    {
#line 498
    __bad_size_call_parameter();
    }
#line 498
    goto ldv_36407;
    switch_break___24: /* CIL Label */ ;
    }
    ldv_36407: 
    {
#line 498
    printk("\017GRU:%d %s: FAILED idle tfh: 0x%p, state %d\n", pscr_ret_____4, "gru_try_dropin",
           tfh, (int )tfh->state);
    }
  } else {

  }
#line 499
  return (0);
  failinval: 
  {
#line 503
  tfh_exception(tfh);
#line 504
  gru_flush_cache_cbe(cbe);
  }
#line 505
  if ((gru_options & 2UL) != 0UL) {
    {
#line 505
    atomic_long_inc(& gru_stats.tlb_dropin_fail_invalid);
    }
  } else {

  }
#line 506
  if ((int )gru_options & 1) {
#line 506
    __vpp_verify___5 = (void const   *)0;
    {
#line 506
    if (4UL == 1UL) {
#line 506
      goto case_1___29;
    } else {

    }
#line 506
    if (4UL == 2UL) {
#line 506
      goto case_2___30;
    } else {

    }
#line 506
    if (4UL == 4UL) {
#line 506
      goto case_4___31;
    } else {

    }
#line 506
    if (4UL == 8UL) {
#line 506
      goto case_8___32;
    } else {

    }
#line 506
    goto switch_default___33;
    case_1___29: /* CIL Label */ ;
    {
#line 506
    if (4UL == 1UL) {
#line 506
      goto case_1___30;
    } else {

    }
#line 506
    if (4UL == 2UL) {
#line 506
      goto case_2___29;
    } else {

    }
#line 506
    if (4UL == 4UL) {
#line 506
      goto case_4___29;
    } else {

    }
#line 506
    if (4UL == 8UL) {
#line 506
      goto case_8___29;
    } else {

    }
#line 506
    goto switch_default___29;
    case_1___30: /* CIL Label */ 
#line 506
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____23): "m" (cpu_number));
#line 506
    goto ldv_36442;
    case_2___29: /* CIL Label */ 
#line 506
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____23): "m" (cpu_number));
#line 506
    goto ldv_36442;
    case_4___29: /* CIL Label */ 
#line 506
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____23): "m" (cpu_number));
#line 506
    goto ldv_36442;
    case_8___29: /* CIL Label */ 
#line 506
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____23): "m" (cpu_number));
#line 506
    goto ldv_36442;
    switch_default___29: /* CIL Label */ 
    {
#line 506
    __bad_percpu_size();
    }
    switch_break___30: /* CIL Label */ ;
    }
    ldv_36442: 
#line 506
    pscr_ret_____5 = pfo_ret_____23;
#line 506
    goto ldv_36448;
    case_2___30: /* CIL Label */ ;
    {
#line 506
    if (4UL == 1UL) {
#line 506
      goto case_1___31;
    } else {

    }
#line 506
    if (4UL == 2UL) {
#line 506
      goto case_2___31;
    } else {

    }
#line 506
    if (4UL == 4UL) {
#line 506
      goto case_4___30;
    } else {

    }
#line 506
    if (4UL == 8UL) {
#line 506
      goto case_8___30;
    } else {

    }
#line 506
    goto switch_default___30;
    case_1___31: /* CIL Label */ 
#line 506
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____24): "m" (cpu_number));
#line 506
    goto ldv_36452;
    case_2___31: /* CIL Label */ 
#line 506
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____24): "m" (cpu_number));
#line 506
    goto ldv_36452;
    case_4___30: /* CIL Label */ 
#line 506
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____24): "m" (cpu_number));
#line 506
    goto ldv_36452;
    case_8___30: /* CIL Label */ 
#line 506
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____24): "m" (cpu_number));
#line 506
    goto ldv_36452;
    switch_default___30: /* CIL Label */ 
    {
#line 506
    __bad_percpu_size();
    }
    switch_break___31: /* CIL Label */ ;
    }
    ldv_36452: 
#line 506
    pscr_ret_____5 = pfo_ret_____24;
#line 506
    goto ldv_36448;
    case_4___31: /* CIL Label */ ;
    {
#line 506
    if (4UL == 1UL) {
#line 506
      goto case_1___32;
    } else {

    }
#line 506
    if (4UL == 2UL) {
#line 506
      goto case_2___32;
    } else {

    }
#line 506
    if (4UL == 4UL) {
#line 506
      goto case_4___32;
    } else {

    }
#line 506
    if (4UL == 8UL) {
#line 506
      goto case_8___31;
    } else {

    }
#line 506
    goto switch_default___31;
    case_1___32: /* CIL Label */ 
#line 506
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____25): "m" (cpu_number));
#line 506
    goto ldv_36461;
    case_2___32: /* CIL Label */ 
#line 506
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____25): "m" (cpu_number));
#line 506
    goto ldv_36461;
    case_4___32: /* CIL Label */ 
#line 506
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____25): "m" (cpu_number));
#line 506
    goto ldv_36461;
    case_8___31: /* CIL Label */ 
#line 506
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____25): "m" (cpu_number));
#line 506
    goto ldv_36461;
    switch_default___31: /* CIL Label */ 
    {
#line 506
    __bad_percpu_size();
    }
    switch_break___32: /* CIL Label */ ;
    }
    ldv_36461: 
#line 506
    pscr_ret_____5 = pfo_ret_____25;
#line 506
    goto ldv_36448;
    case_8___32: /* CIL Label */ ;
    {
#line 506
    if (4UL == 1UL) {
#line 506
      goto case_1___33;
    } else {

    }
#line 506
    if (4UL == 2UL) {
#line 506
      goto case_2___33;
    } else {

    }
#line 506
    if (4UL == 4UL) {
#line 506
      goto case_4___33;
    } else {

    }
#line 506
    if (4UL == 8UL) {
#line 506
      goto case_8___33;
    } else {

    }
#line 506
    goto switch_default___32;
    case_1___33: /* CIL Label */ 
#line 506
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____26): "m" (cpu_number));
#line 506
    goto ldv_36470;
    case_2___33: /* CIL Label */ 
#line 506
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____26): "m" (cpu_number));
#line 506
    goto ldv_36470;
    case_4___33: /* CIL Label */ 
#line 506
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____26): "m" (cpu_number));
#line 506
    goto ldv_36470;
    case_8___33: /* CIL Label */ 
#line 506
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____26): "m" (cpu_number));
#line 506
    goto ldv_36470;
    switch_default___32: /* CIL Label */ 
    {
#line 506
    __bad_percpu_size();
    }
    switch_break___33: /* CIL Label */ ;
    }
    ldv_36470: 
#line 506
    pscr_ret_____5 = pfo_ret_____26;
#line 506
    goto ldv_36448;
    switch_default___33: /* CIL Label */ 
    {
#line 506
    __bad_size_call_parameter();
    }
#line 506
    goto ldv_36448;
    switch_break___29: /* CIL Label */ ;
    }
    ldv_36448: 
    {
#line 506
    printk("\017GRU:%d %s: FAILED inval tfh: 0x%p, vaddr 0x%lx\n", pscr_ret_____5,
           "gru_try_dropin", tfh, vaddr);
    }
  } else {

  }
#line 507
  return (-14);
  failactive: ;
#line 511
  if ((unsigned long )cbk == (unsigned long )((struct gru_instruction_bits *)0)) {
    {
#line 512
    tfh_user_polling_mode(tfh);
    }
  } else {
    {
#line 514
    gru_flush_cache((void *)tfh);
    }
  }
  {
#line 515
  gru_flush_cache_cbe(cbe);
  }
#line 516
  if ((gru_options & 2UL) != 0UL) {
    {
#line 516
    atomic_long_inc(& gru_stats.tlb_dropin_fail_range_active);
    }
  } else {

  }
#line 517
  if ((int )gru_options & 1) {
#line 517
    __vpp_verify___6 = (void const   *)0;
    {
#line 517
    if (4UL == 1UL) {
#line 517
      goto case_1___34;
    } else {

    }
#line 518
    if (4UL == 2UL) {
#line 518
      goto case_2___35;
    } else {

    }
#line 518
    if (4UL == 4UL) {
#line 518
      goto case_4___36;
    } else {

    }
#line 518
    if (4UL == 8UL) {
#line 518
      goto case_8___37;
    } else {

    }
#line 518
    goto switch_default___38;
    case_1___34: /* CIL Label */ ;
    {
#line 518
    if (4UL == 1UL) {
#line 518
      goto case_1___35;
    } else {

    }
#line 518
    if (4UL == 2UL) {
#line 518
      goto case_2___34;
    } else {

    }
#line 518
    if (4UL == 4UL) {
#line 518
      goto case_4___34;
    } else {

    }
#line 518
    if (4UL == 8UL) {
#line 518
      goto case_8___34;
    } else {

    }
#line 518
    goto switch_default___34;
    case_1___35: /* CIL Label */ 
#line 518
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____27): "m" (cpu_number));
#line 518
    goto ldv_36483;
    case_2___34: /* CIL Label */ 
#line 518
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____27): "m" (cpu_number));
#line 518
    goto ldv_36483;
    case_4___34: /* CIL Label */ 
#line 518
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____27): "m" (cpu_number));
#line 518
    goto ldv_36483;
    case_8___34: /* CIL Label */ 
#line 518
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____27): "m" (cpu_number));
#line 518
    goto ldv_36483;
    switch_default___34: /* CIL Label */ 
    {
#line 518
    __bad_percpu_size();
    }
    switch_break___35: /* CIL Label */ ;
    }
    ldv_36483: 
#line 518
    pscr_ret_____6 = pfo_ret_____27;
#line 518
    goto ldv_36489;
    case_2___35: /* CIL Label */ ;
    {
#line 518
    if (4UL == 1UL) {
#line 518
      goto case_1___36;
    } else {

    }
#line 518
    if (4UL == 2UL) {
#line 518
      goto case_2___36;
    } else {

    }
#line 518
    if (4UL == 4UL) {
#line 518
      goto case_4___35;
    } else {

    }
#line 518
    if (4UL == 8UL) {
#line 518
      goto case_8___35;
    } else {

    }
#line 518
    goto switch_default___35;
    case_1___36: /* CIL Label */ 
#line 518
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____28): "m" (cpu_number));
#line 518
    goto ldv_36493;
    case_2___36: /* CIL Label */ 
#line 518
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____28): "m" (cpu_number));
#line 518
    goto ldv_36493;
    case_4___35: /* CIL Label */ 
#line 518
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____28): "m" (cpu_number));
#line 518
    goto ldv_36493;
    case_8___35: /* CIL Label */ 
#line 518
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____28): "m" (cpu_number));
#line 518
    goto ldv_36493;
    switch_default___35: /* CIL Label */ 
    {
#line 518
    __bad_percpu_size();
    }
    switch_break___36: /* CIL Label */ ;
    }
    ldv_36493: 
#line 518
    pscr_ret_____6 = pfo_ret_____28;
#line 518
    goto ldv_36489;
    case_4___36: /* CIL Label */ ;
    {
#line 518
    if (4UL == 1UL) {
#line 518
      goto case_1___37;
    } else {

    }
#line 518
    if (4UL == 2UL) {
#line 518
      goto case_2___37;
    } else {

    }
#line 518
    if (4UL == 4UL) {
#line 518
      goto case_4___37;
    } else {

    }
#line 518
    if (4UL == 8UL) {
#line 518
      goto case_8___36;
    } else {

    }
#line 518
    goto switch_default___36;
    case_1___37: /* CIL Label */ 
#line 518
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____29): "m" (cpu_number));
#line 518
    goto ldv_36502;
    case_2___37: /* CIL Label */ 
#line 518
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____29): "m" (cpu_number));
#line 518
    goto ldv_36502;
    case_4___37: /* CIL Label */ 
#line 518
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____29): "m" (cpu_number));
#line 518
    goto ldv_36502;
    case_8___36: /* CIL Label */ 
#line 518
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____29): "m" (cpu_number));
#line 518
    goto ldv_36502;
    switch_default___36: /* CIL Label */ 
    {
#line 518
    __bad_percpu_size();
    }
    switch_break___37: /* CIL Label */ ;
    }
    ldv_36502: 
#line 518
    pscr_ret_____6 = pfo_ret_____29;
#line 518
    goto ldv_36489;
    case_8___37: /* CIL Label */ ;
    {
#line 518
    if (4UL == 1UL) {
#line 518
      goto case_1___38;
    } else {

    }
#line 518
    if (4UL == 2UL) {
#line 518
      goto case_2___38;
    } else {

    }
#line 518
    if (4UL == 4UL) {
#line 518
      goto case_4___38;
    } else {

    }
#line 518
    if (4UL == 8UL) {
#line 518
      goto case_8___38;
    } else {

    }
#line 518
    goto switch_default___37;
    case_1___38: /* CIL Label */ 
#line 518
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____30): "m" (cpu_number));
#line 518
    goto ldv_36511;
    case_2___38: /* CIL Label */ 
#line 518
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____30): "m" (cpu_number));
#line 518
    goto ldv_36511;
    case_4___38: /* CIL Label */ 
#line 518
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____30): "m" (cpu_number));
#line 518
    goto ldv_36511;
    case_8___38: /* CIL Label */ 
#line 518
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____30): "m" (cpu_number));
#line 518
    goto ldv_36511;
    switch_default___37: /* CIL Label */ 
    {
#line 518
    __bad_percpu_size();
    }
    switch_break___38: /* CIL Label */ ;
    }
    ldv_36511: 
#line 518
    pscr_ret_____6 = pfo_ret_____30;
#line 518
    goto ldv_36489;
    switch_default___38: /* CIL Label */ 
    {
#line 518
    __bad_size_call_parameter();
    }
#line 518
    goto ldv_36489;
    switch_break___34: /* CIL Label */ ;
    }
    ldv_36489: 
    {
#line 518
    printk("\017GRU:%d %s: FAILED range active: tfh 0x%p, vaddr 0x%lx\n", pscr_ret_____6,
           "gru_try_dropin", tfh, vaddr);
    }
  } else {

  }
#line 519
  return (1);
}
}
#line 528 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static irqreturn_t gru_intr(int chiplet , int blade ) 
{ 
  struct gru_state *gru ;
  struct gru_tlb_fault_map imap ;
  struct gru_tlb_fault_map dmap ;
  struct gru_thread_state *gts ;
  struct gru_tlb_fault_handle *tfh ;
  struct completion *cmp ;
  int cbrnum ;
  int ctxnum ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  unsigned long tmp ;
  int pscr_ret_____2 ;
  void const   *__vpp_verify___2 ;
  int pfo_ret_____11 ;
  int pfo_ret_____12 ;
  int pfo_ret_____13 ;
  int pfo_ret_____14 ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 533
  tfh = (struct gru_tlb_fault_handle *)0;
#line 537
  if ((gru_options & 2UL) != 0UL) {
    {
#line 537
    atomic_long_inc(& gru_stats.intr);
    }
  } else {

  }
#line 539
  gru = (struct gru_state *)(& (gru_base[blade])->bs_grus) + (unsigned long )chiplet;
#line 540
  if ((unsigned long )gru == (unsigned long )((struct gru_state *)0)) {
#line 542
    __vpp_verify = (void const   *)0;
    {
#line 542
    if (4UL == 1UL) {
#line 542
      goto case_1;
    } else {

    }
#line 542
    if (4UL == 2UL) {
#line 542
      goto case_2___0;
    } else {

    }
#line 542
    if (4UL == 4UL) {
#line 542
      goto case_4___1;
    } else {

    }
#line 542
    if (4UL == 8UL) {
#line 542
      goto case_8___2;
    } else {

    }
#line 542
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 542
    if (4UL == 1UL) {
#line 542
      goto case_1___0;
    } else {

    }
#line 542
    if (4UL == 2UL) {
#line 542
      goto case_2;
    } else {

    }
#line 542
    if (4UL == 4UL) {
#line 542
      goto case_4;
    } else {

    }
#line 542
    if (4UL == 8UL) {
#line 542
      goto case_8;
    } else {

    }
#line 542
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 542
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 542
    goto ldv_36536;
    case_2: /* CIL Label */ 
#line 542
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 542
    goto ldv_36536;
    case_4: /* CIL Label */ 
#line 542
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 542
    goto ldv_36536;
    case_8: /* CIL Label */ 
#line 542
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 542
    goto ldv_36536;
    switch_default: /* CIL Label */ 
    {
#line 542
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_36536: 
#line 542
    pscr_ret__ = pfo_ret__;
#line 542
    goto ldv_36542;
    case_2___0: /* CIL Label */ ;
    {
#line 542
    if (4UL == 1UL) {
#line 542
      goto case_1___1;
    } else {

    }
#line 542
    if (4UL == 2UL) {
#line 542
      goto case_2___1;
    } else {

    }
#line 542
    if (4UL == 4UL) {
#line 542
      goto case_4___0;
    } else {

    }
#line 542
    if (4UL == 8UL) {
#line 542
      goto case_8___0;
    } else {

    }
#line 542
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 542
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 542
    goto ldv_36546;
    case_2___1: /* CIL Label */ 
#line 542
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 542
    goto ldv_36546;
    case_4___0: /* CIL Label */ 
#line 542
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 542
    goto ldv_36546;
    case_8___0: /* CIL Label */ 
#line 542
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 542
    goto ldv_36546;
    switch_default___0: /* CIL Label */ 
    {
#line 542
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_36546: 
#line 542
    pscr_ret__ = pfo_ret_____0;
#line 542
    goto ldv_36542;
    case_4___1: /* CIL Label */ ;
    {
#line 542
    if (4UL == 1UL) {
#line 542
      goto case_1___2;
    } else {

    }
#line 542
    if (4UL == 2UL) {
#line 542
      goto case_2___2;
    } else {

    }
#line 542
    if (4UL == 4UL) {
#line 542
      goto case_4___2;
    } else {

    }
#line 542
    if (4UL == 8UL) {
#line 542
      goto case_8___1;
    } else {

    }
#line 542
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 542
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 542
    goto ldv_36555;
    case_2___2: /* CIL Label */ 
#line 542
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 542
    goto ldv_36555;
    case_4___2: /* CIL Label */ 
#line 542
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 542
    goto ldv_36555;
    case_8___1: /* CIL Label */ 
#line 542
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 542
    goto ldv_36555;
    switch_default___1: /* CIL Label */ 
    {
#line 542
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_36555: 
#line 542
    pscr_ret__ = pfo_ret_____1;
#line 542
    goto ldv_36542;
    case_8___2: /* CIL Label */ ;
    {
#line 542
    if (4UL == 1UL) {
#line 542
      goto case_1___3;
    } else {

    }
#line 542
    if (4UL == 2UL) {
#line 542
      goto case_2___3;
    } else {

    }
#line 542
    if (4UL == 4UL) {
#line 542
      goto case_4___3;
    } else {

    }
#line 542
    if (4UL == 8UL) {
#line 542
      goto case_8___3;
    } else {

    }
#line 542
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 542
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 542
    goto ldv_36564;
    case_2___3: /* CIL Label */ 
#line 542
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 542
    goto ldv_36564;
    case_4___3: /* CIL Label */ 
#line 542
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 542
    goto ldv_36564;
    case_8___3: /* CIL Label */ 
#line 542
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 542
    goto ldv_36564;
    switch_default___2: /* CIL Label */ 
    {
#line 542
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_36564: 
#line 542
    pscr_ret__ = pfo_ret_____2;
#line 542
    goto ldv_36542;
    switch_default___3: /* CIL Label */ 
    {
#line 542
    __bad_size_call_parameter();
    }
#line 542
    goto ldv_36542;
    switch_break: /* CIL Label */ ;
    }
    ldv_36542: 
    {
#line 542
    dev_err((struct device  const  *)grudev, "GRU: invalid interrupt: cpu %d, chiplet %d\n",
            pscr_ret__, chiplet);
    }
#line 543
    return (0);
  } else {

  }
  {
#line 545
  get_clear_fault_map(gru, & imap, & dmap);
  }
#line 546
  if ((int )gru_options & 1) {
#line 550
    __vpp_verify___0 = (void const   *)0;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___4;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___5;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___6;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___7;
    } else {

    }
#line 550
    goto switch_default___8;
    case_1___4: /* CIL Label */ ;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___5;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___4;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___4;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___4;
    } else {

    }
#line 550
    goto switch_default___4;
    case_1___5: /* CIL Label */ 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 550
    goto ldv_36619;
    case_2___4: /* CIL Label */ 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 550
    goto ldv_36619;
    case_4___4: /* CIL Label */ 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 550
    goto ldv_36619;
    case_8___4: /* CIL Label */ 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 550
    goto ldv_36619;
    switch_default___4: /* CIL Label */ 
    {
#line 550
    __bad_percpu_size();
    }
    switch_break___5: /* CIL Label */ ;
    }
    ldv_36619: 
#line 550
    pscr_ret_____0 = pfo_ret_____3;
#line 550
    goto ldv_36625;
    case_2___5: /* CIL Label */ ;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___6;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___6;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___5;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___5;
    } else {

    }
#line 550
    goto switch_default___5;
    case_1___6: /* CIL Label */ 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 550
    goto ldv_36629;
    case_2___6: /* CIL Label */ 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 550
    goto ldv_36629;
    case_4___5: /* CIL Label */ 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 550
    goto ldv_36629;
    case_8___5: /* CIL Label */ 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 550
    goto ldv_36629;
    switch_default___5: /* CIL Label */ 
    {
#line 550
    __bad_percpu_size();
    }
    switch_break___6: /* CIL Label */ ;
    }
    ldv_36629: 
#line 550
    pscr_ret_____0 = pfo_ret_____4;
#line 550
    goto ldv_36625;
    case_4___6: /* CIL Label */ ;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___7;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___7;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___7;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___6;
    } else {

    }
#line 550
    goto switch_default___6;
    case_1___7: /* CIL Label */ 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 550
    goto ldv_36638;
    case_2___7: /* CIL Label */ 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 550
    goto ldv_36638;
    case_4___7: /* CIL Label */ 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 550
    goto ldv_36638;
    case_8___6: /* CIL Label */ 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 550
    goto ldv_36638;
    switch_default___6: /* CIL Label */ 
    {
#line 550
    __bad_percpu_size();
    }
    switch_break___7: /* CIL Label */ ;
    }
    ldv_36638: 
#line 550
    pscr_ret_____0 = pfo_ret_____5;
#line 550
    goto ldv_36625;
    case_8___7: /* CIL Label */ ;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___8;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___8;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___8;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___8;
    } else {

    }
#line 550
    goto switch_default___7;
    case_1___8: /* CIL Label */ 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 550
    goto ldv_36647;
    case_2___8: /* CIL Label */ 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 550
    goto ldv_36647;
    case_4___8: /* CIL Label */ 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 550
    goto ldv_36647;
    case_8___8: /* CIL Label */ 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 550
    goto ldv_36647;
    switch_default___7: /* CIL Label */ 
    {
#line 550
    __bad_percpu_size();
    }
    switch_break___8: /* CIL Label */ ;
    }
    ldv_36647: 
#line 550
    pscr_ret_____0 = pfo_ret_____6;
#line 550
    goto ldv_36625;
    switch_default___8: /* CIL Label */ 
    {
#line 550
    __bad_size_call_parameter();
    }
#line 550
    goto ldv_36625;
    switch_break___4: /* CIL Label */ ;
    }
    ldv_36625: 
#line 546
    __vpp_verify___1 = (void const   *)0;
    {
#line 546
    if (4UL == 1UL) {
#line 546
      goto case_1___9;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___10;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___11;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___12;
    } else {

    }
#line 550
    goto switch_default___13;
    case_1___9: /* CIL Label */ ;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___10;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___9;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___9;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___9;
    } else {

    }
#line 550
    goto switch_default___9;
    case_1___10: /* CIL Label */ 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 550
    goto ldv_36577;
    case_2___9: /* CIL Label */ 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 550
    goto ldv_36577;
    case_4___9: /* CIL Label */ 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 550
    goto ldv_36577;
    case_8___9: /* CIL Label */ 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 550
    goto ldv_36577;
    switch_default___9: /* CIL Label */ 
    {
#line 550
    __bad_percpu_size();
    }
    switch_break___10: /* CIL Label */ ;
    }
    ldv_36577: 
#line 550
    pscr_ret_____1 = pfo_ret_____7;
#line 550
    goto ldv_36583;
    case_2___10: /* CIL Label */ ;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___11;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___11;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___10;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___10;
    } else {

    }
#line 550
    goto switch_default___10;
    case_1___11: /* CIL Label */ 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 550
    goto ldv_36587;
    case_2___11: /* CIL Label */ 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 550
    goto ldv_36587;
    case_4___10: /* CIL Label */ 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 550
    goto ldv_36587;
    case_8___10: /* CIL Label */ 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 550
    goto ldv_36587;
    switch_default___10: /* CIL Label */ 
    {
#line 550
    __bad_percpu_size();
    }
    switch_break___11: /* CIL Label */ ;
    }
    ldv_36587: 
#line 550
    pscr_ret_____1 = pfo_ret_____8;
#line 550
    goto ldv_36583;
    case_4___11: /* CIL Label */ ;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___12;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___12;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___12;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___11;
    } else {

    }
#line 550
    goto switch_default___11;
    case_1___12: /* CIL Label */ 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 550
    goto ldv_36596;
    case_2___12: /* CIL Label */ 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 550
    goto ldv_36596;
    case_4___12: /* CIL Label */ 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 550
    goto ldv_36596;
    case_8___11: /* CIL Label */ 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 550
    goto ldv_36596;
    switch_default___11: /* CIL Label */ 
    {
#line 550
    __bad_percpu_size();
    }
    switch_break___12: /* CIL Label */ ;
    }
    ldv_36596: 
#line 550
    pscr_ret_____1 = pfo_ret_____9;
#line 550
    goto ldv_36583;
    case_8___12: /* CIL Label */ ;
    {
#line 550
    if (4UL == 1UL) {
#line 550
      goto case_1___13;
    } else {

    }
#line 550
    if (4UL == 2UL) {
#line 550
      goto case_2___13;
    } else {

    }
#line 550
    if (4UL == 4UL) {
#line 550
      goto case_4___13;
    } else {

    }
#line 550
    if (4UL == 8UL) {
#line 550
      goto case_8___13;
    } else {

    }
#line 550
    goto switch_default___12;
    case_1___13: /* CIL Label */ 
#line 550
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 550
    goto ldv_36605;
    case_2___13: /* CIL Label */ 
#line 550
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 550
    goto ldv_36605;
    case_4___13: /* CIL Label */ 
#line 550
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 550
    goto ldv_36605;
    case_8___13: /* CIL Label */ 
#line 550
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 550
    goto ldv_36605;
    switch_default___12: /* CIL Label */ 
    {
#line 550
    __bad_percpu_size();
    }
    switch_break___13: /* CIL Label */ ;
    }
    ldv_36605: 
#line 550
    pscr_ret_____1 = pfo_ret_____10;
#line 550
    goto ldv_36583;
    switch_default___13: /* CIL Label */ 
    {
#line 550
    __bad_size_call_parameter();
    }
#line 550
    goto ldv_36583;
    switch_break___9: /* CIL Label */ ;
    }
    ldv_36583: 
    {
#line 550
    printk("\017GRU:%d %s: cpu %d, chiplet %d, gid %d, imap %016lx %016lx, dmap %016lx %016lx\n",
           pscr_ret_____1, "gru_intr", pscr_ret_____0, chiplet, (int )gru->gs_gid,
           imap.fault_bits[0], imap.fault_bits[1], dmap.fault_bits[0], dmap.fault_bits[1]);
    }
  } else {

  }
  {
#line 552
  tmp = ldv_find_first_bit_99((unsigned long const   *)(& dmap.fault_bits), 128UL);
#line 552
  cbrnum = (int )tmp;
  }
#line 552
  goto ldv_36697;
  ldv_36696: ;
#line 553
  if ((gru_options & 2UL) != 0UL) {
    {
#line 553
    atomic_long_inc(& gru_stats.intr_cbr);
    }
  } else {

  }
#line 554
  cmp = (gru->gs_blade)->bs_async_wq;
#line 555
  if ((unsigned long )cmp != (unsigned long )((struct completion *)0)) {
    {
#line 556
    complete(cmp);
    }
  } else {

  }
#line 557
  if ((int )gru_options & 1) {
#line 557
    __vpp_verify___2 = (void const   *)0;
    {
#line 557
    if (4UL == 1UL) {
#line 557
      goto case_1___14;
    } else {

    }
#line 558
    if (4UL == 2UL) {
#line 558
      goto case_2___15;
    } else {

    }
#line 558
    if (4UL == 4UL) {
#line 558
      goto case_4___16;
    } else {

    }
#line 558
    if (4UL == 8UL) {
#line 558
      goto case_8___17;
    } else {

    }
#line 558
    goto switch_default___18;
    case_1___14: /* CIL Label */ ;
    {
#line 558
    if (4UL == 1UL) {
#line 558
      goto case_1___15;
    } else {

    }
#line 558
    if (4UL == 2UL) {
#line 558
      goto case_2___14;
    } else {

    }
#line 558
    if (4UL == 4UL) {
#line 558
      goto case_4___14;
    } else {

    }
#line 558
    if (4UL == 8UL) {
#line 558
      goto case_8___14;
    } else {

    }
#line 558
    goto switch_default___14;
    case_1___15: /* CIL Label */ 
#line 558
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____11): "m" (cpu_number));
#line 558
    goto ldv_36660;
    case_2___14: /* CIL Label */ 
#line 558
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 558
    goto ldv_36660;
    case_4___14: /* CIL Label */ 
#line 558
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 558
    goto ldv_36660;
    case_8___14: /* CIL Label */ 
#line 558
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 558
    goto ldv_36660;
    switch_default___14: /* CIL Label */ 
    {
#line 558
    __bad_percpu_size();
    }
    switch_break___15: /* CIL Label */ ;
    }
    ldv_36660: 
#line 558
    pscr_ret_____2 = pfo_ret_____11;
#line 558
    goto ldv_36666;
    case_2___15: /* CIL Label */ ;
    {
#line 558
    if (4UL == 1UL) {
#line 558
      goto case_1___16;
    } else {

    }
#line 558
    if (4UL == 2UL) {
#line 558
      goto case_2___16;
    } else {

    }
#line 558
    if (4UL == 4UL) {
#line 558
      goto case_4___15;
    } else {

    }
#line 558
    if (4UL == 8UL) {
#line 558
      goto case_8___15;
    } else {

    }
#line 558
    goto switch_default___15;
    case_1___16: /* CIL Label */ 
#line 558
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____12): "m" (cpu_number));
#line 558
    goto ldv_36670;
    case_2___16: /* CIL Label */ 
#line 558
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 558
    goto ldv_36670;
    case_4___15: /* CIL Label */ 
#line 558
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 558
    goto ldv_36670;
    case_8___15: /* CIL Label */ 
#line 558
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 558
    goto ldv_36670;
    switch_default___15: /* CIL Label */ 
    {
#line 558
    __bad_percpu_size();
    }
    switch_break___16: /* CIL Label */ ;
    }
    ldv_36670: 
#line 558
    pscr_ret_____2 = pfo_ret_____12;
#line 558
    goto ldv_36666;
    case_4___16: /* CIL Label */ ;
    {
#line 558
    if (4UL == 1UL) {
#line 558
      goto case_1___17;
    } else {

    }
#line 558
    if (4UL == 2UL) {
#line 558
      goto case_2___17;
    } else {

    }
#line 558
    if (4UL == 4UL) {
#line 558
      goto case_4___17;
    } else {

    }
#line 558
    if (4UL == 8UL) {
#line 558
      goto case_8___16;
    } else {

    }
#line 558
    goto switch_default___16;
    case_1___17: /* CIL Label */ 
#line 558
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____13): "m" (cpu_number));
#line 558
    goto ldv_36679;
    case_2___17: /* CIL Label */ 
#line 558
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 558
    goto ldv_36679;
    case_4___17: /* CIL Label */ 
#line 558
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 558
    goto ldv_36679;
    case_8___16: /* CIL Label */ 
#line 558
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 558
    goto ldv_36679;
    switch_default___16: /* CIL Label */ 
    {
#line 558
    __bad_percpu_size();
    }
    switch_break___17: /* CIL Label */ ;
    }
    ldv_36679: 
#line 558
    pscr_ret_____2 = pfo_ret_____13;
#line 558
    goto ldv_36666;
    case_8___17: /* CIL Label */ ;
    {
#line 558
    if (4UL == 1UL) {
#line 558
      goto case_1___18;
    } else {

    }
#line 558
    if (4UL == 2UL) {
#line 558
      goto case_2___18;
    } else {

    }
#line 558
    if (4UL == 4UL) {
#line 558
      goto case_4___18;
    } else {

    }
#line 558
    if (4UL == 8UL) {
#line 558
      goto case_8___18;
    } else {

    }
#line 558
    goto switch_default___17;
    case_1___18: /* CIL Label */ 
#line 558
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____14): "m" (cpu_number));
#line 558
    goto ldv_36688;
    case_2___18: /* CIL Label */ 
#line 558
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 558
    goto ldv_36688;
    case_4___18: /* CIL Label */ 
#line 558
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 558
    goto ldv_36688;
    case_8___18: /* CIL Label */ 
#line 558
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 558
    goto ldv_36688;
    switch_default___17: /* CIL Label */ 
    {
#line 558
    __bad_percpu_size();
    }
    switch_break___18: /* CIL Label */ ;
    }
    ldv_36688: 
#line 558
    pscr_ret_____2 = pfo_ret_____14;
#line 558
    goto ldv_36666;
    switch_default___18: /* CIL Label */ 
    {
#line 558
    __bad_size_call_parameter();
    }
#line 558
    goto ldv_36666;
    switch_break___14: /* CIL Label */ ;
    }
    ldv_36666: 
    {
#line 558
    printk("\017GRU:%d %s: gid %d, cbr_done %d, done %d\n", pscr_ret_____2, "gru_intr",
           (int )gru->gs_gid, cbrnum, (unsigned long )cmp != (unsigned long )((struct completion *)0) ? cmp->done : 4294967295U);
    }
  } else {

  }
  {
#line 552
  tmp___0 = ldv_find_next_bit_100((unsigned long const   *)(& dmap.fault_bits), 128UL,
                                  (unsigned long )(cbrnum + 1));
#line 552
  cbrnum = (int )tmp___0;
  }
  ldv_36697: ;
#line 552
  if (cbrnum <= 127) {
#line 554
    goto ldv_36696;
  } else {

  }
  {
#line 561
  tmp___1 = ldv_find_first_bit_101((unsigned long const   *)(& imap.fault_bits), 128UL);
#line 561
  cbrnum = (int )tmp___1;
  }
#line 561
  goto ldv_36701;
  ldv_36700: ;
#line 562
  if ((gru_options & 2UL) != 0UL) {
    {
#line 562
    atomic_long_inc(& gru_stats.intr_tfh);
    }
  } else {

  }
  {
#line 563
  tfh = get_tfh(gru->gs_gru_base_vaddr, cbrnum);
#line 564
  prefetchw((void const   *)tfh);
#line 572
  ctxnum = (int )tfh->ctxnum;
#line 573
  gts = gru->gs_gts[ctxnum];
  }
#line 576
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 577
    if ((gru_options & 2UL) != 0UL) {
      {
#line 577
      atomic_long_inc(& gru_stats.intr_spurious);
      }
    } else {

    }
#line 578
    goto ldv_36699;
  } else {

  }
#line 585
  gts->ustats.fmm_tlbmiss = gts->ustats.fmm_tlbmiss + 1UL;
#line 586
  if ((int )((signed char )gts->ts_force_cch_reload) == 0) {
    {
#line 586
    tmp___2 = down_read_trylock(& (gts->ts_mm)->mmap_sem);
    }
#line 586
    if (tmp___2 != 0) {
      {
#line 588
      gru_try_dropin(gru, gts, tfh, (struct gru_instruction_bits *)0);
#line 589
      up_read(& (gts->ts_mm)->mmap_sem);
      }
    } else {
#line 586
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 591
    tfh_user_polling_mode(tfh);
    }
#line 592
    if ((gru_options & 2UL) != 0UL) {
      {
#line 592
      atomic_long_inc(& gru_stats.intr_mm_lock_failed);
      }
    } else {

    }
  }
  ldv_36699: 
  {
#line 561
  tmp___3 = ldv_find_next_bit_102((unsigned long const   *)(& imap.fault_bits), 128UL,
                                  (unsigned long )(cbrnum + 1));
#line 561
  cbrnum = (int )tmp___3;
  }
  ldv_36701: ;
#line 561
  if (cbrnum <= 127) {
#line 563
    goto ldv_36700;
  } else {

  }

#line 595
  return (1);
}
}
#line 598 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
irqreturn_t gru0_intr(int irq , void *dev_id ) 
{ 
  int tmp ;
  irqreturn_t tmp___0 ;

  {
  {
#line 600
  tmp = uv_numa_blade_id();
#line 600
  tmp___0 = gru_intr(0, tmp);
  }
#line 600
  return (tmp___0);
}
}
#line 603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
irqreturn_t gru1_intr(int irq , void *dev_id ) 
{ 
  int tmp ;
  irqreturn_t tmp___0 ;

  {
  {
#line 605
  tmp = uv_numa_blade_id();
#line 605
  tmp___0 = gru_intr(1, tmp);
  }
#line 605
  return (tmp___0);
}
}
#line 608 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
irqreturn_t gru_intr_mblade(int irq , void *dev_id ) 
{ 
  int blade ;
  int tmp ;
  int tmp___0 ;

  {
#line 612
  blade = 0;
#line 612
  goto ldv_36718;
  ldv_36717: 
  {
#line 613
  tmp = uv_blade_nr_possible_cpus(blade);
  }
#line 613
  if (tmp != 0) {
#line 614
    goto ldv_36716;
  } else {

  }
  {
#line 615
  gru_intr(0, blade);
#line 616
  gru_intr(1, blade);
  }
  ldv_36716: 
#line 612
  blade = blade + 1;
  ldv_36718: 
  {
#line 612
  tmp___0 = uv_num_possible_blades();
  }
#line 612
  if (blade < tmp___0) {
#line 614
    goto ldv_36717;
  } else {

  }

#line 618
  return (1);
}
}
#line 622 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static int gru_user_dropin(struct gru_thread_state *gts , struct gru_tlb_fault_handle *tfh ,
                           void *cb ) 
{ 
  struct gru_mm_struct *gms ;
  int ret ;
  int tmp ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 626
  gms = gts->ts_gms;
#line 629
  gts->ustats.upm_tlbmiss = gts->ustats.upm_tlbmiss + 1UL;
  ldv_36735: 
  {
#line 631
  __might_sleep("drivers/misc/sgi-gru/grufault.c", 632, 0);
#line 631
  tmp = atomic_read((atomic_t const   *)(& gms->ms_range_active));
  }
#line 631
  if (tmp == 0) {
#line 631
    goto ldv_36727;
  } else {

  }
  {
#line 631
  __ret = 0L;
#line 631
  INIT_LIST_HEAD(& __wait.task_list);
#line 631
  __wait.flags = 0U;
  }
  ldv_36733: 
  {
#line 631
  tmp___0 = prepare_to_wait_event(& gms->ms_wait_queue, & __wait, 2);
#line 631
  __int = tmp___0;
#line 631
  tmp___1 = atomic_read((atomic_t const   *)(& gms->ms_range_active));
  }
#line 631
  if (tmp___1 == 0) {
#line 631
    goto ldv_36732;
  } else {

  }
  {
#line 631
  schedule();
  }
#line 631
  goto ldv_36733;
  ldv_36732: 
  {
#line 631
  finish_wait(& gms->ms_wait_queue, & __wait);
  }

  ldv_36727: 
  {
#line 633
  prefetchw((void const   *)tfh);
#line 634
  ret = gru_try_dropin(gts->ts_gru, gts, tfh, (struct gru_instruction_bits *)cb);
  }
#line 635
  if (ret <= 0) {
#line 636
    return (ret);
  } else {

  }
#line 637
  if ((gru_options & 2UL) != 0UL) {
    {
#line 637
    atomic_long_inc(& gru_stats.call_os_wait_queue);
    }
  } else {

  }
#line 638
  goto ldv_36735;
}
}
#line 646 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
int gru_handle_user_call_os(unsigned long cb ) 
{ 
  struct gru_tlb_fault_handle *tfh ;
  struct gru_thread_state *gts ;
  void *cbk ;
  int ucbnum ;
  int cbrnum ;
  int ret ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 651
  ret = -22;
#line 653
  if ((gru_options & 2UL) != 0UL) {
    {
#line 653
    atomic_long_inc(& gru_stats.call_os);
    }
  } else {

  }
  {
#line 656
  tmp = get_cb_number((void *)cb);
#line 656
  ucbnum = (int )tmp;
  }
#line 657
  if ((cb & 255UL) != 0UL || ucbnum > 127) {
#line 658
    return (-22);
  } else {

  }
  {
#line 660
  gts = gru_find_lock_gts(cb);
  }
#line 661
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 662
    return (-22);
  } else {

  }
#line 663
  if ((int )gru_options & 1) {
#line 663
    __vpp_verify = (void const   *)0;
    {
#line 663
    if (4UL == 1UL) {
#line 663
      goto case_1;
    } else {

    }
#line 663
    if (4UL == 2UL) {
#line 663
      goto case_2___0;
    } else {

    }
#line 663
    if (4UL == 4UL) {
#line 663
      goto case_4___1;
    } else {

    }
#line 663
    if (4UL == 8UL) {
#line 663
      goto case_8___2;
    } else {

    }
#line 663
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 663
    if (4UL == 1UL) {
#line 663
      goto case_1___0;
    } else {

    }
#line 663
    if (4UL == 2UL) {
#line 663
      goto case_2;
    } else {

    }
#line 663
    if (4UL == 4UL) {
#line 663
      goto case_4;
    } else {

    }
#line 663
    if (4UL == 8UL) {
#line 663
      goto case_8;
    } else {

    }
#line 663
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 663
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 663
    goto ldv_36750;
    case_2: /* CIL Label */ 
#line 663
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 663
    goto ldv_36750;
    case_4: /* CIL Label */ 
#line 663
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 663
    goto ldv_36750;
    case_8: /* CIL Label */ 
#line 663
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 663
    goto ldv_36750;
    switch_default: /* CIL Label */ 
    {
#line 663
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_36750: 
#line 663
    pscr_ret__ = pfo_ret__;
#line 663
    goto ldv_36756;
    case_2___0: /* CIL Label */ ;
    {
#line 663
    if (4UL == 1UL) {
#line 663
      goto case_1___1;
    } else {

    }
#line 663
    if (4UL == 2UL) {
#line 663
      goto case_2___1;
    } else {

    }
#line 663
    if (4UL == 4UL) {
#line 663
      goto case_4___0;
    } else {

    }
#line 663
    if (4UL == 8UL) {
#line 663
      goto case_8___0;
    } else {

    }
#line 663
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 663
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 663
    goto ldv_36760;
    case_2___1: /* CIL Label */ 
#line 663
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 663
    goto ldv_36760;
    case_4___0: /* CIL Label */ 
#line 663
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 663
    goto ldv_36760;
    case_8___0: /* CIL Label */ 
#line 663
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 663
    goto ldv_36760;
    switch_default___0: /* CIL Label */ 
    {
#line 663
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_36760: 
#line 663
    pscr_ret__ = pfo_ret_____0;
#line 663
    goto ldv_36756;
    case_4___1: /* CIL Label */ ;
    {
#line 663
    if (4UL == 1UL) {
#line 663
      goto case_1___2;
    } else {

    }
#line 663
    if (4UL == 2UL) {
#line 663
      goto case_2___2;
    } else {

    }
#line 663
    if (4UL == 4UL) {
#line 663
      goto case_4___2;
    } else {

    }
#line 663
    if (4UL == 8UL) {
#line 663
      goto case_8___1;
    } else {

    }
#line 663
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 663
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 663
    goto ldv_36769;
    case_2___2: /* CIL Label */ 
#line 663
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 663
    goto ldv_36769;
    case_4___2: /* CIL Label */ 
#line 663
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 663
    goto ldv_36769;
    case_8___1: /* CIL Label */ 
#line 663
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 663
    goto ldv_36769;
    switch_default___1: /* CIL Label */ 
    {
#line 663
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_36769: 
#line 663
    pscr_ret__ = pfo_ret_____1;
#line 663
    goto ldv_36756;
    case_8___2: /* CIL Label */ ;
    {
#line 663
    if (4UL == 1UL) {
#line 663
      goto case_1___3;
    } else {

    }
#line 663
    if (4UL == 2UL) {
#line 663
      goto case_2___3;
    } else {

    }
#line 663
    if (4UL == 4UL) {
#line 663
      goto case_4___3;
    } else {

    }
#line 663
    if (4UL == 8UL) {
#line 663
      goto case_8___3;
    } else {

    }
#line 663
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 663
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 663
    goto ldv_36778;
    case_2___3: /* CIL Label */ 
#line 663
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 663
    goto ldv_36778;
    case_4___3: /* CIL Label */ 
#line 663
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 663
    goto ldv_36778;
    case_8___3: /* CIL Label */ 
#line 663
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 663
    goto ldv_36778;
    switch_default___2: /* CIL Label */ 
    {
#line 663
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_36778: 
#line 663
    pscr_ret__ = pfo_ret_____2;
#line 663
    goto ldv_36756;
    switch_default___3: /* CIL Label */ 
    {
#line 663
    __bad_size_call_parameter();
    }
#line 663
    goto ldv_36756;
    switch_break: /* CIL Label */ ;
    }
    ldv_36756: 
    {
#line 663
    printk("\017GRU:%d %s: address 0x%lx, gid %d, gts 0x%p\n", pscr_ret__, "gru_handle_user_call_os",
           cb, (unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0) ? (int )(gts->ts_gru)->gs_gid : -1,
           gts);
    }
  } else {

  }
#line 665
  if (ucbnum >= (int )gts->ts_cbr_au_count * 2) {
#line 666
    goto exit;
  } else {

  }
  {
#line 668
  gru_check_context_placement(gts);
  }
#line 673
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0) && (int )((signed char )gts->ts_force_cch_reload) != 0) {
    {
#line 674
    gts->ts_force_cch_reload = 0;
#line 675
    gru_update_cch(gts);
    }
  } else {

  }
#line 678
  ret = -11;
#line 679
  cbrnum = (int )gts->ts_cbr_idx[ucbnum / 2] * 2 + ucbnum % 2;
#line 680
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0)) {
    {
#line 681
    tfh = get_tfh((gts->ts_gru)->gs_gru_base_vaddr, cbrnum);
#line 682
    cbk = get_gseg_base_address_cb((gts->ts_gru)->gs_gru_base_vaddr, gts->ts_ctxnum,
                                   ucbnum);
#line 684
    ret = gru_user_dropin(gts, tfh, cbk);
    }
  } else {

  }
  exit: 
  {
#line 687
  gru_unlock_gts(gts);
  }
#line 688
  return (ret);
}
}
#line 695 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
int gru_get_exception_detail(unsigned long arg ) 
{ 
  struct control_block_extended_exc_detail excdet ;
  struct gru_control_block_extended *cbe ;
  struct gru_thread_state *gts ;
  int ucbnum ;
  int cbrnum ;
  int ret ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  unsigned long tmp___0 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  unsigned long tmp___1 ;

  {
#line 702
  if ((gru_options & 2UL) != 0UL) {
    {
#line 702
    atomic_long_inc(& gru_stats.user_exception);
    }
  } else {

  }
  {
#line 703
  tmp = copy_from_user((void *)(& excdet), (void const   *)arg, 48UL);
  }
#line 703
  if (tmp != 0UL) {
#line 704
    return (-14);
  } else {

  }
  {
#line 706
  gts = gru_find_lock_gts(excdet.cb);
  }
#line 707
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 708
    return (-22);
  } else {

  }
#line 710
  if ((int )gru_options & 1) {
#line 710
    __vpp_verify = (void const   *)0;
    {
#line 710
    if (4UL == 1UL) {
#line 710
      goto case_1;
    } else {

    }
#line 710
    if (4UL == 2UL) {
#line 710
      goto case_2___0;
    } else {

    }
#line 710
    if (4UL == 4UL) {
#line 710
      goto case_4___1;
    } else {

    }
#line 710
    if (4UL == 8UL) {
#line 710
      goto case_8___2;
    } else {

    }
#line 710
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 710
    if (4UL == 1UL) {
#line 710
      goto case_1___0;
    } else {

    }
#line 710
    if (4UL == 2UL) {
#line 710
      goto case_2;
    } else {

    }
#line 710
    if (4UL == 4UL) {
#line 710
      goto case_4;
    } else {

    }
#line 710
    if (4UL == 8UL) {
#line 710
      goto case_8;
    } else {

    }
#line 710
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 710
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 710
    goto ldv_36802;
    case_2: /* CIL Label */ 
#line 710
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 710
    goto ldv_36802;
    case_4: /* CIL Label */ 
#line 710
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 710
    goto ldv_36802;
    case_8: /* CIL Label */ 
#line 710
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 710
    goto ldv_36802;
    switch_default: /* CIL Label */ 
    {
#line 710
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_36802: 
#line 710
    pscr_ret__ = pfo_ret__;
#line 710
    goto ldv_36808;
    case_2___0: /* CIL Label */ ;
    {
#line 710
    if (4UL == 1UL) {
#line 710
      goto case_1___1;
    } else {

    }
#line 710
    if (4UL == 2UL) {
#line 710
      goto case_2___1;
    } else {

    }
#line 710
    if (4UL == 4UL) {
#line 710
      goto case_4___0;
    } else {

    }
#line 710
    if (4UL == 8UL) {
#line 710
      goto case_8___0;
    } else {

    }
#line 710
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 710
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 710
    goto ldv_36812;
    case_2___1: /* CIL Label */ 
#line 710
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 710
    goto ldv_36812;
    case_4___0: /* CIL Label */ 
#line 710
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 710
    goto ldv_36812;
    case_8___0: /* CIL Label */ 
#line 710
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 710
    goto ldv_36812;
    switch_default___0: /* CIL Label */ 
    {
#line 710
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_36812: 
#line 710
    pscr_ret__ = pfo_ret_____0;
#line 710
    goto ldv_36808;
    case_4___1: /* CIL Label */ ;
    {
#line 710
    if (4UL == 1UL) {
#line 710
      goto case_1___2;
    } else {

    }
#line 710
    if (4UL == 2UL) {
#line 710
      goto case_2___2;
    } else {

    }
#line 710
    if (4UL == 4UL) {
#line 710
      goto case_4___2;
    } else {

    }
#line 710
    if (4UL == 8UL) {
#line 710
      goto case_8___1;
    } else {

    }
#line 710
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 710
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 710
    goto ldv_36821;
    case_2___2: /* CIL Label */ 
#line 710
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 710
    goto ldv_36821;
    case_4___2: /* CIL Label */ 
#line 710
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 710
    goto ldv_36821;
    case_8___1: /* CIL Label */ 
#line 710
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 710
    goto ldv_36821;
    switch_default___1: /* CIL Label */ 
    {
#line 710
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_36821: 
#line 710
    pscr_ret__ = pfo_ret_____1;
#line 710
    goto ldv_36808;
    case_8___2: /* CIL Label */ ;
    {
#line 710
    if (4UL == 1UL) {
#line 710
      goto case_1___3;
    } else {

    }
#line 710
    if (4UL == 2UL) {
#line 710
      goto case_2___3;
    } else {

    }
#line 710
    if (4UL == 4UL) {
#line 710
      goto case_4___3;
    } else {

    }
#line 710
    if (4UL == 8UL) {
#line 710
      goto case_8___3;
    } else {

    }
#line 710
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 710
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 710
    goto ldv_36830;
    case_2___3: /* CIL Label */ 
#line 710
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 710
    goto ldv_36830;
    case_4___3: /* CIL Label */ 
#line 710
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 710
    goto ldv_36830;
    case_8___3: /* CIL Label */ 
#line 710
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 710
    goto ldv_36830;
    switch_default___2: /* CIL Label */ 
    {
#line 710
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_36830: 
#line 710
    pscr_ret__ = pfo_ret_____2;
#line 710
    goto ldv_36808;
    switch_default___3: /* CIL Label */ 
    {
#line 710
    __bad_size_call_parameter();
    }
#line 710
    goto ldv_36808;
    switch_break: /* CIL Label */ ;
    }
    ldv_36808: 
    {
#line 710
    printk("\017GRU:%d %s: address 0x%lx, gid %d, gts 0x%p\n", pscr_ret__, "gru_get_exception_detail",
           excdet.cb, (unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0) ? (int )(gts->ts_gru)->gs_gid : -1,
           gts);
    }
  } else {

  }
  {
#line 711
  tmp___0 = get_cb_number((void *)excdet.cb);
#line 711
  ucbnum = (int )tmp___0;
  }
#line 712
  if (ucbnum >= (int )gts->ts_cbr_au_count * 2) {
#line 713
    ret = -22;
  } else
#line 714
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0)) {
    {
#line 715
    cbrnum = (int )gts->ts_cbr_idx[ucbnum / 2] * 2 + ucbnum % 2;
#line 716
    cbe = get_cbe((gts->ts_gru)->gs_gru_base_vaddr, cbrnum);
#line 717
    gru_flush_cache((void *)cbe);
#line 718
    sync_core();
#line 719
    excdet.opc = (int )cbe->opccpy;
#line 720
    excdet.exopc = (int )cbe->exopccpy;
#line 721
    excdet.ecause = (int )cbe->ecause;
#line 722
    excdet.exceptdet0 = (long )cbe->idef1upd;
#line 723
    excdet.exceptdet1 = (int )cbe->idef3upd;
#line 724
    excdet.cbrstate = (int )cbe->cbrstate;
#line 725
    excdet.cbrexecstatus = (int )cbe->cbrexecstatus;
#line 726
    gru_flush_cache_cbe(cbe);
#line 727
    ret = 0;
    }
  } else {
#line 729
    ret = -11;
  }
  {
#line 731
  gru_unlock_gts(gts);
  }
#line 733
  if ((int )gru_options & 1) {
#line 733
    __vpp_verify___0 = (void const   *)0;
    {
#line 733
    if (4UL == 1UL) {
#line 733
      goto case_1___4;
    } else {

    }
#line 737
    if (4UL == 2UL) {
#line 737
      goto case_2___5;
    } else {

    }
#line 737
    if (4UL == 4UL) {
#line 737
      goto case_4___6;
    } else {

    }
#line 737
    if (4UL == 8UL) {
#line 737
      goto case_8___7;
    } else {

    }
#line 737
    goto switch_default___8;
    case_1___4: /* CIL Label */ ;
    {
#line 737
    if (4UL == 1UL) {
#line 737
      goto case_1___5;
    } else {

    }
#line 737
    if (4UL == 2UL) {
#line 737
      goto case_2___4;
    } else {

    }
#line 737
    if (4UL == 4UL) {
#line 737
      goto case_4___4;
    } else {

    }
#line 737
    if (4UL == 8UL) {
#line 737
      goto case_8___4;
    } else {

    }
#line 737
    goto switch_default___4;
    case_1___5: /* CIL Label */ 
#line 737
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 737
    goto ldv_36844;
    case_2___4: /* CIL Label */ 
#line 737
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 737
    goto ldv_36844;
    case_4___4: /* CIL Label */ 
#line 737
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 737
    goto ldv_36844;
    case_8___4: /* CIL Label */ 
#line 737
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 737
    goto ldv_36844;
    switch_default___4: /* CIL Label */ 
    {
#line 737
    __bad_percpu_size();
    }
    switch_break___5: /* CIL Label */ ;
    }
    ldv_36844: 
#line 737
    pscr_ret_____0 = pfo_ret_____3;
#line 737
    goto ldv_36850;
    case_2___5: /* CIL Label */ ;
    {
#line 737
    if (4UL == 1UL) {
#line 737
      goto case_1___6;
    } else {

    }
#line 737
    if (4UL == 2UL) {
#line 737
      goto case_2___6;
    } else {

    }
#line 737
    if (4UL == 4UL) {
#line 737
      goto case_4___5;
    } else {

    }
#line 737
    if (4UL == 8UL) {
#line 737
      goto case_8___5;
    } else {

    }
#line 737
    goto switch_default___5;
    case_1___6: /* CIL Label */ 
#line 737
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 737
    goto ldv_36854;
    case_2___6: /* CIL Label */ 
#line 737
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 737
    goto ldv_36854;
    case_4___5: /* CIL Label */ 
#line 737
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 737
    goto ldv_36854;
    case_8___5: /* CIL Label */ 
#line 737
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 737
    goto ldv_36854;
    switch_default___5: /* CIL Label */ 
    {
#line 737
    __bad_percpu_size();
    }
    switch_break___6: /* CIL Label */ ;
    }
    ldv_36854: 
#line 737
    pscr_ret_____0 = pfo_ret_____4;
#line 737
    goto ldv_36850;
    case_4___6: /* CIL Label */ ;
    {
#line 737
    if (4UL == 1UL) {
#line 737
      goto case_1___7;
    } else {

    }
#line 737
    if (4UL == 2UL) {
#line 737
      goto case_2___7;
    } else {

    }
#line 737
    if (4UL == 4UL) {
#line 737
      goto case_4___7;
    } else {

    }
#line 737
    if (4UL == 8UL) {
#line 737
      goto case_8___6;
    } else {

    }
#line 737
    goto switch_default___6;
    case_1___7: /* CIL Label */ 
#line 737
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 737
    goto ldv_36863;
    case_2___7: /* CIL Label */ 
#line 737
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 737
    goto ldv_36863;
    case_4___7: /* CIL Label */ 
#line 737
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 737
    goto ldv_36863;
    case_8___6: /* CIL Label */ 
#line 737
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 737
    goto ldv_36863;
    switch_default___6: /* CIL Label */ 
    {
#line 737
    __bad_percpu_size();
    }
    switch_break___7: /* CIL Label */ ;
    }
    ldv_36863: 
#line 737
    pscr_ret_____0 = pfo_ret_____5;
#line 737
    goto ldv_36850;
    case_8___7: /* CIL Label */ ;
    {
#line 737
    if (4UL == 1UL) {
#line 737
      goto case_1___8;
    } else {

    }
#line 737
    if (4UL == 2UL) {
#line 737
      goto case_2___8;
    } else {

    }
#line 737
    if (4UL == 4UL) {
#line 737
      goto case_4___8;
    } else {

    }
#line 737
    if (4UL == 8UL) {
#line 737
      goto case_8___8;
    } else {

    }
#line 737
    goto switch_default___7;
    case_1___8: /* CIL Label */ 
#line 737
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 737
    goto ldv_36872;
    case_2___8: /* CIL Label */ 
#line 737
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 737
    goto ldv_36872;
    case_4___8: /* CIL Label */ 
#line 737
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 737
    goto ldv_36872;
    case_8___8: /* CIL Label */ 
#line 737
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 737
    goto ldv_36872;
    switch_default___7: /* CIL Label */ 
    {
#line 737
    __bad_percpu_size();
    }
    switch_break___8: /* CIL Label */ ;
    }
    ldv_36872: 
#line 737
    pscr_ret_____0 = pfo_ret_____6;
#line 737
    goto ldv_36850;
    switch_default___8: /* CIL Label */ 
    {
#line 737
    __bad_size_call_parameter();
    }
#line 737
    goto ldv_36850;
    switch_break___4: /* CIL Label */ ;
    }
    ldv_36850: 
    {
#line 737
    printk("\017GRU:%d %s: cb 0x%lx, op %d, exopc %d, cbrstate %d, cbrexecstatus 0x%x, ecause 0x%x, exdet0 0x%lx, exdet1 0x%x\n",
           pscr_ret_____0, "gru_get_exception_detail", excdet.cb, excdet.opc, excdet.exopc,
           excdet.cbrstate, excdet.cbrexecstatus, excdet.ecause, excdet.exceptdet0,
           excdet.exceptdet1);
    }
  } else {

  }
#line 738
  if (ret == 0) {
    {
#line 738
    tmp___1 = copy_to_user((void *)arg, (void const   *)(& excdet), 48UL);
    }
#line 738
    if (tmp___1 != 0UL) {
#line 739
      ret = -14;
    } else {

    }
  } else {

  }
#line 740
  return (ret);
}
}
#line 746 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
static int gru_unload_all_contexts(void) 
{ 
  struct gru_thread_state *gts ;
  struct gru_state *gru ;
  int gid ;
  int ctxnum ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 752
  tmp = capable(21);
  }
#line 752
  if (tmp) {
#line 752
    tmp___0 = 0;
  } else {
#line 752
    tmp___0 = 1;
  }
#line 752
  if (tmp___0) {
#line 753
    return (-1);
  } else {

  }
#line 754
  gid = 0;
#line 754
  goto ldv_36891;
  ldv_36890: 
  {
#line 755
  gru = (unsigned long )gru_base[gid / 2] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[gid / 2])->bs_grus) + (unsigned long )(gid % 2) : (struct gru_state *)0;
#line 756
  ldv_spin_lock_108(& gru->gs_lock);
#line 757
  ctxnum = 0;
  }
#line 757
  goto ldv_36888;
  ldv_36887: 
#line 758
  gts = gru->gs_gts[ctxnum];
#line 759
  if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 759
    tmp___1 = ldv_mutex_trylock_104(& gts->ts_ctxlock);
    }
#line 759
    if (tmp___1 != 0) {
      {
#line 760
      ldv_spin_unlock_109(& gru->gs_lock);
#line 761
      gru_unload_context(gts, 1);
#line 762
      ldv_mutex_unlock_106(& gts->ts_ctxlock);
#line 763
      ldv_spin_lock_108(& gru->gs_lock);
      }
    } else {

    }
  } else {

  }
#line 757
  ctxnum = ctxnum + 1;
  ldv_36888: ;
#line 757
  if (ctxnum <= 15) {
#line 759
    goto ldv_36887;
  } else {

  }
  {
#line 766
  ldv_spin_unlock_109(& gru->gs_lock);
#line 754
  gid = gid + 1;
  }
  ldv_36891: ;
#line 754
  if ((unsigned int )gid < gru_max_gids) {
#line 756
    goto ldv_36890;
  } else {

  }

#line 768
  return (0);
}
}
#line 771 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
int gru_user_unload_context(unsigned long arg ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_unload_context_req req ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___0 ;

  {
#line 776
  if ((gru_options & 2UL) != 0UL) {
    {
#line 776
    atomic_long_inc(& gru_stats.user_unload_context);
    }
  } else {

  }
  {
#line 777
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 8UL);
  }
#line 777
  if (tmp != 0UL) {
#line 778
    return (-14);
  } else {

  }
#line 780
  if ((int )gru_options & 1) {
#line 780
    __vpp_verify = (void const   *)0;
    {
#line 780
    if (4UL == 1UL) {
#line 780
      goto case_1;
    } else {

    }
#line 780
    if (4UL == 2UL) {
#line 780
      goto case_2___0;
    } else {

    }
#line 780
    if (4UL == 4UL) {
#line 780
      goto case_4___1;
    } else {

    }
#line 780
    if (4UL == 8UL) {
#line 780
      goto case_8___2;
    } else {

    }
#line 780
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 780
    if (4UL == 1UL) {
#line 780
      goto case_1___0;
    } else {

    }
#line 780
    if (4UL == 2UL) {
#line 780
      goto case_2;
    } else {

    }
#line 780
    if (4UL == 4UL) {
#line 780
      goto case_4;
    } else {

    }
#line 780
    if (4UL == 8UL) {
#line 780
      goto case_8;
    } else {

    }
#line 780
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 780
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 780
    goto ldv_36903;
    case_2: /* CIL Label */ 
#line 780
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 780
    goto ldv_36903;
    case_4: /* CIL Label */ 
#line 780
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 780
    goto ldv_36903;
    case_8: /* CIL Label */ 
#line 780
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 780
    goto ldv_36903;
    switch_default: /* CIL Label */ 
    {
#line 780
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_36903: 
#line 780
    pscr_ret__ = pfo_ret__;
#line 780
    goto ldv_36909;
    case_2___0: /* CIL Label */ ;
    {
#line 780
    if (4UL == 1UL) {
#line 780
      goto case_1___1;
    } else {

    }
#line 780
    if (4UL == 2UL) {
#line 780
      goto case_2___1;
    } else {

    }
#line 780
    if (4UL == 4UL) {
#line 780
      goto case_4___0;
    } else {

    }
#line 780
    if (4UL == 8UL) {
#line 780
      goto case_8___0;
    } else {

    }
#line 780
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 780
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 780
    goto ldv_36913;
    case_2___1: /* CIL Label */ 
#line 780
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 780
    goto ldv_36913;
    case_4___0: /* CIL Label */ 
#line 780
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 780
    goto ldv_36913;
    case_8___0: /* CIL Label */ 
#line 780
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 780
    goto ldv_36913;
    switch_default___0: /* CIL Label */ 
    {
#line 780
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_36913: 
#line 780
    pscr_ret__ = pfo_ret_____0;
#line 780
    goto ldv_36909;
    case_4___1: /* CIL Label */ ;
    {
#line 780
    if (4UL == 1UL) {
#line 780
      goto case_1___2;
    } else {

    }
#line 780
    if (4UL == 2UL) {
#line 780
      goto case_2___2;
    } else {

    }
#line 780
    if (4UL == 4UL) {
#line 780
      goto case_4___2;
    } else {

    }
#line 780
    if (4UL == 8UL) {
#line 780
      goto case_8___1;
    } else {

    }
#line 780
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 780
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 780
    goto ldv_36922;
    case_2___2: /* CIL Label */ 
#line 780
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 780
    goto ldv_36922;
    case_4___2: /* CIL Label */ 
#line 780
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 780
    goto ldv_36922;
    case_8___1: /* CIL Label */ 
#line 780
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 780
    goto ldv_36922;
    switch_default___1: /* CIL Label */ 
    {
#line 780
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_36922: 
#line 780
    pscr_ret__ = pfo_ret_____1;
#line 780
    goto ldv_36909;
    case_8___2: /* CIL Label */ ;
    {
#line 780
    if (4UL == 1UL) {
#line 780
      goto case_1___3;
    } else {

    }
#line 780
    if (4UL == 2UL) {
#line 780
      goto case_2___3;
    } else {

    }
#line 780
    if (4UL == 4UL) {
#line 780
      goto case_4___3;
    } else {

    }
#line 780
    if (4UL == 8UL) {
#line 780
      goto case_8___3;
    } else {

    }
#line 780
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 780
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 780
    goto ldv_36931;
    case_2___3: /* CIL Label */ 
#line 780
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 780
    goto ldv_36931;
    case_4___3: /* CIL Label */ 
#line 780
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 780
    goto ldv_36931;
    case_8___3: /* CIL Label */ 
#line 780
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 780
    goto ldv_36931;
    switch_default___2: /* CIL Label */ 
    {
#line 780
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_36931: 
#line 780
    pscr_ret__ = pfo_ret_____2;
#line 780
    goto ldv_36909;
    switch_default___3: /* CIL Label */ 
    {
#line 780
    __bad_size_call_parameter();
    }
#line 780
    goto ldv_36909;
    switch_break: /* CIL Label */ ;
    }
    ldv_36909: 
    {
#line 780
    printk("\017GRU:%d %s: gseg 0x%lx\n", pscr_ret__, "gru_user_unload_context", req.gseg);
    }
  } else {

  }
#line 782
  if (req.gseg == 0UL) {
    {
#line 783
    tmp___0 = gru_unload_all_contexts();
    }
#line 783
    return (tmp___0);
  } else {

  }
  {
#line 785
  gts = gru_find_lock_gts(req.gseg);
  }
#line 786
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 787
    return (-22);
  } else {

  }
#line 789
  if ((unsigned long )gts->ts_gru != (unsigned long )((struct gru_state *)0)) {
    {
#line 790
    gru_unload_context(gts, 1);
    }
  } else {

  }
  {
#line 791
  gru_unlock_gts(gts);
  }
#line 793
  return (0);
}
}
#line 800 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
int gru_user_flush_tlb(unsigned long arg ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_flush_tlb_req req ;
  struct gru_mm_struct *gms ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 806
  if ((gru_options & 2UL) != 0UL) {
    {
#line 806
    atomic_long_inc(& gru_stats.user_flush_tlb);
    }
  } else {

  }
  {
#line 807
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 24UL);
  }
#line 807
  if (tmp != 0UL) {
#line 808
    return (-14);
  } else {

  }
#line 810
  if ((int )gru_options & 1) {
#line 810
    __vpp_verify = (void const   *)0;
    {
#line 810
    if (4UL == 1UL) {
#line 810
      goto case_1;
    } else {

    }
#line 811
    if (4UL == 2UL) {
#line 811
      goto case_2___0;
    } else {

    }
#line 811
    if (4UL == 4UL) {
#line 811
      goto case_4___1;
    } else {

    }
#line 811
    if (4UL == 8UL) {
#line 811
      goto case_8___2;
    } else {

    }
#line 811
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 811
    if (4UL == 1UL) {
#line 811
      goto case_1___0;
    } else {

    }
#line 811
    if (4UL == 2UL) {
#line 811
      goto case_2;
    } else {

    }
#line 811
    if (4UL == 4UL) {
#line 811
      goto case_4;
    } else {

    }
#line 811
    if (4UL == 8UL) {
#line 811
      goto case_8;
    } else {

    }
#line 811
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 811
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 811
    goto ldv_36951;
    case_2: /* CIL Label */ 
#line 811
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 811
    goto ldv_36951;
    case_4: /* CIL Label */ 
#line 811
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 811
    goto ldv_36951;
    case_8: /* CIL Label */ 
#line 811
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 811
    goto ldv_36951;
    switch_default: /* CIL Label */ 
    {
#line 811
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_36951: 
#line 811
    pscr_ret__ = pfo_ret__;
#line 811
    goto ldv_36957;
    case_2___0: /* CIL Label */ ;
    {
#line 811
    if (4UL == 1UL) {
#line 811
      goto case_1___1;
    } else {

    }
#line 811
    if (4UL == 2UL) {
#line 811
      goto case_2___1;
    } else {

    }
#line 811
    if (4UL == 4UL) {
#line 811
      goto case_4___0;
    } else {

    }
#line 811
    if (4UL == 8UL) {
#line 811
      goto case_8___0;
    } else {

    }
#line 811
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 811
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 811
    goto ldv_36961;
    case_2___1: /* CIL Label */ 
#line 811
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 811
    goto ldv_36961;
    case_4___0: /* CIL Label */ 
#line 811
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 811
    goto ldv_36961;
    case_8___0: /* CIL Label */ 
#line 811
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 811
    goto ldv_36961;
    switch_default___0: /* CIL Label */ 
    {
#line 811
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_36961: 
#line 811
    pscr_ret__ = pfo_ret_____0;
#line 811
    goto ldv_36957;
    case_4___1: /* CIL Label */ ;
    {
#line 811
    if (4UL == 1UL) {
#line 811
      goto case_1___2;
    } else {

    }
#line 811
    if (4UL == 2UL) {
#line 811
      goto case_2___2;
    } else {

    }
#line 811
    if (4UL == 4UL) {
#line 811
      goto case_4___2;
    } else {

    }
#line 811
    if (4UL == 8UL) {
#line 811
      goto case_8___1;
    } else {

    }
#line 811
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 811
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 811
    goto ldv_36970;
    case_2___2: /* CIL Label */ 
#line 811
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 811
    goto ldv_36970;
    case_4___2: /* CIL Label */ 
#line 811
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 811
    goto ldv_36970;
    case_8___1: /* CIL Label */ 
#line 811
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 811
    goto ldv_36970;
    switch_default___1: /* CIL Label */ 
    {
#line 811
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_36970: 
#line 811
    pscr_ret__ = pfo_ret_____1;
#line 811
    goto ldv_36957;
    case_8___2: /* CIL Label */ ;
    {
#line 811
    if (4UL == 1UL) {
#line 811
      goto case_1___3;
    } else {

    }
#line 811
    if (4UL == 2UL) {
#line 811
      goto case_2___3;
    } else {

    }
#line 811
    if (4UL == 4UL) {
#line 811
      goto case_4___3;
    } else {

    }
#line 811
    if (4UL == 8UL) {
#line 811
      goto case_8___3;
    } else {

    }
#line 811
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 811
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 811
    goto ldv_36979;
    case_2___3: /* CIL Label */ 
#line 811
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 811
    goto ldv_36979;
    case_4___3: /* CIL Label */ 
#line 811
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 811
    goto ldv_36979;
    case_8___3: /* CIL Label */ 
#line 811
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 811
    goto ldv_36979;
    switch_default___2: /* CIL Label */ 
    {
#line 811
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_36979: 
#line 811
    pscr_ret__ = pfo_ret_____2;
#line 811
    goto ldv_36957;
    switch_default___3: /* CIL Label */ 
    {
#line 811
    __bad_size_call_parameter();
    }
#line 811
    goto ldv_36957;
    switch_break: /* CIL Label */ ;
    }
    ldv_36957: 
    {
#line 811
    printk("\017GRU:%d %s: gseg 0x%lx, vaddr 0x%lx, len 0x%lx\n", pscr_ret__, "gru_user_flush_tlb",
           req.gseg, req.vaddr, req.len);
    }
  } else {

  }
  {
#line 813
  gts = gru_find_lock_gts(req.gseg);
  }
#line 814
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
#line 815
    return (-22);
  } else {

  }
  {
#line 817
  gms = gts->ts_gms;
#line 818
  gru_unlock_gts(gts);
#line 819
  gru_flush_tlb_range(gms, req.vaddr, req.len);
  }
#line 821
  return (0);
}
}
#line 827 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
long gru_get_gseg_statistics(unsigned long arg ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_get_gseg_statistics_req req ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 832
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 120UL);
  }
#line 832
  if (tmp != 0UL) {
#line 833
    return (-14L);
  } else {

  }
  {
#line 840
  gts = gru_find_lock_gts(req.gseg);
  }
#line 841
  if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 842
    __memcpy((void *)(& req.stats), (void const   *)(& gts->ustats), 112UL);
#line 843
    gru_unlock_gts(gts);
    }
  } else {
    {
#line 845
    __memset((void *)(& req.stats), 0, 112UL);
    }
  }
  {
#line 848
  tmp___0 = copy_to_user((void *)arg, (void const   *)(& req), 120UL);
  }
#line 848
  if (tmp___0 != 0UL) {
#line 849
    return (-14L);
  } else {

  }
#line 851
  return (0L);
}
}
#line 858 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grufault.c"
int gru_set_context_option(unsigned long arg ) 
{ 
  struct gru_thread_state *gts ;
  struct gru_set_context_option_req req ;
  int ret ;
  unsigned long tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  long tmp___0 ;
  bool tmp___1 ;
  struct task_struct *tmp___2 ;

  {
#line 862
  ret = 0;
#line 864
  if ((gru_options & 2UL) != 0UL) {
    {
#line 864
    atomic_long_inc(& gru_stats.set_context_option);
    }
  } else {

  }
  {
#line 865
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 24UL);
  }
#line 865
  if (tmp != 0UL) {
#line 866
    return (-14);
  } else {

  }
#line 867
  if ((int )gru_options & 1) {
#line 867
    __vpp_verify = (void const   *)0;
    {
#line 867
    if (4UL == 1UL) {
#line 867
      goto case_1;
    } else {

    }
#line 867
    if (4UL == 2UL) {
#line 867
      goto case_2___0;
    } else {

    }
#line 867
    if (4UL == 4UL) {
#line 867
      goto case_4___1;
    } else {

    }
#line 867
    if (4UL == 8UL) {
#line 867
      goto case_8___2;
    } else {

    }
#line 867
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 867
    if (4UL == 1UL) {
#line 867
      goto case_1___0;
    } else {

    }
#line 867
    if (4UL == 2UL) {
#line 867
      goto case_2;
    } else {

    }
#line 867
    if (4UL == 4UL) {
#line 867
      goto case_4;
    } else {

    }
#line 867
    if (4UL == 8UL) {
#line 867
      goto case_8;
    } else {

    }
#line 867
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 867
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 867
    goto ldv_37004;
    case_2: /* CIL Label */ 
#line 867
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 867
    goto ldv_37004;
    case_4: /* CIL Label */ 
#line 867
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 867
    goto ldv_37004;
    case_8: /* CIL Label */ 
#line 867
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 867
    goto ldv_37004;
    switch_default: /* CIL Label */ 
    {
#line 867
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_37004: 
#line 867
    pscr_ret__ = pfo_ret__;
#line 867
    goto ldv_37010;
    case_2___0: /* CIL Label */ ;
    {
#line 867
    if (4UL == 1UL) {
#line 867
      goto case_1___1;
    } else {

    }
#line 867
    if (4UL == 2UL) {
#line 867
      goto case_2___1;
    } else {

    }
#line 867
    if (4UL == 4UL) {
#line 867
      goto case_4___0;
    } else {

    }
#line 867
    if (4UL == 8UL) {
#line 867
      goto case_8___0;
    } else {

    }
#line 867
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 867
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 867
    goto ldv_37014;
    case_2___1: /* CIL Label */ 
#line 867
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 867
    goto ldv_37014;
    case_4___0: /* CIL Label */ 
#line 867
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 867
    goto ldv_37014;
    case_8___0: /* CIL Label */ 
#line 867
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 867
    goto ldv_37014;
    switch_default___0: /* CIL Label */ 
    {
#line 867
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_37014: 
#line 867
    pscr_ret__ = pfo_ret_____0;
#line 867
    goto ldv_37010;
    case_4___1: /* CIL Label */ ;
    {
#line 867
    if (4UL == 1UL) {
#line 867
      goto case_1___2;
    } else {

    }
#line 867
    if (4UL == 2UL) {
#line 867
      goto case_2___2;
    } else {

    }
#line 867
    if (4UL == 4UL) {
#line 867
      goto case_4___2;
    } else {

    }
#line 867
    if (4UL == 8UL) {
#line 867
      goto case_8___1;
    } else {

    }
#line 867
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 867
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 867
    goto ldv_37023;
    case_2___2: /* CIL Label */ 
#line 867
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 867
    goto ldv_37023;
    case_4___2: /* CIL Label */ 
#line 867
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 867
    goto ldv_37023;
    case_8___1: /* CIL Label */ 
#line 867
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 867
    goto ldv_37023;
    switch_default___1: /* CIL Label */ 
    {
#line 867
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_37023: 
#line 867
    pscr_ret__ = pfo_ret_____1;
#line 867
    goto ldv_37010;
    case_8___2: /* CIL Label */ ;
    {
#line 867
    if (4UL == 1UL) {
#line 867
      goto case_1___3;
    } else {

    }
#line 867
    if (4UL == 2UL) {
#line 867
      goto case_2___3;
    } else {

    }
#line 867
    if (4UL == 4UL) {
#line 867
      goto case_4___3;
    } else {

    }
#line 867
    if (4UL == 8UL) {
#line 867
      goto case_8___3;
    } else {

    }
#line 867
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 867
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 867
    goto ldv_37032;
    case_2___3: /* CIL Label */ 
#line 867
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 867
    goto ldv_37032;
    case_4___3: /* CIL Label */ 
#line 867
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 867
    goto ldv_37032;
    case_8___3: /* CIL Label */ 
#line 867
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 867
    goto ldv_37032;
    switch_default___2: /* CIL Label */ 
    {
#line 867
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_37032: 
#line 867
    pscr_ret__ = pfo_ret_____2;
#line 867
    goto ldv_37010;
    switch_default___3: /* CIL Label */ 
    {
#line 867
    __bad_size_call_parameter();
    }
#line 867
    goto ldv_37010;
    switch_break: /* CIL Label */ ;
    }
    ldv_37010: 
    {
#line 867
    printk("\017GRU:%d %s: op %d, gseg 0x%lx, value1 0x%lx\n", pscr_ret__, "gru_set_context_option",
           req.op, req.gseg, req.val1);
    }
  } else {

  }
  {
#line 869
  gts = gru_find_lock_gts(req.gseg);
  }
#line 870
  if ((unsigned long )gts == (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 871
    gts = gru_alloc_locked_gts(req.gseg);
#line 872
    tmp___1 = IS_ERR((void const   *)gts);
    }
#line 872
    if ((int )tmp___1) {
      {
#line 873
      tmp___0 = PTR_ERR((void const   *)gts);
      }
#line 873
      return ((int )tmp___0);
    } else {

    }
  } else {

  }
  {
#line 877
  if (req.op == 2) {
#line 877
    goto case_2___4;
  } else {

  }
#line 889
  if (req.op == 0) {
#line 889
    goto case_0;
  } else {

  }
#line 893
  if (req.op == 1) {
#line 893
    goto case_1___4;
  } else {

  }
#line 897
  goto switch_default___4;
  case_2___4: /* CIL Label */ ;
#line 879
  if ((((unsigned int )req.val0 - 4294967295U > 2U || req.val1 < -1L) || req.val1 > 1023L) || (req.val1 >= 0L && (unsigned long )gru_base[req.val1] == (unsigned long )((struct gru_blade_state *)0))) {
#line 882
    ret = -22;
  } else {
    {
#line 884
    gts->ts_user_blade_id = (short )req.val1;
#line 885
    gts->ts_user_chiplet_id = (char )req.val0;
#line 886
    gru_check_context_placement(gts);
    }
  }
#line 888
  goto ldv_37042;
  case_0: /* CIL Label */ 
  {
#line 891
  tmp___2 = get_current___1();
#line 891
  gts->ts_tgid_owner = tmp___2->tgid;
  }
#line 892
  goto ldv_37042;
  case_1___4: /* CIL Label */ 
#line 895
  gts->ts_cch_req_slice = (int )((char )req.val1) & 3;
#line 896
  goto ldv_37042;
  switch_default___4: /* CIL Label */ 
#line 898
  ret = -22;
  switch_break___4: /* CIL Label */ ;
  }
  ldv_37042: 
  {
#line 900
  gru_unlock_gts(gts);
  }
#line 902
  return (ret);
}
}
#line 699 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 702
  tmp = ldv_ptr_err(ptr);
  }
#line 702
  return (tmp);
}
}
#line 1347 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static void ldv_mutex_lock_96(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1351
  ldv_linux_kernel_locking_mutex_mutex_lock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1352
  return;
}
}
#line 1354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static void ldv_mutex_lock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1358
  ldv_linux_kernel_locking_mutex_mutex_lock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1359
  return;
}
}
#line 1361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1365
  ldv_linux_kernel_locking_mutex_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1366
  return;
}
}
#line 1368 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static unsigned long ldv_find_first_bit_99(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1371
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1371
  return (tmp);
}
}
#line 1374 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static unsigned long ldv_find_next_bit_100(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1377
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1377
  return (tmp);
}
}
#line 1380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static unsigned long ldv_find_first_bit_101(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1383
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1383
  return (tmp);
}
}
#line 1386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static unsigned long ldv_find_next_bit_102(unsigned long const   *addr , unsigned long size ,
                                           unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1389
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1389
  return (tmp);
}
}
#line 1400 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static int ldv_mutex_trylock_104(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 1404
  tmp = ldv_linux_kernel_locking_mutex_mutex_trylock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1404
  return (tmp);
}
}
#line 1415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grufault.c.aux"
static void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1419
  ldv_linux_kernel_locking_mutex_mutex_unlock_ts_ctxlock_of_gru_thread_state(ldv_func_arg1);
  }
#line 1420
  return;
}
}
#line 217 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
void *ldv_kzalloc(size_t size , gfp_t flags ) ;
#line 226
int ldv_linux_usb_dev_atomic_dec_and_test(atomic_t *v ) ;
#line 336
void ldv_linux_kernel_rcu_update_lock_rcu_read_lock(void) ;
#line 337
void ldv_linux_kernel_rcu_update_lock_rcu_read_unlock(void) ;
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
extern struct pv_cpu_ops pv_cpu_ops ;
#line 437 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bitops/find.h"
static unsigned long ldv_find_next_bit_98(unsigned long const   *addr , unsigned long size ,
                                          unsigned long offset ) ;
#line 54
static unsigned long ldv_find_first_bit_97(unsigned long const   *addr , unsigned long size ) ;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current___2(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  {
#line 14
  if (8UL == 1UL) {
#line 14
    goto case_1;
  } else {

  }
#line 14
  if (8UL == 2UL) {
#line 14
    goto case_2;
  } else {

  }
#line 14
  if (8UL == 4UL) {
#line 14
    goto case_4;
  } else {

  }
#line 14
  if (8UL == 8UL) {
#line 14
    goto case_8;
  } else {

  }
#line 14
  goto switch_default;
  case_1: /* CIL Label */ 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3544;
  case_2: /* CIL Label */ 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3544;
  case_4: /* CIL Label */ 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3544;
  case_8: /* CIL Label */ 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3544;
  switch_default: /* CIL Label */ 
  {
#line 14
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_3544: ;
#line 14
  return (pfo_ret__);
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static u64 paravirt_read_tsc(void) 
{ 
  u64 __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  {
#line 179
  __edi = __edi;
#line 179
  __esi = __esi;
#line 179
  __edx = __edx;
#line 179
  __ecx = __ecx;
#line 179
  __eax = __eax;
#line 179
  tmp = __builtin_expect((unsigned long )pv_cpu_ops.read_tsc == (unsigned long )((u64 (*)(void))0),
                         0L);
  }
#line 179
  if (tmp != 0L) {
    {
#line 179
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (179), "i" (12UL));
#line 179
    __builtin_unreachable();
    }
  } else {

  }
#line 179
  __asm__  volatile   ("771:\n\tcall *%c6;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c5\n  .byte 772b-771b\n  .short %c7\n.popsection\n": "=D" (__edi),
                       "=S" (__esi), "=d" (__edx), "=c" (__ecx), "=a" (__eax): [paravirt_typenum] "i" (34UL),
                       [paravirt_opptr] "i" (& pv_cpu_ops.read_tsc), [paravirt_clobber] "i" (511): "memory",
                       "cc", "r8", "r9", "r10", "r11");
#line 179
  __ret = (unsigned long long )__eax;
#line 179
  return (__ret);
}
}
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static void *ERR_PTR(long error ) ;
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_inc(atomic_t *v ) ;
#line 120
__inline static int atomic_dec_and_test(atomic_t *v ) ;
#line 159
__inline static int atomic_add_return(int i , atomic_t *v ) ;
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_sub_return___0(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 173
  tmp = atomic_add_return(- i, v);
  }
#line 173
  return (tmp);
}
}
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add___0(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
  {
#line 72
  if (4UL == 1UL) {
#line 72
    goto case_1;
  } else {

  }
#line 72
  if (4UL == 2UL) {
#line 72
    goto case_2;
  } else {

  }
#line 72
  if (4UL == 4UL) {
#line 72
    goto case_4;
  } else {

  }
#line 72
  if (4UL == 8UL) {
#line 72
    goto case_8;
  } else {

  }
#line 72
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_7188;
  case_2: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_7188;
  case_4: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_7188;
  case_8: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_7188;
  switch_default: /* CIL Label */ 
  {
#line 72
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7188: ;
#line 74
  return;
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub___0(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8;
  } else {

  }
#line 77
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_7200;
  case_2: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_7200;
  case_4: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_7200;
  case_8: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_7200;
  switch_default: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7200: ;
#line 79
  return;
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_lock_96(spinlock_t *lock ) ;
#line 399
__inline static void ldv_spin_unlock_99(spinlock_t *lock ) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
extern int debug_lockdep_rcu_enabled(void) ;
#line 433
extern int rcu_read_lock_held(void) ;
#line 878
__inline static void rcu_read_lock(void) ;
#line 936
__inline static void rcu_read_unlock(void) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/tsc.h"
__inline static cycles_t get_cycles(void) 
{ 
  unsigned long long ret ;

  {
  {
#line 24
  ret = 0ULL;
#line 30
  ret = paravirt_read_tsc();
  }
#line 32
  return (ret);
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmu_notifier.h"
extern int __mmu_notifier_register(struct mmu_notifier * , struct mm_struct * ) ;
#line 199
static int ldv___mmu_notifier_register_100(struct mmu_notifier *ldv_func_arg1 , struct mm_struct *ldv_func_arg2 ) ;
#line 201
extern void mmu_notifier_unregister(struct mmu_notifier * , struct mm_struct * ) ;
#line 205
static void ldv_mmu_notifier_unregister_101(struct mmu_notifier *ldv_func_arg1 , struct mm_struct *ldv_func_arg2 ) ;
#line 124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static struct gru_tlb_global_handle *get_tgh(void *base , int ctxnum ) 
{ 


  {
#line 126
  return ((struct gru_tlb_global_handle *)(base + ((unsigned long )(ctxnum * 256) + 67141632UL)));
}
}
#line 520
int tgh_invalidate(struct gru_tlb_global_handle *tgh , unsigned long vaddr , unsigned long vaddrmask ,
                   int asid , int pagesize , int global , int n , unsigned short ctxbitmap ) ;
#line 570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static void __lock_handle___0(void *h ) 
{ 
  int tmp ;

  {
#line 572
  goto ldv_33003;
  ldv_33002: 
  {
#line 573
  cpu_relax();
  }
  ldv_33003: 
  {
#line 572
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)h);
  }
#line 572
  if (tmp != 0) {
#line 574
    goto ldv_33002;
  } else {

  }

#line 579
  return;
}
}
#line 597 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static void lock_tgh_handle(struct gru_tlb_global_handle *tgh ) 
{ 


  {
  {
#line 599
  __lock_handle___0((void *)tgh);
  }
#line 600
  return;
}
}
#line 602 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static void unlock_tgh_handle(struct gru_tlb_global_handle *tgh ) 
{ 


  {
  {
#line 604
  __unlock_handle((void *)tgh);
  }
#line 605
  return;
}
}
#line 504 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static int uv_blade_processor_id(void) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 506
  __vpp_verify = (void const   *)0;
#line 506
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 506
  return ((int )((struct uv_hub_info_s *)tcp_ptr__)->blade_processor_id);
}
}
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
__inline static int get_off_blade_tgh(struct gru_state *gru ) 
{ 
  int n ;
  cycles_t tmp ;

  {
  {
#line 64
  n = 24 - (int )gru->gs_tgh_first_remote;
#line 65
  tmp = get_cycles();
#line 65
  n = (int )(tmp % (cycles_t )n);
#line 66
  n = n + (int )gru->gs_tgh_first_remote;
  }
#line 67
  return (n);
}
}
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
__inline static int get_on_blade_tgh(struct gru_state *gru ) 
{ 
  int tmp ;

  {
  {
#line 72
  tmp = uv_blade_processor_id();
  }
#line 72
  return (tmp >> (int )gru->gs_tgh_local_shift);
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
static struct gru_tlb_global_handle *get_lock_tgh_handle(struct gru_state *gru ) 
{ 
  struct gru_tlb_global_handle *tgh ;
  int n ;
  int tmp ;

  {
  {
#line 81
  __preempt_count_add___0(1);
#line 81
  __asm__  volatile   ("": : : "memory");
#line 82
  tmp = uv_numa_blade_id();
  }
#line 82
  if (tmp == (int )gru->gs_blade_id) {
    {
#line 83
    n = get_on_blade_tgh(gru);
    }
  } else {
    {
#line 85
    n = get_off_blade_tgh(gru);
    }
  }
  {
#line 86
  tgh = get_tgh(gru->gs_gru_base_vaddr, n);
#line 87
  lock_tgh_handle(tgh);
  }
#line 89
  return (tgh);
}
}
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
static void get_unlock_tgh_handle(struct gru_tlb_global_handle *tgh ) 
{ 


  {
  {
#line 94
  unlock_tgh_handle(tgh);
#line 95
  __asm__  volatile   ("": : : "memory");
#line 95
  __preempt_count_sub___0(1);
  }
#line 96
  return;
}
}
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
void gru_flush_tlb_range(struct gru_mm_struct *gms , unsigned long start , unsigned long len ) 
{ 
  struct gru_state *gru ;
  struct gru_mm_tracker *asids ;
  struct gru_tlb_global_handle *tgh ;
  unsigned long num ;
  int grupagesize ;
  int pagesize ;
  int pageshift ;
  int gid ;
  int asid ;
  unsigned long _min1 ;
  unsigned long _min2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  unsigned long tmp ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  unsigned long tmp___0 ;

  {
#line 168
  pageshift = 12;
#line 169
  pagesize = (int )(1UL << pageshift);
#line 170
  grupagesize = pageshift > 20 ? ((pageshift + 2) >> 1) + -6 : (pageshift >> 1) + -6;
#line 171
  _min1 = ((len + (unsigned long )pagesize) - 1UL) >> pageshift;
#line 171
  _min2 = 1024UL;
#line 171
  num = _min1 < _min2 ? _min1 : _min2;
#line 173
  if ((gru_options & 2UL) != 0UL) {
    {
#line 173
    atomic_long_inc(& gru_stats.flush_tlb);
    }
  } else {

  }
#line 174
  if ((int )gru_options & 1) {
#line 174
    __vpp_verify = (void const   *)0;
    {
#line 174
    if (4UL == 1UL) {
#line 174
      goto case_1;
    } else {

    }
#line 175
    if (4UL == 2UL) {
#line 175
      goto case_2___0;
    } else {

    }
#line 175
    if (4UL == 4UL) {
#line 175
      goto case_4___1;
    } else {

    }
#line 175
    if (4UL == 8UL) {
#line 175
      goto case_8___2;
    } else {

    }
#line 175
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 175
    if (4UL == 1UL) {
#line 175
      goto case_1___0;
    } else {

    }
#line 175
    if (4UL == 2UL) {
#line 175
      goto case_2;
    } else {

    }
#line 175
    if (4UL == 4UL) {
#line 175
      goto case_4;
    } else {

    }
#line 175
    if (4UL == 8UL) {
#line 175
      goto case_8;
    } else {

    }
#line 175
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 175
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 175
    goto ldv_34591;
    case_2: /* CIL Label */ 
#line 175
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 175
    goto ldv_34591;
    case_4: /* CIL Label */ 
#line 175
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 175
    goto ldv_34591;
    case_8: /* CIL Label */ 
#line 175
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 175
    goto ldv_34591;
    switch_default: /* CIL Label */ 
    {
#line 175
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34591: 
#line 175
    pscr_ret__ = pfo_ret__;
#line 175
    goto ldv_34597;
    case_2___0: /* CIL Label */ ;
    {
#line 175
    if (4UL == 1UL) {
#line 175
      goto case_1___1;
    } else {

    }
#line 175
    if (4UL == 2UL) {
#line 175
      goto case_2___1;
    } else {

    }
#line 175
    if (4UL == 4UL) {
#line 175
      goto case_4___0;
    } else {

    }
#line 175
    if (4UL == 8UL) {
#line 175
      goto case_8___0;
    } else {

    }
#line 175
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 175
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 175
    goto ldv_34601;
    case_2___1: /* CIL Label */ 
#line 175
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 175
    goto ldv_34601;
    case_4___0: /* CIL Label */ 
#line 175
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 175
    goto ldv_34601;
    case_8___0: /* CIL Label */ 
#line 175
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 175
    goto ldv_34601;
    switch_default___0: /* CIL Label */ 
    {
#line 175
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34601: 
#line 175
    pscr_ret__ = pfo_ret_____0;
#line 175
    goto ldv_34597;
    case_4___1: /* CIL Label */ ;
    {
#line 175
    if (4UL == 1UL) {
#line 175
      goto case_1___2;
    } else {

    }
#line 175
    if (4UL == 2UL) {
#line 175
      goto case_2___2;
    } else {

    }
#line 175
    if (4UL == 4UL) {
#line 175
      goto case_4___2;
    } else {

    }
#line 175
    if (4UL == 8UL) {
#line 175
      goto case_8___1;
    } else {

    }
#line 175
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 175
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 175
    goto ldv_34610;
    case_2___2: /* CIL Label */ 
#line 175
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 175
    goto ldv_34610;
    case_4___2: /* CIL Label */ 
#line 175
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 175
    goto ldv_34610;
    case_8___1: /* CIL Label */ 
#line 175
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 175
    goto ldv_34610;
    switch_default___1: /* CIL Label */ 
    {
#line 175
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34610: 
#line 175
    pscr_ret__ = pfo_ret_____1;
#line 175
    goto ldv_34597;
    case_8___2: /* CIL Label */ ;
    {
#line 175
    if (4UL == 1UL) {
#line 175
      goto case_1___3;
    } else {

    }
#line 175
    if (4UL == 2UL) {
#line 175
      goto case_2___3;
    } else {

    }
#line 175
    if (4UL == 4UL) {
#line 175
      goto case_4___3;
    } else {

    }
#line 175
    if (4UL == 8UL) {
#line 175
      goto case_8___3;
    } else {

    }
#line 175
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 175
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 175
    goto ldv_34619;
    case_2___3: /* CIL Label */ 
#line 175
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 175
    goto ldv_34619;
    case_4___3: /* CIL Label */ 
#line 175
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 175
    goto ldv_34619;
    case_8___3: /* CIL Label */ 
#line 175
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 175
    goto ldv_34619;
    switch_default___2: /* CIL Label */ 
    {
#line 175
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34619: 
#line 175
    pscr_ret__ = pfo_ret_____2;
#line 175
    goto ldv_34597;
    switch_default___3: /* CIL Label */ 
    {
#line 175
    __bad_size_call_parameter();
    }
#line 175
    goto ldv_34597;
    switch_break: /* CIL Label */ ;
    }
    ldv_34597: 
    {
#line 175
    printk("\017GRU:%d %s: gms %p, start 0x%lx, len 0x%lx, asidmap 0x%lx\n", pscr_ret__,
           "gru_flush_tlb_range", gms, start, len, gms->ms_asidmap[0]);
    }
  } else {

  }
  {
#line 177
  ldv_spin_lock_96(& gms->ms_asid_lock);
#line 178
  tmp = ldv_find_first_bit_97((unsigned long const   *)(& gms->ms_asidmap), 2048UL);
#line 178
  gid = (int )tmp;
  }
#line 178
  goto ldv_34711;
  ldv_34710: ;
#line 179
  if ((gru_options & 2UL) != 0UL) {
    {
#line 179
    atomic_long_inc(& gru_stats.flush_tlb_gru);
    }
  } else {

  }
#line 180
  gru = (unsigned long )gru_base[gid / 2] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[gid / 2])->bs_grus) + (unsigned long )(gid % 2) : (struct gru_state *)0;
#line 181
  asids = (struct gru_mm_tracker *)(& gms->ms_asids) + (unsigned long )gid;
#line 182
  asid = (int )asids->mt_asid;
#line 183
  if ((unsigned int )asids->mt_ctxbitmap != 0U && asid != 0) {
#line 184
    if ((gru_options & 2UL) != 0UL) {
      {
#line 184
      atomic_long_inc(& gru_stats.flush_tlb_gru_tgh);
      }
    } else {

    }
#line 185
    asid = (int )((unsigned int )asid + ((unsigned int )(start >> 61) & 3U));
#line 186
    if ((int )gru_options & 1) {
#line 186
      __vpp_verify___0 = (void const   *)0;
      {
#line 186
      if (4UL == 1UL) {
#line 186
        goto case_1___4;
      } else {

      }
#line 188
      if (4UL == 2UL) {
#line 188
        goto case_2___5;
      } else {

      }
#line 188
      if (4UL == 4UL) {
#line 188
        goto case_4___6;
      } else {

      }
#line 188
      if (4UL == 8UL) {
#line 188
        goto case_8___7;
      } else {

      }
#line 188
      goto switch_default___8;
      case_1___4: /* CIL Label */ ;
      {
#line 188
      if (4UL == 1UL) {
#line 188
        goto case_1___5;
      } else {

      }
#line 188
      if (4UL == 2UL) {
#line 188
        goto case_2___4;
      } else {

      }
#line 188
      if (4UL == 4UL) {
#line 188
        goto case_4___4;
      } else {

      }
#line 188
      if (4UL == 8UL) {
#line 188
        goto case_8___4;
      } else {

      }
#line 188
      goto switch_default___4;
      case_1___5: /* CIL Label */ 
#line 188
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 188
      goto ldv_34633;
      case_2___4: /* CIL Label */ 
#line 188
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 188
      goto ldv_34633;
      case_4___4: /* CIL Label */ 
#line 188
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 188
      goto ldv_34633;
      case_8___4: /* CIL Label */ 
#line 188
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 188
      goto ldv_34633;
      switch_default___4: /* CIL Label */ 
      {
#line 188
      __bad_percpu_size();
      }
      switch_break___5: /* CIL Label */ ;
      }
      ldv_34633: 
#line 188
      pscr_ret_____0 = pfo_ret_____3;
#line 188
      goto ldv_34639;
      case_2___5: /* CIL Label */ ;
      {
#line 188
      if (4UL == 1UL) {
#line 188
        goto case_1___6;
      } else {

      }
#line 188
      if (4UL == 2UL) {
#line 188
        goto case_2___6;
      } else {

      }
#line 188
      if (4UL == 4UL) {
#line 188
        goto case_4___5;
      } else {

      }
#line 188
      if (4UL == 8UL) {
#line 188
        goto case_8___5;
      } else {

      }
#line 188
      goto switch_default___5;
      case_1___6: /* CIL Label */ 
#line 188
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 188
      goto ldv_34643;
      case_2___6: /* CIL Label */ 
#line 188
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 188
      goto ldv_34643;
      case_4___5: /* CIL Label */ 
#line 188
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 188
      goto ldv_34643;
      case_8___5: /* CIL Label */ 
#line 188
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 188
      goto ldv_34643;
      switch_default___5: /* CIL Label */ 
      {
#line 188
      __bad_percpu_size();
      }
      switch_break___6: /* CIL Label */ ;
      }
      ldv_34643: 
#line 188
      pscr_ret_____0 = pfo_ret_____4;
#line 188
      goto ldv_34639;
      case_4___6: /* CIL Label */ ;
      {
#line 188
      if (4UL == 1UL) {
#line 188
        goto case_1___7;
      } else {

      }
#line 188
      if (4UL == 2UL) {
#line 188
        goto case_2___7;
      } else {

      }
#line 188
      if (4UL == 4UL) {
#line 188
        goto case_4___7;
      } else {

      }
#line 188
      if (4UL == 8UL) {
#line 188
        goto case_8___6;
      } else {

      }
#line 188
      goto switch_default___6;
      case_1___7: /* CIL Label */ 
#line 188
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 188
      goto ldv_34652;
      case_2___7: /* CIL Label */ 
#line 188
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 188
      goto ldv_34652;
      case_4___7: /* CIL Label */ 
#line 188
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 188
      goto ldv_34652;
      case_8___6: /* CIL Label */ 
#line 188
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 188
      goto ldv_34652;
      switch_default___6: /* CIL Label */ 
      {
#line 188
      __bad_percpu_size();
      }
      switch_break___7: /* CIL Label */ ;
      }
      ldv_34652: 
#line 188
      pscr_ret_____0 = pfo_ret_____5;
#line 188
      goto ldv_34639;
      case_8___7: /* CIL Label */ ;
      {
#line 188
      if (4UL == 1UL) {
#line 188
        goto case_1___8;
      } else {

      }
#line 188
      if (4UL == 2UL) {
#line 188
        goto case_2___8;
      } else {

      }
#line 188
      if (4UL == 4UL) {
#line 188
        goto case_4___8;
      } else {

      }
#line 188
      if (4UL == 8UL) {
#line 188
        goto case_8___8;
      } else {

      }
#line 188
      goto switch_default___7;
      case_1___8: /* CIL Label */ 
#line 188
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 188
      goto ldv_34661;
      case_2___8: /* CIL Label */ 
#line 188
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 188
      goto ldv_34661;
      case_4___8: /* CIL Label */ 
#line 188
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 188
      goto ldv_34661;
      case_8___8: /* CIL Label */ 
#line 188
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 188
      goto ldv_34661;
      switch_default___7: /* CIL Label */ 
      {
#line 188
      __bad_percpu_size();
      }
      switch_break___8: /* CIL Label */ ;
      }
      ldv_34661: 
#line 188
      pscr_ret_____0 = pfo_ret_____6;
#line 188
      goto ldv_34639;
      switch_default___8: /* CIL Label */ 
      {
#line 188
      __bad_size_call_parameter();
      }
#line 188
      goto ldv_34639;
      switch_break___4: /* CIL Label */ ;
      }
      ldv_34639: 
      {
#line 188
      printk("\017GRU:%d %s:   FLUSH gruid %d, asid 0x%x, vaddr 0x%lx, vamask 0x%x, num %ld, cbmap 0x%x\n",
             pscr_ret_____0, "gru_flush_tlb_range", gid, asid, start, grupagesize,
             num, (int )asids->mt_ctxbitmap);
      }
    } else {

    }
    {
#line 189
    tgh = get_lock_tgh_handle(gru);
#line 190
    tgh_invalidate(tgh, start, 0xffffffffffffffffUL, asid, grupagesize, 0, (int )((unsigned int )num - 1U),
                   (int )asids->mt_ctxbitmap);
#line 192
    get_unlock_tgh_handle(tgh);
    }
  } else {
#line 194
    if ((gru_options & 2UL) != 0UL) {
      {
#line 194
      atomic_long_inc(& gru_stats.flush_tlb_gru_zero_asid);
      }
    } else {

    }
    {
#line 195
    asids->mt_asid = 0U;
#line 196
    __clear_bit((long )gru->gs_gid, (unsigned long volatile   *)(& gms->ms_asidmap));
    }
#line 197
    if ((int )gru_options & 1) {
#line 197
      __vpp_verify___1 = (void const   *)0;
      {
#line 197
      if (4UL == 1UL) {
#line 197
        goto case_1___9;
      } else {

      }
#line 200
      if (4UL == 2UL) {
#line 200
        goto case_2___10;
      } else {

      }
#line 200
      if (4UL == 4UL) {
#line 200
        goto case_4___11;
      } else {

      }
#line 200
      if (4UL == 8UL) {
#line 200
        goto case_8___12;
      } else {

      }
#line 200
      goto switch_default___13;
      case_1___9: /* CIL Label */ ;
      {
#line 200
      if (4UL == 1UL) {
#line 200
        goto case_1___10;
      } else {

      }
#line 200
      if (4UL == 2UL) {
#line 200
        goto case_2___9;
      } else {

      }
#line 200
      if (4UL == 4UL) {
#line 200
        goto case_4___9;
      } else {

      }
#line 200
      if (4UL == 8UL) {
#line 200
        goto case_8___9;
      } else {

      }
#line 200
      goto switch_default___9;
      case_1___10: /* CIL Label */ 
#line 200
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 200
      goto ldv_34674;
      case_2___9: /* CIL Label */ 
#line 200
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 200
      goto ldv_34674;
      case_4___9: /* CIL Label */ 
#line 200
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 200
      goto ldv_34674;
      case_8___9: /* CIL Label */ 
#line 200
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 200
      goto ldv_34674;
      switch_default___9: /* CIL Label */ 
      {
#line 200
      __bad_percpu_size();
      }
      switch_break___10: /* CIL Label */ ;
      }
      ldv_34674: 
#line 200
      pscr_ret_____1 = pfo_ret_____7;
#line 200
      goto ldv_34680;
      case_2___10: /* CIL Label */ ;
      {
#line 200
      if (4UL == 1UL) {
#line 200
        goto case_1___11;
      } else {

      }
#line 200
      if (4UL == 2UL) {
#line 200
        goto case_2___11;
      } else {

      }
#line 200
      if (4UL == 4UL) {
#line 200
        goto case_4___10;
      } else {

      }
#line 200
      if (4UL == 8UL) {
#line 200
        goto case_8___10;
      } else {

      }
#line 200
      goto switch_default___10;
      case_1___11: /* CIL Label */ 
#line 200
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 200
      goto ldv_34684;
      case_2___11: /* CIL Label */ 
#line 200
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 200
      goto ldv_34684;
      case_4___10: /* CIL Label */ 
#line 200
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 200
      goto ldv_34684;
      case_8___10: /* CIL Label */ 
#line 200
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 200
      goto ldv_34684;
      switch_default___10: /* CIL Label */ 
      {
#line 200
      __bad_percpu_size();
      }
      switch_break___11: /* CIL Label */ ;
      }
      ldv_34684: 
#line 200
      pscr_ret_____1 = pfo_ret_____8;
#line 200
      goto ldv_34680;
      case_4___11: /* CIL Label */ ;
      {
#line 200
      if (4UL == 1UL) {
#line 200
        goto case_1___12;
      } else {

      }
#line 200
      if (4UL == 2UL) {
#line 200
        goto case_2___12;
      } else {

      }
#line 200
      if (4UL == 4UL) {
#line 200
        goto case_4___12;
      } else {

      }
#line 200
      if (4UL == 8UL) {
#line 200
        goto case_8___11;
      } else {

      }
#line 200
      goto switch_default___11;
      case_1___12: /* CIL Label */ 
#line 200
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 200
      goto ldv_34693;
      case_2___12: /* CIL Label */ 
#line 200
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 200
      goto ldv_34693;
      case_4___12: /* CIL Label */ 
#line 200
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 200
      goto ldv_34693;
      case_8___11: /* CIL Label */ 
#line 200
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 200
      goto ldv_34693;
      switch_default___11: /* CIL Label */ 
      {
#line 200
      __bad_percpu_size();
      }
      switch_break___12: /* CIL Label */ ;
      }
      ldv_34693: 
#line 200
      pscr_ret_____1 = pfo_ret_____9;
#line 200
      goto ldv_34680;
      case_8___12: /* CIL Label */ ;
      {
#line 200
      if (4UL == 1UL) {
#line 200
        goto case_1___13;
      } else {

      }
#line 200
      if (4UL == 2UL) {
#line 200
        goto case_2___13;
      } else {

      }
#line 200
      if (4UL == 4UL) {
#line 200
        goto case_4___13;
      } else {

      }
#line 200
      if (4UL == 8UL) {
#line 200
        goto case_8___13;
      } else {

      }
#line 200
      goto switch_default___12;
      case_1___13: /* CIL Label */ 
#line 200
      __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 200
      goto ldv_34702;
      case_2___13: /* CIL Label */ 
#line 200
      __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 200
      goto ldv_34702;
      case_4___13: /* CIL Label */ 
#line 200
      __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 200
      goto ldv_34702;
      case_8___13: /* CIL Label */ 
#line 200
      __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 200
      goto ldv_34702;
      switch_default___12: /* CIL Label */ 
      {
#line 200
      __bad_percpu_size();
      }
      switch_break___13: /* CIL Label */ ;
      }
      ldv_34702: 
#line 200
      pscr_ret_____1 = pfo_ret_____10;
#line 200
      goto ldv_34680;
      switch_default___13: /* CIL Label */ 
      {
#line 200
      __bad_size_call_parameter();
      }
#line 200
      goto ldv_34680;
      switch_break___9: /* CIL Label */ ;
      }
      ldv_34680: 
      {
#line 200
      printk("\017GRU:%d %s:   CLEARASID gruid %d, asid 0x%x, cbtmap 0x%x, asidmap 0x%lx\n",
             pscr_ret_____1, "gru_flush_tlb_range", gid, asid, (int )asids->mt_ctxbitmap,
             gms->ms_asidmap[0]);
      }
    } else {

    }
  }
  {
#line 178
  tmp___0 = ldv_find_next_bit_98((unsigned long const   *)(& gms->ms_asidmap), 2048UL,
                                 (unsigned long )(gid + 1));
#line 178
  gid = (int )tmp___0;
  }
  ldv_34711: ;
#line 178
  if (gid <= 2047) {
#line 180
    goto ldv_34710;
  } else {

  }
  {
#line 203
  ldv_spin_unlock_99(& gms->ms_asid_lock);
  }
#line 204
  return;
}
}
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
void gru_flush_all_tlb(struct gru_state *gru ) 
{ 
  struct gru_tlb_global_handle *tgh ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 213
  if ((int )gru_options & 1) {
#line 213
    __vpp_verify = (void const   *)0;
    {
#line 213
    if (4UL == 1UL) {
#line 213
      goto case_1;
    } else {

    }
#line 213
    if (4UL == 2UL) {
#line 213
      goto case_2___0;
    } else {

    }
#line 213
    if (4UL == 4UL) {
#line 213
      goto case_4___1;
    } else {

    }
#line 213
    if (4UL == 8UL) {
#line 213
      goto case_8___2;
    } else {

    }
#line 213
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 213
    if (4UL == 1UL) {
#line 213
      goto case_1___0;
    } else {

    }
#line 213
    if (4UL == 2UL) {
#line 213
      goto case_2;
    } else {

    }
#line 213
    if (4UL == 4UL) {
#line 213
      goto case_4;
    } else {

    }
#line 213
    if (4UL == 8UL) {
#line 213
      goto case_8;
    } else {

    }
#line 213
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 213
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 213
    goto ldv_34722;
    case_2: /* CIL Label */ 
#line 213
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 213
    goto ldv_34722;
    case_4: /* CIL Label */ 
#line 213
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 213
    goto ldv_34722;
    case_8: /* CIL Label */ 
#line 213
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 213
    goto ldv_34722;
    switch_default: /* CIL Label */ 
    {
#line 213
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34722: 
#line 213
    pscr_ret__ = pfo_ret__;
#line 213
    goto ldv_34728;
    case_2___0: /* CIL Label */ ;
    {
#line 213
    if (4UL == 1UL) {
#line 213
      goto case_1___1;
    } else {

    }
#line 213
    if (4UL == 2UL) {
#line 213
      goto case_2___1;
    } else {

    }
#line 213
    if (4UL == 4UL) {
#line 213
      goto case_4___0;
    } else {

    }
#line 213
    if (4UL == 8UL) {
#line 213
      goto case_8___0;
    } else {

    }
#line 213
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 213
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 213
    goto ldv_34732;
    case_2___1: /* CIL Label */ 
#line 213
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 213
    goto ldv_34732;
    case_4___0: /* CIL Label */ 
#line 213
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 213
    goto ldv_34732;
    case_8___0: /* CIL Label */ 
#line 213
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 213
    goto ldv_34732;
    switch_default___0: /* CIL Label */ 
    {
#line 213
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34732: 
#line 213
    pscr_ret__ = pfo_ret_____0;
#line 213
    goto ldv_34728;
    case_4___1: /* CIL Label */ ;
    {
#line 213
    if (4UL == 1UL) {
#line 213
      goto case_1___2;
    } else {

    }
#line 213
    if (4UL == 2UL) {
#line 213
      goto case_2___2;
    } else {

    }
#line 213
    if (4UL == 4UL) {
#line 213
      goto case_4___2;
    } else {

    }
#line 213
    if (4UL == 8UL) {
#line 213
      goto case_8___1;
    } else {

    }
#line 213
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 213
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 213
    goto ldv_34741;
    case_2___2: /* CIL Label */ 
#line 213
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 213
    goto ldv_34741;
    case_4___2: /* CIL Label */ 
#line 213
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 213
    goto ldv_34741;
    case_8___1: /* CIL Label */ 
#line 213
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 213
    goto ldv_34741;
    switch_default___1: /* CIL Label */ 
    {
#line 213
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34741: 
#line 213
    pscr_ret__ = pfo_ret_____1;
#line 213
    goto ldv_34728;
    case_8___2: /* CIL Label */ ;
    {
#line 213
    if (4UL == 1UL) {
#line 213
      goto case_1___3;
    } else {

    }
#line 213
    if (4UL == 2UL) {
#line 213
      goto case_2___3;
    } else {

    }
#line 213
    if (4UL == 4UL) {
#line 213
      goto case_4___3;
    } else {

    }
#line 213
    if (4UL == 8UL) {
#line 213
      goto case_8___3;
    } else {

    }
#line 213
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 213
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 213
    goto ldv_34750;
    case_2___3: /* CIL Label */ 
#line 213
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 213
    goto ldv_34750;
    case_4___3: /* CIL Label */ 
#line 213
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 213
    goto ldv_34750;
    case_8___3: /* CIL Label */ 
#line 213
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 213
    goto ldv_34750;
    switch_default___2: /* CIL Label */ 
    {
#line 213
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34750: 
#line 213
    pscr_ret__ = pfo_ret_____2;
#line 213
    goto ldv_34728;
    switch_default___3: /* CIL Label */ 
    {
#line 213
    __bad_size_call_parameter();
    }
#line 213
    goto ldv_34728;
    switch_break: /* CIL Label */ ;
    }
    ldv_34728: 
    {
#line 213
    printk("\017GRU:%d %s: gid %d\n", pscr_ret__, "gru_flush_all_tlb", (int )gru->gs_gid);
    }
  } else {

  }
  {
#line 214
  tgh = get_lock_tgh_handle(gru);
#line 215
  tgh_invalidate(tgh, 0UL, 0xffffffffffffffffUL, 0, 1, 1, 1023, 65535);
#line 216
  get_unlock_tgh_handle(tgh);
  }
#line 217
  return;
}
}
#line 222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
static void gru_invalidate_range_start(struct mmu_notifier *mn , struct mm_struct *mm ,
                                       unsigned long start , unsigned long end ) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier  const  *__mptr ;
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 226
  __mptr = (struct mmu_notifier  const  *)mn;
#line 226
  gms = (struct gru_mm_struct *)__mptr;
#line 229
  if ((gru_options & 2UL) != 0UL) {
    {
#line 229
    atomic_long_inc(& gru_stats.mmu_invalidate_range);
    }
  } else {

  }
  {
#line 230
  atomic_inc(& gms->ms_range_active);
  }
#line 231
  if ((int )gru_options & 1) {
    {
#line 231
    tmp = atomic_read((atomic_t const   *)(& gms->ms_range_active));
#line 231
    __vpp_verify = (void const   *)0;
    }
    {
#line 231
    if (4UL == 1UL) {
#line 231
      goto case_1;
    } else {

    }
#line 232
    if (4UL == 2UL) {
#line 232
      goto case_2___0;
    } else {

    }
#line 232
    if (4UL == 4UL) {
#line 232
      goto case_4___1;
    } else {

    }
#line 232
    if (4UL == 8UL) {
#line 232
      goto case_8___2;
    } else {

    }
#line 232
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 232
    if (4UL == 1UL) {
#line 232
      goto case_1___0;
    } else {

    }
#line 232
    if (4UL == 2UL) {
#line 232
      goto case_2;
    } else {

    }
#line 232
    if (4UL == 4UL) {
#line 232
      goto case_4;
    } else {

    }
#line 232
    if (4UL == 8UL) {
#line 232
      goto case_8;
    } else {

    }
#line 232
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 232
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 232
    goto ldv_34773;
    case_2: /* CIL Label */ 
#line 232
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 232
    goto ldv_34773;
    case_4: /* CIL Label */ 
#line 232
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 232
    goto ldv_34773;
    case_8: /* CIL Label */ 
#line 232
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 232
    goto ldv_34773;
    switch_default: /* CIL Label */ 
    {
#line 232
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34773: 
#line 232
    pscr_ret__ = pfo_ret__;
#line 232
    goto ldv_34779;
    case_2___0: /* CIL Label */ ;
    {
#line 232
    if (4UL == 1UL) {
#line 232
      goto case_1___1;
    } else {

    }
#line 232
    if (4UL == 2UL) {
#line 232
      goto case_2___1;
    } else {

    }
#line 232
    if (4UL == 4UL) {
#line 232
      goto case_4___0;
    } else {

    }
#line 232
    if (4UL == 8UL) {
#line 232
      goto case_8___0;
    } else {

    }
#line 232
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 232
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 232
    goto ldv_34783;
    case_2___1: /* CIL Label */ 
#line 232
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 232
    goto ldv_34783;
    case_4___0: /* CIL Label */ 
#line 232
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 232
    goto ldv_34783;
    case_8___0: /* CIL Label */ 
#line 232
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 232
    goto ldv_34783;
    switch_default___0: /* CIL Label */ 
    {
#line 232
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34783: 
#line 232
    pscr_ret__ = pfo_ret_____0;
#line 232
    goto ldv_34779;
    case_4___1: /* CIL Label */ ;
    {
#line 232
    if (4UL == 1UL) {
#line 232
      goto case_1___2;
    } else {

    }
#line 232
    if (4UL == 2UL) {
#line 232
      goto case_2___2;
    } else {

    }
#line 232
    if (4UL == 4UL) {
#line 232
      goto case_4___2;
    } else {

    }
#line 232
    if (4UL == 8UL) {
#line 232
      goto case_8___1;
    } else {

    }
#line 232
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 232
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 232
    goto ldv_34792;
    case_2___2: /* CIL Label */ 
#line 232
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 232
    goto ldv_34792;
    case_4___2: /* CIL Label */ 
#line 232
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 232
    goto ldv_34792;
    case_8___1: /* CIL Label */ 
#line 232
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 232
    goto ldv_34792;
    switch_default___1: /* CIL Label */ 
    {
#line 232
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34792: 
#line 232
    pscr_ret__ = pfo_ret_____1;
#line 232
    goto ldv_34779;
    case_8___2: /* CIL Label */ ;
    {
#line 232
    if (4UL == 1UL) {
#line 232
      goto case_1___3;
    } else {

    }
#line 232
    if (4UL == 2UL) {
#line 232
      goto case_2___3;
    } else {

    }
#line 232
    if (4UL == 4UL) {
#line 232
      goto case_4___3;
    } else {

    }
#line 232
    if (4UL == 8UL) {
#line 232
      goto case_8___3;
    } else {

    }
#line 232
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 232
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 232
    goto ldv_34801;
    case_2___3: /* CIL Label */ 
#line 232
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 232
    goto ldv_34801;
    case_4___3: /* CIL Label */ 
#line 232
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 232
    goto ldv_34801;
    case_8___3: /* CIL Label */ 
#line 232
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 232
    goto ldv_34801;
    switch_default___2: /* CIL Label */ 
    {
#line 232
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34801: 
#line 232
    pscr_ret__ = pfo_ret_____2;
#line 232
    goto ldv_34779;
    switch_default___3: /* CIL Label */ 
    {
#line 232
    __bad_size_call_parameter();
    }
#line 232
    goto ldv_34779;
    switch_break: /* CIL Label */ ;
    }
    ldv_34779: 
    {
#line 232
    printk("\017GRU:%d %s: gms %p, start 0x%lx, end 0x%lx, act %d\n", pscr_ret__,
           "gru_invalidate_range_start", gms, start, end, tmp);
    }
  } else {

  }
  {
#line 233
  gru_flush_tlb_range(gms, start, end - start);
  }
#line 234
  return;
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
static void gru_invalidate_range_end(struct mmu_notifier *mn , struct mm_struct *mm ,
                                     unsigned long start , unsigned long end ) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier  const  *__mptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
  {
#line 240
  __mptr = (struct mmu_notifier  const  *)mn;
#line 240
  gms = (struct gru_mm_struct *)__mptr;
#line 244
  atomic_dec_and_test(& gms->ms_range_active);
#line 246
  __wake_up(& gms->ms_wait_queue, 3U, 0, (void *)0);
  }
#line 247
  if ((int )gru_options & 1) {
#line 247
    __vpp_verify = (void const   *)0;
    {
#line 247
    if (4UL == 1UL) {
#line 247
      goto case_1;
    } else {

    }
#line 247
    if (4UL == 2UL) {
#line 247
      goto case_2___0;
    } else {

    }
#line 247
    if (4UL == 4UL) {
#line 247
      goto case_4___1;
    } else {

    }
#line 247
    if (4UL == 8UL) {
#line 247
      goto case_8___2;
    } else {

    }
#line 247
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 247
    if (4UL == 1UL) {
#line 247
      goto case_1___0;
    } else {

    }
#line 247
    if (4UL == 2UL) {
#line 247
      goto case_2;
    } else {

    }
#line 247
    if (4UL == 4UL) {
#line 247
      goto case_4;
    } else {

    }
#line 247
    if (4UL == 8UL) {
#line 247
      goto case_8;
    } else {

    }
#line 247
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 247
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 247
    goto ldv_34824;
    case_2: /* CIL Label */ 
#line 247
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 247
    goto ldv_34824;
    case_4: /* CIL Label */ 
#line 247
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 247
    goto ldv_34824;
    case_8: /* CIL Label */ 
#line 247
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 247
    goto ldv_34824;
    switch_default: /* CIL Label */ 
    {
#line 247
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34824: 
#line 247
    pscr_ret__ = pfo_ret__;
#line 247
    goto ldv_34830;
    case_2___0: /* CIL Label */ ;
    {
#line 247
    if (4UL == 1UL) {
#line 247
      goto case_1___1;
    } else {

    }
#line 247
    if (4UL == 2UL) {
#line 247
      goto case_2___1;
    } else {

    }
#line 247
    if (4UL == 4UL) {
#line 247
      goto case_4___0;
    } else {

    }
#line 247
    if (4UL == 8UL) {
#line 247
      goto case_8___0;
    } else {

    }
#line 247
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 247
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 247
    goto ldv_34834;
    case_2___1: /* CIL Label */ 
#line 247
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 247
    goto ldv_34834;
    case_4___0: /* CIL Label */ 
#line 247
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 247
    goto ldv_34834;
    case_8___0: /* CIL Label */ 
#line 247
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 247
    goto ldv_34834;
    switch_default___0: /* CIL Label */ 
    {
#line 247
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34834: 
#line 247
    pscr_ret__ = pfo_ret_____0;
#line 247
    goto ldv_34830;
    case_4___1: /* CIL Label */ ;
    {
#line 247
    if (4UL == 1UL) {
#line 247
      goto case_1___2;
    } else {

    }
#line 247
    if (4UL == 2UL) {
#line 247
      goto case_2___2;
    } else {

    }
#line 247
    if (4UL == 4UL) {
#line 247
      goto case_4___2;
    } else {

    }
#line 247
    if (4UL == 8UL) {
#line 247
      goto case_8___1;
    } else {

    }
#line 247
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 247
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 247
    goto ldv_34843;
    case_2___2: /* CIL Label */ 
#line 247
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 247
    goto ldv_34843;
    case_4___2: /* CIL Label */ 
#line 247
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 247
    goto ldv_34843;
    case_8___1: /* CIL Label */ 
#line 247
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 247
    goto ldv_34843;
    switch_default___1: /* CIL Label */ 
    {
#line 247
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34843: 
#line 247
    pscr_ret__ = pfo_ret_____1;
#line 247
    goto ldv_34830;
    case_8___2: /* CIL Label */ ;
    {
#line 247
    if (4UL == 1UL) {
#line 247
      goto case_1___3;
    } else {

    }
#line 247
    if (4UL == 2UL) {
#line 247
      goto case_2___3;
    } else {

    }
#line 247
    if (4UL == 4UL) {
#line 247
      goto case_4___3;
    } else {

    }
#line 247
    if (4UL == 8UL) {
#line 247
      goto case_8___3;
    } else {

    }
#line 247
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 247
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 247
    goto ldv_34852;
    case_2___3: /* CIL Label */ 
#line 247
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 247
    goto ldv_34852;
    case_4___3: /* CIL Label */ 
#line 247
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 247
    goto ldv_34852;
    case_8___3: /* CIL Label */ 
#line 247
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 247
    goto ldv_34852;
    switch_default___2: /* CIL Label */ 
    {
#line 247
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34852: 
#line 247
    pscr_ret__ = pfo_ret_____2;
#line 247
    goto ldv_34830;
    switch_default___3: /* CIL Label */ 
    {
#line 247
    __bad_size_call_parameter();
    }
#line 247
    goto ldv_34830;
    switch_break: /* CIL Label */ ;
    }
    ldv_34830: 
    {
#line 247
    printk("\017GRU:%d %s: gms %p, start 0x%lx, end 0x%lx\n", pscr_ret__, "gru_invalidate_range_end",
           gms, start, end);
    }
  } else {

  }
#line 248
  return;
}
}
#line 250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
static void gru_invalidate_page(struct mmu_notifier *mn , struct mm_struct *mm , unsigned long address ) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier  const  *__mptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 253
  __mptr = (struct mmu_notifier  const  *)mn;
#line 253
  gms = (struct gru_mm_struct *)__mptr;
#line 256
  if ((gru_options & 2UL) != 0UL) {
    {
#line 256
    atomic_long_inc(& gru_stats.mmu_invalidate_page);
    }
  } else {

  }
  {
#line 257
  gru_flush_tlb_range(gms, address, 4096UL);
  }
#line 258
  if ((int )gru_options & 1) {
#line 258
    __vpp_verify = (void const   *)0;
    {
#line 258
    if (4UL == 1UL) {
#line 258
      goto case_1;
    } else {

    }
#line 258
    if (4UL == 2UL) {
#line 258
      goto case_2___0;
    } else {

    }
#line 258
    if (4UL == 4UL) {
#line 258
      goto case_4___1;
    } else {

    }
#line 258
    if (4UL == 8UL) {
#line 258
      goto case_8___2;
    } else {

    }
#line 258
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 258
    if (4UL == 1UL) {
#line 258
      goto case_1___0;
    } else {

    }
#line 258
    if (4UL == 2UL) {
#line 258
      goto case_2;
    } else {

    }
#line 258
    if (4UL == 4UL) {
#line 258
      goto case_4;
    } else {

    }
#line 258
    if (4UL == 8UL) {
#line 258
      goto case_8;
    } else {

    }
#line 258
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 258
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 258
    goto ldv_34874;
    case_2: /* CIL Label */ 
#line 258
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 258
    goto ldv_34874;
    case_4: /* CIL Label */ 
#line 258
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 258
    goto ldv_34874;
    case_8: /* CIL Label */ 
#line 258
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 258
    goto ldv_34874;
    switch_default: /* CIL Label */ 
    {
#line 258
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34874: 
#line 258
    pscr_ret__ = pfo_ret__;
#line 258
    goto ldv_34880;
    case_2___0: /* CIL Label */ ;
    {
#line 258
    if (4UL == 1UL) {
#line 258
      goto case_1___1;
    } else {

    }
#line 258
    if (4UL == 2UL) {
#line 258
      goto case_2___1;
    } else {

    }
#line 258
    if (4UL == 4UL) {
#line 258
      goto case_4___0;
    } else {

    }
#line 258
    if (4UL == 8UL) {
#line 258
      goto case_8___0;
    } else {

    }
#line 258
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 258
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 258
    goto ldv_34884;
    case_2___1: /* CIL Label */ 
#line 258
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 258
    goto ldv_34884;
    case_4___0: /* CIL Label */ 
#line 258
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 258
    goto ldv_34884;
    case_8___0: /* CIL Label */ 
#line 258
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 258
    goto ldv_34884;
    switch_default___0: /* CIL Label */ 
    {
#line 258
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34884: 
#line 258
    pscr_ret__ = pfo_ret_____0;
#line 258
    goto ldv_34880;
    case_4___1: /* CIL Label */ ;
    {
#line 258
    if (4UL == 1UL) {
#line 258
      goto case_1___2;
    } else {

    }
#line 258
    if (4UL == 2UL) {
#line 258
      goto case_2___2;
    } else {

    }
#line 258
    if (4UL == 4UL) {
#line 258
      goto case_4___2;
    } else {

    }
#line 258
    if (4UL == 8UL) {
#line 258
      goto case_8___1;
    } else {

    }
#line 258
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 258
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 258
    goto ldv_34893;
    case_2___2: /* CIL Label */ 
#line 258
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 258
    goto ldv_34893;
    case_4___2: /* CIL Label */ 
#line 258
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 258
    goto ldv_34893;
    case_8___1: /* CIL Label */ 
#line 258
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 258
    goto ldv_34893;
    switch_default___1: /* CIL Label */ 
    {
#line 258
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34893: 
#line 258
    pscr_ret__ = pfo_ret_____1;
#line 258
    goto ldv_34880;
    case_8___2: /* CIL Label */ ;
    {
#line 258
    if (4UL == 1UL) {
#line 258
      goto case_1___3;
    } else {

    }
#line 258
    if (4UL == 2UL) {
#line 258
      goto case_2___3;
    } else {

    }
#line 258
    if (4UL == 4UL) {
#line 258
      goto case_4___3;
    } else {

    }
#line 258
    if (4UL == 8UL) {
#line 258
      goto case_8___3;
    } else {

    }
#line 258
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 258
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 258
    goto ldv_34902;
    case_2___3: /* CIL Label */ 
#line 258
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 258
    goto ldv_34902;
    case_4___3: /* CIL Label */ 
#line 258
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 258
    goto ldv_34902;
    case_8___3: /* CIL Label */ 
#line 258
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 258
    goto ldv_34902;
    switch_default___2: /* CIL Label */ 
    {
#line 258
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34902: 
#line 258
    pscr_ret__ = pfo_ret_____2;
#line 258
    goto ldv_34880;
    switch_default___3: /* CIL Label */ 
    {
#line 258
    __bad_size_call_parameter();
    }
#line 258
    goto ldv_34880;
    switch_break: /* CIL Label */ ;
    }
    ldv_34880: 
    {
#line 258
    printk("\017GRU:%d %s: gms %p, address 0x%lx\n", pscr_ret__, "gru_invalidate_page",
           gms, address);
    }
  } else {

  }
#line 259
  return;
}
}
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
static void gru_release(struct mmu_notifier *mn , struct mm_struct *mm ) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier  const  *__mptr ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 263
  __mptr = (struct mmu_notifier  const  *)mn;
#line 263
  gms = (struct gru_mm_struct *)__mptr;
#line 266
  gms->ms_released = 1;
#line 267
  if ((int )gru_options & 1) {
#line 267
    __vpp_verify = (void const   *)0;
    {
#line 267
    if (4UL == 1UL) {
#line 267
      goto case_1;
    } else {

    }
#line 267
    if (4UL == 2UL) {
#line 267
      goto case_2___0;
    } else {

    }
#line 267
    if (4UL == 4UL) {
#line 267
      goto case_4___1;
    } else {

    }
#line 267
    if (4UL == 8UL) {
#line 267
      goto case_8___2;
    } else {

    }
#line 267
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 267
    if (4UL == 1UL) {
#line 267
      goto case_1___0;
    } else {

    }
#line 267
    if (4UL == 2UL) {
#line 267
      goto case_2;
    } else {

    }
#line 267
    if (4UL == 4UL) {
#line 267
      goto case_4;
    } else {

    }
#line 267
    if (4UL == 8UL) {
#line 267
      goto case_8;
    } else {

    }
#line 267
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 267
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 267
    goto ldv_34923;
    case_2: /* CIL Label */ 
#line 267
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 267
    goto ldv_34923;
    case_4: /* CIL Label */ 
#line 267
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 267
    goto ldv_34923;
    case_8: /* CIL Label */ 
#line 267
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 267
    goto ldv_34923;
    switch_default: /* CIL Label */ 
    {
#line 267
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34923: 
#line 267
    pscr_ret__ = pfo_ret__;
#line 267
    goto ldv_34929;
    case_2___0: /* CIL Label */ ;
    {
#line 267
    if (4UL == 1UL) {
#line 267
      goto case_1___1;
    } else {

    }
#line 267
    if (4UL == 2UL) {
#line 267
      goto case_2___1;
    } else {

    }
#line 267
    if (4UL == 4UL) {
#line 267
      goto case_4___0;
    } else {

    }
#line 267
    if (4UL == 8UL) {
#line 267
      goto case_8___0;
    } else {

    }
#line 267
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 267
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 267
    goto ldv_34933;
    case_2___1: /* CIL Label */ 
#line 267
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 267
    goto ldv_34933;
    case_4___0: /* CIL Label */ 
#line 267
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 267
    goto ldv_34933;
    case_8___0: /* CIL Label */ 
#line 267
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 267
    goto ldv_34933;
    switch_default___0: /* CIL Label */ 
    {
#line 267
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34933: 
#line 267
    pscr_ret__ = pfo_ret_____0;
#line 267
    goto ldv_34929;
    case_4___1: /* CIL Label */ ;
    {
#line 267
    if (4UL == 1UL) {
#line 267
      goto case_1___2;
    } else {

    }
#line 267
    if (4UL == 2UL) {
#line 267
      goto case_2___2;
    } else {

    }
#line 267
    if (4UL == 4UL) {
#line 267
      goto case_4___2;
    } else {

    }
#line 267
    if (4UL == 8UL) {
#line 267
      goto case_8___1;
    } else {

    }
#line 267
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 267
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 267
    goto ldv_34942;
    case_2___2: /* CIL Label */ 
#line 267
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 267
    goto ldv_34942;
    case_4___2: /* CIL Label */ 
#line 267
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 267
    goto ldv_34942;
    case_8___1: /* CIL Label */ 
#line 267
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 267
    goto ldv_34942;
    switch_default___1: /* CIL Label */ 
    {
#line 267
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34942: 
#line 267
    pscr_ret__ = pfo_ret_____1;
#line 267
    goto ldv_34929;
    case_8___2: /* CIL Label */ ;
    {
#line 267
    if (4UL == 1UL) {
#line 267
      goto case_1___3;
    } else {

    }
#line 267
    if (4UL == 2UL) {
#line 267
      goto case_2___3;
    } else {

    }
#line 267
    if (4UL == 4UL) {
#line 267
      goto case_4___3;
    } else {

    }
#line 267
    if (4UL == 8UL) {
#line 267
      goto case_8___3;
    } else {

    }
#line 267
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 267
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 267
    goto ldv_34951;
    case_2___3: /* CIL Label */ 
#line 267
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 267
    goto ldv_34951;
    case_4___3: /* CIL Label */ 
#line 267
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 267
    goto ldv_34951;
    case_8___3: /* CIL Label */ 
#line 267
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 267
    goto ldv_34951;
    switch_default___2: /* CIL Label */ 
    {
#line 267
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34951: 
#line 267
    pscr_ret__ = pfo_ret_____2;
#line 267
    goto ldv_34929;
    switch_default___3: /* CIL Label */ 
    {
#line 267
    __bad_size_call_parameter();
    }
#line 267
    goto ldv_34929;
    switch_break: /* CIL Label */ ;
    }
    ldv_34929: 
    {
#line 267
    printk("\017GRU:%d %s: gms %p\n", pscr_ret__, "gru_release", gms);
    }
  } else {

  }
#line 268
  return;
}
}
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
static struct mmu_notifier_ops  const  gru_mmuops  = 
#line 271
     {& gru_release, 0, 0, 0, & gru_invalidate_page, & gru_invalidate_range_start, & gru_invalidate_range_end,
    0};
#line 279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
static struct mmu_notifier *mmu_find_ops(struct mm_struct *mm , struct mmu_notifier_ops  const  *ops ) 
{ 
  struct mmu_notifier *mn ;
  struct mmu_notifier *gru_mn ;
  struct hlist_node *____ptr ;
  struct hlist_node *________p1 ;
  struct hlist_node *_________p1 ;
  struct hlist_node *__var ;
  bool __warned ;
  int tmp ;
  struct hlist_node  const  *__mptr ;
  struct mmu_notifier *tmp___0 ;
  struct hlist_node *____ptr___0 ;
  struct hlist_node *________p1___0 ;
  struct hlist_node *_________p1___0 ;
  struct hlist_node *__var___0 ;
  bool __warned___0 ;
  int tmp___1 ;
  struct hlist_node  const  *__mptr___0 ;
  struct mmu_notifier *tmp___2 ;

  {
#line 282
  gru_mn = (struct mmu_notifier *)0;
#line 284
  if ((unsigned long )mm->mmu_notifier_mm != (unsigned long )((struct mmu_notifier_mm *)0)) {
    {
#line 285
    rcu_read_lock();
#line 286
    __var = (struct hlist_node *)0;
#line 286
    _________p1 = *((struct hlist_node * volatile  *)(& (mm->mmu_notifier_mm)->list.first));
#line 286
    ________p1 = _________p1;
#line 286
    tmp = debug_lockdep_rcu_enabled();
    }
#line 286
    if (tmp != 0 && ! __warned) {
      {
#line 286
      rcu_read_lock_held();
      }
    } else {

    }
#line 286
    ____ptr = ________p1;
#line 286
    if ((unsigned long )____ptr != (unsigned long )((struct hlist_node *)0)) {
#line 286
      __mptr = (struct hlist_node  const  *)____ptr;
#line 286
      tmp___0 = (struct mmu_notifier *)__mptr;
    } else {
#line 286
      tmp___0 = (struct mmu_notifier *)0;
    }
#line 286
    mn = tmp___0;
#line 286
    goto ldv_35005;
    ldv_35004: ;
#line 288
    if ((unsigned long )mn->ops == (unsigned long )ops) {
#line 289
      gru_mn = mn;
#line 290
      goto ldv_35003;
    } else {

    }
    {
#line 286
    __var___0 = (struct hlist_node *)0;
#line 286
    _________p1___0 = *((struct hlist_node * volatile  *)(& mn->hlist.next));
#line 286
    ________p1___0 = _________p1___0;
#line 286
    tmp___1 = debug_lockdep_rcu_enabled();
    }
#line 286
    if (tmp___1 != 0 && ! __warned___0) {
      {
#line 286
      rcu_read_lock_held();
      }
    } else {

    }
#line 286
    ____ptr___0 = ________p1___0;
#line 286
    if ((unsigned long )____ptr___0 != (unsigned long )((struct hlist_node *)0)) {
#line 286
      __mptr___0 = (struct hlist_node  const  *)____ptr___0;
#line 286
      tmp___2 = (struct mmu_notifier *)__mptr___0;
    } else {
#line 286
      tmp___2 = (struct mmu_notifier *)0;
    }
#line 286
    mn = tmp___2;
    ldv_35005: ;
#line 286
    if ((unsigned long )mn != (unsigned long )((struct mmu_notifier *)0)) {
#line 288
      goto ldv_35004;
    } else {

    }
    ldv_35003: 
    {
#line 292
    rcu_read_unlock();
    }
  } else {

  }
#line 294
  return (gru_mn);
}
}
#line 297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
struct gru_mm_struct *gru_register_mmu_notifier(void) 
{ 
  struct gru_mm_struct *gms ;
  struct mmu_notifier *mn ;
  int err ;
  struct task_struct *tmp ;
  struct mmu_notifier  const  *__mptr ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  void *tmp___3 ;

  {
  {
#line 303
  tmp = get_current___2();
#line 303
  mn = mmu_find_ops(tmp->mm, & gru_mmuops);
  }
#line 304
  if ((unsigned long )mn != (unsigned long )((struct mmu_notifier *)0)) {
    {
#line 305
    __mptr = (struct mmu_notifier  const  *)mn;
#line 305
    gms = (struct gru_mm_struct *)__mptr;
#line 306
    atomic_inc(& gms->ms_refcnt);
    }
  } else {
    {
#line 308
    tmp___0 = kzalloc(16840UL, 208U);
#line 308
    gms = (struct gru_mm_struct *)tmp___0;
    }
#line 309
    if ((unsigned long )gms != (unsigned long )((struct gru_mm_struct *)0)) {
#line 310
      if ((gru_options & 2UL) != 0UL) {
        {
#line 310
        atomic_long_inc(& gru_stats.gms_alloc);
        }
      } else {

      }
      {
#line 311
      spinlock_check(& gms->ms_asid_lock);
#line 311
      __raw_spin_lock_init(& gms->ms_asid_lock.__annonCompField18.rlock, "&(&gms->ms_asid_lock)->rlock",
                           & __key);
#line 312
      gms->ms_notifier.ops = & gru_mmuops;
#line 313
      atomic_set(& gms->ms_refcnt, 1);
#line 314
      __init_waitqueue_head(& gms->ms_wait_queue, "&gms->ms_wait_queue", & __key___0);
#line 315
      tmp___1 = get_current___2();
#line 315
      err = ldv___mmu_notifier_register_100(& gms->ms_notifier, tmp___1->mm);
      }
#line 316
      if (err != 0) {
#line 317
        goto error;
      } else {

      }
    } else {

    }
  }
#line 320
  if ((int )gru_options & 1) {
    {
#line 320
    tmp___2 = atomic_read((atomic_t const   *)(& gms->ms_refcnt));
#line 320
    __vpp_verify = (void const   *)0;
    }
    {
#line 320
    if (4UL == 1UL) {
#line 320
      goto case_1;
    } else {

    }
#line 321
    if (4UL == 2UL) {
#line 321
      goto case_2___0;
    } else {

    }
#line 321
    if (4UL == 4UL) {
#line 321
      goto case_4___1;
    } else {

    }
#line 321
    if (4UL == 8UL) {
#line 321
      goto case_8___2;
    } else {

    }
#line 321
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 321
    if (4UL == 1UL) {
#line 321
      goto case_1___0;
    } else {

    }
#line 321
    if (4UL == 2UL) {
#line 321
      goto case_2;
    } else {

    }
#line 321
    if (4UL == 4UL) {
#line 321
      goto case_4;
    } else {

    }
#line 321
    if (4UL == 8UL) {
#line 321
      goto case_8;
    } else {

    }
#line 321
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 321
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 321
    goto ldv_35022;
    case_2: /* CIL Label */ 
#line 321
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 321
    goto ldv_35022;
    case_4: /* CIL Label */ 
#line 321
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 321
    goto ldv_35022;
    case_8: /* CIL Label */ 
#line 321
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 321
    goto ldv_35022;
    switch_default: /* CIL Label */ 
    {
#line 321
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_35022: 
#line 321
    pscr_ret__ = pfo_ret__;
#line 321
    goto ldv_35028;
    case_2___0: /* CIL Label */ ;
    {
#line 321
    if (4UL == 1UL) {
#line 321
      goto case_1___1;
    } else {

    }
#line 321
    if (4UL == 2UL) {
#line 321
      goto case_2___1;
    } else {

    }
#line 321
    if (4UL == 4UL) {
#line 321
      goto case_4___0;
    } else {

    }
#line 321
    if (4UL == 8UL) {
#line 321
      goto case_8___0;
    } else {

    }
#line 321
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 321
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 321
    goto ldv_35032;
    case_2___1: /* CIL Label */ 
#line 321
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 321
    goto ldv_35032;
    case_4___0: /* CIL Label */ 
#line 321
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 321
    goto ldv_35032;
    case_8___0: /* CIL Label */ 
#line 321
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 321
    goto ldv_35032;
    switch_default___0: /* CIL Label */ 
    {
#line 321
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_35032: 
#line 321
    pscr_ret__ = pfo_ret_____0;
#line 321
    goto ldv_35028;
    case_4___1: /* CIL Label */ ;
    {
#line 321
    if (4UL == 1UL) {
#line 321
      goto case_1___2;
    } else {

    }
#line 321
    if (4UL == 2UL) {
#line 321
      goto case_2___2;
    } else {

    }
#line 321
    if (4UL == 4UL) {
#line 321
      goto case_4___2;
    } else {

    }
#line 321
    if (4UL == 8UL) {
#line 321
      goto case_8___1;
    } else {

    }
#line 321
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 321
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 321
    goto ldv_35041;
    case_2___2: /* CIL Label */ 
#line 321
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 321
    goto ldv_35041;
    case_4___2: /* CIL Label */ 
#line 321
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 321
    goto ldv_35041;
    case_8___1: /* CIL Label */ 
#line 321
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 321
    goto ldv_35041;
    switch_default___1: /* CIL Label */ 
    {
#line 321
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_35041: 
#line 321
    pscr_ret__ = pfo_ret_____1;
#line 321
    goto ldv_35028;
    case_8___2: /* CIL Label */ ;
    {
#line 321
    if (4UL == 1UL) {
#line 321
      goto case_1___3;
    } else {

    }
#line 321
    if (4UL == 2UL) {
#line 321
      goto case_2___3;
    } else {

    }
#line 321
    if (4UL == 4UL) {
#line 321
      goto case_4___3;
    } else {

    }
#line 321
    if (4UL == 8UL) {
#line 321
      goto case_8___3;
    } else {

    }
#line 321
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 321
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 321
    goto ldv_35050;
    case_2___3: /* CIL Label */ 
#line 321
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 321
    goto ldv_35050;
    case_4___3: /* CIL Label */ 
#line 321
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 321
    goto ldv_35050;
    case_8___3: /* CIL Label */ 
#line 321
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 321
    goto ldv_35050;
    switch_default___2: /* CIL Label */ 
    {
#line 321
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_35050: 
#line 321
    pscr_ret__ = pfo_ret_____2;
#line 321
    goto ldv_35028;
    switch_default___3: /* CIL Label */ 
    {
#line 321
    __bad_size_call_parameter();
    }
#line 321
    goto ldv_35028;
    switch_break: /* CIL Label */ ;
    }
    ldv_35028: 
    {
#line 321
    printk("\017GRU:%d %s: gms %p, refcnt %d\n", pscr_ret__, "gru_register_mmu_notifier",
           gms, tmp___2);
    }
  } else {

  }
#line 322
  return (gms);
  error: 
  {
#line 324
  kfree((void const   *)gms);
#line 325
  tmp___3 = ERR_PTR((long )err);
  }
#line 325
  return ((struct gru_mm_struct *)tmp___3);
}
}
#line 328 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
void gru_drop_mmu_notifier(struct gru_mm_struct *gms ) 
{ 
  int tmp ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;

  {
#line 330
  if ((int )gru_options & 1) {
    {
#line 330
    tmp = atomic_read((atomic_t const   *)(& gms->ms_refcnt));
#line 330
    __vpp_verify = (void const   *)0;
    }
    {
#line 330
    if (4UL == 1UL) {
#line 330
      goto case_1;
    } else {

    }
#line 331
    if (4UL == 2UL) {
#line 331
      goto case_2___0;
    } else {

    }
#line 331
    if (4UL == 4UL) {
#line 331
      goto case_4___1;
    } else {

    }
#line 331
    if (4UL == 8UL) {
#line 331
      goto case_8___2;
    } else {

    }
#line 331
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 331
    if (4UL == 1UL) {
#line 331
      goto case_1___0;
    } else {

    }
#line 331
    if (4UL == 2UL) {
#line 331
      goto case_2;
    } else {

    }
#line 331
    if (4UL == 4UL) {
#line 331
      goto case_4;
    } else {

    }
#line 331
    if (4UL == 8UL) {
#line 331
      goto case_8;
    } else {

    }
#line 331
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 331
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 331
    goto ldv_35067;
    case_2: /* CIL Label */ 
#line 331
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 331
    goto ldv_35067;
    case_4: /* CIL Label */ 
#line 331
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 331
    goto ldv_35067;
    case_8: /* CIL Label */ 
#line 331
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 331
    goto ldv_35067;
    switch_default: /* CIL Label */ 
    {
#line 331
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_35067: 
#line 331
    pscr_ret__ = pfo_ret__;
#line 331
    goto ldv_35073;
    case_2___0: /* CIL Label */ ;
    {
#line 331
    if (4UL == 1UL) {
#line 331
      goto case_1___1;
    } else {

    }
#line 331
    if (4UL == 2UL) {
#line 331
      goto case_2___1;
    } else {

    }
#line 331
    if (4UL == 4UL) {
#line 331
      goto case_4___0;
    } else {

    }
#line 331
    if (4UL == 8UL) {
#line 331
      goto case_8___0;
    } else {

    }
#line 331
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 331
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 331
    goto ldv_35077;
    case_2___1: /* CIL Label */ 
#line 331
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 331
    goto ldv_35077;
    case_4___0: /* CIL Label */ 
#line 331
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 331
    goto ldv_35077;
    case_8___0: /* CIL Label */ 
#line 331
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 331
    goto ldv_35077;
    switch_default___0: /* CIL Label */ 
    {
#line 331
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_35077: 
#line 331
    pscr_ret__ = pfo_ret_____0;
#line 331
    goto ldv_35073;
    case_4___1: /* CIL Label */ ;
    {
#line 331
    if (4UL == 1UL) {
#line 331
      goto case_1___2;
    } else {

    }
#line 331
    if (4UL == 2UL) {
#line 331
      goto case_2___2;
    } else {

    }
#line 331
    if (4UL == 4UL) {
#line 331
      goto case_4___2;
    } else {

    }
#line 331
    if (4UL == 8UL) {
#line 331
      goto case_8___1;
    } else {

    }
#line 331
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 331
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 331
    goto ldv_35086;
    case_2___2: /* CIL Label */ 
#line 331
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 331
    goto ldv_35086;
    case_4___2: /* CIL Label */ 
#line 331
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 331
    goto ldv_35086;
    case_8___1: /* CIL Label */ 
#line 331
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 331
    goto ldv_35086;
    switch_default___1: /* CIL Label */ 
    {
#line 331
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_35086: 
#line 331
    pscr_ret__ = pfo_ret_____1;
#line 331
    goto ldv_35073;
    case_8___2: /* CIL Label */ ;
    {
#line 331
    if (4UL == 1UL) {
#line 331
      goto case_1___3;
    } else {

    }
#line 331
    if (4UL == 2UL) {
#line 331
      goto case_2___3;
    } else {

    }
#line 331
    if (4UL == 4UL) {
#line 331
      goto case_4___3;
    } else {

    }
#line 331
    if (4UL == 8UL) {
#line 331
      goto case_8___3;
    } else {

    }
#line 331
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 331
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 331
    goto ldv_35095;
    case_2___3: /* CIL Label */ 
#line 331
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 331
    goto ldv_35095;
    case_4___3: /* CIL Label */ 
#line 331
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 331
    goto ldv_35095;
    case_8___3: /* CIL Label */ 
#line 331
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 331
    goto ldv_35095;
    switch_default___2: /* CIL Label */ 
    {
#line 331
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_35095: 
#line 331
    pscr_ret__ = pfo_ret_____2;
#line 331
    goto ldv_35073;
    switch_default___3: /* CIL Label */ 
    {
#line 331
    __bad_size_call_parameter();
    }
#line 331
    goto ldv_35073;
    switch_break: /* CIL Label */ ;
    }
    ldv_35073: 
    {
#line 331
    printk("\017GRU:%d %s: gms %p, refcnt %d, released %d\n", pscr_ret__, "gru_drop_mmu_notifier",
           gms, tmp, (int )gms->ms_released);
    }
  } else {

  }
  {
#line 332
  tmp___1 = atomic_sub_return___0(1, & gms->ms_refcnt);
  }
#line 332
  if (tmp___1 == 0) {
#line 333
    if ((int )((signed char )gms->ms_released) == 0) {
      {
#line 334
      tmp___0 = get_current___2();
#line 334
      ldv_mmu_notifier_unregister_101(& gms->ms_notifier, tmp___0->mm);
      }
    } else {

    }
    {
#line 335
    kfree((void const   *)gms);
    }
#line 336
    if ((gru_options & 2UL) != 0UL) {
      {
#line 336
      atomic_long_inc(& gru_stats.gms_free);
      }
    } else {

    }
  } else {

  }
#line 338
  return;
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutlbpurge.c"
void gru_tgh_flush_init(struct gru_state *gru ) 
{ 
  int cpus ;
  int shift ;
  int n ;
  int tmp ;
  int _max1 ;
  int _max2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 356
  shift = 0;
#line 358
  cpus = uv_blade_nr_possible_cpus((int )gru->gs_blade_id);
  }
#line 361
  if (cpus != 0) {
    {
#line 362
    tmp = fls(cpus + -1);
#line 362
    n = 1 << tmp;
#line 370
    _max1 = 0;
#line 370
    tmp___0 = fls(n + -1);
#line 370
    tmp___1 = fls(15);
#line 370
    _max2 = tmp___0 - tmp___1;
#line 370
    shift = _max1 > _max2 ? _max1 : _max2;
    }
  } else {

  }
#line 372
  gru->gs_tgh_local_shift = (unsigned char )shift;
#line 375
  gru->gs_tgh_first_remote = (unsigned char )(((cpus + (1 << shift)) + -1) >> shift);
#line 376
  return;
}
}
#line 650 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
extern int ldv___mmu_notifier_register(int  , struct mmu_notifier * , struct mm_struct * ) ;
#line 657
extern void ldv_mmu_notifier_unregister(void * , struct mmu_notifier * , struct mm_struct * ) ;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
void ldv_dummy_resourceless_instance_callback_11_12(void (*arg0)(struct mmu_notifier * ,
                                                                 struct mm_struct * ,
                                                                 unsigned long  ,
                                                                 unsigned long  ) ,
                                                    struct mmu_notifier *arg1 , struct mm_struct *arg2 ,
                                                    unsigned long arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 666
  gru_invalidate_range_start(arg1, arg2, arg3, arg4);
  }
#line 667
  return;
}
}
#line 670 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
void ldv_dummy_resourceless_instance_callback_11_15(void (*arg0)(struct mmu_notifier * ,
                                                                 struct mm_struct * ) ,
                                                    struct mmu_notifier *arg1 , struct mm_struct *arg2 ) 
{ 


  {
  {
#line 671
  gru_release(arg1, arg2);
  }
#line 672
  return;
}
}
#line 675 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
void ldv_dummy_resourceless_instance_callback_11_3(void (*arg0)(struct mmu_notifier * ,
                                                                struct mm_struct * ,
                                                                unsigned long  ) ,
                                                   struct mmu_notifier *arg1 , struct mm_struct *arg2 ,
                                                   unsigned long arg3 ) 
{ 


  {
  {
#line 676
  gru_invalidate_page(arg1, arg2, arg3);
  }
#line 677
  return;
}
}
#line 680 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
void ldv_dummy_resourceless_instance_callback_11_9(void (*arg0)(struct mmu_notifier * ,
                                                                struct mm_struct * ,
                                                                unsigned long  , unsigned long  ) ,
                                                   struct mmu_notifier *arg1 , struct mm_struct *arg2 ,
                                                   unsigned long arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 681
  gru_invalidate_range_end(arg1, arg2, arg3, arg4);
  }
#line 682
  return;
}
}
#line 763 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
__inline static int atomic_dec_and_test(atomic_t *v ) 
{ 
  int tmp ;

  {
  {
#line 766
  tmp = ldv_linux_usb_dev_atomic_dec_and_test(v);
  }
#line 766
  return (tmp);
}
}
#line 927 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
__inline static void rcu_read_lock(void) 
{ 


  {
  {
#line 930
  ldv_linux_kernel_rcu_update_lock_rcu_read_lock();
  }
#line 931
  return;
}
}
#line 933 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
__inline static void rcu_read_unlock(void) 
{ 


  {
  {
#line 936
  ldv_linux_kernel_rcu_update_lock_rcu_read_unlock();
  }
#line 937
  return;
}
}
#line 1330 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 1333
  tmp = ldv_kzalloc(size, flags);
  }
#line 1333
  return (tmp);
}
}
#line 1383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
static unsigned long ldv_find_first_bit_97(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1386
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1386
  return (tmp);
}
}
#line 1389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
static unsigned long ldv_find_next_bit_98(unsigned long const   *addr , unsigned long size ,
                                          unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1392
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1392
  return (tmp);
}
}
#line 1403 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
static int ldv___mmu_notifier_register_100(struct mmu_notifier *ldv_func_arg1 , struct mm_struct *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1407
  tmp = __mmu_notifier_register(ldv_func_arg1, ldv_func_arg2);
#line 1407
  ldv_func_res = tmp;
#line 1410
  tmp___0 = ldv___mmu_notifier_register(ldv_func_res, ldv_func_arg1, ldv_func_arg2);
  }
#line 1410
  return (tmp___0);
#line 1412
  return (ldv_func_res);
}
}
#line 1415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grutlbpurge.c.aux"
static void ldv_mmu_notifier_unregister_101(struct mmu_notifier *ldv_func_arg1 , struct mm_struct *ldv_func_arg2 ) 
{ 


  {
  {
#line 1418
  mmu_notifier_unregister(ldv_func_arg1, ldv_func_arg2);
#line 1421
  ldv_mmu_notifier_unregister((void *)0, ldv_func_arg1, ldv_func_arg2);
  }
#line 1422
  return;
}
}
#line 75 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_filter_err_code(int ret_val ) ;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern int kstrtoul_from_user(char const   * , size_t  , unsigned int  , unsigned long * ) ;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic64_64.h"
__inline static long atomic64_read(atomic64_t const   *v ) 
{ 
  long __var ;

  {
#line 25
  __var = 0L;
#line 25
  return ((long )*((long const volatile   *)(& v->counter)));
}
}
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
__inline static long atomic_long_read(atomic_long_t *l ) 
{ 
  atomic64_t *v ;
  long tmp ;

  {
  {
#line 29
  v = l;
#line 31
  tmp = atomic64_read((atomic64_t const   *)v);
  }
#line 31
  return (tmp);
}
}
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/proc_fs.h"
extern struct proc_dir_entry *proc_mkdir(char const   * , struct proc_dir_entry * ) ;
#line 25
extern struct proc_dir_entry *proc_create_data(char const   * , umode_t  , struct proc_dir_entry * ,
                                               struct file_operations  const  * ,
                                               void * ) ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/proc_fs.h"
__inline static struct proc_dir_entry *proc_create(char const   *name , umode_t mode ,
                                                   struct proc_dir_entry *parent ,
                                                   struct file_operations  const  *proc_fops ) 
{ 
  struct proc_dir_entry *tmp ;

  {
  {
#line 34
  tmp = proc_create_data(name, (int )mode, parent, proc_fops, (void *)0);
  }
#line 34
  return (tmp);
}
}
#line 41
extern void proc_remove(struct proc_dir_entry * ) ;
#line 42
extern void remove_proc_entry(char const   * , struct proc_dir_entry * ) ;
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
extern int seq_open(struct file * , struct seq_operations  const  * ) ;
#line 116
static int ldv_seq_open_95(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) ;
#line 120
static int ldv_seq_open_96(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) ;
#line 122
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 123
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 124
extern int seq_release(struct inode * , struct file * ) ;
#line 130
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 138
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
#line 140
extern int single_release(struct inode * , struct file * ) ;
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct mcs_op_statistic mcs_op_statistics[8U] ;
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static void printstat_val(struct seq_file *s , atomic_long_t *v , char *id ) 
{ 
  unsigned long val ;
  long tmp ;

  {
  {
#line 37
  tmp = atomic_long_read(v);
#line 37
  val = (unsigned long )tmp;
#line 39
  seq_printf(s, "%16lu %s\n", val, id);
  }
#line 40
  return;
}
}
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int statistics_show(struct seq_file *s , void *p ) 
{ 


  {
  {
#line 44
  printstat_val(s, & gru_stats.vdata_alloc, (char *)"vdata_alloc");
#line 45
  printstat_val(s, & gru_stats.vdata_free, (char *)"vdata_free");
#line 46
  printstat_val(s, & gru_stats.gts_alloc, (char *)"gts_alloc");
#line 47
  printstat_val(s, & gru_stats.gts_free, (char *)"gts_free");
#line 48
  printstat_val(s, & gru_stats.gms_alloc, (char *)"gms_alloc");
#line 49
  printstat_val(s, & gru_stats.gms_free, (char *)"gms_free");
#line 50
  printstat_val(s, & gru_stats.gts_double_allocate, (char *)"gts_double_allocate");
#line 51
  printstat_val(s, & gru_stats.assign_context, (char *)"assign_context");
#line 52
  printstat_val(s, & gru_stats.assign_context_failed, (char *)"assign_context_failed");
#line 53
  printstat_val(s, & gru_stats.free_context, (char *)"free_context");
#line 54
  printstat_val(s, & gru_stats.load_user_context, (char *)"load_user_context");
#line 55
  printstat_val(s, & gru_stats.load_kernel_context, (char *)"load_kernel_context");
#line 56
  printstat_val(s, & gru_stats.lock_kernel_context, (char *)"lock_kernel_context");
#line 57
  printstat_val(s, & gru_stats.unlock_kernel_context, (char *)"unlock_kernel_context");
#line 58
  printstat_val(s, & gru_stats.steal_user_context, (char *)"steal_user_context");
#line 59
  printstat_val(s, & gru_stats.steal_kernel_context, (char *)"steal_kernel_context");
#line 60
  printstat_val(s, & gru_stats.steal_context_failed, (char *)"steal_context_failed");
#line 61
  printstat_val(s, & gru_stats.nopfn, (char *)"nopfn");
#line 62
  printstat_val(s, & gru_stats.asid_new, (char *)"asid_new");
#line 63
  printstat_val(s, & gru_stats.asid_next, (char *)"asid_next");
#line 64
  printstat_val(s, & gru_stats.asid_wrap, (char *)"asid_wrap");
#line 65
  printstat_val(s, & gru_stats.asid_reuse, (char *)"asid_reuse");
#line 66
  printstat_val(s, & gru_stats.intr, (char *)"intr");
#line 67
  printstat_val(s, & gru_stats.intr_cbr, (char *)"intr_cbr");
#line 68
  printstat_val(s, & gru_stats.intr_tfh, (char *)"intr_tfh");
#line 69
  printstat_val(s, & gru_stats.intr_spurious, (char *)"intr_spurious");
#line 70
  printstat_val(s, & gru_stats.intr_mm_lock_failed, (char *)"intr_mm_lock_failed");
#line 71
  printstat_val(s, & gru_stats.call_os, (char *)"call_os");
#line 72
  printstat_val(s, & gru_stats.call_os_wait_queue, (char *)"call_os_wait_queue");
#line 73
  printstat_val(s, & gru_stats.user_flush_tlb, (char *)"user_flush_tlb");
#line 74
  printstat_val(s, & gru_stats.user_unload_context, (char *)"user_unload_context");
#line 75
  printstat_val(s, & gru_stats.user_exception, (char *)"user_exception");
#line 76
  printstat_val(s, & gru_stats.set_context_option, (char *)"set_context_option");
#line 77
  printstat_val(s, & gru_stats.check_context_retarget_intr, (char *)"check_context_retarget_intr");
#line 78
  printstat_val(s, & gru_stats.check_context_unload, (char *)"check_context_unload");
#line 79
  printstat_val(s, & gru_stats.tlb_dropin, (char *)"tlb_dropin");
#line 80
  printstat_val(s, & gru_stats.tlb_preload_page, (char *)"tlb_preload_page");
#line 81
  printstat_val(s, & gru_stats.tlb_dropin_fail_no_asid, (char *)"tlb_dropin_fail_no_asid");
#line 82
  printstat_val(s, & gru_stats.tlb_dropin_fail_upm, (char *)"tlb_dropin_fail_upm");
#line 83
  printstat_val(s, & gru_stats.tlb_dropin_fail_invalid, (char *)"tlb_dropin_fail_invalid");
#line 84
  printstat_val(s, & gru_stats.tlb_dropin_fail_range_active, (char *)"tlb_dropin_fail_range_active");
#line 85
  printstat_val(s, & gru_stats.tlb_dropin_fail_idle, (char *)"tlb_dropin_fail_idle");
#line 86
  printstat_val(s, & gru_stats.tlb_dropin_fail_fmm, (char *)"tlb_dropin_fail_fmm");
#line 87
  printstat_val(s, & gru_stats.tlb_dropin_fail_no_exception, (char *)"tlb_dropin_fail_no_exception");
#line 88
  printstat_val(s, & gru_stats.tfh_stale_on_fault, (char *)"tfh_stale_on_fault");
#line 89
  printstat_val(s, & gru_stats.mmu_invalidate_range, (char *)"mmu_invalidate_range");
#line 90
  printstat_val(s, & gru_stats.mmu_invalidate_page, (char *)"mmu_invalidate_page");
#line 91
  printstat_val(s, & gru_stats.flush_tlb, (char *)"flush_tlb");
#line 92
  printstat_val(s, & gru_stats.flush_tlb_gru, (char *)"flush_tlb_gru");
#line 93
  printstat_val(s, & gru_stats.flush_tlb_gru_tgh, (char *)"flush_tlb_gru_tgh");
#line 94
  printstat_val(s, & gru_stats.flush_tlb_gru_zero_asid, (char *)"flush_tlb_gru_zero_asid");
#line 95
  printstat_val(s, & gru_stats.copy_gpa, (char *)"copy_gpa");
#line 96
  printstat_val(s, & gru_stats.read_gpa, (char *)"read_gpa");
#line 97
  printstat_val(s, & gru_stats.mesq_receive, (char *)"mesq_receive");
#line 98
  printstat_val(s, & gru_stats.mesq_receive_none, (char *)"mesq_receive_none");
#line 99
  printstat_val(s, & gru_stats.mesq_send, (char *)"mesq_send");
#line 100
  printstat_val(s, & gru_stats.mesq_send_failed, (char *)"mesq_send_failed");
#line 101
  printstat_val(s, & gru_stats.mesq_noop, (char *)"mesq_noop");
#line 102
  printstat_val(s, & gru_stats.mesq_send_unexpected_error, (char *)"mesq_send_unexpected_error");
#line 103
  printstat_val(s, & gru_stats.mesq_send_lb_overflow, (char *)"mesq_send_lb_overflow");
#line 104
  printstat_val(s, & gru_stats.mesq_send_qlimit_reached, (char *)"mesq_send_qlimit_reached");
#line 105
  printstat_val(s, & gru_stats.mesq_send_amo_nacked, (char *)"mesq_send_amo_nacked");
#line 106
  printstat_val(s, & gru_stats.mesq_send_put_nacked, (char *)"mesq_send_put_nacked");
#line 107
  printstat_val(s, & gru_stats.mesq_qf_locked, (char *)"mesq_qf_locked");
#line 108
  printstat_val(s, & gru_stats.mesq_qf_noop_not_full, (char *)"mesq_qf_noop_not_full");
#line 109
  printstat_val(s, & gru_stats.mesq_qf_switch_head_failed, (char *)"mesq_qf_switch_head_failed");
#line 110
  printstat_val(s, & gru_stats.mesq_qf_unexpected_error, (char *)"mesq_qf_unexpected_error");
#line 111
  printstat_val(s, & gru_stats.mesq_noop_unexpected_error, (char *)"mesq_noop_unexpected_error");
#line 112
  printstat_val(s, & gru_stats.mesq_noop_lb_overflow, (char *)"mesq_noop_lb_overflow");
#line 113
  printstat_val(s, & gru_stats.mesq_noop_qlimit_reached, (char *)"mesq_noop_qlimit_reached");
#line 114
  printstat_val(s, & gru_stats.mesq_noop_amo_nacked, (char *)"mesq_noop_amo_nacked");
#line 115
  printstat_val(s, & gru_stats.mesq_noop_put_nacked, (char *)"mesq_noop_put_nacked");
#line 116
  printstat_val(s, & gru_stats.mesq_noop_page_overflow, (char *)"mesq_noop_page_overflow");
  }
#line 117
  return (0);
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static ssize_t statistics_write(struct file *file , char const   *userbuf , size_t count ,
                                loff_t *data ) 
{ 


  {
  {
#line 123
  __memset((void *)(& gru_stats), 0, 592UL);
  }
#line 124
  return ((ssize_t )count);
}
}
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int mcs_statistics_show(struct seq_file *s , void *p ) 
{ 
  int op ;
  unsigned long total ;
  unsigned long count ;
  unsigned long max ;
  char *id[8U] ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 131
  id[0] = (char *)"cch_allocate";
#line 131
  id[1] = (char *)"cch_start";
#line 131
  id[2] = (char *)"cch_interrupt";
#line 131
  id[3] = (char *)"cch_interrupt_sync";
#line 131
  id[4] = (char *)"cch_deallocate";
#line 131
  id[5] = (char *)"tfh_write_only";
#line 131
  id[6] = (char *)"tfh_write_restart";
#line 131
  id[7] = (char *)"tgh_invalidate";
#line 135
  seq_printf(s, "%-20s%12s%12s%12s\n", (char *)"#id", (char *)"count", (char *)"aver-clks",
             (char *)"max-clks");
#line 136
  op = 0;
  }
#line 136
  goto ldv_32179;
  ldv_32178: 
  {
#line 137
  tmp = atomic_long_read(& mcs_op_statistics[op].count);
#line 137
  count = (unsigned long )tmp;
#line 138
  tmp___0 = atomic_long_read(& mcs_op_statistics[op].total);
#line 138
  total = (unsigned long )tmp___0;
#line 139
  max = mcs_op_statistics[op].max;
#line 140
  seq_printf(s, "%-20s%12ld%12ld%12ld\n", id[op], count, count != 0UL ? total / count : 0UL,
             max);
#line 136
  op = op + 1;
  }
  ldv_32179: ;
#line 136
  if (op <= 7) {
#line 138
    goto ldv_32178;
  } else {

  }

#line 143
  return (0);
}
}
#line 146 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static ssize_t mcs_statistics_write(struct file *file , char const   *userbuf , size_t count ,
                                    loff_t *data ) 
{ 


  {
  {
#line 149
  __memset((void *)(& mcs_op_statistics), 0, 192UL);
  }
#line 150
  return ((ssize_t )count);
}
}
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int options_show(struct seq_file *s , void *p ) 
{ 


  {
  {
#line 155
  seq_printf(s, "#bitmask: 1=trace, 2=statistics\n");
#line 156
  seq_printf(s, "0x%lx\n", gru_options);
  }
#line 157
  return (0);
}
}
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static ssize_t options_write(struct file *file , char const   *userbuf , size_t count ,
                             loff_t *data ) 
{ 
  int ret ;

  {
  {
#line 165
  ret = kstrtoul_from_user(userbuf, count, 0U, & gru_options);
  }
#line 166
  if (ret != 0) {
#line 167
    return ((ssize_t )ret);
  } else {

  }
#line 169
  return ((ssize_t )count);
}
}
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int cch_seq_show(struct seq_file *file , void *data ) 
{ 
  long gid ;
  int i ;
  struct gru_state *gru ;
  struct gru_thread_state *ts ;
  char const   *mode[4U] ;
  int tmp ;
  int tmp___0 ;

  {
#line 174
  gid = *((long *)data);
#line 176
  gru = (unsigned long )gru_base[gid / 2L] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[gid / 2L])->bs_grus) + (unsigned long )(gid % 2L) : (struct gru_state *)0;
#line 178
  mode[0] = "??";
#line 178
  mode[1] = "UPM";
#line 178
  mode[2] = "INTR";
#line 178
  mode[3] = "OS_POLL";
#line 180
  if (gid == 0L) {
    {
#line 181
    seq_printf(file, "#%5s%5s%6s%7s%9s%6s%8s%8s\n", (char *)"gid", (char *)"bid",
               (char *)"ctx#", (char *)"asid", (char *)"pid", (char *)"cbrs", (char *)"dsbytes",
               (char *)"mode");
    }
  } else {

  }
#line 183
  if ((unsigned long )gru != (unsigned long )((struct gru_state *)0)) {
#line 184
    i = 0;
#line 184
    goto ldv_32209;
    ldv_32208: 
#line 185
    ts = gru->gs_gts[i];
#line 186
    if ((unsigned long )ts == (unsigned long )((struct gru_thread_state *)0)) {
#line 187
      goto ldv_32207;
    } else {

    }
    {
#line 188
    tmp = is_kernel_context(ts);
#line 188
    tmp___0 = is_kernel_context(ts);
#line 188
    seq_printf(file, " %5d%5d%6d%7d%9d%6d%8d%8s\n", (int )gru->gs_gid, (int )gru->gs_blade_id,
               i, tmp___0 == 0 ? (int )(ts->ts_gms)->ms_asids[gid].mt_asid : 0, tmp == 0 ? ts->ts_tgid_owner : 0,
               (int )ts->ts_cbr_au_count * 2, (int )ts->ts_cbr_au_count * 1024, mode[ts->ts_user_options & 3L]);
    }
    ldv_32207: 
#line 184
    i = i + 1;
    ldv_32209: ;
#line 184
    if (i <= 15) {
#line 186
      goto ldv_32208;
    } else {

    }

  } else {

  }
#line 198
  return (0);
}
}
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int gru_seq_show(struct seq_file *file , void *data ) 
{ 
  long gid ;
  long ctxfree ;
  long cbrfree ;
  long dsrfree ;
  struct gru_state *gru ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 203
  gid = *((long *)data);
#line 204
  gru = (unsigned long )gru_base[gid / 2L] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[gid / 2L])->bs_grus) + (unsigned long )(gid % 2L) : (struct gru_state *)0;
#line 206
  if (gid == 0L) {
    {
#line 207
    seq_printf(file, "#%5s%5s%7s%6s%6s%8s%6s%6s\n", (char *)"gid", (char *)"nid",
               (char *)"ctx", (char *)"cbr", (char *)"dsr", (char *)"ctx", (char *)"cbr",
               (char *)"dsr");
#line 209
    seq_printf(file, "#%5s%5s%7s%6s%6s%8s%6s%6s\n", (char *)"", (char *)"", (char *)"busy",
               (char *)"busy", (char *)"busy", (char *)"free", (char *)"free", (char *)"free");
    }
  } else {

  }
#line 212
  if ((unsigned long )gru != (unsigned long )((struct gru_state *)0)) {
    {
#line 213
    ctxfree = (long )(16 - (int )gru->gs_active_contexts);
#line 214
    tmp = __arch_hweight64((__u64 )gru->gs_cbr_map);
#line 214
    cbrfree = (long )(tmp * 2UL);
#line 215
    tmp___0 = __arch_hweight64((__u64 )gru->gs_dsr_map);
#line 215
    dsrfree = (long )(tmp___0 * 1024UL);
#line 216
    seq_printf(file, " %5d%5d%7ld%6ld%6ld%8ld%6ld%6ld\n", (int )gru->gs_gid, (int )gru->gs_blade_id,
               16L - ctxfree, 128L - cbrfree, 32768L - dsrfree, ctxfree, cbrfree,
               dsrfree);
    }
  } else {

  }
#line 222
  return (0);
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static void seq_stop(struct seq_file *file , void *data ) 
{ 


  {
#line 227
  return;
}
}
#line 229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static void *seq_start(struct seq_file *file , loff_t *gid ) 
{ 


  {
#line 231
  if (*gid < (loff_t )gru_max_gids) {
#line 232
    return ((void *)gid);
  } else {

  }
#line 233
  return ((void *)0);
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static void *seq_next(struct seq_file *file , void *data , loff_t *gid ) 
{ 


  {
#line 238
  *gid = *gid + 1LL;
#line 239
  if (*gid < (loff_t )gru_max_gids) {
#line 240
    return ((void *)gid);
  } else {

  }
#line 241
  return ((void *)0);
}
}
#line 244 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct seq_operations  const  cch_seq_ops  =    {& seq_start, & seq_stop, & seq_next, & cch_seq_show};
#line 251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct seq_operations  const  gru_seq_ops  =    {& seq_start, & seq_stop, & seq_next, & gru_seq_show};
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int statistics_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  {
#line 260
  tmp = single_open(file, & statistics_show, (void *)0);
  }
#line 260
  return (tmp);
}
}
#line 263 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int mcs_statistics_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  {
#line 265
  tmp = single_open(file, & mcs_statistics_show, (void *)0);
  }
#line 265
  return (tmp);
}
}
#line 268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int options_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  {
#line 270
  tmp = single_open(file, & options_show, (void *)0);
  }
#line 270
  return (tmp);
}
}
#line 273 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int cch_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  {
#line 275
  tmp = ldv_seq_open_95(file, & cch_seq_ops);
  }
#line 275
  return (tmp);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int gru_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  {
#line 280
  tmp = ldv_seq_open_96(file, & gru_seq_ops);
  }
#line 280
  return (tmp);
}
}
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  statistics_fops  = 
#line 284
     {0, & seq_lseek, & seq_read, & statistics_write, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    & statistics_open, 0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  mcs_statistics_fops  = 
#line 292
     {0, & seq_lseek, & seq_read, & mcs_statistics_write, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & mcs_statistics_open, 0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
#line 300 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  options_fops  = 
#line 300
     {0, & seq_lseek, & seq_read, & options_write, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & options_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 308 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  cch_fops  = 
#line 308
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & cch_open, 0, & seq_release,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct file_operations  const  gru_fops___0  = 
#line 314
     {0, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & gru_open, 0, & seq_release,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 326 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct proc_entry proc_files[6U]  = {      {(char *)"statistics", 420U, & statistics_fops, 0}, 
        {(char *)"mcs_statistics", 420U, & mcs_statistics_fops, 0}, 
        {(char *)"debug_options", 420U, & options_fops, 0}, 
        {(char *)"cch_status", 292U, & cch_fops, 0}, 
        {(char *)"gru_status", 292U, & gru_fops___0, 0}, 
        {(char *)0, (unsigned short)0, 0, 0}};
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static struct proc_dir_entry *proc_gru  ;
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static int create_proc_file(struct proc_entry *p ) 
{ 


  {
  {
#line 340
  p->entry = proc_create((char const   *)p->name, (int )p->mode, proc_gru, p->fops);
  }
#line 341
  if ((unsigned long )p->entry == (unsigned long )((struct proc_dir_entry *)0)) {
#line 342
    return (-1);
  } else {

  }
#line 343
  return (0);
}
}
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
static void delete_proc_files(void) 
{ 
  struct proc_entry *p ;

  {
#line 350
  if ((unsigned long )proc_gru != (unsigned long )((struct proc_dir_entry *)0)) {
#line 351
    p = (struct proc_entry *)(& proc_files);
#line 351
    goto ldv_32275;
    ldv_32274: ;
#line 352
    if ((unsigned long )p->entry != (unsigned long )((struct proc_dir_entry *)0)) {
      {
#line 353
      remove_proc_entry((char const   *)p->name, proc_gru);
      }
    } else {

    }
#line 351
    p = p + 1;
    ldv_32275: ;
#line 351
    if ((unsigned long )p->name != (unsigned long )((char *)0)) {
#line 353
      goto ldv_32274;
    } else {

    }
    {
#line 354
    proc_remove(proc_gru);
    }
  } else {

  }
#line 356
  return;
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
int gru_proc_init(void) 
{ 
  struct proc_entry *p ;
  int tmp ;

  {
  {
#line 362
  proc_gru = proc_mkdir("sgi_uv/gru", (struct proc_dir_entry *)0);
#line 364
  p = (struct proc_entry *)(& proc_files);
  }
#line 364
  goto ldv_32283;
  ldv_32282: 
  {
#line 365
  tmp = create_proc_file(p);
  }
#line 365
  if (tmp != 0) {
#line 366
    goto err;
  } else {

  }
#line 364
  p = p + 1;
  ldv_32283: ;
#line 364
  if ((unsigned long )p->name != (unsigned long )((char *)0)) {
#line 366
    goto ldv_32282;
  } else {

  }

#line 367
  return (0);
  err: 
  {
#line 370
  delete_proc_files();
  }
#line 371
  return (-1);
}
}
#line 374 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruprocfs.c"
void gru_proc_exit(void) 
{ 


  {
  {
#line 376
  delete_proc_files();
  }
#line 377
  return;
}
}
#line 650 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_dispatch_register_17_1(struct seq_file *arg0 , struct seq_operations *arg1 ) ;
#line 657
void ldv_file_operations_instance_callback_0_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 659
void ldv_file_operations_instance_callback_0_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 661
void ldv_file_operations_instance_callback_1_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 665
void ldv_file_operations_instance_callback_2_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 667
void ldv_file_operations_instance_callback_2_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 669
void ldv_file_operations_instance_callback_3_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 671
void ldv_file_operations_instance_callback_3_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 673
void ldv_file_operations_instance_callback_4_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 675
void ldv_file_operations_instance_callback_4_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 676
int ldv_file_operations_instance_probe_0_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 677
int ldv_file_operations_instance_probe_1_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 678
int ldv_file_operations_instance_probe_2_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 679
int ldv_file_operations_instance_probe_3_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 680
int ldv_file_operations_instance_probe_4_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 681
void ldv_file_operations_instance_release_0_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 682
void ldv_file_operations_instance_release_1_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 683
void ldv_file_operations_instance_release_2_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 684
void ldv_file_operations_instance_release_3_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 685
void ldv_file_operations_instance_release_4_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 688
void ldv_file_operations_instance_write_2_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 689
void ldv_file_operations_instance_write_3_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 690
void ldv_file_operations_instance_write_4_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 691
void ldv_seq_instance_next_10_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                                struct seq_file *arg1 , void *arg2 , long long *arg3 ) ;
#line 692
void ldv_seq_instance_next_6_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                               struct seq_file *arg1 , void *arg2 , long long *arg3 ) ;
#line 693
void ldv_seq_instance_next_7_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                               struct seq_file *arg1 , void *arg2 , long long *arg3 ) ;
#line 694
void ldv_seq_instance_next_8_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                               struct seq_file *arg1 , void *arg2 , long long *arg3 ) ;
#line 695
void ldv_seq_instance_next_9_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                               struct seq_file *arg1 , void *arg2 , long long *arg3 ) ;
#line 696
void ldv_seq_instance_show_10_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) ;
#line 697
void ldv_seq_instance_show_6_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                               void *arg2 ) ;
#line 698
void ldv_seq_instance_show_7_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                               void *arg2 ) ;
#line 699
void ldv_seq_instance_show_8_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                               void *arg2 ) ;
#line 700
void ldv_seq_instance_show_9_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                               void *arg2 ) ;
#line 701
void ldv_seq_instance_start_10_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                 struct seq_file *arg1 , long long *arg2 ) ;
#line 702
void ldv_seq_instance_start_6_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                struct seq_file *arg1 , long long *arg2 ) ;
#line 703
void ldv_seq_instance_start_7_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                struct seq_file *arg1 , long long *arg2 ) ;
#line 704
void ldv_seq_instance_start_8_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                struct seq_file *arg1 , long long *arg2 ) ;
#line 705
void ldv_seq_instance_start_9_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                struct seq_file *arg1 , long long *arg2 ) ;
#line 706
void ldv_seq_instance_stop_10_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                 void *arg2 ) ;
#line 707
void ldv_seq_instance_stop_6_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) ;
#line 708
void ldv_seq_instance_stop_7_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) ;
#line 709
void ldv_seq_instance_stop_8_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) ;
#line 710
void ldv_seq_instance_stop_9_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) ;
#line 711
int ldv_seq_open(int arg0 , struct file *arg1 , struct seq_operations *arg2 ) ;
#line 712
void ldv_seq_operations_seq_instance_10(void *arg0 ) ;
#line 713
void ldv_seq_operations_seq_instance_6(void *arg0 ) ;
#line 714
void ldv_seq_operations_seq_instance_7(void *arg0 ) ;
#line 715
void ldv_seq_operations_seq_instance_8(void *arg0 ) ;
#line 716
void ldv_seq_operations_seq_instance_9(void *arg0 ) ;
#line 719 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_0  ;
#line 720 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_1  ;
#line 721 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_10  ;
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_2  ;
#line 723 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_3  ;
#line 724 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_4  ;
#line 725 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_6  ;
#line 726 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_7  ;
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_8  ;
#line 728 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
struct ldv_thread ldv_thread_9  ;
#line 734 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_dispatch_register_17_1(struct seq_file *arg0 , struct seq_operations *arg1 ) 
{ 
  struct ldv_struct_seq_instance_6 *cf_arg_8 ;
  struct ldv_struct_seq_instance_6 *cf_arg_9 ;
  struct ldv_struct_seq_instance_6 *cf_arg_10 ;
  struct ldv_struct_seq_instance_6 *cf_arg_6 ;
  struct ldv_struct_seq_instance_6 *cf_arg_7 ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 741
  tmp = ldv_undef_int();
  }
  {
#line 742
  if (tmp == 0) {
#line 742
    goto case_0;
  } else {

  }
#line 749
  if (tmp == 1) {
#line 749
    goto case_1;
  } else {

  }
#line 756
  if (tmp == 2) {
#line 756
    goto case_2;
  } else {

  }
#line 763
  if (tmp == 3) {
#line 763
    goto case_3;
  } else {

  }
#line 770
  if (tmp == 4) {
#line 770
    goto case_4;
  } else {

  }
#line 777
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 743
  tmp___0 = ldv_xmalloc(24UL);
#line 743
  cf_arg_8 = (struct ldv_struct_seq_instance_6 *)tmp___0;
#line 744
  cf_arg_8->arg0 = arg0;
#line 745
  cf_arg_8->arg1 = arg1;
#line 746
  ldv_seq_operations_seq_instance_8((void *)cf_arg_8);
  }
#line 747
  goto ldv_32761;
  case_1: /* CIL Label */ 
  {
#line 750
  tmp___1 = ldv_xmalloc(24UL);
#line 750
  cf_arg_9 = (struct ldv_struct_seq_instance_6 *)tmp___1;
#line 751
  cf_arg_9->arg0 = arg0;
#line 752
  cf_arg_9->arg1 = arg1;
#line 753
  ldv_seq_operations_seq_instance_9((void *)cf_arg_9);
  }
#line 754
  goto ldv_32761;
  case_2: /* CIL Label */ 
  {
#line 757
  tmp___2 = ldv_xmalloc(24UL);
#line 757
  cf_arg_10 = (struct ldv_struct_seq_instance_6 *)tmp___2;
#line 758
  cf_arg_10->arg0 = arg0;
#line 759
  cf_arg_10->arg1 = arg1;
#line 760
  ldv_seq_operations_seq_instance_10((void *)cf_arg_10);
  }
#line 761
  goto ldv_32761;
  case_3: /* CIL Label */ 
  {
#line 764
  tmp___3 = ldv_xmalloc(24UL);
#line 764
  cf_arg_6 = (struct ldv_struct_seq_instance_6 *)tmp___3;
#line 765
  cf_arg_6->arg0 = arg0;
#line 766
  cf_arg_6->arg1 = arg1;
#line 767
  ldv_seq_operations_seq_instance_6((void *)cf_arg_6);
  }
#line 768
  goto ldv_32761;
  case_4: /* CIL Label */ 
  {
#line 771
  tmp___4 = ldv_xmalloc(24UL);
#line 771
  cf_arg_7 = (struct ldv_struct_seq_instance_6 *)tmp___4;
#line 772
  cf_arg_7->arg0 = arg0;
#line 773
  cf_arg_7->arg1 = arg1;
#line 774
  ldv_seq_operations_seq_instance_7((void *)cf_arg_7);
  }
#line 775
  goto ldv_32761;
  switch_default: /* CIL Label */ 
  {
#line 777
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_32761: ;
#line 779
  return;
}
}
#line 783 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_file_operations_instance_0(void *arg0 ) 
{ 
  long long (*ldv_0_callback_llseek)(struct file * , long long  , int  ) ;
  int (*ldv_0_callback_mmap)(struct file * , struct vm_area_struct * ) ;
  long (*ldv_0_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  long (*ldv_0_callback_unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
  struct file_operations *ldv_0_container_file_operations ;
  char *ldv_0_ldv_param_23_1_default ;
  long long *ldv_0_ldv_param_23_3_default ;
  unsigned int ldv_0_ldv_param_26_1_default ;
  char *ldv_0_ldv_param_4_1_default ;
  long long *ldv_0_ldv_param_4_3_default ;
  long long ldv_0_ldv_param_5_1_default ;
  int ldv_0_ldv_param_5_2_default ;
  struct file *ldv_0_resource_file ;
  struct inode *ldv_0_resource_inode ;
  int ldv_0_ret_default ;
  struct vm_area_struct *ldv_0_size_cnt_struct_vm_area_struct_ptr ;
  unsigned long ldv_0_size_cnt_write_size ;
  struct ldv_struct_file_operations_instance_0 *data ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 804
  data = (struct ldv_struct_file_operations_instance_0 *)arg0;
#line 808
  ldv_0_ret_default = 1;
#line 811
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_file_operations_instance_0 *)0)) {
    {
#line 812
    ldv_0_container_file_operations = data->arg0;
#line 813
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 818
  tmp = ldv_xmalloc(504UL);
#line 818
  ldv_0_resource_file = (struct file *)tmp;
#line 819
  tmp___0 = ldv_xmalloc(976UL);
#line 819
  ldv_0_resource_inode = (struct inode *)tmp___0;
#line 820
  tmp___1 = ldv_undef_int();
#line 820
  ldv_0_size_cnt_struct_vm_area_struct_ptr = (struct vm_area_struct *)((long )tmp___1);
  }
#line 827
  goto ldv_main_0;
#line 829
  return;
  ldv_main_0: 
  {
#line 835
  tmp___3 = ldv_undef_int();
  }
#line 835
  if (tmp___3 != 0) {
    {
#line 838
    ldv_0_ret_default = ldv_file_operations_instance_probe_0_12(ldv_0_container_file_operations->open,
                                                                ldv_0_resource_inode,
                                                                ldv_0_resource_file);
#line 840
    ldv_0_ret_default = ldv_filter_err_code(ldv_0_ret_default);
#line 843
    tmp___2 = ldv_undef_int();
    }
#line 843
    if (tmp___2 != 0) {
      {
#line 845
      ldv_assume(ldv_0_ret_default == 0);
      }
#line 852
      goto ldv_call_0;
    } else {
      {
#line 856
      ldv_assume(ldv_0_ret_default != 0);
      }
#line 863
      goto ldv_main_0;
    }
  } else {
    {
#line 868
    ldv_free((void *)ldv_0_resource_file);
#line 869
    ldv_free((void *)ldv_0_resource_inode);
    }
#line 877
    return;
  }
#line 880
  return;
  ldv_call_0: 
  {
#line 886
  tmp___4 = ldv_undef_int();
  }
  {
#line 887
  if (tmp___4 == 1) {
#line 887
    goto case_1;
  } else {

  }
#line 914
  if (tmp___4 == 2) {
#line 914
    goto case_2;
  } else {

  }
#line 927
  if (tmp___4 == 3) {
#line 927
    goto case_3;
  } else {

  }
#line 988
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 889
  tmp___5 = ldv_xmalloc(1UL);
#line 889
  ldv_0_ldv_param_4_1_default = (char *)tmp___5;
#line 890
  tmp___6 = ldv_xmalloc(8UL);
#line 890
  ldv_0_ldv_param_4_3_default = (long long *)tmp___6;
#line 895
  ldv_assume((unsigned long )ldv_0_size_cnt_struct_vm_area_struct_ptr <= (unsigned long )((struct vm_area_struct *)2147479552));
  }
#line 896
  if ((unsigned long )ldv_0_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 898
    ldv_file_operations_instance_write_0_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_0_container_file_operations->write,
                                           ldv_0_resource_file, ldv_0_ldv_param_4_1_default,
                                           ldv_0_size_cnt_write_size, ldv_0_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 903
  ldv_free((void *)ldv_0_ldv_param_4_1_default);
#line 904
  ldv_free((void *)ldv_0_ldv_param_4_3_default);
  }
#line 911
  goto ldv_call_0;
  case_2: /* CIL Label */ 
  {
#line 917
  ldv_file_operations_instance_release_0_2(ldv_0_container_file_operations->release,
                                           ldv_0_resource_inode, ldv_0_resource_file);
  }
#line 924
  goto ldv_main_0;
  case_3: /* CIL Label */ 
  {
#line 931
  tmp___7 = ldv_undef_int();
  }
  {
#line 932
  if (tmp___7 == 1) {
#line 932
    goto case_1___0;
  } else {

  }
#line 948
  if (tmp___7 == 2) {
#line 948
    goto case_2___0;
  } else {

  }
#line 966
  if (tmp___7 == 3) {
#line 966
    goto case_3___0;
  } else {

  }
#line 976
  if (tmp___7 == 4) {
#line 976
    goto case_4;
  } else {

  }
#line 984
  goto switch_default;
  case_1___0: /* CIL Label */ ;
#line 937
  if ((unsigned long )ldv_0_callback_unlocked_ioctl != (unsigned long )((long (*)(struct file * ,
                                                                                  unsigned int  ,
                                                                                  unsigned long  ))0)) {
    {
#line 939
    ldv_file_operations_instance_callback_0_26(ldv_0_callback_unlocked_ioctl, ldv_0_resource_file,
                                               ldv_0_ldv_param_26_1_default, ldv_0_size_cnt_write_size);
    }
  } else {

  }
#line 946
  goto ldv_32806;
  case_2___0: /* CIL Label */ 
  {
#line 950
  tmp___8 = ldv_xmalloc(1UL);
#line 950
  ldv_0_ldv_param_23_1_default = (char *)tmp___8;
#line 951
  tmp___9 = ldv_xmalloc(8UL);
#line 951
  ldv_0_ldv_param_23_3_default = (long long *)tmp___9;
#line 956
  ldv_file_operations_instance_callback_0_23(ldv_0_callback_read, ldv_0_resource_file,
                                             ldv_0_ldv_param_23_1_default, ldv_0_size_cnt_write_size,
                                             ldv_0_ldv_param_23_3_default);
#line 960
  ldv_free((void *)ldv_0_ldv_param_23_1_default);
#line 961
  ldv_free((void *)ldv_0_ldv_param_23_3_default);
  }
#line 964
  goto ldv_32806;
  case_3___0: /* CIL Label */ ;
#line 968
  if ((unsigned long )ldv_0_callback_mmap != (unsigned long )((int (*)(struct file * ,
                                                                       struct vm_area_struct * ))0)) {
    {
#line 970
    ldv_file_operations_instance_callback_0_22(ldv_0_callback_mmap, ldv_0_resource_file,
                                               ldv_0_size_cnt_struct_vm_area_struct_ptr);
    }
  } else {

  }
#line 974
  goto ldv_32806;
  case_4: /* CIL Label */ 
  {
#line 979
  ldv_file_operations_instance_callback_0_5(ldv_0_callback_llseek, ldv_0_resource_file,
                                            ldv_0_ldv_param_5_1_default, ldv_0_ldv_param_5_2_default);
  }
#line 982
  goto ldv_32806;
  switch_default: /* CIL Label */ 
  {
#line 984
  ldv_stop();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_32806: ;
#line 986
  goto ldv_32811;
  switch_default___0: /* CIL Label */ 
  {
#line 988
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_32811: ;
#line 997
  goto ldv_call_0;
#line 999
  goto ldv_call_0;
#line 1001
  return;
}
}
#line 1006 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_file_operations_instance_1(void *arg0 ) 
{ 
  long long (*ldv_1_callback_llseek)(struct file * , long long  , int  ) ;
  int (*ldv_1_callback_mmap)(struct file * , struct vm_area_struct * ) ;
  long (*ldv_1_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  long (*ldv_1_callback_unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
  struct file_operations *ldv_1_container_file_operations ;
  char *ldv_1_ldv_param_23_1_default ;
  long long *ldv_1_ldv_param_23_3_default ;
  unsigned int ldv_1_ldv_param_26_1_default ;
  char *ldv_1_ldv_param_4_1_default ;
  long long *ldv_1_ldv_param_4_3_default ;
  long long ldv_1_ldv_param_5_1_default ;
  int ldv_1_ldv_param_5_2_default ;
  struct file *ldv_1_resource_file ;
  struct inode *ldv_1_resource_inode ;
  int ldv_1_ret_default ;
  struct vm_area_struct *ldv_1_size_cnt_struct_vm_area_struct_ptr ;
  unsigned long ldv_1_size_cnt_write_size ;
  struct ldv_struct_file_operations_instance_0 *data ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 1027
  data = (struct ldv_struct_file_operations_instance_0 *)arg0;
#line 1031
  ldv_1_ret_default = 1;
#line 1034
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_file_operations_instance_0 *)0)) {
    {
#line 1035
    ldv_1_container_file_operations = data->arg0;
#line 1036
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1041
  tmp = ldv_xmalloc(504UL);
#line 1041
  ldv_1_resource_file = (struct file *)tmp;
#line 1042
  tmp___0 = ldv_xmalloc(976UL);
#line 1042
  ldv_1_resource_inode = (struct inode *)tmp___0;
#line 1043
  tmp___1 = ldv_undef_int();
#line 1043
  ldv_1_size_cnt_struct_vm_area_struct_ptr = (struct vm_area_struct *)((long )tmp___1);
  }
#line 1050
  goto ldv_main_1;
#line 1052
  return;
  ldv_main_1: 
  {
#line 1058
  tmp___3 = ldv_undef_int();
  }
#line 1058
  if (tmp___3 != 0) {
    {
#line 1061
    ldv_1_ret_default = ldv_file_operations_instance_probe_1_12(ldv_1_container_file_operations->open,
                                                                ldv_1_resource_inode,
                                                                ldv_1_resource_file);
#line 1063
    ldv_1_ret_default = ldv_filter_err_code(ldv_1_ret_default);
#line 1066
    tmp___2 = ldv_undef_int();
    }
#line 1066
    if (tmp___2 != 0) {
      {
#line 1068
      ldv_assume(ldv_1_ret_default == 0);
      }
#line 1075
      goto ldv_call_1;
    } else {
      {
#line 1079
      ldv_assume(ldv_1_ret_default != 0);
      }
#line 1086
      goto ldv_main_1;
    }
  } else {
    {
#line 1091
    ldv_free((void *)ldv_1_resource_file);
#line 1092
    ldv_free((void *)ldv_1_resource_inode);
    }
#line 1100
    return;
  }
#line 1103
  return;
  ldv_call_1: 
  {
#line 1109
  tmp___4 = ldv_undef_int();
  }
  {
#line 1110
  if (tmp___4 == 1) {
#line 1110
    goto case_1;
  } else {

  }
#line 1137
  if (tmp___4 == 2) {
#line 1137
    goto case_2;
  } else {

  }
#line 1150
  if (tmp___4 == 3) {
#line 1150
    goto case_3;
  } else {

  }
#line 1207
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 1112
  tmp___5 = ldv_xmalloc(1UL);
#line 1112
  ldv_1_ldv_param_4_1_default = (char *)tmp___5;
#line 1113
  tmp___6 = ldv_xmalloc(8UL);
#line 1113
  ldv_1_ldv_param_4_3_default = (long long *)tmp___6;
#line 1118
  ldv_assume((unsigned long )ldv_1_size_cnt_struct_vm_area_struct_ptr <= (unsigned long )((struct vm_area_struct *)2147479552));
  }
#line 1119
  if ((unsigned long )ldv_1_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 1121
    ldv_file_operations_instance_write_1_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_1_container_file_operations->write,
                                           ldv_1_resource_file, ldv_1_ldv_param_4_1_default,
                                           ldv_1_size_cnt_write_size, ldv_1_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 1126
  ldv_free((void *)ldv_1_ldv_param_4_1_default);
#line 1127
  ldv_free((void *)ldv_1_ldv_param_4_3_default);
  }
#line 1134
  goto ldv_call_1;
  case_2: /* CIL Label */ 
  {
#line 1140
  ldv_file_operations_instance_release_1_2(ldv_1_container_file_operations->release,
                                           ldv_1_resource_inode, ldv_1_resource_file);
  }
#line 1147
  goto ldv_main_1;
  case_3: /* CIL Label */ 
  {
#line 1154
  tmp___7 = ldv_undef_int();
  }
  {
#line 1155
  if (tmp___7 == 1) {
#line 1155
    goto case_1___0;
  } else {

  }
#line 1169
  if (tmp___7 == 2) {
#line 1169
    goto case_2___0;
  } else {

  }
#line 1187
  if (tmp___7 == 3) {
#line 1187
    goto case_3___0;
  } else {

  }
#line 1195
  if (tmp___7 == 4) {
#line 1195
    goto case_4;
  } else {

  }
#line 1203
  goto switch_default;
  case_1___0: /* CIL Label */ 
  {
#line 1161
  ldv_file_operations_instance_callback_1_26(ldv_1_callback_unlocked_ioctl, ldv_1_resource_file,
                                             ldv_1_ldv_param_26_1_default, ldv_1_size_cnt_write_size);
  }
#line 1167
  goto ldv_32852;
  case_2___0: /* CIL Label */ 
  {
#line 1171
  tmp___8 = ldv_xmalloc(1UL);
#line 1171
  ldv_1_ldv_param_23_1_default = (char *)tmp___8;
#line 1172
  tmp___9 = ldv_xmalloc(8UL);
#line 1172
  ldv_1_ldv_param_23_3_default = (long long *)tmp___9;
#line 1177
  ldv_file_operations_instance_callback_1_23(ldv_1_callback_read, ldv_1_resource_file,
                                             ldv_1_ldv_param_23_1_default, ldv_1_size_cnt_write_size,
                                             ldv_1_ldv_param_23_3_default);
#line 1181
  ldv_free((void *)ldv_1_ldv_param_23_1_default);
#line 1182
  ldv_free((void *)ldv_1_ldv_param_23_3_default);
  }
#line 1185
  goto ldv_32852;
  case_3___0: /* CIL Label */ 
  {
#line 1190
  ldv_file_operations_instance_callback_1_22(ldv_1_callback_mmap, ldv_1_resource_file,
                                             ldv_1_size_cnt_struct_vm_area_struct_ptr);
  }
#line 1193
  goto ldv_32852;
  case_4: /* CIL Label */ 
  {
#line 1198
  ldv_file_operations_instance_callback_1_5(ldv_1_callback_llseek, ldv_1_resource_file,
                                            ldv_1_ldv_param_5_1_default, ldv_1_ldv_param_5_2_default);
  }
#line 1201
  goto ldv_32852;
  switch_default: /* CIL Label */ 
  {
#line 1203
  ldv_stop();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_32852: ;
#line 1205
  goto ldv_32857;
  switch_default___0: /* CIL Label */ 
  {
#line 1207
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_32857: ;
#line 1216
  goto ldv_call_1;
#line 1218
  goto ldv_call_1;
#line 1220
  return;
}
}
#line 1225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_file_operations_instance_2(void *arg0 ) 
{ 
  long long (*ldv_2_callback_llseek)(struct file * , long long  , int  ) ;
  int (*ldv_2_callback_mmap)(struct file * , struct vm_area_struct * ) ;
  long (*ldv_2_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  long (*ldv_2_callback_unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
  struct file_operations *ldv_2_container_file_operations ;
  char *ldv_2_ldv_param_23_1_default ;
  long long *ldv_2_ldv_param_23_3_default ;
  unsigned int ldv_2_ldv_param_26_1_default ;
  char *ldv_2_ldv_param_4_1_default ;
  long long *ldv_2_ldv_param_4_3_default ;
  long long ldv_2_ldv_param_5_1_default ;
  int ldv_2_ldv_param_5_2_default ;
  struct file *ldv_2_resource_file ;
  struct inode *ldv_2_resource_inode ;
  int ldv_2_ret_default ;
  struct vm_area_struct *ldv_2_size_cnt_struct_vm_area_struct_ptr ;
  unsigned long ldv_2_size_cnt_write_size ;
  struct ldv_struct_file_operations_instance_0 *data ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 1246
  data = (struct ldv_struct_file_operations_instance_0 *)arg0;
#line 1250
  ldv_2_ret_default = 1;
#line 1253
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_file_operations_instance_0 *)0)) {
    {
#line 1254
    ldv_2_container_file_operations = data->arg0;
#line 1255
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1260
  tmp = ldv_xmalloc(504UL);
#line 1260
  ldv_2_resource_file = (struct file *)tmp;
#line 1261
  tmp___0 = ldv_xmalloc(976UL);
#line 1261
  ldv_2_resource_inode = (struct inode *)tmp___0;
#line 1262
  tmp___1 = ldv_undef_int();
#line 1262
  ldv_2_size_cnt_struct_vm_area_struct_ptr = (struct vm_area_struct *)((long )tmp___1);
  }
#line 1269
  goto ldv_main_2;
#line 1271
  return;
  ldv_main_2: 
  {
#line 1277
  tmp___3 = ldv_undef_int();
  }
#line 1277
  if (tmp___3 != 0) {
    {
#line 1280
    ldv_2_ret_default = ldv_file_operations_instance_probe_2_12(ldv_2_container_file_operations->open,
                                                                ldv_2_resource_inode,
                                                                ldv_2_resource_file);
#line 1282
    ldv_2_ret_default = ldv_filter_err_code(ldv_2_ret_default);
#line 1285
    tmp___2 = ldv_undef_int();
    }
#line 1285
    if (tmp___2 != 0) {
      {
#line 1287
      ldv_assume(ldv_2_ret_default == 0);
      }
#line 1294
      goto ldv_call_2;
    } else {
      {
#line 1298
      ldv_assume(ldv_2_ret_default != 0);
      }
#line 1305
      goto ldv_main_2;
    }
  } else {
    {
#line 1310
    ldv_free((void *)ldv_2_resource_file);
#line 1311
    ldv_free((void *)ldv_2_resource_inode);
    }
#line 1319
    return;
  }
#line 1322
  return;
  ldv_call_2: 
  {
#line 1328
  tmp___4 = ldv_undef_int();
  }
  {
#line 1329
  if (tmp___4 == 1) {
#line 1329
    goto case_1;
  } else {

  }
#line 1354
  if (tmp___4 == 2) {
#line 1354
    goto case_2;
  } else {

  }
#line 1367
  if (tmp___4 == 3) {
#line 1367
    goto case_3;
  } else {

  }
#line 1428
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 1331
  tmp___5 = ldv_xmalloc(1UL);
#line 1331
  ldv_2_ldv_param_4_1_default = (char *)tmp___5;
#line 1332
  tmp___6 = ldv_xmalloc(8UL);
#line 1332
  ldv_2_ldv_param_4_3_default = (long long *)tmp___6;
#line 1337
  ldv_assume((unsigned long )ldv_2_size_cnt_struct_vm_area_struct_ptr <= (unsigned long )((struct vm_area_struct *)2147479552));
#line 1339
  ldv_file_operations_instance_write_2_4((long (*)(struct file * , char * , unsigned long  ,
                                                   long long * ))ldv_2_container_file_operations->write,
                                         ldv_2_resource_file, ldv_2_ldv_param_4_1_default,
                                         ldv_2_size_cnt_write_size, ldv_2_ldv_param_4_3_default);
#line 1343
  ldv_free((void *)ldv_2_ldv_param_4_1_default);
#line 1344
  ldv_free((void *)ldv_2_ldv_param_4_3_default);
  }
#line 1351
  goto ldv_call_2;
  case_2: /* CIL Label */ 
  {
#line 1357
  ldv_file_operations_instance_release_2_2(ldv_2_container_file_operations->release,
                                           ldv_2_resource_inode, ldv_2_resource_file);
  }
#line 1364
  goto ldv_main_2;
  case_3: /* CIL Label */ 
  {
#line 1371
  tmp___7 = ldv_undef_int();
  }
  {
#line 1372
  if (tmp___7 == 1) {
#line 1372
    goto case_1___0;
  } else {

  }
#line 1388
  if (tmp___7 == 2) {
#line 1388
    goto case_2___0;
  } else {

  }
#line 1406
  if (tmp___7 == 3) {
#line 1406
    goto case_3___0;
  } else {

  }
#line 1416
  if (tmp___7 == 4) {
#line 1416
    goto case_4;
  } else {

  }
#line 1424
  goto switch_default;
  case_1___0: /* CIL Label */ ;
#line 1377
  if ((unsigned long )ldv_2_callback_unlocked_ioctl != (unsigned long )((long (*)(struct file * ,
                                                                                  unsigned int  ,
                                                                                  unsigned long  ))0)) {
    {
#line 1379
    ldv_file_operations_instance_callback_2_26(ldv_2_callback_unlocked_ioctl, ldv_2_resource_file,
                                               ldv_2_ldv_param_26_1_default, ldv_2_size_cnt_write_size);
    }
  } else {

  }
#line 1386
  goto ldv_32898;
  case_2___0: /* CIL Label */ 
  {
#line 1390
  tmp___8 = ldv_xmalloc(1UL);
#line 1390
  ldv_2_ldv_param_23_1_default = (char *)tmp___8;
#line 1391
  tmp___9 = ldv_xmalloc(8UL);
#line 1391
  ldv_2_ldv_param_23_3_default = (long long *)tmp___9;
#line 1396
  ldv_file_operations_instance_callback_2_23(ldv_2_callback_read, ldv_2_resource_file,
                                             ldv_2_ldv_param_23_1_default, ldv_2_size_cnt_write_size,
                                             ldv_2_ldv_param_23_3_default);
#line 1400
  ldv_free((void *)ldv_2_ldv_param_23_1_default);
#line 1401
  ldv_free((void *)ldv_2_ldv_param_23_3_default);
  }
#line 1404
  goto ldv_32898;
  case_3___0: /* CIL Label */ ;
#line 1408
  if ((unsigned long )ldv_2_callback_mmap != (unsigned long )((int (*)(struct file * ,
                                                                       struct vm_area_struct * ))0)) {
    {
#line 1410
    ldv_file_operations_instance_callback_2_22(ldv_2_callback_mmap, ldv_2_resource_file,
                                               ldv_2_size_cnt_struct_vm_area_struct_ptr);
    }
  } else {

  }
#line 1414
  goto ldv_32898;
  case_4: /* CIL Label */ 
  {
#line 1419
  ldv_file_operations_instance_callback_2_5(ldv_2_callback_llseek, ldv_2_resource_file,
                                            ldv_2_ldv_param_5_1_default, ldv_2_ldv_param_5_2_default);
  }
#line 1422
  goto ldv_32898;
  switch_default: /* CIL Label */ 
  {
#line 1424
  ldv_stop();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_32898: ;
#line 1426
  goto ldv_32903;
  switch_default___0: /* CIL Label */ 
  {
#line 1428
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_32903: ;
#line 1437
  goto ldv_call_2;
#line 1439
  goto ldv_call_2;
#line 1441
  return;
}
}
#line 1446 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_file_operations_instance_3(void *arg0 ) 
{ 
  long long (*ldv_3_callback_llseek)(struct file * , long long  , int  ) ;
  int (*ldv_3_callback_mmap)(struct file * , struct vm_area_struct * ) ;
  long (*ldv_3_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  long (*ldv_3_callback_unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
  struct file_operations *ldv_3_container_file_operations ;
  char *ldv_3_ldv_param_23_1_default ;
  long long *ldv_3_ldv_param_23_3_default ;
  unsigned int ldv_3_ldv_param_26_1_default ;
  char *ldv_3_ldv_param_4_1_default ;
  long long *ldv_3_ldv_param_4_3_default ;
  long long ldv_3_ldv_param_5_1_default ;
  int ldv_3_ldv_param_5_2_default ;
  struct file *ldv_3_resource_file ;
  struct inode *ldv_3_resource_inode ;
  int ldv_3_ret_default ;
  struct vm_area_struct *ldv_3_size_cnt_struct_vm_area_struct_ptr ;
  unsigned long ldv_3_size_cnt_write_size ;
  struct ldv_struct_file_operations_instance_0 *data ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 1467
  data = (struct ldv_struct_file_operations_instance_0 *)arg0;
#line 1471
  ldv_3_ret_default = 1;
#line 1474
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_file_operations_instance_0 *)0)) {
    {
#line 1475
    ldv_3_container_file_operations = data->arg0;
#line 1476
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1481
  tmp = ldv_xmalloc(504UL);
#line 1481
  ldv_3_resource_file = (struct file *)tmp;
#line 1482
  tmp___0 = ldv_xmalloc(976UL);
#line 1482
  ldv_3_resource_inode = (struct inode *)tmp___0;
#line 1483
  tmp___1 = ldv_undef_int();
#line 1483
  ldv_3_size_cnt_struct_vm_area_struct_ptr = (struct vm_area_struct *)((long )tmp___1);
  }
#line 1490
  goto ldv_main_3;
#line 1492
  return;
  ldv_main_3: 
  {
#line 1498
  tmp___3 = ldv_undef_int();
  }
#line 1498
  if (tmp___3 != 0) {
    {
#line 1501
    ldv_3_ret_default = ldv_file_operations_instance_probe_3_12(ldv_3_container_file_operations->open,
                                                                ldv_3_resource_inode,
                                                                ldv_3_resource_file);
#line 1503
    ldv_3_ret_default = ldv_filter_err_code(ldv_3_ret_default);
#line 1506
    tmp___2 = ldv_undef_int();
    }
#line 1506
    if (tmp___2 != 0) {
      {
#line 1508
      ldv_assume(ldv_3_ret_default == 0);
      }
#line 1515
      goto ldv_call_3;
    } else {
      {
#line 1519
      ldv_assume(ldv_3_ret_default != 0);
      }
#line 1526
      goto ldv_main_3;
    }
  } else {
    {
#line 1531
    ldv_free((void *)ldv_3_resource_file);
#line 1532
    ldv_free((void *)ldv_3_resource_inode);
    }
#line 1540
    return;
  }
#line 1543
  return;
  ldv_call_3: 
  {
#line 1549
  tmp___4 = ldv_undef_int();
  }
  {
#line 1550
  if (tmp___4 == 1) {
#line 1550
    goto case_1;
  } else {

  }
#line 1575
  if (tmp___4 == 2) {
#line 1575
    goto case_2;
  } else {

  }
#line 1588
  if (tmp___4 == 3) {
#line 1588
    goto case_3;
  } else {

  }
#line 1649
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 1552
  tmp___5 = ldv_xmalloc(1UL);
#line 1552
  ldv_3_ldv_param_4_1_default = (char *)tmp___5;
#line 1553
  tmp___6 = ldv_xmalloc(8UL);
#line 1553
  ldv_3_ldv_param_4_3_default = (long long *)tmp___6;
#line 1558
  ldv_assume((unsigned long )ldv_3_size_cnt_struct_vm_area_struct_ptr <= (unsigned long )((struct vm_area_struct *)2147479552));
#line 1560
  ldv_file_operations_instance_write_3_4((long (*)(struct file * , char * , unsigned long  ,
                                                   long long * ))ldv_3_container_file_operations->write,
                                         ldv_3_resource_file, ldv_3_ldv_param_4_1_default,
                                         ldv_3_size_cnt_write_size, ldv_3_ldv_param_4_3_default);
#line 1564
  ldv_free((void *)ldv_3_ldv_param_4_1_default);
#line 1565
  ldv_free((void *)ldv_3_ldv_param_4_3_default);
  }
#line 1572
  goto ldv_call_3;
  case_2: /* CIL Label */ 
  {
#line 1578
  ldv_file_operations_instance_release_3_2(ldv_3_container_file_operations->release,
                                           ldv_3_resource_inode, ldv_3_resource_file);
  }
#line 1585
  goto ldv_main_3;
  case_3: /* CIL Label */ 
  {
#line 1592
  tmp___7 = ldv_undef_int();
  }
  {
#line 1593
  if (tmp___7 == 1) {
#line 1593
    goto case_1___0;
  } else {

  }
#line 1609
  if (tmp___7 == 2) {
#line 1609
    goto case_2___0;
  } else {

  }
#line 1627
  if (tmp___7 == 3) {
#line 1627
    goto case_3___0;
  } else {

  }
#line 1637
  if (tmp___7 == 4) {
#line 1637
    goto case_4;
  } else {

  }
#line 1645
  goto switch_default;
  case_1___0: /* CIL Label */ ;
#line 1598
  if ((unsigned long )ldv_3_callback_unlocked_ioctl != (unsigned long )((long (*)(struct file * ,
                                                                                  unsigned int  ,
                                                                                  unsigned long  ))0)) {
    {
#line 1600
    ldv_file_operations_instance_callback_3_26(ldv_3_callback_unlocked_ioctl, ldv_3_resource_file,
                                               ldv_3_ldv_param_26_1_default, ldv_3_size_cnt_write_size);
    }
  } else {

  }
#line 1607
  goto ldv_32944;
  case_2___0: /* CIL Label */ 
  {
#line 1611
  tmp___8 = ldv_xmalloc(1UL);
#line 1611
  ldv_3_ldv_param_23_1_default = (char *)tmp___8;
#line 1612
  tmp___9 = ldv_xmalloc(8UL);
#line 1612
  ldv_3_ldv_param_23_3_default = (long long *)tmp___9;
#line 1617
  ldv_file_operations_instance_callback_3_23(ldv_3_callback_read, ldv_3_resource_file,
                                             ldv_3_ldv_param_23_1_default, ldv_3_size_cnt_write_size,
                                             ldv_3_ldv_param_23_3_default);
#line 1621
  ldv_free((void *)ldv_3_ldv_param_23_1_default);
#line 1622
  ldv_free((void *)ldv_3_ldv_param_23_3_default);
  }
#line 1625
  goto ldv_32944;
  case_3___0: /* CIL Label */ ;
#line 1629
  if ((unsigned long )ldv_3_callback_mmap != (unsigned long )((int (*)(struct file * ,
                                                                       struct vm_area_struct * ))0)) {
    {
#line 1631
    ldv_file_operations_instance_callback_3_22(ldv_3_callback_mmap, ldv_3_resource_file,
                                               ldv_3_size_cnt_struct_vm_area_struct_ptr);
    }
  } else {

  }
#line 1635
  goto ldv_32944;
  case_4: /* CIL Label */ 
  {
#line 1640
  ldv_file_operations_instance_callback_3_5(ldv_3_callback_llseek, ldv_3_resource_file,
                                            ldv_3_ldv_param_5_1_default, ldv_3_ldv_param_5_2_default);
  }
#line 1643
  goto ldv_32944;
  switch_default: /* CIL Label */ 
  {
#line 1645
  ldv_stop();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_32944: ;
#line 1647
  goto ldv_32949;
  switch_default___0: /* CIL Label */ 
  {
#line 1649
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_32949: ;
#line 1658
  goto ldv_call_3;
#line 1660
  goto ldv_call_3;
#line 1662
  return;
}
}
#line 1667 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_file_operations_instance_4(void *arg0 ) 
{ 
  long long (*ldv_4_callback_llseek)(struct file * , long long  , int  ) ;
  int (*ldv_4_callback_mmap)(struct file * , struct vm_area_struct * ) ;
  long (*ldv_4_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  long (*ldv_4_callback_unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
  struct file_operations *ldv_4_container_file_operations ;
  char *ldv_4_ldv_param_23_1_default ;
  long long *ldv_4_ldv_param_23_3_default ;
  unsigned int ldv_4_ldv_param_26_1_default ;
  char *ldv_4_ldv_param_4_1_default ;
  long long *ldv_4_ldv_param_4_3_default ;
  long long ldv_4_ldv_param_5_1_default ;
  int ldv_4_ldv_param_5_2_default ;
  struct file *ldv_4_resource_file ;
  struct inode *ldv_4_resource_inode ;
  int ldv_4_ret_default ;
  struct vm_area_struct *ldv_4_size_cnt_struct_vm_area_struct_ptr ;
  unsigned long ldv_4_size_cnt_write_size ;
  struct ldv_struct_file_operations_instance_0 *data ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
#line 1688
  data = (struct ldv_struct_file_operations_instance_0 *)arg0;
#line 1692
  ldv_4_ret_default = 1;
#line 1695
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_file_operations_instance_0 *)0)) {
    {
#line 1696
    ldv_4_container_file_operations = data->arg0;
#line 1697
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1702
  tmp = ldv_xmalloc(504UL);
#line 1702
  ldv_4_resource_file = (struct file *)tmp;
#line 1703
  tmp___0 = ldv_xmalloc(976UL);
#line 1703
  ldv_4_resource_inode = (struct inode *)tmp___0;
#line 1704
  tmp___1 = ldv_undef_int();
#line 1704
  ldv_4_size_cnt_struct_vm_area_struct_ptr = (struct vm_area_struct *)((long )tmp___1);
  }
#line 1711
  goto ldv_main_4;
#line 1713
  return;
  ldv_main_4: 
  {
#line 1719
  tmp___3 = ldv_undef_int();
  }
#line 1719
  if (tmp___3 != 0) {
    {
#line 1722
    ldv_4_ret_default = ldv_file_operations_instance_probe_4_12(ldv_4_container_file_operations->open,
                                                                ldv_4_resource_inode,
                                                                ldv_4_resource_file);
#line 1724
    ldv_4_ret_default = ldv_filter_err_code(ldv_4_ret_default);
#line 1727
    tmp___2 = ldv_undef_int();
    }
#line 1727
    if (tmp___2 != 0) {
      {
#line 1729
      ldv_assume(ldv_4_ret_default == 0);
      }
#line 1736
      goto ldv_call_4;
    } else {
      {
#line 1740
      ldv_assume(ldv_4_ret_default != 0);
      }
#line 1747
      goto ldv_main_4;
    }
  } else {
    {
#line 1752
    ldv_free((void *)ldv_4_resource_file);
#line 1753
    ldv_free((void *)ldv_4_resource_inode);
    }
#line 1761
    return;
  }
#line 1764
  return;
  ldv_call_4: 
  {
#line 1770
  tmp___4 = ldv_undef_int();
  }
  {
#line 1771
  if (tmp___4 == 1) {
#line 1771
    goto case_1;
  } else {

  }
#line 1796
  if (tmp___4 == 2) {
#line 1796
    goto case_2;
  } else {

  }
#line 1809
  if (tmp___4 == 3) {
#line 1809
    goto case_3;
  } else {

  }
#line 1870
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 1773
  tmp___5 = ldv_xmalloc(1UL);
#line 1773
  ldv_4_ldv_param_4_1_default = (char *)tmp___5;
#line 1774
  tmp___6 = ldv_xmalloc(8UL);
#line 1774
  ldv_4_ldv_param_4_3_default = (long long *)tmp___6;
#line 1779
  ldv_assume((unsigned long )ldv_4_size_cnt_struct_vm_area_struct_ptr <= (unsigned long )((struct vm_area_struct *)2147479552));
#line 1781
  ldv_file_operations_instance_write_4_4((long (*)(struct file * , char * , unsigned long  ,
                                                   long long * ))ldv_4_container_file_operations->write,
                                         ldv_4_resource_file, ldv_4_ldv_param_4_1_default,
                                         ldv_4_size_cnt_write_size, ldv_4_ldv_param_4_3_default);
#line 1785
  ldv_free((void *)ldv_4_ldv_param_4_1_default);
#line 1786
  ldv_free((void *)ldv_4_ldv_param_4_3_default);
  }
#line 1793
  goto ldv_call_4;
  case_2: /* CIL Label */ 
  {
#line 1799
  ldv_file_operations_instance_release_4_2(ldv_4_container_file_operations->release,
                                           ldv_4_resource_inode, ldv_4_resource_file);
  }
#line 1806
  goto ldv_main_4;
  case_3: /* CIL Label */ 
  {
#line 1813
  tmp___7 = ldv_undef_int();
  }
  {
#line 1814
  if (tmp___7 == 1) {
#line 1814
    goto case_1___0;
  } else {

  }
#line 1830
  if (tmp___7 == 2) {
#line 1830
    goto case_2___0;
  } else {

  }
#line 1848
  if (tmp___7 == 3) {
#line 1848
    goto case_3___0;
  } else {

  }
#line 1858
  if (tmp___7 == 4) {
#line 1858
    goto case_4;
  } else {

  }
#line 1866
  goto switch_default;
  case_1___0: /* CIL Label */ ;
#line 1819
  if ((unsigned long )ldv_4_callback_unlocked_ioctl != (unsigned long )((long (*)(struct file * ,
                                                                                  unsigned int  ,
                                                                                  unsigned long  ))0)) {
    {
#line 1821
    ldv_file_operations_instance_callback_4_26(ldv_4_callback_unlocked_ioctl, ldv_4_resource_file,
                                               ldv_4_ldv_param_26_1_default, ldv_4_size_cnt_write_size);
    }
  } else {

  }
#line 1828
  goto ldv_32990;
  case_2___0: /* CIL Label */ 
  {
#line 1832
  tmp___8 = ldv_xmalloc(1UL);
#line 1832
  ldv_4_ldv_param_23_1_default = (char *)tmp___8;
#line 1833
  tmp___9 = ldv_xmalloc(8UL);
#line 1833
  ldv_4_ldv_param_23_3_default = (long long *)tmp___9;
#line 1838
  ldv_file_operations_instance_callback_4_23(ldv_4_callback_read, ldv_4_resource_file,
                                             ldv_4_ldv_param_23_1_default, ldv_4_size_cnt_write_size,
                                             ldv_4_ldv_param_23_3_default);
#line 1842
  ldv_free((void *)ldv_4_ldv_param_23_1_default);
#line 1843
  ldv_free((void *)ldv_4_ldv_param_23_3_default);
  }
#line 1846
  goto ldv_32990;
  case_3___0: /* CIL Label */ ;
#line 1850
  if ((unsigned long )ldv_4_callback_mmap != (unsigned long )((int (*)(struct file * ,
                                                                       struct vm_area_struct * ))0)) {
    {
#line 1852
    ldv_file_operations_instance_callback_4_22(ldv_4_callback_mmap, ldv_4_resource_file,
                                               ldv_4_size_cnt_struct_vm_area_struct_ptr);
    }
  } else {

  }
#line 1856
  goto ldv_32990;
  case_4: /* CIL Label */ 
  {
#line 1861
  ldv_file_operations_instance_callback_4_5(ldv_4_callback_llseek, ldv_4_resource_file,
                                            ldv_4_ldv_param_5_1_default, ldv_4_ldv_param_5_2_default);
  }
#line 1864
  goto ldv_32990;
  switch_default: /* CIL Label */ 
  {
#line 1866
  ldv_stop();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_32990: ;
#line 1868
  goto ldv_32995;
  switch_default___0: /* CIL Label */ 
  {
#line 1870
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_32995: ;
#line 1879
  goto ldv_call_4;
#line 1881
  goto ldv_call_4;
#line 1883
  return;
}
}
#line 1888 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_0_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 1889
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 1890
  return;
}
}
#line 1893 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_0_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 1894
  seq_lseek(arg1, arg2, arg3);
  }
#line 1895
  return;
}
}
#line 1898 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_1_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 1899
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 1900
  return;
}
}
#line 1903 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_2_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 1904
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 1905
  return;
}
}
#line 1908 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_2_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 1909
  seq_lseek(arg1, arg2, arg3);
  }
#line 1910
  return;
}
}
#line 1913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_3_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 1914
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 1915
  return;
}
}
#line 1918 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_3_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 1919
  seq_lseek(arg1, arg2, arg3);
  }
#line 1920
  return;
}
}
#line 1923 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_4_23(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 1924
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 1925
  return;
}
}
#line 1928 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_callback_4_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 1929
  seq_lseek(arg1, arg2, arg3);
  }
#line 1930
  return;
}
}
#line 1933 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
int ldv_file_operations_instance_probe_0_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1934
  tmp = cch_open(arg1, arg2);
  }
#line 1934
  return (tmp);
}
}
#line 1938 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
int ldv_file_operations_instance_probe_1_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1939
  tmp = gru_open(arg1, arg2);
  }
#line 1939
  return (tmp);
}
}
#line 1943 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
int ldv_file_operations_instance_probe_2_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1944
  tmp = mcs_statistics_open(arg1, arg2);
  }
#line 1944
  return (tmp);
}
}
#line 1948 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
int ldv_file_operations_instance_probe_3_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1949
  tmp = options_open(arg1, arg2);
  }
#line 1949
  return (tmp);
}
}
#line 1953 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
int ldv_file_operations_instance_probe_4_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 1954
  tmp = statistics_open(arg1, arg2);
  }
#line 1954
  return (tmp);
}
}
#line 1958 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_release_0_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 1959
  seq_release(arg1, arg2);
  }
#line 1960
  return;
}
}
#line 1963 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_release_1_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 1964
  seq_release(arg1, arg2);
  }
#line 1965
  return;
}
}
#line 1968 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_release_2_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 1969
  single_release(arg1, arg2);
  }
#line 1970
  return;
}
}
#line 1973 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_release_3_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 1974
  single_release(arg1, arg2);
  }
#line 1975
  return;
}
}
#line 1978 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_release_4_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 1979
  single_release(arg1, arg2);
  }
#line 1980
  return;
}
}
#line 1983 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_write_2_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1984
  mcs_statistics_write(arg1, (char const   *)arg2, arg3, arg4);
  }
#line 1985
  return;
}
}
#line 1988 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_write_3_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1989
  options_write(arg1, (char const   *)arg2, arg3, arg4);
  }
#line 1990
  return;
}
}
#line 1993 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_file_operations_instance_write_4_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1994
  statistics_write(arg1, (char const   *)arg2, arg3, arg4);
  }
#line 1995
  return;
}
}
#line 1998 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_next_10_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                                struct seq_file *arg1 , void *arg2 , long long *arg3 ) 
{ 


  {
  {
#line 1999
  seq_next(arg1, arg2, arg3);
  }
#line 2000
  return;
}
}
#line 2003 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_next_6_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                               struct seq_file *arg1 , void *arg2 , long long *arg3 ) 
{ 


  {
  {
#line 2004
  seq_next(arg1, arg2, arg3);
  }
#line 2005
  return;
}
}
#line 2008 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_next_7_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                               struct seq_file *arg1 , void *arg2 , long long *arg3 ) 
{ 


  {
  {
#line 2009
  seq_next(arg1, arg2, arg3);
  }
#line 2010
  return;
}
}
#line 2013 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_next_8_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                               struct seq_file *arg1 , void *arg2 , long long *arg3 ) 
{ 


  {
  {
#line 2014
  seq_next(arg1, arg2, arg3);
  }
#line 2015
  return;
}
}
#line 2018 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_next_9_7(void *(*arg0)(struct seq_file * , void * , long long * ) ,
                               struct seq_file *arg1 , void *arg2 , long long *arg3 ) 
{ 


  {
  {
#line 2019
  seq_next(arg1, arg2, arg3);
  }
#line 2020
  return;
}
}
#line 2023 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_show_10_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) 
{ 


  {
  {
#line 2024
  statistics_show(arg1, arg2);
  }
#line 2025
  return;
}
}
#line 2028 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_show_6_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                               void *arg2 ) 
{ 


  {
  {
#line 2029
  cch_seq_show(arg1, arg2);
  }
#line 2030
  return;
}
}
#line 2033 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_show_7_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                               void *arg2 ) 
{ 


  {
  {
#line 2034
  gru_seq_show(arg1, arg2);
  }
#line 2035
  return;
}
}
#line 2038 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_show_8_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                               void *arg2 ) 
{ 


  {
  {
#line 2039
  mcs_statistics_show(arg1, arg2);
  }
#line 2040
  return;
}
}
#line 2043 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_show_9_8(int (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                               void *arg2 ) 
{ 


  {
  {
#line 2044
  options_show(arg1, arg2);
  }
#line 2045
  return;
}
}
#line 2048 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_start_10_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                 struct seq_file *arg1 , long long *arg2 ) 
{ 


  {
  {
#line 2049
  seq_start(arg1, arg2);
  }
#line 2050
  return;
}
}
#line 2053 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_start_6_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                struct seq_file *arg1 , long long *arg2 ) 
{ 


  {
  {
#line 2054
  seq_start(arg1, arg2);
  }
#line 2055
  return;
}
}
#line 2058 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_start_7_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                struct seq_file *arg1 , long long *arg2 ) 
{ 


  {
  {
#line 2059
  seq_start(arg1, arg2);
  }
#line 2060
  return;
}
}
#line 2063 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_start_8_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                struct seq_file *arg1 , long long *arg2 ) 
{ 


  {
  {
#line 2064
  seq_start(arg1, arg2);
  }
#line 2065
  return;
}
}
#line 2068 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_start_9_4(void *(*arg0)(struct seq_file * , long long * ) ,
                                struct seq_file *arg1 , long long *arg2 ) 
{ 


  {
  {
#line 2069
  seq_start(arg1, arg2);
  }
#line 2070
  return;
}
}
#line 2073 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_stop_10_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                 void *arg2 ) 
{ 


  {
  {
#line 2074
  seq_stop(arg1, arg2);
  }
#line 2075
  return;
}
}
#line 2078 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_stop_6_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) 
{ 


  {
  {
#line 2079
  seq_stop(arg1, arg2);
  }
#line 2080
  return;
}
}
#line 2083 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_stop_7_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) 
{ 


  {
  {
#line 2084
  seq_stop(arg1, arg2);
  }
#line 2085
  return;
}
}
#line 2088 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_stop_8_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) 
{ 


  {
  {
#line 2089
  seq_stop(arg1, arg2);
  }
#line 2090
  return;
}
}
#line 2093 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_instance_stop_9_10(void (*arg0)(struct seq_file * , void * ) , struct seq_file *arg1 ,
                                void *arg2 ) 
{ 


  {
  {
#line 2094
  seq_stop(arg1, arg2);
  }
#line 2095
  return;
}
}
#line 2098 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
int ldv_seq_open(int arg0 , struct file *arg1 , struct seq_operations *arg2 ) 
{ 
  struct seq_operations *ldv_17_ops_seq_operations ;
  struct seq_file *ldv_17_seq_file_seq_file ;
  void *tmp ;

  {
  {
#line 2106
  tmp = ldv_xmalloc(256UL);
#line 2106
  ldv_17_seq_file_seq_file = (struct seq_file *)tmp;
#line 2107
  ldv_17_ops_seq_operations = arg2;
#line 2112
  ldv_dispatch_register_17_1(ldv_17_seq_file_seq_file, ldv_17_ops_seq_operations);
  }
#line 2116
  return (arg0);
#line 2118
  return (arg0);
}
}
#line 2123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_operations_seq_instance_10(void *arg0 ) 
{ 
  void *ldv_10_ldv_param_10_1_default ;
  long long *ldv_10_ldv_param_4_1_default ;
  void *ldv_10_ldv_param_7_1_default ;
  long long *ldv_10_ldv_param_7_2_default ;
  void *ldv_10_ldv_param_8_1_default ;
  struct seq_operations *ldv_10_ops_seq_operations ;
  struct seq_file *ldv_10_seq_file_seq_file ;
  int ldv_10_started_default ;
  struct ldv_struct_seq_instance_6 *data ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2135
  data = (struct ldv_struct_seq_instance_6 *)arg0;
#line 2139
  ldv_10_started_default = 0;
#line 2142
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_seq_instance_6 *)0)) {
    {
#line 2143
    ldv_10_seq_file_seq_file = data->arg0;
#line 2144
    ldv_10_ops_seq_operations = data->arg1;
#line 2145
    ldv_free((void *)data);
    }
  } else {

  }
#line 2153
  goto ldv_do_10;
#line 2155
  return;
  ldv_do_10: 
  {
#line 2161
  tmp___3 = ldv_undef_int();
  }
#line 2161
  if (tmp___3 != 0) {
    {
#line 2163
    ldv_assume(ldv_10_started_default == 1);
#line 2166
    tmp = ldv_undef_int();
    }
    {
#line 2167
    if (tmp == 1) {
#line 2167
      goto case_1;
    } else {

    }
#line 2192
    if (tmp == 2) {
#line 2192
      goto case_2;
    } else {

    }
#line 2215
    if (tmp == 3) {
#line 2215
      goto case_3;
    } else {

    }
#line 2242
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 2169
    ldv_10_ldv_param_10_1_default = ldv_xmalloc(1UL);
#line 2174
    ldv_seq_instance_stop_10_10(ldv_10_ops_seq_operations->stop, ldv_10_seq_file_seq_file,
                                ldv_10_ldv_param_10_1_default);
#line 2178
    ldv_free(ldv_10_ldv_param_10_1_default);
#line 2182
    ldv_10_started_default = 0;
    }
#line 2189
    goto ldv_do_10;
    case_2: /* CIL Label */ 
    {
#line 2194
    ldv_10_ldv_param_8_1_default = ldv_xmalloc(1UL);
#line 2199
    ldv_seq_instance_show_10_8(ldv_10_ops_seq_operations->show, ldv_10_seq_file_seq_file,
                               ldv_10_ldv_param_8_1_default);
#line 2203
    ldv_free(ldv_10_ldv_param_8_1_default);
    }
#line 2210
    goto ldv_do_10;
#line 2212
    goto ldv_do_10;
    case_3: /* CIL Label */ 
    {
#line 2217
    ldv_10_ldv_param_7_1_default = ldv_xmalloc(1UL);
#line 2218
    tmp___0 = ldv_xmalloc(8UL);
#line 2218
    ldv_10_ldv_param_7_2_default = (long long *)tmp___0;
#line 2223
    ldv_seq_instance_next_10_7(ldv_10_ops_seq_operations->next, ldv_10_seq_file_seq_file,
                               ldv_10_ldv_param_7_1_default, ldv_10_ldv_param_7_2_default);
#line 2227
    ldv_free(ldv_10_ldv_param_7_1_default);
#line 2228
    ldv_free((void *)ldv_10_ldv_param_7_2_default);
    }
#line 2235
    goto ldv_do_10;
#line 2237
    goto ldv_do_10;
#line 2239
    goto ldv_do_10;
    switch_default: /* CIL Label */ 
    {
#line 2242
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2247
    ldv_assume(ldv_10_started_default == 0);
#line 2250
    tmp___2 = ldv_undef_int();
    }
#line 2250
    if (tmp___2 != 0) {
      {
#line 2252
      tmp___1 = ldv_xmalloc(8UL);
#line 2252
      ldv_10_ldv_param_4_1_default = (long long *)tmp___1;
#line 2257
      ldv_seq_instance_start_10_4(ldv_10_ops_seq_operations->start, ldv_10_seq_file_seq_file,
                                  ldv_10_ldv_param_4_1_default);
#line 2261
      ldv_free((void *)ldv_10_ldv_param_4_1_default);
#line 2265
      ldv_10_started_default = 1;
      }
#line 2272
      goto ldv_do_10;
    } else {
#line 2280
      return;
    }
  }
#line 2284
  return;
}
}
#line 2289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_operations_seq_instance_6(void *arg0 ) 
{ 
  void *ldv_6_ldv_param_10_1_default ;
  long long *ldv_6_ldv_param_4_1_default ;
  void *ldv_6_ldv_param_7_1_default ;
  long long *ldv_6_ldv_param_7_2_default ;
  void *ldv_6_ldv_param_8_1_default ;
  struct seq_operations *ldv_6_ops_seq_operations ;
  struct seq_file *ldv_6_seq_file_seq_file ;
  int ldv_6_started_default ;
  struct ldv_struct_seq_instance_6 *data ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2301
  data = (struct ldv_struct_seq_instance_6 *)arg0;
#line 2305
  ldv_6_started_default = 0;
#line 2308
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_seq_instance_6 *)0)) {
    {
#line 2309
    ldv_6_seq_file_seq_file = data->arg0;
#line 2310
    ldv_6_ops_seq_operations = data->arg1;
#line 2311
    ldv_free((void *)data);
    }
  } else {

  }
#line 2319
  goto ldv_do_6;
#line 2321
  return;
  ldv_do_6: 
  {
#line 2327
  tmp___3 = ldv_undef_int();
  }
#line 2327
  if (tmp___3 != 0) {
    {
#line 2329
    ldv_assume(ldv_6_started_default == 1);
#line 2332
    tmp = ldv_undef_int();
    }
    {
#line 2333
    if (tmp == 1) {
#line 2333
      goto case_1;
    } else {

    }
#line 2358
    if (tmp == 2) {
#line 2358
      goto case_2;
    } else {

    }
#line 2381
    if (tmp == 3) {
#line 2381
      goto case_3;
    } else {

    }
#line 2408
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 2335
    ldv_6_ldv_param_10_1_default = ldv_xmalloc(1UL);
#line 2340
    ldv_seq_instance_stop_6_10(ldv_6_ops_seq_operations->stop, ldv_6_seq_file_seq_file,
                               ldv_6_ldv_param_10_1_default);
#line 2344
    ldv_free(ldv_6_ldv_param_10_1_default);
#line 2348
    ldv_6_started_default = 0;
    }
#line 2355
    goto ldv_do_6;
    case_2: /* CIL Label */ 
    {
#line 2360
    ldv_6_ldv_param_8_1_default = ldv_xmalloc(1UL);
#line 2365
    ldv_seq_instance_show_6_8(ldv_6_ops_seq_operations->show, ldv_6_seq_file_seq_file,
                              ldv_6_ldv_param_8_1_default);
#line 2369
    ldv_free(ldv_6_ldv_param_8_1_default);
    }
#line 2376
    goto ldv_do_6;
#line 2378
    goto ldv_do_6;
    case_3: /* CIL Label */ 
    {
#line 2383
    ldv_6_ldv_param_7_1_default = ldv_xmalloc(1UL);
#line 2384
    tmp___0 = ldv_xmalloc(8UL);
#line 2384
    ldv_6_ldv_param_7_2_default = (long long *)tmp___0;
#line 2389
    ldv_seq_instance_next_6_7(ldv_6_ops_seq_operations->next, ldv_6_seq_file_seq_file,
                              ldv_6_ldv_param_7_1_default, ldv_6_ldv_param_7_2_default);
#line 2393
    ldv_free(ldv_6_ldv_param_7_1_default);
#line 2394
    ldv_free((void *)ldv_6_ldv_param_7_2_default);
    }
#line 2401
    goto ldv_do_6;
#line 2403
    goto ldv_do_6;
#line 2405
    goto ldv_do_6;
    switch_default: /* CIL Label */ 
    {
#line 2408
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2413
    ldv_assume(ldv_6_started_default == 0);
#line 2416
    tmp___2 = ldv_undef_int();
    }
#line 2416
    if (tmp___2 != 0) {
      {
#line 2418
      tmp___1 = ldv_xmalloc(8UL);
#line 2418
      ldv_6_ldv_param_4_1_default = (long long *)tmp___1;
#line 2423
      ldv_seq_instance_start_6_4(ldv_6_ops_seq_operations->start, ldv_6_seq_file_seq_file,
                                 ldv_6_ldv_param_4_1_default);
#line 2427
      ldv_free((void *)ldv_6_ldv_param_4_1_default);
#line 2431
      ldv_6_started_default = 1;
      }
#line 2438
      goto ldv_do_6;
    } else {
#line 2446
      return;
    }
  }
#line 2450
  return;
}
}
#line 2455 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_operations_seq_instance_7(void *arg0 ) 
{ 
  void *ldv_7_ldv_param_10_1_default ;
  long long *ldv_7_ldv_param_4_1_default ;
  void *ldv_7_ldv_param_7_1_default ;
  long long *ldv_7_ldv_param_7_2_default ;
  void *ldv_7_ldv_param_8_1_default ;
  struct seq_operations *ldv_7_ops_seq_operations ;
  struct seq_file *ldv_7_seq_file_seq_file ;
  int ldv_7_started_default ;
  struct ldv_struct_seq_instance_6 *data ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2467
  data = (struct ldv_struct_seq_instance_6 *)arg0;
#line 2471
  ldv_7_started_default = 0;
#line 2474
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_seq_instance_6 *)0)) {
    {
#line 2475
    ldv_7_seq_file_seq_file = data->arg0;
#line 2476
    ldv_7_ops_seq_operations = data->arg1;
#line 2477
    ldv_free((void *)data);
    }
  } else {

  }
#line 2485
  goto ldv_do_7;
#line 2487
  return;
  ldv_do_7: 
  {
#line 2493
  tmp___3 = ldv_undef_int();
  }
#line 2493
  if (tmp___3 != 0) {
    {
#line 2495
    ldv_assume(ldv_7_started_default == 1);
#line 2498
    tmp = ldv_undef_int();
    }
    {
#line 2499
    if (tmp == 1) {
#line 2499
      goto case_1;
    } else {

    }
#line 2524
    if (tmp == 2) {
#line 2524
      goto case_2;
    } else {

    }
#line 2547
    if (tmp == 3) {
#line 2547
      goto case_3;
    } else {

    }
#line 2574
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 2501
    ldv_7_ldv_param_10_1_default = ldv_xmalloc(1UL);
#line 2506
    ldv_seq_instance_stop_7_10(ldv_7_ops_seq_operations->stop, ldv_7_seq_file_seq_file,
                               ldv_7_ldv_param_10_1_default);
#line 2510
    ldv_free(ldv_7_ldv_param_10_1_default);
#line 2514
    ldv_7_started_default = 0;
    }
#line 2521
    goto ldv_do_7;
    case_2: /* CIL Label */ 
    {
#line 2526
    ldv_7_ldv_param_8_1_default = ldv_xmalloc(1UL);
#line 2531
    ldv_seq_instance_show_7_8(ldv_7_ops_seq_operations->show, ldv_7_seq_file_seq_file,
                              ldv_7_ldv_param_8_1_default);
#line 2535
    ldv_free(ldv_7_ldv_param_8_1_default);
    }
#line 2542
    goto ldv_do_7;
#line 2544
    goto ldv_do_7;
    case_3: /* CIL Label */ 
    {
#line 2549
    ldv_7_ldv_param_7_1_default = ldv_xmalloc(1UL);
#line 2550
    tmp___0 = ldv_xmalloc(8UL);
#line 2550
    ldv_7_ldv_param_7_2_default = (long long *)tmp___0;
#line 2555
    ldv_seq_instance_next_7_7(ldv_7_ops_seq_operations->next, ldv_7_seq_file_seq_file,
                              ldv_7_ldv_param_7_1_default, ldv_7_ldv_param_7_2_default);
#line 2559
    ldv_free(ldv_7_ldv_param_7_1_default);
#line 2560
    ldv_free((void *)ldv_7_ldv_param_7_2_default);
    }
#line 2567
    goto ldv_do_7;
#line 2569
    goto ldv_do_7;
#line 2571
    goto ldv_do_7;
    switch_default: /* CIL Label */ 
    {
#line 2574
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2579
    ldv_assume(ldv_7_started_default == 0);
#line 2582
    tmp___2 = ldv_undef_int();
    }
#line 2582
    if (tmp___2 != 0) {
      {
#line 2584
      tmp___1 = ldv_xmalloc(8UL);
#line 2584
      ldv_7_ldv_param_4_1_default = (long long *)tmp___1;
#line 2589
      ldv_seq_instance_start_7_4(ldv_7_ops_seq_operations->start, ldv_7_seq_file_seq_file,
                                 ldv_7_ldv_param_4_1_default);
#line 2593
      ldv_free((void *)ldv_7_ldv_param_4_1_default);
#line 2597
      ldv_7_started_default = 1;
      }
#line 2604
      goto ldv_do_7;
    } else {
#line 2612
      return;
    }
  }
#line 2616
  return;
}
}
#line 2621 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_operations_seq_instance_8(void *arg0 ) 
{ 
  void *ldv_8_ldv_param_10_1_default ;
  long long *ldv_8_ldv_param_4_1_default ;
  void *ldv_8_ldv_param_7_1_default ;
  long long *ldv_8_ldv_param_7_2_default ;
  void *ldv_8_ldv_param_8_1_default ;
  struct seq_operations *ldv_8_ops_seq_operations ;
  struct seq_file *ldv_8_seq_file_seq_file ;
  int ldv_8_started_default ;
  struct ldv_struct_seq_instance_6 *data ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2633
  data = (struct ldv_struct_seq_instance_6 *)arg0;
#line 2637
  ldv_8_started_default = 0;
#line 2640
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_seq_instance_6 *)0)) {
    {
#line 2641
    ldv_8_seq_file_seq_file = data->arg0;
#line 2642
    ldv_8_ops_seq_operations = data->arg1;
#line 2643
    ldv_free((void *)data);
    }
  } else {

  }
#line 2651
  goto ldv_do_8;
#line 2653
  return;
  ldv_do_8: 
  {
#line 2659
  tmp___3 = ldv_undef_int();
  }
#line 2659
  if (tmp___3 != 0) {
    {
#line 2661
    ldv_assume(ldv_8_started_default == 1);
#line 2664
    tmp = ldv_undef_int();
    }
    {
#line 2665
    if (tmp == 1) {
#line 2665
      goto case_1;
    } else {

    }
#line 2690
    if (tmp == 2) {
#line 2690
      goto case_2;
    } else {

    }
#line 2713
    if (tmp == 3) {
#line 2713
      goto case_3;
    } else {

    }
#line 2740
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 2667
    ldv_8_ldv_param_10_1_default = ldv_xmalloc(1UL);
#line 2672
    ldv_seq_instance_stop_8_10(ldv_8_ops_seq_operations->stop, ldv_8_seq_file_seq_file,
                               ldv_8_ldv_param_10_1_default);
#line 2676
    ldv_free(ldv_8_ldv_param_10_1_default);
#line 2680
    ldv_8_started_default = 0;
    }
#line 2687
    goto ldv_do_8;
    case_2: /* CIL Label */ 
    {
#line 2692
    ldv_8_ldv_param_8_1_default = ldv_xmalloc(1UL);
#line 2697
    ldv_seq_instance_show_8_8(ldv_8_ops_seq_operations->show, ldv_8_seq_file_seq_file,
                              ldv_8_ldv_param_8_1_default);
#line 2701
    ldv_free(ldv_8_ldv_param_8_1_default);
    }
#line 2708
    goto ldv_do_8;
#line 2710
    goto ldv_do_8;
    case_3: /* CIL Label */ 
    {
#line 2715
    ldv_8_ldv_param_7_1_default = ldv_xmalloc(1UL);
#line 2716
    tmp___0 = ldv_xmalloc(8UL);
#line 2716
    ldv_8_ldv_param_7_2_default = (long long *)tmp___0;
#line 2721
    ldv_seq_instance_next_8_7(ldv_8_ops_seq_operations->next, ldv_8_seq_file_seq_file,
                              ldv_8_ldv_param_7_1_default, ldv_8_ldv_param_7_2_default);
#line 2725
    ldv_free(ldv_8_ldv_param_7_1_default);
#line 2726
    ldv_free((void *)ldv_8_ldv_param_7_2_default);
    }
#line 2733
    goto ldv_do_8;
#line 2735
    goto ldv_do_8;
#line 2737
    goto ldv_do_8;
    switch_default: /* CIL Label */ 
    {
#line 2740
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2745
    ldv_assume(ldv_8_started_default == 0);
#line 2748
    tmp___2 = ldv_undef_int();
    }
#line 2748
    if (tmp___2 != 0) {
      {
#line 2750
      tmp___1 = ldv_xmalloc(8UL);
#line 2750
      ldv_8_ldv_param_4_1_default = (long long *)tmp___1;
#line 2755
      ldv_seq_instance_start_8_4(ldv_8_ops_seq_operations->start, ldv_8_seq_file_seq_file,
                                 ldv_8_ldv_param_4_1_default);
#line 2759
      ldv_free((void *)ldv_8_ldv_param_4_1_default);
#line 2763
      ldv_8_started_default = 1;
      }
#line 2770
      goto ldv_do_8;
    } else {
#line 2778
      return;
    }
  }
#line 2782
  return;
}
}
#line 2787 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
void ldv_seq_operations_seq_instance_9(void *arg0 ) 
{ 
  void *ldv_9_ldv_param_10_1_default ;
  long long *ldv_9_ldv_param_4_1_default ;
  void *ldv_9_ldv_param_7_1_default ;
  long long *ldv_9_ldv_param_7_2_default ;
  void *ldv_9_ldv_param_8_1_default ;
  struct seq_operations *ldv_9_ops_seq_operations ;
  struct seq_file *ldv_9_seq_file_seq_file ;
  int ldv_9_started_default ;
  struct ldv_struct_seq_instance_6 *data ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2799
  data = (struct ldv_struct_seq_instance_6 *)arg0;
#line 2803
  ldv_9_started_default = 0;
#line 2806
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_seq_instance_6 *)0)) {
    {
#line 2807
    ldv_9_seq_file_seq_file = data->arg0;
#line 2808
    ldv_9_ops_seq_operations = data->arg1;
#line 2809
    ldv_free((void *)data);
    }
  } else {

  }
#line 2817
  goto ldv_do_9;
#line 2819
  return;
  ldv_do_9: 
  {
#line 2825
  tmp___3 = ldv_undef_int();
  }
#line 2825
  if (tmp___3 != 0) {
    {
#line 2827
    ldv_assume(ldv_9_started_default == 1);
#line 2830
    tmp = ldv_undef_int();
    }
    {
#line 2831
    if (tmp == 1) {
#line 2831
      goto case_1;
    } else {

    }
#line 2856
    if (tmp == 2) {
#line 2856
      goto case_2;
    } else {

    }
#line 2879
    if (tmp == 3) {
#line 2879
      goto case_3;
    } else {

    }
#line 2906
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 2833
    ldv_9_ldv_param_10_1_default = ldv_xmalloc(1UL);
#line 2838
    ldv_seq_instance_stop_9_10(ldv_9_ops_seq_operations->stop, ldv_9_seq_file_seq_file,
                               ldv_9_ldv_param_10_1_default);
#line 2842
    ldv_free(ldv_9_ldv_param_10_1_default);
#line 2846
    ldv_9_started_default = 0;
    }
#line 2853
    goto ldv_do_9;
    case_2: /* CIL Label */ 
    {
#line 2858
    ldv_9_ldv_param_8_1_default = ldv_xmalloc(1UL);
#line 2863
    ldv_seq_instance_show_9_8(ldv_9_ops_seq_operations->show, ldv_9_seq_file_seq_file,
                              ldv_9_ldv_param_8_1_default);
#line 2867
    ldv_free(ldv_9_ldv_param_8_1_default);
    }
#line 2874
    goto ldv_do_9;
#line 2876
    goto ldv_do_9;
    case_3: /* CIL Label */ 
    {
#line 2881
    ldv_9_ldv_param_7_1_default = ldv_xmalloc(1UL);
#line 2882
    tmp___0 = ldv_xmalloc(8UL);
#line 2882
    ldv_9_ldv_param_7_2_default = (long long *)tmp___0;
#line 2887
    ldv_seq_instance_next_9_7(ldv_9_ops_seq_operations->next, ldv_9_seq_file_seq_file,
                              ldv_9_ldv_param_7_1_default, ldv_9_ldv_param_7_2_default);
#line 2891
    ldv_free(ldv_9_ldv_param_7_1_default);
#line 2892
    ldv_free((void *)ldv_9_ldv_param_7_2_default);
    }
#line 2899
    goto ldv_do_9;
#line 2901
    goto ldv_do_9;
#line 2903
    goto ldv_do_9;
    switch_default: /* CIL Label */ 
    {
#line 2906
    ldv_stop();
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2911
    ldv_assume(ldv_9_started_default == 0);
#line 2914
    tmp___2 = ldv_undef_int();
    }
#line 2914
    if (tmp___2 != 0) {
      {
#line 2916
      tmp___1 = ldv_xmalloc(8UL);
#line 2916
      ldv_9_ldv_param_4_1_default = (long long *)tmp___1;
#line 2921
      ldv_seq_instance_start_9_4(ldv_9_ops_seq_operations->start, ldv_9_seq_file_seq_file,
                                 ldv_9_ldv_param_4_1_default);
#line 2925
      ldv_free((void *)ldv_9_ldv_param_4_1_default);
#line 2929
      ldv_9_started_default = 1;
      }
#line 2936
      goto ldv_do_9;
    } else {
#line 2944
      return;
    }
  }
#line 2948
  return;
}
}
#line 3635 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
static int ldv_seq_open_95(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3639
  tmp = seq_open(ldv_func_arg1, ldv_func_arg2);
#line 3639
  ldv_func_res = tmp;
#line 3642
  tmp___0 = ldv_seq_open(ldv_func_res, ldv_func_arg1, (struct seq_operations *)ldv_func_arg2);
  }
#line 3642
  return (tmp___0);
#line 3644
  return (ldv_func_res);
}
}
#line 3647 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_gruprocfs.c.aux"
static int ldv_seq_open_96(struct file *ldv_func_arg1 , struct seq_operations  const  *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 3651
  tmp = seq_open(ldv_func_arg1, ldv_func_arg2);
#line 3651
  ldv_func_res = tmp;
#line 3654
  tmp___0 = ldv_seq_open(ldv_func_res, ldv_func_arg1, (struct seq_operations *)ldv_func_arg2);
  }
#line 3654
  return (tmp___0);
#line 3656
  return (ldv_func_res);
}
}
#line 250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grukservices.c.aux"
void ldv_linux_kernel_sched_completion_wait_for_completion_bs_async_wq_of_gru_blade_state(void) ;
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void panic(char const   *  , ...) ;
#line 392
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add___1(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
  {
#line 72
  if (4UL == 1UL) {
#line 72
    goto case_1;
  } else {

  }
#line 72
  if (4UL == 2UL) {
#line 72
    goto case_2;
  } else {

  }
#line 72
  if (4UL == 4UL) {
#line 72
    goto case_4;
  } else {

  }
#line 72
  if (4UL == 8UL) {
#line 72
    goto case_8;
  } else {

  }
#line 72
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_7174;
  case_2: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_7174;
  case_4: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_7174;
  case_8: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_7174;
  switch_default: /* CIL Label */ 
  {
#line 72
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7174: ;
#line 74
  return;
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub___1(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8;
  } else {

  }
#line 77
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_7186;
  case_2: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_7186;
  case_4: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_7186;
  case_8: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_7186;
  switch_default: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7186: ;
#line 79
  return;
}
}
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/completion.h"
extern void wait_for_completion(struct completion * ) ;
#line 94
static void ldv_wait_for_completion_95(struct completion *ldv_func_arg1 ) ;
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
int gru_check_status_proc(void *cb ) ;
#line 23
int gru_wait_proc(void *cb ) ;
#line 24
void gru_wait_abort_proc(void *cb ) ;
#line 313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static unsigned long __opdword(unsigned char opcode , unsigned char exopc ,
                                        unsigned char xtype , unsigned char iaa0 ,
                                        unsigned char iaa1 , unsigned long idef2 ,
                                        unsigned char ima ) 
{ 


  {
#line 317
  return ((((((((idef2 << 32) | (unsigned long )((int )iaa0 << 11)) | (unsigned long )((int )iaa1 << 13)) | (unsigned long )((int )ima << 1)) | (unsigned long )((int )xtype << 8)) | (unsigned long )((int )opcode << 16)) | (unsigned long )((int )exopc << 24)) | 144115188075855873UL);
}
}
#line 340 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_start_instruction(struct gru_instruction *ins , unsigned long op64 ) 
{ 


  {
  {
#line 342
  __asm__  volatile   ("": : : "memory");
#line 342
  *((unsigned long *)ins) = op64;
#line 343
  __asm__  volatile   ("mfence": : : "memory");
#line 344
  gru_flush_cache((void *)ins);
  }
#line 345
  return;
}
}
#line 359 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vload_phys(void *cb , unsigned long gpa , unsigned int tri0 ,
                                    int iaa , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 362
  ins = (struct gru_instruction *)cb;
#line 364
  ins->baddr0 = gpa | ((unsigned long )iaa << 62);
#line 365
  ins->nelem = 1UL;
#line 366
  ins->op1_stride = 1UL;
#line 367
  tmp = __opdword(2, 0, 3, (int )((unsigned char )iaa), 0, (unsigned long )tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 367
  gru_start_instruction(ins, tmp);
  }
#line 369
  return;
}
}
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vstore_phys(void *cb , unsigned long gpa , unsigned int tri0 ,
                                     int iaa , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 374
  ins = (struct gru_instruction *)cb;
#line 376
  ins->baddr0 = gpa | ((unsigned long )iaa << 62);
#line 377
  ins->nelem = 1UL;
#line 378
  ins->op1_stride = 1UL;
#line 379
  tmp = __opdword(4, 0, 3, (int )((unsigned char )iaa), 0, (unsigned long )tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 379
  gru_start_instruction(ins, tmp);
  }
#line 381
  return;
}
}
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vload(void *cb , unsigned long mem_addr , unsigned int tri0 ,
                               unsigned char xtype , unsigned long nelem , unsigned long stride ,
                               unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 387
  ins = (struct gru_instruction *)cb;
#line 389
  ins->baddr0 = mem_addr;
#line 390
  ins->nelem = nelem;
#line 391
  ins->op1_stride = stride;
#line 392
  tmp = __opdword(2, 0, (int )xtype, 0, 0, (unsigned long )tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 392
  gru_start_instruction(ins, tmp);
  }
#line 394
  return;
}
}
#line 396 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vstore(void *cb , unsigned long mem_addr , unsigned int tri0 ,
                                unsigned char xtype , unsigned long nelem , unsigned long stride ,
                                unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 400
  ins = (struct gru_instruction *)cb;
#line 402
  ins->baddr0 = mem_addr;
#line 403
  ins->nelem = nelem;
#line 404
  ins->op1_stride = stride;
#line 405
  tmp = __opdword(4, 0, (int )xtype, 0, 0, (unsigned long )tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 405
  gru_start_instruction(ins, tmp);
  }
#line 406
  return;
}
}
#line 435 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_vset(void *cb , unsigned long mem_addr , unsigned long value ,
                              unsigned char xtype , unsigned long nelem , unsigned long stride ,
                              unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 439
  ins = (struct gru_instruction *)cb;
#line 441
  ins->baddr0 = mem_addr;
#line 442
  ins->op2_value_baddr1 = value;
#line 443
  ins->nelem = nelem;
#line 444
  ins->op1_stride = stride;
#line 445
  tmp = __opdword(6, 0, (int )xtype, 0, 0, 0UL, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 445
  gru_start_instruction(ins, tmp);
  }
#line 446
  return;
}
}
#line 484 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_bcopy(void *cb , unsigned long const   src , unsigned long dest ,
                               unsigned int tri0 , unsigned int xtype , unsigned long nelem ,
                               unsigned int bufsize , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 489
  ins = (struct gru_instruction *)cb;
#line 491
  ins->baddr0 = (unsigned long )src;
#line 492
  ins->op2_value_baddr1 = dest;
#line 493
  ins->nelem = nelem;
#line 494
  ins->tri1_bufsize = (unsigned long )bufsize;
#line 495
  tmp = __opdword(1, 0, (int )((unsigned char )xtype), 0, 0, (unsigned long )tri0,
                  (int )((unsigned int )((unsigned char )hints) | 2U));
#line 495
  gru_start_instruction(ins, tmp);
  }
#line 496
  return;
}
}
#line 512 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_gamir(void *cb , int exopc , unsigned long src , unsigned int xtype ,
                               unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 515
  ins = (struct gru_instruction *)cb;
#line 517
  ins->baddr0 = src;
#line 518
  tmp = __opdword(10, (int )((unsigned char )exopc), (int )((unsigned char )xtype),
                  0, 0, 0UL, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 518
  gru_start_instruction(ins, tmp);
  }
#line 519
  return;
}
}
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_gamer(void *cb , int exopc , unsigned long src , unsigned int xtype ,
                               unsigned long operand1 , unsigned long operand2 , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 537
  ins = (struct gru_instruction *)cb;
#line 539
  ins->baddr0 = src;
#line 540
  ins->op1_stride = operand1;
#line 541
  ins->op2_value_baddr1 = operand2;
#line 542
  tmp = __opdword(12, (int )((unsigned char )exopc), (int )((unsigned char )xtype),
                  0, 0, 0UL, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 542
  gru_start_instruction(ins, tmp);
  }
#line 543
  return;
}
}
#line 570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static void gru_mesq(void *cb , unsigned long queue , unsigned long tri0 ,
                              unsigned long nelem , unsigned long hints ) 
{ 
  struct gru_instruction *ins ;
  unsigned long tmp ;

  {
  {
#line 574
  ins = (struct gru_instruction *)cb;
#line 576
  ins->baddr0 = queue;
#line 577
  ins->nelem = nelem;
#line 578
  tmp = __opdword(8, 0, 6, 0, 0, tri0, (int )((unsigned int )((unsigned char )hints) | 2U));
#line 578
  gru_start_instruction(ins, tmp);
  }
#line 579
  return;
}
}
#line 582 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static unsigned long gru_get_amo_value(void *cb ) 
{ 
  struct gru_instruction *ins ;

  {
#line 584
  ins = (struct gru_instruction *)cb;
#line 586
  return (ins->avalue);
}
}
#line 589 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_get_amo_value_head(void *cb ) 
{ 
  struct gru_instruction *ins ;

  {
#line 591
  ins = (struct gru_instruction *)cb;
#line 593
  return ((int )ins->avalue);
}
}
#line 596 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_get_amo_value_limit(void *cb ) 
{ 
  struct gru_instruction *ins ;

  {
#line 598
  ins = (struct gru_instruction *)cb;
#line 600
  return ((int )(ins->avalue >> 32));
}
}
#line 603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static union gru_mesqhead gru_mesq_head(int head , int limit ) 
{ 
  union gru_mesqhead mqh ;

  {
#line 607
  mqh.__annonCompField74.head = (unsigned int )head;
#line 608
  mqh.__annonCompField74.limit = (unsigned int )limit;
#line 609
  return (mqh);
}
}
#line 615
int gru_get_cb_exception_detail(void *cb , struct control_block_extended_exc_detail *excdet ) ;
#line 644 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_get_cb_message_queue_substatus(void *cb ) 
{ 
  struct gru_control_block_status *cbs ;

  {
#line 646
  cbs = (struct gru_control_block_status *)cb;
#line 648
  return ((int )cbs->isubstatus & 7);
}
}
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_check_status(void *cb ) 
{ 
  struct gru_control_block_status *cbs ;
  int ret ;

  {
#line 667
  cbs = (struct gru_control_block_status *)cb;
#line 670
  ret = (int )cbs->istatus;
#line 671
  if (ret != 2) {
    {
#line 672
    ret = gru_check_status_proc(cb);
    }
  } else {

  }
#line 673
  return (ret);
}
}
#line 683 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_wait(void *cb ) 
{ 
  int tmp ;

  {
  {
#line 685
  tmp = gru_wait_proc(cb);
  }
#line 685
  return (tmp);
}
}
#line 732 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gru_instructions.h"
__inline static int gru_get_tri(void *vaddr ) 
{ 


  {
#line 734
  return ((int )(((unsigned int )((long )vaddr) & 262143U) - 131072U));
}
}
#line 112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
__inline static void *get_gseg_base_address_ds(void *base , int ctxnum , int line ) 
{ 
  void *tmp ;

  {
  {
#line 114
  tmp = get_gseg_base_address(base, ctxnum);
  }
#line 114
  return (tmp + ((unsigned long )(line * 64) + 131072UL));
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.h"
int gru_create_message_queue(struct gru_message_queue_desc *mqd , void *p , unsigned int bytes ,
                             int nasid , int vector , int apicid ) ;
#line 94
int gru_send_message_gpa(struct gru_message_queue_desc *mqd , void *mesg , unsigned int bytes ) ;
#line 114
void gru_free_message(struct gru_message_queue_desc *mqd , void *mesg ) ;
#line 130
void *gru_get_next_message(struct gru_message_queue_desc *mqd ) ;
#line 144
int gru_read_gpa(unsigned long *value , unsigned long gpa ) ;
#line 160
int gru_copy_gpa(unsigned long dest_gpa , unsigned long src_gpa , unsigned int bytes ) ;
#line 176
unsigned long gru_reserve_async_resources(int blade_id , int cbrs , int dsr_bytes ,
                                          struct completion *cmp ) ;
#line 185
void gru_release_async_resources(unsigned long han ) ;
#line 193
void gru_wait_async_cbr(unsigned long han ) ;
#line 204
void gru_lock_async_resource(unsigned long han , void **cb , void **dsr ) ;
#line 212
void gru_unlock_async_resource(unsigned long han ) ;
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_gpa(void *v ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 325
  tmp = __phys_addr((unsigned long )v);
#line 325
  tmp___0 = uv_soc_phys_ram_to_gpa(tmp);
  }
#line 325
  return (tmp___0);
}
}
#line 441 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
__inline static unsigned long uv_global_gru_mmr_address(int pnode , unsigned long offset ) 
{ 
  void const   *__vpp_verify ;
  unsigned long tcp_ptr__ ;

  {
#line 444
  __vpp_verify = (void const   *)0;
#line 444
  __asm__  volatile   ("add %%gs:%1, %0": "=r" (tcp_ptr__): "m" (this_cpu_off), "0" (& __uv_hub_info));
#line 443
  return ((offset | ((unsigned long )pnode << (int )((struct uv_hub_info_s *)tcp_ptr__)->m_val)) | 67108864UL);
}
}
#line 645
extern unsigned int uv_apicid_hibits ;
#line 646 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uv/uv_hub.h"
static unsigned long uv_hub_ipi_value(int apicid , int vector , int mode ) 
{ 


  {
#line 648
  apicid = (int )((unsigned int )apicid | uv_apicid_hibits);
#line 649
  return ((((unsigned long )(apicid << 16) | (unsigned long )(mode << 8)) | (unsigned long )vector) | 0x8000000000000000UL);
}
}
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static void gru_load_kernel_context(struct gru_blade_state *bs , int blade_id ) 
{ 
  struct gru_state *gru ;
  struct gru_thread_state *kgts ;
  void *vaddr ;
  int ctxnum ;
  int ncpus ;
  struct gru_state *tmp ;

  {
  {
#line 159
  up_read(& bs->bs_kgts_sema);
#line 160
  down_write(& bs->bs_kgts_sema);
  }
#line 162
  if ((unsigned long )bs->bs_kgts == (unsigned long )((struct gru_thread_state *)0)) {
    {
#line 163
    bs->bs_kgts = gru_alloc_gts((struct vm_area_struct *)0, 0, 0, 0, 0, 0);
#line 164
    (bs->bs_kgts)->ts_user_blade_id = (short )blade_id;
    }
  } else {

  }
#line 166
  kgts = bs->bs_kgts;
#line 168
  if ((unsigned long )kgts->ts_gru == (unsigned long )((struct gru_state *)0)) {
#line 169
    if ((gru_options & 2UL) != 0UL) {
      {
#line 169
      atomic_long_inc(& gru_stats.load_kernel_context);
      }
    } else {

    }
    {
#line 170
    ncpus = uv_blade_nr_possible_cpus(blade_id);
#line 171
    kgts->ts_cbr_au_count = (unsigned char )(((ncpus + bs->bs_async_cbrs) + 1) / 2);
#line 173
    kgts->ts_dsr_au_count = (unsigned char )(((ncpus * 256 + bs->bs_async_dsr_bytes) + 1023) / 1024);
    }
#line 176
    goto ldv_33689;
    ldv_33688: 
    {
#line 177
    msleep(1U);
#line 178
    gru_steal_context(kgts);
    }
    ldv_33689: 
    {
#line 176
    tmp = gru_assign_gru_context(kgts);
    }
#line 176
    if ((unsigned long )tmp == (unsigned long )((struct gru_state *)0)) {
#line 178
      goto ldv_33688;
    } else {

    }
    {
#line 180
    gru_load_context(kgts);
#line 181
    gru = (bs->bs_kgts)->ts_gru;
#line 182
    vaddr = gru->gs_gru_base_vaddr;
#line 183
    ctxnum = kgts->ts_ctxnum;
#line 184
    bs->kernel_cb = get_gseg_base_address_cb(vaddr, ctxnum, 0);
#line 185
    bs->kernel_dsr = get_gseg_base_address_ds(vaddr, ctxnum, 0);
    }
  } else {

  }
  {
#line 187
  downgrade_write(& bs->bs_kgts_sema);
  }
#line 188
  return;
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int gru_free_kernel_contexts(void) 
{ 
  struct gru_blade_state *bs ;
  struct gru_thread_state *kgts ;
  int bid ;
  int ret ;
  int tmp ;

  {
#line 198
  ret = 0;
#line 200
  bid = 0;
#line 200
  goto ldv_33700;
  ldv_33699: 
#line 201
  bs = gru_base[bid];
#line 202
  if ((unsigned long )bs == (unsigned long )((struct gru_blade_state *)0)) {
#line 203
    goto ldv_33698;
  } else {

  }
  {
#line 206
  tmp = down_write_trylock(& bs->bs_kgts_sema);
  }
#line 206
  if (tmp != 0) {
#line 207
    kgts = bs->bs_kgts;
#line 208
    if ((unsigned long )kgts != (unsigned long )((struct gru_thread_state *)0) && (unsigned long )kgts->ts_gru != (unsigned long )((struct gru_state *)0)) {
      {
#line 209
      gru_unload_context(kgts, 0);
      }
    } else {

    }
    {
#line 210
    bs->bs_kgts = (struct gru_thread_state *)0;
#line 211
    up_write(& bs->bs_kgts_sema);
#line 212
    kfree((void const   *)kgts);
    }
  } else {
#line 214
    ret = ret + 1;
  }
  ldv_33698: 
#line 200
  bid = bid + 1;
  ldv_33700: ;
#line 200
  if (bid <= 1023) {
#line 202
    goto ldv_33699;
  } else {

  }

#line 217
  return (ret);
}
}
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static struct gru_blade_state *gru_lock_kernel_context(int blade_id ) 
{ 
  struct gru_blade_state *bs ;
  int bid ;
  int tmp ;
  int tmp___0 ;

  {
#line 228
  if ((gru_options & 2UL) != 0UL) {
    {
#line 228
    atomic_long_inc(& gru_stats.lock_kernel_context);
    }
  } else {

  }
  again: ;
#line 230
  if (blade_id < 0) {
    {
#line 230
    tmp = uv_numa_blade_id();
#line 230
    bid = tmp;
    }
  } else {
#line 230
    bid = blade_id;
  }
  {
#line 231
  bs = gru_base[bid];
#line 234
  down_read(& bs->bs_kgts_sema);
  }
#line 235
  if (blade_id < 0) {
    {
#line 235
    tmp___0 = uv_numa_blade_id();
    }
#line 235
    if (bid != tmp___0) {
      {
#line 236
      up_read(& bs->bs_kgts_sema);
      }
#line 237
      goto again;
    } else {

    }
  } else {

  }
#line 239
  if ((unsigned long )bs->bs_kgts == (unsigned long )((struct gru_thread_state *)0) || (unsigned long )(bs->bs_kgts)->ts_gru == (unsigned long )((struct gru_state *)0)) {
    {
#line 240
    gru_load_kernel_context(bs, bid);
    }
  } else {

  }
#line 241
  return (bs);
}
}
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static void gru_unlock_kernel_context(int blade_id ) 
{ 
  struct gru_blade_state *bs ;

  {
  {
#line 253
  bs = gru_base[blade_id];
#line 254
  up_read(& bs->bs_kgts_sema);
  }
#line 255
  if ((gru_options & 2UL) != 0UL) {
    {
#line 255
    atomic_long_inc(& gru_stats.unlock_kernel_context);
    }
  } else {

  }
#line 256
  return;
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int gru_get_cpu_resources(int dsr_bytes , void **cb , void **dsr ) 
{ 
  struct gru_blade_state *bs ;
  int lcpu ;
  long tmp ;

  {
  {
#line 267
  tmp = __builtin_expect(dsr_bytes > 256, 0L);
  }
#line 267
  if (tmp != 0L) {
    {
#line 267
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grukservices.c"),
                         "i" (267), "i" (12UL));
#line 267
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 268
  __preempt_count_add___1(1);
#line 268
  __asm__  volatile   ("": : : "memory");
#line 269
  bs = gru_lock_kernel_context(-1);
#line 270
  lcpu = uv_blade_processor_id();
#line 271
  *cb = bs->kernel_cb + (unsigned long )(lcpu * 256);
#line 272
  *dsr = bs->kernel_dsr + (unsigned long )(lcpu * 256);
  }
#line 273
  return (0);
}
}
#line 279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static void gru_free_cpu_resources(void *cb , void *dsr ) 
{ 
  int tmp ;

  {
  {
#line 281
  tmp = uv_numa_blade_id();
#line 281
  gru_unlock_kernel_context(tmp);
#line 282
  __asm__  volatile   ("": : : "memory");
#line 282
  __preempt_count_sub___1(1);
  }
#line 283
  return;
}
}
#line 297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
unsigned long gru_reserve_async_resources(int blade_id , int cbrs , int dsr_bytes ,
                                          struct completion *cmp ) 
{ 
  struct gru_blade_state *bs ;
  struct gru_thread_state *kgts ;
  int ret ;

  {
  {
#line 302
  ret = 0;
#line 304
  bs = gru_base[blade_id];
#line 306
  down_write(& bs->bs_kgts_sema);
  }
#line 309
  if (bs->bs_async_dsr_bytes + bs->bs_async_cbrs != 0) {
#line 310
    goto done;
  } else {

  }
#line 311
  bs->bs_async_dsr_bytes = dsr_bytes;
#line 312
  bs->bs_async_cbrs = cbrs;
#line 313
  bs->bs_async_wq = cmp;
#line 314
  kgts = bs->bs_kgts;
#line 317
  if ((unsigned long )kgts != (unsigned long )((struct gru_thread_state *)0) && (unsigned long )kgts->ts_gru != (unsigned long )((struct gru_state *)0)) {
    {
#line 318
    gru_unload_context(kgts, 0);
    }
  } else {

  }
#line 319
  ret = blade_id + 1;
  done: 
  {
#line 322
  up_write(& bs->bs_kgts_sema);
  }
#line 323
  return ((unsigned long )ret);
}
}
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void gru_release_async_resources(unsigned long han ) 
{ 
  struct gru_blade_state *bs ;

  {
  {
#line 334
  bs = gru_base[han - 1UL];
#line 336
  down_write(& bs->bs_kgts_sema);
#line 337
  bs->bs_async_dsr_bytes = 0;
#line 338
  bs->bs_async_cbrs = 0;
#line 339
  bs->bs_async_wq = (struct completion *)0;
#line 340
  up_write(& bs->bs_kgts_sema);
  }
#line 341
  return;
}
}
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void gru_wait_async_cbr(unsigned long han ) 
{ 
  struct gru_blade_state *bs ;

  {
  {
#line 351
  bs = gru_base[han - 1UL];
#line 353
  ldv_wait_for_completion_95(bs->bs_async_wq);
#line 354
  __asm__  volatile   ("mfence": : : "memory");
  }
#line 355
  return;
}
}
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void gru_lock_async_resource(unsigned long han , void **cb , void **dsr ) 
{ 
  struct gru_blade_state *bs ;
  int blade_id ;
  int ncpus ;

  {
  {
#line 368
  bs = gru_base[han - 1UL];
#line 369
  blade_id = (int )((unsigned int )han - 1U);
#line 372
  gru_lock_kernel_context(blade_id);
#line 373
  ncpus = uv_blade_nr_possible_cpus(blade_id);
  }
#line 374
  if ((unsigned long )cb != (unsigned long )((void **)0)) {
#line 375
    *cb = bs->kernel_cb + (unsigned long )(ncpus * 256);
  } else {

  }
#line 376
  if ((unsigned long )dsr != (unsigned long )((void **)0)) {
#line 377
    *dsr = bs->kernel_dsr + (unsigned long )(ncpus * 256);
  } else {

  }
#line 378
  return;
}
}
#line 386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void gru_unlock_async_resource(unsigned long han ) 
{ 
  int blade_id ;

  {
  {
#line 388
  blade_id = (int )((unsigned int )han - 1U);
#line 390
  gru_unlock_kernel_context(blade_id);
  }
#line 391
  return;
}
}
#line 394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_get_cb_exception_detail(void *cb , struct control_block_extended_exc_detail *excdet ) 
{ 
  struct gru_control_block_extended *cbe ;
  struct gru_thread_state *kgts ;
  unsigned long off ;
  int cbrnum ;
  int bid ;
  int tmp ;
  long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 398
  kgts = (struct gru_thread_state *)0;
#line 407
  bid = 0;
#line 407
  goto ldv_33765;
  ldv_33764: ;
#line 408
  if ((unsigned long )gru_base[bid] == (unsigned long )((struct gru_blade_state *)0)) {
#line 409
    goto ldv_33762;
  } else {

  }
#line 410
  kgts = (gru_base[bid])->bs_kgts;
#line 411
  if ((unsigned long )kgts == (unsigned long )((struct gru_thread_state *)0) || (unsigned long )kgts->ts_gru == (unsigned long )((struct gru_state *)0)) {
#line 412
    goto ldv_33763;
  } else {

  }
#line 413
  off = (unsigned long )((long )cb - (long )(kgts->ts_gru)->gs_gru_base_vaddr);
#line 414
  if (off <= 134217727UL) {
#line 415
    goto ldv_33762;
  } else {

  }
#line 416
  kgts = (struct gru_thread_state *)0;
  ldv_33763: 
#line 407
  bid = bid + 1;
  ldv_33765: 
  {
#line 407
  tmp = uv_num_possible_blades();
  }
#line 407
  if (bid < tmp) {
#line 409
    goto ldv_33764;
  } else {

  }
  ldv_33762: 
  {
#line 418
  tmp___0 = __builtin_expect((unsigned long )kgts == (unsigned long )((struct gru_thread_state *)0),
                             0L);
  }
#line 418
  if (tmp___0 != 0L) {
    {
#line 418
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grukservices.c"),
                         "i" (418), "i" (12UL));
#line 418
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 419
  tmp___1 = get_cb_number(cb);
#line 419
  tmp___2 = get_cb_number(cb);
#line 419
  cbrnum = (int )((unsigned int )((int )kgts->ts_cbr_idx[tmp___1 / 2UL] * 2) + ((unsigned int )tmp___2 & 1U));
#line 420
  cbe = get_cbe((void *)((unsigned long )cb & 0xfffffffff8000000UL), cbrnum);
#line 421
  gru_flush_cache((void *)cbe);
#line 422
  sync_core();
#line 423
  excdet->opc = (int )cbe->opccpy;
#line 424
  excdet->exopc = (int )cbe->exopccpy;
#line 425
  excdet->ecause = (int )cbe->ecause;
#line 426
  excdet->exceptdet0 = (long )cbe->idef1upd;
#line 427
  excdet->exceptdet1 = (int )cbe->idef3upd;
#line 428
  gru_flush_cache((void *)cbe);
  }
#line 429
  return (0);
}
}
#line 432 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
char *gru_get_cb_exception_detail_str(int ret , void *cb , char *buf , int size ) 
{ 
  struct gru_control_block_status *gen ;
  struct control_block_extended_exc_detail excdet ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;

  {
#line 435
  gen = (struct gru_control_block_status *)cb;
#line 438
  if (ret > 0 && (unsigned int )*((unsigned char *)gen + 7UL) == 1U) {
    {
#line 439
    gru_get_cb_exception_detail(cb, & excdet);
#line 442
    __vpp_verify = (void const   *)0;
    }
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2___0;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4___1;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8___2;
    } else {

    }
#line 442
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1___0;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8;
    } else {

    }
#line 442
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_33779;
    case_2: /* CIL Label */ 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_33779;
    case_4: /* CIL Label */ 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_33779;
    case_8: /* CIL Label */ 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 442
    goto ldv_33779;
    switch_default: /* CIL Label */ 
    {
#line 442
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_33779: 
#line 442
    pscr_ret__ = pfo_ret__;
#line 442
    goto ldv_33785;
    case_2___0: /* CIL Label */ ;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1___1;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2___1;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4___0;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8___0;
    } else {

    }
#line 442
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_33789;
    case_2___1: /* CIL Label */ 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_33789;
    case_4___0: /* CIL Label */ 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_33789;
    case_8___0: /* CIL Label */ 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 442
    goto ldv_33789;
    switch_default___0: /* CIL Label */ 
    {
#line 442
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_33789: 
#line 442
    pscr_ret__ = pfo_ret_____0;
#line 442
    goto ldv_33785;
    case_4___1: /* CIL Label */ ;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1___2;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2___2;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4___2;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8___1;
    } else {

    }
#line 442
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_33798;
    case_2___2: /* CIL Label */ 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_33798;
    case_4___2: /* CIL Label */ 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_33798;
    case_8___1: /* CIL Label */ 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 442
    goto ldv_33798;
    switch_default___1: /* CIL Label */ 
    {
#line 442
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_33798: 
#line 442
    pscr_ret__ = pfo_ret_____1;
#line 442
    goto ldv_33785;
    case_8___2: /* CIL Label */ ;
    {
#line 442
    if (4UL == 1UL) {
#line 442
      goto case_1___3;
    } else {

    }
#line 442
    if (4UL == 2UL) {
#line 442
      goto case_2___3;
    } else {

    }
#line 442
    if (4UL == 4UL) {
#line 442
      goto case_4___3;
    } else {

    }
#line 442
    if (4UL == 8UL) {
#line 442
      goto case_8___3;
    } else {

    }
#line 442
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 442
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_33807;
    case_2___3: /* CIL Label */ 
#line 442
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_33807;
    case_4___3: /* CIL Label */ 
#line 442
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_33807;
    case_8___3: /* CIL Label */ 
#line 442
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 442
    goto ldv_33807;
    switch_default___2: /* CIL Label */ 
    {
#line 442
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_33807: 
#line 442
    pscr_ret__ = pfo_ret_____2;
#line 442
    goto ldv_33785;
    switch_default___3: /* CIL Label */ 
    {
#line 442
    __bad_size_call_parameter();
    }
#line 442
    goto ldv_33785;
    switch_break: /* CIL Label */ ;
    }
    ldv_33785: 
    {
#line 442
    snprintf(buf, (size_t )size, "GRU:%d exception: cb %p, opc %d, exopc %d, ecause 0x%x,excdet0 0x%lx, excdet1 0x%x",
             pscr_ret__, gen, excdet.opc, excdet.exopc, excdet.ecause, excdet.exceptdet0,
             excdet.exceptdet1);
    }
  } else {
    {
#line 446
    snprintf(buf, (size_t )size, "No exception");
    }
  }
#line 448
  return (buf);
}
}
#line 451 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int gru_wait_idle_or_exception(struct gru_control_block_status *gen ) 
{ 


  {
#line 453
  goto ldv_33819;
  ldv_33818: 
  {
#line 454
  cpu_relax();
#line 455
  __asm__  volatile   ("": : : "memory");
  }
  ldv_33819: ;
#line 453
  if ((int )gen->istatus > 1) {
#line 455
    goto ldv_33818;
  } else {

  }

#line 457
  return ((int )gen->istatus);
}
}
#line 460 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int gru_retry_exception(void *cb ) 
{ 
  struct gru_control_block_status *gen ;
  struct control_block_extended_exc_detail excdet ;
  int retry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 462
  gen = (struct gru_control_block_status *)cb;
#line 464
  retry = 3;
  ldv_33828: 
  {
#line 467
  tmp = gru_wait_idle_or_exception(gen);
  }
#line 467
  if (tmp == 0) {
#line 468
    return (0);
  } else {

  }
  {
#line 469
  tmp___0 = gru_get_cb_message_queue_substatus(cb);
  }
#line 469
  if (tmp___0 != 0) {
#line 470
    return (1);
  } else {

  }
  {
#line 471
  gru_get_cb_exception_detail(cb, & excdet);
  }
#line 472
  if ((excdet.ecause & -414593) != 0 || excdet.cbrexecstatus & 1) {
#line 474
    goto ldv_33827;
  } else {

  }
#line 475
  tmp___1 = retry;
#line 475
  retry = retry - 1;
#line 475
  if (tmp___1 == 0) {
#line 476
    goto ldv_33827;
  } else {

  }
  {
#line 477
  gen->icmd = 1U;
#line 478
  gru_flush_cache((void *)gen);
  }
#line 479
  goto ldv_33828;
  ldv_33827: ;
#line 480
  return (1);
}
}
#line 483 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_check_status_proc(void *cb ) 
{ 
  struct gru_control_block_status *gen ;
  int ret ;

  {
#line 485
  gen = (struct gru_control_block_status *)cb;
#line 488
  ret = (int )gen->istatus;
#line 489
  if (ret == 1) {
    {
#line 490
    ret = gru_retry_exception(cb);
    }
  } else {

  }
#line 491
  __asm__  volatile   ("lfence": : : "memory");
#line 492
  return (ret);
}
}
#line 496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_wait_proc(void *cb ) 
{ 
  struct gru_control_block_status *gen ;
  int ret ;

  {
  {
#line 498
  gen = (struct gru_control_block_status *)cb;
#line 501
  ret = gru_wait_idle_or_exception(gen);
  }
#line 502
  if (ret == 1) {
    {
#line 503
    ret = gru_retry_exception(cb);
    }
  } else {

  }
#line 504
  __asm__  volatile   ("lfence": : : "memory");
#line 505
  return (ret);
}
}
#line 508 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void gru_abort(int ret , void *cb , char *str ) 
{ 
  char buf[256U] ;
  char *tmp ;

  {
  {
#line 512
  tmp = gru_get_cb_exception_detail_str(ret, cb, (char *)(& buf), 256);
#line 512
  panic("GRU FATAL ERROR: %s - %s\n", str, tmp);
  }
#line 514
  return;
}
}
#line 516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void gru_wait_abort_proc(void *cb ) 
{ 
  int ret ;

  {
  {
#line 520
  ret = gru_wait_proc(cb);
  }
#line 521
  if (ret != 0) {
    {
#line 522
    gru_abort(ret, cb, (char *)"gru_wait_abort");
    }
  } else {

  }
#line 523
  return;
}
}
#line 536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
__inline static int get_present2(void *p ) 
{ 
  struct message_header *mhdr ;

  {
#line 538
  mhdr = (struct message_header *)p + 64U;
#line 539
  return ((int )mhdr->present);
}
}
#line 542 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
__inline static void restore_present2(void *p , int val ) 
{ 
  struct message_header *mhdr ;

  {
#line 544
  mhdr = (struct message_header *)p + 64U;
#line 545
  mhdr->present = (char )val;
#line 546
  return;
}
}
#line 552 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_create_message_queue(struct gru_message_queue_desc *mqd , void *p , unsigned int bytes ,
                             int nasid , int vector , int apicid ) 
{ 
  struct message_queue *mq ;
  unsigned int qlines ;

  {
  {
#line 555
  mq = (struct message_queue *)p;
#line 558
  qlines = bytes / 64U - 2U;
#line 559
  __memset((void *)mq, 0, (size_t )bytes);
#line 560
  mq->start = (void *)(& mq->data);
#line 561
  mq->start2 = (void *)(& mq->data) + (unsigned long )((qlines / 2U + 67108863U) * 64U);
#line 562
  mq->next = (void *)(& mq->data);
#line 563
  mq->limit = (void *)(& mq->data) + (unsigned long )((qlines + 67108862U) * 64U);
#line 564
  mq->qlines = (int )qlines;
#line 565
  mq->hstatus[0] = 0L;
#line 566
  mq->hstatus[1] = 1L;
#line 567
  mq->head = gru_mesq_head(2, (int )(qlines / 2U + 1U));
#line 568
  mqd->mq = (void *)mq;
#line 569
  mqd->mq_gpa = uv_gpa((void *)mq);
#line 570
  mqd->qlines = (int )qlines;
#line 571
  mqd->interrupt_pnode = nasid >> 1;
#line 572
  mqd->interrupt_vector = vector;
#line 573
  mqd->interrupt_apicid = apicid;
  }
#line 574
  return (0);
}
}
#line 576 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_create_message_queue[25U]  = 
#line 576
  {      'g',      'r',      'u',      '_', 
        'c',      'r',      'e',      'a', 
        't',      'e',      '_',      'm', 
        'e',      's',      's',      'a', 
        'g',      'e',      '_',      'q', 
        'u',      'e',      'u',      'e', 
        '\000'};
#line 576
struct kernel_symbol  const  __ksymtab_gru_create_message_queue ;
#line 576 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_create_message_queue  =    {(unsigned long )(& gru_create_message_queue), (char const   *)(& __kstrtab_gru_create_message_queue)};
#line 586 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int send_noop_message(void *cb , struct gru_message_queue_desc *mqd , void *mesg ) 
{ 
  struct message_header noop_header ;
  unsigned long m ;
  int substatus ;
  int ret ;
  struct message_header save_mhdr ;
  struct message_header *mhdr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 589
  noop_header.present = 2;
#line 589
  noop_header.present2 = (char)0;
#line 589
  noop_header.lines = 1;
#line 589
  noop_header.fill = (char)0;
#line 593
  mhdr = (struct message_header *)mesg;
#line 595
  if ((gru_options & 2UL) != 0UL) {
    {
#line 595
    atomic_long_inc(& gru_stats.mesq_noop);
    }
  } else {

  }
  {
#line 596
  save_mhdr = *mhdr;
#line 597
  *mhdr = noop_header;
#line 598
  tmp = gru_get_tri((void *)mhdr);
#line 598
  gru_mesq(cb, mqd->mq_gpa, (unsigned long )tmp, 1UL, 1UL);
#line 599
  ret = gru_wait(cb);
  }
#line 601
  if (ret != 0) {
    {
#line 602
    substatus = gru_get_cb_message_queue_substatus(cb);
    }
    {
#line 604
    if (substatus == 0) {
#line 604
      goto case_0;
    } else {

    }
#line 608
    if (substatus == 1) {
#line 608
      goto case_1;
    } else {

    }
#line 612
    if (substatus == 2) {
#line 612
      goto case_2;
    } else {

    }
#line 616
    if (substatus == 4) {
#line 616
      goto case_4;
    } else {

    }
#line 620
    if (substatus == 5) {
#line 620
      goto case_5;
    } else {

    }
#line 630
    if (substatus == 3) {
#line 630
      goto case_3;
    } else {

    }
#line 633
    goto switch_default;
    case_0: /* CIL Label */ ;
#line 605
    if ((gru_options & 2UL) != 0UL) {
      {
#line 605
      atomic_long_inc(& gru_stats.mesq_noop_unexpected_error);
      }
    } else {

    }
#line 606
    ret = 3;
#line 607
    goto ldv_33892;
    case_1: /* CIL Label */ ;
#line 609
    if ((gru_options & 2UL) != 0UL) {
      {
#line 609
      atomic_long_inc(& gru_stats.mesq_noop_lb_overflow);
      }
    } else {

    }
#line 610
    ret = 1;
#line 611
    goto ldv_33892;
    case_2: /* CIL Label */ ;
#line 613
    if ((gru_options & 2UL) != 0UL) {
      {
#line 613
      atomic_long_inc(& gru_stats.mesq_noop_qlimit_reached);
      }
    } else {

    }
#line 614
    ret = 0;
#line 615
    goto ldv_33892;
    case_4: /* CIL Label */ ;
#line 617
    if ((gru_options & 2UL) != 0UL) {
      {
#line 617
      atomic_long_inc(& gru_stats.mesq_noop_amo_nacked);
      }
    } else {

    }
#line 618
    ret = 1;
#line 619
    goto ldv_33892;
    case_5: /* CIL Label */ ;
#line 621
    if ((gru_options & 2UL) != 0UL) {
      {
#line 621
      atomic_long_inc(& gru_stats.mesq_noop_put_nacked);
      }
    } else {

    }
    {
#line 622
    tmp___0 = gru_get_amo_value_head(cb);
#line 622
    m = mqd->mq_gpa + (unsigned long )(tmp___0 << 6);
#line 623
    tmp___1 = gru_get_tri(mesg);
#line 623
    gru_vstore(cb, m, (unsigned int )tmp___1, 6, 1UL, 1UL, 1UL);
#line 625
    tmp___2 = gru_wait(cb);
    }
#line 625
    if (tmp___2 == 0) {
#line 626
      ret = -1;
    } else {
#line 628
      ret = 3;
    }
#line 629
    goto ldv_33892;
    case_3: /* CIL Label */ ;
#line 631
    if ((gru_options & 2UL) != 0UL) {
      {
#line 631
      atomic_long_inc(& gru_stats.mesq_noop_page_overflow);
      }
    } else {

    }
    switch_default: /* CIL Label */ 
    {
#line 634
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grukservices.c"),
                         "i" (634), "i" (12UL));
#line 634
    __builtin_unreachable();
    }
    switch_break: /* CIL Label */ ;
    }
    ldv_33892: ;
  } else {

  }
#line 637
  *mhdr = save_mhdr;
#line 638
  return (ret);
}
}
#line 644 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int send_message_queue_full(void *cb , struct gru_message_queue_desc *mqd ,
                                   void *mesg , int lines ) 
{ 
  union gru_mesqhead mqh ;
  unsigned int limit ;
  unsigned int head ;
  unsigned long avalue ;
  int half ;
  int qlines ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;

  {
  {
#line 653
  avalue = gru_get_amo_value(cb);
#line 654
  tmp = gru_get_amo_value_head(cb);
#line 654
  head = (unsigned int )tmp;
#line 655
  tmp___0 = gru_get_amo_value_limit(cb);
#line 655
  limit = (unsigned int )tmp___0;
#line 657
  qlines = mqd->qlines;
#line 658
  half = limit != (unsigned int )qlines;
  }
#line 660
  if (half != 0) {
    {
#line 661
    mqh = gru_mesq_head(qlines / 2 + 1, qlines);
    }
  } else {
    {
#line 663
    mqh = gru_mesq_head(2, qlines / 2 + 1);
    }
  }
  {
#line 666
  gru_gamir(cb, 2, mqd->mq_gpa + ((unsigned long )half + 2UL) * 8UL, 3U, 1UL);
#line 667
  tmp___1 = gru_wait(cb);
  }
#line 667
  if (tmp___1 != 0) {
#line 668
    goto cberr;
  } else {

  }
  {
#line 669
  tmp___2 = gru_get_amo_value(cb);
  }
#line 669
  if (tmp___2 == 0UL) {
#line 670
    if ((gru_options & 2UL) != 0UL) {
      {
#line 670
      atomic_long_inc(& gru_stats.mesq_qf_locked);
      }
    } else {

    }
#line 671
    return (2);
  } else {

  }
#line 675
  if (head != limit) {
    {
#line 676
    tmp___4 = send_noop_message(cb, mqd, mesg);
    }
#line 676
    if (tmp___4 != 0) {
      {
#line 677
      gru_gamir(cb, 5, mqd->mq_gpa + ((unsigned long )half + 2UL) * 8UL, 3U, 1UL);
#line 679
      tmp___3 = gru_wait(cb);
      }
#line 679
      if (tmp___3 != 0) {
#line 680
        goto cberr;
      } else {

      }
#line 681
      if ((gru_options & 2UL) != 0UL) {
        {
#line 681
        atomic_long_inc(& gru_stats.mesq_qf_noop_not_full);
        }
      } else {

      }
#line 682
      return (-1);
    } else {

    }
#line 684
    avalue = avalue + 1UL;
  } else {

  }
  {
#line 688
  gru_gamer(cb, 8, mqd->mq_gpa, 3U, mqh.val, avalue, 1UL);
#line 690
  tmp___5 = gru_wait(cb);
  }
#line 690
  if (tmp___5 != 0) {
#line 691
    goto cberr;
  } else {

  }
  {
#line 694
  tmp___7 = gru_get_amo_value(cb);
  }
#line 694
  if (tmp___7 != avalue) {
#line 695
    if ((gru_options & 2UL) != 0UL) {
      {
#line 695
      atomic_long_inc(& gru_stats.mesq_qf_switch_head_failed);
      }
    } else {

    }
    {
#line 696
    gru_gamir(cb, 5, mqd->mq_gpa + ((unsigned long )half + 2UL) * 8UL, 3U, 1UL);
#line 698
    tmp___6 = gru_wait(cb);
    }
#line 698
    if (tmp___6 != 0) {
#line 699
      goto cberr;
    } else {

    }
  } else {

  }
#line 701
  return (-1);
  cberr: ;
#line 703
  if ((gru_options & 2UL) != 0UL) {
    {
#line 703
    atomic_long_inc(& gru_stats.mesq_qf_unexpected_error);
    }
  } else {

  }
#line 704
  return (3);
}
}
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int send_message_put_nacked(void *cb , struct gru_message_queue_desc *mqd ,
                                   void *mesg , int lines ) 
{ 
  unsigned long m ;
  unsigned long *val ;
  unsigned long gpa ;
  unsigned long save ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 716
  val = (unsigned long *)mesg;
#line 719
  tmp = gru_get_amo_value_head(cb);
#line 719
  m = mqd->mq_gpa + (unsigned long )(tmp << 6);
  }
#line 720
  if (lines == 2) {
    {
#line 721
    gru_vset(cb, m, 0UL, 6, (unsigned long )lines, 1UL, 1UL);
#line 722
    tmp___0 = gru_wait(cb);
    }
#line 722
    if (tmp___0 != 0) {
#line 723
      return (3);
    } else {

    }
  } else {

  }
  {
#line 725
  tmp___1 = gru_get_tri(mesg);
#line 725
  gru_vstore(cb, m, (unsigned int )tmp___1, 6, (unsigned long )lines, 1UL, 1UL);
#line 726
  tmp___2 = gru_wait(cb);
  }
#line 726
  if (tmp___2 != 0) {
#line 727
    return (3);
  } else {

  }
#line 729
  if (mqd->interrupt_vector == 0) {
#line 730
    return (0);
  } else {

  }
  {
#line 739
  gpa = uv_global_gru_mmr_address(mqd->interrupt_pnode, 394496UL);
#line 740
  save = *val;
#line 741
  *val = uv_hub_ipi_value(mqd->interrupt_apicid, mqd->interrupt_vector, 0);
#line 743
  tmp___3 = gru_get_tri(mesg);
#line 743
  gru_vstore_phys(cb, gpa, (unsigned int )tmp___3, 3, 1UL);
#line 744
  ret = gru_wait(cb);
#line 745
  *val = save;
  }
#line 746
  if (ret != 0) {
#line 747
    return (3);
  } else {

  }
#line 748
  return (0);
}
}
#line 755 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int send_message_failure(void *cb , struct gru_message_queue_desc *mqd , void *mesg ,
                                int lines ) 
{ 
  int substatus ;
  int ret ;

  {
  {
#line 758
  ret = 0;
#line 760
  substatus = gru_get_cb_message_queue_substatus(cb);
  }
  {
#line 762
  if (substatus == 0) {
#line 762
    goto case_0;
  } else {

  }
#line 766
  if (substatus == 1) {
#line 766
    goto case_1;
  } else {

  }
#line 770
  if (substatus == 2) {
#line 770
    goto case_2;
  } else {

  }
#line 774
  if (substatus == 4) {
#line 774
    goto case_4;
  } else {

  }
#line 778
  if (substatus == 5) {
#line 778
    goto case_5;
  } else {

  }
#line 782
  if (substatus == 3) {
#line 782
    goto case_3;
  } else {

  }
#line 785
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 763
  if ((gru_options & 2UL) != 0UL) {
    {
#line 763
    atomic_long_inc(& gru_stats.mesq_send_unexpected_error);
    }
  } else {

  }
#line 764
  ret = 3;
#line 765
  goto ldv_33932;
  case_1: /* CIL Label */ ;
#line 767
  if ((gru_options & 2UL) != 0UL) {
    {
#line 767
    atomic_long_inc(& gru_stats.mesq_send_lb_overflow);
    }
  } else {

  }
#line 768
  ret = 1;
#line 769
  goto ldv_33932;
  case_2: /* CIL Label */ ;
#line 771
  if ((gru_options & 2UL) != 0UL) {
    {
#line 771
    atomic_long_inc(& gru_stats.mesq_send_qlimit_reached);
    }
  } else {

  }
  {
#line 772
  ret = send_message_queue_full(cb, mqd, mesg, lines);
  }
#line 773
  goto ldv_33932;
  case_4: /* CIL Label */ ;
#line 775
  if ((gru_options & 2UL) != 0UL) {
    {
#line 775
    atomic_long_inc(& gru_stats.mesq_send_amo_nacked);
    }
  } else {

  }
#line 776
  ret = 1;
#line 777
  goto ldv_33932;
  case_5: /* CIL Label */ ;
#line 779
  if ((gru_options & 2UL) != 0UL) {
    {
#line 779
    atomic_long_inc(& gru_stats.mesq_send_put_nacked);
    }
  } else {

  }
  {
#line 780
  ret = send_message_put_nacked(cb, mqd, mesg, lines);
  }
#line 781
  goto ldv_33932;
  case_3: /* CIL Label */ ;
#line 783
  if ((gru_options & 2UL) != 0UL) {
    {
#line 783
    atomic_long_inc(& gru_stats.mesq_page_overflow);
    }
  } else {

  }
  switch_default: /* CIL Label */ 
  {
#line 786
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grukservices.c"),
                       "i" (786), "i" (12UL));
#line 786
  __builtin_unreachable();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_33932: ;
#line 788
  return (ret);
}
}
#line 797 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_send_message_gpa(struct gru_message_queue_desc *mqd , void *mesg , unsigned int bytes ) 
{ 
  struct message_header *mhdr ;
  void *cb ;
  void *dsr ;
  int istatus ;
  int clines ;
  int ret ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 805
  if ((gru_options & 2UL) != 0UL) {
    {
#line 805
    atomic_long_inc(& gru_stats.mesq_send);
    }
  } else {

  }
  {
#line 806
  tmp = __builtin_expect(bytes - 4U > 124U, 0L);
  }
#line 806
  if (tmp != 0L) {
    {
#line 806
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grukservices.c"),
                         "i" (806), "i" (12UL));
#line 806
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 808
  clines = (int )((bytes + 63U) / 64U);
#line 809
  tmp___0 = gru_get_cpu_resources((int )bytes, & cb, & dsr);
  }
#line 809
  if (tmp___0 != 0) {
#line 810
    return (11);
  } else {

  }
  {
#line 811
  __memcpy(dsr, (void const   *)mesg, (size_t )bytes);
#line 812
  mhdr = (struct message_header *)dsr;
#line 813
  mhdr->present = 1;
#line 814
  mhdr->lines = (char )clines;
  }
#line 815
  if (clines == 2) {
    {
#line 816
    tmp___1 = get_present2((void *)mhdr);
#line 816
    mhdr->present2 = (char )tmp___1;
#line 817
    restore_present2((void *)mhdr, 1);
    }
  } else {

  }
  ldv_33950: 
  {
#line 821
  ret = 0;
#line 822
  tmp___2 = gru_get_tri((void *)mhdr);
#line 822
  gru_mesq(cb, mqd->mq_gpa, (unsigned long )tmp___2, (unsigned long )clines, 1UL);
#line 823
  istatus = gru_wait(cb);
  }
#line 824
  if (istatus != 0) {
    {
#line 825
    ret = send_message_failure(cb, mqd, dsr, clines);
    }
  } else {

  }
#line 826
  if (ret == -1) {
#line 828
    goto ldv_33950;
  } else {

  }
  {
#line 827
  gru_free_cpu_resources(cb, dsr);
  }
#line 829
  if (ret != 0) {
#line 830
    if ((gru_options & 2UL) != 0UL) {
      {
#line 830
      atomic_long_inc(& gru_stats.mesq_send_failed);
      }
    } else {

    }
  } else {

  }
#line 831
  return (ret);
}
}
#line 833 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_send_message_gpa[21U]  = 
#line 833
  {      'g',      'r',      'u',      '_', 
        's',      'e',      'n',      'd', 
        '_',      'm',      'e',      's', 
        's',      'a',      'g',      'e', 
        '_',      'g',      'p',      'a', 
        '\000'};
#line 833
struct kernel_symbol  const  __ksymtab_gru_send_message_gpa ;
#line 833 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_send_message_gpa  =    {(unsigned long )(& gru_send_message_gpa), (char const   *)(& __kstrtab_gru_send_message_gpa)};
#line 838 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void gru_free_message(struct gru_message_queue_desc *mqd , void *mesg ) 
{ 
  struct message_queue *mq ;
  struct message_header *mhdr ;
  void *next ;
  void *pnext ;
  int half ;
  int lines ;

  {
#line 840
  mq = (struct message_queue *)mqd->mq;
#line 841
  mhdr = (struct message_header *)mq->next;
#line 843
  half = -1;
#line 844
  lines = (int )mhdr->lines;
#line 846
  if (lines == 2) {
    {
#line 847
    restore_present2((void *)mhdr, 0);
    }
  } else {

  }
#line 848
  mhdr->present = 0;
#line 850
  pnext = mq->next;
#line 851
  next = pnext + (unsigned long )(lines * 64);
#line 852
  if ((unsigned long )next == (unsigned long )mq->limit) {
#line 853
    next = mq->start;
#line 854
    half = 1;
  } else
#line 855
  if ((unsigned long )pnext < (unsigned long )mq->start2 && (unsigned long )next >= (unsigned long )mq->start2) {
#line 856
    half = 0;
  } else {

  }
#line 859
  if (half >= 0) {
#line 860
    mq->hstatus[half] = 1L;
  } else {

  }
#line 861
  mq->next = next;
#line 862
  return;
}
}
#line 863 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_free_message[17U]  = 
#line 863
  {      'g',      'r',      'u',      '_', 
        'f',      'r',      'e',      'e', 
        '_',      'm',      'e',      's', 
        's',      'a',      'g',      'e', 
        '\000'};
#line 863
struct kernel_symbol  const  __ksymtab_gru_free_message ;
#line 863 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_free_message  =    {(unsigned long )(& gru_free_message), (char const   *)(& __kstrtab_gru_free_message)};
#line 870 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void *gru_get_next_message(struct gru_message_queue_desc *mqd ) 
{ 
  struct message_queue *mq ;
  struct message_header *mhdr ;
  int present ;
  int tmp ;

  {
#line 872
  mq = (struct message_queue *)mqd->mq;
#line 873
  mhdr = (struct message_header *)mq->next;
#line 874
  present = (int )mhdr->present;
#line 877
  goto ldv_33986;
  ldv_33985: 
  {
#line 878
  gru_free_message(mqd, (void *)mhdr);
#line 879
  mhdr = (struct message_header *)mq->next;
#line 880
  present = (int )mhdr->present;
  }
  ldv_33986: ;
#line 877
  if (present == 2) {
#line 879
    goto ldv_33985;
  } else {

  }

#line 884
  if (present == 1 && (int )((signed char )mhdr->lines) == 2) {
    {
#line 884
    tmp = get_present2((void *)mhdr);
    }
#line 884
    if (tmp == 0) {
#line 886
      present = 0;
    } else {

    }
  } else {

  }
#line 888
  if (present == 0) {
#line 889
    if ((gru_options & 2UL) != 0UL) {
      {
#line 889
      atomic_long_inc(& gru_stats.mesq_receive_none);
      }
    } else {

    }
#line 890
    return ((void *)0);
  } else {

  }
#line 893
  if ((int )((signed char )mhdr->lines) == 2) {
    {
#line 894
    restore_present2((void *)mhdr, (int )mhdr->present2);
    }
  } else {

  }
#line 896
  if ((gru_options & 2UL) != 0UL) {
    {
#line 896
    atomic_long_inc(& gru_stats.mesq_receive);
    }
  } else {

  }
#line 897
  return ((void *)mhdr);
}
}
#line 899 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_get_next_message[21U]  = 
#line 899
  {      'g',      'r',      'u',      '_', 
        'g',      'e',      't',      '_', 
        'n',      'e',      'x',      't', 
        '_',      'm',      'e',      's', 
        's',      'a',      'g',      'e', 
        '\000'};
#line 899
struct kernel_symbol  const  __ksymtab_gru_get_next_message ;
#line 899 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_get_next_message  =    {(unsigned long )(& gru_get_next_message), (char const   *)(& __kstrtab_gru_get_next_message)};
#line 906 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_read_gpa(unsigned long *value , unsigned long gpa ) 
{ 
  void *cb ;
  void *dsr ;
  int ret ;
  int iaa ;
  int tmp ;
  int tmp___0 ;

  {
#line 912
  if ((gru_options & 2UL) != 0UL) {
    {
#line 912
    atomic_long_inc(& gru_stats.read_gpa);
    }
  } else {

  }
  {
#line 913
  tmp = gru_get_cpu_resources(256, & cb, & dsr);
  }
#line 913
  if (tmp != 0) {
#line 914
    return (11);
  } else {

  }
  {
#line 915
  iaa = (int )(gpa >> 62);
#line 916
  tmp___0 = gru_get_tri(dsr);
#line 916
  gru_vload_phys(cb, gpa, (unsigned int )tmp___0, iaa, 1UL);
#line 917
  ret = gru_wait(cb);
  }
#line 918
  if (ret == 0) {
#line 919
    *value = *((unsigned long *)dsr);
  } else {

  }
  {
#line 920
  gru_free_cpu_resources(cb, dsr);
  }
#line 921
  return (ret);
}
}
#line 923 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_read_gpa[13U]  = 
#line 923
  {      'g',      'r',      'u',      '_', 
        'r',      'e',      'a',      'd', 
        '_',      'g',      'p',      'a', 
        '\000'};
#line 923
struct kernel_symbol  const  __ksymtab_gru_read_gpa ;
#line 923 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_read_gpa  =    {(unsigned long )(& gru_read_gpa), (char const   *)(& __kstrtab_gru_read_gpa)};
#line 929 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_copy_gpa(unsigned long dest_gpa , unsigned long src_gpa , unsigned int bytes ) 
{ 
  void *cb ;
  void *dsr ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 936
  if ((gru_options & 2UL) != 0UL) {
    {
#line 936
    atomic_long_inc(& gru_stats.copy_gpa);
    }
  } else {

  }
  {
#line 937
  tmp = gru_get_cpu_resources(256, & cb, & dsr);
  }
#line 937
  if (tmp != 0) {
#line 938
    return (11);
  } else {

  }
  {
#line 939
  tmp___0 = gru_get_tri(dsr);
#line 939
  gru_bcopy(cb, src_gpa, dest_gpa, (unsigned int )tmp___0, 0U, (unsigned long )bytes,
            4U, 1UL);
#line 941
  ret = gru_wait(cb);
#line 942
  gru_free_cpu_resources(cb, dsr);
  }
#line 943
  return (ret);
}
}
#line 945 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static char const   __kstrtab_gru_copy_gpa[13U]  = 
#line 945
  {      'g',      'r',      'u',      '_', 
        'c',      'o',      'p',      'y', 
        '_',      'g',      'p',      'a', 
        '\000'};
#line 945
struct kernel_symbol  const  __ksymtab_gru_copy_gpa ;
#line 945 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
struct kernel_symbol  const  __ksymtab_gru_copy_gpa  =    {(unsigned long )(& gru_copy_gpa), (char const   *)(& __kstrtab_gru_copy_gpa)};
#line 950 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int quicktest0(unsigned long arg ) 
{ 
  unsigned long word0 ;
  unsigned long word1 ;
  void *cb ;
  void *dsr ;
  unsigned long *p ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  int pscr_ret_____1 ;
  void const   *__vpp_verify___1 ;
  int pfo_ret_____7 ;
  int pfo_ret_____8 ;
  int pfo_ret_____9 ;
  int pfo_ret_____10 ;
  int tmp___5 ;
  int pscr_ret_____2 ;
  void const   *__vpp_verify___2 ;
  int pfo_ret_____11 ;
  int pfo_ret_____12 ;
  int pfo_ret_____13 ;
  int pfo_ret_____14 ;

  {
  {
#line 957
  ret = -5;
#line 959
  tmp = gru_get_cpu_resources(64, & cb, & dsr);
  }
#line 959
  if (tmp != 0) {
#line 960
    return (11);
  } else {

  }
  {
#line 961
  p = (unsigned long *)dsr;
#line 962
  word0 = 1311768467139281697UL;
#line 963
  word1 = 0UL;
#line 965
  tmp___0 = gru_get_tri(dsr);
#line 965
  tmp___1 = uv_gpa((void *)(& word0));
#line 965
  gru_vload(cb, tmp___1, (unsigned int )tmp___0, 3, 1UL, 1UL, 1UL);
#line 966
  tmp___2 = gru_wait(cb);
  }
#line 966
  if (tmp___2 != 0) {
#line 967
    __vpp_verify = (void const   *)0;
    {
#line 967
    if (4UL == 1UL) {
#line 967
      goto case_1;
    } else {

    }
#line 967
    if (4UL == 2UL) {
#line 967
      goto case_2___0;
    } else {

    }
#line 967
    if (4UL == 4UL) {
#line 967
      goto case_4___1;
    } else {

    }
#line 967
    if (4UL == 8UL) {
#line 967
      goto case_8___2;
    } else {

    }
#line 967
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 967
    if (4UL == 1UL) {
#line 967
      goto case_1___0;
    } else {

    }
#line 967
    if (4UL == 2UL) {
#line 967
      goto case_2;
    } else {

    }
#line 967
    if (4UL == 4UL) {
#line 967
      goto case_4;
    } else {

    }
#line 967
    if (4UL == 8UL) {
#line 967
      goto case_8;
    } else {

    }
#line 967
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 967
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 967
    goto ldv_34042;
    case_2: /* CIL Label */ 
#line 967
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 967
    goto ldv_34042;
    case_4: /* CIL Label */ 
#line 967
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 967
    goto ldv_34042;
    case_8: /* CIL Label */ 
#line 967
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 967
    goto ldv_34042;
    switch_default: /* CIL Label */ 
    {
#line 967
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34042: 
#line 967
    pscr_ret__ = pfo_ret__;
#line 967
    goto ldv_34048;
    case_2___0: /* CIL Label */ ;
    {
#line 967
    if (4UL == 1UL) {
#line 967
      goto case_1___1;
    } else {

    }
#line 967
    if (4UL == 2UL) {
#line 967
      goto case_2___1;
    } else {

    }
#line 967
    if (4UL == 4UL) {
#line 967
      goto case_4___0;
    } else {

    }
#line 967
    if (4UL == 8UL) {
#line 967
      goto case_8___0;
    } else {

    }
#line 967
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 967
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 967
    goto ldv_34052;
    case_2___1: /* CIL Label */ 
#line 967
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 967
    goto ldv_34052;
    case_4___0: /* CIL Label */ 
#line 967
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 967
    goto ldv_34052;
    case_8___0: /* CIL Label */ 
#line 967
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 967
    goto ldv_34052;
    switch_default___0: /* CIL Label */ 
    {
#line 967
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34052: 
#line 967
    pscr_ret__ = pfo_ret_____0;
#line 967
    goto ldv_34048;
    case_4___1: /* CIL Label */ ;
    {
#line 967
    if (4UL == 1UL) {
#line 967
      goto case_1___2;
    } else {

    }
#line 967
    if (4UL == 2UL) {
#line 967
      goto case_2___2;
    } else {

    }
#line 967
    if (4UL == 4UL) {
#line 967
      goto case_4___2;
    } else {

    }
#line 967
    if (4UL == 8UL) {
#line 967
      goto case_8___1;
    } else {

    }
#line 967
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 967
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 967
    goto ldv_34061;
    case_2___2: /* CIL Label */ 
#line 967
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 967
    goto ldv_34061;
    case_4___2: /* CIL Label */ 
#line 967
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 967
    goto ldv_34061;
    case_8___1: /* CIL Label */ 
#line 967
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 967
    goto ldv_34061;
    switch_default___1: /* CIL Label */ 
    {
#line 967
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34061: 
#line 967
    pscr_ret__ = pfo_ret_____1;
#line 967
    goto ldv_34048;
    case_8___2: /* CIL Label */ ;
    {
#line 967
    if (4UL == 1UL) {
#line 967
      goto case_1___3;
    } else {

    }
#line 967
    if (4UL == 2UL) {
#line 967
      goto case_2___3;
    } else {

    }
#line 967
    if (4UL == 4UL) {
#line 967
      goto case_4___3;
    } else {

    }
#line 967
    if (4UL == 8UL) {
#line 967
      goto case_8___3;
    } else {

    }
#line 967
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 967
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 967
    goto ldv_34070;
    case_2___3: /* CIL Label */ 
#line 967
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 967
    goto ldv_34070;
    case_4___3: /* CIL Label */ 
#line 967
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 967
    goto ldv_34070;
    case_8___3: /* CIL Label */ 
#line 967
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 967
    goto ldv_34070;
    switch_default___2: /* CIL Label */ 
    {
#line 967
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34070: 
#line 967
    pscr_ret__ = pfo_ret_____2;
#line 967
    goto ldv_34048;
    switch_default___3: /* CIL Label */ 
    {
#line 967
    __bad_size_call_parameter();
    }
#line 967
    goto ldv_34048;
    switch_break: /* CIL Label */ ;
    }
    ldv_34048: 
    {
#line 967
    printk("\017GRU:%d quicktest0: CBR failure 1\n", pscr_ret__);
    }
#line 968
    goto done;
  } else {

  }
#line 971
  if (*p != 1311768467139281697UL) {
#line 972
    __vpp_verify___0 = (void const   *)0;
    {
#line 972
    if (4UL == 1UL) {
#line 972
      goto case_1___4;
    } else {

    }
#line 972
    if (4UL == 2UL) {
#line 972
      goto case_2___5;
    } else {

    }
#line 972
    if (4UL == 4UL) {
#line 972
      goto case_4___6;
    } else {

    }
#line 972
    if (4UL == 8UL) {
#line 972
      goto case_8___7;
    } else {

    }
#line 972
    goto switch_default___8;
    case_1___4: /* CIL Label */ ;
    {
#line 972
    if (4UL == 1UL) {
#line 972
      goto case_1___5;
    } else {

    }
#line 972
    if (4UL == 2UL) {
#line 972
      goto case_2___4;
    } else {

    }
#line 972
    if (4UL == 4UL) {
#line 972
      goto case_4___4;
    } else {

    }
#line 972
    if (4UL == 8UL) {
#line 972
      goto case_8___4;
    } else {

    }
#line 972
    goto switch_default___4;
    case_1___5: /* CIL Label */ 
#line 972
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 972
    goto ldv_34084;
    case_2___4: /* CIL Label */ 
#line 972
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 972
    goto ldv_34084;
    case_4___4: /* CIL Label */ 
#line 972
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 972
    goto ldv_34084;
    case_8___4: /* CIL Label */ 
#line 972
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 972
    goto ldv_34084;
    switch_default___4: /* CIL Label */ 
    {
#line 972
    __bad_percpu_size();
    }
    switch_break___5: /* CIL Label */ ;
    }
    ldv_34084: 
#line 972
    pscr_ret_____0 = pfo_ret_____3;
#line 972
    goto ldv_34090;
    case_2___5: /* CIL Label */ ;
    {
#line 972
    if (4UL == 1UL) {
#line 972
      goto case_1___6;
    } else {

    }
#line 972
    if (4UL == 2UL) {
#line 972
      goto case_2___6;
    } else {

    }
#line 972
    if (4UL == 4UL) {
#line 972
      goto case_4___5;
    } else {

    }
#line 972
    if (4UL == 8UL) {
#line 972
      goto case_8___5;
    } else {

    }
#line 972
    goto switch_default___5;
    case_1___6: /* CIL Label */ 
#line 972
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 972
    goto ldv_34094;
    case_2___6: /* CIL Label */ 
#line 972
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 972
    goto ldv_34094;
    case_4___5: /* CIL Label */ 
#line 972
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 972
    goto ldv_34094;
    case_8___5: /* CIL Label */ 
#line 972
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 972
    goto ldv_34094;
    switch_default___5: /* CIL Label */ 
    {
#line 972
    __bad_percpu_size();
    }
    switch_break___6: /* CIL Label */ ;
    }
    ldv_34094: 
#line 972
    pscr_ret_____0 = pfo_ret_____4;
#line 972
    goto ldv_34090;
    case_4___6: /* CIL Label */ ;
    {
#line 972
    if (4UL == 1UL) {
#line 972
      goto case_1___7;
    } else {

    }
#line 972
    if (4UL == 2UL) {
#line 972
      goto case_2___7;
    } else {

    }
#line 972
    if (4UL == 4UL) {
#line 972
      goto case_4___7;
    } else {

    }
#line 972
    if (4UL == 8UL) {
#line 972
      goto case_8___6;
    } else {

    }
#line 972
    goto switch_default___6;
    case_1___7: /* CIL Label */ 
#line 972
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 972
    goto ldv_34103;
    case_2___7: /* CIL Label */ 
#line 972
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 972
    goto ldv_34103;
    case_4___7: /* CIL Label */ 
#line 972
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 972
    goto ldv_34103;
    case_8___6: /* CIL Label */ 
#line 972
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 972
    goto ldv_34103;
    switch_default___6: /* CIL Label */ 
    {
#line 972
    __bad_percpu_size();
    }
    switch_break___7: /* CIL Label */ ;
    }
    ldv_34103: 
#line 972
    pscr_ret_____0 = pfo_ret_____5;
#line 972
    goto ldv_34090;
    case_8___7: /* CIL Label */ ;
    {
#line 972
    if (4UL == 1UL) {
#line 972
      goto case_1___8;
    } else {

    }
#line 972
    if (4UL == 2UL) {
#line 972
      goto case_2___8;
    } else {

    }
#line 972
    if (4UL == 4UL) {
#line 972
      goto case_4___8;
    } else {

    }
#line 972
    if (4UL == 8UL) {
#line 972
      goto case_8___8;
    } else {

    }
#line 972
    goto switch_default___7;
    case_1___8: /* CIL Label */ 
#line 972
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 972
    goto ldv_34112;
    case_2___8: /* CIL Label */ 
#line 972
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 972
    goto ldv_34112;
    case_4___8: /* CIL Label */ 
#line 972
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 972
    goto ldv_34112;
    case_8___8: /* CIL Label */ 
#line 972
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 972
    goto ldv_34112;
    switch_default___7: /* CIL Label */ 
    {
#line 972
    __bad_percpu_size();
    }
    switch_break___8: /* CIL Label */ ;
    }
    ldv_34112: 
#line 972
    pscr_ret_____0 = pfo_ret_____6;
#line 972
    goto ldv_34090;
    switch_default___8: /* CIL Label */ 
    {
#line 972
    __bad_size_call_parameter();
    }
#line 972
    goto ldv_34090;
    switch_break___4: /* CIL Label */ ;
    }
    ldv_34090: 
    {
#line 972
    printk("\017GRU:%d quicktest0 bad magic 0x%lx\n", pscr_ret_____0, *p);
    }
#line 973
    goto done;
  } else {

  }
  {
#line 975
  tmp___3 = gru_get_tri(dsr);
#line 975
  tmp___4 = uv_gpa((void *)(& word1));
#line 975
  gru_vstore(cb, tmp___4, (unsigned int )tmp___3, 3, 1UL, 1UL, 1UL);
#line 976
  tmp___5 = gru_wait(cb);
  }
#line 976
  if (tmp___5 != 0) {
#line 977
    __vpp_verify___1 = (void const   *)0;
    {
#line 977
    if (4UL == 1UL) {
#line 977
      goto case_1___9;
    } else {

    }
#line 977
    if (4UL == 2UL) {
#line 977
      goto case_2___10;
    } else {

    }
#line 977
    if (4UL == 4UL) {
#line 977
      goto case_4___11;
    } else {

    }
#line 977
    if (4UL == 8UL) {
#line 977
      goto case_8___12;
    } else {

    }
#line 977
    goto switch_default___13;
    case_1___9: /* CIL Label */ ;
    {
#line 977
    if (4UL == 1UL) {
#line 977
      goto case_1___10;
    } else {

    }
#line 977
    if (4UL == 2UL) {
#line 977
      goto case_2___9;
    } else {

    }
#line 977
    if (4UL == 4UL) {
#line 977
      goto case_4___9;
    } else {

    }
#line 977
    if (4UL == 8UL) {
#line 977
      goto case_8___9;
    } else {

    }
#line 977
    goto switch_default___9;
    case_1___10: /* CIL Label */ 
#line 977
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____7): "m" (cpu_number));
#line 977
    goto ldv_34125;
    case_2___9: /* CIL Label */ 
#line 977
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 977
    goto ldv_34125;
    case_4___9: /* CIL Label */ 
#line 977
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 977
    goto ldv_34125;
    case_8___9: /* CIL Label */ 
#line 977
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____7): "m" (cpu_number));
#line 977
    goto ldv_34125;
    switch_default___9: /* CIL Label */ 
    {
#line 977
    __bad_percpu_size();
    }
    switch_break___10: /* CIL Label */ ;
    }
    ldv_34125: 
#line 977
    pscr_ret_____1 = pfo_ret_____7;
#line 977
    goto ldv_34131;
    case_2___10: /* CIL Label */ ;
    {
#line 977
    if (4UL == 1UL) {
#line 977
      goto case_1___11;
    } else {

    }
#line 977
    if (4UL == 2UL) {
#line 977
      goto case_2___11;
    } else {

    }
#line 977
    if (4UL == 4UL) {
#line 977
      goto case_4___10;
    } else {

    }
#line 977
    if (4UL == 8UL) {
#line 977
      goto case_8___10;
    } else {

    }
#line 977
    goto switch_default___10;
    case_1___11: /* CIL Label */ 
#line 977
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____8): "m" (cpu_number));
#line 977
    goto ldv_34135;
    case_2___11: /* CIL Label */ 
#line 977
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 977
    goto ldv_34135;
    case_4___10: /* CIL Label */ 
#line 977
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 977
    goto ldv_34135;
    case_8___10: /* CIL Label */ 
#line 977
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____8): "m" (cpu_number));
#line 977
    goto ldv_34135;
    switch_default___10: /* CIL Label */ 
    {
#line 977
    __bad_percpu_size();
    }
    switch_break___11: /* CIL Label */ ;
    }
    ldv_34135: 
#line 977
    pscr_ret_____1 = pfo_ret_____8;
#line 977
    goto ldv_34131;
    case_4___11: /* CIL Label */ ;
    {
#line 977
    if (4UL == 1UL) {
#line 977
      goto case_1___12;
    } else {

    }
#line 977
    if (4UL == 2UL) {
#line 977
      goto case_2___12;
    } else {

    }
#line 977
    if (4UL == 4UL) {
#line 977
      goto case_4___12;
    } else {

    }
#line 977
    if (4UL == 8UL) {
#line 977
      goto case_8___11;
    } else {

    }
#line 977
    goto switch_default___11;
    case_1___12: /* CIL Label */ 
#line 977
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____9): "m" (cpu_number));
#line 977
    goto ldv_34144;
    case_2___12: /* CIL Label */ 
#line 977
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 977
    goto ldv_34144;
    case_4___12: /* CIL Label */ 
#line 977
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 977
    goto ldv_34144;
    case_8___11: /* CIL Label */ 
#line 977
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____9): "m" (cpu_number));
#line 977
    goto ldv_34144;
    switch_default___11: /* CIL Label */ 
    {
#line 977
    __bad_percpu_size();
    }
    switch_break___12: /* CIL Label */ ;
    }
    ldv_34144: 
#line 977
    pscr_ret_____1 = pfo_ret_____9;
#line 977
    goto ldv_34131;
    case_8___12: /* CIL Label */ ;
    {
#line 977
    if (4UL == 1UL) {
#line 977
      goto case_1___13;
    } else {

    }
#line 977
    if (4UL == 2UL) {
#line 977
      goto case_2___13;
    } else {

    }
#line 977
    if (4UL == 4UL) {
#line 977
      goto case_4___13;
    } else {

    }
#line 977
    if (4UL == 8UL) {
#line 977
      goto case_8___13;
    } else {

    }
#line 977
    goto switch_default___12;
    case_1___13: /* CIL Label */ 
#line 977
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____10): "m" (cpu_number));
#line 977
    goto ldv_34153;
    case_2___13: /* CIL Label */ 
#line 977
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 977
    goto ldv_34153;
    case_4___13: /* CIL Label */ 
#line 977
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 977
    goto ldv_34153;
    case_8___13: /* CIL Label */ 
#line 977
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____10): "m" (cpu_number));
#line 977
    goto ldv_34153;
    switch_default___12: /* CIL Label */ 
    {
#line 977
    __bad_percpu_size();
    }
    switch_break___13: /* CIL Label */ ;
    }
    ldv_34153: 
#line 977
    pscr_ret_____1 = pfo_ret_____10;
#line 977
    goto ldv_34131;
    switch_default___13: /* CIL Label */ 
    {
#line 977
    __bad_size_call_parameter();
    }
#line 977
    goto ldv_34131;
    switch_break___9: /* CIL Label */ ;
    }
    ldv_34131: 
    {
#line 977
    printk("\017GRU:%d quicktest0: CBR failure 2\n", pscr_ret_____1);
    }
#line 978
    goto done;
  } else {

  }
#line 981
  if (word0 != word1 || word1 != 1311768467139281697UL) {
#line 984
    __vpp_verify___2 = (void const   *)0;
    {
#line 984
    if (4UL == 1UL) {
#line 984
      goto case_1___14;
    } else {

    }
#line 984
    if (4UL == 2UL) {
#line 984
      goto case_2___15;
    } else {

    }
#line 984
    if (4UL == 4UL) {
#line 984
      goto case_4___16;
    } else {

    }
#line 984
    if (4UL == 8UL) {
#line 984
      goto case_8___17;
    } else {

    }
#line 984
    goto switch_default___18;
    case_1___14: /* CIL Label */ ;
    {
#line 984
    if (4UL == 1UL) {
#line 984
      goto case_1___15;
    } else {

    }
#line 984
    if (4UL == 2UL) {
#line 984
      goto case_2___14;
    } else {

    }
#line 984
    if (4UL == 4UL) {
#line 984
      goto case_4___14;
    } else {

    }
#line 984
    if (4UL == 8UL) {
#line 984
      goto case_8___14;
    } else {

    }
#line 984
    goto switch_default___14;
    case_1___15: /* CIL Label */ 
#line 984
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____11): "m" (cpu_number));
#line 984
    goto ldv_34166;
    case_2___14: /* CIL Label */ 
#line 984
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 984
    goto ldv_34166;
    case_4___14: /* CIL Label */ 
#line 984
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 984
    goto ldv_34166;
    case_8___14: /* CIL Label */ 
#line 984
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____11): "m" (cpu_number));
#line 984
    goto ldv_34166;
    switch_default___14: /* CIL Label */ 
    {
#line 984
    __bad_percpu_size();
    }
    switch_break___15: /* CIL Label */ ;
    }
    ldv_34166: 
#line 984
    pscr_ret_____2 = pfo_ret_____11;
#line 984
    goto ldv_34172;
    case_2___15: /* CIL Label */ ;
    {
#line 984
    if (4UL == 1UL) {
#line 984
      goto case_1___16;
    } else {

    }
#line 984
    if (4UL == 2UL) {
#line 984
      goto case_2___16;
    } else {

    }
#line 984
    if (4UL == 4UL) {
#line 984
      goto case_4___15;
    } else {

    }
#line 984
    if (4UL == 8UL) {
#line 984
      goto case_8___15;
    } else {

    }
#line 984
    goto switch_default___15;
    case_1___16: /* CIL Label */ 
#line 984
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____12): "m" (cpu_number));
#line 984
    goto ldv_34176;
    case_2___16: /* CIL Label */ 
#line 984
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 984
    goto ldv_34176;
    case_4___15: /* CIL Label */ 
#line 984
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 984
    goto ldv_34176;
    case_8___15: /* CIL Label */ 
#line 984
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____12): "m" (cpu_number));
#line 984
    goto ldv_34176;
    switch_default___15: /* CIL Label */ 
    {
#line 984
    __bad_percpu_size();
    }
    switch_break___16: /* CIL Label */ ;
    }
    ldv_34176: 
#line 984
    pscr_ret_____2 = pfo_ret_____12;
#line 984
    goto ldv_34172;
    case_4___16: /* CIL Label */ ;
    {
#line 984
    if (4UL == 1UL) {
#line 984
      goto case_1___17;
    } else {

    }
#line 984
    if (4UL == 2UL) {
#line 984
      goto case_2___17;
    } else {

    }
#line 984
    if (4UL == 4UL) {
#line 984
      goto case_4___17;
    } else {

    }
#line 984
    if (4UL == 8UL) {
#line 984
      goto case_8___16;
    } else {

    }
#line 984
    goto switch_default___16;
    case_1___17: /* CIL Label */ 
#line 984
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____13): "m" (cpu_number));
#line 984
    goto ldv_34185;
    case_2___17: /* CIL Label */ 
#line 984
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 984
    goto ldv_34185;
    case_4___17: /* CIL Label */ 
#line 984
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 984
    goto ldv_34185;
    case_8___16: /* CIL Label */ 
#line 984
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____13): "m" (cpu_number));
#line 984
    goto ldv_34185;
    switch_default___16: /* CIL Label */ 
    {
#line 984
    __bad_percpu_size();
    }
    switch_break___17: /* CIL Label */ ;
    }
    ldv_34185: 
#line 984
    pscr_ret_____2 = pfo_ret_____13;
#line 984
    goto ldv_34172;
    case_8___17: /* CIL Label */ ;
    {
#line 984
    if (4UL == 1UL) {
#line 984
      goto case_1___18;
    } else {

    }
#line 984
    if (4UL == 2UL) {
#line 984
      goto case_2___18;
    } else {

    }
#line 984
    if (4UL == 4UL) {
#line 984
      goto case_4___18;
    } else {

    }
#line 984
    if (4UL == 8UL) {
#line 984
      goto case_8___18;
    } else {

    }
#line 984
    goto switch_default___17;
    case_1___18: /* CIL Label */ 
#line 984
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____14): "m" (cpu_number));
#line 984
    goto ldv_34194;
    case_2___18: /* CIL Label */ 
#line 984
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 984
    goto ldv_34194;
    case_4___18: /* CIL Label */ 
#line 984
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 984
    goto ldv_34194;
    case_8___18: /* CIL Label */ 
#line 984
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____14): "m" (cpu_number));
#line 984
    goto ldv_34194;
    switch_default___17: /* CIL Label */ 
    {
#line 984
    __bad_percpu_size();
    }
    switch_break___18: /* CIL Label */ ;
    }
    ldv_34194: 
#line 984
    pscr_ret_____2 = pfo_ret_____14;
#line 984
    goto ldv_34172;
    switch_default___18: /* CIL Label */ 
    {
#line 984
    __bad_size_call_parameter();
    }
#line 984
    goto ldv_34172;
    switch_break___14: /* CIL Label */ ;
    }
    ldv_34172: 
    {
#line 984
    printk("\017GRU:%d quicktest0 err: found 0x%lx, expected 0x%lx\n", pscr_ret_____2,
           word1, 1311768467139281697UL);
    }
#line 985
    goto done;
  } else {

  }
#line 987
  ret = 0;
  done: 
  {
#line 990
  gru_free_cpu_resources(cb, dsr);
  }
#line 991
  return (ret);
}
}
#line 996 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int quicktest1(unsigned long arg ) 
{ 
  struct gru_message_queue_desc mqd ;
  void *p ;
  void *mq ;
  unsigned long *dw ;
  int i ;
  int ret ;
  char mes[64U] ;
  char *m ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  void *tmp ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;

  {
  {
#line 1001
  ret = -5;
#line 1005
  p = kmalloc(4096UL, 0U);
  }
#line 1006
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1007
    return (-12);
  } else {

  }
  {
#line 1008
  mq = (void *)(((unsigned long )p + 1023UL) & 0xfffffffffffffc00UL);
#line 1009
  __memset((void *)(& mes), 238, 64UL);
#line 1010
  dw = (unsigned long *)mq;
#line 1012
  gru_create_message_queue(& mqd, mq, 512U, 0, 0, 0);
#line 1013
  i = 0;
  }
#line 1013
  goto ldv_34217;
  ldv_34216: 
#line 1014
  mes[8] = (char )i;
  ldv_34213: 
  {
#line 1016
  ret = gru_send_message_gpa(& mqd, (void *)(& mes), 64U);
  }
#line 1017
  if (ret == 1) {
#line 1019
    goto ldv_34213;
  } else {

  }

#line 1018
  if (ret != 0) {
#line 1019
    goto ldv_34215;
  } else {

  }
#line 1013
  i = i + 1;
  ldv_34217: ;
#line 1013
  if (i <= 5) {
#line 1015
    goto ldv_34216;
  } else {

  }
  ldv_34215: ;
#line 1021
  if (ret != 2 || i != 4) {
#line 1023
    __vpp_verify = (void const   *)0;
    {
#line 1023
    if (4UL == 1UL) {
#line 1023
      goto case_1;
    } else {

    }
#line 1023
    if (4UL == 2UL) {
#line 1023
      goto case_2___0;
    } else {

    }
#line 1023
    if (4UL == 4UL) {
#line 1023
      goto case_4___1;
    } else {

    }
#line 1023
    if (4UL == 8UL) {
#line 1023
      goto case_8___2;
    } else {

    }
#line 1023
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 1023
    if (4UL == 1UL) {
#line 1023
      goto case_1___0;
    } else {

    }
#line 1023
    if (4UL == 2UL) {
#line 1023
      goto case_2;
    } else {

    }
#line 1023
    if (4UL == 4UL) {
#line 1023
      goto case_4;
    } else {

    }
#line 1023
    if (4UL == 8UL) {
#line 1023
      goto case_8;
    } else {

    }
#line 1023
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 1023
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1023
    goto ldv_34223;
    case_2: /* CIL Label */ 
#line 1023
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1023
    goto ldv_34223;
    case_4: /* CIL Label */ 
#line 1023
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1023
    goto ldv_34223;
    case_8: /* CIL Label */ 
#line 1023
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1023
    goto ldv_34223;
    switch_default: /* CIL Label */ 
    {
#line 1023
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34223: 
#line 1023
    pscr_ret__ = pfo_ret__;
#line 1023
    goto ldv_34229;
    case_2___0: /* CIL Label */ ;
    {
#line 1023
    if (4UL == 1UL) {
#line 1023
      goto case_1___1;
    } else {

    }
#line 1023
    if (4UL == 2UL) {
#line 1023
      goto case_2___1;
    } else {

    }
#line 1023
    if (4UL == 4UL) {
#line 1023
      goto case_4___0;
    } else {

    }
#line 1023
    if (4UL == 8UL) {
#line 1023
      goto case_8___0;
    } else {

    }
#line 1023
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 1023
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1023
    goto ldv_34233;
    case_2___1: /* CIL Label */ 
#line 1023
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1023
    goto ldv_34233;
    case_4___0: /* CIL Label */ 
#line 1023
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1023
    goto ldv_34233;
    case_8___0: /* CIL Label */ 
#line 1023
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1023
    goto ldv_34233;
    switch_default___0: /* CIL Label */ 
    {
#line 1023
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34233: 
#line 1023
    pscr_ret__ = pfo_ret_____0;
#line 1023
    goto ldv_34229;
    case_4___1: /* CIL Label */ ;
    {
#line 1023
    if (4UL == 1UL) {
#line 1023
      goto case_1___2;
    } else {

    }
#line 1023
    if (4UL == 2UL) {
#line 1023
      goto case_2___2;
    } else {

    }
#line 1023
    if (4UL == 4UL) {
#line 1023
      goto case_4___2;
    } else {

    }
#line 1023
    if (4UL == 8UL) {
#line 1023
      goto case_8___1;
    } else {

    }
#line 1023
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 1023
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1023
    goto ldv_34242;
    case_2___2: /* CIL Label */ 
#line 1023
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1023
    goto ldv_34242;
    case_4___2: /* CIL Label */ 
#line 1023
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1023
    goto ldv_34242;
    case_8___1: /* CIL Label */ 
#line 1023
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1023
    goto ldv_34242;
    switch_default___1: /* CIL Label */ 
    {
#line 1023
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34242: 
#line 1023
    pscr_ret__ = pfo_ret_____1;
#line 1023
    goto ldv_34229;
    case_8___2: /* CIL Label */ ;
    {
#line 1023
    if (4UL == 1UL) {
#line 1023
      goto case_1___3;
    } else {

    }
#line 1023
    if (4UL == 2UL) {
#line 1023
      goto case_2___3;
    } else {

    }
#line 1023
    if (4UL == 4UL) {
#line 1023
      goto case_4___3;
    } else {

    }
#line 1023
    if (4UL == 8UL) {
#line 1023
      goto case_8___3;
    } else {

    }
#line 1023
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 1023
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1023
    goto ldv_34251;
    case_2___3: /* CIL Label */ 
#line 1023
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1023
    goto ldv_34251;
    case_4___3: /* CIL Label */ 
#line 1023
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1023
    goto ldv_34251;
    case_8___3: /* CIL Label */ 
#line 1023
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1023
    goto ldv_34251;
    switch_default___2: /* CIL Label */ 
    {
#line 1023
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34251: 
#line 1023
    pscr_ret__ = pfo_ret_____2;
#line 1023
    goto ldv_34229;
    switch_default___3: /* CIL Label */ 
    {
#line 1023
    __bad_size_call_parameter();
    }
#line 1023
    goto ldv_34229;
    switch_break: /* CIL Label */ ;
    }
    ldv_34229: 
    {
#line 1023
    printk("\017GRU:%d quicktest1: unexpect status %d, i %d\n", pscr_ret__, ret, i);
    }
#line 1024
    goto done;
  } else {

  }
#line 1027
  i = 0;
#line 1027
  goto ldv_34262;
  ldv_34261: 
  {
#line 1028
  tmp = gru_get_next_message(& mqd);
#line 1028
  m = (char *)tmp;
  }
#line 1029
  if ((unsigned long )m == (unsigned long )((char *)0) || (int )*(m + 8UL) != i) {
#line 1030
    goto ldv_34260;
  } else {

  }
  {
#line 1031
  gru_free_message(& mqd, (void *)m);
#line 1027
  i = i + 1;
  }
  ldv_34262: ;
#line 1027
  if (i <= 5) {
#line 1029
    goto ldv_34261;
  } else {

  }
  ldv_34260: ;
#line 1033
  if (i != 4) {
#line 1035
    __vpp_verify___0 = (void const   *)0;
    {
#line 1035
    if (4UL == 1UL) {
#line 1035
      goto case_1___4;
    } else {

    }
#line 1035
    if (4UL == 2UL) {
#line 1035
      goto case_2___5;
    } else {

    }
#line 1035
    if (4UL == 4UL) {
#line 1035
      goto case_4___6;
    } else {

    }
#line 1035
    if (4UL == 8UL) {
#line 1035
      goto case_8___7;
    } else {

    }
#line 1035
    goto switch_default___8;
    case_1___4: /* CIL Label */ ;
    {
#line 1035
    if (4UL == 1UL) {
#line 1035
      goto case_1___5;
    } else {

    }
#line 1035
    if (4UL == 2UL) {
#line 1035
      goto case_2___4;
    } else {

    }
#line 1035
    if (4UL == 4UL) {
#line 1035
      goto case_4___4;
    } else {

    }
#line 1035
    if (4UL == 8UL) {
#line 1035
      goto case_8___4;
    } else {

    }
#line 1035
    goto switch_default___4;
    case_1___5: /* CIL Label */ 
#line 1035
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 1035
    goto ldv_34268;
    case_2___4: /* CIL Label */ 
#line 1035
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1035
    goto ldv_34268;
    case_4___4: /* CIL Label */ 
#line 1035
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1035
    goto ldv_34268;
    case_8___4: /* CIL Label */ 
#line 1035
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1035
    goto ldv_34268;
    switch_default___4: /* CIL Label */ 
    {
#line 1035
    __bad_percpu_size();
    }
    switch_break___5: /* CIL Label */ ;
    }
    ldv_34268: 
#line 1035
    pscr_ret_____0 = pfo_ret_____3;
#line 1035
    goto ldv_34274;
    case_2___5: /* CIL Label */ ;
    {
#line 1035
    if (4UL == 1UL) {
#line 1035
      goto case_1___6;
    } else {

    }
#line 1035
    if (4UL == 2UL) {
#line 1035
      goto case_2___6;
    } else {

    }
#line 1035
    if (4UL == 4UL) {
#line 1035
      goto case_4___5;
    } else {

    }
#line 1035
    if (4UL == 8UL) {
#line 1035
      goto case_8___5;
    } else {

    }
#line 1035
    goto switch_default___5;
    case_1___6: /* CIL Label */ 
#line 1035
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 1035
    goto ldv_34278;
    case_2___6: /* CIL Label */ 
#line 1035
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1035
    goto ldv_34278;
    case_4___5: /* CIL Label */ 
#line 1035
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1035
    goto ldv_34278;
    case_8___5: /* CIL Label */ 
#line 1035
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1035
    goto ldv_34278;
    switch_default___5: /* CIL Label */ 
    {
#line 1035
    __bad_percpu_size();
    }
    switch_break___6: /* CIL Label */ ;
    }
    ldv_34278: 
#line 1035
    pscr_ret_____0 = pfo_ret_____4;
#line 1035
    goto ldv_34274;
    case_4___6: /* CIL Label */ ;
    {
#line 1035
    if (4UL == 1UL) {
#line 1035
      goto case_1___7;
    } else {

    }
#line 1035
    if (4UL == 2UL) {
#line 1035
      goto case_2___7;
    } else {

    }
#line 1035
    if (4UL == 4UL) {
#line 1035
      goto case_4___7;
    } else {

    }
#line 1035
    if (4UL == 8UL) {
#line 1035
      goto case_8___6;
    } else {

    }
#line 1035
    goto switch_default___6;
    case_1___7: /* CIL Label */ 
#line 1035
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 1035
    goto ldv_34287;
    case_2___7: /* CIL Label */ 
#line 1035
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1035
    goto ldv_34287;
    case_4___7: /* CIL Label */ 
#line 1035
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1035
    goto ldv_34287;
    case_8___6: /* CIL Label */ 
#line 1035
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1035
    goto ldv_34287;
    switch_default___6: /* CIL Label */ 
    {
#line 1035
    __bad_percpu_size();
    }
    switch_break___7: /* CIL Label */ ;
    }
    ldv_34287: 
#line 1035
    pscr_ret_____0 = pfo_ret_____5;
#line 1035
    goto ldv_34274;
    case_8___7: /* CIL Label */ ;
    {
#line 1035
    if (4UL == 1UL) {
#line 1035
      goto case_1___8;
    } else {

    }
#line 1035
    if (4UL == 2UL) {
#line 1035
      goto case_2___8;
    } else {

    }
#line 1035
    if (4UL == 4UL) {
#line 1035
      goto case_4___8;
    } else {

    }
#line 1035
    if (4UL == 8UL) {
#line 1035
      goto case_8___8;
    } else {

    }
#line 1035
    goto switch_default___7;
    case_1___8: /* CIL Label */ 
#line 1035
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 1035
    goto ldv_34296;
    case_2___8: /* CIL Label */ 
#line 1035
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1035
    goto ldv_34296;
    case_4___8: /* CIL Label */ 
#line 1035
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1035
    goto ldv_34296;
    case_8___8: /* CIL Label */ 
#line 1035
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1035
    goto ldv_34296;
    switch_default___7: /* CIL Label */ 
    {
#line 1035
    __bad_percpu_size();
    }
    switch_break___8: /* CIL Label */ ;
    }
    ldv_34296: 
#line 1035
    pscr_ret_____0 = pfo_ret_____6;
#line 1035
    goto ldv_34274;
    switch_default___8: /* CIL Label */ 
    {
#line 1035
    __bad_size_call_parameter();
    }
#line 1035
    goto ldv_34274;
    switch_break___4: /* CIL Label */ ;
    }
    ldv_34274: 
    {
#line 1035
    printk("\017GRU:%d quicktest2: bad message, i %d, m %p, m8 %d\n", pscr_ret_____0,
           i, m, (unsigned long )m != (unsigned long )((char *)0) ? (int )*(m + 8UL) : -1);
    }
#line 1036
    goto done;
  } else {

  }
#line 1038
  ret = 0;
  done: 
  {
#line 1041
  kfree((void const   *)p);
  }
#line 1042
  return (ret);
}
}
#line 1045 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int quicktest2(unsigned long arg ) 
{ 
  struct completion cmp ;
  unsigned long han ;
  int blade_id ;
  int numcb ;
  int ret ;
  unsigned long *buf ;
  void *cb0 ;
  void *cb ;
  struct gru_control_block_status *gen ;
  int i ;
  int k ;
  int istatus ;
  int bytes ;
  void *tmp ;
  unsigned long tmp___0 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int pscr_ret_____0 ;
  void const   *__vpp_verify___0 ;
  int pfo_ret_____3 ;
  int pfo_ret_____4 ;
  int pfo_ret_____5 ;
  int pfo_ret_____6 ;
  long tmp___1 ;

  {
  {
#line 1047
  cmp.done = 0U;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.raw_lock.__annonCompField4.head_tail = 0U;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.magic = 3735899821U;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.owner_cpu = 4294967295U;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.owner = (void *)-1;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.dep_map.key = 0;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.dep_map.class_cache[0] = 0;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.dep_map.class_cache[1] = 0;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.dep_map.name = "(cmp).wait.lock";
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.dep_map.cpu = 0;
#line 1047
  cmp.wait.lock.__annonCompField18.rlock.dep_map.ip = 0UL;
#line 1047
  cmp.wait.task_list.next = & cmp.wait.task_list;
#line 1047
  cmp.wait.task_list.prev = & cmp.wait.task_list;
#line 1049
  blade_id = 0;
#line 1050
  numcb = 4;
#line 1051
  ret = 0;
#line 1057
  bytes = numcb * 32;
#line 1058
  tmp = kmalloc((size_t )bytes, 208U);
#line 1058
  buf = (unsigned long *)tmp;
  }
#line 1059
  if ((unsigned long )buf == (unsigned long )((unsigned long *)0UL)) {
#line 1060
    return (-12);
  } else {

  }
  {
#line 1062
  ret = -16;
#line 1063
  han = gru_reserve_async_resources(blade_id, numcb, 0, & cmp);
  }
#line 1064
  if (han == 0UL) {
#line 1065
    goto done;
  } else {

  }
  {
#line 1067
  gru_lock_async_resource(han, & cb0, (void **)0);
#line 1068
  __memset((void *)buf, 238, (size_t )bytes);
#line 1069
  i = 0;
  }
#line 1069
  goto ldv_34323;
  ldv_34322: 
  {
#line 1070
  tmp___0 = uv_gpa((void *)buf + (unsigned long )(i * 4));
#line 1070
  gru_vset(cb0 + (unsigned long )(i * 256), tmp___0, 0UL, 3, 4UL, 1UL, 4UL);
#line 1069
  i = i + 1;
  }
  ldv_34323: ;
#line 1069
  if (i < numcb) {
#line 1071
    goto ldv_34322;
  } else {

  }
#line 1073
  ret = 0;
#line 1074
  k = numcb;
  ldv_34411: 
  {
#line 1076
  gru_wait_async_cbr(han);
#line 1077
  i = 0;
  }
#line 1077
  goto ldv_34327;
  ldv_34326: 
  {
#line 1078
  cb = cb0 + (unsigned long )(i * 256);
#line 1079
  istatus = gru_check_status(cb);
  }
#line 1080
  if ((unsigned int )istatus - 2U > 1U) {
#line 1081
    goto ldv_34325;
  } else {

  }
#line 1077
  i = i + 1;
  ldv_34327: ;
#line 1077
  if (i < numcb) {
#line 1079
    goto ldv_34326;
  } else {

  }
  ldv_34325: ;
#line 1083
  if (i == numcb) {
#line 1084
    goto ldv_34328;
  } else {

  }
#line 1085
  if (istatus != 0) {
#line 1086
    __vpp_verify = (void const   *)0;
    {
#line 1086
    if (4UL == 1UL) {
#line 1086
      goto case_1;
    } else {

    }
#line 1086
    if (4UL == 2UL) {
#line 1086
      goto case_2___0;
    } else {

    }
#line 1086
    if (4UL == 4UL) {
#line 1086
      goto case_4___1;
    } else {

    }
#line 1086
    if (4UL == 8UL) {
#line 1086
      goto case_8___2;
    } else {

    }
#line 1086
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 1086
    if (4UL == 1UL) {
#line 1086
      goto case_1___0;
    } else {

    }
#line 1086
    if (4UL == 2UL) {
#line 1086
      goto case_2;
    } else {

    }
#line 1086
    if (4UL == 4UL) {
#line 1086
      goto case_4;
    } else {

    }
#line 1086
    if (4UL == 8UL) {
#line 1086
      goto case_8;
    } else {

    }
#line 1086
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 1086
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1086
    goto ldv_34334;
    case_2: /* CIL Label */ 
#line 1086
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1086
    goto ldv_34334;
    case_4: /* CIL Label */ 
#line 1086
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1086
    goto ldv_34334;
    case_8: /* CIL Label */ 
#line 1086
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1086
    goto ldv_34334;
    switch_default: /* CIL Label */ 
    {
#line 1086
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34334: 
#line 1086
    pscr_ret__ = pfo_ret__;
#line 1086
    goto ldv_34340;
    case_2___0: /* CIL Label */ ;
    {
#line 1086
    if (4UL == 1UL) {
#line 1086
      goto case_1___1;
    } else {

    }
#line 1086
    if (4UL == 2UL) {
#line 1086
      goto case_2___1;
    } else {

    }
#line 1086
    if (4UL == 4UL) {
#line 1086
      goto case_4___0;
    } else {

    }
#line 1086
    if (4UL == 8UL) {
#line 1086
      goto case_8___0;
    } else {

    }
#line 1086
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 1086
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1086
    goto ldv_34344;
    case_2___1: /* CIL Label */ 
#line 1086
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1086
    goto ldv_34344;
    case_4___0: /* CIL Label */ 
#line 1086
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1086
    goto ldv_34344;
    case_8___0: /* CIL Label */ 
#line 1086
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1086
    goto ldv_34344;
    switch_default___0: /* CIL Label */ 
    {
#line 1086
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34344: 
#line 1086
    pscr_ret__ = pfo_ret_____0;
#line 1086
    goto ldv_34340;
    case_4___1: /* CIL Label */ ;
    {
#line 1086
    if (4UL == 1UL) {
#line 1086
      goto case_1___2;
    } else {

    }
#line 1086
    if (4UL == 2UL) {
#line 1086
      goto case_2___2;
    } else {

    }
#line 1086
    if (4UL == 4UL) {
#line 1086
      goto case_4___2;
    } else {

    }
#line 1086
    if (4UL == 8UL) {
#line 1086
      goto case_8___1;
    } else {

    }
#line 1086
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 1086
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1086
    goto ldv_34353;
    case_2___2: /* CIL Label */ 
#line 1086
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1086
    goto ldv_34353;
    case_4___2: /* CIL Label */ 
#line 1086
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1086
    goto ldv_34353;
    case_8___1: /* CIL Label */ 
#line 1086
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1086
    goto ldv_34353;
    switch_default___1: /* CIL Label */ 
    {
#line 1086
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34353: 
#line 1086
    pscr_ret__ = pfo_ret_____1;
#line 1086
    goto ldv_34340;
    case_8___2: /* CIL Label */ ;
    {
#line 1086
    if (4UL == 1UL) {
#line 1086
      goto case_1___3;
    } else {

    }
#line 1086
    if (4UL == 2UL) {
#line 1086
      goto case_2___3;
    } else {

    }
#line 1086
    if (4UL == 4UL) {
#line 1086
      goto case_4___3;
    } else {

    }
#line 1086
    if (4UL == 8UL) {
#line 1086
      goto case_8___3;
    } else {

    }
#line 1086
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 1086
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1086
    goto ldv_34362;
    case_2___3: /* CIL Label */ 
#line 1086
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1086
    goto ldv_34362;
    case_4___3: /* CIL Label */ 
#line 1086
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1086
    goto ldv_34362;
    case_8___3: /* CIL Label */ 
#line 1086
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1086
    goto ldv_34362;
    switch_default___2: /* CIL Label */ 
    {
#line 1086
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34362: 
#line 1086
    pscr_ret__ = pfo_ret_____2;
#line 1086
    goto ldv_34340;
    switch_default___3: /* CIL Label */ 
    {
#line 1086
    __bad_size_call_parameter();
    }
#line 1086
    goto ldv_34340;
    switch_break: /* CIL Label */ ;
    }
    ldv_34340: 
    {
#line 1086
    printk("\017GRU:%d quicktest2: cb %d, exception\n", pscr_ret__, i);
#line 1087
    ret = -14;
    }
  } else
#line 1088
  if (((*(buf + (unsigned long )(i * 4)) != 0UL || *(buf + ((unsigned long )(i * 4) + 1UL)) != 0UL) || *(buf + ((unsigned long )(i * 4) + 2UL)) != 0UL) || *(buf + ((unsigned long )(i * 4) + 3UL)) != 0UL) {
#line 1091
    __vpp_verify___0 = (void const   *)0;
    {
#line 1091
    if (4UL == 1UL) {
#line 1091
      goto case_1___4;
    } else {

    }
#line 1091
    if (4UL == 2UL) {
#line 1091
      goto case_2___5;
    } else {

    }
#line 1091
    if (4UL == 4UL) {
#line 1091
      goto case_4___6;
    } else {

    }
#line 1091
    if (4UL == 8UL) {
#line 1091
      goto case_8___7;
    } else {

    }
#line 1091
    goto switch_default___8;
    case_1___4: /* CIL Label */ ;
    {
#line 1091
    if (4UL == 1UL) {
#line 1091
      goto case_1___5;
    } else {

    }
#line 1091
    if (4UL == 2UL) {
#line 1091
      goto case_2___4;
    } else {

    }
#line 1091
    if (4UL == 4UL) {
#line 1091
      goto case_4___4;
    } else {

    }
#line 1091
    if (4UL == 8UL) {
#line 1091
      goto case_8___4;
    } else {

    }
#line 1091
    goto switch_default___4;
    case_1___5: /* CIL Label */ 
#line 1091
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____3): "m" (cpu_number));
#line 1091
    goto ldv_34375;
    case_2___4: /* CIL Label */ 
#line 1091
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1091
    goto ldv_34375;
    case_4___4: /* CIL Label */ 
#line 1091
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1091
    goto ldv_34375;
    case_8___4: /* CIL Label */ 
#line 1091
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____3): "m" (cpu_number));
#line 1091
    goto ldv_34375;
    switch_default___4: /* CIL Label */ 
    {
#line 1091
    __bad_percpu_size();
    }
    switch_break___5: /* CIL Label */ ;
    }
    ldv_34375: 
#line 1091
    pscr_ret_____0 = pfo_ret_____3;
#line 1091
    goto ldv_34381;
    case_2___5: /* CIL Label */ ;
    {
#line 1091
    if (4UL == 1UL) {
#line 1091
      goto case_1___6;
    } else {

    }
#line 1091
    if (4UL == 2UL) {
#line 1091
      goto case_2___6;
    } else {

    }
#line 1091
    if (4UL == 4UL) {
#line 1091
      goto case_4___5;
    } else {

    }
#line 1091
    if (4UL == 8UL) {
#line 1091
      goto case_8___5;
    } else {

    }
#line 1091
    goto switch_default___5;
    case_1___6: /* CIL Label */ 
#line 1091
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____4): "m" (cpu_number));
#line 1091
    goto ldv_34385;
    case_2___6: /* CIL Label */ 
#line 1091
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1091
    goto ldv_34385;
    case_4___5: /* CIL Label */ 
#line 1091
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1091
    goto ldv_34385;
    case_8___5: /* CIL Label */ 
#line 1091
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____4): "m" (cpu_number));
#line 1091
    goto ldv_34385;
    switch_default___5: /* CIL Label */ 
    {
#line 1091
    __bad_percpu_size();
    }
    switch_break___6: /* CIL Label */ ;
    }
    ldv_34385: 
#line 1091
    pscr_ret_____0 = pfo_ret_____4;
#line 1091
    goto ldv_34381;
    case_4___6: /* CIL Label */ ;
    {
#line 1091
    if (4UL == 1UL) {
#line 1091
      goto case_1___7;
    } else {

    }
#line 1091
    if (4UL == 2UL) {
#line 1091
      goto case_2___7;
    } else {

    }
#line 1091
    if (4UL == 4UL) {
#line 1091
      goto case_4___7;
    } else {

    }
#line 1091
    if (4UL == 8UL) {
#line 1091
      goto case_8___6;
    } else {

    }
#line 1091
    goto switch_default___6;
    case_1___7: /* CIL Label */ 
#line 1091
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____5): "m" (cpu_number));
#line 1091
    goto ldv_34394;
    case_2___7: /* CIL Label */ 
#line 1091
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1091
    goto ldv_34394;
    case_4___7: /* CIL Label */ 
#line 1091
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1091
    goto ldv_34394;
    case_8___6: /* CIL Label */ 
#line 1091
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____5): "m" (cpu_number));
#line 1091
    goto ldv_34394;
    switch_default___6: /* CIL Label */ 
    {
#line 1091
    __bad_percpu_size();
    }
    switch_break___7: /* CIL Label */ ;
    }
    ldv_34394: 
#line 1091
    pscr_ret_____0 = pfo_ret_____5;
#line 1091
    goto ldv_34381;
    case_8___7: /* CIL Label */ ;
    {
#line 1091
    if (4UL == 1UL) {
#line 1091
      goto case_1___8;
    } else {

    }
#line 1091
    if (4UL == 2UL) {
#line 1091
      goto case_2___8;
    } else {

    }
#line 1091
    if (4UL == 4UL) {
#line 1091
      goto case_4___8;
    } else {

    }
#line 1091
    if (4UL == 8UL) {
#line 1091
      goto case_8___8;
    } else {

    }
#line 1091
    goto switch_default___7;
    case_1___8: /* CIL Label */ 
#line 1091
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____6): "m" (cpu_number));
#line 1091
    goto ldv_34403;
    case_2___8: /* CIL Label */ 
#line 1091
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1091
    goto ldv_34403;
    case_4___8: /* CIL Label */ 
#line 1091
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1091
    goto ldv_34403;
    case_8___8: /* CIL Label */ 
#line 1091
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____6): "m" (cpu_number));
#line 1091
    goto ldv_34403;
    switch_default___7: /* CIL Label */ 
    {
#line 1091
    __bad_percpu_size();
    }
    switch_break___8: /* CIL Label */ ;
    }
    ldv_34403: 
#line 1091
    pscr_ret_____0 = pfo_ret_____6;
#line 1091
    goto ldv_34381;
    switch_default___8: /* CIL Label */ 
    {
#line 1091
    __bad_size_call_parameter();
    }
#line 1091
    goto ldv_34381;
    switch_break___4: /* CIL Label */ ;
    }
    ldv_34381: 
    {
#line 1091
    printk("\017GRU:%d quicktest2:cb %d,  buf 0x%lx, 0x%lx, 0x%lx, 0x%lx\n", pscr_ret_____0,
           i, *(buf + (unsigned long )(i * 4)), *(buf + ((unsigned long )(i * 4) + 1UL)),
           *(buf + ((unsigned long )(i * 4) + 2UL)), *(buf + ((unsigned long )(i * 4) + 3UL)));
#line 1092
    ret = -5;
    }
  } else {

  }
#line 1094
  k = k - 1;
#line 1095
  gen = (struct gru_control_block_status *)cb;
#line 1096
  gen->istatus = 3U;
  ldv_34328: ;
#line 1097
  if (k != 0) {
#line 1099
    goto ldv_34411;
  } else {

  }
  {
#line 1098
  tmp___1 = __builtin_expect(cmp.done != 0U, 0L);
  }
#line 1098
  if (tmp___1 != 0L) {
    {
#line 1098
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grukservices.c"),
                         "i" (1098), "i" (12UL));
#line 1098
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 1100
  gru_unlock_async_resource(han);
#line 1101
  gru_release_async_resources(han);
  }
  done: 
  {
#line 1103
  kfree((void const   *)buf);
  }
#line 1104
  return (ret);
}
}
#line 1108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
static int quicktest3(unsigned long arg ) 
{ 
  char buf1[200U] ;
  char buf2[200U] ;
  int ret ;
  cycles_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int pscr_ret__ ;
  void const   *__vpp_verify ;
  int pfo_ret__ ;
  int pfo_ret_____0 ;
  int pfo_ret_____1 ;
  int pfo_ret_____2 ;
  int tmp___2 ;

  {
  {
#line 1111
  ret = 0;
#line 1113
  __memset((void *)(& buf2), 0, 200UL);
#line 1114
  tmp = get_cycles();
#line 1114
  __memset((void *)(& buf1), (int )tmp & 255, 200UL);
#line 1115
  tmp___0 = uv_gpa((void *)(& buf1));
#line 1115
  tmp___1 = uv_gpa((void *)(& buf2));
#line 1115
  gru_copy_gpa(tmp___1, tmp___0, 200U);
#line 1116
  tmp___2 = memcmp((void const   *)(& buf1), (void const   *)(& buf2), 200UL);
  }
#line 1116
  if (tmp___2 != 0) {
#line 1117
    __vpp_verify = (void const   *)0;
    {
#line 1117
    if (4UL == 1UL) {
#line 1117
      goto case_1;
    } else {

    }
#line 1117
    if (4UL == 2UL) {
#line 1117
      goto case_2___0;
    } else {

    }
#line 1117
    if (4UL == 4UL) {
#line 1117
      goto case_4___1;
    } else {

    }
#line 1117
    if (4UL == 8UL) {
#line 1117
      goto case_8___2;
    } else {

    }
#line 1117
    goto switch_default___3;
    case_1: /* CIL Label */ ;
    {
#line 1117
    if (4UL == 1UL) {
#line 1117
      goto case_1___0;
    } else {

    }
#line 1117
    if (4UL == 2UL) {
#line 1117
      goto case_2;
    } else {

    }
#line 1117
    if (4UL == 4UL) {
#line 1117
      goto case_4;
    } else {

    }
#line 1117
    if (4UL == 8UL) {
#line 1117
      goto case_8;
    } else {

    }
#line 1117
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 1117
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (cpu_number));
#line 1117
    goto ldv_34424;
    case_2: /* CIL Label */ 
#line 1117
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1117
    goto ldv_34424;
    case_4: /* CIL Label */ 
#line 1117
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1117
    goto ldv_34424;
    case_8: /* CIL Label */ 
#line 1117
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (cpu_number));
#line 1117
    goto ldv_34424;
    switch_default: /* CIL Label */ 
    {
#line 1117
    __bad_percpu_size();
    }
    switch_break___0: /* CIL Label */ ;
    }
    ldv_34424: 
#line 1117
    pscr_ret__ = pfo_ret__;
#line 1117
    goto ldv_34430;
    case_2___0: /* CIL Label */ ;
    {
#line 1117
    if (4UL == 1UL) {
#line 1117
      goto case_1___1;
    } else {

    }
#line 1117
    if (4UL == 2UL) {
#line 1117
      goto case_2___1;
    } else {

    }
#line 1117
    if (4UL == 4UL) {
#line 1117
      goto case_4___0;
    } else {

    }
#line 1117
    if (4UL == 8UL) {
#line 1117
      goto case_8___0;
    } else {

    }
#line 1117
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 1117
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____0): "m" (cpu_number));
#line 1117
    goto ldv_34434;
    case_2___1: /* CIL Label */ 
#line 1117
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1117
    goto ldv_34434;
    case_4___0: /* CIL Label */ 
#line 1117
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1117
    goto ldv_34434;
    case_8___0: /* CIL Label */ 
#line 1117
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____0): "m" (cpu_number));
#line 1117
    goto ldv_34434;
    switch_default___0: /* CIL Label */ 
    {
#line 1117
    __bad_percpu_size();
    }
    switch_break___1: /* CIL Label */ ;
    }
    ldv_34434: 
#line 1117
    pscr_ret__ = pfo_ret_____0;
#line 1117
    goto ldv_34430;
    case_4___1: /* CIL Label */ ;
    {
#line 1117
    if (4UL == 1UL) {
#line 1117
      goto case_1___2;
    } else {

    }
#line 1117
    if (4UL == 2UL) {
#line 1117
      goto case_2___2;
    } else {

    }
#line 1117
    if (4UL == 4UL) {
#line 1117
      goto case_4___2;
    } else {

    }
#line 1117
    if (4UL == 8UL) {
#line 1117
      goto case_8___1;
    } else {

    }
#line 1117
    goto switch_default___1;
    case_1___2: /* CIL Label */ 
#line 1117
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____1): "m" (cpu_number));
#line 1117
    goto ldv_34443;
    case_2___2: /* CIL Label */ 
#line 1117
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1117
    goto ldv_34443;
    case_4___2: /* CIL Label */ 
#line 1117
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1117
    goto ldv_34443;
    case_8___1: /* CIL Label */ 
#line 1117
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____1): "m" (cpu_number));
#line 1117
    goto ldv_34443;
    switch_default___1: /* CIL Label */ 
    {
#line 1117
    __bad_percpu_size();
    }
    switch_break___2: /* CIL Label */ ;
    }
    ldv_34443: 
#line 1117
    pscr_ret__ = pfo_ret_____1;
#line 1117
    goto ldv_34430;
    case_8___2: /* CIL Label */ ;
    {
#line 1117
    if (4UL == 1UL) {
#line 1117
      goto case_1___3;
    } else {

    }
#line 1117
    if (4UL == 2UL) {
#line 1117
      goto case_2___3;
    } else {

    }
#line 1117
    if (4UL == 4UL) {
#line 1117
      goto case_4___3;
    } else {

    }
#line 1117
    if (4UL == 8UL) {
#line 1117
      goto case_8___3;
    } else {

    }
#line 1117
    goto switch_default___2;
    case_1___3: /* CIL Label */ 
#line 1117
    __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret_____2): "m" (cpu_number));
#line 1117
    goto ldv_34452;
    case_2___3: /* CIL Label */ 
#line 1117
    __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1117
    goto ldv_34452;
    case_4___3: /* CIL Label */ 
#line 1117
    __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1117
    goto ldv_34452;
    case_8___3: /* CIL Label */ 
#line 1117
    __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret_____2): "m" (cpu_number));
#line 1117
    goto ldv_34452;
    switch_default___2: /* CIL Label */ 
    {
#line 1117
    __bad_percpu_size();
    }
    switch_break___3: /* CIL Label */ ;
    }
    ldv_34452: 
#line 1117
    pscr_ret__ = pfo_ret_____2;
#line 1117
    goto ldv_34430;
    switch_default___3: /* CIL Label */ 
    {
#line 1117
    __bad_size_call_parameter();
    }
#line 1117
    goto ldv_34430;
    switch_break: /* CIL Label */ ;
    }
    ldv_34430: 
    {
#line 1117
    printk("\017GRU:%d quicktest3 error\n", pscr_ret__);
#line 1118
    ret = -5;
    }
  } else {

  }
#line 1120
  return (ret);
}
}
#line 1127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_ktest(unsigned long arg ) 
{ 
  int ret ;

  {
#line 1129
  ret = -22;
  {
#line 1132
  if ((arg & 255UL) == 0UL) {
#line 1132
    goto case_0;
  } else {

  }
#line 1135
  if ((arg & 255UL) == 1UL) {
#line 1135
    goto case_1;
  } else {

  }
#line 1138
  if ((arg & 255UL) == 2UL) {
#line 1138
    goto case_2;
  } else {

  }
#line 1141
  if ((arg & 255UL) == 3UL) {
#line 1141
    goto case_3;
  } else {

  }
#line 1144
  if ((arg & 255UL) == 99UL) {
#line 1144
    goto case_99;
  } else {

  }
#line 1131
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1133
  ret = quicktest0(arg);
  }
#line 1134
  goto ldv_34465;
  case_1: /* CIL Label */ 
  {
#line 1136
  ret = quicktest1(arg);
  }
#line 1137
  goto ldv_34465;
  case_2: /* CIL Label */ 
  {
#line 1139
  ret = quicktest2(arg);
  }
#line 1140
  goto ldv_34465;
  case_3: /* CIL Label */ 
  {
#line 1142
  ret = quicktest3(arg);
  }
#line 1143
  goto ldv_34465;
  case_99: /* CIL Label */ 
  {
#line 1145
  ret = gru_free_kernel_contexts();
  }
#line 1146
  goto ldv_34465;
  switch_break: /* CIL Label */ ;
  }
  ldv_34465: ;
#line 1148
  return (ret);
}
}
#line 1152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
int gru_kservices_init(void) 
{ 


  {
#line 1154
  return (0);
}
}
#line 1157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukservices.c"
void gru_kservices_exit(void) 
{ 
  int tmp ;

  {
  {
#line 1159
  tmp = gru_free_kernel_contexts();
  }
#line 1159
  if (tmp != 0) {
    {
#line 1160
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/misc/sgi-gru/grukservices.c"),
                         "i" (1160), "i" (12UL));
#line 1160
    __builtin_unreachable();
    }
  } else {

  }
#line 1162
  return;
}
}
#line 1339 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grukservices.c.aux"
static void ldv_wait_for_completion_95(struct completion *ldv_func_arg1 ) 
{ 


  {
  {
#line 1342
  ldv_linux_kernel_sched_completion_wait_for_completion_bs_async_wq_of_gru_blade_state();
#line 1344
  wait_for_completion(ldv_func_arg1);
  }
#line 1345
  return;
}
}
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic64_64.h"
__inline static void atomic64_add(long i , atomic64_t *v ) 
{ 


  {
#line 45
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; addq %1,%0": "=m" (v->counter): "er" (i),
                       "m" (v->counter));
#line 48
  return;
}
}
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
__inline static void atomic_long_add(long i , atomic_long_t *l ) 
{ 
  atomic64_t *v ;

  {
  {
#line 57
  v = l;
#line 59
  atomic64_add(i, v);
  }
#line 60
  return;
}
}
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/tsc.h"
extern unsigned int tsc_khz ;
#line 527 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.h"
void tfh_restart(struct gru_tlb_fault_handle *tfh ) ;
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
struct mcs_op_statistic mcs_op_statistics[8U]  ;
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
static void update_mcs_stats(enum mcs_op op , unsigned long clks ) 
{ 
  unsigned long nsec ;

  {
  {
#line 46
  nsec = (clks * 1000000UL) / (unsigned long )tsc_khz;
#line 47
  atomic_long_inc(& mcs_op_statistics[(unsigned int )op].count);
#line 48
  atomic_long_add((long )nsec, & mcs_op_statistics[(unsigned int )op].total);
  }
#line 49
  if (mcs_op_statistics[(unsigned int )op].max < nsec) {
#line 50
    mcs_op_statistics[(unsigned int )op].max = nsec;
  } else {

  }
#line 51
  return;
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
static void start_instruction(void *h ) 
{ 
  unsigned long *w0 ;

  {
  {
#line 55
  w0 = (unsigned long *)h;
#line 57
  __asm__  volatile   ("sfence": : : "memory");
#line 58
  *w0 = *w0 | 131073UL;
#line 59
  gru_flush_cache(h);
  }
#line 60
  return;
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
static void report_instruction_timeout(void *h ) 
{ 
  unsigned long goff ;
  char *id ;

  {
#line 64
  goff = (unsigned long )h & 134217727UL;
#line 65
  id = (char *)"???";
#line 67
  if (goff - 67239936UL <= 4095UL && (goff & 255UL) == 0UL) {
#line 68
    id = (char *)"CCH";
  } else
#line 69
  if (goff - 67141632UL <= 6143UL && (goff & 255UL) == 0UL) {
#line 70
    id = (char *)"TGH";
  } else
#line 71
  if (goff - 67207168UL <= 32767UL && (goff & 255UL) == 0UL) {
#line 72
    id = (char *)"TFH";
  } else {

  }
  {
#line 74
  panic("\tGRU %p (%s) is malfunctioning\n", h, id);
  }
#line 75
  return;
}
}
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
static int wait_instruction_complete(void *h , enum mcs_op opc ) 
{ 
  int status ;
  unsigned long start_time ;
  cycles_t tmp ;
  cycles_t tmp___0 ;
  cycles_t tmp___1 ;
  cycles_t tmp___2 ;

  {
  {
#line 80
  tmp = get_cycles();
#line 80
  start_time = (unsigned long )tmp;
  }
  ldv_31116: 
  {
#line 83
  cpu_relax();
#line 84
  status = (int )(*((unsigned long *)h) >> 16) & 3;
  }
#line 85
  if (status != 2) {
#line 86
    goto ldv_31115;
  } else {

  }
  {
#line 87
  tmp___1 = get_cycles();
  }
#line 87
  if ((unsigned long long )tsc_khz * 10000ULL < tmp___1 - (unsigned long long )start_time) {
    {
#line 88
    report_instruction_timeout(h);
#line 89
    tmp___0 = get_cycles();
#line 89
    start_time = (unsigned long )tmp___0;
    }
  } else {

  }
#line 91
  goto ldv_31116;
  ldv_31115: ;
#line 92
  if ((gru_options & 2UL) != 0UL) {
    {
#line 93
    tmp___2 = get_cycles();
#line 93
    update_mcs_stats(opc, (unsigned long )(tmp___2 - (unsigned long long )start_time));
    }
  } else {

  }
#line 94
  return (status);
}
}
#line 97 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
int cch_allocate(struct gru_context_configuration_handle *cch ) 
{ 
  int ret ;

  {
  {
#line 101
  cch->opc = 2U;
#line 102
  start_instruction((void *)cch);
#line 103
  ret = wait_instruction_complete((void *)cch, 0);
#line 109
  sync_core();
  }
#line 110
  return (ret);
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
int cch_start(struct gru_context_configuration_handle *cch ) 
{ 
  int tmp ;

  {
  {
#line 115
  cch->opc = 1U;
#line 116
  start_instruction((void *)cch);
#line 117
  tmp = wait_instruction_complete((void *)cch, 1);
  }
#line 117
  return (tmp);
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
int cch_interrupt(struct gru_context_configuration_handle *cch ) 
{ 
  int tmp ;

  {
  {
#line 122
  cch->opc = 3U;
#line 123
  start_instruction((void *)cch);
#line 124
  tmp = wait_instruction_complete((void *)cch, 2);
  }
#line 124
  return (tmp);
}
}
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
int cch_deallocate(struct gru_context_configuration_handle *cch ) 
{ 
  int ret ;

  {
  {
#line 131
  cch->opc = 4U;
#line 132
  start_instruction((void *)cch);
#line 133
  ret = wait_instruction_complete((void *)cch, 4);
#line 139
  sync_core();
  }
#line 140
  return (ret);
}
}
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
int cch_interrupt_sync(struct gru_context_configuration_handle *cch ) 
{ 
  int tmp ;

  {
  {
#line 146
  cch->opc = 5U;
#line 147
  start_instruction((void *)cch);
#line 148
  tmp = wait_instruction_complete((void *)cch, 3);
  }
#line 148
  return (tmp);
}
}
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
int tgh_invalidate(struct gru_tlb_global_handle *tgh , unsigned long vaddr , unsigned long vaddrmask ,
                   int asid , int pagesize , int global , int n , unsigned short ctxbitmap ) 
{ 
  int tmp ;

  {
  {
#line 156
  tgh->vaddr = vaddr;
#line 157
  tgh->asid = (unsigned int )asid;
#line 158
  tgh->pagesize = (unsigned char )pagesize;
#line 159
  tgh->n = (unsigned short )n;
#line 160
  tgh->global = (unsigned char )global;
#line 161
  tgh->vaddrmask = vaddrmask;
#line 162
  tgh->ctxbitmap = ctxbitmap;
#line 163
  tgh->opc = 1U;
#line 164
  start_instruction((void *)tgh);
#line 165
  tmp = wait_instruction_complete((void *)tgh, 7);
  }
#line 165
  return (tmp);
}
}
#line 168 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
int tfh_write_only(struct gru_tlb_fault_handle *tfh , unsigned long paddr , int gaa ,
                   unsigned long vaddr , int asid , int dirty , int pagesize ) 
{ 
  int tmp ;

  {
  {
#line 173
  tfh->fillasid = (unsigned int )asid;
#line 174
  tfh->fillvaddr = vaddr;
#line 175
  tfh->pfn = paddr >> 12;
#line 176
  tfh->gaa = (unsigned char )gaa;
#line 177
  tfh->dirty = (unsigned char )dirty;
#line 178
  tfh->pagesize = (unsigned char )pagesize;
#line 179
  tfh->opc = 2U;
#line 180
  start_instruction((void *)tfh);
#line 181
  tmp = wait_instruction_complete((void *)tfh, 5);
  }
#line 181
  return (tmp);
}
}
#line 184 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
void tfh_write_restart(struct gru_tlb_fault_handle *tfh , unsigned long paddr , int gaa ,
                       unsigned long vaddr , int asid , int dirty , int pagesize ) 
{ 


  {
  {
#line 189
  tfh->fillasid = (unsigned int )asid;
#line 190
  tfh->fillvaddr = vaddr;
#line 191
  tfh->pfn = paddr >> 12;
#line 192
  tfh->gaa = (unsigned char )gaa;
#line 193
  tfh->dirty = (unsigned char )dirty;
#line 194
  tfh->pagesize = (unsigned char )pagesize;
#line 195
  tfh->opc = 3U;
#line 196
  start_instruction((void *)tfh);
  }
#line 197
  return;
}
}
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
void tfh_restart(struct gru_tlb_fault_handle *tfh ) 
{ 


  {
  {
#line 201
  tfh->opc = 1U;
#line 202
  start_instruction((void *)tfh);
  }
#line 203
  return;
}
}
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
void tfh_user_polling_mode(struct gru_tlb_fault_handle *tfh ) 
{ 


  {
  {
#line 207
  tfh->opc = 7U;
#line 208
  start_instruction((void *)tfh);
  }
#line 209
  return;
}
}
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/gruhandles.c"
void tfh_exception(struct gru_tlb_fault_handle *tfh ) 
{ 


  {
  {
#line 213
  tfh->opc = 4U;
#line 214
  start_instruction((void *)tfh);
  }
#line 215
  return;
}
}
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bitops/find.h"
static unsigned long ldv_find_next_bit_93(unsigned long const   *addr , unsigned long size ,
                                          unsigned long offset ) ;
#line 54
static unsigned long ldv_find_first_bit_92(unsigned long const   *addr , unsigned long size ) ;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/arch_hweight.h"
__inline static unsigned int __arch_hweight32(unsigned int w ) 
{ 
  unsigned int res ;

  {
#line 26
  res = 0U;
#line 28
  __asm__  ("661:\n\tcall __sw_hweight32\n662:\n.pushsection .altinstructions,\"a\"\n .long 661b - .\n .long 6631f - .\n .word ( 4*32+23)\n .byte 662b-661b\n .byte 6641f-6631f\n.popsection\n.pushsection .discard,\"aw\",@progbits\n .byte 0xff + (6641f-6631f) - (662b-661b)\n.popsection\n.pushsection .altinstr_replacement, \"ax\"\n6631:\n\t.byte 0xf3,0x40,0x0f,0xb8,0xc7\n6641:\n\t.popsection": "=a" (res): "D" (w));
#line 32
  return (res);
}
}
#line 565 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static int __trylock_handle(void *h ) 
{ 
  int tmp ;

  {
  {
#line 567
  tmp = test_and_set_bit(1L, (unsigned long volatile   *)h);
  }
#line 567
  return (tmp == 0);
}
}
#line 581 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grutables.h"
__inline static int trylock_cch_handle(struct gru_context_configuration_handle *cch ) 
{ 
  int tmp ;

  {
  {
#line 583
  tmp = __trylock_handle((void *)cch);
  }
#line 583
  return (tmp);
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukdump.c"
static int gru_user_copy_handle(void **dp , void *s ) 
{ 
  unsigned long tmp ;

  {
  {
#line 39
  tmp = copy_to_user(*dp, (void const   *)s, 64UL);
  }
#line 39
  if (tmp != 0UL) {
#line 40
    return (-1);
  } else {

  }
#line 41
  *dp = *dp + 64UL;
#line 42
  return (0);
}
}
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukdump.c"
static int gru_dump_context_data(void *grubase , struct gru_context_configuration_handle *cch ,
                                 void *ubuf , int ctxnum , int dsrcnt , int flush_cbrs ) 
{ 
  void *cb ;
  void *cbe ;
  void *tfh ;
  void *gseg ;
  int i ;
  int scr ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 53
  gseg = grubase + (unsigned long )(ctxnum * 4194304);
#line 54
  cb = gseg;
#line 55
  cbe = grubase + 67174400UL;
#line 56
  tfh = grubase + 67207168UL;
#line 58
  tmp = ldv_find_first_bit_92((unsigned long const   *)(& cch->cbr_allocation_map),
                              64UL);
#line 58
  scr = (int )tmp;
  }
#line 58
  goto ldv_32593;
  ldv_32592: 
#line 58
  i = scr * 2;
#line 58
  goto ldv_32590;
  ldv_32589: ;
#line 59
  if (flush_cbrs != 0) {
    {
#line 60
    gru_flush_cache(cb);
    }
  } else {

  }
  {
#line 61
  tmp___0 = gru_user_copy_handle(& ubuf, cb);
  }
#line 61
  if (tmp___0 != 0) {
#line 62
    goto fail;
  } else {

  }
  {
#line 63
  tmp___1 = gru_user_copy_handle(& ubuf, tfh + (unsigned long )(i * 256));
  }
#line 63
  if (tmp___1 != 0) {
#line 64
    goto fail;
  } else {

  }
  {
#line 65
  tmp___2 = gru_user_copy_handle(& ubuf, cbe + (unsigned long )(i * 256));
  }
#line 65
  if (tmp___2 != 0) {
#line 66
    goto fail;
  } else {

  }
#line 67
  cb = cb + 256UL;
#line 58
  i = i + 1;
  ldv_32590: ;
#line 58
  if (i < (scr + 1) * 2) {
#line 60
    goto ldv_32589;
  } else {

  }
  {
#line 58
  tmp___3 = ldv_find_next_bit_93((unsigned long const   *)(& cch->cbr_allocation_map),
                                 64UL, (unsigned long )(scr + 1));
#line 58
  scr = (int )tmp___3;
  }
  ldv_32593: ;
#line 58
  if (scr <= 63) {
#line 60
    goto ldv_32592;
  } else {

  }

#line 69
  if (dsrcnt != 0) {
    {
#line 70
    __memcpy(ubuf, (void const   *)gseg + 131072U, (size_t )(dsrcnt * 256));
    }
  } else {

  }
#line 71
  return (0);
  fail: ;
#line 74
  return (-14);
}
}
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukdump.c"
static int gru_dump_tfm(struct gru_state *gru , void *ubuf , void *ubufend ) 
{ 
  struct gru_tlb_fault_map *tfm ;
  int i ;
  int ret ;
  int bytes ;
  int tmp ;

  {
#line 83
  bytes = 1024;
#line 84
  if ((long )bytes > (long )ubufend - (long )ubuf) {
#line 85
    ret = -27;
  } else {

  }
#line 87
  i = 0;
#line 87
  goto ldv_32606;
  ldv_32605: 
  {
#line 88
  tfm = get_tfm(gru->gs_gru_base_vaddr, i);
#line 89
  tmp = gru_user_copy_handle(& ubuf, (void *)tfm);
  }
#line 89
  if (tmp != 0) {
#line 90
    goto fail;
  } else {

  }
#line 87
  i = i + 1;
  ldv_32606: ;
#line 87
  if (i <= 15) {
#line 89
    goto ldv_32605;
  } else {

  }

#line 92
  return (1024);
  fail: ;
#line 95
  return (-14);
}
}
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukdump.c"
static int gru_dump_tgh(struct gru_state *gru , void *ubuf , void *ubufend ) 
{ 
  struct gru_tlb_global_handle *tgh ;
  int i ;
  int ret ;
  int bytes ;
  int tmp ;

  {
#line 104
  bytes = 1536;
#line 105
  if ((long )bytes > (long )ubufend - (long )ubuf) {
#line 106
    ret = -27;
  } else {

  }
#line 108
  i = 0;
#line 108
  goto ldv_32619;
  ldv_32618: 
  {
#line 109
  tgh = get_tgh(gru->gs_gru_base_vaddr, i);
#line 110
  tmp = gru_user_copy_handle(& ubuf, (void *)tgh);
  }
#line 110
  if (tmp != 0) {
#line 111
    goto fail;
  } else {

  }
#line 108
  i = i + 1;
  ldv_32619: ;
#line 108
  if (i <= 23) {
#line 110
    goto ldv_32618;
  } else {

  }

#line 113
  return (1536);
  fail: ;
#line 116
  return (-14);
}
}
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukdump.c"
static int gru_dump_context(struct gru_state *gru , int ctxnum , void *ubuf , void *ubufend ,
                            char data_opt , char lock_cch , char flush_cbrs ) 
{ 
  struct gru_dump_context_header hdr ;
  struct gru_dump_context_header *uhdr ;
  struct gru_context_configuration_handle *cch ;
  struct gru_context_configuration_handle *ubufcch ;
  struct gru_thread_state *gts ;
  int try ;
  int cch_locked ;
  int cbrcnt ;
  int dsrcnt ;
  int bytes ;
  int ret ;
  void *grubase ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned int tmp___1 ;
  unsigned long tmp___2 ;

  {
  {
#line 124
  uhdr = (struct gru_dump_context_header *)ubuf;
#line 127
  cbrcnt = 0;
#line 127
  dsrcnt = 0;
#line 127
  bytes = 0;
#line 127
  ret = 0;
#line 130
  __memset((void *)(& hdr), 0, 32UL);
#line 131
  grubase = gru->gs_gru_base_vaddr;
#line 132
  cch = get_cch(grubase, ctxnum);
#line 133
  try = 0;
  }
#line 133
  goto ldv_32644;
  ldv_32643: 
  {
#line 134
  cch_locked = trylock_cch_handle(cch);
  }
#line 135
  if (cch_locked != 0) {
#line 136
    goto ldv_32642;
  } else {

  }
  {
#line 137
  msleep(1U);
#line 133
  try = try + 1;
  }
  ldv_32644: ;
#line 133
  if (try <= 9) {
#line 135
    goto ldv_32643;
  } else {

  }
  ldv_32642: 
  {
#line 140
  ubuf = ubuf + 32UL;
#line 141
  ubufcch = (struct gru_context_configuration_handle *)ubuf;
#line 142
  tmp = gru_user_copy_handle(& ubuf, (void *)cch);
  }
#line 142
  if (tmp != 0) {
#line 143
    if (cch_locked != 0) {
      {
#line 144
      unlock_cch_handle(cch);
      }
    } else {

    }
#line 145
    return (-14);
  } else {

  }
#line 147
  if (cch_locked != 0) {
#line 148
    ubufcch->delresp = 0U;
  } else {

  }
#line 149
  bytes = 96;
#line 151
  if (cch_locked != 0 || (int )((signed char )lock_cch) == 0) {
#line 152
    gts = gru->gs_gts[ctxnum];
#line 153
    if ((unsigned long )gts != (unsigned long )((struct gru_thread_state *)0) && (unsigned long )gts->ts_vma != (unsigned long )((struct vm_area_struct *)0)) {
#line 154
      hdr.pid = gts->ts_tgid_owner;
#line 155
      hdr.vaddr = (gts->ts_vma)->vm_start;
    } else {

    }
#line 157
    if ((unsigned int )*((unsigned char *)cch + 2UL) != 0U) {
      {
#line 158
      tmp___0 = __arch_hweight64((__u64 )cch->cbr_allocation_map);
#line 158
      cbrcnt = (int )((unsigned int )tmp___0 * 2U);
      }
#line 160
      if ((int )((signed char )data_opt) != 0) {
        {
#line 160
        tmp___1 = __arch_hweight32(cch->dsr_allocation_map);
#line 160
        dsrcnt = (int )(tmp___1 * 16U);
        }
      } else {
#line 160
        dsrcnt = 0;
      }
    } else {

    }
#line 163
    bytes = bytes + (cbrcnt * 3 + dsrcnt) * 64;
#line 164
    if ((long )bytes > (long )ubufend - (long )ubuf) {
#line 165
      ret = -27;
    } else {
      {
#line 167
      ret = gru_dump_context_data(grubase, cch, ubuf, ctxnum, dsrcnt, (int )flush_cbrs);
      }
    }
  } else {

  }
#line 170
  if (cch_locked != 0) {
    {
#line 171
    unlock_cch_handle(cch);
    }
  } else {

  }
#line 172
  if (ret != 0) {
#line 173
    return (ret);
  } else {

  }
  {
#line 175
  hdr.magic = 880061292U;
#line 176
  hdr.gid = (unsigned int )gru->gs_gid;
#line 177
  hdr.ctxnum = (unsigned char )ctxnum;
#line 178
  hdr.cbrcnt = (unsigned char )cbrcnt;
#line 179
  hdr.dsrcnt = (unsigned char )dsrcnt;
#line 180
  hdr.cch_locked = cch_locked;
#line 181
  tmp___2 = copy_to_user((void *)uhdr, (void const   *)(& hdr), 32UL);
  }
#line 181
  if (tmp___2 != 0UL) {
#line 182
    return (-14);
  } else {

  }
#line 184
  return (bytes);
}
}
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/misc/sgi-gru/grukdump.c"
int gru_dump_chiplet_request(unsigned long arg ) 
{ 
  struct gru_state *gru ;
  struct gru_dump_chiplet_state_req req ;
  void *ubuf ;
  void *ubufend ;
  int ctxnum ;
  int ret ;
  int cnt ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 193
  cnt = 0;
#line 195
  tmp = copy_from_user((void *)(& req), (void const   *)arg, 56UL);
  }
#line 195
  if (tmp != 0UL) {
#line 196
    return (-14);
  } else {

  }
#line 199
  if (req.gid >= gru_max_gids) {
#line 200
    return (-22);
  } else {

  }
  {
#line 202
  gru = (unsigned long )gru_base[req.gid / 2U] != (unsigned long )((struct gru_blade_state *)0) ? (struct gru_state *)(& (gru_base[req.gid / 2U])->bs_grus) + ((unsigned long )req.gid & 1UL) : (struct gru_state *)0;
#line 203
  ubuf = req.buf;
#line 204
  ubufend = req.buf + req.buflen;
#line 206
  ret = gru_dump_tfm(gru, ubuf, ubufend);
  }
#line 207
  if (ret < 0) {
#line 208
    goto fail;
  } else {

  }
  {
#line 209
  ubuf = ubuf + (unsigned long )ret;
#line 211
  ret = gru_dump_tgh(gru, ubuf, ubufend);
  }
#line 212
  if (ret < 0) {
#line 213
    goto fail;
  } else {

  }
#line 214
  ubuf = ubuf + (unsigned long )ret;
#line 216
  ctxnum = 0;
#line 216
  goto ldv_32657;
  ldv_32656: ;
#line 217
  if (req.ctxnum == ctxnum || req.ctxnum < 0) {
    {
#line 218
    ret = gru_dump_context(gru, ctxnum, ubuf, ubufend, (int )req.data_opt, (int )req.lock_cch,
                           (int )req.flush_cbrs);
    }
#line 221
    if (ret < 0) {
#line 222
      goto fail;
    } else {

    }
#line 223
    ubuf = ubuf + (unsigned long )ret;
#line 224
    cnt = cnt + 1;
  } else {

  }
#line 216
  ctxnum = ctxnum + 1;
  ldv_32657: ;
#line 216
  if (ctxnum <= 15) {
#line 218
    goto ldv_32656;
  } else {

  }
  {
#line 228
  tmp___0 = copy_to_user((void *)arg, (void const   *)(& req), 56UL);
  }
#line 228
  if (tmp___0 != 0UL) {
#line 229
    return (-14);
  } else {

  }
#line 230
  return (cnt);
  fail: ;
#line 233
  return (ret);
}
}
#line 1318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grukdump.c.aux"
static unsigned long ldv_find_first_bit_92(unsigned long const   *addr , unsigned long size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1321
  tmp = ldv_linux_lib_find_bit_find_first_bit(size);
  }
#line 1321
  return (tmp);
}
}
#line 1324 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/weaver/.tmp_grukdump.c.aux"
static unsigned long ldv_find_next_bit_93(unsigned long const   *addr , unsigned long size ,
                                          unsigned long offset ) 
{ 
  unsigned long tmp ;

  {
  {
#line 1327
  tmp = ldv_linux_lib_find_bit_find_next_bit(size, offset);
  }
#line 1327
  return (tmp);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/irq.linux_alloc_irq.bk.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) ;
#line 50 "/home/ubuntu/klever-work/linux/ldv/irq.h"
bool ldv_in_interrupt_context(void) ;
#line 24 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 27
  tmp = ldv_in_interrupt_context();
  }
#line 27
  if (tmp) {
#line 27
    tmp___0 = 0;
  } else {
#line 27
    tmp___0 = 1;
  }
  {
#line 27
  ldv_assert_linux_alloc_irq__wrong_flags(tmp___0 || flags == 32U);
  }
#line 28
  return;
}
}
#line 31 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) 
{ 
  bool tmp ;

  {
  {
#line 33
  tmp = ldv_in_interrupt_context();
  }
#line 33
  if ((int )tmp) {
    {
#line 36
    ldv_assert_linux_alloc_irq__nonatomic(0);
    }
  } else {

  }
#line 37
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/spinlock.linux_alloc_spinlock.bk.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
int ldv_exclusive_spin_is_locked(void) ;
#line 25 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_flags(gfp_t flags ) 
{ 
  int tmp ;

  {
#line 27
  if (flags != 32U && flags != 0U) {
    {
#line 29
    tmp = ldv_exclusive_spin_is_locked();
#line 29
    ldv_assert_linux_alloc_spinlock__wrong_flags(tmp == 0);
    }
  } else {

  }
#line 30
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_nonatomic(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_exclusive_spin_is_locked();
#line 37
  ldv_assert_linux_alloc_spinlock__nonatomic(tmp == 0);
  }
#line 38
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/usb lock.linux_alloc_usb_lock.bk.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_lock  =    1;
#line 26 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 28
  if (ldv_linux_alloc_usb_lock_lock == 2) {
    {
#line 31
    ldv_assert_linux_alloc_usb_lock__wrong_flags(flags == 16U || flags == 32U);
    }
  } else {

  }
#line 32
  return;
}
}
#line 36 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_alloc_usb_lock__nonatomic(ldv_linux_alloc_usb_lock_lock == 1);
  }
#line 40
  return;
}
}
#line 43 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_lock_device(void) 
{ 


  {
#line 46
  ldv_linux_alloc_usb_lock_lock = 2;
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_trylock_device(void) 
{ 
  int tmp ;

  {
#line 52
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 52
    tmp = ldv_undef_int();
    }
#line 52
    if (tmp != 0) {
#line 55
      ldv_linux_alloc_usb_lock_lock = 2;
#line 57
      return (1);
    } else {
#line 62
      return (0);
    }
  } else {
#line 62
    return (0);
  }
}
}
#line 67 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_lock_device_for_reset(void) 
{ 
  int tmp ;

  {
#line 69
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 69
    tmp = ldv_undef_int();
    }
#line 69
    if (tmp != 0) {
#line 72
      ldv_linux_alloc_usb_lock_lock = 2;
#line 74
      return (0);
    } else {
#line 79
      return (-1);
    }
  } else {
#line 79
    return (-1);
  }
}
}
#line 84 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_unlock_device(void) 
{ 


  {
#line 87
  ldv_linux_alloc_usb_lock_lock = 1;
#line 88
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 23
  v->counter = v->counter + i;
#line 24
  return;
}
}
#line 27 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 29
  v->counter = v->counter - i;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_sub_and_test(int i , atomic_t *v ) 
{ 


  {
#line 35
  v->counter = v->counter - i;
#line 36
  if (v->counter != 0) {
#line 37
    return (0);
  } else {

  }
#line 39
  return (1);
}
}
#line 43 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) 
{ 


  {
#line 45
  v->counter = v->counter + 1;
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_dec(atomic_t *v ) 
{ 


  {
#line 51
  v->counter = v->counter - 1;
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_dec_and_test(atomic_t *v ) 
{ 


  {
#line 57
  v->counter = v->counter - 1;
#line 58
  if (v->counter != 0) {
#line 59
    return (0);
  } else {

  }
#line 61
  return (1);
}
}
#line 65 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_and_test(atomic_t *v ) 
{ 


  {
#line 67
  v->counter = v->counter + 1;
#line 68
  if (v->counter != 0) {
#line 69
    return (0);
  } else {

  }
#line 71
  return (1);
}
}
#line 75 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) 
{ 


  {
#line 77
  v->counter = v->counter + i;
#line 78
  return (v->counter);
}
}
#line 82 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_negative(int i , atomic_t *v ) 
{ 


  {
#line 84
  v->counter = v->counter + i;
#line 85
  return (v->counter < 0);
}
}
#line 89 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_short(short *v ) 
{ 


  {
#line 91
  *v = (short )((unsigned int )((unsigned short )*v) + 1U);
#line 92
  return ((int )*v);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/io.linux_arch_io.bk.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/verifier/nondet.h"
void *ldv_undef_ptr(void) ;
#line 22 "/home/ubuntu/klever-work/linux/arch/io.c"
int ldv_linux_arch_io_iomem  =    0;
#line 25 "/home/ubuntu/klever-work/linux/arch/io.c"
void *ldv_linux_arch_io_io_mem_remap(void) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_undef_ptr();
#line 27
  ptr = tmp;
  }
#line 29
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 31
    ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem + 1;
#line 33
    return (ptr);
  } else {

  }
#line 36
  return (ptr);
}
}
#line 40 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_io_mem_unmap(void) 
{ 


  {
  {
#line 43
  ldv_assert_linux_arch_io__less_initial_decrement(ldv_linux_arch_io_iomem > 0);
#line 45
  ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem - 1;
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_arch_io__more_initial_at_exit(ldv_linux_arch_io_iomem == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/genhd.linux_block_genhd.bk.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) ;
#line 2
void ldv_assert_linux_block_genhd__double_allocation(int expr ) ;
#line 3
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) ;
#line 4
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) ;
#line 31 "/home/ubuntu/klever-work/linux/block/genhd.c"
static int ldv_linux_block_genhd_disk_state  =    0;
#line 34 "/home/ubuntu/klever-work/linux/block/genhd.c"
struct gendisk *ldv_linux_block_genhd_alloc_disk(void) 
{ 
  struct gendisk *res ;
  void *tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ptr();
#line 39
  res = (struct gendisk *)tmp;
#line 37
  ldv_assert_linux_block_genhd__double_allocation(ldv_linux_block_genhd_disk_state == 0);
  }
#line 41
  if ((unsigned long )res != (unsigned long )((struct gendisk *)0)) {
#line 43
    ldv_linux_block_genhd_disk_state = 1;
#line 45
    return (res);
  } else {

  }
#line 48
  return (res);
}
}
#line 52 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_add_disk(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_block_genhd__use_before_allocation(ldv_linux_block_genhd_disk_state == 1);
#line 57
  ldv_linux_block_genhd_disk_state = 2;
  }
#line 58
  return;
}
}
#line 61 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_del_gendisk(void) 
{ 


  {
  {
#line 64
  ldv_assert_linux_block_genhd__delete_before_add(ldv_linux_block_genhd_disk_state == 2);
#line 66
  ldv_linux_block_genhd_disk_state = 1;
  }
#line 67
  return;
}
}
#line 70 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_put_disk(struct gendisk *disk ) 
{ 


  {
#line 72
  if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
    {
#line 74
    ldv_assert_linux_block_genhd__free_before_allocation(ldv_linux_block_genhd_disk_state > 0);
#line 76
    ldv_linux_block_genhd_disk_state = 0;
    }
  } else {

  }
#line 78
  return;
}
}
#line 81 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_check_final_state(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_block_genhd__more_initial_at_exit(ldv_linux_block_genhd_disk_state == 0);
  }
#line 85
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/queue.linux_block_queue.bk.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) ;
#line 2
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/block/queue.c"
static int ldv_linux_block_queue_queue_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/block/queue.c"
struct request_queue *ldv_linux_block_queue_request_queue(void) 
{ 
  struct request_queue *res ;
  void *tmp ;

  {
  {
#line 38
  tmp = ldv_undef_ptr();
#line 38
  res = (struct request_queue *)tmp;
#line 36
  ldv_assert_linux_block_queue__double_allocation(ldv_linux_block_queue_queue_state == 0);
  }
#line 40
  if ((unsigned long )res != (unsigned long )((struct request_queue *)0)) {
#line 42
    ldv_linux_block_queue_queue_state = 1;
#line 44
    return (res);
  } else {

  }
#line 47
  return (res);
}
}
#line 51 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_blk_cleanup_queue(void) 
{ 


  {
  {
#line 54
  ldv_assert_linux_block_queue__use_before_allocation(ldv_linux_block_queue_queue_state == 1);
#line 56
  ldv_linux_block_queue_queue_state = 0;
  }
#line 57
  return;
}
}
#line 60 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_check_final_state(void) 
{ 


  {
  {
#line 63
  ldv_assert_linux_block_queue__more_initial_at_exit(ldv_linux_block_queue_queue_state == 0);
  }
#line 64
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/request.linux_block_request.bk.c"
void ldv_assert_linux_block_request__double_get(int expr ) ;
#line 2
void ldv_assert_linux_block_request__double_put(int expr ) ;
#line 3
void ldv_assert_linux_block_request__get_at_exit(int expr ) ;
#line 21 "/home/ubuntu/klever-work/linux/ldv/err.h"
long ldv_is_err(void const   *ptr ) ;
#line 32 "/home/ubuntu/klever-work/linux/block/request.c"
int ldv_linux_block_request_blk_rq  =    0;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_get_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;

  {
  {
#line 40
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 43
  tmp = ldv_undef_ptr();
#line 43
  res = (struct request *)tmp;
  }
#line 46
  if ((mask == 16U || mask == 208U) || mask == 16U) {
    {
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
    }
  } else {

  }
#line 49
  if ((unsigned long )res != (unsigned long )((struct request *)0)) {
#line 51
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 54
  return (res);
}
}
#line 58 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_make_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 63
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 66
  tmp = ldv_undef_ptr();
#line 66
  res = (struct request *)tmp;
#line 67
  ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
  }
#line 70
  if (tmp___0 == 0L) {
#line 72
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 75
  return (res);
}
}
#line 79 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_put_blk_rq(void) 
{ 


  {
  {
#line 82
  ldv_assert_linux_block_request__double_put(ldv_linux_block_request_blk_rq == 1);
#line 84
  ldv_linux_block_request_blk_rq = 0;
  }
#line 85
  return;
}
}
#line 88 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_block_request__get_at_exit(ldv_linux_block_request_blk_rq == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/class.linux_drivers_base_class.bk.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_nonpositive(void) ;
#line 33 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_usb_gadget_class  =    0;
#line 36 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void *ldv_linux_drivers_base_class_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 41
  is_got = ldv_undef_ptr();
#line 44
  ldv_assume((int )((long )is_got));
#line 47
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 47
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 52
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 56
  return (is_got);
}
}
#line 60 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 65
  is_reg = ldv_undef_int_nonpositive();
  }
#line 68
  if (is_reg == 0) {
    {
#line 71
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 73
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 77
  return (is_reg);
}
}
#line 81 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_unregister_class(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_drivers_base_class__double_deregistration(ldv_linux_drivers_base_class_usb_gadget_class == 1);
#line 86
  ldv_linux_drivers_base_class_usb_gadget_class = 0;
  }
#line 87
  return;
}
}
#line 89 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 91
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 92
    return;
  } else {
    {
#line 91
    tmp = ldv_is_err((void const   *)cls);
    }
#line 91
    if (tmp != 0L) {
#line 92
      return;
    } else {

    }
  }
  {
#line 93
  ldv_linux_drivers_base_class_unregister_class();
  }
#line 94
  return;
}
}
#line 97 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_check_final_state(void) 
{ 


  {
  {
#line 100
  ldv_assert_linux_drivers_base_class__registered_at_exit(ldv_linux_drivers_base_class_usb_gadget_class == 0);
  }
#line 101
  return;
}
}
#line 35 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 26 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 28
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 29
    return ((dev->p)->driver_data);
  } else {

  }
#line 30
  return ((void *)0);
}
}
#line 39 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 41
  tmp = ldv_xzalloc(8UL);
#line 41
  dev->p = (struct device_private *)tmp;
#line 42
  (dev->p)->driver_data = data;
  }
#line 43
  return (0);
}
}
#line 31 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/ubuntu/klever-work/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 2176UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)master + 1U);
  }
#line 34
  return (master);
}
}
#line 20 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/ubuntu/klever-work/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/ubuntu/klever-work/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/char_dev.linux_fs_char_dev.bk.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_usb_gadget_chrdev  =    0;
#line 33 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 38
  is_reg = ldv_undef_int_nonpositive();
  }
#line 41
  if (is_reg == 0) {
    {
#line 43
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 45
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
#line 46
    if (major == 0) {
      {
#line 48
      is_reg = ldv_undef_int();
#line 49
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 54
  return (is_reg);
}
}
#line 58 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 70
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
  } else {

  }
#line 74
  return (is_reg);
}
}
#line 78 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_unregister_chrdev_region(void) 
{ 


  {
  {
#line 81
  ldv_assert_linux_fs_char_dev__double_deregistration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 1);
#line 83
  ldv_linux_fs_char_dev_usb_gadget_chrdev = 0;
  }
#line 84
  return;
}
}
#line 87 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_check_final_state(void) 
{ 


  {
  {
#line 90
  ldv_assert_linux_fs_char_dev__registered_at_exit(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
  }
#line 91
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/sysfs.linux_fs_sysfs.bk.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs  =    0;
#line 25 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs_create_group(void) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 28
  tmp = ldv_undef_int_nonpositive();
#line 28
  res = tmp;
  }
#line 30
  if (res == 0) {
#line 32
    ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs + 1;
#line 34
    return (0);
  } else {

  }
#line 37
  return (res);
}
}
#line 41 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_sysfs_remove_group(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_fs_sysfs__less_initial_decrement(ldv_linux_fs_sysfs_sysfs > 0);
#line 46
  ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs - 1;
  }
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_check_final_state(void) 
{ 


  {
  {
#line 53
  ldv_assert_linux_fs_sysfs__more_initial_at_exit(ldv_linux_fs_sysfs_sysfs == 0);
  }
#line 54
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/rwlock.linux_kernel_locking_rwlock.bk.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) ;
#line 6
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_rlock  =    1;
#line 25 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_wlock  =    1;
#line 28 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_lock(void) 
{ 


  {
  {
#line 31
  ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 33
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
  }
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_unlock(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(ldv_linux_kernel_locking_rwlock_rlock > 1);
#line 42
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + -1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_lock(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_locking_rwlock__double_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 51
  ldv_linux_kernel_locking_rwlock_wlock = 2;
  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_unlock(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(ldv_linux_kernel_locking_rwlock_wlock != 1);
#line 60
  ldv_linux_kernel_locking_rwlock_wlock = 1;
  }
#line 61
  return;
}
}
#line 64 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_read_trylock(void) 
{ 
  int tmp ;

  {
#line 67
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 67
    tmp = ldv_undef_int();
    }
#line 67
    if (tmp != 0) {
#line 69
      ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
#line 71
      return (1);
    } else {
#line 75
      return (0);
    }
  } else {
#line 75
    return (0);
  }
}
}
#line 80 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_write_trylock(void) 
{ 
  int tmp ;

  {
#line 83
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 83
    tmp = ldv_undef_int();
    }
#line 83
    if (tmp != 0) {
#line 85
      ldv_linux_kernel_locking_rwlock_wlock = 2;
#line 87
      return (1);
    } else {
#line 91
      return (0);
    }
  } else {
#line 91
    return (0);
  }
}
}
#line 96 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_check_final_state(void) 
{ 


  {
  {
#line 99
  ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(ldv_linux_kernel_locking_rwlock_rlock == 1);
#line 101
  ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(ldv_linux_kernel_locking_rwlock_wlock == 1);
  }
#line 102
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/module.linux_kernel_module.bk.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_module_refcounter  =    1;
#line 27 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_get(struct module *module ) 
{ 


  {
#line 30
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 32
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
  } else {

  }
#line 33
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_try_module_get(struct module *module ) 
{ 
  int tmp ;

  {
#line 40
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 42
    tmp = ldv_undef_int();
    }
#line 42
    if (tmp == 1) {
#line 44
      ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
#line 46
      return (1);
    } else {
#line 50
      return (0);
    }
  } else {

  }
#line 51
  return (0);
}
}
#line 56 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put(struct module *module ) 
{ 


  {
#line 59
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 61
    ldv_assert_linux_kernel_module__less_initial_decrement(ldv_linux_kernel_module_module_refcounter > 1);
#line 63
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter - 1;
    }
  } else {

  }
#line 65
  return;
}
}
#line 68 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put_and_exit(void) 
{ 


  {
  {
#line 71
  ldv_linux_kernel_module_module_put((struct module *)1);
  }
  LDV_LINUX_KERNEL_MODULE_STOP: ;
#line 73
  goto LDV_LINUX_KERNEL_MODULE_STOP;
}
}
#line 77 "/home/ubuntu/klever-work/linux/kernel/module.c"
unsigned int ldv_linux_kernel_module_module_refcount(void) 
{ 


  {
#line 80
  return ((unsigned int )(ldv_linux_kernel_module_module_refcounter + -1));
}
}
#line 84 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_check_final_state(void) 
{ 


  {
  {
#line 87
  ldv_assert_linux_kernel_module__more_initial_at_exit(ldv_linux_kernel_module_module_refcounter == 1);
  }
#line 88
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/srcu.linux_kernel_rcu_srcu.bk.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
int ldv_linux_kernel_rcu_srcu_srcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_srcu__more_unlocks(ldv_linux_kernel_rcu_srcu_srcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/lock bh.linux_kernel_rcu_update_lock_bh.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
int ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_lock_bh(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_unlock_bh(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/lock sched.linux_kernel_rcu_update_lock_sched.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
int ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_lock_sched(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_unlock_sched(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/lock.linux_kernel_rcu_update_lock.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
int ldv_linux_kernel_rcu_update_lock_rcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(ldv_linux_kernel_rcu_update_lock_rcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 53
  return;
}
}
#line 67 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_post_probe(int probe_ret_val ) ;
#line 21 "/home/ubuntu/klever-work/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 23
  ldv_assume(val <= 0);
  }
#line 24
  return (val);
}
}
#line 31 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 45
  return (tmp);
}
}
#line 25 "/home/ubuntu/klever-work/linux/ldv/irq.c"
static bool __ldv_in_interrupt_context  =    0;
#line 27 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_interrupt_context(void) 
{ 


  {
#line 29
  __ldv_in_interrupt_context = 1;
#line 30
  return;
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_process_context(void) 
{ 


  {
#line 34
  __ldv_in_interrupt_context = 0;
#line 35
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/irq.c"
bool ldv_in_interrupt_context(void) 
{ 


  {
#line 39
  return (__ldv_in_interrupt_context);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/find_bit.linux_lib_find_bit.bk.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.h"
unsigned long ldv_undef_ulong(void) ;
#line 24 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_next_bit(unsigned long size , unsigned long offset ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 29
  tmp = ldv_undef_ulong();
#line 29
  nondet = tmp;
#line 27
  ldv_assert_linux_lib_find_bit__offset_out_of_range(offset <= size);
#line 30
  ldv_assume(nondet <= size);
#line 31
  ldv_assume(1);
  }
#line 32
  return (nondet);
}
}
#line 36 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_first_bit(unsigned long size ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ulong();
#line 39
  nondet = tmp;
#line 40
  ldv_assume(nondet <= size);
#line 41
  ldv_assume(1);
  }
#line 42
  return (nondet);
}
}
#line 46 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
void ldv_linux_lib_find_bit_initialize(void) 
{ 


  {
  {
#line 48
  ldv_assume(nr_cpu_ids > 0);
  }
#line 49
  return;
}
}
#line 24 "/home/ubuntu/klever-work/linux/mm/kzalloc.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 28
  ldv_check_alloc_flags(flags);
#line 29
  res = ldv_zalloc(size);
#line 30
  ldv_after_alloc(res);
  }
#line 32
  return (res);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/sdio_func.linux_mmc_sdio_func.bk.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) ;
#line 2
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) ;
#line 3
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) ;
#line 25 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
unsigned short ldv_linux_mmc_sdio_func_sdio_element  =    0U;
#line 28 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_context(struct sdio_func *func ) 
{ 


  {
  {
#line 31
  ldv_assert_linux_mmc_sdio_func__wrong_params((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
  }
#line 32
  return;
}
}
#line 35 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_claim_host(struct sdio_func *func ) 
{ 


  {
  {
#line 38
  ldv_assert_linux_mmc_sdio_func__double_claim((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
#line 41
  ldv_linux_mmc_sdio_func_sdio_element = (unsigned short )((func->card)->host)->index;
  }
#line 42
  return;
}
}
#line 45 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_release_host(struct sdio_func *func ) 
{ 


  {
  {
#line 48
  ldv_assert_linux_mmc_sdio_func__release_without_claim((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
#line 51
  ldv_linux_mmc_sdio_func_sdio_element = 0U;
  }
#line 52
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_mmc_sdio_func__unreleased_at_exit((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/register.linux_net_register.bk.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) ;
#line 105 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_register_netdev(void) ;
#line 30 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_linux_net_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_pre_register_netdev(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_net_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_net_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_net_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_net_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_net_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/rtnetlink.linux_net_rtnetlink.bk.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) ;
#line 2
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) ;
#line 3
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int rtnllocknumber  =    0;
#line 29 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_unlock(void) 
{ 


  {
  {
#line 32
  ldv_assert_linux_net_rtnetlink__double_unlock(rtnllocknumber == 1);
#line 34
  rtnllocknumber = 0;
  }
#line 35
  return;
}
}
#line 38 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_lock(void) 
{ 


  {
  {
#line 41
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 43
  rtnllocknumber = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_before_ieee80211_unregister_hw(void) 
{ 


  {
  {
#line 50
  ldv_linux_net_rtnetlink_past_rtnl_lock();
#line 52
  ldv_linux_net_rtnetlink_past_rtnl_unlock();
  }
#line 53
  return;
}
}
#line 56 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_is_locked(void) 
{ 
  int tmp ;

  {
#line 59
  if (rtnllocknumber != 0) {
#line 61
    return (rtnllocknumber);
  } else {
    {
#line 63
    tmp = ldv_undef_int();
    }
#line 63
    if (tmp != 0) {
#line 65
      return (1);
    } else {
#line 68
      return (0);
    }
  }
}
}
#line 72 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_trylock(void) 
{ 
  int tmp ;

  {
  {
#line 75
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 77
  tmp = ldv_linux_net_rtnetlink_rtnl_is_locked();
  }
#line 77
  if (tmp == 0) {
#line 79
    rtnllocknumber = 1;
#line 81
    return (1);
  } else {
#line 84
    return (0);
  }
}
}
#line 88 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_net_rtnetlink__lock_on_exit(rtnllocknumber == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/sock.linux_net_sock.bk.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) ;
#line 2
void ldv_assert_linux_net_sock__double_release(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/net/sock.c"
int locksocknumber  =    0;
#line 27 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_past_lock_sock_nested(void) 
{ 


  {
#line 30
  locksocknumber = locksocknumber + 1;
#line 31
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/net/sock.c"
bool ldv_linux_net_sock_lock_sock_fast(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_undef_int();
  }
#line 37
  if (tmp != 0) {
#line 39
    locksocknumber = locksocknumber + 1;
#line 41
    return (1);
  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_unlock_sock_fast(void) 
{ 


  {
  {
#line 51
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 53
  locksocknumber = locksocknumber - 1;
  }
#line 54
  return;
}
}
#line 57 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_before_release_sock(void) 
{ 


  {
  {
#line 60
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 62
  locksocknumber = locksocknumber - 1;
  }
#line 63
  return;
}
}
#line 66 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_check_final_state(void) 
{ 


  {
  {
#line 69
  ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(locksocknumber == 0);
  }
#line 70
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/coherent.linux_usb_coherent.bk.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/coherent.c"
int ldv_linux_usb_coherent_coherent_state  =    0;
#line 27 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void *ldv_linux_usb_coherent_usb_alloc_coherent(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 30
  tmp = ldv_undef_ptr();
#line 30
  arbitrary_memory = tmp;
  }
#line 32
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 34
    return (arbitrary_memory);
  } else {

  }
#line 37
  ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + 1;
#line 39
  return (arbitrary_memory);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_usb_free_coherent(void *addr ) 
{ 


  {
#line 45
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 47
    ldv_assert_linux_usb_coherent__less_initial_decrement(ldv_linux_usb_coherent_coherent_state > 0);
#line 49
    ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + -1;
    }
  } else {

  }
#line 51
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_usb_coherent__more_initial_at_exit(ldv_linux_usb_coherent_coherent_state == 0);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/dev.linux_usb_dev.bk.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_usb_dev__probe_failed(int expr ) ;
#line 4
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/dev.c"
ldv_map LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS  ;
#line 27 "/home/ubuntu/klever-work/linux/usb/dev.c"
struct usb_device *ldv_linux_usb_dev_usb_get_dev(struct usb_device *dev ) 
{ 


  {
#line 30
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
#line 32
    LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0 ? LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + 1 : 1;
  } else {

  }
#line 39
  return (dev);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_usb_put_dev(struct usb_device *dev ) 
{ 


  {
#line 46
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
    {
#line 48
    ldv_assert_linux_usb_dev__unincremented_counter_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0);
#line 50
    ldv_assert_linux_usb_dev__less_initial_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 0);
    }
#line 54
    if (LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 1) {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + -1;
    } else {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
    }
  } else {

  }
#line 56
  return;
}
}
#line 59 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_return_value_probe(int retval ) 
{ 


  {
#line 62
  if (retval != 0) {
    {
#line 64
    ldv_assert_linux_usb_dev__probe_failed(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
    }
  } else {

  }
#line 65
  return;
}
}
#line 69 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_initialize(void) 
{ 


  {
#line 72
  LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
#line 73
  return;
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_final_state(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_dev__more_initial_at_exit(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
  }
#line 80
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/gadget.linux_usb_gadget.bk.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) ;
#line 2
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) ;
#line 3
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) ;
#line 4
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) ;
#line 5
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) ;
#line 6
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) ;
#line 7
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) ;
#line 33 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_usb_gadget  =    0;
#line 37 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void *ldv_linux_usb_gadget_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 42
  is_got = ldv_undef_ptr();
#line 45
  ldv_assume((int )((long )is_got));
#line 48
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 48
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 54
  return (is_got);
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 72
  return (is_reg);
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_class(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 80
  return;
}
}
#line 82 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 84
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 85
    return;
  } else {
    {
#line 84
    tmp = ldv_is_err((void const   *)cls);
    }
#line 84
    if (tmp != 0L) {
#line 85
      return;
    } else {

    }
  }
  {
#line 86
  ldv_linux_usb_gadget_unregister_class();
  }
#line 87
  return;
}
}
#line 90 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 95
  is_reg = ldv_undef_int_nonpositive();
  }
#line 98
  if (is_reg == 0) {
    {
#line 100
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
#line 101
    if (major == 0) {
      {
#line 103
      is_reg = ldv_undef_int();
#line 104
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 109
  return (is_reg);
}
}
#line 113 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 118
  is_reg = ldv_undef_int_nonpositive();
  }
#line 121
  if (is_reg == 0) {
    {
#line 123
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 127
  return (is_reg);
}
}
#line 131 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_chrdev_region(void) 
{ 


  {
  {
#line 134
  ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 135
  return;
}
}
#line 138 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_usb_gadget(void) 
{ 
  int is_reg ;

  {
  {
#line 143
  is_reg = ldv_undef_int_nonpositive();
  }
#line 146
  if (is_reg == 0) {
    {
#line 148
    ldv_assert_linux_usb_gadget__double_usb_gadget_registration(ldv_linux_usb_gadget_usb_gadget == 0);
#line 150
    ldv_linux_usb_gadget_usb_gadget = 1;
    }
  } else {

  }
#line 154
  return (is_reg);
}
}
#line 158 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_usb_gadget(void) 
{ 


  {
  {
#line 161
  ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(ldv_linux_usb_gadget_usb_gadget == 1);
#line 163
  ldv_linux_usb_gadget_usb_gadget = 0;
  }
#line 164
  return;
}
}
#line 167 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_check_final_state(void) 
{ 


  {
  {
#line 170
  ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 171
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/register.linux_usb_register.bk.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) ;
#line 90 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_usb_register_driver(void) ;
#line 30 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_linux_usb_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_pre_usb_register_driver(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_usb_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_usb_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_usb_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_usb_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_usb_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/urb.linux_usb_urb.bk.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/usb/urb.c"
int ldv_linux_usb_urb_urb_state  =    0;
#line 29 "/home/ubuntu/klever-work/linux/usb/urb.c"
struct urb *ldv_linux_usb_urb_usb_alloc_urb(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 32
  tmp = ldv_undef_ptr();
#line 32
  arbitrary_memory = tmp;
  }
#line 34
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 36
    return ((struct urb *)arbitrary_memory);
  } else {

  }
#line 39
  ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + 1;
#line 41
  return ((struct urb *)arbitrary_memory);
}
}
#line 45 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_usb_free_urb(struct urb *urb ) 
{ 


  {
#line 46
  if ((unsigned long )urb != (unsigned long )((struct urb *)0)) {
    {
#line 48
    ldv_assert_linux_usb_urb__less_initial_decrement(ldv_linux_usb_urb_urb_state > 0);
#line 50
    ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + -1;
    }
  } else {

  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_check_final_state(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_usb_urb__more_initial_at_exit(ldv_linux_usb_urb_urb_state == 0);
  }
#line 59
  return;
}
}
#line 24 "/home/ubuntu/klever-work/verifier/common.h"
extern void ldv_assert(char const   * , int  ) ;
#line 45
void __builtin_trap(void) ;
#line 23 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_assume(int expression ) 
{ 


  {
#line 25
  if (expression == 0) {
    ldv_assume_label: ;
#line 29
    goto ldv_assume_label;
  } else {

  }
#line 31
  return;
}
}
#line 33 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_stop(void) 
{ 


  {
  ldv_stop_label: ;
#line 36
  goto ldv_stop_label;
}
}
#line 43 "/home/ubuntu/klever-work/verifier/common.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 45
  return (exp);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/common.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 56
  ldv_assert("", 0);
  }
#line 57
  return;
}
}
#line 29 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 30
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 37
extern void *external_allocated_data(void) ;
#line 40
void *ldv_calloc_unknown_size(void) ;
#line 41
void *ldv_zalloc_unknown_size(void) ;
#line 47
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 25 "/home/ubuntu/klever-work/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 26
extern void *calloc(size_t  , size_t  ) ;
#line 27
extern void free(void * ) ;
#line 28
extern void *memset(void * , int  , size_t  ) ;
#line 30 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp___1 = ldv_undef_int();
  }
#line 32
  if (tmp___1 != 0) {
    {
#line 33
    tmp = malloc(size);
#line 33
    res = tmp;
#line 34
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    ldv_assume(tmp___0 == 0L);
    }
#line 36
    return (res);
  } else {
#line 39
    return ((void *)0);
  }
}
}
#line 43 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 48
    tmp___0 = ldv_is_err((void const   *)res);
#line 48
    ldv_assume(tmp___0 == 0L);
    }
#line 49
    return (res);
  } else {
#line 52
    return ((void *)0);
  }
}
}
#line 56 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = ldv_calloc(1UL, size);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/ubuntu/klever-work/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 63
  free(s);
  }
#line 64
  return;
}
}
#line 66 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 68
  tmp = malloc(size);
#line 68
  res = tmp;
#line 69
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
#line 70
  ldv_assume(tmp___0 == 0L);
  }
#line 71
  return (res);
}
}
#line 74 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 76
  tmp = calloc(1UL, size);
#line 76
  res = tmp;
#line 77
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 78
  tmp___0 = ldv_is_err((void const   *)res);
#line 78
  ldv_assume(tmp___0 == 0L);
  }
#line 79
  return (res);
}
}
#line 82 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = ldv_undef_int();
  }
#line 84
  if (tmp___1 != 0) {
    {
#line 85
    tmp = external_allocated_data();
#line 85
    res = tmp;
#line 86
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 87
    tmp___0 = ldv_is_err((void const   *)res);
#line 87
    ldv_assume(tmp___0 == 0L);
    }
#line 88
    return (res);
  } else {
#line 91
    return ((void *)0);
  }
}
}
#line 95 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 97
  tmp___1 = ldv_undef_int();
  }
#line 97
  if (tmp___1 != 0) {
    {
#line 98
    tmp = external_allocated_data();
#line 98
    res = tmp;
#line 99
    memset(res, 0, 8UL);
#line 100
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 101
    tmp___0 = ldv_is_err((void const   *)res);
#line 101
    ldv_assume(tmp___0 == 0L);
    }
#line 102
    return (res);
  } else {
#line 105
    return ((void *)0);
  }
}
}
#line 109 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 111
  tmp = ldv_calloc_unknown_size();
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 116
  tmp = external_allocated_data();
#line 116
  res = tmp;
#line 117
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 118
  tmp___0 = ldv_is_err((void const   *)res);
#line 118
  ldv_assume(tmp___0 == 0L);
  }
#line 119
  return (res);
}
}
#line 27 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_negative(void) ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern void *__VERIFIER_nondet_pointer(void) ;
#line 40 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = __VERIFIER_nondet_int();
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/ubuntu/klever-work/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = __VERIFIER_nondet_pointer();
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 49
  tmp = __VERIFIER_nondet_ulong();
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 54
  tmp = ldv_undef_int();
#line 54
  ret = tmp;
#line 55
  ldv_assume(ret < 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 61
  tmp = ldv_undef_int();
#line 61
  ret = tmp;
#line 62
  ldv_assume(ret <= 0);
  }
#line 63
  return (ret);
}
}
#line 32 "/home/ubuntu/klever-work/verifier/thread.h"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) ;
#line 35
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) ;
#line 38
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) ;
#line 41
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) ;
#line 27 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) 
{ 


  {
#line 29
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
    {
#line 30
    (*function)(data);
    }
  } else {

  }
#line 31
  return (0);
}
}
#line 35 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) 
{ 
  int i ;

  {
#line 39
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
#line 40
    i = 0;
#line 40
    goto ldv_1179;
    ldv_1178: 
    {
#line 41
    (*function)(data);
#line 40
    i = i + 1;
    }
    ldv_1179: ;
#line 40
    if (i < ldv_thread_set->number) {
#line 42
      goto ldv_1178;
    } else {

    }

  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) 
{ 


  {
#line 56
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/mutex.linux_kernel_locking_mutex.bk.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode  ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 33
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 35
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
  }
#line 36
  return;
}
}
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 42
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 44
  tmp = ldv_undef_int();
  }
#line 44
  if (tmp != 0) {
#line 46
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 48
    return (0);
  } else {
#line 52
    return (-4);
  }
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 60
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode) {
#line 62
    return (1);
  } else {
    {
#line 65
    tmp = ldv_undef_int();
    }
#line 65
    if (tmp != 0) {
#line 67
      return (1);
    } else {
#line 71
      return (0);
    }
  }
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 79
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 82
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(lock);
  }
#line 82
  if (tmp != 0) {
#line 84
    return (0);
  } else {
#line 88
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 90
    return (1);
  }
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt ,
                                                                              struct mutex *lock ) 
{ 


  {
#line 98
  cnt->counter = cnt->counter - 1;
#line 101
  if (cnt->counter != 0) {
#line 103
    return (0);
  } else {
    {
#line 106
    ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(lock);
    }
#line 108
    return (1);
  }
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 116
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 118
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
  }
#line 119
  return;
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock  ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 126
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 128
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
  }
#line 129
  return;
}
}
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 135
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 137
  tmp = ldv_undef_int();
  }
#line 137
  if (tmp != 0) {
#line 139
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 141
    return (0);
  } else {
#line 145
    return (-4);
  }
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 153
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock) {
#line 155
    return (1);
  } else {
    {
#line 158
    tmp = ldv_undef_int();
    }
#line 158
    if (tmp != 0) {
#line 160
      return (1);
    } else {
#line 164
      return (0);
    }
  }
}
}
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 172
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 175
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(lock);
  }
#line 175
  if (tmp != 0) {
#line 177
    return (0);
  } else {
#line 181
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 183
    return (1);
  }
}
}
#line 188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_lock(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ 


  {
#line 191
  cnt->counter = cnt->counter - 1;
#line 194
  if (cnt->counter != 0) {
#line 196
    return (0);
  } else {
    {
#line 199
    ldv_linux_kernel_locking_mutex_mutex_lock_lock(lock);
    }
#line 201
    return (1);
  }
}
}
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 209
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 211
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
  }
#line 212
  return;
}
}
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device  ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 219
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 221
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
  }
#line 222
  return;
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 228
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 230
  tmp = ldv_undef_int();
  }
#line 230
  if (tmp != 0) {
#line 232
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 234
    return (0);
  } else {
#line 238
    return (-4);
  }
}
}
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 246
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device) {
#line 248
    return (1);
  } else {
    {
#line 251
    tmp = ldv_undef_int();
    }
#line 251
    if (tmp != 0) {
#line 253
      return (1);
    } else {
#line 257
      return (0);
    }
  }
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 265
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 268
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(lock);
  }
#line 268
  if (tmp != 0) {
#line 270
    return (0);
  } else {
#line 274
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 276
    return (1);
  }
}
}
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt ,
                                                                             struct mutex *lock ) 
{ 


  {
#line 284
  cnt->counter = cnt->counter - 1;
#line 287
  if (cnt->counter != 0) {
#line 289
    return (0);
  } else {
    {
#line 292
    ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(lock);
    }
#line 294
    return (1);
  }
}
}
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 302
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 304
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state  ;
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 


  {
  {
#line 312
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state);
#line 314
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state = 1;
  }
#line 315
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 321
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state);
#line 323
  tmp = ldv_undef_int();
  }
#line 323
  if (tmp != 0) {
#line 325
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state = 1;
#line 327
    return (0);
  } else {
#line 331
    return (-4);
  }
}
}
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 339
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state) {
#line 341
    return (1);
  } else {
    {
#line 344
    tmp = ldv_undef_int();
    }
#line 344
    if (tmp != 0) {
#line 346
      return (1);
    } else {
#line 350
      return (0);
    }
  }
}
}
#line 355 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 358
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state);
#line 361
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_ts_ctxlock_of_gru_thread_state(lock);
  }
#line 361
  if (tmp != 0) {
#line 363
    return (0);
  } else {
#line 367
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state = 1;
#line 369
    return (1);
  }
}
}
#line 374 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_ts_ctxlock_of_gru_thread_state(atomic_t *cnt ,
                                                                                            struct mutex *lock ) 
{ 


  {
#line 377
  cnt->counter = cnt->counter - 1;
#line 380
  if (cnt->counter != 0) {
#line 382
    return (0);
  } else {
    {
#line 385
    ldv_linux_kernel_locking_mutex_mutex_lock_ts_ctxlock_of_gru_thread_state(lock);
    }
#line 387
    return (1);
  }
}
}
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_ts_ctxlock_of_gru_thread_state(struct mutex *lock ) 
{ 


  {
  {
#line 395
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state);
#line 397
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state = 0;
  }
#line 398
  return;
}
}
#line 400 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_initialize(void) 
{ 


  {
#line 403
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
#line 405
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
#line 407
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
#line 409
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state = 0;
#line 410
  return;
}
}
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_check_final_state(void) 
{ 


  {
  {
#line 416
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 418
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 420
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 422
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ts_ctxlock_of_gru_thread_state);
  }
#line 423
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/spinlock.linux_kernel_locking_spinlock.bk.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct  =    1;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 28
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 30
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 32
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
  }
#line 33
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 41
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 43
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 52
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 54
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 57
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 60
  if (is_spin_held_by_another_thread != 0) {
#line 62
    return (0);
  } else {
#line 66
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 68
    return (1);
  }
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 76
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 78
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
  }
#line 79
  return;
}
}
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 87
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 90
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 92
    return (0);
  } else {
#line 96
    return (1);
  }
}
}
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_alloc_lock_of_task_struct(void) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct();
  }
#line 104
  return (tmp == 0);
}
}
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 113
  is_spin_contended = ldv_undef_int();
  }
#line 116
  if (is_spin_contended != 0) {
#line 118
    return (0);
  } else {
#line 122
    return (1);
  }
}
}
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_alloc_lock_of_task_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 132
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 134
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 137
  atomic_value_after_dec = ldv_undef_int();
  }
#line 140
  if (atomic_value_after_dec == 0) {
#line 142
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 144
    return (1);
  } else {

  }
#line 148
  return (0);
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state  =    1;
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_bs_lock_of_gru_blade_state(void) 
{ 


  {
  {
#line 156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
#line 158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
#line 160
  ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state = 2;
  }
#line 161
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_bs_lock_of_gru_blade_state(void) 
{ 


  {
  {
#line 167
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 2);
#line 169
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 2);
#line 171
  ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state = 1;
  }
#line 172
  return;
}
}
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_bs_lock_of_gru_blade_state(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
#line 182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
#line 185
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 188
  if (is_spin_held_by_another_thread != 0) {
#line 190
    return (0);
  } else {
#line 194
    ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state = 2;
#line 196
    return (1);
  }
}
}
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_bs_lock_of_gru_blade_state(void) 
{ 


  {
  {
#line 204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
#line 206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
  }
#line 207
  return;
}
}
#line 210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_bs_lock_of_gru_blade_state(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 215
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 218
  if (ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1 && is_spin_held_by_another_thread == 0) {
#line 220
    return (0);
  } else {
#line 224
    return (1);
  }
}
}
#line 229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_bs_lock_of_gru_blade_state(void) 
{ 
  int tmp ;

  {
  {
#line 232
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_bs_lock_of_gru_blade_state();
  }
#line 232
  return (tmp == 0);
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_bs_lock_of_gru_blade_state(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 241
  is_spin_contended = ldv_undef_int();
  }
#line 244
  if (is_spin_contended != 0) {
#line 246
    return (0);
  } else {
#line 250
    return (1);
  }
}
}
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_bs_lock_of_gru_blade_state(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 260
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
#line 262
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
#line 265
  atomic_value_after_dec = ldv_undef_int();
  }
#line 268
  if (atomic_value_after_dec == 0) {
#line 270
    ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state = 2;
#line 272
    return (1);
  } else {

  }
#line 276
  return (0);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state  =    1;
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_gs_asid_lock_of_gru_state(void) 
{ 


  {
  {
#line 284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
#line 286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
#line 288
  ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state = 2;
  }
#line 289
  return;
}
}
#line 292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_gs_asid_lock_of_gru_state(void) 
{ 


  {
  {
#line 295
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 2);
#line 297
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 2);
#line 299
  ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state = 1;
  }
#line 300
  return;
}
}
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_gs_asid_lock_of_gru_state(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
#line 310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
#line 313
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 316
  if (is_spin_held_by_another_thread != 0) {
#line 318
    return (0);
  } else {
#line 322
    ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state = 2;
#line 324
    return (1);
  }
}
}
#line 329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_gs_asid_lock_of_gru_state(void) 
{ 


  {
  {
#line 332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
#line 334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
  }
#line 335
  return;
}
}
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_gs_asid_lock_of_gru_state(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 343
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 346
  if (ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1 && is_spin_held_by_another_thread == 0) {
#line 348
    return (0);
  } else {
#line 352
    return (1);
  }
}
}
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_gs_asid_lock_of_gru_state(void) 
{ 
  int tmp ;

  {
  {
#line 360
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_gs_asid_lock_of_gru_state();
  }
#line 360
  return (tmp == 0);
}
}
#line 364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_gs_asid_lock_of_gru_state(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 369
  is_spin_contended = ldv_undef_int();
  }
#line 372
  if (is_spin_contended != 0) {
#line 374
    return (0);
  } else {
#line 378
    return (1);
  }
}
}
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_gs_asid_lock_of_gru_state(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 388
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
#line 390
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
#line 393
  atomic_value_after_dec = ldv_undef_int();
  }
#line 396
  if (atomic_value_after_dec == 0) {
#line 398
    ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state = 2;
#line 400
    return (1);
  } else {

  }
#line 404
  return (0);
}
}
#line 406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state  =    1;
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_gs_lock_of_gru_state(void) 
{ 


  {
  {
#line 412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
#line 414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
#line 416
  ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state = 2;
  }
#line 417
  return;
}
}
#line 420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_gs_lock_of_gru_state(void) 
{ 


  {
  {
#line 423
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 2);
#line 425
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 2);
#line 427
  ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state = 1;
  }
#line 428
  return;
}
}
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_gs_lock_of_gru_state(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
#line 438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
#line 441
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 444
  if (is_spin_held_by_another_thread != 0) {
#line 446
    return (0);
  } else {
#line 450
    ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state = 2;
#line 452
    return (1);
  }
}
}
#line 457 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_gs_lock_of_gru_state(void) 
{ 


  {
  {
#line 460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
#line 462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
  }
#line 463
  return;
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_gs_lock_of_gru_state(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 471
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 474
  if (ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1 && is_spin_held_by_another_thread == 0) {
#line 476
    return (0);
  } else {
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_gs_lock_of_gru_state(void) 
{ 
  int tmp ;

  {
  {
#line 488
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_gs_lock_of_gru_state();
  }
#line 488
  return (tmp == 0);
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_gs_lock_of_gru_state(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 497
  is_spin_contended = ldv_undef_int();
  }
#line 500
  if (is_spin_contended != 0) {
#line 502
    return (0);
  } else {
#line 506
    return (1);
  }
}
}
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_gs_lock_of_gru_state(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 516
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
#line 518
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
#line 521
  atomic_value_after_dec = ldv_undef_int();
  }
#line 524
  if (atomic_value_after_dec == 0) {
#line 526
    ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state = 2;
#line 528
    return (1);
  } else {

  }
#line 532
  return (0);
}
}
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode  =    1;
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_i_lock_of_inode(void) 
{ 


  {
  {
#line 540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 544
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
  }
#line 545
  return;
}
}
#line 548 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_i_lock_of_inode(void) 
{ 


  {
  {
#line 551
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 553
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 555
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 1;
  }
#line 556
  return;
}
}
#line 559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 566
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 569
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 572
  if (is_spin_held_by_another_thread != 0) {
#line 574
    return (0);
  } else {
#line 578
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 580
    return (1);
  }
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_i_lock_of_inode(void) 
{ 


  {
  {
#line 588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 590
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
  }
#line 591
  return;
}
}
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 599
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 602
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1 && is_spin_held_by_another_thread == 0) {
#line 604
    return (0);
  } else {
#line 608
    return (1);
  }
}
}
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_i_lock_of_inode(void) 
{ 
  int tmp ;

  {
  {
#line 616
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode();
  }
#line 616
  return (tmp == 0);
}
}
#line 620 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_i_lock_of_inode(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 625
  is_spin_contended = ldv_undef_int();
  }
#line 628
  if (is_spin_contended != 0) {
#line 630
    return (0);
  } else {
#line 634
    return (1);
  }
}
}
#line 639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_i_lock_of_inode(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 644
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 646
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 649
  atomic_value_after_dec = ldv_undef_int();
  }
#line 652
  if (atomic_value_after_dec == 0) {
#line 654
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 656
    return (1);
  } else {

  }
#line 660
  return (0);
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock  =    1;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock(void) 
{ 


  {
  {
#line 668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 670
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 672
  ldv_linux_kernel_locking_spinlock_spin_lock = 2;
  }
#line 673
  return;
}
}
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock(void) 
{ 


  {
  {
#line 679
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 681
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 683
  ldv_linux_kernel_locking_spinlock_spin_lock = 1;
  }
#line 684
  return;
}
}
#line 687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 694
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 697
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 700
  if (is_spin_held_by_another_thread != 0) {
#line 702
    return (0);
  } else {
#line 706
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 708
    return (1);
  }
}
}
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock(void) 
{ 


  {
  {
#line 716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 718
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
  }
#line 719
  return;
}
}
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 727
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 730
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 1 && is_spin_held_by_another_thread == 0) {
#line 732
    return (0);
  } else {
#line 736
    return (1);
  }
}
}
#line 741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock(void) 
{ 
  int tmp ;

  {
  {
#line 744
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock();
  }
#line 744
  return (tmp == 0);
}
}
#line 748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 753
  is_spin_contended = ldv_undef_int();
  }
#line 756
  if (is_spin_contended != 0) {
#line 758
    return (0);
  } else {
#line 762
    return (1);
  }
}
}
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 772
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 774
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 777
  atomic_value_after_dec = ldv_undef_int();
  }
#line 780
  if (atomic_value_after_dec == 0) {
#line 782
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 784
    return (1);
  } else {

  }
#line 788
  return (0);
}
}
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN  =    1;
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 798
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 800
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
  }
#line 801
  return;
}
}
#line 804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 807
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 809
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 811
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 1;
  }
#line 812
  return;
}
}
#line 815 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 822
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 825
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 828
  if (is_spin_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 834
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 836
    return (1);
  }
}
}
#line 841 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 846
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
  }
#line 847
  return;
}
}
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 855
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 858
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1 && is_spin_held_by_another_thread == 0) {
#line 860
    return (0);
  } else {
#line 864
    return (1);
  }
}
}
#line 869 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int tmp ;

  {
  {
#line 872
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN();
  }
#line 872
  return (tmp == 0);
}
}
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 881
  is_spin_contended = ldv_undef_int();
  }
#line 884
  if (is_spin_contended != 0) {
#line 886
    return (0);
  } else {
#line 890
    return (1);
  }
}
}
#line 895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 900
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 902
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 905
  atomic_value_after_dec = ldv_undef_int();
  }
#line 908
  if (atomic_value_after_dec == 0) {
#line 910
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 912
    return (1);
  } else {

  }
#line 916
  return (0);
}
}
#line 918 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct  =    1;
#line 921 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_ms_asid_lock_of_gru_mm_struct(void) 
{ 


  {
  {
#line 924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
#line 926
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
#line 928
  ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct = 2;
  }
#line 929
  return;
}
}
#line 932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_ms_asid_lock_of_gru_mm_struct(void) 
{ 


  {
  {
#line 935
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 2);
#line 937
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 2);
#line 939
  ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct = 1;
  }
#line 940
  return;
}
}
#line 943 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_ms_asid_lock_of_gru_mm_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 948
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
#line 950
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
#line 953
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 956
  if (is_spin_held_by_another_thread != 0) {
#line 958
    return (0);
  } else {
#line 962
    ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct = 2;
#line 964
    return (1);
  }
}
}
#line 969 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_ms_asid_lock_of_gru_mm_struct(void) 
{ 


  {
  {
#line 972
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
#line 974
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
  }
#line 975
  return;
}
}
#line 978 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_ms_asid_lock_of_gru_mm_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 983
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 986
  if (ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 988
    return (0);
  } else {
#line 992
    return (1);
  }
}
}
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_ms_asid_lock_of_gru_mm_struct(void) 
{ 
  int tmp ;

  {
  {
#line 1000
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_ms_asid_lock_of_gru_mm_struct();
  }
#line 1000
  return (tmp == 0);
}
}
#line 1004 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_ms_asid_lock_of_gru_mm_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1009
  is_spin_contended = ldv_undef_int();
  }
#line 1012
  if (is_spin_contended != 0) {
#line 1014
    return (0);
  } else {
#line 1018
    return (1);
  }
}
}
#line 1023 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_ms_asid_lock_of_gru_mm_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1028
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
#line 1030
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
#line 1033
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1036
  if (atomic_value_after_dec == 0) {
#line 1038
    ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct = 2;
#line 1040
    return (1);
  } else {

  }
#line 1044
  return (0);
}
}
#line 1046 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data  =    1;
#line 1049 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1052
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1054
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1056
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
  }
#line 1057
  return;
}
}
#line 1060 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1063
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 1065
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 1067
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 1;
  }
#line 1068
  return;
}
}
#line 1071 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1076
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1078
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1081
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1084
  if (is_spin_held_by_another_thread != 0) {
#line 1086
    return (0);
  } else {
#line 1090
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 1092
    return (1);
  }
}
}
#line 1097 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 1100
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1102
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
  }
#line 1103
  return;
}
}
#line 1106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1111
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1114
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1 && is_spin_held_by_another_thread == 0) {
#line 1116
    return (0);
  } else {
#line 1120
    return (1);
  }
}
}
#line 1125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_node_size_lock_of_pglist_data(void) 
{ 
  int tmp ;

  {
  {
#line 1128
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data();
  }
#line 1128
  return (tmp == 0);
}
}
#line 1132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1137
  is_spin_contended = ldv_undef_int();
  }
#line 1140
  if (is_spin_contended != 0) {
#line 1142
    return (0);
  } else {
#line 1146
    return (1);
  }
}
}
#line 1151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_node_size_lock_of_pglist_data(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1161
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1164
  if (atomic_value_after_dec == 0) {
#line 1166
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 1168
    return (1);
  } else {

  }
#line 1172
  return (0);
}
}
#line 1174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_ptl  =    1;
#line 1177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_ptl(void) 
{ 


  {
  {
#line 1180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1184
  ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
  }
#line 1185
  return;
}
}
#line 1188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_ptl(void) 
{ 


  {
  {
#line 1191
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 1193
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 1195
  ldv_linux_kernel_locking_spinlock_spin_ptl = 1;
  }
#line 1196
  return;
}
}
#line 1199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1209
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1212
  if (is_spin_held_by_another_thread != 0) {
#line 1214
    return (0);
  } else {
#line 1218
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 1220
    return (1);
  }
}
}
#line 1225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_ptl(void) 
{ 


  {
  {
#line 1228
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1230
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
  }
#line 1231
  return;
}
}
#line 1234 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1239
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1242
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 1 && is_spin_held_by_another_thread == 0) {
#line 1244
    return (0);
  } else {
#line 1248
    return (1);
  }
}
}
#line 1253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_ptl(void) 
{ 
  int tmp ;

  {
  {
#line 1256
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl();
  }
#line 1256
  return (tmp == 0);
}
}
#line 1260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_ptl(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1265
  is_spin_contended = ldv_undef_int();
  }
#line 1268
  if (is_spin_contended != 0) {
#line 1270
    return (0);
  } else {
#line 1274
    return (1);
  }
}
}
#line 1279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_ptl(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1289
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1292
  if (atomic_value_after_dec == 0) {
#line 1294
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 1296
    return (1);
  } else {

  }
#line 1300
  return (0);
}
}
#line 1302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct  =    1;
#line 1305 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1312
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
  }
#line 1313
  return;
}
}
#line 1316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1319
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 1321
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 1323
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 1;
  }
#line 1324
  return;
}
}
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1337
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1340
  if (is_spin_held_by_another_thread != 0) {
#line 1342
    return (0);
  } else {
#line 1346
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 1348
    return (1);
  }
}
}
#line 1353 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1356
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1358
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
  }
#line 1359
  return;
}
}
#line 1362 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1367
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1370
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 1372
    return (0);
  } else {
#line 1376
    return (1);
  }
}
}
#line 1381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_siglock_of_sighand_struct(void) 
{ 
  int tmp ;

  {
  {
#line 1384
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct();
  }
#line 1384
  return (tmp == 0);
}
}
#line 1388 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_siglock_of_sighand_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1393
  is_spin_contended = ldv_undef_int();
  }
#line 1396
  if (is_spin_contended != 0) {
#line 1398
    return (0);
  } else {
#line 1402
    return (1);
  }
}
}
#line 1407 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_siglock_of_sighand_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1417
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1420
  if (atomic_value_after_dec == 0) {
#line 1422
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 1424
    return (1);
  } else {

  }
#line 1428
  return (0);
}
}
#line 1430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data  =    1;
#line 1433 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_vd_lock_of_gru_vma_data(void) 
{ 


  {
  {
#line 1436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
#line 1438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
#line 1440
  ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data = 2;
  }
#line 1441
  return;
}
}
#line 1444 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_vd_lock_of_gru_vma_data(void) 
{ 


  {
  {
#line 1447
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 2);
#line 1449
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 2);
#line 1451
  ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data = 1;
  }
#line 1452
  return;
}
}
#line 1455 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_vd_lock_of_gru_vma_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
#line 1462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
#line 1465
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1468
  if (is_spin_held_by_another_thread != 0) {
#line 1470
    return (0);
  } else {
#line 1474
    ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data = 2;
#line 1476
    return (1);
  }
}
}
#line 1481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_vd_lock_of_gru_vma_data(void) 
{ 


  {
  {
#line 1484
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
#line 1486
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
  }
#line 1487
  return;
}
}
#line 1490 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_vd_lock_of_gru_vma_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1495
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1498
  if (ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1 && is_spin_held_by_another_thread == 0) {
#line 1500
    return (0);
  } else {
#line 1504
    return (1);
  }
}
}
#line 1509 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_vd_lock_of_gru_vma_data(void) 
{ 
  int tmp ;

  {
  {
#line 1512
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_vd_lock_of_gru_vma_data();
  }
#line 1512
  return (tmp == 0);
}
}
#line 1516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_vd_lock_of_gru_vma_data(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1521
  is_spin_contended = ldv_undef_int();
  }
#line 1524
  if (is_spin_contended != 0) {
#line 1526
    return (0);
  } else {
#line 1530
    return (1);
  }
}
}
#line 1535 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_vd_lock_of_gru_vma_data(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
#line 1542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
#line 1545
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1548
  if (atomic_value_after_dec == 0) {
#line 1550
    ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data = 2;
#line 1552
    return (1);
  } else {

  }
#line 1556
  return (0);
}
}
#line 1559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_check_final_state(void) 
{ 


  {
  {
#line 1562
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 1564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 1);
#line 1566
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 1);
#line 1568
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 1);
#line 1570
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 1572
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1574
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1576
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 1);
#line 1578
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1580
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1582
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1584
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 1);
  }
#line 1585
  return;
}
}
#line 1588 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_exclusive_spin_is_locked(void) 
{ 


  {
#line 1591
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2) {
#line 1593
    return (1);
  } else {

  }
#line 1596
  if (ldv_linux_kernel_locking_spinlock_spin_bs_lock_of_gru_blade_state == 2) {
#line 1598
    return (1);
  } else {

  }
#line 1601
  if (ldv_linux_kernel_locking_spinlock_spin_gs_asid_lock_of_gru_state == 2) {
#line 1603
    return (1);
  } else {

  }
#line 1606
  if (ldv_linux_kernel_locking_spinlock_spin_gs_lock_of_gru_state == 2) {
#line 1608
    return (1);
  } else {

  }
#line 1611
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2) {
#line 1613
    return (1);
  } else {

  }
#line 1616
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 2) {
#line 1618
    return (1);
  } else {

  }
#line 1621
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2) {
#line 1623
    return (1);
  } else {

  }
#line 1626
  if (ldv_linux_kernel_locking_spinlock_spin_ms_asid_lock_of_gru_mm_struct == 2) {
#line 1628
    return (1);
  } else {

  }
#line 1631
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2) {
#line 1633
    return (1);
  } else {

  }
#line 1636
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 2) {
#line 1638
    return (1);
  } else {

  }
#line 1641
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2) {
#line 1643
    return (1);
  } else {

  }
#line 1646
  if (ldv_linux_kernel_locking_spinlock_spin_vd_lock_of_gru_vma_data == 2) {
#line 1648
    return (1);
  } else {

  }
#line 1651
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/completion.linux_kernel_sched_completion.bk.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) ;
#line 2
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/sched/completion.c"
static int ldv_linux_kernel_sched_completion_completion_bs_async_wq_of_gru_blade_state  =    0;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_bs_async_wq_of_gru_blade_state(void) 
{ 


  {
#line 33
  ldv_linux_kernel_sched_completion_completion_bs_async_wq_of_gru_blade_state = 1;
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_macro_bs_async_wq_of_gru_blade_state(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_sched_completion__double_init(ldv_linux_kernel_sched_completion_completion_bs_async_wq_of_gru_blade_state != 0);
#line 42
  ldv_linux_kernel_sched_completion_completion_bs_async_wq_of_gru_blade_state = 1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_wait_for_completion_bs_async_wq_of_gru_blade_state(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_sched_completion__wait_without_init(ldv_linux_kernel_sched_completion_completion_bs_async_wq_of_gru_blade_state != 0);
#line 51
  ldv_linux_kernel_sched_completion_completion_bs_async_wq_of_gru_blade_state = 2;
  }
#line 52
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/rsg/models/idr.linux_lib_idr.bk.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) ;
#line 2
void ldv_assert_linux_lib_idr__double_init(int expr ) ;
#line 3
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_lib_idr__not_initialized(int expr ) ;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/lib/idr.c"
static int ldv_linux_lib_idr_idr  =    0;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_init(void) 
{ 


  {
  {
#line 35
  ldv_assert_linux_lib_idr__double_init(ldv_linux_lib_idr_idr == 0);
#line 37
  ldv_linux_lib_idr_idr = 1;
  }
#line 38
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_alloc(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 46
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 48
  ldv_linux_lib_idr_idr = 2;
  }
#line 49
  return;
}
}
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_find(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 57
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 59
  ldv_linux_lib_idr_idr = 2;
  }
#line 60
  return;
}
}
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_remove(void) 
{ 


  {
  {
#line 66
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 68
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 70
  ldv_linux_lib_idr_idr = 2;
  }
#line 71
  return;
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_destroy(void) 
{ 


  {
  {
#line 77
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 79
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 81
  ldv_linux_lib_idr_idr = 3;
  }
#line 82
  return;
}
}
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/misc/sgi-gru/gru.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_check_final_state(void) 
{ 


  {
  {
#line 88
  ldv_assert_linux_lib_idr__more_at_exit(ldv_linux_lib_idr_idr == 0 || ldv_linux_lib_idr_idr == 3);
  }
#line 89
  return;
}
}
#line 2 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
extern void __VERIFIER_error_linux_net_rtnetlink(void) ;
#line 3 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 6
  return;
}
}
#line 7 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) 
{ 


  {
#line 8
  if (! expr) {
    {
#line 9
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 10
  return;
}
}
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) 
{ 


  {
#line 12
  if (! expr) {
    {
#line 13
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 14
  return;
}
}
#line 15
extern void __VERIFIER_error_linux_kernel_locking_rwlock(void) ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) 
{ 


  {
#line 17
  if (! expr) {
    {
#line 18
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 19
  return;
}
}
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) 
{ 


  {
#line 21
  if (! expr) {
    {
#line 22
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 23
  return;
}
}
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) 
{ 


  {
#line 25
  if (! expr) {
    {
#line 26
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 27
  return;
}
}
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) 
{ 


  {
#line 29
  if (! expr) {
    {
#line 30
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 31
  return;
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) 
{ 


  {
#line 33
  if (! expr) {
    {
#line 34
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 35
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) 
{ 


  {
#line 37
  if (! expr) {
    {
#line 38
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 39
  return;
}
}
#line 40
extern void __VERIFIER_error_linux_lib_idr(void) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__double_init(int expr ) 
{ 


  {
#line 42
  if (! expr) {
    {
#line 43
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 44
  return;
}
}
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__not_initialized(int expr ) 
{ 


  {
#line 46
  if (! expr) {
    {
#line 47
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 48
  return;
}
}
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) 
{ 


  {
#line 50
  if (! expr) {
    {
#line 51
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 52
  return;
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) 
{ 


  {
#line 54
  if (! expr) {
    {
#line 55
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 56
  return;
}
}
#line 57
extern void __VERIFIER_error_linux_kernel_sched_completion(void) ;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) 
{ 


  {
#line 59
  if (! expr) {
    {
#line 60
    __VERIFIER_error_linux_kernel_sched_completion();
    }
  } else {

  }
#line 61
  return;
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) 
{ 


  {
#line 63
  if (! expr) {
    {
#line 64
    __VERIFIER_error_linux_kernel_sched_completion();
    }
  } else {

  }
#line 65
  return;
}
}
#line 66
extern void __VERIFIER_error_linux_net_register(void) ;
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) 
{ 


  {
#line 68
  if (! expr) {
    {
#line 69
    __VERIFIER_error_linux_net_register();
    }
  } else {

  }
#line 70
  return;
}
}
#line 71
extern void __VERIFIER_error_linux_fs_char_dev(void) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) 
{ 


  {
#line 73
  if (! expr) {
    {
#line 74
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 75
  return;
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) 
{ 


  {
#line 77
  if (! expr) {
    {
#line 78
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 79
  return;
}
}
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) 
{ 


  {
#line 81
  if (! expr) {
    {
#line 82
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 83
  return;
}
}
#line 84
extern void __VERIFIER_error_linux_kernel_rcu_srcu(void) ;
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) 
{ 


  {
#line 86
  if (! expr) {
    {
#line 87
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 88
  return;
}
}
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) 
{ 


  {
#line 90
  if (! expr) {
    {
#line 91
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 92
  return;
}
}
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) 
{ 


  {
#line 94
  if (! expr) {
    {
#line 95
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 96
  return;
}
}
#line 97
extern void __VERIFIER_error_linux_kernel_module(void) ;
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) 
{ 


  {
#line 99
  if (! expr) {
    {
#line 100
    __VERIFIER_error_linux_kernel_module();
    }
  } else {

  }
#line 101
  return;
}
}
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) 
{ 


  {
#line 103
  if (! expr) {
    {
#line 104
    __VERIFIER_error_linux_kernel_module();
    }
  } else {

  }
#line 105
  return;
}
}
#line 106
extern void __VERIFIER_error_linux_alloc_spinlock(void) ;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) 
{ 


  {
#line 108
  if (! expr) {
    {
#line 109
    __VERIFIER_error_linux_alloc_spinlock();
    }
  } else {

  }
#line 110
  return;
}
}
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) 
{ 


  {
#line 112
  if (! expr) {
    {
#line 113
    __VERIFIER_error_linux_alloc_spinlock();
    }
  } else {

  }
#line 114
  return;
}
}
#line 115
extern void __VERIFIER_error_linux_lib_find_bit(void) ;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) 
{ 


  {
#line 117
  if (! expr) {
    {
#line 118
    __VERIFIER_error_linux_lib_find_bit();
    }
  } else {

  }
#line 119
  return;
}
}
#line 120
extern void __VERIFIER_error_linux_mmc_sdio_func(void) ;
#line 121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) 
{ 


  {
#line 122
  if (! expr) {
    {
#line 123
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 124
  return;
}
}
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) 
{ 


  {
#line 126
  if (! expr) {
    {
#line 127
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 128
  return;
}
}
#line 129 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) 
{ 


  {
#line 130
  if (! expr) {
    {
#line 131
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 132
  return;
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) 
{ 


  {
#line 134
  if (! expr) {
    {
#line 135
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 136
  return;
}
}
#line 137
extern void __VERIFIER_error_linux_usb_coherent(void) ;
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) 
{ 


  {
#line 139
  if (! expr) {
    {
#line 140
    __VERIFIER_error_linux_usb_coherent();
    }
  } else {

  }
#line 141
  return;
}
}
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) 
{ 


  {
#line 143
  if (! expr) {
    {
#line 144
    __VERIFIER_error_linux_usb_coherent();
    }
  } else {

  }
#line 145
  return;
}
}
#line 146
extern void __VERIFIER_error_linux_kernel_rcu_update_lock(void) ;
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) 
{ 


  {
#line 148
  if (! expr) {
    {
#line 149
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 150
  return;
}
}
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) 
{ 


  {
#line 152
  if (! expr) {
    {
#line 153
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 154
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) 
{ 


  {
#line 156
  if (! expr) {
    {
#line 157
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 158
  return;
}
}
#line 159
extern void __VERIFIER_error_linux_net_sock(void) ;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) 
{ 


  {
#line 161
  if (! expr) {
    {
#line 162
    __VERIFIER_error_linux_net_sock();
    }
  } else {

  }
#line 163
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__double_release(int expr ) 
{ 


  {
#line 165
  if (! expr) {
    {
#line 166
    __VERIFIER_error_linux_net_sock();
    }
  } else {

  }
#line 167
  return;
}
}
#line 168
extern void __VERIFIER_error_linux_kernel_rcu_update_lock_bh(void) ;
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) 
{ 


  {
#line 170
  if (! expr) {
    {
#line 171
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 172
  return;
}
}
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) 
{ 


  {
#line 174
  if (! expr) {
    {
#line 175
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 176
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) 
{ 


  {
#line 178
  if (! expr) {
    {
#line 179
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 180
  return;
}
}
#line 181
extern void __VERIFIER_error_linux_usb_dev(void) ;
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) 
{ 


  {
#line 183
  if (! expr) {
    {
#line 184
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 185
  return;
}
}
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) 
{ 


  {
#line 187
  if (! expr) {
    {
#line 188
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 189
  return;
}
}
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) 
{ 


  {
#line 191
  if (! expr) {
    {
#line 192
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 193
  return;
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__probe_failed(int expr ) 
{ 


  {
#line 195
  if (! expr) {
    {
#line 196
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 197
  return;
}
}
#line 198
extern void __VERIFIER_error_linux_kernel_locking_mutex(void) ;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) 
{ 


  {
#line 200
  if (! expr) {
    {
#line 201
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 202
  return;
}
}
#line 203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 204
  if (! expr) {
    {
#line 205
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 206
  return;
}
}
#line 207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) 
{ 


  {
#line 208
  if (! expr) {
    {
#line 209
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 210
  return;
}
}
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 212
  if (! expr) {
    {
#line 213
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 214
  return;
}
}
#line 215
extern void __VERIFIER_error_linux_usb_gadget(void) ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 217
  if (! expr) {
    {
#line 218
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 219
  return;
}
}
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 221
  if (! expr) {
    {
#line 222
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 223
  return;
}
}
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 225
  if (! expr) {
    {
#line 226
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 227
  return;
}
}
#line 228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 229
  if (! expr) {
    {
#line 230
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 231
  return;
}
}
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) 
{ 


  {
#line 233
  if (! expr) {
    {
#line 234
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 235
  return;
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) 
{ 


  {
#line 237
  if (! expr) {
    {
#line 238
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 239
  return;
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) 
{ 


  {
#line 241
  if (! expr) {
    {
#line 242
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 243
  return;
}
}
#line 244
extern void __VERIFIER_error_linux_alloc_usb_lock(void) ;
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) 
{ 


  {
#line 246
  if (! expr) {
    {
#line 247
    __VERIFIER_error_linux_alloc_usb_lock();
    }
  } else {

  }
#line 248
  return;
}
}
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) 
{ 


  {
#line 250
  if (! expr) {
    {
#line 251
    __VERIFIER_error_linux_alloc_usb_lock();
    }
  } else {

  }
#line 252
  return;
}
}
#line 253
extern void __VERIFIER_error_linux_block_request(void) ;
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_get(int expr ) 
{ 


  {
#line 255
  if (! expr) {
    {
#line 256
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 257
  return;
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_put(int expr ) 
{ 


  {
#line 259
  if (! expr) {
    {
#line 260
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 261
  return;
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__get_at_exit(int expr ) 
{ 


  {
#line 263
  if (! expr) {
    {
#line 264
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 265
  return;
}
}
#line 266
extern void __VERIFIER_error_linux_alloc_irq(void) ;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) 
{ 


  {
#line 268
  if (! expr) {
    {
#line 269
    __VERIFIER_error_linux_alloc_irq();
    }
  } else {

  }
#line 270
  return;
}
}
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) 
{ 


  {
#line 272
  if (! expr) {
    {
#line 273
    __VERIFIER_error_linux_alloc_irq();
    }
  } else {

  }
#line 274
  return;
}
}
#line 275
extern void __VERIFIER_error_linux_drivers_base_class(void) ;
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) 
{ 


  {
#line 277
  if (! expr) {
    {
#line 278
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 279
  return;
}
}
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) 
{ 


  {
#line 281
  if (! expr) {
    {
#line 282
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 283
  return;
}
}
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) 
{ 


  {
#line 285
  if (! expr) {
    {
#line 286
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 287
  return;
}
}
#line 288
extern void __VERIFIER_error_linux_block_queue(void) ;
#line 289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) 
{ 


  {
#line 290
  if (! expr) {
    {
#line 291
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 292
  return;
}
}
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) 
{ 


  {
#line 294
  if (! expr) {
    {
#line 295
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 296
  return;
}
}
#line 297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) 
{ 


  {
#line 298
  if (! expr) {
    {
#line 299
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 300
  return;
}
}
#line 301
extern void __VERIFIER_error_linux_block_genhd(void) ;
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__double_allocation(int expr ) 
{ 


  {
#line 303
  if (! expr) {
    {
#line 304
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) 
{ 


  {
#line 307
  if (! expr) {
    {
#line 308
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 309
  return;
}
}
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) 
{ 


  {
#line 311
  if (! expr) {
    {
#line 312
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 313
  return;
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) 
{ 


  {
#line 315
  if (! expr) {
    {
#line 316
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 317
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) 
{ 


  {
#line 319
  if (! expr) {
    {
#line 320
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 321
  return;
}
}
#line 322
extern void __VERIFIER_error_linux_arch_io(void) ;
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) 
{ 


  {
#line 324
  if (! expr) {
    {
#line 325
    __VERIFIER_error_linux_arch_io();
    }
  } else {

  }
#line 326
  return;
}
}
#line 327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) 
{ 


  {
#line 328
  if (! expr) {
    {
#line 329
    __VERIFIER_error_linux_arch_io();
    }
  } else {

  }
#line 330
  return;
}
}
#line 331
extern void __VERIFIER_error_linux_usb_register(void) ;
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) 
{ 


  {
#line 333
  if (! expr) {
    {
#line 334
    __VERIFIER_error_linux_usb_register();
    }
  } else {

  }
#line 335
  return;
}
}
#line 336
extern void __VERIFIER_error_linux_fs_sysfs(void) ;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) 
{ 


  {
#line 338
  if (! expr) {
    {
#line 339
    __VERIFIER_error_linux_fs_sysfs();
    }
  } else {

  }
#line 340
  return;
}
}
#line 341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) 
{ 


  {
#line 342
  if (! expr) {
    {
#line 343
    __VERIFIER_error_linux_fs_sysfs();
    }
  } else {

  }
#line 344
  return;
}
}
#line 345
extern void __VERIFIER_error_linux_kernel_locking_spinlock(void) ;
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) 
{ 


  {
#line 347
  if (! expr) {
    {
#line 348
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 349
  return;
}
}
#line 350 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 351
  if (! expr) {
    {
#line 352
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 353
  return;
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) 
{ 


  {
#line 355
  if (! expr) {
    {
#line 356
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 357
  return;
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 359
  if (! expr) {
    {
#line 360
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 361
  return;
}
}
#line 362
extern void __VERIFIER_error_linux_usb_urb(void) ;
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) 
{ 


  {
#line 364
  if (! expr) {
    {
#line 365
    __VERIFIER_error_linux_usb_urb();
    }
  } else {

  }
#line 366
  return;
}
}
#line 367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) 
{ 


  {
#line 368
  if (! expr) {
    {
#line 369
    __VERIFIER_error_linux_usb_urb();
    }
  } else {

  }
#line 370
  return;
}
}
#line 371
extern void __VERIFIER_error_linux_kernel_rcu_update_lock_sched(void) ;
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) 
{ 


  {
#line 373
  if (! expr) {
    {
#line 374
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 375
  return;
}
}
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) 
{ 


  {
#line 377
  if (! expr) {
    {
#line 378
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 379
  return;
}
}
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/misc/sgi-gru/gru.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) 
{ 


  {
#line 381
  if (! expr) {
    {
#line 382
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 383
  return;
}
}
