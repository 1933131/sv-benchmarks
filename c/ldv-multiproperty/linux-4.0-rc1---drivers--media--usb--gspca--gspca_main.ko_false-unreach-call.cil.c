/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef short __s16;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef long long __s64;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u16 __le16;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 186
struct hlist_node;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
struct class;
#line 131
struct urb;
#line 199
struct device;
#line 245
struct completion;
#line 252
struct usb_device;
#line 277
struct gendisk;
#line 338
struct module;
#line 346
struct mutex;
#line 482
struct request_queue;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 15
struct task_struct;
#line 16
struct lockdep_map;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_11 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_9 {
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
   struct __anonstruct____missing_field_name_11 __annonCompField6 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_9 __annonCompField7 ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_12 {
   pteval_t pte ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_12 pte_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_13 pgd_t;
#line 361
struct page;
#line 361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 369
struct file;
#line 382
struct seq_file;
#line 420
struct thread_struct;
#line 422
struct mm_struct;
#line 423
struct cpumask;
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
struct file_operations;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_16 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_16 __annonCompField8 ;
};
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_21 {
   u64 rip ;
   u64 rdp ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_22 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_20 {
   struct __anonstruct____missing_field_name_21 __annonCompField12 ;
   struct __anonstruct____missing_field_name_22 __annonCompField13 ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_23 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_20 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_23 __annonCompField15 ;
};
#line 345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndreg {
   u64 lower_bound ;
   u64 upper_bound ;
};
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndcsr {
   u64 bndcfgu ;
   u64 bndstatus ;
};
#line 386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndreg bndreg[4U] ;
   struct bndcsr bndcsr ;
};
#line 401 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_27 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_26 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_27 __annonCompField17 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_26 __annonCompField18 ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_28 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_28 rwlock_t;
#line 51 "/home/ubuntu/klever-work/linux/ldv/irq.h"
struct ldv_thread;
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 bInterfaceNumber ;
   kernel_ulong_t driver_info ;
};
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1U] ;
   kernel_ulong_t keybit[12U] ;
   kernel_ulong_t relbit[1U] ;
   kernel_ulong_t absbit[1U] ;
   kernel_ulong_t mscbit[1U] ;
   kernel_ulong_t ledbit[1U] ;
   kernel_ulong_t sndbit[1U] ;
   kernel_ulong_t ffbit[2U] ;
   kernel_ulong_t swbit[1U] ;
   kernel_ulong_t driver_info ;
};
#line 253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
#line 275 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
#line 692 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
#line 751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
#line 801 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
#line 811 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
#line 905
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
#line 914
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
struct timespec;
#line 55
struct compat_timespec;
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
struct __anonstruct_futex_33 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
struct __anonstruct_nanosleep_34 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 56
struct pollfd;
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
struct __anonstruct_poll_35 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
union __anonunion____missing_field_name_32 {
   struct __anonstruct_futex_33 futex ;
   struct __anonstruct_nanosleep_34 nanosleep ;
   struct __anonstruct_poll_35 poll ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_32 __annonCompField19 ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ftrace_irq.h"
struct vm_area_struct;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmdebug.h"
struct llist_node;
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jump_label.h"
struct jump_entry;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_112 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_112 seqlock_t;
#line 478 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/time.h"
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debugobjects.h"
struct tvec_base;
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debugobjects.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 540
struct dev_pm_qos;
#line 540 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_113 {
   unsigned long bits[16U] ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_113 nodemask_t;
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_114 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_114 mm_context_t;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci_iomap.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io_apic.h"
struct device_node;
#line 789 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore;
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hardirq.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int in_hrtirq ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct kref {
   atomic_t refcount ;
};
#line 652 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
union __anonunion____missing_field_name_145 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 652 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_145 __annonCompField33 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185
struct dentry;
#line 186
struct iattr;
#line 187
struct super_block;
#line 188
struct file_system_type;
#line 189
struct kernfs_open_node;
#line 190
struct kernfs_iattrs;
#line 212
struct kernfs_root;
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 88
struct kernfs_ops;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
union __anonunion____missing_field_name_146 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_146 __annonCompField34 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170
struct vm_operations_struct;
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 469
struct sock;
#line 470
struct kobject;
#line 471
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/highuid.h"
struct user_namespace;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kuid_t_147 {
   uid_t val ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_147 kuid_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kgid_t_148 {
   gid_t val ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_148 kgid_t;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct bin_attribute;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct klist_node;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 67
struct path;
#line 68
struct inode;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/klist.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 186
struct pinctrl;
#line 187
struct pinctrl_state;
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ratelimit.h"
struct dma_map_ops;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ratelimit.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/device.h"
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct iommu_ops;
#line 20
struct iommu_group;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 322
struct class_attribute;
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 483 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 652
struct acpi_device;
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 659
struct dma_coherent_mem;
#line 659
struct cma;
#line 659 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 806 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct hlist_bl_node;
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_150 {
   spinlock_t lock ;
   int count ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
union __anonunion____missing_field_name_149 {
   struct __anonstruct____missing_field_name_150 __annonCompField35 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_149 __annonCompField36 ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct vfsmount;
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct __anonstruct____missing_field_name_152 {
   u32 hash ;
   u32 len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
union __anonunion____missing_field_name_151 {
   struct __anonstruct____missing_field_name_152 __annonCompField37 ;
   u64 hash_len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_151 __annonCompField38 ;
   unsigned char const   *name ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
union __anonunion_d_u_153 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_153 d_u ;
};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 555 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/path.h"
struct mem_cgroup;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/path.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_155 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
union __anonunion____missing_field_name_154 {
   struct __anonstruct____missing_field_name_155 __annonCompField39 ;
   struct callback_head callback_head ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_154 __annonCompField40 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 428
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 435
struct pid_namespace;
#line 435 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-rwsem.h"
struct block_device;
#line 31
struct io_context;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fs.h"
struct backing_dev_info;
#line 61
struct export_operations;
#line 63
struct iovec;
#line 64
struct nameidata;
#line 65
struct kiocb;
#line 66
struct pipe_inode_info;
#line 67
struct poll_table_struct;
#line 68
struct kstatfs;
#line 69
struct cred;
#line 70
struct swap_info_struct;
#line 71
struct iov_iter;
#line 72
struct vm_fault;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
struct __anonstruct_kprojid_t_158 {
   projid_t val ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_158 kprojid_t;
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 164
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
union __anonunion____missing_field_name_159 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_159 __annonCompField42 ;
   enum quota_type type ;
};
#line 183 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 205
struct quota_format_type;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 384 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 460
struct address_space;
#line 461
struct writeback_control;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 414
struct hd_struct;
#line 414 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 531
struct posix_acl;
#line 532
struct inode_operations;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_162 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_163 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 532
struct file_lock_context;
#line 532
struct cdev;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_164 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_162 __annonCompField43 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_163 __annonCompField44 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_164 __annonCompField45 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 776 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion_f_u_165 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_165 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
typedef void *fl_owner_t;
#line 884
struct file_lock;
#line 885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 891 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_get_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_put_owner)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 912
struct nlm_lockowner;
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_167 {
   struct list_head link ;
   int state ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_166 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_167 afs ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_166 fl_u ;
};
#line 965 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1021 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1223
struct super_operations;
#line 1223
struct xattr_handler;
#line 1223
struct mtd_info;
#line 1223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1475
struct dir_context;
#line 1500 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   void (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
   int (*dentry_open)(struct dentry * , struct file * , struct cred  const  * ) ;
};
#line 1624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1856 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_173 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_174 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_172 {
   struct __anonstruct____missing_field_name_173 __annonCompField48 ;
   struct __anonstruct____missing_field_name_174 __annonCompField49 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_172 __annonCompField50 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct xol_area;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_175 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_177 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_181 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_180 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_181 __annonCompField53 ;
   int units ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_179 {
   union __anonunion____missing_field_name_180 __annonCompField54 ;
   atomic_t _count ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_178 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_179 __annonCompField55 ;
   unsigned int active ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_176 {
   union __anonunion____missing_field_name_177 __annonCompField52 ;
   union __anonunion____missing_field_name_178 __annonCompField56 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_183 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_184 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_182 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_183 __annonCompField58 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_184 __annonCompField59 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_185 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_175 __annonCompField51 ;
   struct __anonstruct____missing_field_name_176 __annonCompField57 ;
   union __anonunion____missing_field_name_182 __annonCompField60 ;
   union __anonunion____missing_field_name_185 __annonCompField61 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct_shared_186 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 248
struct anon_vma;
#line 248
struct mempolicy;
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_186 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 335 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 348
struct kioctx_table;
#line 349
struct linux_binfmt;
#line 349
struct mmu_notifier_mm;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/shm.h"
struct user_struct;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_188 {
   unsigned long sig[1U] ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_188 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_190 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_191 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_192 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_193 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_195 {
   void *_lower ;
   void *_upper ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_194 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_195 _addr_bnd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_196 {
   long _band ;
   int _fd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_197 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_189 {
   int _pad[28U] ;
   struct __anonstruct__kill_190 _kill ;
   struct __anonstruct__timer_191 _timer ;
   struct __anonstruct__rt_192 _rt ;
   struct __anonstruct__sigchld_193 _sigchld ;
   struct __anonstruct__sigfault_194 _sigfault ;
   struct __anonstruct__sigpoll_196 _sigpoll ;
   struct __anonstruct__sigsys_197 _sigsys ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_189 _sifields ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/resource.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct assoc_array_ptr;
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct key_type;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_202 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_203 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct __anonstruct____missing_field_name_205 {
   struct key_type *type ;
   char *description ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_204 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_205 __annonCompField66 ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_type_data_206 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_payload_208 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_207 {
   union __anonunion_payload_208 payload ;
   struct assoc_array keys ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_202 __annonCompField64 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_203 __annonCompField65 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_204 __annonCompField67 ;
   union __anonunion_type_data_206 type_data ;
   union __anonunion____missing_field_name_207 __annonCompField68 ;
};
#line 358
struct audit_context;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct futex_pi_state;
#line 128
struct robust_list_head;
#line 129
struct bio_list;
#line 130
struct fs_struct;
#line 131
struct perf_event_context;
#line 132
struct blk_plug;
#line 182
struct cfs_rq;
#line 183
struct task_group;
#line 471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 518 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 525 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 599
struct autogroup;
#line 600
struct tty_struct;
#line 600
struct taskstats;
#line 600
struct tty_audit_buf;
#line 600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 781 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 824
struct reclaim_state;
#line 825 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1195
struct rt_rq;
#line 1195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1702
struct sched_class;
#line 1702
struct files_struct;
#line 1702
struct css_set;
#line 1702
struct compat_robust_list_head;
#line 1702
struct numa_group;
#line 1702
struct ftrace_ret_stack;
#line 1702 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
};
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_runtime.h"
struct wusb_dev;
#line 284
struct ep_device;
#line 285 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm_runtime.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
   int streams ;
};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
#line 92
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
#line 99 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
#line 230 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
#line 294 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
#line 318
struct mon_bus;
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   unsigned int resuming_ports ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
#line 369
struct usb_tt;
#line 370
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb2_lpm_parameters {
   unsigned int besl ;
   int timeout ;
};
#line 404 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb3_lpm_parameters {
   unsigned int mel ;
   unsigned int pel ;
   unsigned int sel ;
   int timeout ;
};
#line 443 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   unsigned long connect_time ;
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
};
#line 1174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
#line 1216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
#line 1236
struct scatterlist;
#line 1236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 672 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pagemap.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/poll.h"
struct poll_table_struct {
   void (*_qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
   unsigned long _key ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/poll.h"
typedef struct poll_table_struct poll_table;
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/poll.h"
struct v4l2_edid {
   __u32 pad ;
   __u32 start_block ;
   __u32 blocks ;
   __u32 reserved[5U] ;
   __u8 *edid ;
};
#line 571 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-common.h"
enum v4l2_buf_type {
    V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
    V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
    V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
    V4L2_BUF_TYPE_VBI_CAPTURE = 4,
    V4L2_BUF_TYPE_VBI_OUTPUT = 5,
    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
    V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
    V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
    V4L2_BUF_TYPE_SDR_CAPTURE = 11,
    V4L2_BUF_TYPE_PRIVATE = 128
} ;
#line 594
enum v4l2_memory {
    V4L2_MEMORY_MMAP = 1,
    V4L2_MEMORY_USERPTR = 2,
    V4L2_MEMORY_OVERLAY = 3,
    V4L2_MEMORY_DMABUF = 4
} ;
#line 632
enum v4l2_priority {
    V4L2_PRIORITY_UNSET = 0,
    V4L2_PRIORITY_BACKGROUND = 1,
    V4L2_PRIORITY_INTERACTIVE = 2,
    V4L2_PRIORITY_RECORD = 3,
    V4L2_PRIORITY_DEFAULT = 2
} ;
#line 640 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-common.h"
struct v4l2_rect {
   __s32 left ;
   __s32 top ;
   __u32 width ;
   __u32 height ;
};
#line 294 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_fract {
   __u32 numerator ;
   __u32 denominator ;
};
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_capability {
   __u8 driver[16U] ;
   __u8 card[32U] ;
   __u8 bus_info[32U] ;
   __u32 version ;
   __u32 capabilities ;
   __u32 device_caps ;
   __u32 reserved[3U] ;
};
#line 320 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_pix_format {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
   __u32 flags ;
   __u32 ycbcr_enc ;
   __u32 quantization ;
};
#line 373 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_fmtdesc {
   __u32 index ;
   __u32 type ;
   __u32 flags ;
   __u8 description[32U] ;
   __u32 pixelformat ;
   __u32 reserved[4U] ;
};
#line 562 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_frmsize_discrete {
   __u32 width ;
   __u32 height ;
};
#line 575 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_frmsize_stepwise {
   __u32 min_width ;
   __u32 max_width ;
   __u32 step_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 step_height ;
};
#line 584 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_214 {
   struct v4l2_frmsize_discrete discrete ;
   struct v4l2_frmsize_stepwise stepwise ;
};
#line 584 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_frmsizeenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 type ;
   union __anonunion____missing_field_name_214 __annonCompField72 ;
   __u32 reserved[2U] ;
};
#line 603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_frmival_stepwise {
   struct v4l2_fract min ;
   struct v4l2_fract max ;
   struct v4l2_fract step ;
};
#line 612 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_215 {
   struct v4l2_fract discrete ;
   struct v4l2_frmival_stepwise stepwise ;
};
#line 612 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_frmivalenum {
   __u32 index ;
   __u32 pixel_format ;
   __u32 width ;
   __u32 height ;
   __u32 type ;
   union __anonunion____missing_field_name_215 __annonCompField73 ;
   __u32 reserved[2U] ;
};
#line 627 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_timecode {
   __u32 type ;
   __u32 flags ;
   __u8 frames ;
   __u8 seconds ;
   __u8 minutes ;
   __u8 hours ;
   __u8 userbits[4U] ;
};
#line 641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_jpegcompression {
   int quality ;
   int APPn ;
   int APP_len ;
   char APP_data[60U] ;
   int COM_len ;
   char COM_data[60U] ;
   __u32 jpeg_markers ;
};
#line 670 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_requestbuffers {
   __u32 count ;
   __u32 type ;
   __u32 memory ;
   __u32 reserved[2U] ;
};
#line 695 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion_m_216 {
   __u32 mem_offset ;
   unsigned long userptr ;
   __s32 fd ;
};
#line 695 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_plane {
   __u32 bytesused ;
   __u32 length ;
   union __anonunion_m_216 m ;
   __u32 data_offset ;
   __u32 reserved[11U] ;
};
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion_m_217 {
   __u32 offset ;
   unsigned long userptr ;
   struct v4l2_plane *planes ;
   __s32 fd ;
};
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_buffer {
   __u32 index ;
   __u32 type ;
   __u32 bytesused ;
   __u32 flags ;
   __u32 field ;
   struct timeval timestamp ;
   struct v4l2_timecode timecode ;
   __u32 sequence ;
   __u32 memory ;
   union __anonunion_m_217 m ;
   __u32 length ;
   __u32 reserved2 ;
   __u32 reserved ;
};
#line 780 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_exportbuffer {
   __u32 type ;
   __u32 index ;
   __u32 plane ;
   __u32 flags ;
   __s32 fd ;
   __u32 reserved[11U] ;
};
#line 839 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct __anonstruct_fmt_218 {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 bytesperline ;
   __u32 sizeimage ;
   __u32 colorspace ;
   __u32 priv ;
};
#line 839 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_framebuffer {
   __u32 capability ;
   __u32 flags ;
   void *base ;
   struct __anonstruct_fmt_218 fmt ;
};
#line 860 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_clip {
   struct v4l2_rect c ;
   struct v4l2_clip *next ;
};
#line 882 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_window {
   struct v4l2_rect w ;
   __u32 field ;
   __u32 chromakey ;
   struct v4l2_clip *clips ;
   __u32 clipcount ;
   void *bitmap ;
   __u8 global_alpha ;
};
#line 892 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_captureparm {
   __u32 capability ;
   __u32 capturemode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 readbuffers ;
   __u32 reserved[4U] ;
};
#line 904 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_outputparm {
   __u32 capability ;
   __u32 outputmode ;
   struct v4l2_fract timeperframe ;
   __u32 extendedmode ;
   __u32 writebuffers ;
   __u32 reserved[4U] ;
};
#line 917 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_cropcap {
   __u32 type ;
   struct v4l2_rect bounds ;
   struct v4l2_rect defrect ;
   struct v4l2_fract pixelaspect ;
};
#line 927 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_crop {
   __u32 type ;
   struct v4l2_rect c ;
};
#line 932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_selection {
   __u32 type ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[9U] ;
};
#line 959 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
typedef __u64 v4l2_std_id;
#line 1095 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_bt_timings {
   __u32 width ;
   __u32 height ;
   __u32 interlaced ;
   __u32 polarities ;
   __u64 pixelclock ;
   __u32 hfrontporch ;
   __u32 hsync ;
   __u32 hbackporch ;
   __u32 vfrontporch ;
   __u32 vsync ;
   __u32 vbackporch ;
   __u32 il_vfrontporch ;
   __u32 il_vsync ;
   __u32 il_vbackporch ;
   __u32 standards ;
   __u32 flags ;
   __u32 reserved[14U] ;
};
#line 1151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_219 {
   struct v4l2_bt_timings bt ;
   __u32 reserved[32U] ;
};
#line 1151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_dv_timings {
   __u32 type ;
   union __anonunion____missing_field_name_219 __annonCompField74 ;
};
#line 1213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_enum_dv_timings {
   __u32 index ;
   __u32 pad ;
   __u32 reserved[2U] ;
   struct v4l2_dv_timings timings ;
};
#line 1231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_bt_timings_cap {
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u64 min_pixelclock ;
   __u64 max_pixelclock ;
   __u32 standards ;
   __u32 capabilities ;
   __u32 reserved[16U] ;
};
#line 1254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_220 {
   struct v4l2_bt_timings_cap bt ;
   __u32 raw_data[32U] ;
};
#line 1254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_dv_timings_cap {
   __u32 type ;
   __u32 pad ;
   __u32 reserved[2U] ;
   union __anonunion____missing_field_name_220 __annonCompField75 ;
};
#line 1279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_input {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 tuner ;
   v4l2_std_id std ;
   __u32 status ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1295 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_output {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 audioset ;
   __u32 modulator ;
   v4l2_std_id std ;
   __u32 capabilities ;
   __u32 reserved[3U] ;
};
#line 1343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_control {
   __u32 id ;
   __s32 value ;
};
#line 1361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_221 {
   __s32 value ;
   __s64 value64 ;
   char *string ;
   __u8 *p_u8 ;
   __u16 *p_u16 ;
   __u32 *p_u32 ;
   void *ptr ;
};
#line 1361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_ext_control {
   __u32 id ;
   __u32 size ;
   __u32 reserved2[1U] ;
   union __anonunion____missing_field_name_221 __annonCompField76 ;
};
#line 1376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_ext_controls {
   __u32 ctrl_class ;
   __u32 count ;
   __u32 error_idx ;
   __u32 reserved[2U] ;
   struct v4l2_ext_control *controls ;
};
#line 1384
enum v4l2_ctrl_type {
    V4L2_CTRL_TYPE_INTEGER = 1,
    V4L2_CTRL_TYPE_BOOLEAN = 2,
    V4L2_CTRL_TYPE_MENU = 3,
    V4L2_CTRL_TYPE_BUTTON = 4,
    V4L2_CTRL_TYPE_INTEGER64 = 5,
    V4L2_CTRL_TYPE_CTRL_CLASS = 6,
    V4L2_CTRL_TYPE_STRING = 7,
    V4L2_CTRL_TYPE_BITMASK = 8,
    V4L2_CTRL_TYPE_INTEGER_MENU = 9,
    V4L2_CTRL_COMPOUND_TYPES = 256,
    V4L2_CTRL_TYPE_U8 = 256,
    V4L2_CTRL_TYPE_U16 = 257,
    V4L2_CTRL_TYPE_U32 = 258
} ;
#line 1400 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_queryctrl {
   __u32 id ;
   __u32 type ;
   __u8 name[32U] ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 step ;
   __s32 default_value ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_query_ext_ctrl {
   __u32 id ;
   __u32 type ;
   char name[32U] ;
   __s64 minimum ;
   __s64 maximum ;
   __u64 step ;
   __s64 default_value ;
   __u32 flags ;
   __u32 elem_size ;
   __u32 elems ;
   __u32 nr_of_dims ;
   __u32 dims[4U] ;
   __u32 reserved[32U] ;
};
#line 1437 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_222 {
   __u8 name[32U] ;
   __s64 value ;
};
#line 1437 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_querymenu {
   __u32 id ;
   __u32 index ;
   union __anonunion____missing_field_name_222 __annonCompField77 ;
   __u32 reserved ;
};
#line 1448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_tuner {
   __u32 index ;
   __u8 name[32U] ;
   __u32 type ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 rxsubchans ;
   __u32 audmode ;
   __s32 signal ;
   __s32 afc ;
   __u32 reserved[4U] ;
};
#line 1486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_modulator {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 txsubchans ;
   __u32 reserved[4U] ;
};
#line 1496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_frequency {
   __u32 tuner ;
   __u32 type ;
   __u32 frequency ;
   __u32 reserved[8U] ;
};
#line 1535 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_frequency_band {
   __u32 tuner ;
   __u32 type ;
   __u32 index ;
   __u32 capability ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 modulation ;
   __u32 reserved[9U] ;
};
#line 1550 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_hw_freq_seek {
   __u32 tuner ;
   __u32 type ;
   __u32 seek_upward ;
   __u32 wrap_around ;
   __u32 spacing ;
   __u32 rangelow ;
   __u32 rangehigh ;
   __u32 reserved[5U] ;
};
#line 1571 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_audio {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1593 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_audioout {
   __u32 index ;
   __u8 name[32U] ;
   __u32 capability ;
   __u32 mode ;
   __u32 reserved[2U] ;
};
#line 1608 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_enc_idx_entry {
   __u64 offset ;
   __u64 pts ;
   __u32 length ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1627 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_enc_idx {
   __u32 entries ;
   __u32 entries_cap ;
   __u32 reserved[4U] ;
   struct v4l2_enc_idx_entry entry[64U] ;
};
#line 1635 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct __anonstruct_raw_224 {
   __u32 data[8U] ;
};
#line 1635 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_223 {
   struct __anonstruct_raw_224 raw ;
};
#line 1635 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_encoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_223 __annonCompField78 ;
};
#line 1654 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct __anonstruct_stop_226 {
   __u64 pts ;
};
#line 1654 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct __anonstruct_start_227 {
   __s32 speed ;
   __u32 format ;
};
#line 1654 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct __anonstruct_raw_228 {
   __u32 data[16U] ;
};
#line 1654 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_225 {
   struct __anonstruct_stop_226 stop ;
   struct __anonstruct_start_227 start ;
   struct __anonstruct_raw_228 raw ;
};
#line 1654 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_decoder_cmd {
   __u32 cmd ;
   __u32 flags ;
   union __anonunion____missing_field_name_225 __annonCompField79 ;
};
#line 1703 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_vbi_format {
   __u32 sampling_rate ;
   __u32 offset ;
   __u32 samples_per_line ;
   __u32 sample_format ;
   __s32 start[2U] ;
   __u32 count[2U] ;
   __u32 flags ;
   __u32 reserved[2U] ;
};
#line 1723 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_format {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 io_size ;
   __u32 reserved[2U] ;
};
#line 1751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_cap {
   __u16 service_set ;
   __u16 service_lines[2U][24U] ;
   __u32 type ;
   __u32 reserved[3U] ;
};
#line 1775 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_sliced_vbi_data {
   __u32 id ;
   __u32 field ;
   __u32 line ;
   __u32 reserved ;
   __u8 data[48U] ;
};
#line 1830 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_plane_pix_format {
   __u32 sizeimage ;
   __u16 bytesperline ;
   __u16 reserved[7U] ;
};
#line 1847 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_pix_format_mplane {
   __u32 width ;
   __u32 height ;
   __u32 pixelformat ;
   __u32 field ;
   __u32 colorspace ;
   struct v4l2_plane_pix_format plane_fmt[8U] ;
   __u8 num_planes ;
   __u8 flags ;
   __u8 ycbcr_enc ;
   __u8 quantization ;
   __u8 reserved[8U] ;
};
#line 1875 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_sdr_format {
   __u32 pixelformat ;
   __u32 buffersize ;
   __u8 reserved[24U] ;
};
#line 1886 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion_fmt_230 {
   struct v4l2_pix_format pix ;
   struct v4l2_pix_format_mplane pix_mp ;
   struct v4l2_window win ;
   struct v4l2_vbi_format vbi ;
   struct v4l2_sliced_vbi_format sliced ;
   struct v4l2_sdr_format sdr ;
   __u8 raw_data[200U] ;
};
#line 1886 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_format {
   __u32 type ;
   union __anonunion_fmt_230 fmt ;
};
#line 1909 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion_parm_231 {
   struct v4l2_captureparm capture ;
   struct v4l2_outputparm output ;
   __u8 raw_data[200U] ;
};
#line 1909 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_streamparm {
   __u32 type ;
   union __anonunion_parm_231 parm ;
};
#line 2000 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_event_subscription {
   __u32 type ;
   __u32 id ;
   __u32 flags ;
   __u32 reserved[5U] ;
};
#line 2010 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
union __anonunion____missing_field_name_234 {
   __u32 addr ;
   char name[32U] ;
};
#line 2010 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_dbg_match {
   __u32 type ;
   union __anonunion____missing_field_name_234 __annonCompField82 ;
};
#line 2036 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_dbg_register {
   struct v4l2_dbg_match match ;
   __u32 size ;
   __u64 reg ;
   __u64 val ;
};
#line 2043 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_dbg_chip_info {
   struct v4l2_dbg_match match ;
   char name[32U] ;
   __u32 flags ;
   __u32 reserved[32U] ;
};
#line 2054 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_create_buffers {
   __u32 index ;
   __u32 count ;
   __u32 memory ;
   struct v4l2_format format ;
   __u32 reserved[8U] ;
};
#line 2071
struct v4l2_fh;
#line 2072 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/videodev2.h"
struct v4l2_ioctl_ops {
   int (*vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
   int (*vidioc_g_priority)(struct file * , void * , enum v4l2_priority * ) ;
   int (*vidioc_s_priority)(struct file * , void * , enum v4l2_priority  ) ;
   int (*vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_overlay)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_enum_fmt_sdr_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
   int (*vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_g_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_s_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_overlay)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sliced_vbi_out)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_cap_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_vid_out_mplane)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_try_fmt_sdr_cap)(struct file * , void * , struct v4l2_format * ) ;
   int (*vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
   int (*vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_expbuf)(struct file * , void * , struct v4l2_exportbuffer * ) ;
   int (*vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_create_bufs)(struct file * , void * , struct v4l2_create_buffers * ) ;
   int (*vidioc_prepare_buf)(struct file * , void * , struct v4l2_buffer * ) ;
   int (*vidioc_overlay)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_g_fbuf)(struct file * , void * , struct v4l2_framebuffer * ) ;
   int (*vidioc_s_fbuf)(struct file * , void * , struct v4l2_framebuffer  const  * ) ;
   int (*vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
   int (*vidioc_g_std)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_s_std)(struct file * , void * , v4l2_std_id  ) ;
   int (*vidioc_querystd)(struct file * , void * , v4l2_std_id * ) ;
   int (*vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
   int (*vidioc_g_input)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_input)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_enum_output)(struct file * , void * , struct v4l2_output * ) ;
   int (*vidioc_g_output)(struct file * , void * , unsigned int * ) ;
   int (*vidioc_s_output)(struct file * , void * , unsigned int  ) ;
   int (*vidioc_queryctrl)(struct file * , void * , struct v4l2_queryctrl * ) ;
   int (*vidioc_query_ext_ctrl)(struct file * , void * , struct v4l2_query_ext_ctrl * ) ;
   int (*vidioc_g_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_s_ctrl)(struct file * , void * , struct v4l2_control * ) ;
   int (*vidioc_g_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_s_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_try_ext_ctrls)(struct file * , void * , struct v4l2_ext_controls * ) ;
   int (*vidioc_querymenu)(struct file * , void * , struct v4l2_querymenu * ) ;
   int (*vidioc_enumaudio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_g_audio)(struct file * , void * , struct v4l2_audio * ) ;
   int (*vidioc_s_audio)(struct file * , void * , struct v4l2_audio  const  * ) ;
   int (*vidioc_enumaudout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_g_audout)(struct file * , void * , struct v4l2_audioout * ) ;
   int (*vidioc_s_audout)(struct file * , void * , struct v4l2_audioout  const  * ) ;
   int (*vidioc_g_modulator)(struct file * , void * , struct v4l2_modulator * ) ;
   int (*vidioc_s_modulator)(struct file * , void * , struct v4l2_modulator  const  * ) ;
   int (*vidioc_cropcap)(struct file * , void * , struct v4l2_cropcap * ) ;
   int (*vidioc_g_crop)(struct file * , void * , struct v4l2_crop * ) ;
   int (*vidioc_s_crop)(struct file * , void * , struct v4l2_crop  const  * ) ;
   int (*vidioc_g_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_s_selection)(struct file * , void * , struct v4l2_selection * ) ;
   int (*vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
   int (*vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression  const  * ) ;
   int (*vidioc_g_enc_index)(struct file * , void * , struct v4l2_enc_idx * ) ;
   int (*vidioc_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_try_encoder_cmd)(struct file * , void * , struct v4l2_encoder_cmd * ) ;
   int (*vidioc_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_try_decoder_cmd)(struct file * , void * , struct v4l2_decoder_cmd * ) ;
   int (*vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
   int (*vidioc_g_tuner)(struct file * , void * , struct v4l2_tuner * ) ;
   int (*vidioc_s_tuner)(struct file * , void * , struct v4l2_tuner  const  * ) ;
   int (*vidioc_g_frequency)(struct file * , void * , struct v4l2_frequency * ) ;
   int (*vidioc_s_frequency)(struct file * , void * , struct v4l2_frequency  const  * ) ;
   int (*vidioc_enum_freq_bands)(struct file * , void * , struct v4l2_frequency_band * ) ;
   int (*vidioc_g_sliced_vbi_cap)(struct file * , void * , struct v4l2_sliced_vbi_cap * ) ;
   int (*vidioc_log_status)(struct file * , void * ) ;
   int (*vidioc_s_hw_freq_seek)(struct file * , void * , struct v4l2_hw_freq_seek  const  * ) ;
   int (*vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
   int (*vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register  const  * ) ;
   int (*vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
   int (*vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
   int (*vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
   int (*vidioc_s_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_g_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_query_dv_timings)(struct file * , void * , struct v4l2_dv_timings * ) ;
   int (*vidioc_enum_dv_timings)(struct file * , void * , struct v4l2_enum_dv_timings * ) ;
   int (*vidioc_dv_timings_cap)(struct file * , void * , struct v4l2_dv_timings_cap * ) ;
   int (*vidioc_g_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_s_edid)(struct file * , void * , struct v4l2_edid * ) ;
   int (*vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   int (*vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
   long (*vidioc_default)(struct file * , void * , bool  , unsigned int  , void * ) ;
};
#line 315 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ioctl.h"
struct video_device;
#line 340
struct v4l2_ctrl_handler;
#line 341
struct v4l2_ctrl_helper;
#line 342
struct v4l2_ctrl;
#line 343
struct v4l2_subdev;
#line 345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ioctl.h"
union v4l2_ctrl_ptr {
   s32 *p_s32 ;
   s64 *p_s64 ;
   u8 *p_u8 ;
   u16 *p_u16 ;
   u32 *p_u32 ;
   char *p_char ;
   void *p ;
};
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ops {
   int (*g_volatile_ctrl)(struct v4l2_ctrl * ) ;
   int (*try_ctrl)(struct v4l2_ctrl * ) ;
   int (*s_ctrl)(struct v4l2_ctrl * ) ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
struct v4l2_ctrl_type_ops {
   bool (*equal)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  , union v4l2_ctrl_ptr  ) ;
   void (*init)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
   void (*log)(struct v4l2_ctrl  const  * ) ;
   int (*validate)(struct v4l2_ctrl  const  * , u32  , union v4l2_ctrl_ptr  ) ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_235 {
   u64 step ;
   u64 menu_skip_mask ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
union __anonunion____missing_field_name_236 {
   char const   * const  *qmenu ;
   s64 const   *qmenu_int ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
struct __anonstruct_cur_237 {
   s32 val ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
struct v4l2_ctrl {
   struct list_head node ;
   struct list_head ev_subs ;
   struct v4l2_ctrl_handler *handler ;
   struct v4l2_ctrl **cluster ;
   unsigned int ncontrols ;
   unsigned char done : 1 ;
   unsigned char is_new : 1 ;
   unsigned char has_changed : 1 ;
   unsigned char is_private : 1 ;
   unsigned char is_auto : 1 ;
   unsigned char is_int : 1 ;
   unsigned char is_string : 1 ;
   unsigned char is_ptr : 1 ;
   unsigned char is_array : 1 ;
   unsigned char has_volatiles : 1 ;
   unsigned char call_notify : 1 ;
   unsigned char manual_mode_value ;
   struct v4l2_ctrl_ops  const  *ops ;
   struct v4l2_ctrl_type_ops  const  *type_ops ;
   u32 id ;
   char const   *name ;
   enum v4l2_ctrl_type type ;
   s64 minimum ;
   s64 maximum ;
   s64 default_value ;
   u32 elems ;
   u32 elem_size ;
   u32 dims[4U] ;
   u32 nr_of_dims ;
   union __anonunion____missing_field_name_235 __annonCompField83 ;
   union __anonunion____missing_field_name_236 __annonCompField84 ;
   unsigned long flags ;
   void *priv ;
   s32 val ;
   struct __anonstruct_cur_237 cur ;
   union v4l2_ctrl_ptr p_new ;
   union v4l2_ctrl_ptr p_cur ;
};
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
struct v4l2_ctrl_ref {
   struct list_head node ;
   struct v4l2_ctrl_ref *next ;
   struct v4l2_ctrl *ctrl ;
   struct v4l2_ctrl_helper *helper ;
};
#line 229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
struct v4l2_ctrl_handler {
   struct mutex _lock ;
   struct mutex *lock ;
   struct list_head ctrls ;
   struct list_head ctrl_refs ;
   struct v4l2_ctrl_ref *cached ;
   struct v4l2_ctrl_ref **buckets ;
   void (*notify)(struct v4l2_ctrl * , void * ) ;
   void *notify_priv ;
   u16 nr_of_buckets ;
   int error ;
};
#line 837
struct v4l2_m2m_ctx;
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
struct v4l2_fh {
   struct list_head list ;
   struct video_device *vdev ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   enum v4l2_priority prio ;
   wait_queue_head_t wait ;
   struct list_head subscribed ;
   struct list_head available ;
   unsigned int navailable ;
   u32 sequence ;
   struct v4l2_m2m_ctx *m2m_ctx ;
};
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_242 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_242 __annonCompField85 ;
};
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212
struct module_sect_attrs;
#line 212
struct module_notes_attrs;
#line 212
struct tracepoint;
#line 212
struct ftrace_event_call;
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 129 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/media.h"
struct media_pipeline {

};
#line 132
struct media_pad;
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/media.h"
struct media_link {
   struct media_pad *source ;
   struct media_pad *sink ;
   struct media_link *reverse ;
   unsigned long flags ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
struct media_entity;
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
struct media_pad {
   struct media_entity *entity ;
   u16 index ;
   unsigned long flags ;
};
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
struct media_entity_operations {
   int (*link_setup)(struct media_entity * , struct media_pad  const  * , struct media_pad  const  * ,
                     u32  ) ;
   int (*link_validate)(struct media_link * ) ;
};
#line 53
struct media_device;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
struct __anonstruct_v4l_248 {
   u32 major ;
   u32 minor ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
struct __anonstruct_fb_249 {
   u32 major ;
   u32 minor ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
struct __anonstruct_alsa_250 {
   u32 card ;
   u32 device ;
   u32 subdevice ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
union __anonunion_info_247 {
   struct __anonstruct_v4l_248 v4l ;
   struct __anonstruct_fb_249 fb ;
   struct __anonstruct_alsa_250 alsa ;
   int dvb ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
struct media_entity {
   struct list_head list ;
   struct media_device *parent ;
   u32 id ;
   char const   *name ;
   u32 type ;
   u32 revision ;
   unsigned long flags ;
   u32 group_id ;
   u16 num_pads ;
   u16 num_links ;
   u16 num_backlinks ;
   u16 max_links ;
   struct media_pad *pads ;
   struct media_link *links ;
   struct media_entity_operations  const  *ops ;
   int stream_count ;
   int use_count ;
   struct media_pipeline *pipe ;
   union __anonunion_info_247 info ;
};
#line 156
struct v4l2_device;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-entity.h"
struct v4l2_prio_state {
   atomic_t prios[4U] ;
};
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
struct v4l2_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl32)(struct file * , unsigned int  , unsigned long  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 79
struct vb2_queue;
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
struct video_device {
   struct media_entity entity ;
   struct v4l2_file_operations  const  *fops ;
   struct device dev ;
   struct cdev *cdev ;
   struct v4l2_device *v4l2_dev ;
   struct device *dev_parent ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct vb2_queue *queue ;
   struct v4l2_prio_state *prio ;
   char name[32U] ;
   int vfl_type ;
   int vfl_dir ;
   int minor ;
   u16 num ;
   unsigned long flags ;
   int index ;
   spinlock_t fh_lock ;
   struct list_head fh_list ;
   int dev_debug ;
   v4l2_std_id tvnorms ;
   void (*release)(struct video_device * ) ;
   struct v4l2_ioctl_ops  const  *ioctl_ops ;
   unsigned long valid_ioctls[3U] ;
   unsigned long disable_locking[3U] ;
   struct mutex *lock ;
};
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-common.h"
struct v4l2_subdev_ops;
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-common.h"
struct v4l2_priv_tun_config {
   int tuner ;
   void *priv ;
};
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-common.h"
struct media_file_operations {
   struct module *owner ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*open)(struct file * ) ;
   int (*release)(struct file * ) ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-devnode.h"
struct media_devnode {
   struct media_file_operations  const  *fops ;
   struct device dev ;
   struct cdev cdev ;
   struct device *parent ;
   int minor ;
   unsigned long flags ;
   void (*release)(struct media_devnode * ) ;
};
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-devnode.h"
struct media_device {
   struct device *dev ;
   struct media_devnode devnode ;
   char model[32U] ;
   char serial[40U] ;
   char bus_info[32U] ;
   u32 hw_revision ;
   u32 driver_version ;
   u32 entity_id ;
   struct list_head entities ;
   spinlock_t lock ;
   struct mutex graph_mutex ;
   int (*link_notify)(struct media_link * , u32  , unsigned int  ) ;
};
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/media-device.h"
struct v4l2_mbus_framefmt {
   __u32 width ;
   __u32 height ;
   __u32 code ;
   __u32 field ;
   __u32 colorspace ;
   __u16 ycbcr_enc ;
   __u16 quantization ;
   __u32 reserved[6U] ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-mediabus.h"
struct v4l2_subdev_format {
   __u32 which ;
   __u32 pad ;
   struct v4l2_mbus_framefmt format ;
   __u32 reserved[8U] ;
};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_mbus_code_enum {
   __u32 pad ;
   __u32 index ;
   __u32 code ;
   __u32 reserved[9U] ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_size_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 min_width ;
   __u32 max_width ;
   __u32 min_height ;
   __u32 max_height ;
   __u32 reserved[9U] ;
};
#line 96 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval {
   __u32 pad ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_frame_interval_enum {
   __u32 index ;
   __u32 pad ;
   __u32 code ;
   __u32 width ;
   __u32 height ;
   struct v4l2_fract interval ;
   __u32 reserved[9U] ;
};
#line 126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct v4l2_subdev_selection {
   __u32 which ;
   __u32 pad ;
   __u32 target ;
   __u32 flags ;
   struct v4l2_rect r ;
   __u32 reserved[8U] ;
};
#line 150
struct v4l2_async_notifier;
#line 151
enum v4l2_async_match_type {
    V4L2_ASYNC_MATCH_CUSTOM = 0,
    V4L2_ASYNC_MATCH_DEVNAME = 1,
    V4L2_ASYNC_MATCH_I2C = 2,
    V4L2_ASYNC_MATCH_OF = 3
} ;
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_of_253 {
   struct device_node  const  *node ;
};
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_device_name_254 {
   char const   *name ;
};
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_i2c_255 {
   int adapter_id ;
   unsigned short address ;
};
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct __anonstruct_custom_256 {
   bool (*match)(struct device * , struct v4l2_async_subdev * ) ;
   void *priv ;
};
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
union __anonunion_match_252 {
   struct __anonstruct_of_253 of ;
   struct __anonstruct_device_name_254 device_name ;
   struct __anonstruct_i2c_255 i2c ;
   struct __anonstruct_custom_256 custom ;
};
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/v4l2-subdev.h"
struct v4l2_async_subdev {
   enum v4l2_async_match_type match_type ;
   union __anonunion_match_252 match ;
   struct list_head list ;
};
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-async.h"
struct v4l2_async_notifier {
   unsigned int num_subdevs ;
   struct v4l2_async_subdev **subdevs ;
   struct v4l2_device *v4l2_dev ;
   struct list_head waiting ;
   struct list_head done ;
   struct list_head list ;
   int (*bound)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
   int (*complete)(struct v4l2_async_notifier * ) ;
   void (*unbind)(struct v4l2_async_notifier * , struct v4l2_subdev * , struct v4l2_async_subdev * ) ;
};
#line 97
enum v4l2_mbus_type {
    V4L2_MBUS_PARALLEL = 0,
    V4L2_MBUS_BT656 = 1,
    V4L2_MBUS_CSI2 = 2
} ;
#line 103 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-async.h"
struct v4l2_mbus_config {
   enum v4l2_mbus_type type ;
   unsigned int flags ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-mediabus.h"
struct v4l2_subdev_fh;
#line 114
struct tuner_setup;
#line 115
struct v4l2_mbus_frame_desc;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-mediabus.h"
struct v4l2_decode_vbi_line {
   u32 is_second_field ;
   u8 *p ;
   u32 line ;
   u32 type ;
};
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_io_pin_config {
   u32 flags ;
   u8 pin ;
   u8 function ;
   u8 value ;
   u8 strength ;
};
#line 117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_core_ops {
   int (*log_status)(struct v4l2_subdev * ) ;
   int (*s_io_pin_config)(struct v4l2_subdev * , size_t  , struct v4l2_subdev_io_pin_config * ) ;
   int (*init)(struct v4l2_subdev * , u32  ) ;
   int (*load_fw)(struct v4l2_subdev * ) ;
   int (*reset)(struct v4l2_subdev * , u32  ) ;
   int (*s_gpio)(struct v4l2_subdev * , u32  ) ;
   int (*queryctrl)(struct v4l2_subdev * , struct v4l2_queryctrl * ) ;
   int (*g_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*s_ctrl)(struct v4l2_subdev * , struct v4l2_control * ) ;
   int (*g_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*s_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*try_ext_ctrls)(struct v4l2_subdev * , struct v4l2_ext_controls * ) ;
   int (*querymenu)(struct v4l2_subdev * , struct v4l2_querymenu * ) ;
   long (*ioctl)(struct v4l2_subdev * , unsigned int  , void * ) ;
   long (*compat_ioctl32)(struct v4l2_subdev * , unsigned int  , unsigned long  ) ;
   int (*g_register)(struct v4l2_subdev * , struct v4l2_dbg_register * ) ;
   int (*s_register)(struct v4l2_subdev * , struct v4l2_dbg_register  const  * ) ;
   int (*s_power)(struct v4l2_subdev * , int  ) ;
   int (*interrupt_service_routine)(struct v4l2_subdev * , u32  , bool * ) ;
   int (*subscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
   int (*unsubscribe_event)(struct v4l2_subdev * , struct v4l2_fh * , struct v4l2_event_subscription * ) ;
};
#line 178 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_tuner_ops {
   int (*s_radio)(struct v4l2_subdev * ) ;
   int (*s_frequency)(struct v4l2_subdev * , struct v4l2_frequency  const  * ) ;
   int (*g_frequency)(struct v4l2_subdev * , struct v4l2_frequency * ) ;
   int (*enum_freq_bands)(struct v4l2_subdev * , struct v4l2_frequency_band * ) ;
   int (*g_tuner)(struct v4l2_subdev * , struct v4l2_tuner * ) ;
   int (*s_tuner)(struct v4l2_subdev * , struct v4l2_tuner  const  * ) ;
   int (*g_modulator)(struct v4l2_subdev * , struct v4l2_modulator * ) ;
   int (*s_modulator)(struct v4l2_subdev * , struct v4l2_modulator  const  * ) ;
   int (*s_type_addr)(struct v4l2_subdev * , struct tuner_setup * ) ;
   int (*s_config)(struct v4l2_subdev * , struct v4l2_priv_tun_config  const  * ) ;
};
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_audio_ops {
   int (*s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_i2s_clock_freq)(struct v4l2_subdev * , u32  ) ;
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
};
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc_entry {
   u16 flags ;
   u32 pixelcode ;
   u32 length ;
};
#line 253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_mbus_frame_desc {
   struct v4l2_mbus_frame_desc_entry entry[4U] ;
   unsigned short num_entries ;
};
#line 265 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_video_ops {
   int (*s_routing)(struct v4l2_subdev * , u32  , u32  , u32  ) ;
   int (*s_crystal_freq)(struct v4l2_subdev * , u32  , u32  ) ;
   int (*g_std)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*s_std)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*s_std_output)(struct v4l2_subdev * , v4l2_std_id  ) ;
   int (*g_std_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*querystd)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_tvnorms_output)(struct v4l2_subdev * , v4l2_std_id * ) ;
   int (*g_input_status)(struct v4l2_subdev * , u32 * ) ;
   int (*s_stream)(struct v4l2_subdev * , int  ) ;
   int (*cropcap)(struct v4l2_subdev * , struct v4l2_cropcap * ) ;
   int (*g_crop)(struct v4l2_subdev * , struct v4l2_crop * ) ;
   int (*s_crop)(struct v4l2_subdev * , struct v4l2_crop  const  * ) ;
   int (*g_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*s_parm)(struct v4l2_subdev * , struct v4l2_streamparm * ) ;
   int (*g_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*s_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_frame_interval * ) ;
   int (*enum_framesizes)(struct v4l2_subdev * , struct v4l2_frmsizeenum * ) ;
   int (*enum_frameintervals)(struct v4l2_subdev * , struct v4l2_frmivalenum * ) ;
   int (*s_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*g_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*query_dv_timings)(struct v4l2_subdev * , struct v4l2_dv_timings * ) ;
   int (*enum_mbus_fmt)(struct v4l2_subdev * , unsigned int  , u32 * ) ;
   int (*g_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*try_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*s_mbus_fmt)(struct v4l2_subdev * , struct v4l2_mbus_framefmt * ) ;
   int (*g_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config * ) ;
   int (*s_mbus_config)(struct v4l2_subdev * , struct v4l2_mbus_config  const  * ) ;
   int (*s_rx_buffer)(struct v4l2_subdev * , void * , unsigned int * ) ;
};
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_vbi_ops {
   int (*decode_vbi_line)(struct v4l2_subdev * , struct v4l2_decode_vbi_line * ) ;
   int (*s_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data  const  * ) ;
   int (*g_vbi_data)(struct v4l2_subdev * , struct v4l2_sliced_vbi_data * ) ;
   int (*g_sliced_vbi_cap)(struct v4l2_subdev * , struct v4l2_sliced_vbi_cap * ) ;
   int (*s_raw_fmt)(struct v4l2_subdev * , struct v4l2_vbi_format * ) ;
   int (*g_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
   int (*s_sliced_fmt)(struct v4l2_subdev * , struct v4l2_sliced_vbi_format * ) ;
};
#line 397 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_sensor_ops {
   int (*g_skip_top_lines)(struct v4l2_subdev * , u32 * ) ;
   int (*g_skip_frames)(struct v4l2_subdev * , u32 * ) ;
};
#line 412
enum v4l2_subdev_ir_mode {
    V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0
} ;
#line 416 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_parameters {
   unsigned int bytes_per_data_element ;
   enum v4l2_subdev_ir_mode mode ;
   bool enable ;
   bool interrupt_enable ;
   bool shutdown ;
   bool modulation ;
   u32 max_pulse_width ;
   unsigned int carrier_freq ;
   unsigned int duty_cycle ;
   bool invert_level ;
   bool invert_carrier_sense ;
   u32 noise_filter_min_width ;
   unsigned int carrier_range_lower ;
   unsigned int carrier_range_upper ;
   u32 resolution ;
};
#line 464 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_ir_ops {
   int (*rx_read)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*rx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*rx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_write)(struct v4l2_subdev * , u8 * , size_t  , ssize_t * ) ;
   int (*tx_g_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
   int (*tx_s_parameters)(struct v4l2_subdev * , struct v4l2_subdev_ir_parameters * ) ;
};
#line 483 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_pad_ops {
   int (*enum_mbus_code)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_mbus_code_enum * ) ;
   int (*enum_frame_size)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_size_enum * ) ;
   int (*enum_frame_interval)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_frame_interval_enum * ) ;
   int (*get_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*set_fmt)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_format * ) ;
   int (*get_selection)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_selection * ) ;
   int (*set_selection)(struct v4l2_subdev * , struct v4l2_subdev_fh * , struct v4l2_subdev_selection * ) ;
   int (*get_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*set_edid)(struct v4l2_subdev * , struct v4l2_edid * ) ;
   int (*dv_timings_cap)(struct v4l2_subdev * , struct v4l2_dv_timings_cap * ) ;
   int (*enum_dv_timings)(struct v4l2_subdev * , struct v4l2_enum_dv_timings * ) ;
   int (*link_validate)(struct v4l2_subdev * , struct media_link * , struct v4l2_subdev_format * ,
                        struct v4l2_subdev_format * ) ;
   int (*get_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
   int (*set_frame_desc)(struct v4l2_subdev * , unsigned int  , struct v4l2_mbus_frame_desc * ) ;
};
#line 523 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_ops {
   struct v4l2_subdev_core_ops  const  *core ;
   struct v4l2_subdev_tuner_ops  const  *tuner ;
   struct v4l2_subdev_audio_ops  const  *audio ;
   struct v4l2_subdev_video_ops  const  *video ;
   struct v4l2_subdev_vbi_ops  const  *vbi ;
   struct v4l2_subdev_ir_ops  const  *ir ;
   struct v4l2_subdev_sensor_ops  const  *sensor ;
   struct v4l2_subdev_pad_ops  const  *pad ;
};
#line 535 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_internal_ops {
   int (*registered)(struct v4l2_subdev * ) ;
   void (*unregistered)(struct v4l2_subdev * ) ;
   int (*open)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
   int (*close)(struct v4l2_subdev * , struct v4l2_subdev_fh * ) ;
};
#line 556
struct regulator_bulk_data;
#line 557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_platform_data {
   struct regulator_bulk_data *regulators ;
   int num_regulators ;
   void *host_priv ;
};
#line 578 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev {
   struct media_entity entity ;
   struct list_head list ;
   struct module *owner ;
   bool owner_v4l2_dev ;
   u32 flags ;
   struct v4l2_device *v4l2_dev ;
   struct v4l2_subdev_ops  const  *ops ;
   struct v4l2_subdev_internal_ops  const  *internal_ops ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   char name[32U] ;
   u32 grp_id ;
   void *dev_priv ;
   void *host_priv ;
   struct video_device *devnode ;
   struct device *dev ;
   struct list_head async_list ;
   struct v4l2_async_subdev *asd ;
   struct v4l2_async_notifier *notifier ;
   struct v4l2_subdev_platform_data *pdata ;
};
#line 616 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct __anonstruct_pad_257 {
   struct v4l2_mbus_framefmt try_fmt ;
   struct v4l2_rect try_crop ;
   struct v4l2_rect try_compose ;
};
#line 616 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_subdev_fh {
   struct v4l2_fh vfh ;
   struct __anonstruct_pad_257 *pad ;
};
#line 685 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-subdev.h"
struct v4l2_device {
   struct device *dev ;
   struct media_device *mdev ;
   struct list_head subdevs ;
   spinlock_t lock ;
   char name[36U] ;
   void (*notify)(struct v4l2_subdev * , unsigned int  , void * ) ;
   struct v4l2_ctrl_handler *ctrl_handler ;
   struct v4l2_prio_state prio ;
   struct mutex ioctl_lock ;
   struct kref ref ;
   void (*release)(struct v4l2_device * ) ;
};
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.h"
struct framerates {
   u8 const   *rates ;
   int nrates ;
};
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.h"
struct cam {
   struct v4l2_pix_format  const  *cam_mode ;
   struct framerates  const  *mode_framerates ;
   u32 bulk_size ;
   u32 input_flags ;
   u8 nmodes ;
   u8 no_urb_create ;
   u8 bulk_nurbs ;
   u8 bulk ;
   u8 npkt ;
   u8 needs_full_bandwidth ;
};
#line 63
struct gspca_dev;
#line 64
struct gspca_frame;
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.h"
struct sd_desc {
   char const   *name ;
   int (*config)(struct gspca_dev * , struct usb_device_id  const  * ) ;
   int (*init)(struct gspca_dev * ) ;
   int (*init_controls)(struct gspca_dev * ) ;
   int (*start)(struct gspca_dev * ) ;
   void (*pkt_scan)(struct gspca_dev * , u8 * , int  ) ;
   int (*isoc_init)(struct gspca_dev * ) ;
   int (*isoc_nego)(struct gspca_dev * ) ;
   void (*stopN)(struct gspca_dev * ) ;
   void (*stop0)(struct gspca_dev * ) ;
   void (*dq_callback)(struct gspca_dev * ) ;
   int (*get_jcomp)(struct gspca_dev * , struct v4l2_jpegcompression * ) ;
   int (*set_jcomp)(struct gspca_dev * , struct v4l2_jpegcompression  const  * ) ;
   void (*get_streamparm)(struct gspca_dev * , struct v4l2_streamparm * ) ;
   void (*set_streamparm)(struct gspca_dev * , struct v4l2_streamparm * ) ;
   void (*try_fmt)(struct gspca_dev * , struct v4l2_format * ) ;
   int (*enum_framesizes)(struct gspca_dev * , struct v4l2_frmsizeenum * ) ;
   int (*set_register)(struct gspca_dev * , struct v4l2_dbg_register  const  * ) ;
   int (*get_register)(struct gspca_dev * , struct v4l2_dbg_register * ) ;
   int (*get_chip_info)(struct gspca_dev * , struct v4l2_dbg_chip_info * ) ;
   int (*int_pkt_scan)(struct gspca_dev * , u8 * , int  ) ;
   u8 other_input ;
};
#line 129
enum gspca_packet_type {
    DISCARD_PACKET = 0,
    FIRST_PACKET = 1,
    INTER_PACKET = 2,
    LAST_PACKET = 3
} ;
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.h"
struct gspca_frame {
   __u8 *data ;
   int vma_use_count ;
   struct v4l2_buffer v4l2_buf ;
};
#line 144
struct input_dev;
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.h"
struct __anonstruct____missing_field_name_258 {
   struct v4l2_ctrl *autogain ;
   struct v4l2_ctrl *exposure ;
   struct v4l2_ctrl *gain ;
   int exp_too_low_cnt ;
   int exp_too_high_cnt ;
};
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.h"
struct gspca_dev {
   struct video_device vdev ;
   struct module *module ;
   struct v4l2_device v4l2_dev ;
   struct usb_device *dev ;
   struct file *capt_file ;
   struct input_dev *input_dev ;
   char phys[64U] ;
   struct cam cam ;
   struct sd_desc  const  *sd_desc ;
   struct v4l2_ctrl_handler ctrl_handler ;
   struct __anonstruct____missing_field_name_258 __annonCompField87 ;
   __u8 *usb_buf ;
   struct urb *urb[4U] ;
   struct urb *int_urb ;
   __u8 *frbuf ;
   struct gspca_frame frame[16U] ;
   u8 *image ;
   __u32 frsz ;
   u32 image_len ;
   atomic_t fr_q ;
   atomic_t fr_i ;
   signed char fr_queue[16U] ;
   char nframes ;
   u8 fr_o ;
   __u8 last_packet_type ;
   __s8 empty_packet ;
   __u8 streaming ;
   __u8 curr_mode ;
   struct v4l2_pix_format pixfmt ;
   __u32 sequence ;
   wait_queue_head_t wq ;
   struct mutex usb_lock ;
   struct mutex queue_lock ;
   int usb_err ;
   u16 pkt_size ;
   char frozen ;
   char present ;
   char nbufread ;
   char memory ;
   __u8 iface ;
   __u8 alt ;
   int xfer_ep ;
   u8 audio ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct input_id {
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct input_absinfo {
   __s32 value ;
   __s32 minimum ;
   __s32 maximum ;
   __s32 fuzz ;
   __s32 flat ;
   __s32 resolution ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct input_keymap_entry {
   __u8 flags ;
   __u8 len ;
   __u16 index ;
   __u32 keycode ;
   __u8 scancode[32U] ;
};
#line 99 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_replay {
   __u16 length ;
   __u16 delay ;
};
#line 1004 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_trigger {
   __u16 button ;
   __u16 interval ;
};
#line 1014 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_envelope {
   __u16 attack_length ;
   __u16 attack_level ;
   __u16 fade_length ;
   __u16 fade_level ;
};
#line 1033 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_constant_effect {
   __s16 level ;
   struct ff_envelope envelope ;
};
#line 1043 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_ramp_effect {
   __s16 start_level ;
   __s16 end_level ;
   struct ff_envelope envelope ;
};
#line 1055 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_condition_effect {
   __u16 right_saturation ;
   __u16 left_saturation ;
   __s16 right_coeff ;
   __s16 left_coeff ;
   __u16 deadband ;
   __s16 center ;
};
#line 1076 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_periodic_effect {
   __u16 waveform ;
   __u16 period ;
   __s16 magnitude ;
   __s16 offset ;
   __u16 phase ;
   struct ff_envelope envelope ;
   __u32 custom_len ;
   __s16 *custom_data ;
};
#line 1107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_rumble_effect {
   __u16 strong_magnitude ;
   __u16 weak_magnitude ;
};
#line 1120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
union __anonunion_u_259 {
   struct ff_constant_effect constant ;
   struct ff_ramp_effect ramp ;
   struct ff_periodic_effect periodic ;
   struct ff_condition_effect condition[2U] ;
   struct ff_rumble_effect rumble ;
};
#line 1120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct ff_effect {
   __u16 type ;
   __s16 id ;
   __u16 direction ;
   struct ff_trigger trigger ;
   struct ff_replay replay ;
   union __anonunion_u_259 u ;
};
#line 1159 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/input.h"
struct input_value {
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/input.h"
struct ff_device;
#line 38
struct input_mt;
#line 38
struct input_handle;
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/input.h"
struct input_dev {
   char const   *name ;
   char const   *phys ;
   char const   *uniq ;
   struct input_id id ;
   unsigned long propbit[1U] ;
   unsigned long evbit[1U] ;
   unsigned long keybit[12U] ;
   unsigned long relbit[1U] ;
   unsigned long absbit[1U] ;
   unsigned long mscbit[1U] ;
   unsigned long ledbit[1U] ;
   unsigned long sndbit[1U] ;
   unsigned long ffbit[2U] ;
   unsigned long swbit[1U] ;
   unsigned int hint_events_per_packet ;
   unsigned int keycodemax ;
   unsigned int keycodesize ;
   void *keycode ;
   int (*setkeycode)(struct input_dev * , struct input_keymap_entry  const  * , unsigned int * ) ;
   int (*getkeycode)(struct input_dev * , struct input_keymap_entry * ) ;
   struct ff_device *ff ;
   unsigned int repeat_key ;
   struct timer_list timer ;
   int rep[2U] ;
   struct input_mt *mt ;
   struct input_absinfo *absinfo ;
   unsigned long key[12U] ;
   unsigned long led[1U] ;
   unsigned long snd[1U] ;
   unsigned long sw[1U] ;
   int (*open)(struct input_dev * ) ;
   void (*close)(struct input_dev * ) ;
   int (*flush)(struct input_dev * , struct file * ) ;
   int (*event)(struct input_dev * , unsigned int  , unsigned int  , int  ) ;
   struct input_handle *grab ;
   spinlock_t event_lock ;
   struct mutex mutex ;
   unsigned int users ;
   bool going_away ;
   struct device dev ;
   struct list_head h_list ;
   struct list_head node ;
   unsigned int num_vals ;
   unsigned int max_vals ;
   struct input_value *vals ;
   bool devres_managed ;
};
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/input.h"
struct input_handler {
   void *private ;
   void (*event)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   void (*events)(struct input_handle * , struct input_value  const  * , unsigned int  ) ;
   bool (*filter)(struct input_handle * , unsigned int  , unsigned int  , int  ) ;
   bool (*match)(struct input_handler * , struct input_dev * ) ;
   int (*connect)(struct input_handler * , struct input_dev * , struct input_device_id  const  * ) ;
   void (*disconnect)(struct input_handle * ) ;
   void (*start)(struct input_handle * ) ;
   bool legacy_minors ;
   int minor ;
   char const   *name ;
   struct input_device_id  const  *id_table ;
   struct list_head h_list ;
   struct list_head node ;
};
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/input.h"
struct input_handle {
   void *private ;
   int open ;
   char const   *name ;
   struct input_dev *dev ;
   struct input_handler *handler ;
   struct list_head d_node ;
   struct list_head h_node ;
};
#line 473 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/input.h"
struct ff_device {
   int (*upload)(struct input_dev * , struct ff_effect * , struct ff_effect * ) ;
   int (*erase)(struct input_dev * , int  ) ;
   int (*playback)(struct input_dev * , int  , int  ) ;
   void (*set_gain)(struct input_dev * , u16  ) ;
   void (*set_autocenter)(struct input_dev * , u16  ) ;
   void (*destroy)(struct ff_device * ) ;
   void *private ;
   unsigned long ffbit[2U] ;
   struct mutex mutex ;
   int max_effects ;
   struct ff_effect *effects ;
   struct file *effect_owners[] ;
};
#line 664 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct ep_tb_s {
   u32 alt ;
   u32 bandwidth ;
};
#line 2278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct ldv_struct_EMGentry_2 {
   int signal_pending ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request;
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   struct kthread_worker *worker ;
};
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/scatterlist.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
struct dma_chan;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};
#line 151
struct spi_message;
#line 152
struct spi_transfer;
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
   bool (*can_dma)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master * ) ;
   int (*transfer_one_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_transfer_hardware)(struct spi_master * ) ;
   int (*prepare_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_message)(struct spi_master * , struct spi_message * ) ;
   void (*set_cs)(struct spi_device * , bool  ) ;
   int (*transfer_one)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};
#line 506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_transfer {
   void const   *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned char cs_change : 1 ;
   unsigned char tx_nbits : 3 ;
   unsigned char rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};
#line 630 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned char is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct notifier_block;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 720 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/pm.h"
typedef unsigned int mmc_pm_flag_t;
#line 26
struct mmc_card;
#line 27
struct sdio_func;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
typedef void sdio_irq_handler_t(struct sdio_func * );
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func_tuple {
   struct sdio_func_tuple *next ;
   unsigned char code ;
   unsigned char size ;
   unsigned char data[0U] ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func {
   struct mmc_card *card ;
   struct device dev ;
   sdio_irq_handler_t *irq_handler ;
   unsigned int num ;
   unsigned char class ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned int max_blksize ;
   unsigned int cur_blksize ;
   unsigned int enable_timeout ;
   unsigned int state ;
   u8 tmpbuf[4U] ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
};
#line 161
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
} ;
#line 167
struct led_trigger;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct led_classdev {
   char const   *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev * , enum led_brightness  ) ;
   int (*brightness_set_sync)(struct led_classdev * , enum led_brightness  ) ;
   enum led_brightness (*brightness_get)(struct led_classdev * ) ;
   int (*blink_set)(struct led_classdev * , unsigned long * , unsigned long * ) ;
   struct device *dev ;
   struct attribute_group  const  **groups ;
   struct list_head node ;
   char const   *default_trigger ;
   unsigned long blink_delay_on ;
   unsigned long blink_delay_off ;
   struct timer_list blink_timer ;
   int blink_brightness ;
   void (*flash_resume)(struct led_classdev * ) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/leds.h"
struct led_trigger {
   char const   *name ;
   void (*activate)(struct led_classdev * ) ;
   void (*deactivate)(struct led_classdev * ) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debugfs.h"
struct fault_attr {
   unsigned long probability ;
   unsigned long interval ;
   atomic_t times ;
   atomic_t space ;
   unsigned long verbose ;
   u32 task_filter ;
   unsigned long stacktrace_depth ;
   unsigned long require_start ;
   unsigned long require_end ;
   unsigned long reject_start ;
   unsigned long reject_end ;
   unsigned long count ;
   struct ratelimit_state ratelimit_state ;
   struct dentry *dname ;
};
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_data;
#line 654
struct mmc_request;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_command {
   u32 opcode ;
   u32 arg ;
   u32 resp[4U] ;
   unsigned int flags ;
   unsigned int retries ;
   unsigned int error ;
   unsigned int busy_timeout ;
   bool sanitize_busy ;
   struct mmc_data *data ;
   struct mmc_request *mrq ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_data {
   unsigned int timeout_ns ;
   unsigned int timeout_clks ;
   unsigned int blksz ;
   unsigned int blocks ;
   unsigned int error ;
   unsigned int flags ;
   unsigned int bytes_xfered ;
   struct mmc_command *stop ;
   struct mmc_request *mrq ;
   unsigned int sg_len ;
   struct scatterlist *sg ;
   s32 host_cookie ;
};
#line 127
struct mmc_host;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_request {
   struct mmc_command *sbc ;
   struct mmc_command *cmd ;
   struct mmc_data *data ;
   struct mmc_command *stop ;
   struct completion completion ;
   void (*done)(struct mmc_request * ) ;
   struct mmc_host *host ;
};
#line 139
struct mmc_async_req;
#line 214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_cid {
   unsigned int manfid ;
   char prod_name[8U] ;
   unsigned char prv ;
   unsigned int serial ;
   unsigned short oemid ;
   unsigned short year ;
   unsigned char hwrev ;
   unsigned char fwrev ;
   unsigned char month ;
};
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_csd {
   unsigned char structure ;
   unsigned char mmca_vsn ;
   unsigned short cmdclass ;
   unsigned short tacc_clks ;
   unsigned int tacc_ns ;
   unsigned int c_size ;
   unsigned int r2w_factor ;
   unsigned int max_dtr ;
   unsigned int erase_size ;
   unsigned int read_blkbits ;
   unsigned int write_blkbits ;
   unsigned int capacity ;
   unsigned char read_partial : 1 ;
   unsigned char read_misalign : 1 ;
   unsigned char write_partial : 1 ;
   unsigned char write_misalign : 1 ;
   unsigned char dsr_imp : 1 ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ext_csd {
   u8 rev ;
   u8 erase_group_def ;
   u8 sec_feature_support ;
   u8 rel_sectors ;
   u8 rel_param ;
   u8 part_config ;
   u8 cache_ctrl ;
   u8 rst_n_function ;
   u8 max_packed_writes ;
   u8 max_packed_reads ;
   u8 packed_event_en ;
   unsigned int part_time ;
   unsigned int sa_timeout ;
   unsigned int generic_cmd6_time ;
   unsigned int power_off_longtime ;
   u8 power_off_notification ;
   unsigned int hs_max_dtr ;
   unsigned int hs200_max_dtr ;
   unsigned int sectors ;
   unsigned int hc_erase_size ;
   unsigned int hc_erase_timeout ;
   unsigned int sec_trim_mult ;
   unsigned int sec_erase_mult ;
   unsigned int trim_timeout ;
   bool partition_setting_completed ;
   unsigned long long enhanced_area_offset ;
   unsigned int enhanced_area_size ;
   unsigned int cache_size ;
   bool hpi_en ;
   bool hpi ;
   unsigned int hpi_cmd ;
   bool bkops ;
   bool man_bkops_en ;
   unsigned int data_sector_size ;
   unsigned int data_tag_unit_size ;
   unsigned int boot_ro_lock ;
   bool boot_ro_lockable ;
   bool ffu_capable ;
   u8 fwrev[8U] ;
   u8 raw_exception_status ;
   u8 raw_partition_support ;
   u8 raw_rpmb_size_mult ;
   u8 raw_erased_mem_count ;
   u8 raw_ext_csd_structure ;
   u8 raw_card_type ;
   u8 out_of_int_time ;
   u8 raw_pwr_cl_52_195 ;
   u8 raw_pwr_cl_26_195 ;
   u8 raw_pwr_cl_52_360 ;
   u8 raw_pwr_cl_26_360 ;
   u8 raw_s_a_timeout ;
   u8 raw_hc_erase_gap_size ;
   u8 raw_erase_timeout_mult ;
   u8 raw_hc_erase_grp_size ;
   u8 raw_sec_trim_mult ;
   u8 raw_sec_erase_mult ;
   u8 raw_sec_feature_support ;
   u8 raw_trim_mult ;
   u8 raw_pwr_cl_200_195 ;
   u8 raw_pwr_cl_200_360 ;
   u8 raw_pwr_cl_ddr_52_195 ;
   u8 raw_pwr_cl_ddr_52_360 ;
   u8 raw_pwr_cl_ddr_200_360 ;
   u8 raw_bkops_status ;
   u8 raw_sectors[4U] ;
   unsigned int feature_support ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_scr {
   unsigned char sda_vsn ;
   unsigned char sda_spec3 ;
   unsigned char bus_widths ;
   unsigned char cmds ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_ssr {
   unsigned int au ;
   unsigned int erase_timeout ;
   unsigned int erase_offset ;
};
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_switch_caps {
   unsigned int hs_max_dtr ;
   unsigned int uhs_max_dtr ;
   unsigned int sd3_bus_mode ;
   unsigned int sd3_drv_type ;
   unsigned int sd3_curr_limit ;
};
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cccr {
   unsigned int sdio_vsn ;
   unsigned int sd_vsn ;
   unsigned char multi_block : 1 ;
   unsigned char low_speed : 1 ;
   unsigned char wide_bus : 1 ;
   unsigned char high_power : 1 ;
   unsigned char high_speed : 1 ;
   unsigned char disable_cd : 1 ;
};
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cis {
   unsigned short vendor ;
   unsigned short device ;
   unsigned short blksize ;
   unsigned int max_dtr ;
};
#line 200
struct mmc_ios;
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_part {
   unsigned int size ;
   unsigned int part_cfg ;
   char name[20U] ;
   bool force_ro ;
   unsigned int area_type ;
};
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_card {
   struct mmc_host *host ;
   struct device dev ;
   u32 ocr ;
   unsigned int rca ;
   unsigned int type ;
   unsigned int state ;
   unsigned int quirks ;
   unsigned int erase_size ;
   unsigned int erase_shift ;
   unsigned int pref_erase ;
   u8 erased_byte ;
   u32 raw_cid[4U] ;
   u32 raw_csd[4U] ;
   u32 raw_scr[2U] ;
   struct mmc_cid cid ;
   struct mmc_csd csd ;
   struct mmc_ext_csd ext_csd ;
   struct sd_scr scr ;
   struct sd_ssr ssr ;
   struct sd_switch_caps sw_caps ;
   unsigned int sdio_funcs ;
   struct sdio_cccr cccr ;
   struct sdio_cis cis ;
   struct sdio_func *sdio_func[7U] ;
   struct sdio_func *sdio_single_irq ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
   unsigned int sd_bus_speed ;
   unsigned int mmc_avail_type ;
   struct dentry *debugfs_root ;
   struct mmc_part part[7U] ;
   unsigned int nr_parts ;
};
#line 519 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ios {
   unsigned int clock ;
   unsigned short vdd ;
   unsigned char bus_mode ;
   unsigned char chip_select ;
   unsigned char power_mode ;
   unsigned char bus_width ;
   unsigned char timing ;
   unsigned char signal_voltage ;
   unsigned char drv_type ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host_ops {
   int (*enable)(struct mmc_host * ) ;
   int (*disable)(struct mmc_host * ) ;
   void (*post_req)(struct mmc_host * , struct mmc_request * , int  ) ;
   void (*pre_req)(struct mmc_host * , struct mmc_request * , bool  ) ;
   void (*request)(struct mmc_host * , struct mmc_request * ) ;
   void (*set_ios)(struct mmc_host * , struct mmc_ios * ) ;
   int (*get_ro)(struct mmc_host * ) ;
   int (*get_cd)(struct mmc_host * ) ;
   void (*enable_sdio_irq)(struct mmc_host * , int  ) ;
   void (*init_card)(struct mmc_host * , struct mmc_card * ) ;
   int (*start_signal_voltage_switch)(struct mmc_host * , struct mmc_ios * ) ;
   int (*card_busy)(struct mmc_host * ) ;
   int (*execute_tuning)(struct mmc_host * , u32  ) ;
   int (*prepare_hs400_tuning)(struct mmc_host * , struct mmc_ios * ) ;
   int (*select_drive_strength)(unsigned int  , int  , int  ) ;
   void (*hw_reset)(struct mmc_host * ) ;
   void (*card_event)(struct mmc_host * ) ;
   int (*multi_io_quirk)(struct mmc_card * , unsigned int  , int  ) ;
};
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_async_req {
   struct mmc_request *mrq ;
   int (*err_check)(struct mmc_card * , struct mmc_async_req * ) ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_slot {
   int cd_irq ;
   void *handler_priv ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_context_info {
   bool is_done_rcv ;
   bool is_new_req ;
   bool is_waiting_last_req ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
};
#line 196
struct regulator;
#line 197
struct mmc_pwrseq;
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_supply {
   struct regulator *vmmc ;
   struct regulator *vqmmc ;
};
#line 204
struct mmc_bus_ops;
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host {
   struct device *parent ;
   struct device class_dev ;
   int index ;
   struct mmc_host_ops  const  *ops ;
   struct mmc_pwrseq *pwrseq ;
   unsigned int f_min ;
   unsigned int f_max ;
   unsigned int f_init ;
   u32 ocr_avail ;
   u32 ocr_avail_sdio ;
   u32 ocr_avail_sd ;
   u32 ocr_avail_mmc ;
   struct notifier_block pm_notify ;
   u32 max_current_330 ;
   u32 max_current_300 ;
   u32 max_current_180 ;
   u32 caps ;
   u32 caps2 ;
   mmc_pm_flag_t pm_caps ;
   int clk_requests ;
   unsigned int clk_delay ;
   bool clk_gated ;
   struct delayed_work clk_gate_work ;
   unsigned int clk_old ;
   spinlock_t clk_lock ;
   struct mutex clk_gate_mutex ;
   struct device_attribute clkgate_delay_attr ;
   unsigned long clkgate_delay ;
   unsigned int max_seg_size ;
   unsigned short max_segs ;
   unsigned short unused ;
   unsigned int max_req_size ;
   unsigned int max_blk_size ;
   unsigned int max_blk_count ;
   unsigned int max_busy_timeout ;
   spinlock_t lock ;
   struct mmc_ios ios ;
   unsigned char use_spi_crc : 1 ;
   unsigned char claimed : 1 ;
   unsigned char bus_dead : 1 ;
   unsigned char removed : 1 ;
   int rescan_disable ;
   int rescan_entered ;
   bool trigger_card_event ;
   struct mmc_card *card ;
   wait_queue_head_t wq ;
   struct task_struct *claimer ;
   int claim_cnt ;
   struct delayed_work detect ;
   int detect_change ;
   struct mmc_slot slot ;
   struct mmc_bus_ops  const  *bus_ops ;
   unsigned int bus_refs ;
   unsigned int sdio_irqs ;
   struct task_struct *sdio_irq_thread ;
   bool sdio_irq_pending ;
   atomic_t sdio_irq_thread_abort ;
   mmc_pm_flag_t pm_flags ;
   struct led_trigger *led ;
   bool regulator_enabled ;
   struct mmc_supply supply ;
   struct dentry *debugfs_root ;
   struct mmc_async_req *areq ;
   struct mmc_context_info context_info ;
   struct fault_attr fail_mmc_request ;
   unsigned int actual_clock ;
   unsigned int slotno ;
   int dsr_req ;
   u32 dsr ;
   unsigned long private[0U] ;
};
#line 24 "/home/ubuntu/klever-work/verifier/map.h"
typedef int ldv_map;
#line 8 "thread.c"
struct ldv_thread_set {
   int number ;
   struct ldv_thread **threads ;
};
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct ldv_thread {
   int identifier ;
   void (*function)(void * ) ;
};
#line 22 "/home/ubuntu/klever-work/verifier/set.h"
typedef _Bool ldv_set;
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 28 "/home/ubuntu/klever-work/verifier/common.h"
void ldv_assume(int expression ) ;
#line 31
void ldv_stop(void) ;
#line 6 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) ;
#line 7
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) ;
#line 11
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) ;
#line 16
void ldv_linux_arch_io_check_final_state(void) ;
#line 20
void ldv_linux_block_genhd_check_final_state(void) ;
#line 24
void ldv_linux_block_queue_check_final_state(void) ;
#line 28
void ldv_linux_block_request_check_final_state(void) ;
#line 32
void *ldv_linux_drivers_base_class_create_class(void) ;
#line 33
int ldv_linux_drivers_base_class_register_class(void) ;
#line 37
void ldv_linux_drivers_base_class_check_final_state(void) ;
#line 48
void ldv_linux_fs_char_dev_check_final_state(void) ;
#line 52
void ldv_linux_fs_sysfs_check_final_state(void) ;
#line 56
void ldv_linux_kernel_locking_rwlock_check_final_state(void) ;
#line 60
void ldv_linux_kernel_module_check_final_state(void) ;
#line 64
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) ;
#line 65
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) ;
#line 69
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) ;
#line 70
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) ;
#line 74
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) ;
#line 75
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) ;
#line 79
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) ;
#line 80
void ldv_linux_kernel_rcu_srcu_check_final_state(void) ;
#line 84
void ldv_linux_lib_find_bit_initialize(void) ;
#line 88
void ldv_linux_lib_idr_check_final_state(void) ;
#line 92
void ldv_linux_mmc_sdio_func_check_final_state(void) ;
#line 96
void ldv_linux_net_register_reset_error_counter(void) ;
#line 101
void ldv_linux_net_rtnetlink_check_final_state(void) ;
#line 105
void ldv_linux_net_sock_check_final_state(void) ;
#line 109
void *ldv_linux_usb_coherent_usb_alloc_coherent(void) ;
#line 110
void ldv_linux_usb_coherent_check_final_state(void) ;
#line 114
void *ldv_linux_usb_gadget_create_class(void) ;
#line 115
int ldv_linux_usb_gadget_register_class(void) ;
#line 122
void ldv_linux_usb_gadget_check_final_state(void) ;
#line 126
void ldv_linux_usb_register_reset_error_counter(void) ;
#line 131
struct urb *ldv_linux_usb_urb_usb_alloc_urb(void) ;
#line 132
void ldv_linux_usb_urb_check_final_state(void) ;
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 139
  ldv_linux_alloc_irq_check_alloc_nonatomic();
#line 143
  ldv_linux_alloc_usb_lock_check_alloc_nonatomic();
  }
#line 144
  return;
}
}
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
  {
#line 150
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 154
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 155
  return;
}
}
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_check_for_read_section(void) 
{ 


  {
  {
#line 161
  ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section();
#line 165
  ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section();
#line 169
  ldv_linux_kernel_rcu_update_lock_check_for_read_section();
#line 173
  ldv_linux_kernel_rcu_srcu_check_for_read_section();
  }
#line 174
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void *ldv_create_class(void) 
{ 
  void *res1 ;
  void *tmp ;
  void *res2 ;
  void *tmp___0 ;

  {
  {
#line 180
  tmp = ldv_linux_drivers_base_class_create_class();
#line 180
  res1 = tmp;
#line 181
  tmp___0 = ldv_linux_usb_gadget_create_class();
#line 181
  res2 = tmp___0;
#line 182
  ldv_assume((unsigned long )res1 == (unsigned long )res2);
  }
#line 183
  return (res1);
}
}
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
int ldv_register_class(void) 
{ 
  int res1 ;
  int tmp ;
  int res2 ;
  int tmp___0 ;

  {
  {
#line 194
  tmp = ldv_linux_drivers_base_class_register_class();
#line 194
  res1 = tmp;
#line 195
  tmp___0 = ldv_linux_usb_gadget_register_class();
#line 195
  res2 = tmp___0;
#line 196
  ldv_assume(res1 == res2);
  }
#line 197
  return (res1);
}
}
#line 21 "/home/ubuntu/klever-work/linux/ldv/err.h"
long ldv_is_err(void const   *ptr ) ;
#line 217 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void *ldv_kzalloc(size_t size , gfp_t flags ) ;
#line 244
void ldv_linux_usb_coherent_usb_free_coherent(void *addr ) ;
#line 22 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 34 "/home/ubuntu/klever-work/linux/ldv/common.h"
static void ldv_ldv_initialize_154(void) ;
#line 47
int ldv_post_init(int init_ret_val ) ;
#line 50
static int ldv_ldv_post_init_151(int ldv_func_arg1 ) ;
#line 75
int ldv_filter_err_code(int ret_val ) ;
#line 122
static void ldv_ldv_check_final_state_152(void) ;
#line 126
static void ldv_ldv_check_final_state_153(void) ;
#line 32 "/home/ubuntu/klever-work/verifier/memory.h"
void ldv_free(void *s ) ;
#line 34
void *ldv_xmalloc(size_t size ) ;
#line 39
void *ldv_malloc_unknown_size(void) ;
#line 308 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
extern void ldv_after_alloc(void * ) ;
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void *ldv_alloc_macro(gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 312
  ldv_check_alloc_flags(flags);
#line 313
  tmp = ldv_malloc_unknown_size();
  }
#line 313
  return (tmp);
}
}
#line 341
int ldv_linux_kernel_module_try_module_get(struct module *module ) ;
#line 343
void ldv_linux_kernel_module_module_put(struct module *module ) ;
#line 370
static void ldv_mutex_lock_137(struct mutex *ldv_func_arg1 ) ;
#line 374
static void ldv_mutex_lock_145(struct mutex *ldv_func_arg1 ) ;
#line 378
static void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) ;
#line 382
static void ldv_mutex_lock_149(struct mutex *ldv_func_arg1 ) ;
#line 388
static int ldv_mutex_lock_interruptible_113(struct mutex *ldv_func_arg1 ) ;
#line 392
static int ldv_mutex_lock_interruptible_117(struct mutex *ldv_func_arg1 ) ;
#line 396
static int ldv_mutex_lock_interruptible_118(struct mutex *ldv_func_arg1 ) ;
#line 400
static int ldv_mutex_lock_interruptible_123(struct mutex *ldv_func_arg1 ) ;
#line 404
static int ldv_mutex_lock_interruptible_125(struct mutex *ldv_func_arg1 ) ;
#line 408
static int ldv_mutex_lock_interruptible_127(struct mutex *ldv_func_arg1 ) ;
#line 412
static int ldv_mutex_lock_interruptible_129(struct mutex *ldv_func_arg1 ) ;
#line 416
static int ldv_mutex_lock_interruptible_131(struct mutex *ldv_func_arg1 ) ;
#line 420
static int ldv_mutex_lock_interruptible_133(struct mutex *ldv_func_arg1 ) ;
#line 424
static int ldv_mutex_lock_interruptible_135(struct mutex *ldv_func_arg1 ) ;
#line 428
static int ldv_mutex_lock_interruptible_139(struct mutex *ldv_func_arg1 ) ;
#line 432
static int ldv_mutex_lock_interruptible_141(struct mutex *ldv_func_arg1 ) ;
#line 436
static int ldv_mutex_lock_interruptible_143(struct mutex *ldv_func_arg1 ) ;
#line 468
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(struct mutex *lock ) ;
#line 474
void ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(struct mutex *lock ) ;
#line 475
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_usb_lock_of_gspca_dev(struct mutex *lock ) ;
#line 477
void ldv_linux_kernel_locking_mutex_mutex_lock_usb_lock_of_gspca_dev(struct mutex *lock ) ;
#line 481
void ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(struct mutex *lock ) ;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/export.h"
extern struct module __this_module ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 80
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
#line 82
  return;
}
}
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 235
extern void might_fault(void) ;
#line 392
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  {
#line 14
  if (8UL == 1UL) {
#line 14
    goto case_1;
  } else {

  }
#line 14
  if (8UL == 2UL) {
#line 14
    goto case_2;
  } else {

  }
#line 14
  if (8UL == 4UL) {
#line 14
    goto case_4;
  } else {

  }
#line 14
  if (8UL == 8UL) {
#line 14
    goto case_8;
  } else {

  }
#line 14
  goto switch_default;
  case_1: /* CIL Label */ 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3650;
  case_2: /* CIL Label */ 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3650;
  case_4: /* CIL Label */ 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3650;
  case_8: /* CIL Label */ 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3650;
  switch_default: /* CIL Label */ 
  {
#line 14
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_3650: ;
#line 14
  return (pfo_ret__);
}
}
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *__memset(void * , int  , size_t  ) ;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 35
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;

  {
#line 27
  __var = 0;
#line 27
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/atomic.h"
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
#line 39
  v->counter = i;
#line 40
  return;
}
}
#line 569 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_linux_usb_urb_usb_free_urb(struct urb *urb ) ;
#line 448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_dir_in(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 450
  return ((int )((signed char )epd->bEndpointAddress) < 0);
}
}
#line 498 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/usb/ch9.h"
__inline static int usb_endpoint_xfer_int(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
#line 501
  return (((int )epd->bmAttributes & 3) == 3);
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/time.h"
extern struct timeval ns_to_timeval(s64 const    ) ;
#line 291 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
extern ktime_t ktime_get(void) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
#line 149
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 913
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 914
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
#line 197
static void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1 ) ;
#line 201
static void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) ;
#line 205
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) ;
#line 209
static void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) ;
#line 213
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) ;
#line 217
static void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1 ) ;
#line 221
static void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) ;
#line 225
static void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) ;
#line 229
static void ldv_mutex_unlock_132(struct mutex *ldv_func_arg1 ) ;
#line 233
static void ldv_mutex_unlock_134(struct mutex *ldv_func_arg1 ) ;
#line 237
static void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1 ) ;
#line 241
static void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) ;
#line 245
static void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) ;
#line 249
static void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) ;
#line 253
static void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) ;
#line 257
static void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) ;
#line 261
static void ldv_mutex_unlock_148(struct mutex *ldv_func_arg1 ) ;
#line 265
static void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) ;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/vmalloc.h"
static void *ldv_vmalloc_32_107(unsigned long ldv_func_arg1 ) ;
#line 86
extern void vfree(void const   * ) ;
#line 647 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 672
extern void __copy_to_user_overflow(void) ;
#line 723 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 725
  sz = -1;
#line 727
  might_fault();
#line 730
  tmp = __builtin_expect(sz < 0, 1L);
  }
#line 730
  if (tmp != 0L) {
    {
#line 731
    n = _copy_to_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 730
    tmp___0 = __builtin_expect((unsigned long )sz >= n, 1L);
    }
#line 730
    if (tmp___0 != 0L) {
      {
#line 731
      n = _copy_to_user(to, from, (unsigned int )n);
      }
    } else {
      {
#line 735
      __copy_to_user_overflow();
      }
    }
  }
#line 737
  return (n);
}
}
#line 86 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 809 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 812
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 813
    return ((char const   *)dev->init_name);
  } else {

  }
  {
#line 815
  tmp = kobject_name(& dev->kobj);
  }
#line 815
  return (tmp);
}
}
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 842
  return ((void *)dev->driver_data);
}
}
#line 845 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 847
  dev->driver_data = data;
#line 848
  return;
}
}
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
extern long schedule_timeout(long  ) ;
#line 189 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
__inline static void *usb_get_intfdata(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
  {
#line 191
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
  }
#line 191
  return (tmp);
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
__inline static void usb_set_intfdata(struct usb_interface *intf , void *data ) 
{ 


  {
  {
#line 196
  dev_set_drvdata(& intf->dev, data);
  }
#line 197
  return;
}
}
#line 590 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
__inline static struct usb_device *interface_to_usbdev(struct usb_interface *intf ) 
{ 
  struct device  const  *__mptr ;

  {
#line 592
  __mptr = (struct device  const  *)intf->dev.parent;
#line 592
  return ((struct usb_device *)__mptr + 0xffffffffffffff70UL);
}
}
#line 746
extern struct usb_interface *usb_ifnum_to_if(struct usb_device  const  * , unsigned int  ) ;
#line 786 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
__inline static int usb_make_path(struct usb_device *dev , char *buf , size_t size ) 
{ 
  int actual ;

  {
  {
#line 789
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, (char *)(& dev->devpath));
  }
#line 791
  return (actual < (int )size ? actual : -1);
}
}
#line 1547 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
__inline static void usb_fill_int_urb(struct urb *urb , struct usb_device *dev , unsigned int pipe ,
                                      void *transfer_buffer , int buffer_length ,
                                      void (*complete_fn)(struct urb * ) , void *context ,
                                      int interval ) 
{ 
  int _min1 ;
  int _max1 ;
  int _max2 ;
  int _min2 ;

  {
#line 1556
  urb->dev = dev;
#line 1557
  urb->pipe = pipe;
#line 1558
  urb->transfer_buffer = transfer_buffer;
#line 1559
  urb->transfer_buffer_length = (u32 )buffer_length;
#line 1560
  urb->complete = complete_fn;
#line 1561
  urb->context = context;
#line 1563
  if ((unsigned int )dev->speed == 3U || (unsigned int )dev->speed == 5U) {
#line 1565
    _max1 = interval;
#line 1565
    _max2 = 1;
#line 1565
    _min1 = _max1 > _max2 ? _max1 : _max2;
#line 1565
    _min2 = 16;
#line 1565
    interval = _min1 < _min2 ? _min1 : _min2;
#line 1567
    urb->interval = 1 << (interval + -1);
  } else {
#line 1569
    urb->interval = interval;
  }
#line 1572
  urb->start_frame = -1;
#line 1573
  return;
}
}
#line 1579
static struct urb *ldv_usb_alloc_urb_98(int ldv_func_arg1 , gfp_t flags ) ;
#line 1583
static struct urb *ldv_usb_alloc_urb_110(int ldv_func_arg1 , gfp_t flags ) ;
#line 1588
static void ldv_usb_free_urb_102(struct urb *urb ) ;
#line 1592
static void ldv_usb_free_urb_104(struct urb *urb ) ;
#line 1596
static void ldv_usb_free_urb_109(struct urb *urb ) ;
#line 1603
static int ldv_usb_submit_urb_97(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1607
static int ldv_usb_submit_urb_100(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1611
static int ldv_usb_submit_urb_105(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1615
static int ldv_usb_submit_urb_106(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1619
static int ldv_usb_submit_urb_112(struct urb *ldv_func_arg1 , gfp_t flags ) ;
#line 1622
extern void usb_kill_urb(struct urb * ) ;
#line 1630
static void *ldv_usb_alloc_coherent_99(struct usb_device *ldv_func_arg1 , size_t ldv_func_arg2 ,
                                       gfp_t flags , dma_addr_t *ldv_func_arg4 ) ;
#line 1634
static void *ldv_usb_alloc_coherent_111(struct usb_device *ldv_func_arg1 , size_t ldv_func_arg2 ,
                                        gfp_t flags , dma_addr_t *ldv_func_arg4 ) ;
#line 1640
static void ldv_usb_free_coherent_101(struct usb_device *dev , size_t size , void *addr ,
                                      dma_addr_t dma ) ;
#line 1644
static void ldv_usb_free_coherent_103(struct usb_device *dev , size_t size , void *addr ,
                                      dma_addr_t dma ) ;
#line 1648
static void ldv_usb_free_coherent_108(struct usb_device *dev , size_t size , void *addr ,
                                      dma_addr_t dma ) ;
#line 1689
extern int usb_clear_halt(struct usb_device * , int  ) ;
#line 1691
extern int usb_set_interface(struct usb_device * , int  , int  ) ;
#line 1779 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb.h"
__inline static unsigned int __create_pipe(struct usb_device *dev , unsigned int endpoint ) 
{ 


  {
#line 1782
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 418
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
extern struct page *vmalloc_to_page(void const   * ) ;
#line 2086
extern int vm_insert_page(struct vm_area_struct * , unsigned long  , struct page * ) ;
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/poll.h"
__inline static void poll_wait(struct file *filp , wait_queue_head_t *wait_address ,
                               poll_table *p ) 
{ 


  {
#line 44
  if ((unsigned long )p != (unsigned long )((poll_table *)0) && ((unsigned long )p->_qproc != (unsigned long )((void (*)(struct file * ,
                                                                                                                         wait_queue_head_t * ,
                                                                                                                         struct poll_table_struct * ))0) && (unsigned long )wait_address != (unsigned long )((wait_queue_head_t *)0))) {
    {
#line 45
    (*(p->_qproc))(filp, wait_address, p);
    }
  } else {

  }
#line 46
  return;
}
}
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/poll.h"
__inline static unsigned long poll_requested_events(poll_table const   *p ) 
{ 


  {
#line 66
  return ((unsigned long )p != (unsigned long )((poll_table const   *)0) ? (unsigned long )p->_key : 0xffffffffffffffffUL);
}
}
#line 339 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ioctl.h"
extern long video_ioctl2(struct file * , unsigned int  , unsigned long  ) ;
#line 370 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
extern void v4l2_ctrl_handler_free(struct v4l2_ctrl_handler * ) ;
#line 398
extern int v4l2_ctrl_handler_setup(struct v4l2_ctrl_handler * ) ;
#line 802
extern int v4l2_ctrl_subscribe_event(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 806
extern unsigned int v4l2_ctrl_poll(struct file * , struct poll_table_struct * ) ;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-fh.h"
extern int v4l2_fh_open(struct file * ) ;
#line 92
extern int v4l2_fh_release(struct file * ) ;
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-event.h"
extern int v4l2_event_unsubscribe(struct v4l2_fh * , struct v4l2_event_subscription  const  * ) ;
#line 461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
static bool ldv_try_module_get_115(struct module *ldv_func_arg1 ) ;
#line 467
static void ldv_module_put_116(struct module *ldv_func_arg1 ) ;
#line 471
static void ldv_module_put_120(struct module *ldv_func_arg1 ) ;
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
extern int __video_register_device(struct video_device * , int  , int  , int  , struct module * ) ;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
__inline static int video_register_device(struct video_device *vdev , int type , int nr ) 
{ 
  int tmp ;

  {
  {
#line 160
  tmp = __video_register_device(vdev, type, nr, 1, (vdev->fops)->owner);
  }
#line 160
  return (tmp);
}
}
#line 173
extern void video_unregister_device(struct video_device * ) ;
#line 185
extern void video_device_release_empty(struct video_device * ) ;
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
__inline static void v4l2_disable_ioctl_locking(struct video_device *vdev , unsigned int cmd ) 
{ 


  {
#line 193
  if ((cmd & 255U) <= 191U) {
    {
#line 194
    set_bit((long )cmd & 255L, (unsigned long volatile   *)(& vdev->disable_locking));
    }
  } else {

  }
#line 195
  return;
}
}
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
__inline static void v4l2_disable_ioctl(struct video_device *vdev , unsigned int cmd ) 
{ 


  {
#line 203
  if ((cmd & 255U) <= 191U) {
    {
#line 204
    set_bit((long )cmd & 255L, (unsigned long volatile   *)(& vdev->valid_ioctls));
    }
  } else {

  }
#line 205
  return;
}
}
#line 208 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
__inline static void *video_get_drvdata(struct video_device *vdev ) 
{ 
  void *tmp ;

  {
  {
#line 210
  tmp = dev_get_drvdata((struct device  const  *)(& vdev->dev));
  }
#line 210
  return (tmp);
}
}
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
__inline static void video_set_drvdata(struct video_device *vdev , void *data ) 
{ 


  {
  {
#line 215
  dev_set_drvdata(& vdev->dev, data);
  }
#line 216
  return;
}
}
#line 218
extern struct video_device *video_devdata(struct file * ) ;
#line 222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
__inline static void *video_drvdata(struct file *file ) 
{ 
  struct video_device *tmp ;
  void *tmp___0 ;

  {
  {
#line 224
  tmp = video_devdata(file);
#line 224
  tmp___0 = video_get_drvdata(tmp);
  }
#line 224
  return (tmp___0);
}
}
#line 227 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-dev.h"
__inline static char const   *video_device_node_name(struct video_device *vdev ) 
{ 
  char const   *tmp ;

  {
  {
#line 229
  tmp = dev_name((struct device  const  *)(& vdev->dev));
  }
#line 229
  return (tmp);
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-device.h"
extern int v4l2_device_put(struct v4l2_device * ) ;
#line 79
extern int v4l2_device_register(struct device * , struct v4l2_device * ) ;
#line 103
extern void v4l2_device_disconnect(struct v4l2_device * ) ;
#line 106
extern void v4l2_device_unregister(struct v4l2_device * ) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.h"
int gspca_debug  ;
#line 216
int gspca_dev_probe(struct usb_interface *intf , struct usb_device_id  const  *id ,
                    struct sd_desc  const  *sd_desc , int dev_size , struct module *module ) ;
#line 221
int gspca_dev_probe2(struct usb_interface *intf , struct usb_device_id  const  *id ,
                     struct sd_desc  const  *sd_desc , int dev_size , struct module *module ) ;
#line 226
void gspca_disconnect(struct usb_interface *intf ) ;
#line 227
void gspca_frame_add(struct gspca_dev *gspca_dev , enum gspca_packet_type packet_type ,
                     u8 const   *data , int len ) ;
#line 232
int gspca_suspend(struct usb_interface *intf , pm_message_t message ) ;
#line 233
int gspca_resume(struct usb_interface *intf ) ;
#line 333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/input.h"
extern struct input_dev *input_allocate_device(void) ;
#line 335
extern void input_free_device(struct input_dev * ) ;
#line 358
extern int input_register_device(struct input_dev * ) ;
#line 359
extern void input_unregister_device(struct input_dev * ) ;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/usb/input.h"
__inline static void usb_to_input_id(struct usb_device  const  *dev , struct input_id *id ) 
{ 


  {
#line 19
  id->bustype = 3U;
#line 20
  id->vendor = dev->descriptor.idVendor;
#line 21
  id->product = dev->descriptor.idProduct;
#line 22
  id->version = dev->descriptor.bcdDevice;
#line 23
  return;
}
}
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static char const   __kstrtab_gspca_debug[12U]  = 
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
  {      'g',      's',      'p',      'c', 
        'a',      '_',      'd',      'e', 
        'b',      'u',      'g',      '\000'};
#line 64
struct kernel_symbol  const  __ksymtab_gspca_debug ;
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct kernel_symbol  const  __ksymtab_gspca_debug  =    {(unsigned long )(& gspca_debug), (char const   *)(& __kstrtab_gspca_debug)};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void PDEBUG_MODE(struct gspca_dev *gspca_dev , int debug , char *txt , __u32 pixfmt ,
                        int w , int h ) 
{ 


  {
#line 69
  if ((pixfmt >> 24) - 48U <= 74U) {
#line 70
    if (gspca_debug >= debug) {
      {
#line 70
      printk("\017%s: %s %c%c%c%c %dx%d", (char *)(& gspca_dev->v4l2_dev.name), txt,
             pixfmt & 255U, (pixfmt >> 8) & 255U, (pixfmt >> 16) & 255U, pixfmt >> 24,
             w, h);
      }
    } else {

    }
  } else
#line 78
  if (gspca_debug >= debug) {
    {
#line 78
    printk("\017%s: %s 0x%08x %dx%d", (char *)(& gspca_dev->v4l2_dev.name), txt, pixfmt,
           w, h);
    }
  } else {

  }
#line 79
  return;
}
}
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void gspca_vm_open(struct vm_area_struct *vma ) 
{ 
  struct gspca_frame *frame ;

  {
#line 96
  frame = (struct gspca_frame *)vma->vm_private_data;
#line 98
  frame->vma_use_count = frame->vma_use_count + 1;
#line 99
  frame->v4l2_buf.flags = frame->v4l2_buf.flags | 1U;
#line 100
  return;
}
}
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void gspca_vm_close(struct vm_area_struct *vma ) 
{ 
  struct gspca_frame *frame ;

  {
#line 104
  frame = (struct gspca_frame *)vma->vm_private_data;
#line 106
  frame->vma_use_count = frame->vma_use_count - 1;
#line 106
  if (frame->vma_use_count <= 0) {
#line 107
    frame->v4l2_buf.flags = frame->v4l2_buf.flags & 4294967294U;
  } else {

  }
#line 108
  return;
}
}
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static struct vm_operations_struct  const  gspca_vm_ops  = 
#line 110
     {& gspca_vm_open, & gspca_vm_close, 0, 0, 0, 0, 0, 0, 0, 0};
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void int_irq(struct urb *urb ) 
{ 
  struct gspca_dev *gspca_dev ;
  int ret ;
  int tmp ;

  {
#line 121
  gspca_dev = (struct gspca_dev *)urb->context;
#line 124
  ret = urb->status;
  {
#line 126
  if (ret == 0) {
#line 126
    goto case_0;
  } else {

  }
#line 133
  if (ret == -2) {
#line 133
    goto case_neg_2;
  } else {

  }
#line 134
  if (ret == -104) {
#line 134
    goto case_neg_104;
  } else {

  }
#line 135
  if (ret == -19) {
#line 135
    goto case_neg_19;
  } else {

  }
#line 136
  if (ret == -108) {
#line 136
    goto case_neg_108;
  } else {

  }
#line 142
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 127
  tmp = (*((gspca_dev->sd_desc)->int_pkt_scan))(gspca_dev, (u8 *)urb->transfer_buffer,
                                                (int )urb->actual_length);
  }
#line 127
  if (tmp < 0) {
    {
#line 129
    printk("\v%s: Unknown packet received", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
#line 131
  goto ldv_36456;
  case_neg_2: /* CIL Label */ ;
  case_neg_104: /* CIL Label */ ;
  case_neg_19: /* CIL Label */ ;
  case_neg_108: /* CIL Label */ ;
#line 140
  goto ldv_36456;
  switch_default: /* CIL Label */ 
  {
#line 143
  printk("\v%s: URB error %i, resubmitting", (char *)(& gspca_dev->v4l2_dev.name),
         urb->status);
#line 144
  urb->status = 0;
#line 145
  ret = 0;
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_36456: ;
#line 148
  if (ret == 0) {
    {
#line 149
    ret = ldv_usb_submit_urb_97(urb, 32U);
    }
#line 150
    if (ret < 0) {
      {
#line 151
      printk("\vgspca_main: Resubmit URB failed with error %i\n", ret);
      }
    } else {

    }
  } else {

  }
#line 153
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int gspca_input_connect(struct gspca_dev *dev ) 
{ 
  struct input_dev *input_dev ;
  int err ;

  {
#line 158
  err = 0;
#line 160
  dev->input_dev = (struct input_dev *)0;
#line 161
  if ((unsigned long )(dev->sd_desc)->int_pkt_scan != (unsigned long )((int (*)(struct gspca_dev * ,
                                                                                u8 * ,
                                                                                int  ))0) || (unsigned int )((unsigned char )(dev->sd_desc)->other_input) != 0U) {
    {
#line 162
    input_dev = input_allocate_device();
    }
#line 163
    if ((unsigned long )input_dev == (unsigned long )((struct input_dev *)0)) {
#line 164
      return (-12);
    } else {

    }
    {
#line 166
    usb_make_path(dev->dev, (char *)(& dev->phys), 64UL);
#line 167
    strlcat((char *)(& dev->phys), "/input0", 64UL);
#line 169
    input_dev->name = (dev->sd_desc)->name;
#line 170
    input_dev->phys = (char const   *)(& dev->phys);
#line 172
    usb_to_input_id((struct usb_device  const  *)dev->dev, & input_dev->id);
#line 174
    input_dev->evbit[0] = 2UL;
#line 175
    input_dev->keybit[3] = 1048576UL;
#line 176
    input_dev->dev.parent = & (dev->dev)->dev;
#line 178
    err = input_register_device(input_dev);
    }
#line 179
    if (err != 0) {
      {
#line 180
      printk("\vgspca_main: Input device registration failed with error %i\n", err);
#line 182
      input_dev->dev.parent = (struct device *)0;
#line 183
      input_free_device(input_dev);
      }
    } else {
#line 185
      dev->input_dev = input_dev;
    }
  } else {

  }
#line 189
  return (err);
}
}
#line 192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int alloc_and_submit_int_urb(struct gspca_dev *gspca_dev , struct usb_endpoint_descriptor *ep ) 
{ 
  unsigned int buffer_len ;
  int interval ;
  struct urb *urb ;
  struct usb_device *dev ;
  void *buffer ;
  int ret ;
  unsigned int tmp ;

  {
#line 199
  buffer = (void *)0;
#line 200
  ret = -22;
#line 202
  buffer_len = (unsigned int )ep->wMaxPacketSize;
#line 203
  interval = (int )ep->bInterval;
#line 204
  if (gspca_debug > 1) {
    {
#line 204
    printk("\017%s: found int in endpoint: 0x%x, buffer_len=%u, interval=%u", (char *)(& gspca_dev->v4l2_dev.name),
           (int )ep->bEndpointAddress, buffer_len, interval);
    }
  } else {

  }
  {
#line 208
  dev = gspca_dev->dev;
#line 210
  urb = ldv_usb_alloc_urb_98(0, 208U);
  }
#line 211
  if ((unsigned long )urb == (unsigned long )((struct urb *)0)) {
#line 212
    ret = -12;
#line 213
    goto error;
  } else {

  }
  {
#line 216
  buffer = ldv_usb_alloc_coherent_99(dev, (size_t )buffer_len, 208U, & urb->transfer_dma);
  }
#line 218
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 219
    ret = -12;
#line 220
    goto error_buffer;
  } else {

  }
  {
#line 222
  tmp = __create_pipe(dev, (unsigned int )ep->bEndpointAddress);
#line 222
  usb_fill_int_urb(urb, dev, tmp | 1073741952U, buffer, (int )buffer_len, & int_irq,
                   (void *)gspca_dev, interval);
#line 226
  urb->transfer_flags = urb->transfer_flags | 4U;
#line 227
  ret = ldv_usb_submit_urb_100(urb, 208U);
  }
#line 228
  if (ret < 0) {
    {
#line 229
    printk("\v%s: submit int URB failed with error %i", (char *)(& gspca_dev->v4l2_dev.name),
           ret);
    }
#line 230
    goto error_submit;
  } else {

  }
#line 232
  gspca_dev->int_urb = urb;
#line 233
  return (ret);
  error_submit: 
  {
#line 236
  ldv_usb_free_coherent_101(dev, (size_t )urb->transfer_buffer_length, urb->transfer_buffer,
                            urb->transfer_dma);
  }
  error_buffer: 
  {
#line 241
  ldv_usb_free_urb_102(urb);
  }
  error: ;
#line 243
  return (ret);
}
}
#line 246 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void gspca_input_create_urb(struct gspca_dev *gspca_dev ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *intf_desc ;
  struct usb_endpoint_descriptor *ep ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 253
  if ((unsigned long )(gspca_dev->sd_desc)->int_pkt_scan != (unsigned long )((int (*)(struct gspca_dev * ,
                                                                                      u8 * ,
                                                                                      int  ))0)) {
    {
#line 254
    intf = usb_ifnum_to_if((struct usb_device  const  *)gspca_dev->dev, (unsigned int )gspca_dev->iface);
#line 255
    intf_desc = intf->cur_altsetting;
#line 256
    i = 0;
    }
#line 256
    goto ldv_36489;
    ldv_36488: 
    {
#line 257
    ep = & (intf_desc->endpoint + (unsigned long )i)->desc;
#line 258
    tmp = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)ep);
    }
#line 258
    if (tmp != 0) {
      {
#line 258
      tmp___0 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
      }
#line 258
      if (tmp___0 != 0) {
        {
#line 261
        alloc_and_submit_int_urb(gspca_dev, ep);
        }
#line 262
        goto ldv_36487;
      } else {

      }
    } else {

    }
#line 256
    i = i + 1;
    ldv_36489: ;
#line 256
    if (i < (int )intf_desc->desc.bNumEndpoints) {
#line 258
      goto ldv_36488;
    } else {

    }
    ldv_36487: ;
  } else {

  }
#line 264
  return;
}
}
#line 268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void gspca_input_destroy_urb(struct gspca_dev *gspca_dev ) 
{ 
  struct urb *urb ;

  {
#line 272
  urb = gspca_dev->int_urb;
#line 273
  if ((unsigned long )urb != (unsigned long )((struct urb *)0)) {
    {
#line 274
    gspca_dev->int_urb = (struct urb *)0;
#line 275
    usb_kill_urb(urb);
#line 276
    ldv_usb_free_coherent_103(gspca_dev->dev, (size_t )urb->transfer_buffer_length,
                              urb->transfer_buffer, urb->transfer_dma);
#line 280
    ldv_usb_free_urb_104(urb);
    }
  } else {

  }
#line 282
  return;
}
}
#line 301 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void fill_frame(struct gspca_dev *gspca_dev , struct urb *urb ) 
{ 
  u8 *data ;
  int i ;
  int len ;
  int st ;
  void (*pkt_scan)(struct gspca_dev * , u8 * , int  ) ;

  {
#line 308
  if (urb->status != 0) {
#line 309
    if (urb->status == -108) {
#line 310
      return;
    } else {

    }
#line 312
    if ((int )((signed char )gspca_dev->frozen) != 0) {
#line 313
      return;
    } else {

    }
    {
#line 315
    printk("\v%s: urb status: %d", (char *)(& gspca_dev->v4l2_dev.name), urb->status);
#line 316
    urb->status = 0;
    }
#line 317
    goto resubmit;
  } else {

  }
#line 319
  pkt_scan = (gspca_dev->sd_desc)->pkt_scan;
#line 320
  i = 0;
#line 320
  goto ldv_36506;
  ldv_36505: 
#line 321
  len = (int )urb->iso_frame_desc[i].actual_length;
#line 324
  st = urb->iso_frame_desc[i].status;
#line 325
  if (st != 0) {
    {
#line 326
    printk("\vgspca_main: ISOC data error: [%d] len=%d, status=%d\n", i, len, st);
#line 328
    gspca_dev->last_packet_type = 0U;
    }
#line 329
    goto ldv_36504;
  } else {

  }
#line 331
  if (len == 0) {
#line 332
    if ((int )gspca_dev->empty_packet == 0) {
#line 333
      gspca_dev->empty_packet = 1;
    } else {

    }
#line 334
    goto ldv_36504;
  } else {

  }
#line 338
  if (gspca_debug > 4) {
    {
#line 338
    printk("\017%s: packet [%d] o:%d l:%d", (char *)(& gspca_dev->v4l2_dev.name),
           i, urb->iso_frame_desc[i].offset, len);
    }
  } else {

  }
  {
#line 340
  data = (u8 *)urb->transfer_buffer + (unsigned long )urb->iso_frame_desc[i].offset;
#line 342
  (*pkt_scan)(gspca_dev, data, len);
  }
  ldv_36504: 
#line 320
  i = i + 1;
  ldv_36506: ;
#line 320
  if (i < urb->number_of_packets) {
#line 322
    goto ldv_36505;
  } else {

  }

  resubmit: 
  {
#line 347
  st = ldv_usb_submit_urb_105(urb, 32U);
  }
#line 348
  if (st < 0) {
    {
#line 349
    printk("\vgspca_main: usb_submit_urb() ret %d\n", st);
    }
  } else {

  }
#line 350
  return;
}
}
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void isoc_irq(struct urb *urb ) 
{ 
  struct gspca_dev *gspca_dev ;

  {
#line 359
  gspca_dev = (struct gspca_dev *)urb->context;
#line 361
  if (gspca_debug > 4) {
    {
#line 361
    printk("\017%s: isoc irq", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
#line 362
  if ((unsigned int )gspca_dev->streaming == 0U) {
#line 363
    return;
  } else {

  }
  {
#line 364
  fill_frame(gspca_dev, urb);
  }
#line 365
  return;
}
}
#line 370 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void bulk_irq(struct urb *urb ) 
{ 
  struct gspca_dev *gspca_dev ;
  int st ;

  {
#line 372
  gspca_dev = (struct gspca_dev *)urb->context;
#line 375
  if (gspca_debug > 4) {
    {
#line 375
    printk("\017%s: bulk irq", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
#line 376
  if ((unsigned int )gspca_dev->streaming == 0U) {
#line 377
    return;
  } else {

  }
  {
#line 379
  if (urb->status == 0) {
#line 379
    goto case_0;
  } else {

  }
#line 381
  if (urb->status == -108) {
#line 381
    goto case_neg_108;
  } else {

  }
#line 383
  goto switch_default;
  case_0: /* CIL Label */ ;
#line 380
  goto ldv_36518;
  case_neg_108: /* CIL Label */ ;
#line 382
  return;
  switch_default: /* CIL Label */ ;
#line 385
  if ((int )((signed char )gspca_dev->frozen) != 0) {
#line 386
    return;
  } else {

  }
  {
#line 388
  printk("\v%s: urb status: %d", (char *)(& gspca_dev->v4l2_dev.name), urb->status);
#line 389
  urb->status = 0;
  }
#line 390
  goto resubmit;
  switch_break: /* CIL Label */ ;
  }
  ldv_36518: ;
#line 393
  if (gspca_debug > 4) {
    {
#line 393
    printk("\017%s: packet l:%d", (char *)(& gspca_dev->v4l2_dev.name), urb->actual_length);
    }
  } else {

  }
  {
#line 394
  (*((gspca_dev->sd_desc)->pkt_scan))(gspca_dev, (u8 *)urb->transfer_buffer, (int )urb->actual_length);
  }
  resubmit: ;
#line 400
  if ((unsigned int )gspca_dev->cam.bulk_nurbs != 0U) {
    {
#line 401
    st = ldv_usb_submit_urb_106(urb, 32U);
    }
#line 402
    if (st < 0) {
      {
#line 403
      printk("\vgspca_main: usb_submit_urb() ret %d\n", st);
      }
    } else {

    }
  } else {

  }
#line 405
  return;
}
}
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
void gspca_frame_add(struct gspca_dev *gspca_dev , enum gspca_packet_type packet_type ,
                     u8 const   *data , int len ) 
{ 
  struct gspca_frame *frame ;
  int i ;
  int j ;
  int tmp ;
  ktime_t tmp___0 ;
  __u32 tmp___1 ;

  {
#line 426
  if (gspca_debug > 4) {
    {
#line 426
    printk("\017%s: add t:%d l:%d", (char *)(& gspca_dev->v4l2_dev.name), (unsigned int )packet_type,
           len);
    }
  } else {

  }
#line 428
  if ((unsigned int )packet_type == 1U) {
    {
#line 429
    i = atomic_read((atomic_t const   *)(& gspca_dev->fr_i));
#line 432
    tmp = atomic_read((atomic_t const   *)(& gspca_dev->fr_q));
    }
#line 432
    if (i == tmp) {
#line 433
      gspca_dev->last_packet_type = 0U;
#line 434
      gspca_dev->sequence = gspca_dev->sequence + 1U;
#line 435
      return;
    } else {

    }
    {
#line 437
    j = (int )gspca_dev->fr_queue[i];
#line 438
    frame = (struct gspca_frame *)(& gspca_dev->frame) + (unsigned long )j;
#line 439
    tmp___0 = ktime_get();
#line 439
    frame->v4l2_buf.timestamp = ns_to_timeval(tmp___0.tv64);
#line 440
    tmp___1 = gspca_dev->sequence;
#line 440
    gspca_dev->sequence = gspca_dev->sequence + 1U;
#line 440
    frame->v4l2_buf.sequence = tmp___1;
#line 441
    gspca_dev->image = frame->data;
#line 442
    gspca_dev->image_len = 0U;
    }
  } else {
    {
#line 445
    if ((int )gspca_dev->last_packet_type == 0) {
#line 445
      goto case_0;
    } else {

    }
#line 452
    if ((int )gspca_dev->last_packet_type == 3) {
#line 452
      goto case_3;
    } else {

    }
#line 444
    goto switch_break;
    case_0: /* CIL Label */ ;
#line 446
    if ((unsigned int )packet_type == 3U) {
#line 447
      gspca_dev->last_packet_type = (__u8 )packet_type;
#line 448
      gspca_dev->image = (u8 *)0U;
#line 449
      gspca_dev->image_len = 0U;
    } else {

    }
#line 451
    return;
    case_3: /* CIL Label */ ;
#line 453
    return;
    switch_break: /* CIL Label */ ;
    }
  }
#line 458
  if (len > 0) {
#line 459
    if (gspca_dev->image_len + (u32 )len > gspca_dev->frsz) {
      {
#line 460
      printk("\v%s: frame overflow %d > %d", (char *)(& gspca_dev->v4l2_dev.name),
             gspca_dev->image_len + (u32 )len, gspca_dev->frsz);
#line 463
      packet_type = 0;
      }
    } else {
      {
#line 471
      __memcpy((void *)gspca_dev->image + (unsigned long )gspca_dev->image_len, (void const   *)data,
               (size_t )len);
#line 473
      gspca_dev->image_len = gspca_dev->image_len + (u32 )len;
      }
    }
  } else {

  }
#line 476
  gspca_dev->last_packet_type = (__u8 )packet_type;
#line 481
  if ((unsigned int )packet_type == 3U) {
    {
#line 482
    i = atomic_read((atomic_t const   *)(& gspca_dev->fr_i));
#line 483
    j = (int )gspca_dev->fr_queue[i];
#line 484
    frame = (struct gspca_frame *)(& gspca_dev->frame) + (unsigned long )j;
#line 485
    frame->v4l2_buf.bytesused = gspca_dev->image_len;
#line 486
    frame->v4l2_buf.flags = (frame->v4l2_buf.flags & 4294967289U) | 4U;
#line 489
    i = (i + 1) % 16;
#line 490
    atomic_set(& gspca_dev->fr_i, i);
#line 491
    __wake_up(& gspca_dev->wq, 1U, 1, (void *)0);
    }
#line 492
    if (gspca_debug > 3) {
      {
#line 492
      printk("\017%s: frame complete len:%d", (char *)(& gspca_dev->v4l2_dev.name),
             frame->v4l2_buf.bytesused);
      }
    } else {

    }
#line 494
    gspca_dev->image = (u8 *)0U;
#line 495
    gspca_dev->image_len = 0U;
  } else {

  }
#line 497
  return;
}
}
#line 498 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static char const   __kstrtab_gspca_frame_add[16U]  = 
#line 498
  {      'g',      's',      'p',      'c', 
        'a',      '_',      'f',      'r', 
        'a',      'm',      'e',      '_', 
        'a',      'd',      'd',      '\000'};
#line 498
struct kernel_symbol  const  __ksymtab_gspca_frame_add ;
#line 498 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct kernel_symbol  const  __ksymtab_gspca_frame_add  =    {(unsigned long )(& gspca_frame_add), (char const   *)(& __kstrtab_gspca_frame_add)};
#line 500 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int frame_alloc(struct gspca_dev *gspca_dev , struct file *file , enum v4l2_memory memory ,
                       unsigned int count ) 
{ 
  struct gspca_frame *frame ;
  unsigned int frsz ;
  int i ;
  void *tmp ;

  {
#line 507
  frsz = gspca_dev->pixfmt.sizeimage;
#line 508
  if (gspca_debug > 2) {
    {
#line 508
    printk("\017%s: frame alloc frsz: %d", (char *)(& gspca_dev->v4l2_dev.name), frsz);
    }
  } else {

  }
#line 509
  frsz = (frsz + 4095U) & 4294963200U;
#line 510
  if (count > 15U) {
#line 511
    count = 15U;
  } else {

  }
  {
#line 512
  tmp = ldv_vmalloc_32_107((unsigned long )(frsz * count));
#line 512
  gspca_dev->frbuf = (__u8 *)tmp;
  }
#line 513
  if ((unsigned long )gspca_dev->frbuf == (unsigned long )((__u8 *)0U)) {
    {
#line 514
    printk("\vgspca_main: frame alloc failed\n");
    }
#line 515
    return (-12);
  } else {

  }
#line 517
  gspca_dev->capt_file = file;
#line 518
  gspca_dev->memory = (char )memory;
#line 519
  gspca_dev->frsz = frsz;
#line 520
  gspca_dev->nframes = (char )count;
#line 521
  i = 0;
#line 521
  goto ldv_36553;
  ldv_36552: 
#line 522
  frame = (struct gspca_frame *)(& gspca_dev->frame) + (unsigned long )i;
#line 523
  frame->v4l2_buf.index = (__u32 )i;
#line 524
  frame->v4l2_buf.type = 1U;
#line 525
  frame->v4l2_buf.flags = 0U;
#line 526
  frame->v4l2_buf.field = 1U;
#line 527
  frame->v4l2_buf.length = frsz;
#line 528
  frame->v4l2_buf.memory = (__u32 )memory;
#line 529
  frame->v4l2_buf.sequence = 0U;
#line 530
  frame->data = gspca_dev->frbuf + (unsigned long )((unsigned int )i * frsz);
#line 531
  frame->v4l2_buf.m.offset = (unsigned int )i * frsz;
#line 521
  i = i + 1;
  ldv_36553: ;
#line 521
  if ((unsigned int )i < count) {
#line 523
    goto ldv_36552;
  } else {

  }
  {
#line 533
  atomic_set(& gspca_dev->fr_q, 0);
#line 534
  atomic_set(& gspca_dev->fr_i, 0);
#line 535
  gspca_dev->fr_o = 0U;
  }
#line 536
  return (0);
}
}
#line 539 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void frame_free(struct gspca_dev *gspca_dev ) 
{ 
  int i ;

  {
#line 543
  if (gspca_debug > 2) {
    {
#line 543
    printk("\017%s: frame free", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
#line 544
  if ((unsigned long )gspca_dev->frbuf != (unsigned long )((__u8 *)0U)) {
    {
#line 545
    vfree((void const   *)gspca_dev->frbuf);
#line 546
    gspca_dev->frbuf = (__u8 *)0U;
#line 547
    i = 0;
    }
#line 547
    goto ldv_36560;
    ldv_36559: 
#line 548
    gspca_dev->frame[i].data = (__u8 *)0U;
#line 547
    i = i + 1;
    ldv_36560: ;
#line 547
    if (i < (int )gspca_dev->nframes) {
#line 549
      goto ldv_36559;
    } else {

    }

  } else {

  }
#line 550
  gspca_dev->nframes = 0;
#line 551
  gspca_dev->frsz = 0U;
#line 552
  gspca_dev->capt_file = (struct file *)0;
#line 553
  gspca_dev->memory = 0;
#line 554
  return;
}
}
#line 556 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void destroy_urbs(struct gspca_dev *gspca_dev ) 
{ 
  struct urb *urb ;
  unsigned int i ;

  {
#line 561
  if (gspca_debug > 2) {
    {
#line 561
    printk("\017%s: kill transfer", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
#line 562
  i = 0U;
#line 562
  goto ldv_36569;
  ldv_36568: 
#line 563
  urb = gspca_dev->urb[i];
#line 564
  if ((unsigned long )urb == (unsigned long )((struct urb *)0)) {
#line 565
    goto ldv_36567;
  } else {

  }
  {
#line 567
  gspca_dev->urb[i] = (struct urb *)0;
#line 568
  usb_kill_urb(urb);
#line 569
  ldv_usb_free_coherent_108(gspca_dev->dev, (size_t )urb->transfer_buffer_length,
                            urb->transfer_buffer, urb->transfer_dma);
#line 573
  ldv_usb_free_urb_109(urb);
#line 562
  i = i + 1U;
  }
  ldv_36569: ;
#line 562
  if (i <= 3U) {
#line 564
    goto ldv_36568;
  } else {

  }
  ldv_36567: ;
#line 569
  return;
}
}
#line 577 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int gspca_set_alt0(struct gspca_dev *gspca_dev ) 
{ 
  int ret ;

  {
#line 581
  if ((unsigned int )gspca_dev->alt == 0U) {
#line 582
    return (0);
  } else {

  }
  {
#line 583
  ret = usb_set_interface(gspca_dev->dev, (int )gspca_dev->iface, 0);
  }
#line 584
  if (ret < 0) {
    {
#line 585
    printk("\vgspca_main: set alt 0 err %d\n", ret);
    }
  } else {

  }
#line 586
  return (ret);
}
}
#line 590 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void gspca_stream_off(struct gspca_dev *gspca_dev ) 
{ 


  {
#line 592
  gspca_dev->streaming = 0U;
#line 593
  gspca_dev->usb_err = 0;
#line 594
  if ((unsigned long )(gspca_dev->sd_desc)->stopN != (unsigned long )((void (*)(struct gspca_dev * ))0)) {
    {
#line 595
    (*((gspca_dev->sd_desc)->stopN))(gspca_dev);
    }
  } else {

  }
  {
#line 596
  destroy_urbs(gspca_dev);
#line 597
  gspca_input_destroy_urb(gspca_dev);
#line 598
  gspca_set_alt0(gspca_dev);
#line 599
  gspca_input_create_urb(gspca_dev);
  }
#line 600
  if ((unsigned long )(gspca_dev->sd_desc)->stop0 != (unsigned long )((void (*)(struct gspca_dev * ))0)) {
    {
#line 601
    (*((gspca_dev->sd_desc)->stop0))(gspca_dev);
    }
  } else {

  }
#line 602
  if (gspca_debug > 2) {
    {
#line 602
    printk("\017%s: stream off OK", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
#line 603
  return;
}
}
#line 611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static struct usb_host_endpoint *alt_xfer(struct usb_host_interface *alt , int xfer ,
                                          int xfer_ep ) 
{ 
  struct usb_host_endpoint *ep ;
  int i ;
  int attr ;
  int tmp ;

  {
#line 617
  i = 0;
#line 617
  goto ldv_36586;
  ldv_36585: 
#line 618
  ep = alt->endpoint + (unsigned long )i;
#line 619
  attr = (int )ep->desc.bmAttributes & 3;
#line 620
  if (attr == xfer && (unsigned int )ep->desc.wMaxPacketSize != 0U) {
    {
#line 620
    tmp = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)(& ep->desc));
    }
#line 620
    if (tmp != 0) {
#line 620
      if (xfer_ep < 0 || (int )ep->desc.bEndpointAddress == xfer_ep) {
#line 624
        return (ep);
      } else {

      }
    } else {

    }
  } else {

  }
#line 617
  i = i + 1;
  ldv_36586: ;
#line 617
  if (i < (int )alt->desc.bNumEndpoints) {
#line 619
    goto ldv_36585;
  } else {

  }

#line 626
  return ((struct usb_host_endpoint *)0);
}
}
#line 630 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static u32 which_bandwidth(struct gspca_dev *gspca_dev ) 
{ 
  u32 bandwidth ;
  struct v4l2_streamparm parm ;

  {
#line 635
  bandwidth = gspca_dev->pixfmt.sizeimage;
#line 638
  if ((unsigned int )gspca_dev->cam.needs_full_bandwidth == 0U && bandwidth < gspca_dev->pixfmt.width * gspca_dev->pixfmt.height) {
#line 641
    bandwidth = (bandwidth * 3U) / 8U;
  } else {

  }
#line 644
  if ((unsigned long )(gspca_dev->sd_desc)->get_streamparm != (unsigned long )((void (*)(struct gspca_dev * ,
                                                                                         struct v4l2_streamparm * ))0)) {
    {
#line 647
    (*((gspca_dev->sd_desc)->get_streamparm))(gspca_dev, & parm);
#line 648
    bandwidth = bandwidth * parm.parm.capture.timeperframe.denominator;
#line 649
    bandwidth = bandwidth / parm.parm.capture.timeperframe.numerator;
    }
  } else
#line 654
  if (gspca_dev->pixfmt.width > 639U && (unsigned int )(gspca_dev->dev)->speed == 2U) {
#line 656
    bandwidth = bandwidth * 15U;
  } else {
#line 658
    bandwidth = bandwidth * 30U;
  }
#line 661
  if (gspca_debug > 2) {
    {
#line 661
    printk("\017%s: min bandwidth: %d", (char *)(& gspca_dev->v4l2_dev.name), bandwidth);
    }
  } else {

  }
#line 662
  return (bandwidth);
}
}
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int build_isoc_ep_tb(struct gspca_dev *gspca_dev , struct usb_interface *intf ,
                            struct ep_tb_s *ep_tb ) 
{ 
  struct usb_host_endpoint *ep ;
  int i ;
  int j ;
  int nbalt ;
  int psize ;
  int found ;
  u32 bandwidth ;
  u32 last_bw ;

  {
#line 684
  nbalt = (int )intf->num_altsetting;
#line 685
  if (nbalt > 16) {
#line 686
    nbalt = 16;
  } else {

  }
#line 689
  i = 0;
#line 690
  last_bw = 0U;
  ldv_36614: 
#line 692
  ep_tb->bandwidth = 480000000U;
#line 693
  found = 0;
#line 694
  j = 0;
#line 694
  goto ldv_36611;
  ldv_36610: 
  {
#line 695
  ep = alt_xfer(intf->altsetting + (unsigned long )j, 1, gspca_dev->xfer_ep);
  }
#line 698
  if ((unsigned long )ep == (unsigned long )((struct usb_host_endpoint *)0)) {
#line 699
    goto ldv_36609;
  } else {

  }
#line 700
  if ((unsigned int )ep->desc.bInterval == 0U) {
    {
#line 701
    printk("\vgspca_main: alt %d iso endp with 0 interval\n", j);
    }
#line 702
    goto ldv_36609;
  } else {

  }
#line 704
  psize = (int )ep->desc.wMaxPacketSize;
#line 705
  psize = (psize & 2047) * (((psize >> 11) & 3) + 1);
#line 706
  bandwidth = (u32 )(psize * 1000);
#line 707
  if ((unsigned int )(gspca_dev->dev)->speed == 3U || (unsigned int )(gspca_dev->dev)->speed == 5U) {
#line 709
    bandwidth = bandwidth * 8U;
  } else {

  }
#line 710
  bandwidth = bandwidth >> ((int )ep->desc.bInterval + -1);
#line 711
  if (bandwidth <= last_bw) {
#line 712
    goto ldv_36609;
  } else {

  }
#line 713
  if (bandwidth < ep_tb->bandwidth) {
#line 714
    ep_tb->bandwidth = bandwidth;
#line 715
    ep_tb->alt = (u32 )j;
#line 716
    found = 1;
  } else {

  }
  ldv_36609: 
#line 694
  j = j + 1;
  ldv_36611: ;
#line 694
  if (j < nbalt) {
#line 696
    goto ldv_36610;
  } else {

  }

#line 719
  if (found == 0) {
#line 720
    goto ldv_36613;
  } else {

  }
#line 721
  if (gspca_debug > 2) {
    {
#line 721
    printk("\017%s: alt %d bandwidth %d", (char *)(& gspca_dev->v4l2_dev.name), ep_tb->alt,
           ep_tb->bandwidth);
    }
  } else {

  }
#line 723
  last_bw = ep_tb->bandwidth;
#line 724
  i = i + 1;
#line 725
  ep_tb = ep_tb + 1;
#line 726
  goto ldv_36614;
  ldv_36613: ;
#line 736
  if (((unsigned int )gspca_dev->audio != 0U && ((unsigned int )(gspca_dev->dev)->speed == 2U && last_bw > 999999U)) && i > 1) {
#line 740
    if (gspca_debug > 2) {
      {
#line 740
      printk("\017%s: dev has usb audio, skipping highest alt", (char *)(& gspca_dev->v4l2_dev.name));
      }
    } else {

    }
#line 741
    i = i - 1;
#line 742
    ep_tb = ep_tb - 1;
  } else {

  }
  {
#line 746
  bandwidth = which_bandwidth(gspca_dev);
#line 747
  ep_tb = ep_tb - 1;
  }
#line 748
  goto ldv_36617;
  ldv_36616: 
#line 749
  ep_tb = ep_tb - 1;
#line 750
  if (ep_tb->bandwidth < bandwidth) {
#line 751
    goto ldv_36615;
  } else {

  }
#line 752
  i = i - 1;
  ldv_36617: ;
#line 748
  if (i > 1) {
#line 750
    goto ldv_36616;
  } else {

  }
  ldv_36615: ;
#line 754
  return (i);
}
}
#line 760 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int create_urbs(struct gspca_dev *gspca_dev , struct usb_host_endpoint *ep ) 
{ 
  struct urb *urb ;
  int n ;
  int nurbs ;
  int i ;
  int psize ;
  int npkt ;
  int bsize ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 767
  psize = (int )ep->desc.wMaxPacketSize;
#line 769
  if ((unsigned int )gspca_dev->cam.bulk == 0U) {
#line 772
    if ((unsigned int )gspca_dev->pkt_size == 0U) {
#line 773
      psize = (psize & 2047) * (((psize >> 11) & 3) + 1);
    } else {
#line 775
      psize = (int )gspca_dev->pkt_size;
    }
#line 776
    npkt = (int )gspca_dev->cam.npkt;
#line 777
    if (npkt == 0) {
#line 778
      npkt = 32;
    } else {

    }
#line 779
    bsize = psize * npkt;
#line 780
    if (gspca_debug > 2) {
      {
#line 780
      printk("\017%s: isoc %d pkts size %d = bsize:%d", (char *)(& gspca_dev->v4l2_dev.name),
             npkt, psize, bsize);
      }
    } else {

    }
#line 783
    nurbs = 3;
  } else {
#line 785
    npkt = 0;
#line 786
    bsize = (int )gspca_dev->cam.bulk_size;
#line 787
    if (bsize == 0) {
#line 788
      bsize = psize;
    } else {

    }
#line 789
    if (gspca_debug > 2) {
      {
#line 789
      printk("\017%s: bulk bsize:%d", (char *)(& gspca_dev->v4l2_dev.name), bsize);
      }
    } else {

    }
#line 790
    if ((unsigned int )gspca_dev->cam.bulk_nurbs != 0U) {
#line 791
      nurbs = (int )gspca_dev->cam.bulk_nurbs;
    } else {
#line 793
      nurbs = 1;
    }
  }
#line 796
  n = 0;
#line 796
  goto ldv_36633;
  ldv_36632: 
  {
#line 797
  urb = ldv_usb_alloc_urb_110(npkt, 208U);
  }
#line 798
  if ((unsigned long )urb == (unsigned long )((struct urb *)0)) {
    {
#line 799
    printk("\vgspca_main: usb_alloc_urb failed\n");
    }
#line 800
    return (-12);
  } else {

  }
  {
#line 802
  gspca_dev->urb[n] = urb;
#line 803
  urb->transfer_buffer = ldv_usb_alloc_coherent_111(gspca_dev->dev, (size_t )bsize,
                                                    208U, & urb->transfer_dma);
  }
#line 808
  if ((unsigned long )urb->transfer_buffer == (unsigned long )((void *)0)) {
    {
#line 809
    printk("\vgspca_main: usb_alloc_coherent failed\n");
    }
#line 810
    return (-12);
  } else {

  }
#line 812
  urb->dev = gspca_dev->dev;
#line 813
  urb->context = (void *)gspca_dev;
#line 814
  urb->transfer_buffer_length = (u32 )bsize;
#line 815
  if (npkt != 0) {
    {
#line 816
    tmp = __create_pipe(gspca_dev->dev, (unsigned int )ep->desc.bEndpointAddress);
#line 816
    urb->pipe = tmp | 128U;
#line 818
    urb->transfer_flags = 6U;
#line 820
    urb->interval = 1 << ((int )ep->desc.bInterval + -1);
#line 821
    urb->complete = & isoc_irq;
#line 822
    urb->number_of_packets = npkt;
#line 823
    i = 0;
    }
#line 823
    goto ldv_36630;
    ldv_36629: 
#line 824
    urb->iso_frame_desc[i].length = (unsigned int )psize;
#line 825
    urb->iso_frame_desc[i].offset = (unsigned int )(psize * i);
#line 823
    i = i + 1;
    ldv_36630: ;
#line 823
    if (i < npkt) {
#line 825
      goto ldv_36629;
    } else {

    }

  } else {
    {
#line 828
    tmp___0 = __create_pipe(gspca_dev->dev, (unsigned int )ep->desc.bEndpointAddress);
#line 828
    urb->pipe = tmp___0 | 3221225600U;
#line 830
    urb->transfer_flags = 4U;
#line 831
    urb->complete = & bulk_irq;
    }
  }
#line 796
  n = n + 1;
  ldv_36633: ;
#line 796
  if (n < nurbs) {
#line 798
    goto ldv_36632;
  } else {

  }

#line 834
  return (0);
}
}
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int gspca_init_transfer(struct gspca_dev *gspca_dev ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_endpoint *ep ;
  struct urb *urb ;
  struct ep_tb_s ep_tb[16U] ;
  int n ;
  int ret ;
  int xfer ;
  int alt ;
  int alt_idx ;
  struct usb_host_endpoint *tmp ;

  {
  {
#line 849
  gspca_dev->image = (u8 *)0U;
#line 850
  gspca_dev->image_len = 0U;
#line 851
  gspca_dev->last_packet_type = 0U;
#line 852
  gspca_dev->sequence = 0U;
#line 854
  gspca_dev->usb_err = 0;
#line 857
  intf = usb_ifnum_to_if((struct usb_device  const  *)gspca_dev->dev, (unsigned int )gspca_dev->iface);
#line 858
  gspca_dev->alt = (unsigned int )gspca_dev->cam.bulk != 0U ? (__u8 )intf->num_altsetting : 0U;
  }
#line 859
  if ((unsigned long )(gspca_dev->sd_desc)->isoc_init != (unsigned long )((int (*)(struct gspca_dev * ))0)) {
    {
#line 860
    ret = (*((gspca_dev->sd_desc)->isoc_init))(gspca_dev);
    }
#line 861
    if (ret < 0) {
#line 862
      return (ret);
    } else {

    }
  } else {

  }
#line 864
  xfer = (unsigned int )gspca_dev->cam.bulk != 0U ? 2 : 1;
#line 868
  if ((unsigned int )gspca_dev->alt != 0U) {
    {
#line 869
    gspca_dev->alt = (__u8 )((int )gspca_dev->alt - 1);
#line 870
    ep = alt_xfer(intf->altsetting + (unsigned long )gspca_dev->alt, xfer, gspca_dev->xfer_ep);
    }
#line 872
    if ((unsigned long )ep == (unsigned long )((struct usb_host_endpoint *)0)) {
      {
#line 873
      printk("\vgspca_main: bad altsetting %d\n", (int )gspca_dev->alt);
      }
#line 874
      return (-5);
    } else {

    }
#line 876
    ep_tb[0].alt = (u32 )gspca_dev->alt;
#line 877
    alt_idx = 1;
  } else {
    {
#line 881
    alt_idx = build_isoc_ep_tb(gspca_dev, intf, (struct ep_tb_s *)(& ep_tb));
    }
#line 882
    if (alt_idx <= 0) {
      {
#line 883
      printk("\vgspca_main: no transfer endpoint found\n");
      }
#line 884
      return (-5);
    } else {

    }
  }
  {
#line 890
  gspca_input_destroy_urb(gspca_dev);
#line 892
  alt_idx = alt_idx - 1;
#line 892
  gspca_dev->alt = (__u8 )ep_tb[alt_idx].alt;
#line 893
  alt = -1;
  }
  ldv_36653: ;
#line 895
  if (alt != (int )gspca_dev->alt) {
#line 896
    alt = (int )gspca_dev->alt;
#line 897
    if (intf->num_altsetting > 1U) {
      {
#line 898
      ret = usb_set_interface(gspca_dev->dev, (int )gspca_dev->iface, alt);
      }
#line 901
      if (ret < 0) {
#line 902
        if (ret == -28) {
#line 903
          goto retry;
        } else {

        }
        {
#line 904
        printk("\vgspca_main: set alt %d err %d\n", alt, ret);
        }
#line 905
        goto out;
      } else {

      }
    } else {

    }
  } else {

  }
#line 909
  if ((unsigned int )gspca_dev->cam.no_urb_create == 0U) {
#line 910
    if (gspca_debug > 2) {
      {
#line 910
      printk("\017%s: init transfer alt %d", (char *)(& gspca_dev->v4l2_dev.name),
             alt);
      }
    } else {

    }
    {
#line 911
    tmp = alt_xfer(intf->altsetting + (unsigned long )alt, xfer, gspca_dev->xfer_ep);
#line 911
    ret = create_urbs(gspca_dev, tmp);
    }
#line 914
    if (ret < 0) {
      {
#line 915
      destroy_urbs(gspca_dev);
      }
#line 916
      goto out;
    } else {

    }
  } else {

  }
#line 921
  if ((unsigned int )gspca_dev->cam.bulk != 0U) {
    {
#line 922
    usb_clear_halt(gspca_dev->dev, (int )(gspca_dev->urb[0])->pipe);
    }
  } else {

  }
  {
#line 926
  ret = (*((gspca_dev->sd_desc)->start))(gspca_dev);
  }
#line 927
  if (ret < 0) {
    {
#line 928
    destroy_urbs(gspca_dev);
    }
#line 929
    goto out;
  } else {

  }
  {
#line 931
  gspca_dev->streaming = 1U;
#line 932
  v4l2_ctrl_handler_setup(gspca_dev->vdev.ctrl_handler);
  }
#line 935
  if ((unsigned int )gspca_dev->cam.bulk != 0U && (unsigned int )gspca_dev->cam.bulk_nurbs == 0U) {
#line 936
    goto ldv_36649;
  } else {

  }
#line 939
  n = 0;
#line 939
  goto ldv_36652;
  ldv_36651: 
#line 940
  urb = gspca_dev->urb[n];
#line 941
  if ((unsigned long )urb == (unsigned long )((struct urb *)0)) {
#line 942
    goto ldv_36650;
  } else {

  }
  {
#line 943
  ret = ldv_usb_submit_urb_112(urb, 208U);
  }
#line 944
  if (ret < 0) {
#line 945
    goto ldv_36650;
  } else {

  }
#line 939
  n = n + 1;
  ldv_36652: ;
#line 939
  if (n <= 3) {
#line 941
    goto ldv_36651;
  } else {

  }
  ldv_36650: ;
#line 947
  if (ret >= 0) {
#line 948
    goto ldv_36649;
  } else {

  }
  {
#line 952
  gspca_stream_off(gspca_dev);
  }
#line 953
  if (ret != -28) {
    {
#line 954
    printk("\vgspca_main: usb_submit_urb alt %d err %d\n", (int )gspca_dev->alt, ret);
    }
#line 956
    goto out;
  } else {

  }
  retry: 
  {
#line 962
  printk("\v%s: alt %d - bandwidth not wide enough, trying again", (char *)(& gspca_dev->v4l2_dev.name),
         alt);
#line 963
  msleep(20U);
  }
#line 964
  if ((unsigned long )(gspca_dev->sd_desc)->isoc_nego != (unsigned long )((int (*)(struct gspca_dev * ))0)) {
    {
#line 965
    ret = (*((gspca_dev->sd_desc)->isoc_nego))(gspca_dev);
    }
#line 966
    if (ret < 0) {
#line 967
      goto out;
    } else {

    }
  } else {
#line 969
    if (alt_idx <= 0) {
      {
#line 970
      printk("\vgspca_main: no transfer endpoint found\n");
#line 971
      ret = -5;
      }
#line 972
      goto out;
    } else {

    }
#line 974
    alt_idx = alt_idx - 1;
#line 974
    gspca_dev->alt = (__u8 )ep_tb[alt_idx].alt;
  }
#line 976
  goto ldv_36653;
  ldv_36649: ;
  out: 
  {
#line 978
  gspca_input_create_urb(gspca_dev);
  }
#line 979
  return (ret);
}
}
#line 982 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void gspca_set_default_mode(struct gspca_dev *gspca_dev ) 
{ 
  int i ;

  {
  {
#line 986
  i = (int )gspca_dev->cam.nmodes + -1;
#line 987
  gspca_dev->curr_mode = (__u8 )i;
#line 988
  gspca_dev->pixfmt = *(gspca_dev->cam.cam_mode + (unsigned long )i);
#line 991
  v4l2_ctrl_handler_setup(gspca_dev->vdev.ctrl_handler);
  }
#line 992
  return;
}
}
#line 994 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int wxh_to_mode(struct gspca_dev *gspca_dev , int width , int height ) 
{ 
  int i ;

  {
#line 999
  i = (int )gspca_dev->cam.nmodes;
#line 999
  goto ldv_36666;
  ldv_36665: ;
#line 1000
  if ((unsigned int )width >= (unsigned int )(gspca_dev->cam.cam_mode + (unsigned long )i)->width && (unsigned int )height >= (unsigned int )(gspca_dev->cam.cam_mode + (unsigned long )i)->height) {
#line 1002
    goto ldv_36664;
  } else {

  }
  ldv_36666: 
#line 999
  i = i - 1;
#line 999
  if (i > 0) {
#line 1001
    goto ldv_36665;
  } else {

  }
  ldv_36664: ;
#line 1004
  return (i);
}
}
#line 1010 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int gspca_get_mode(struct gspca_dev *gspca_dev , int mode , int pixfmt ) 
{ 
  int modeU ;
  int modeD ;

  {
#line 1016
  modeD = mode;
#line 1016
  modeU = modeD;
#line 1017
  goto ldv_36675;
  ldv_36674: 
#line 1018
  modeD = modeD - 1;
#line 1018
  if (modeD >= 0) {
#line 1019
    if ((unsigned int )(gspca_dev->cam.cam_mode + (unsigned long )modeD)->pixelformat == (unsigned int )pixfmt) {
#line 1021
      return (modeD);
    } else {

    }
  } else {

  }
#line 1023
  modeU = modeU + 1;
#line 1023
  if (modeU < (int )gspca_dev->cam.nmodes) {
#line 1024
    if ((unsigned int )(gspca_dev->cam.cam_mode + (unsigned long )modeU)->pixelformat == (unsigned int )pixfmt) {
#line 1026
      return (modeU);
    } else {

    }
  } else {

  }
  ldv_36675: ;
#line 1017
  if (modeU < (int )gspca_dev->cam.nmodes || modeD >= 0) {
#line 1019
    goto ldv_36674;
  } else {

  }

#line 1029
  return (-22);
}
}
#line 1033 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_g_chip_info(struct file *file , void *priv , struct v4l2_dbg_chip_info *chip ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1036
  tmp = video_drvdata(file);
#line 1036
  gspca_dev = (struct gspca_dev *)tmp;
#line 1038
  gspca_dev->usb_err = 0;
  }
#line 1039
  if ((unsigned long )(gspca_dev->sd_desc)->get_chip_info != (unsigned long )((int (*)(struct gspca_dev * ,
                                                                                       struct v4l2_dbg_chip_info * ))0)) {
    {
#line 1040
    tmp___0 = (*((gspca_dev->sd_desc)->get_chip_info))(gspca_dev, chip);
    }
#line 1040
    return (tmp___0);
  } else {

  }
#line 1041
  return (chip->match.__annonCompField82.addr != 0U ? -22 : 0);
}
}
#line 1044 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_g_register(struct file *file , void *priv , struct v4l2_dbg_register *reg ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1047
  tmp = video_drvdata(file);
#line 1047
  gspca_dev = (struct gspca_dev *)tmp;
#line 1049
  gspca_dev->usb_err = 0;
#line 1050
  tmp___0 = (*((gspca_dev->sd_desc)->get_register))(gspca_dev, reg);
  }
#line 1050
  return (tmp___0);
}
}
#line 1053 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_s_register(struct file *file , void *priv , struct v4l2_dbg_register  const  *reg ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1056
  tmp = video_drvdata(file);
#line 1056
  gspca_dev = (struct gspca_dev *)tmp;
#line 1058
  gspca_dev->usb_err = 0;
#line 1059
  tmp___0 = (*((gspca_dev->sd_desc)->set_register))(gspca_dev, reg);
  }
#line 1059
  return (tmp___0);
}
}
#line 1063 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_enum_fmt_vid_cap(struct file *file , void *priv , struct v4l2_fmtdesc *fmtdesc ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int i ;
  int j ;
  int index ;
  __u32 fmt_tb[8U] ;

  {
  {
#line 1066
  tmp = video_drvdata(file);
#line 1066
  gspca_dev = (struct gspca_dev *)tmp;
#line 1071
  index = 0;
#line 1072
  j = 0;
#line 1073
  i = (int )gspca_dev->cam.nmodes;
  }
#line 1073
  goto ldv_36711;
  ldv_36710: 
#line 1074
  fmt_tb[index] = (gspca_dev->cam.cam_mode + (unsigned long )i)->pixelformat;
#line 1075
  j = 0;
  ldv_36706: ;
#line 1077
  if (fmt_tb[j] == fmt_tb[index]) {
#line 1078
    goto ldv_36705;
  } else {

  }
#line 1079
  j = j + 1;
#line 1080
  goto ldv_36706;
  ldv_36705: ;
#line 1081
  if (j == index) {
#line 1082
    if (fmtdesc->index == (__u32 )index) {
#line 1083
      goto ldv_36707;
    } else {

    }
#line 1084
    index = index + 1;
#line 1085
    if ((unsigned int )index > 7U) {
#line 1086
      return (-22);
    } else {

    }
  } else {

  }
  ldv_36711: 
#line 1073
  i = i - 1;
#line 1073
  if (i >= 0) {
#line 1075
    goto ldv_36710;
  } else {

  }
  ldv_36707: ;
#line 1089
  if (i < 0) {
#line 1090
    return (-22);
  } else {

  }
#line 1092
  fmtdesc->pixelformat = fmt_tb[index];
#line 1093
  if ((unsigned int )(gspca_dev->cam.cam_mode + (unsigned long )i)->sizeimage < (unsigned int )(gspca_dev->cam.cam_mode + (unsigned long )i)->width * (unsigned int )(gspca_dev->cam.cam_mode + (unsigned long )i)->height) {
#line 1096
    fmtdesc->flags = 1U;
  } else {

  }
#line 1097
  fmtdesc->description[0] = (__u8 )fmtdesc->pixelformat;
#line 1098
  fmtdesc->description[1] = (__u8 )(fmtdesc->pixelformat >> 8);
#line 1099
  fmtdesc->description[2] = (__u8 )(fmtdesc->pixelformat >> 16);
#line 1100
  fmtdesc->description[3] = (__u8 )(fmtdesc->pixelformat >> 24);
#line 1101
  fmtdesc->description[4] = 0U;
#line 1102
  return (0);
}
}
#line 1105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_g_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *fmt ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;

  {
  {
#line 1108
  tmp = video_drvdata(file);
#line 1108
  gspca_dev = (struct gspca_dev *)tmp;
#line 1110
  fmt->fmt.pix = gspca_dev->pixfmt;
#line 1113
  fmt->fmt.pix.priv = 0U;
  }
#line 1114
  return (0);
}
}
#line 1117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int try_fmt_vid_cap(struct gspca_dev *gspca_dev , struct v4l2_format *fmt ) 
{ 
  int w ;
  int h ;
  int mode ;
  int mode2 ;

  {
  {
#line 1122
  w = (int )fmt->fmt.pix.width;
#line 1123
  h = (int )fmt->fmt.pix.height;
#line 1125
  PDEBUG_MODE(gspca_dev, 2, (char *)"try fmt cap", fmt->fmt.pix.pixelformat, w, h);
#line 1129
  mode = wxh_to_mode(gspca_dev, w, h);
  }
#line 1132
  if ((unsigned int )(gspca_dev->cam.cam_mode + (unsigned long )mode)->pixelformat != fmt->fmt.pix.pixelformat) {
    {
#line 1136
    mode2 = gspca_get_mode(gspca_dev, mode, (int )fmt->fmt.pix.pixelformat);
    }
#line 1138
    if (mode2 >= 0) {
#line 1139
      mode = mode2;
    } else {

    }
  } else {

  }
#line 1141
  fmt->fmt.pix = *(gspca_dev->cam.cam_mode + (unsigned long )mode);
#line 1142
  if ((unsigned long )(gspca_dev->sd_desc)->try_fmt != (unsigned long )((void (*)(struct gspca_dev * ,
                                                                                  struct v4l2_format * ))0)) {
    {
#line 1144
    fmt->fmt.pix.width = (__u32 )w;
#line 1145
    fmt->fmt.pix.height = (__u32 )h;
#line 1146
    (*((gspca_dev->sd_desc)->try_fmt))(gspca_dev, fmt);
    }
  } else {

  }
#line 1150
  fmt->fmt.pix.priv = 0U;
#line 1151
  return (mode);
}
}
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_try_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *fmt ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int ret ;

  {
  {
#line 1158
  tmp = video_drvdata(file);
#line 1158
  gspca_dev = (struct gspca_dev *)tmp;
#line 1161
  ret = try_fmt_vid_cap(gspca_dev, fmt);
  }
#line 1162
  if (ret < 0) {
#line 1163
    return (ret);
  } else {

  }
#line 1164
  return (0);
}
}
#line 1167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_s_fmt_vid_cap(struct file *file , void *priv , struct v4l2_format *fmt ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 1170
  tmp = video_drvdata(file);
#line 1170
  gspca_dev = (struct gspca_dev *)tmp;
#line 1173
  tmp___0 = ldv_mutex_lock_interruptible_113(& gspca_dev->queue_lock);
  }
#line 1173
  if (tmp___0 != 0) {
#line 1174
    return (-512);
  } else {

  }
  {
#line 1176
  ret = try_fmt_vid_cap(gspca_dev, fmt);
  }
#line 1177
  if (ret < 0) {
#line 1178
    goto out;
  } else {

  }
#line 1180
  if ((int )((signed char )gspca_dev->nframes) != 0 && fmt->fmt.pix.sizeimage > gspca_dev->frsz) {
#line 1182
    ret = -22;
#line 1183
    goto out;
  } else {

  }
#line 1186
  if ((unsigned int )gspca_dev->streaming != 0U) {
#line 1187
    ret = -16;
#line 1188
    goto out;
  } else {

  }
#line 1190
  gspca_dev->curr_mode = (__u8 )ret;
#line 1191
  if ((unsigned long )(gspca_dev->sd_desc)->try_fmt != (unsigned long )((void (*)(struct gspca_dev * ,
                                                                                  struct v4l2_format * ))0)) {
#line 1193
    gspca_dev->pixfmt = fmt->fmt.pix;
  } else {
#line 1195
    gspca_dev->pixfmt = *(gspca_dev->cam.cam_mode + (unsigned long )ret);
  }
#line 1197
  ret = 0;
  out: 
  {
#line 1199
  ldv_mutex_unlock_114(& gspca_dev->queue_lock);
  }
#line 1200
  return (ret);
}
}
#line 1203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_enum_framesizes(struct file *file , void *priv , struct v4l2_frmsizeenum *fsize ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int i ;
  __u32 index ;
  int tmp___0 ;

  {
  {
#line 1206
  tmp = video_drvdata(file);
#line 1206
  gspca_dev = (struct gspca_dev *)tmp;
#line 1208
  index = 0U;
  }
#line 1210
  if ((unsigned long )(gspca_dev->sd_desc)->enum_framesizes != (unsigned long )((int (*)(struct gspca_dev * ,
                                                                                         struct v4l2_frmsizeenum * ))0)) {
    {
#line 1211
    tmp___0 = (*((gspca_dev->sd_desc)->enum_framesizes))(gspca_dev, fsize);
    }
#line 1211
    return (tmp___0);
  } else {

  }
#line 1213
  i = 0;
#line 1213
  goto ldv_36751;
  ldv_36750: ;
#line 1214
  if (fsize->pixel_format != (__u32 )(gspca_dev->cam.cam_mode + (unsigned long )i)->pixelformat) {
#line 1216
    goto ldv_36749;
  } else {

  }
#line 1218
  if (fsize->index == index) {
#line 1219
    fsize->type = 1U;
#line 1220
    fsize->__annonCompField72.discrete.width = (gspca_dev->cam.cam_mode + (unsigned long )i)->width;
#line 1222
    fsize->__annonCompField72.discrete.height = (gspca_dev->cam.cam_mode + (unsigned long )i)->height;
#line 1224
    return (0);
  } else {

  }
#line 1226
  index = index + 1U;
  ldv_36749: 
#line 1213
  i = i + 1;
  ldv_36751: ;
#line 1213
  if (i < (int )gspca_dev->cam.nmodes) {
#line 1215
    goto ldv_36750;
  } else {

  }

#line 1229
  return (-22);
}
}
#line 1232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_enum_frameintervals(struct file *filp , void *priv , struct v4l2_frmivalenum *fival ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int mode ;
  int tmp___0 ;
  __u32 i ;

  {
  {
#line 1235
  tmp = video_drvdata(filp);
#line 1235
  gspca_dev = (struct gspca_dev *)tmp;
#line 1236
  tmp___0 = wxh_to_mode(gspca_dev, (int )fival->width, (int )fival->height);
#line 1236
  mode = tmp___0;
  }
#line 1239
  if ((unsigned long )gspca_dev->cam.mode_framerates == (unsigned long )((struct framerates  const  *)0) || (int )(gspca_dev->cam.mode_framerates + (unsigned long )mode)->nrates == 0) {
#line 1241
    return (-22);
  } else {

  }
#line 1243
  if (fival->pixel_format != (__u32 )(gspca_dev->cam.cam_mode + (unsigned long )mode)->pixelformat) {
#line 1245
    return (-22);
  } else {

  }
#line 1247
  i = 0U;
#line 1247
  goto ldv_36762;
  ldv_36761: ;
#line 1248
  if (fival->index == i) {
#line 1249
    fival->type = 1U;
#line 1250
    fival->__annonCompField73.discrete.numerator = 1U;
#line 1251
    fival->__annonCompField73.discrete.denominator = (__u32 )*((gspca_dev->cam.mode_framerates + (unsigned long )mode)->rates + (unsigned long )i);
#line 1253
    return (0);
  } else {

  }
#line 1247
  i = i + 1U;
  ldv_36762: ;
#line 1247
  if (i < (__u32 )(gspca_dev->cam.mode_framerates + (unsigned long )mode)->nrates) {
#line 1249
    goto ldv_36761;
  } else {

  }

#line 1257
  return (-22);
}
}
#line 1260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void gspca_release(struct v4l2_device *v4l2_device ) 
{ 
  struct gspca_dev *gspca_dev ;
  struct v4l2_device  const  *__mptr ;

  {
  {
#line 1263
  __mptr = (struct v4l2_device  const  *)v4l2_device;
#line 1263
  gspca_dev = (struct gspca_dev *)__mptr + 0xfffffffffffff8d0UL;
#line 1265
  v4l2_ctrl_handler_free(gspca_dev->vdev.ctrl_handler);
#line 1266
  v4l2_device_unregister(& gspca_dev->v4l2_dev);
#line 1267
  kfree((void const   *)gspca_dev->usb_buf);
#line 1268
  kfree((void const   *)gspca_dev);
  }
#line 1269
  return;
}
}
#line 1271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int dev_open(struct file *file ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int ret ;
  struct task_struct *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1273
  tmp = video_drvdata(file);
#line 1273
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1276
  if (gspca_debug > 2) {
    {
#line 1276
    tmp___0 = get_current();
#line 1276
    printk("\017%s: [%s] open", (char *)(& gspca_dev->v4l2_dev.name), (char *)(& tmp___0->comm));
    }
  } else {

  }
  {
#line 1279
  tmp___1 = ldv_try_module_get_115(gspca_dev->module);
  }
#line 1279
  if (tmp___1) {
#line 1279
    tmp___2 = 0;
  } else {
#line 1279
    tmp___2 = 1;
  }
#line 1279
  if (tmp___2) {
#line 1280
    return (-19);
  } else {

  }
  {
#line 1282
  ret = v4l2_fh_open(file);
  }
#line 1283
  if (ret != 0) {
    {
#line 1284
    ldv_module_put_116(gspca_dev->module);
    }
  } else {

  }
#line 1285
  return (ret);
}
}
#line 1288 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int dev_close(struct file *file ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1290
  tmp = video_drvdata(file);
#line 1290
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1292
  if (gspca_debug > 2) {
    {
#line 1292
    tmp___0 = get_current();
#line 1292
    printk("\017%s: [%s] close", (char *)(& gspca_dev->v4l2_dev.name), (char *)(& tmp___0->comm));
    }
  } else {

  }
  {
#line 1295
  tmp___1 = ldv_mutex_lock_interruptible_117(& gspca_dev->usb_lock);
  }
#line 1295
  if (tmp___1 != 0) {
#line 1296
    return (-512);
  } else {

  }
  {
#line 1298
  tmp___2 = ldv_mutex_lock_interruptible_118(& gspca_dev->queue_lock);
  }
#line 1298
  if (tmp___2 != 0) {
    {
#line 1299
    ldv_mutex_unlock_119(& gspca_dev->usb_lock);
    }
#line 1300
    return (-512);
  } else {

  }
#line 1304
  if ((unsigned long )gspca_dev->capt_file == (unsigned long )file) {
#line 1305
    if ((unsigned int )gspca_dev->streaming != 0U) {
      {
#line 1306
      gspca_stream_off(gspca_dev);
      }
    } else {

    }
    {
#line 1307
    frame_free(gspca_dev);
    }
  } else {

  }
  {
#line 1309
  ldv_module_put_120(gspca_dev->module);
#line 1310
  ldv_mutex_unlock_121(& gspca_dev->queue_lock);
#line 1311
  ldv_mutex_unlock_122(& gspca_dev->usb_lock);
  }
#line 1313
  if (gspca_debug > 2) {
    {
#line 1313
    printk("\017%s: close done", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
  {
#line 1315
  tmp___3 = v4l2_fh_release(file);
  }
#line 1315
  return (tmp___3);
}
}
#line 1318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_querycap(struct file *file , void *priv , struct v4l2_capability *cap ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;

  {
  {
#line 1321
  tmp = video_drvdata(file);
#line 1321
  gspca_dev = (struct gspca_dev *)tmp;
#line 1323
  strlcpy((char *)(& cap->driver), (gspca_dev->sd_desc)->name, 16UL);
  }
#line 1325
  if ((unsigned long )(gspca_dev->dev)->product != (unsigned long )((char *)0)) {
    {
#line 1326
    strlcpy((char *)(& cap->card), (char const   *)(gspca_dev->dev)->product, 32UL);
    }
  } else {
    {
#line 1329
    snprintf((char *)(& cap->card), 32UL, "USB Camera (%04x:%04x)", (int )(gspca_dev->dev)->descriptor.idVendor,
             (int )(gspca_dev->dev)->descriptor.idProduct);
    }
  }
  {
#line 1334
  usb_make_path(gspca_dev->dev, (char *)(& cap->bus_info), 32UL);
#line 1336
  cap->device_caps = 83886081U;
#line 1339
  cap->capabilities = cap->device_caps | 2147483648U;
  }
#line 1340
  return (0);
}
}
#line 1343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_enum_input(struct file *file , void *priv , struct v4l2_input *input ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;

  {
  {
#line 1346
  tmp = video_drvdata(file);
#line 1346
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1348
  if (input->index != 0U) {
#line 1349
    return (-22);
  } else {

  }
  {
#line 1350
  input->type = 2U;
#line 1351
  input->status = gspca_dev->cam.input_flags;
#line 1352
  strlcpy((char *)(& input->name), (gspca_dev->sd_desc)->name, 32UL);
  }
#line 1354
  return (0);
}
}
#line 1357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_g_input(struct file *file , void *priv , unsigned int *i ) 
{ 


  {
#line 1359
  *i = 0U;
#line 1360
  return (0);
}
}
#line 1363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_s_input(struct file *file , void *priv , unsigned int i ) 
{ 


  {
#line 1365
  if (i != 0U) {
#line 1366
    return (-22);
  } else {

  }
#line 1367
  return (0);
}
}
#line 1370 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_reqbufs(struct file *file , void *priv , struct v4l2_requestbuffers *rb ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int i ;
  int ret ;
  int streaming ;
  int tmp___0 ;

  {
  {
#line 1373
  tmp = video_drvdata(file);
#line 1373
  gspca_dev = (struct gspca_dev *)tmp;
#line 1374
  ret = 0;
#line 1376
  i = (int )rb->memory;
  }
  {
#line 1378
  if (i == 7) {
#line 1378
    goto case_7;
  } else {

  }
#line 1379
  if (i == 1) {
#line 1379
    goto case_1;
  } else {

  }
#line 1380
  if (i == 2) {
#line 1380
    goto case_2;
  } else {

  }
#line 1382
  goto switch_default;
  case_7: /* CIL Label */ ;
  case_1: /* CIL Label */ ;
  case_2: /* CIL Label */ ;
#line 1381
  goto ldv_36813;
  switch_default: /* CIL Label */ ;
#line 1383
  return (-22);
  switch_break: /* CIL Label */ ;
  }
  ldv_36813: 
  {
#line 1385
  tmp___0 = ldv_mutex_lock_interruptible_123(& gspca_dev->queue_lock);
  }
#line 1385
  if (tmp___0 != 0) {
#line 1386
    return (-512);
  } else {

  }
#line 1388
  if (((int )gspca_dev->memory != 0 && (int )gspca_dev->memory != 7) && (__u32 )gspca_dev->memory != rb->memory) {
#line 1391
    ret = -16;
#line 1392
    goto out;
  } else {

  }
#line 1396
  if ((unsigned long )gspca_dev->capt_file != (unsigned long )((struct file *)0) && (unsigned long )gspca_dev->capt_file != (unsigned long )file) {
#line 1398
    ret = -16;
#line 1399
    goto out;
  } else {

  }
#line 1403
  i = 0;
#line 1403
  goto ldv_36817;
  ldv_36816: ;
#line 1404
  if (gspca_dev->frame[i].vma_use_count != 0) {
#line 1405
    ret = -16;
#line 1406
    goto out;
  } else {

  }
#line 1403
  i = i + 1;
  ldv_36817: ;
#line 1403
  if (i < (int )gspca_dev->nframes) {
#line 1405
    goto ldv_36816;
  } else {

  }
#line 1411
  streaming = (int )gspca_dev->streaming;
#line 1412
  if (streaming != 0) {
    {
#line 1413
    gspca_stream_off(gspca_dev);
    }
#line 1417
    if ((int )((signed char )gspca_dev->memory) == 7) {
#line 1418
      streaming = 0;
    } else {

    }
  } else {

  }
#line 1422
  if ((int )((signed char )gspca_dev->nframes) != 0) {
    {
#line 1423
    frame_free(gspca_dev);
    }
  } else {

  }
#line 1424
  if (rb->count == 0U) {
#line 1425
    goto out;
  } else {

  }
  {
#line 1426
  ret = frame_alloc(gspca_dev, file, (enum v4l2_memory )rb->memory, rb->count);
  }
#line 1427
  if (ret == 0) {
#line 1428
    rb->count = (__u32 )gspca_dev->nframes;
#line 1429
    if (streaming != 0) {
      {
#line 1430
      ret = gspca_init_transfer(gspca_dev);
      }
    } else {

    }
  } else {

  }
  out: 
  {
#line 1433
  ldv_mutex_unlock_124(& gspca_dev->queue_lock);
  }
#line 1434
  if (gspca_debug > 2) {
    {
#line 1434
    printk("\017%s: reqbufs st:%d c:%d", (char *)(& gspca_dev->v4l2_dev.name), ret,
           rb->count);
    }
  } else {

  }
#line 1435
  return (ret);
}
}
#line 1438 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_querybuf(struct file *file , void *priv , struct v4l2_buffer *v4l2_buf ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  struct gspca_frame *frame ;

  {
  {
#line 1441
  tmp = video_drvdata(file);
#line 1441
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1444
  if (v4l2_buf->index >= (__u32 )gspca_dev->nframes) {
#line 1445
    return (-22);
  } else {

  }
  {
#line 1447
  frame = (struct gspca_frame *)(& gspca_dev->frame) + (unsigned long )v4l2_buf->index;
#line 1448
  __memcpy((void *)v4l2_buf, (void const   *)(& frame->v4l2_buf), 88UL);
  }
#line 1449
  return (0);
}
}
#line 1452 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_streamon(struct file *file , void *priv , enum v4l2_buf_type buf_type ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 1455
  tmp = video_drvdata(file);
#line 1455
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1458
  if ((unsigned int )buf_type != 1U) {
#line 1459
    return (-22);
  } else {

  }
  {
#line 1460
  tmp___0 = ldv_mutex_lock_interruptible_125(& gspca_dev->queue_lock);
  }
#line 1460
  if (tmp___0 != 0) {
#line 1461
    return (-512);
  } else {

  }
#line 1464
  if ((unsigned long )gspca_dev->capt_file != (unsigned long )file) {
#line 1465
    ret = -16;
#line 1466
    goto out;
  } else {

  }
#line 1469
  if ((int )((signed char )gspca_dev->nframes) == 0 || (gspca_dev->frame[0].v4l2_buf.flags & 2U) == 0U) {
#line 1471
    ret = -22;
#line 1472
    goto out;
  } else {

  }
#line 1474
  if ((unsigned int )gspca_dev->streaming == 0U) {
    {
#line 1475
    ret = gspca_init_transfer(gspca_dev);
    }
#line 1476
    if (ret < 0) {
#line 1477
      goto out;
    } else {

    }
  } else {

  }
  {
#line 1479
  PDEBUG_MODE(gspca_dev, 3, (char *)"stream on OK", gspca_dev->pixfmt.pixelformat,
              (int )gspca_dev->pixfmt.width, (int )gspca_dev->pixfmt.height);
#line 1482
  ret = 0;
  }
  out: 
  {
#line 1484
  ldv_mutex_unlock_126(& gspca_dev->queue_lock);
  }
#line 1485
  return (ret);
}
}
#line 1488 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_streamoff(struct file *file , void *priv , enum v4l2_buf_type buf_type ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int i ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 1491
  tmp = video_drvdata(file);
#line 1491
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1494
  if ((unsigned int )buf_type != 1U) {
#line 1495
    return (-22);
  } else {

  }
  {
#line 1497
  tmp___0 = ldv_mutex_lock_interruptible_127(& gspca_dev->queue_lock);
  }
#line 1497
  if (tmp___0 != 0) {
#line 1498
    return (-512);
  } else {

  }
#line 1500
  if ((unsigned int )gspca_dev->streaming == 0U) {
#line 1501
    ret = 0;
#line 1502
    goto out;
  } else {

  }
#line 1506
  if ((unsigned long )gspca_dev->capt_file != (unsigned long )file) {
#line 1507
    ret = -16;
#line 1508
    goto out;
  } else {

  }
  {
#line 1512
  gspca_stream_off(gspca_dev);
#line 1514
  __wake_up(& gspca_dev->wq, 1U, 1, (void *)0);
#line 1517
  i = 0;
  }
#line 1517
  goto ldv_36844;
  ldv_36843: 
#line 1518
  gspca_dev->frame[i].v4l2_buf.flags = gspca_dev->frame[i].v4l2_buf.flags & 4294967289U;
#line 1517
  i = i + 1;
  ldv_36844: ;
#line 1517
  if (i < (int )gspca_dev->nframes) {
#line 1519
    goto ldv_36843;
  } else {

  }
  {
#line 1519
  atomic_set(& gspca_dev->fr_q, 0);
#line 1520
  atomic_set(& gspca_dev->fr_i, 0);
#line 1521
  gspca_dev->fr_o = 0U;
#line 1522
  ret = 0;
  }
  out: 
  {
#line 1524
  ldv_mutex_unlock_128(& gspca_dev->queue_lock);
  }
#line 1525
  return (ret);
}
}
#line 1528 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_g_jpegcomp(struct file *file , void *priv , struct v4l2_jpegcompression *jpegcomp ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1531
  tmp = video_drvdata(file);
#line 1531
  gspca_dev = (struct gspca_dev *)tmp;
#line 1533
  gspca_dev->usb_err = 0;
#line 1534
  tmp___0 = (*((gspca_dev->sd_desc)->get_jcomp))(gspca_dev, jpegcomp);
  }
#line 1534
  return (tmp___0);
}
}
#line 1537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_s_jpegcomp(struct file *file , void *priv , struct v4l2_jpegcompression  const  *jpegcomp ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1540
  tmp = video_drvdata(file);
#line 1540
  gspca_dev = (struct gspca_dev *)tmp;
#line 1542
  gspca_dev->usb_err = 0;
#line 1543
  tmp___0 = (*((gspca_dev->sd_desc)->set_jcomp))(gspca_dev, jpegcomp);
  }
#line 1543
  return (tmp___0);
}
}
#line 1546 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_g_parm(struct file *filp , void *priv , struct v4l2_streamparm *parm ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;

  {
  {
#line 1549
  tmp = video_drvdata(filp);
#line 1549
  gspca_dev = (struct gspca_dev *)tmp;
#line 1551
  parm->parm.capture.readbuffers = (__u32 )gspca_dev->nbufread;
  }
#line 1553
  if ((unsigned long )(gspca_dev->sd_desc)->get_streamparm != (unsigned long )((void (*)(struct gspca_dev * ,
                                                                                         struct v4l2_streamparm * ))0)) {
    {
#line 1554
    gspca_dev->usb_err = 0;
#line 1555
    (*((gspca_dev->sd_desc)->get_streamparm))(gspca_dev, parm);
    }
#line 1556
    return (gspca_dev->usb_err);
  } else {

  }
#line 1558
  return (0);
}
}
#line 1561 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_s_parm(struct file *filp , void *priv , struct v4l2_streamparm *parm ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  unsigned int n ;

  {
  {
#line 1564
  tmp = video_drvdata(filp);
#line 1564
  gspca_dev = (struct gspca_dev *)tmp;
#line 1567
  n = parm->parm.capture.readbuffers;
  }
#line 1568
  if (n - 1U > 14U) {
#line 1569
    parm->parm.capture.readbuffers = (__u32 )gspca_dev->nbufread;
  } else {
#line 1571
    gspca_dev->nbufread = (char )n;
  }
#line 1573
  if ((unsigned long )(gspca_dev->sd_desc)->set_streamparm != (unsigned long )((void (*)(struct gspca_dev * ,
                                                                                         struct v4l2_streamparm * ))0)) {
    {
#line 1574
    gspca_dev->usb_err = 0;
#line 1575
    (*((gspca_dev->sd_desc)->set_streamparm))(gspca_dev, parm);
    }
#line 1576
    return (gspca_dev->usb_err);
  } else {

  }
#line 1579
  return (0);
}
}
#line 1582 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int dev_mmap(struct file *file , struct vm_area_struct *vma ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  struct gspca_frame *frame ;
  struct page *page ;
  unsigned long addr ;
  unsigned long start ;
  unsigned long size ;
  int i ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 1584
  tmp = video_drvdata(file);
#line 1584
  gspca_dev = (struct gspca_dev *)tmp;
#line 1590
  start = vma->vm_start;
#line 1591
  size = vma->vm_end - vma->vm_start;
  }
#line 1592
  if (gspca_debug > 2) {
    {
#line 1592
    printk("\017%s: mmap start:%08x size:%d", (char *)(& gspca_dev->v4l2_dev.name),
           (int )start, (int )size);
    }
  } else {

  }
  {
#line 1594
  tmp___0 = ldv_mutex_lock_interruptible_129(& gspca_dev->queue_lock);
  }
#line 1594
  if (tmp___0 != 0) {
#line 1595
    return (-512);
  } else {

  }
#line 1596
  if ((unsigned long )gspca_dev->capt_file != (unsigned long )file) {
#line 1597
    ret = -22;
#line 1598
    goto out;
  } else {

  }
#line 1601
  frame = (struct gspca_frame *)0;
#line 1602
  i = 0;
#line 1602
  goto ldv_36886;
  ldv_36885: ;
#line 1603
  if (gspca_dev->frame[i].v4l2_buf.memory != 1U) {
#line 1604
    if (gspca_debug > 2) {
      {
#line 1604
      printk("\017%s: mmap bad memory type", (char *)(& gspca_dev->v4l2_dev.name));
      }
    } else {

    }
#line 1605
    goto ldv_36884;
  } else {

  }
#line 1607
  if ((unsigned long )(gspca_dev->frame[i].v4l2_buf.m.offset >> 12) == vma->vm_pgoff) {
#line 1609
    frame = (struct gspca_frame *)(& gspca_dev->frame) + (unsigned long )i;
#line 1610
    goto ldv_36884;
  } else {

  }
#line 1602
  i = i + 1;
  ldv_36886: ;
#line 1602
  if (i < (int )gspca_dev->nframes) {
#line 1604
    goto ldv_36885;
  } else {

  }
  ldv_36884: ;
#line 1613
  if ((unsigned long )frame == (unsigned long )((struct gspca_frame *)0)) {
#line 1614
    if (gspca_debug > 2) {
      {
#line 1614
      printk("\017%s: mmap no frame buffer found", (char *)(& gspca_dev->v4l2_dev.name));
      }
    } else {

    }
#line 1615
    ret = -22;
#line 1616
    goto out;
  } else {

  }
#line 1618
  if (size != (unsigned long )frame->v4l2_buf.length) {
#line 1619
    if (gspca_debug > 2) {
      {
#line 1619
      printk("\017%s: mmap bad size", (char *)(& gspca_dev->v4l2_dev.name));
      }
    } else {

    }
#line 1620
    ret = -22;
#line 1621
    goto out;
  } else {

  }
#line 1628
  vma->vm_flags = vma->vm_flags | 16384UL;
#line 1630
  addr = (unsigned long )frame->data;
#line 1631
  goto ldv_36888;
  ldv_36887: 
  {
#line 1632
  page = vmalloc_to_page((void const   *)addr);
#line 1633
  ret = vm_insert_page(vma, start, page);
  }
#line 1634
  if (ret < 0) {
#line 1635
    goto out;
  } else {

  }
#line 1636
  start = start + 4096UL;
#line 1637
  addr = addr + 4096UL;
#line 1638
  size = size - 4096UL;
  ldv_36888: ;
#line 1631
  if (size != 0UL) {
#line 1633
    goto ldv_36887;
  } else {

  }
  {
#line 1641
  vma->vm_ops = & gspca_vm_ops;
#line 1642
  vma->vm_private_data = (void *)frame;
#line 1643
  gspca_vm_open(vma);
#line 1644
  ret = 0;
  }
  out: 
  {
#line 1646
  ldv_mutex_unlock_130(& gspca_dev->queue_lock);
  }
#line 1647
  return (ret);
}
}
#line 1650 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int frame_ready_nolock(struct gspca_dev *gspca_dev , struct file *file , enum v4l2_memory memory ) 
{ 
  int tmp ;

  {
#line 1653
  if ((int )((signed char )gspca_dev->present) == 0) {
#line 1654
    return (-19);
  } else {

  }
#line 1655
  if (((unsigned long )gspca_dev->capt_file != (unsigned long )file || (unsigned int )gspca_dev->memory != (unsigned int )memory) || (unsigned int )gspca_dev->streaming == 0U) {
#line 1657
    return (-22);
  } else {

  }
  {
#line 1660
  tmp = atomic_read((atomic_t const   *)(& gspca_dev->fr_i));
  }
#line 1660
  return ((int )gspca_dev->fr_o != tmp);
}
}
#line 1663 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int frame_ready(struct gspca_dev *gspca_dev , struct file *file , enum v4l2_memory memory ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 1668
  tmp = ldv_mutex_lock_interruptible_131(& gspca_dev->queue_lock);
  }
#line 1668
  if (tmp != 0) {
#line 1669
    return (-512);
  } else {

  }
  {
#line 1670
  ret = frame_ready_nolock(gspca_dev, file, memory);
#line 1671
  ldv_mutex_unlock_132(& gspca_dev->queue_lock);
  }
#line 1672
  return (ret);
}
}
#line 1680 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_dqbuf(struct file *file , void *priv , struct v4l2_buffer *v4l2_buf ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  struct gspca_frame *frame ;
  int i ;
  int j ;
  int ret ;
  int tmp___0 ;
  long __ret ;
  unsigned long tmp___1 ;
  wait_queue_t __wait ;
  long __ret___0 ;
  unsigned long tmp___2 ;
  long __int ;
  long tmp___3 ;
  bool __cond ;
  int tmp___4 ;
  bool __cond___0 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;

  {
  {
#line 1683
  tmp = video_drvdata(file);
#line 1683
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1687
  if (gspca_debug > 3) {
    {
#line 1687
    printk("\017%s: dqbuf", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
  {
#line 1689
  tmp___0 = ldv_mutex_lock_interruptible_133(& gspca_dev->queue_lock);
  }
#line 1689
  if (tmp___0 != 0) {
#line 1690
    return (-512);
  } else {

  }
  ldv_36926: 
  {
#line 1693
  ret = frame_ready_nolock(gspca_dev, file, (enum v4l2_memory )v4l2_buf->memory);
  }
#line 1694
  if (ret < 0) {
#line 1695
    goto out;
  } else {

  }
#line 1696
  if (ret > 0) {
#line 1697
    goto ldv_36912;
  } else {

  }
  {
#line 1699
  ldv_mutex_unlock_134(& gspca_dev->queue_lock);
  }
#line 1701
  if ((file->f_flags & 2048U) != 0U) {
#line 1702
    return (-11);
  } else {

  }
  {
#line 1705
  tmp___1 = msecs_to_jiffies(3000U);
#line 1705
  __ret = (long )tmp___1;
#line 1705
  __might_sleep("drivers/media/usb/gspca/gspca.c", 1707, 0);
#line 1705
  tmp___5 = frame_ready(gspca_dev, file, (enum v4l2_memory )v4l2_buf->memory);
#line 1705
  __cond___0 = tmp___5 != 0;
  }
#line 1705
  if ((int )__cond___0 && __ret == 0L) {
#line 1705
    __ret = 1L;
  } else {

  }
#line 1705
  if (((int )__cond___0 || __ret == 0L) == 0) {
    {
#line 1705
    tmp___2 = msecs_to_jiffies(3000U);
#line 1705
    __ret___0 = (long )tmp___2;
#line 1705
    INIT_LIST_HEAD(& __wait.task_list);
#line 1705
    __wait.flags = 0U;
    }
    ldv_36923: 
    {
#line 1705
    tmp___3 = prepare_to_wait_event(& gspca_dev->wq, & __wait, 1);
#line 1705
    __int = tmp___3;
#line 1705
    tmp___4 = frame_ready(gspca_dev, file, (enum v4l2_memory )v4l2_buf->memory);
#line 1705
    __cond = tmp___4 != 0;
    }
#line 1705
    if ((int )__cond && __ret___0 == 0L) {
#line 1705
      __ret___0 = 1L;
    } else {

    }
#line 1705
    if (((int )__cond || __ret___0 == 0L) != 0) {
#line 1705
      goto ldv_36922;
    } else {

    }
#line 1705
    if (__int != 0L) {
#line 1705
      __ret___0 = __int;
#line 1705
      goto ldv_36922;
    } else {

    }
    {
#line 1705
    __ret___0 = schedule_timeout(__ret___0);
    }
#line 1705
    goto ldv_36923;
    ldv_36922: 
    {
#line 1705
    finish_wait(& gspca_dev->wq, & __wait);
    }
#line 1705
    __ret = __ret___0;
  } else {

  }
#line 1705
  ret = (int )__ret;
#line 1708
  if (ret < 0) {
#line 1709
    return (ret);
  } else {

  }
#line 1710
  if (ret == 0) {
#line 1711
    return (-5);
  } else {

  }
  {
#line 1713
  tmp___6 = ldv_mutex_lock_interruptible_135(& gspca_dev->queue_lock);
  }
#line 1713
  if (tmp___6 != 0) {
#line 1714
    return (-512);
  } else {

  }
#line 1715
  goto ldv_36926;
  ldv_36912: 
  {
#line 1717
  i = (int )gspca_dev->fr_o;
#line 1718
  j = (int )gspca_dev->fr_queue[i];
#line 1719
  frame = (struct gspca_frame *)(& gspca_dev->frame) + (unsigned long )j;
#line 1721
  gspca_dev->fr_o = (u8 )((i + 1) % 16);
#line 1723
  frame->v4l2_buf.flags = frame->v4l2_buf.flags & 4294967291U;
#line 1724
  __memcpy((void *)v4l2_buf, (void const   *)(& frame->v4l2_buf), 88UL);
  }
#line 1725
  if (gspca_debug > 3) {
    {
#line 1725
    printk("\017%s: dqbuf %d", (char *)(& gspca_dev->v4l2_dev.name), j);
    }
  } else {

  }
#line 1726
  ret = 0;
#line 1728
  if ((int )((signed char )gspca_dev->memory) == 2) {
    {
#line 1729
    tmp___7 = copy_to_user((void *)frame->v4l2_buf.m.userptr, (void const   *)frame->data,
                           (unsigned long )frame->v4l2_buf.bytesused);
    }
#line 1729
    if (tmp___7 != 0UL) {
      {
#line 1732
      printk("\v%s: dqbuf cp to user failed", (char *)(& gspca_dev->v4l2_dev.name));
#line 1733
      ret = -14;
      }
    } else {

    }
  } else {

  }
  out: 
  {
#line 1737
  ldv_mutex_unlock_136(& gspca_dev->queue_lock);
  }
#line 1739
  if (ret == 0 && (unsigned long )(gspca_dev->sd_desc)->dq_callback != (unsigned long )((void (*)(struct gspca_dev * ))0)) {
    {
#line 1740
    ldv_mutex_lock_137(& gspca_dev->usb_lock);
#line 1741
    gspca_dev->usb_err = 0;
    }
#line 1742
    if ((int )((signed char )gspca_dev->present) != 0) {
      {
#line 1743
      (*((gspca_dev->sd_desc)->dq_callback))(gspca_dev);
      }
    } else {

    }
    {
#line 1744
    ldv_mutex_unlock_138(& gspca_dev->usb_lock);
    }
  } else {

  }
#line 1747
  return (ret);
}
}
#line 1756 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int vidioc_qbuf(struct file *file , void *priv , struct v4l2_buffer *v4l2_buf ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  struct gspca_frame *frame ;
  int i ;
  int index ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 1759
  tmp = video_drvdata(file);
#line 1759
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1763
  if (gspca_debug > 3) {
    {
#line 1763
    printk("\017%s: qbuf %d", (char *)(& gspca_dev->v4l2_dev.name), v4l2_buf->index);
    }
  } else {

  }
  {
#line 1765
  tmp___0 = ldv_mutex_lock_interruptible_139(& gspca_dev->queue_lock);
  }
#line 1765
  if (tmp___0 != 0) {
#line 1766
    return (-512);
  } else {

  }
#line 1768
  index = (int )v4l2_buf->index;
#line 1769
  if ((unsigned int )index >= (unsigned int )gspca_dev->nframes) {
#line 1770
    if (gspca_debug > 3) {
      {
#line 1770
      printk("\017%s: qbuf idx %d >= %d", (char *)(& gspca_dev->v4l2_dev.name), index,
             (int )gspca_dev->nframes);
      }
    } else {

    }
#line 1772
    ret = -22;
#line 1773
    goto out;
  } else {

  }
#line 1775
  if (v4l2_buf->memory != (__u32 )gspca_dev->memory) {
#line 1776
    if (gspca_debug > 3) {
      {
#line 1776
      printk("\017%s: qbuf bad memory type", (char *)(& gspca_dev->v4l2_dev.name));
      }
    } else {

    }
#line 1777
    ret = -22;
#line 1778
    goto out;
  } else {

  }
#line 1781
  frame = (struct gspca_frame *)(& gspca_dev->frame) + (unsigned long )index;
#line 1782
  if ((frame->v4l2_buf.flags & 6U) != 0U) {
#line 1783
    if (gspca_debug > 3) {
      {
#line 1783
      printk("\017%s: qbuf bad state", (char *)(& gspca_dev->v4l2_dev.name));
      }
    } else {

    }
#line 1784
    ret = -22;
#line 1785
    goto out;
  } else {

  }
#line 1788
  frame->v4l2_buf.flags = frame->v4l2_buf.flags | 2U;
#line 1790
  if (frame->v4l2_buf.memory == 2U) {
#line 1791
    frame->v4l2_buf.m.userptr = v4l2_buf->m.userptr;
#line 1792
    frame->v4l2_buf.length = v4l2_buf->length;
  } else {

  }
  {
#line 1796
  i = atomic_read((atomic_t const   *)(& gspca_dev->fr_q));
#line 1797
  gspca_dev->fr_queue[i] = (signed char )index;
#line 1798
  atomic_set(& gspca_dev->fr_q, (i + 1) % 16);
#line 1800
  v4l2_buf->flags = v4l2_buf->flags | 2U;
#line 1801
  v4l2_buf->flags = v4l2_buf->flags & 4294967291U;
#line 1802
  ret = 0;
  }
  out: 
  {
#line 1804
  ldv_mutex_unlock_140(& gspca_dev->queue_lock);
  }
#line 1805
  return (ret);
}
}
#line 1811 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int read_alloc(struct gspca_dev *gspca_dev , struct file *file ) 
{ 
  struct v4l2_buffer v4l2_buf ;
  int i ;
  int ret ;
  int tmp ;
  struct v4l2_requestbuffers rb ;

  {
#line 1817
  if (gspca_debug > 2) {
    {
#line 1817
    printk("\017%s: read alloc", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
  {
#line 1819
  tmp = ldv_mutex_lock_interruptible_141(& gspca_dev->usb_lock);
  }
#line 1819
  if (tmp != 0) {
#line 1820
    return (-512);
  } else {

  }
#line 1822
  if ((int )((signed char )gspca_dev->nframes) == 0) {
    {
#line 1825
    __memset((void *)(& rb), 0, 20UL);
#line 1826
    rb.count = (__u32 )gspca_dev->nbufread;
#line 1827
    rb.type = 1U;
#line 1828
    rb.memory = 7U;
#line 1829
    ret = vidioc_reqbufs(file, (void *)gspca_dev, & rb);
    }
#line 1830
    if (ret != 0) {
#line 1831
      if (gspca_debug > 2) {
        {
#line 1831
        printk("\017%s: read reqbuf err %d", (char *)(& gspca_dev->v4l2_dev.name),
               ret);
        }
      } else {

      }
#line 1832
      goto out;
    } else {

    }
    {
#line 1834
    __memset((void *)(& v4l2_buf), 0, 88UL);
#line 1835
    v4l2_buf.type = 1U;
#line 1836
    v4l2_buf.memory = 7U;
#line 1837
    i = 0;
    }
#line 1837
    goto ldv_36948;
    ldv_36947: 
    {
#line 1838
    v4l2_buf.index = (__u32 )i;
#line 1839
    ret = vidioc_qbuf(file, (void *)gspca_dev, & v4l2_buf);
    }
#line 1840
    if (ret != 0) {
#line 1841
      if (gspca_debug > 2) {
        {
#line 1841
        printk("\017%s: read qbuf err: %d", (char *)(& gspca_dev->v4l2_dev.name),
               ret);
        }
      } else {

      }
#line 1842
      goto out;
    } else {

    }
#line 1837
    i = i + 1;
    ldv_36948: ;
#line 1837
    if (i < (int )gspca_dev->nbufread) {
#line 1839
      goto ldv_36947;
    } else {

    }

  } else {

  }
  {
#line 1848
  ret = vidioc_streamon(file, (void *)gspca_dev, 1);
  }
#line 1849
  if (ret != 0) {
#line 1850
    if (gspca_debug > 2) {
      {
#line 1850
      printk("\017%s: read streamon err %d", (char *)(& gspca_dev->v4l2_dev.name),
             ret);
      }
    } else {

    }
  } else {

  }
  out: 
  {
#line 1852
  ldv_mutex_unlock_142(& gspca_dev->usb_lock);
  }
#line 1853
  return (ret);
}
}
#line 1856 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static unsigned int dev_poll(struct file *file , poll_table *wait ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  unsigned long req_events ;
  unsigned long tmp___0 ;
  int ret ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1858
  tmp = video_drvdata(file);
#line 1858
  gspca_dev = (struct gspca_dev *)tmp;
#line 1859
  tmp___0 = poll_requested_events((poll_table const   *)wait);
#line 1859
  req_events = tmp___0;
#line 1860
  ret = 0;
  }
#line 1862
  if (gspca_debug > 3) {
    {
#line 1862
    printk("\017%s: poll", (char *)(& gspca_dev->v4l2_dev.name));
    }
  } else {

  }
#line 1864
  if ((req_events & 2UL) != 0UL) {
    {
#line 1865
    tmp___1 = v4l2_ctrl_poll(file, wait);
#line 1865
    ret = (int )((unsigned int )ret | tmp___1);
    }
  } else {

  }
#line 1867
  if ((req_events & 65UL) != 0UL) {
#line 1869
    if ((int )((signed char )gspca_dev->memory) == 0) {
      {
#line 1870
      tmp___2 = read_alloc(gspca_dev, file);
      }
#line 1870
      if (tmp___2 != 0) {
#line 1871
        ret = ret | 8;
#line 1872
        goto out;
      } else {

      }
    } else {

    }
    {
#line 1876
    poll_wait(file, & gspca_dev->wq, wait);
#line 1879
    tmp___3 = ldv_mutex_lock_interruptible_143(& gspca_dev->queue_lock);
    }
#line 1879
    if (tmp___3 != 0) {
#line 1880
      ret = ret | 8;
#line 1881
      goto out;
    } else {

    }
    {
#line 1883
    tmp___4 = atomic_read((atomic_t const   *)(& gspca_dev->fr_i));
    }
#line 1883
    if ((int )gspca_dev->fr_o != tmp___4) {
#line 1884
      ret = ret | 65;
    } else {

    }
    {
#line 1885
    ldv_mutex_unlock_144(& gspca_dev->queue_lock);
    }
  } else {

  }
  out: ;
#line 1889
  if ((int )((signed char )gspca_dev->present) == 0) {
#line 1890
    ret = ret | 16;
  } else {

  }
#line 1892
  return ((unsigned int )ret);
}
}
#line 1895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static ssize_t dev_read(struct file *file , char *data , size_t count , loff_t *ppos ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  struct gspca_frame *frame ;
  struct v4l2_buffer v4l2_buf ;
  struct timeval timestamp ;
  int n ;
  int ret ;
  int ret2 ;
  ktime_t tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 1898
  tmp = video_drvdata(file);
#line 1898
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 1904
  if (gspca_debug > 3) {
    {
#line 1904
    printk("\017%s: read (%zd)", (char *)(& gspca_dev->v4l2_dev.name), count);
    }
  } else {

  }
#line 1905
  if ((int )((signed char )gspca_dev->memory) == 0) {
    {
#line 1906
    ret = read_alloc(gspca_dev, file);
    }
#line 1907
    if (ret != 0) {
#line 1908
      return ((ssize_t )ret);
    } else {

    }
  } else {

  }
  {
#line 1912
  tmp___0 = ktime_get();
#line 1912
  timestamp = ns_to_timeval(tmp___0.tv64);
#line 1913
  timestamp.tv_sec = timestamp.tv_sec - 1L;
#line 1914
  n = 2;
  }
  ldv_36972: 
  {
#line 1916
  __memset((void *)(& v4l2_buf), 0, 88UL);
#line 1917
  v4l2_buf.type = 1U;
#line 1918
  v4l2_buf.memory = 7U;
#line 1919
  ret = vidioc_dqbuf(file, (void *)gspca_dev, & v4l2_buf);
  }
#line 1920
  if (ret != 0) {
#line 1921
    if (gspca_debug > 2) {
      {
#line 1921
      printk("\017%s: read dqbuf err %d", (char *)(& gspca_dev->v4l2_dev.name), ret);
      }
    } else {

    }
#line 1922
    return ((ssize_t )ret);
  } else {

  }
#line 1927
  frame = (struct gspca_frame *)(& gspca_dev->frame) + (unsigned long )v4l2_buf.index;
#line 1928
  n = n - 1;
#line 1928
  if (n < 0) {
#line 1929
    goto ldv_36971;
  } else {

  }
#line 1930
  if (frame->v4l2_buf.timestamp.tv_sec >= timestamp.tv_sec) {
#line 1931
    goto ldv_36971;
  } else {

  }
  {
#line 1932
  ret = vidioc_qbuf(file, (void *)gspca_dev, & v4l2_buf);
  }
#line 1933
  if (ret != 0) {
#line 1934
    if (gspca_debug > 2) {
      {
#line 1934
      printk("\017%s: read qbuf err %d", (char *)(& gspca_dev->v4l2_dev.name), ret);
      }
    } else {

    }
#line 1935
    return ((ssize_t )ret);
  } else {

  }
#line 1937
  goto ldv_36972;
  ldv_36971: ;
#line 1940
  if (count > (size_t )frame->v4l2_buf.bytesused) {
#line 1941
    count = (size_t )frame->v4l2_buf.bytesused;
  } else {

  }
  {
#line 1942
  tmp___1 = copy_to_user((void *)data, (void const   *)frame->data, count);
#line 1942
  ret = (int )tmp___1;
  }
#line 1943
  if (ret != 0) {
    {
#line 1944
    printk("\v%s: read cp to user lack %d / %zd", (char *)(& gspca_dev->v4l2_dev.name),
           ret, count);
#line 1945
    ret = -14;
    }
#line 1946
    goto out;
  } else {

  }
#line 1948
  ret = (int )count;
  out: 
  {
#line 1951
  ret2 = vidioc_qbuf(file, (void *)gspca_dev, & v4l2_buf);
  }
#line 1952
  if (ret2 != 0) {
#line 1953
    return ((ssize_t )ret2);
  } else {

  }
#line 1954
  return ((ssize_t )ret);
}
}
#line 1957 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static struct v4l2_file_operations dev_fops  = 
#line 1957
     {& __this_module, & dev_read, 0, & dev_poll, 0, & video_ioctl2, 0, 0, & dev_mmap,
    & dev_open, & dev_close};
#line 1967 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static struct v4l2_ioctl_ops  const  dev_ioctl_ops  = 
#line 1967
     {& vidioc_querycap, 0, 0, & vidioc_enum_fmt_vid_cap, 0, 0, 0, 0, 0, & vidioc_g_fmt_vid_cap,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_s_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & vidioc_try_fmt_vid_cap, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_reqbufs,
    & vidioc_querybuf, & vidioc_qbuf, 0, & vidioc_dqbuf, 0, 0, 0, 0, 0, & vidioc_streamon,
    & vidioc_streamoff, 0, 0, 0, & vidioc_enum_input, & vidioc_g_input, & vidioc_s_input,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & vidioc_g_jpegcomp,
    & vidioc_s_jpegcomp, 0, 0, 0, 0, 0, & vidioc_g_parm, & vidioc_s_parm, 0, 0, 0,
    0, 0, 0, 0, 0, & vidioc_g_register, & vidioc_s_register, & vidioc_g_chip_info,
    & vidioc_enum_framesizes, & vidioc_enum_frameintervals, 0, 0, 0, 0, 0, 0, 0, & v4l2_ctrl_subscribe_event,
    & v4l2_event_unsubscribe, 0};
#line 1997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static struct video_device  const  gspca_template  = 
#line 1997
     {{{0, 0}, 0, 0U, 0, 0U, 0U, 0UL, 0U, (unsigned short)0, (unsigned short)0, (unsigned short)0,
     (unsigned short)0, 0, 0, 0, 0, 0, 0, {.alsa = {0U, 0U, 0U}}}, (struct v4l2_file_operations  const  *)(& dev_fops),
    {0, 0, {0, {0, 0}, 0, 0, 0, 0, {{0}}, {{{0L}, {0, 0}, 0, {0, {0, 0}, 0, 0, 0UL}},
                                           {{0, 0}, 0UL, 0, 0, 0UL, 0, 0, 0, {(char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0,
                                                                              (char)0},
                                            {0, {0, 0}, 0, 0, 0UL}}, 0, 0}, (unsigned char)0,
            (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
     0, 0, {{0}, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}, 0, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}},
     0, 0, 0, 0, {{0}, (unsigned char)0, (unsigned char)0, (_Bool)0, (_Bool)0, (_Bool)0,
                  (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, {{{{{0U}}, 0U, 0U, 0, {0,
                                                                                 {0,
                                                                                  0},
                                                                                 0,
                                                                                 0,
                                                                                 0UL}}}},
                  {0, 0}, {0U, {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0,
                                                                                  0}}},
                  0, (_Bool)0, (_Bool)0, {{0, 0}, 0UL, 0, 0, 0UL, 0, 0, 0, {(char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0,
                                                                            (char)0},
                                          {0, {0, 0}, 0, 0, 0UL}}, 0UL, {{0L}, {0,
                                                                                0},
                                                                         0, {0, {0,
                                                                                 0},
                                                                             0, 0,
                                                                             0UL}},
                  {{{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}, {0},
                  {0}, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
                  (unsigned char)0, (unsigned char)0, (unsigned char)0, 0, 0, 0, 0,
                  0UL, 0UL, 0UL, 0UL, 0, 0, 0}, 0, 0, 0, 0, 0ULL, 0UL, 0, {0, 0},
     0, 0, {0, 0}, 0, {0}, 0U, 0U, {{{{{0U}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}},
     {0, 0}, {0, {0, 0}, {{0}}}, 0, 0, 0, 0, (_Bool)0, (_Bool)0}, 0, 0, 0, 0, 0, 0,
    {'g', 's', 'p', 'c', 'a', ' ', 'm', 'a', 'i', 'n', ' ', 'd', 'r', 'i', 'v', 'e',
     'r', '\000'}, 0, 0, 0, (unsigned short)0, 0UL, 0, {{{{{0U}}, 0U, 0U, 0, {0, {0,
                                                                                  0},
                                                                              0, 0,
                                                                              0UL}}}},
    {0, 0}, 0, 0ULL, & video_device_release_empty, & dev_ioctl_ops, {0UL, 0UL, 0UL},
    {0UL, 0UL, 0UL}, 0};
#line 2010 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
int gspca_dev_probe2(struct usb_interface *intf , struct usb_device_id  const  *id ,
                     struct sd_desc  const  *sd_desc , int dev_size , struct module *module ) 
{ 
  struct gspca_dev *gspca_dev ;
  struct usb_device *dev ;
  struct usb_device *tmp ;
  int ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  int i ;
  struct usb_interface *intf2 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  char const   *tmp___2 ;

  {
  {
#line 2017
  tmp = interface_to_usbdev(intf);
#line 2017
  dev = tmp;
#line 2020
  printk("\016gspca_main: %s-2.14.0 probing %04x:%04x\n", sd_desc->name, (int )id->idVendor,
         (int )id->idProduct);
  }
#line 2024
  if ((unsigned int )dev_size <= 4839U) {
#line 2025
    dev_size = 4840;
  } else {

  }
  {
#line 2026
  tmp___0 = kzalloc((size_t )dev_size, 208U);
#line 2026
  gspca_dev = (struct gspca_dev *)tmp___0;
  }
#line 2027
  if ((unsigned long )gspca_dev == (unsigned long )((struct gspca_dev *)0)) {
    {
#line 2028
    printk("\vgspca_main: couldn\'t kzalloc gspca struct\n");
    }
#line 2029
    return (-12);
  } else {

  }
  {
#line 2031
  tmp___1 = kmalloc(64UL, 208U);
#line 2031
  gspca_dev->usb_buf = (__u8 *)tmp___1;
  }
#line 2032
  if ((unsigned long )gspca_dev->usb_buf == (unsigned long )((__u8 *)0U)) {
    {
#line 2033
    printk("\vgspca_main: out of memory\n");
#line 2034
    ret = -12;
    }
#line 2035
    goto out;
  } else {

  }
#line 2037
  gspca_dev->dev = dev;
#line 2038
  gspca_dev->iface = (intf->cur_altsetting)->desc.bInterfaceNumber;
#line 2039
  gspca_dev->xfer_ep = -1;
#line 2042
  if ((unsigned int )(dev->actconfig)->desc.bNumInterfaces != 1U) {
#line 2046
    i = 0;
#line 2046
    goto ldv_36992;
    ldv_36991: 
#line 2047
    intf2 = (dev->actconfig)->interface[i];
#line 2048
    if (((unsigned long )intf2 != (unsigned long )((struct usb_interface *)0) && (unsigned long )intf2->altsetting != (unsigned long )((struct usb_host_interface *)0)) && (unsigned int )(intf2->altsetting)->desc.bInterfaceClass == 1U) {
#line 2052
      gspca_dev->audio = 1U;
#line 2053
      goto ldv_36990;
    } else {

    }
#line 2046
    i = i + 1;
    ldv_36992: ;
#line 2046
    if (i < (int )(dev->actconfig)->desc.bNumInterfaces) {
#line 2048
      goto ldv_36991;
    } else {

    }
    ldv_36990: ;
  } else {

  }
  {
#line 2058
  gspca_dev->v4l2_dev.release = & gspca_release;
#line 2059
  ret = v4l2_device_register(& intf->dev, & gspca_dev->v4l2_dev);
  }
#line 2060
  if (ret != 0) {
#line 2061
    goto out;
  } else {

  }
  {
#line 2062
  gspca_dev->sd_desc = sd_desc;
#line 2063
  gspca_dev->nbufread = 2;
#line 2064
  gspca_dev->empty_packet = -1;
#line 2065
  gspca_dev->vdev = gspca_template;
#line 2066
  gspca_dev->vdev.v4l2_dev = & gspca_dev->v4l2_dev;
#line 2067
  video_set_drvdata(& gspca_dev->vdev, (void *)gspca_dev);
#line 2068
  gspca_dev->module = module;
#line 2069
  gspca_dev->present = 1;
#line 2071
  __mutex_init(& gspca_dev->usb_lock, "&gspca_dev->usb_lock", & __key);
#line 2072
  gspca_dev->vdev.lock = & gspca_dev->usb_lock;
#line 2073
  __mutex_init(& gspca_dev->queue_lock, "&gspca_dev->queue_lock", & __key___0);
#line 2074
  __init_waitqueue_head(& gspca_dev->wq, "&gspca_dev->wq", & __key___1);
#line 2077
  ret = (*(sd_desc->config))(gspca_dev, id);
  }
#line 2078
  if (ret < 0) {
#line 2079
    goto out;
  } else {

  }
  {
#line 2080
  ret = (*(sd_desc->init))(gspca_dev);
  }
#line 2081
  if (ret < 0) {
#line 2082
    goto out;
  } else {

  }
#line 2083
  if ((unsigned long )sd_desc->init_controls != (unsigned long )((int (*)(struct gspca_dev * ))0)) {
    {
#line 2084
    ret = (*(sd_desc->init_controls))(gspca_dev);
    }
  } else {

  }
#line 2085
  if (ret < 0) {
#line 2086
    goto out;
  } else {

  }
  {
#line 2087
  gspca_set_default_mode(gspca_dev);
#line 2089
  ret = gspca_input_connect(gspca_dev);
  }
#line 2090
  if (ret != 0) {
#line 2091
    goto out;
  } else {

  }
  {
#line 2098
  v4l2_disable_ioctl_locking(& gspca_dev->vdev, 3227014673U);
#line 2099
  v4l2_disable_ioctl_locking(& gspca_dev->vdev, 3227014671U);
#line 2100
  v4l2_disable_ioctl_locking(& gspca_dev->vdev, 3227014665U);
  }
#line 2102
  if ((unsigned long )(gspca_dev->sd_desc)->get_register == (unsigned long )((int (*)(struct gspca_dev * ,
                                                                                      struct v4l2_dbg_register * ))0)) {
    {
#line 2103
    v4l2_disable_ioctl(& gspca_dev->vdev, 3224917584U);
    }
  } else {

  }
#line 2104
  if ((unsigned long )(gspca_dev->sd_desc)->set_register == (unsigned long )((int (*)(struct gspca_dev * ,
                                                                                      struct v4l2_dbg_register  const  * ))0)) {
    {
#line 2105
    v4l2_disable_ioctl(& gspca_dev->vdev, 1077433935U);
    }
  } else {

  }
#line 2107
  if ((unsigned long )(gspca_dev->sd_desc)->get_jcomp == (unsigned long )((int (*)(struct gspca_dev * ,
                                                                                   struct v4l2_jpegcompression * ))0)) {
    {
#line 2108
    v4l2_disable_ioctl(& gspca_dev->vdev, 2156680765U);
    }
  } else {

  }
#line 2109
  if ((unsigned long )(gspca_dev->sd_desc)->set_jcomp == (unsigned long )((int (*)(struct gspca_dev * ,
                                                                                   struct v4l2_jpegcompression  const  * ))0)) {
    {
#line 2110
    v4l2_disable_ioctl(& gspca_dev->vdev, 1082938942U);
    }
  } else {

  }
  {
#line 2113
  ret = video_register_device(& gspca_dev->vdev, 0, -1);
  }
#line 2116
  if (ret < 0) {
    {
#line 2117
    printk("\vgspca_main: video_register_device err %d\n", ret);
    }
#line 2118
    goto out;
  } else {

  }
  {
#line 2121
  usb_set_intfdata(intf, (void *)gspca_dev);
  }
#line 2122
  if (gspca_debug > 0) {
    {
#line 2122
    tmp___2 = video_device_node_name(& gspca_dev->vdev);
#line 2122
    printk("\017%s: %s created", (char *)(& gspca_dev->v4l2_dev.name), tmp___2);
    }
  } else {

  }
  {
#line 2124
  gspca_input_create_urb(gspca_dev);
  }
#line 2126
  return (0);
  out: ;
#line 2129
  if ((unsigned long )gspca_dev->input_dev != (unsigned long )((struct input_dev *)0)) {
    {
#line 2130
    input_unregister_device(gspca_dev->input_dev);
    }
  } else {

  }
  {
#line 2132
  v4l2_ctrl_handler_free(gspca_dev->vdev.ctrl_handler);
#line 2133
  kfree((void const   *)gspca_dev->usb_buf);
#line 2134
  kfree((void const   *)gspca_dev);
  }
#line 2135
  return (ret);
}
}
#line 2137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static char const   __kstrtab_gspca_dev_probe2[17U]  = 
#line 2137
  {      'g',      's',      'p',      'c', 
        'a',      '_',      'd',      'e', 
        'v',      '_',      'p',      'r', 
        'o',      'b',      'e',      '2', 
        '\000'};
#line 2137
struct kernel_symbol  const  __ksymtab_gspca_dev_probe2 ;
#line 2137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct kernel_symbol  const  __ksymtab_gspca_dev_probe2  =    {(unsigned long )(& gspca_dev_probe2), (char const   *)(& __kstrtab_gspca_dev_probe2)};
#line 2140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
int gspca_dev_probe(struct usb_interface *intf , struct usb_device_id  const  *id ,
                    struct sd_desc  const  *sd_desc , int dev_size , struct module *module ) 
{ 
  struct usb_device *dev ;
  struct usb_device *tmp ;
  int tmp___0 ;

  {
  {
#line 2146
  tmp = interface_to_usbdev(intf);
#line 2146
  dev = tmp;
  }
#line 2149
  if ((unsigned int )dev->descriptor.bNumConfigurations != 1U) {
    {
#line 2150
    printk("\vgspca_main: %04x:%04x too many config\n", (int )id->idVendor, (int )id->idProduct);
    }
#line 2152
    return (-19);
  } else {

  }
#line 2156
  if ((unsigned int )(dev->actconfig)->desc.bNumInterfaces != 1U && (unsigned int )(intf->cur_altsetting)->desc.bInterfaceNumber != 0U) {
#line 2158
    return (-19);
  } else {

  }
  {
#line 2160
  tmp___0 = gspca_dev_probe2(intf, id, sd_desc, dev_size, module);
  }
#line 2160
  return (tmp___0);
}
}
#line 2162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static char const   __kstrtab_gspca_dev_probe[16U]  = 
#line 2162
  {      'g',      's',      'p',      'c', 
        'a',      '_',      'd',      'e', 
        'v',      '_',      'p',      'r', 
        'o',      'b',      'e',      '\000'};
#line 2162
struct kernel_symbol  const  __ksymtab_gspca_dev_probe ;
#line 2162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct kernel_symbol  const  __ksymtab_gspca_dev_probe  =    {(unsigned long )(& gspca_dev_probe), (char const   *)(& __kstrtab_gspca_dev_probe)};
#line 2170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
void gspca_disconnect(struct usb_interface *intf ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  struct input_dev *input_dev ;
  char const   *tmp___0 ;

  {
  {
#line 2172
  tmp = usb_get_intfdata(intf);
#line 2172
  gspca_dev = (struct gspca_dev *)tmp;
  }
#line 2177
  if (gspca_debug > 0) {
    {
#line 2177
    tmp___0 = video_device_node_name(& gspca_dev->vdev);
#line 2177
    printk("\017%s: %s disconnect", (char *)(& gspca_dev->v4l2_dev.name), tmp___0);
    }
  } else {

  }
  {
#line 2180
  ldv_mutex_lock_145(& gspca_dev->usb_lock);
#line 2182
  gspca_dev->present = 0;
#line 2183
  destroy_urbs(gspca_dev);
#line 2186
  gspca_input_destroy_urb(gspca_dev);
#line 2187
  input_dev = gspca_dev->input_dev;
  }
#line 2188
  if ((unsigned long )input_dev != (unsigned long )((struct input_dev *)0)) {
    {
#line 2189
    gspca_dev->input_dev = (struct input_dev *)0;
#line 2190
    input_unregister_device(input_dev);
    }
  } else {

  }
#line 2194
  if ((unsigned long )(gspca_dev->sd_desc)->stop0 != (unsigned long )((void (*)(struct gspca_dev * ))0) && (unsigned int )gspca_dev->streaming != 0U) {
    {
#line 2195
    (*((gspca_dev->sd_desc)->stop0))(gspca_dev);
    }
  } else {

  }
  {
#line 2196
  gspca_dev->streaming = 0U;
#line 2197
  gspca_dev->dev = (struct usb_device *)0;
#line 2198
  __wake_up(& gspca_dev->wq, 1U, 1, (void *)0);
#line 2200
  v4l2_device_disconnect(& gspca_dev->v4l2_dev);
#line 2201
  video_unregister_device(& gspca_dev->vdev);
#line 2203
  ldv_mutex_unlock_146(& gspca_dev->usb_lock);
#line 2206
  v4l2_device_put(& gspca_dev->v4l2_dev);
  }
#line 2207
  return;
}
}
#line 2208 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static char const   __kstrtab_gspca_disconnect[17U]  = 
#line 2208
  {      'g',      's',      'p',      'c', 
        'a',      '_',      'd',      'i', 
        's',      'c',      'o',      'n', 
        'n',      'e',      'c',      't', 
        '\000'};
#line 2208
struct kernel_symbol  const  __ksymtab_gspca_disconnect ;
#line 2208 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct kernel_symbol  const  __ksymtab_gspca_disconnect  =    {(unsigned long )(& gspca_disconnect), (char const   *)(& __kstrtab_gspca_disconnect)};
#line 2211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
int gspca_suspend(struct usb_interface *intf , pm_message_t message ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;

  {
  {
#line 2213
  tmp = usb_get_intfdata(intf);
#line 2213
  gspca_dev = (struct gspca_dev *)tmp;
#line 2215
  gspca_input_destroy_urb(gspca_dev);
  }
#line 2217
  if ((unsigned int )gspca_dev->streaming == 0U) {
#line 2218
    return (0);
  } else {

  }
  {
#line 2220
  ldv_mutex_lock_147(& gspca_dev->usb_lock);
#line 2221
  gspca_dev->frozen = 1;
#line 2222
  gspca_dev->usb_err = 0;
  }
#line 2223
  if ((unsigned long )(gspca_dev->sd_desc)->stopN != (unsigned long )((void (*)(struct gspca_dev * ))0)) {
    {
#line 2224
    (*((gspca_dev->sd_desc)->stopN))(gspca_dev);
    }
  } else {

  }
  {
#line 2225
  destroy_urbs(gspca_dev);
#line 2226
  gspca_set_alt0(gspca_dev);
  }
#line 2227
  if ((unsigned long )(gspca_dev->sd_desc)->stop0 != (unsigned long )((void (*)(struct gspca_dev * ))0)) {
    {
#line 2228
    (*((gspca_dev->sd_desc)->stop0))(gspca_dev);
    }
  } else {

  }
  {
#line 2229
  ldv_mutex_unlock_148(& gspca_dev->usb_lock);
  }
#line 2231
  return (0);
}
}
#line 2233 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static char const   __kstrtab_gspca_suspend[14U]  = 
#line 2233
  {      'g',      's',      'p',      'c', 
        'a',      '_',      's',      'u', 
        's',      'p',      'e',      'n', 
        'd',      '\000'};
#line 2233
struct kernel_symbol  const  __ksymtab_gspca_suspend ;
#line 2233 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct kernel_symbol  const  __ksymtab_gspca_suspend  =    {(unsigned long )(& gspca_suspend), (char const   *)(& __kstrtab_gspca_suspend)};
#line 2235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
int gspca_resume(struct usb_interface *intf ) 
{ 
  struct gspca_dev *gspca_dev ;
  void *tmp ;
  int streaming ;
  int ret ;

  {
  {
#line 2237
  tmp = usb_get_intfdata(intf);
#line 2237
  gspca_dev = (struct gspca_dev *)tmp;
#line 2238
  ret = 0;
#line 2240
  ldv_mutex_lock_149(& gspca_dev->usb_lock);
#line 2241
  gspca_dev->frozen = 0;
#line 2242
  gspca_dev->usb_err = 0;
#line 2243
  (*((gspca_dev->sd_desc)->init))(gspca_dev);
#line 2249
  streaming = (int )gspca_dev->streaming;
#line 2250
  gspca_dev->streaming = 0U;
  }
#line 2251
  if (streaming != 0) {
    {
#line 2252
    ret = gspca_init_transfer(gspca_dev);
    }
  } else {
    {
#line 2254
    gspca_input_create_urb(gspca_dev);
    }
  }
  {
#line 2255
  ldv_mutex_unlock_150(& gspca_dev->usb_lock);
  }
#line 2257
  return (ret);
}
}
#line 2259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static char const   __kstrtab_gspca_resume[13U]  = 
#line 2259
  {      'g',      's',      'p',      'c', 
        'a',      '_',      'r',      'e', 
        's',      'u',      'm',      'e', 
        '\000'};
#line 2259
struct kernel_symbol  const  __ksymtab_gspca_resume ;
#line 2259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
struct kernel_symbol  const  __ksymtab_gspca_resume  =    {(unsigned long )(& gspca_resume), (char const   *)(& __kstrtab_gspca_resume)};
#line 2263 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static int gspca_init(void) 
{ 


  {
  {
#line 2265
  printk("\016gspca_main: v2.14.0 registered\n");
  }
#line 2266
  return (0);
}
}
#line 2268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.c"
static void gspca_exit(void) 
{ 


  {
#line 2270
  return;
}
}
#line 593 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_EMGentry_exit_gspca_exit_2_2(void (*arg0)(void) ) ;
#line 594
int ldv_EMGentry_init_gspca_init_2_11(int (*arg0)(void) ) ;
#line 595
void ldv_dispatch_deregister_dummy_resourceless_instance_1_2_4(void) ;
#line 596
void ldv_dispatch_deregister_io_instance_2_2_5(void) ;
#line 597
void ldv_dispatch_register_dummy_resourceless_instance_1_2_6(void) ;
#line 598
void ldv_dispatch_register_io_instance_2_2_7(void) ;
#line 599
void ldv_dummy_resourceless_instance_callback_0_3(void (*arg0)(struct vm_area_struct * ) ,
                                                  struct vm_area_struct *arg1 ) ;
#line 600
void ldv_dummy_resourceless_instance_callback_0_7(void (*arg0)(struct vm_area_struct * ) ,
                                                  struct vm_area_struct *arg1 ) ;
#line 601
void ldv_entry_EMGentry_2(void *arg0 ) ;
#line 602
void main(void) ;
#line 603
void ldv_io_instance_callback_1_17(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                   struct file *arg1 , struct vm_area_struct *arg2 ) ;
#line 604
void ldv_io_instance_callback_1_18(unsigned int (*arg0)(struct file * , struct poll_table_struct * ) ,
                                   struct file *arg1 , struct poll_table_struct *arg2 ) ;
#line 605
void ldv_io_instance_callback_1_19(long (*arg0)(struct file * , char * , unsigned long  ,
                                                long long * ) , struct file *arg1 ,
                                   char *arg2 , unsigned long arg3 , long long *arg4 ) ;
#line 606
void ldv_io_instance_callback_1_22(long (*arg0)(struct file * , unsigned int  , unsigned long  ) ,
                                   struct file *arg1 , unsigned int arg2 , unsigned long arg3 ) ;
#line 607
void ldv_io_instance_callback_1_25(int (*arg0)(struct file * , void * , struct v4l2_buffer * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_buffer *arg3 ) ;
#line 608
void ldv_io_instance_callback_1_26(int (*arg0)(struct file * , void * , struct v4l2_fmtdesc * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_fmtdesc *arg3 ) ;
#line 609
void ldv_io_instance_callback_1_27(int (*arg0)(struct file * , void * , struct v4l2_frmivalenum * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_frmivalenum *arg3 ) ;
#line 610
void ldv_io_instance_callback_1_28(int (*arg0)(struct file * , void * , struct v4l2_frmsizeenum * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_frmsizeenum *arg3 ) ;
#line 611
void ldv_io_instance_callback_1_29(int (*arg0)(struct file * , void * , struct v4l2_input * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_input *arg3 ) ;
#line 612
void ldv_io_instance_callback_1_30(int (*arg0)(struct file * , void * , struct v4l2_dbg_chip_info * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_dbg_chip_info *arg3 ) ;
#line 613
void ldv_io_instance_callback_1_31(int (*arg0)(struct file * , void * , struct v4l2_format * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_format *arg3 ) ;
#line 614
void ldv_io_instance_callback_1_32(int (*arg0)(struct file * , void * , unsigned int * ) ,
                                   struct file *arg1 , void *arg2 , unsigned int *arg3 ) ;
#line 615
void ldv_io_instance_callback_1_35(int (*arg0)(struct file * , void * , struct v4l2_jpegcompression * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_jpegcompression *arg3 ) ;
#line 616
void ldv_io_instance_callback_1_36(int (*arg0)(struct file * , void * , struct v4l2_streamparm * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_streamparm *arg3 ) ;
#line 617
void ldv_io_instance_callback_1_37(int (*arg0)(struct file * , void * , struct v4l2_dbg_register * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_dbg_register *arg3 ) ;
#line 618
void ldv_io_instance_callback_1_38(int (*arg0)(struct file * , void * , struct v4l2_buffer * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_buffer *arg3 ) ;
#line 619
void ldv_io_instance_callback_1_39(int (*arg0)(struct file * , void * , struct v4l2_buffer * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_buffer *arg3 ) ;
#line 620
void ldv_io_instance_callback_1_4(void (*arg0)(struct video_device * ) , struct video_device *arg1 ) ;
#line 621
void ldv_io_instance_callback_1_40(int (*arg0)(struct file * , void * , struct v4l2_capability * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_capability *arg3 ) ;
#line 622
void ldv_io_instance_callback_1_41(int (*arg0)(struct file * , void * , struct v4l2_requestbuffers * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_requestbuffers *arg3 ) ;
#line 623
void ldv_io_instance_callback_1_42(int (*arg0)(struct file * , void * , struct v4l2_format * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_format *arg3 ) ;
#line 624
void ldv_io_instance_callback_1_43(int (*arg0)(struct file * , void * , unsigned int  ) ,
                                   struct file *arg1 , void *arg2 , unsigned int arg3 ) ;
#line 625
void ldv_io_instance_callback_1_46(int (*arg0)(struct file * , void * , struct v4l2_jpegcompression * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_jpegcompression *arg3 ) ;
#line 626
void ldv_io_instance_callback_1_47(int (*arg0)(struct file * , void * , struct v4l2_streamparm * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_streamparm *arg3 ) ;
#line 627
void ldv_io_instance_callback_1_48(int (*arg0)(struct file * , void * , struct v4l2_dbg_register * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_dbg_register *arg3 ) ;
#line 628
void ldv_io_instance_callback_1_49(int (*arg0)(struct file * , void * , enum v4l2_buf_type  ) ,
                                   struct file *arg1 , void *arg2 , enum v4l2_buf_type arg3 ) ;
#line 629
void ldv_io_instance_callback_1_50(int (*arg0)(struct file * , void * , enum v4l2_buf_type  ) ,
                                   struct file *arg1 , void *arg2 , enum v4l2_buf_type arg3 ) ;
#line 630
void ldv_io_instance_callback_1_51(int (*arg0)(struct v4l2_fh * , struct v4l2_event_subscription * ) ,
                                   struct v4l2_fh *arg1 , struct v4l2_event_subscription *arg2 ) ;
#line 631
void ldv_io_instance_callback_1_52(int (*arg0)(struct file * , void * , struct v4l2_format * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_format *arg3 ) ;
#line 632
void ldv_io_instance_callback_1_53(int (*arg0)(struct v4l2_fh * , struct v4l2_event_subscription * ) ,
                                   struct v4l2_fh *arg1 , struct v4l2_event_subscription *arg2 ) ;
#line 633
int ldv_io_instance_probe_1_11(int (*arg0)(struct file * ) , struct file *arg1 ) ;
#line 634
void ldv_io_instance_release_1_2(int (*arg0)(struct file * ) , struct file *arg1 ) ;
#line 635
void ldv_struct_vm_operations_struct_dummy_resourceless_instance_0(void *arg0 ) ;
#line 636
void ldv_v4l2_file_operations_io_instance_1(void *arg0 ) ;
#line 639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
struct ldv_thread ldv_thread_0  ;
#line 640 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
struct ldv_thread ldv_thread_1  ;
#line 641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
struct ldv_thread ldv_thread_2  ;
#line 647 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_EMGentry_exit_gspca_exit_2_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 648
  gspca_exit();
  }
#line 649
  return;
}
}
#line 652 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
int ldv_EMGentry_init_gspca_init_2_11(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 653
  tmp = gspca_init();
  }
#line 653
  return (tmp);
}
}
#line 657 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_1_2_4(void) 
{ 


  {
#line 661
  return;
}
}
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_dispatch_deregister_io_instance_2_2_5(void) 
{ 


  {
#line 669
  return;
}
}
#line 673 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_1_2_6(void) 
{ 
  struct ldv_struct_EMGentry_2 *cf_arg_0 ;
  void *tmp ;

  {
  {
#line 676
  tmp = ldv_xmalloc(4UL);
#line 676
  cf_arg_0 = (struct ldv_struct_EMGentry_2 *)tmp;
#line 677
  ldv_struct_vm_operations_struct_dummy_resourceless_instance_0((void *)cf_arg_0);
  }
#line 678
  return;
}
}
#line 682 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_dispatch_register_io_instance_2_2_7(void) 
{ 
  struct ldv_struct_EMGentry_2 *cf_arg_1 ;
  void *tmp ;

  {
  {
#line 685
  tmp = ldv_xmalloc(4UL);
#line 685
  cf_arg_1 = (struct ldv_struct_EMGentry_2 *)tmp;
#line 686
  ldv_v4l2_file_operations_io_instance_1((void *)cf_arg_1);
  }
#line 687
  return;
}
}
#line 691 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_dummy_resourceless_instance_callback_0_3(void (*arg0)(struct vm_area_struct * ) ,
                                                  struct vm_area_struct *arg1 ) 
{ 


  {
  {
#line 692
  gspca_vm_close(arg1);
  }
#line 693
  return;
}
}
#line 696 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_dummy_resourceless_instance_callback_0_7(void (*arg0)(struct vm_area_struct * ) ,
                                                  struct vm_area_struct *arg1 ) 
{ 


  {
  {
#line 697
  gspca_vm_open(arg1);
  }
#line 698
  return;
}
}
#line 701 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_entry_EMGentry_2(void *arg0 ) 
{ 
  void (*ldv_2_exit_gspca_exit_default)(void) ;
  int (*ldv_2_init_gspca_init_default)(void) ;
  int ldv_2_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 710
  ldv_2_ret_default = ldv_EMGentry_init_gspca_init_2_11(ldv_2_init_gspca_init_default);
#line 712
  ldv_2_ret_default = ldv_ldv_post_init_151(ldv_2_ret_default);
#line 715
  tmp___0 = ldv_undef_int();
  }
#line 715
  if (tmp___0 != 0) {
    {
#line 717
    ldv_assume(ldv_2_ret_default != 0);
#line 721
    ldv_ldv_check_final_state_152();
#line 722
    ldv_stop();
    }
#line 726
    return;
  } else {
    {
#line 730
    ldv_assume(ldv_2_ret_default == 0);
#line 733
    tmp = ldv_undef_int();
    }
#line 733
    if (tmp != 0) {
      {
#line 735
      ldv_dispatch_register_io_instance_2_2_7();
#line 739
      ldv_dispatch_register_dummy_resourceless_instance_1_2_6();
#line 743
      ldv_dispatch_deregister_io_instance_2_2_5();
#line 747
      ldv_dispatch_deregister_dummy_resourceless_instance_1_2_4();
      }
    } else {

    }
    {
#line 758
    ldv_EMGentry_exit_gspca_exit_2_2(ldv_2_exit_gspca_exit_default);
#line 762
    ldv_ldv_check_final_state_153();
#line 763
    ldv_stop();
    }
#line 767
    return;
  }
#line 770
  return;
}
}
#line 775 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void main(void) 
{ 


  {
  {
#line 776
  ldv_ldv_initialize_154();
#line 777
  ldv_entry_EMGentry_2((void *)0);
  }
#line 778
  return;
}
}
#line 782 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_17(int (*arg0)(struct file * , struct vm_area_struct * ) ,
                                   struct file *arg1 , struct vm_area_struct *arg2 ) 
{ 


  {
  {
#line 783
  dev_mmap(arg1, arg2);
  }
#line 784
  return;
}
}
#line 787 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_18(unsigned int (*arg0)(struct file * , struct poll_table_struct * ) ,
                                   struct file *arg1 , struct poll_table_struct *arg2 ) 
{ 


  {
  {
#line 788
  dev_poll(arg1, arg2);
  }
#line 789
  return;
}
}
#line 792 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_19(long (*arg0)(struct file * , char * , unsigned long  ,
                                                long long * ) , struct file *arg1 ,
                                   char *arg2 , unsigned long arg3 , long long *arg4 ) 
{ 


  {
  {
#line 793
  dev_read(arg1, arg2, arg3, arg4);
  }
#line 794
  return;
}
}
#line 797 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_22(long (*arg0)(struct file * , unsigned int  , unsigned long  ) ,
                                   struct file *arg1 , unsigned int arg2 , unsigned long arg3 ) 
{ 


  {
  {
#line 798
  video_ioctl2(arg1, arg2, arg3);
  }
#line 799
  return;
}
}
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_25(int (*arg0)(struct file * , void * , struct v4l2_buffer * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_buffer *arg3 ) 
{ 


  {
  {
#line 803
  vidioc_dqbuf(arg1, arg2, arg3);
  }
#line 804
  return;
}
}
#line 807 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_26(int (*arg0)(struct file * , void * , struct v4l2_fmtdesc * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_fmtdesc *arg3 ) 
{ 


  {
  {
#line 808
  vidioc_enum_fmt_vid_cap(arg1, arg2, arg3);
  }
#line 809
  return;
}
}
#line 812 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_27(int (*arg0)(struct file * , void * , struct v4l2_frmivalenum * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_frmivalenum *arg3 ) 
{ 


  {
  {
#line 813
  vidioc_enum_frameintervals(arg1, arg2, arg3);
  }
#line 814
  return;
}
}
#line 817 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_28(int (*arg0)(struct file * , void * , struct v4l2_frmsizeenum * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_frmsizeenum *arg3 ) 
{ 


  {
  {
#line 818
  vidioc_enum_framesizes(arg1, arg2, arg3);
  }
#line 819
  return;
}
}
#line 822 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_29(int (*arg0)(struct file * , void * , struct v4l2_input * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_input *arg3 ) 
{ 


  {
  {
#line 823
  vidioc_enum_input(arg1, arg2, arg3);
  }
#line 824
  return;
}
}
#line 827 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_30(int (*arg0)(struct file * , void * , struct v4l2_dbg_chip_info * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_dbg_chip_info *arg3 ) 
{ 


  {
  {
#line 828
  vidioc_g_chip_info(arg1, arg2, arg3);
  }
#line 829
  return;
}
}
#line 832 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_31(int (*arg0)(struct file * , void * , struct v4l2_format * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_format *arg3 ) 
{ 


  {
  {
#line 833
  vidioc_g_fmt_vid_cap(arg1, arg2, arg3);
  }
#line 834
  return;
}
}
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_32(int (*arg0)(struct file * , void * , unsigned int * ) ,
                                   struct file *arg1 , void *arg2 , unsigned int *arg3 ) 
{ 


  {
  {
#line 838
  vidioc_g_input(arg1, arg2, arg3);
  }
#line 839
  return;
}
}
#line 842 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_35(int (*arg0)(struct file * , void * , struct v4l2_jpegcompression * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_jpegcompression *arg3 ) 
{ 


  {
  {
#line 843
  vidioc_g_jpegcomp(arg1, arg2, arg3);
  }
#line 844
  return;
}
}
#line 847 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_36(int (*arg0)(struct file * , void * , struct v4l2_streamparm * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_streamparm *arg3 ) 
{ 


  {
  {
#line 848
  vidioc_g_parm(arg1, arg2, arg3);
  }
#line 849
  return;
}
}
#line 852 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_37(int (*arg0)(struct file * , void * , struct v4l2_dbg_register * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_dbg_register *arg3 ) 
{ 


  {
  {
#line 853
  vidioc_g_register(arg1, arg2, arg3);
  }
#line 854
  return;
}
}
#line 857 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_38(int (*arg0)(struct file * , void * , struct v4l2_buffer * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_buffer *arg3 ) 
{ 


  {
  {
#line 858
  vidioc_qbuf(arg1, arg2, arg3);
  }
#line 859
  return;
}
}
#line 862 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_39(int (*arg0)(struct file * , void * , struct v4l2_buffer * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_buffer *arg3 ) 
{ 


  {
  {
#line 863
  vidioc_querybuf(arg1, arg2, arg3);
  }
#line 864
  return;
}
}
#line 867 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_4(void (*arg0)(struct video_device * ) , struct video_device *arg1 ) 
{ 


  {
  {
#line 868
  video_device_release_empty(arg1);
  }
#line 869
  return;
}
}
#line 872 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_40(int (*arg0)(struct file * , void * , struct v4l2_capability * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_capability *arg3 ) 
{ 


  {
  {
#line 873
  vidioc_querycap(arg1, arg2, arg3);
  }
#line 874
  return;
}
}
#line 877 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_41(int (*arg0)(struct file * , void * , struct v4l2_requestbuffers * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_requestbuffers *arg3 ) 
{ 


  {
  {
#line 878
  vidioc_reqbufs(arg1, arg2, arg3);
  }
#line 879
  return;
}
}
#line 882 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_42(int (*arg0)(struct file * , void * , struct v4l2_format * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_format *arg3 ) 
{ 


  {
  {
#line 883
  vidioc_s_fmt_vid_cap(arg1, arg2, arg3);
  }
#line 884
  return;
}
}
#line 887 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_43(int (*arg0)(struct file * , void * , unsigned int  ) ,
                                   struct file *arg1 , void *arg2 , unsigned int arg3 ) 
{ 


  {
  {
#line 888
  vidioc_s_input(arg1, arg2, arg3);
  }
#line 889
  return;
}
}
#line 892 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_46(int (*arg0)(struct file * , void * , struct v4l2_jpegcompression * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_jpegcompression *arg3 ) 
{ 


  {
  {
#line 893
  vidioc_s_jpegcomp(arg1, arg2, (struct v4l2_jpegcompression  const  *)arg3);
  }
#line 894
  return;
}
}
#line 897 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_47(int (*arg0)(struct file * , void * , struct v4l2_streamparm * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_streamparm *arg3 ) 
{ 


  {
  {
#line 898
  vidioc_s_parm(arg1, arg2, arg3);
  }
#line 899
  return;
}
}
#line 902 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_48(int (*arg0)(struct file * , void * , struct v4l2_dbg_register * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_dbg_register *arg3 ) 
{ 


  {
  {
#line 903
  vidioc_s_register(arg1, arg2, (struct v4l2_dbg_register  const  *)arg3);
  }
#line 904
  return;
}
}
#line 907 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_49(int (*arg0)(struct file * , void * , enum v4l2_buf_type  ) ,
                                   struct file *arg1 , void *arg2 , enum v4l2_buf_type arg3 ) 
{ 


  {
  {
#line 908
  vidioc_streamoff(arg1, arg2, arg3);
  }
#line 909
  return;
}
}
#line 912 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_50(int (*arg0)(struct file * , void * , enum v4l2_buf_type  ) ,
                                   struct file *arg1 , void *arg2 , enum v4l2_buf_type arg3 ) 
{ 


  {
  {
#line 913
  vidioc_streamon(arg1, arg2, arg3);
  }
#line 914
  return;
}
}
#line 917 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_51(int (*arg0)(struct v4l2_fh * , struct v4l2_event_subscription * ) ,
                                   struct v4l2_fh *arg1 , struct v4l2_event_subscription *arg2 ) 
{ 


  {
  {
#line 918
  v4l2_ctrl_subscribe_event(arg1, (struct v4l2_event_subscription  const  *)arg2);
  }
#line 919
  return;
}
}
#line 922 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_52(int (*arg0)(struct file * , void * , struct v4l2_format * ) ,
                                   struct file *arg1 , void *arg2 , struct v4l2_format *arg3 ) 
{ 


  {
  {
#line 923
  vidioc_try_fmt_vid_cap(arg1, arg2, arg3);
  }
#line 924
  return;
}
}
#line 927 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_callback_1_53(int (*arg0)(struct v4l2_fh * , struct v4l2_event_subscription * ) ,
                                   struct v4l2_fh *arg1 , struct v4l2_event_subscription *arg2 ) 
{ 


  {
  {
#line 928
  v4l2_event_unsubscribe(arg1, (struct v4l2_event_subscription  const  *)arg2);
  }
#line 929
  return;
}
}
#line 932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
int ldv_io_instance_probe_1_11(int (*arg0)(struct file * ) , struct file *arg1 ) 
{ 
  int tmp ;

  {
  {
#line 933
  tmp = dev_open(arg1);
  }
#line 933
  return (tmp);
}
}
#line 937 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_io_instance_release_1_2(int (*arg0)(struct file * ) , struct file *arg1 ) 
{ 


  {
  {
#line 938
  dev_close(arg1);
  }
#line 939
  return;
}
}
#line 942 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_struct_vm_operations_struct_dummy_resourceless_instance_0(void *arg0 ) 
{ 
  void (*ldv_0_callback_close)(struct vm_area_struct * ) ;
  void (*ldv_0_callback_open)(struct vm_area_struct * ) ;
  struct vm_area_struct *ldv_0_container_struct_vm_area_struct_ptr ;
  int tmp ;

  {
#line 956
  goto ldv_call_0;
#line 958
  return;
  ldv_call_0: 
  {
#line 964
  tmp = ldv_undef_int();
  }
  {
#line 965
  if (tmp == 1) {
#line 965
    goto case_1;
  } else {

  }
#line 978
  if (tmp == 2) {
#line 978
    goto case_2;
  } else {

  }
#line 993
  if (tmp == 3) {
#line 993
    goto case_3;
  } else {

  }
#line 1002
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 968
  ldv_dummy_resourceless_instance_callback_0_7(ldv_0_callback_open, ldv_0_container_struct_vm_area_struct_ptr);
  }
#line 975
  goto ldv_call_0;
  case_2: /* CIL Label */ 
  {
#line 981
  ldv_dummy_resourceless_instance_callback_0_3(ldv_0_callback_close, ldv_0_container_struct_vm_area_struct_ptr);
  }
#line 988
  goto ldv_call_0;
#line 990
  goto ldv_call_0;
  case_3: /* CIL Label */ ;
#line 999
  return;
  switch_default: /* CIL Label */ 
  {
#line 1002
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1005
  return;
}
}
#line 1010 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
void ldv_v4l2_file_operations_io_instance_1(void *arg0 ) 
{ 
  void (*ldv_1_callback_func_1_ptr)(struct video_device * ) ;
  int (*ldv_1_callback_mmap)(struct file * , struct vm_area_struct * ) ;
  unsigned int (*ldv_1_callback_poll)(struct file * , struct poll_table_struct * ) ;
  long (*ldv_1_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  long (*ldv_1_callback_unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
  int (*ldv_1_callback_vidioc_dqbuf)(struct file * , void * , struct v4l2_buffer * ) ;
  int (*ldv_1_callback_vidioc_enum_fmt_vid_cap)(struct file * , void * , struct v4l2_fmtdesc * ) ;
  int (*ldv_1_callback_vidioc_enum_frameintervals)(struct file * , void * , struct v4l2_frmivalenum * ) ;
  int (*ldv_1_callback_vidioc_enum_framesizes)(struct file * , void * , struct v4l2_frmsizeenum * ) ;
  int (*ldv_1_callback_vidioc_enum_input)(struct file * , void * , struct v4l2_input * ) ;
  int (*ldv_1_callback_vidioc_g_chip_info)(struct file * , void * , struct v4l2_dbg_chip_info * ) ;
  int (*ldv_1_callback_vidioc_g_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
  int (*ldv_1_callback_vidioc_g_input)(struct file * , void * , unsigned int * ) ;
  int (*ldv_1_callback_vidioc_g_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
  int (*ldv_1_callback_vidioc_g_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
  int (*ldv_1_callback_vidioc_g_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
  int (*ldv_1_callback_vidioc_qbuf)(struct file * , void * , struct v4l2_buffer * ) ;
  int (*ldv_1_callback_vidioc_querybuf)(struct file * , void * , struct v4l2_buffer * ) ;
  int (*ldv_1_callback_vidioc_querycap)(struct file * , void * , struct v4l2_capability * ) ;
  int (*ldv_1_callback_vidioc_reqbufs)(struct file * , void * , struct v4l2_requestbuffers * ) ;
  int (*ldv_1_callback_vidioc_s_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
  int (*ldv_1_callback_vidioc_s_input)(struct file * , void * , unsigned int  ) ;
  int (*ldv_1_callback_vidioc_s_jpegcomp)(struct file * , void * , struct v4l2_jpegcompression * ) ;
  int (*ldv_1_callback_vidioc_s_parm)(struct file * , void * , struct v4l2_streamparm * ) ;
  int (*ldv_1_callback_vidioc_s_register)(struct file * , void * , struct v4l2_dbg_register * ) ;
  int (*ldv_1_callback_vidioc_streamoff)(struct file * , void * , enum v4l2_buf_type  ) ;
  int (*ldv_1_callback_vidioc_streamon)(struct file * , void * , enum v4l2_buf_type  ) ;
  int (*ldv_1_callback_vidioc_subscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription * ) ;
  int (*ldv_1_callback_vidioc_try_fmt_vid_cap)(struct file * , void * , struct v4l2_format * ) ;
  int (*ldv_1_callback_vidioc_unsubscribe_event)(struct v4l2_fh * , struct v4l2_event_subscription * ) ;
  struct v4l2_file_operations *ldv_1_container_v4l2_file_operations ;
  char *ldv_1_ldv_param_19_1_default ;
  unsigned long ldv_1_ldv_param_19_2_default ;
  long long *ldv_1_ldv_param_19_3_default ;
  unsigned int ldv_1_ldv_param_22_1_default ;
  unsigned long ldv_1_ldv_param_22_2_default ;
  unsigned int *ldv_1_ldv_param_32_2_default ;
  unsigned int ldv_1_ldv_param_43_2_default ;
  enum v4l2_buf_type ldv_1_resource_enum_v4l2_buf_type ;
  struct file *ldv_1_resource_file ;
  struct poll_table_struct *ldv_1_resource_struct_poll_table_struct_ptr ;
  struct v4l2_buffer *ldv_1_resource_struct_v4l2_buffer_ptr ;
  struct v4l2_capability *ldv_1_resource_struct_v4l2_capability_ptr ;
  struct v4l2_dbg_chip_info *ldv_1_resource_struct_v4l2_dbg_chip_info_ptr ;
  struct v4l2_dbg_register *ldv_1_resource_struct_v4l2_dbg_register_ptr ;
  struct v4l2_event_subscription *ldv_1_resource_struct_v4l2_event_subscription_ptr ;
  struct v4l2_fh *ldv_1_resource_struct_v4l2_fh_ptr ;
  struct v4l2_fmtdesc *ldv_1_resource_struct_v4l2_fmtdesc_ptr ;
  struct v4l2_format *ldv_1_resource_struct_v4l2_format_ptr ;
  struct v4l2_frmivalenum *ldv_1_resource_struct_v4l2_frmivalenum_ptr ;
  struct v4l2_frmsizeenum *ldv_1_resource_struct_v4l2_frmsizeenum_ptr ;
  struct v4l2_input *ldv_1_resource_struct_v4l2_input_ptr ;
  struct v4l2_jpegcompression *ldv_1_resource_struct_v4l2_jpegcompression_ptr ;
  struct v4l2_requestbuffers *ldv_1_resource_struct_v4l2_requestbuffers_ptr ;
  struct v4l2_streamparm *ldv_1_resource_struct_v4l2_streamparm_ptr ;
  struct video_device *ldv_1_resource_struct_video_device ;
  struct vm_area_struct *ldv_1_resource_struct_vm_area_struct_ptr ;
  int ldv_1_ret_default ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;

  {
  {
#line 1073
  ldv_1_ret_default = 1;
#line 1078
  tmp = ldv_xmalloc(504UL);
#line 1078
  ldv_1_resource_file = (struct file *)tmp;
#line 1079
  tmp___0 = ldv_xmalloc(16UL);
#line 1079
  ldv_1_resource_struct_poll_table_struct_ptr = (struct poll_table_struct *)tmp___0;
#line 1080
  tmp___1 = ldv_xmalloc(88UL);
#line 1080
  ldv_1_resource_struct_v4l2_buffer_ptr = (struct v4l2_buffer *)tmp___1;
#line 1081
  tmp___2 = ldv_xmalloc(104UL);
#line 1081
  ldv_1_resource_struct_v4l2_capability_ptr = (struct v4l2_capability *)tmp___2;
#line 1082
  tmp___3 = ldv_xmalloc(200UL);
#line 1082
  ldv_1_resource_struct_v4l2_dbg_chip_info_ptr = (struct v4l2_dbg_chip_info *)tmp___3;
#line 1083
  tmp___4 = ldv_xmalloc(56UL);
#line 1083
  ldv_1_resource_struct_v4l2_dbg_register_ptr = (struct v4l2_dbg_register *)tmp___4;
#line 1084
  tmp___5 = ldv_xmalloc(32UL);
#line 1084
  ldv_1_resource_struct_v4l2_event_subscription_ptr = (struct v4l2_event_subscription *)tmp___5;
#line 1085
  tmp___6 = ldv_xmalloc(176UL);
#line 1085
  ldv_1_resource_struct_v4l2_fh_ptr = (struct v4l2_fh *)tmp___6;
#line 1086
  tmp___7 = ldv_xmalloc(64UL);
#line 1086
  ldv_1_resource_struct_v4l2_fmtdesc_ptr = (struct v4l2_fmtdesc *)tmp___7;
#line 1087
  tmp___8 = ldv_xmalloc(208UL);
#line 1087
  ldv_1_resource_struct_v4l2_format_ptr = (struct v4l2_format *)tmp___8;
#line 1088
  tmp___9 = ldv_xmalloc(52UL);
#line 1088
  ldv_1_resource_struct_v4l2_frmivalenum_ptr = (struct v4l2_frmivalenum *)tmp___9;
#line 1089
  tmp___10 = ldv_xmalloc(44UL);
#line 1089
  ldv_1_resource_struct_v4l2_frmsizeenum_ptr = (struct v4l2_frmsizeenum *)tmp___10;
#line 1090
  tmp___11 = ldv_xmalloc(80UL);
#line 1090
  ldv_1_resource_struct_v4l2_input_ptr = (struct v4l2_input *)tmp___11;
#line 1091
  tmp___12 = ldv_xmalloc(140UL);
#line 1091
  ldv_1_resource_struct_v4l2_jpegcompression_ptr = (struct v4l2_jpegcompression *)tmp___12;
#line 1092
  tmp___13 = ldv_xmalloc(20UL);
#line 1092
  ldv_1_resource_struct_v4l2_requestbuffers_ptr = (struct v4l2_requestbuffers *)tmp___13;
#line 1093
  tmp___14 = ldv_xmalloc(204UL);
#line 1093
  ldv_1_resource_struct_v4l2_streamparm_ptr = (struct v4l2_streamparm *)tmp___14;
#line 1094
  tmp___15 = ldv_xmalloc(1832UL);
#line 1094
  ldv_1_resource_struct_video_device = (struct video_device *)tmp___15;
#line 1095
  tmp___16 = ldv_xmalloc(184UL);
#line 1095
  ldv_1_resource_struct_vm_area_struct_ptr = (struct vm_area_struct *)tmp___16;
  }
#line 1102
  goto ldv_main_1;
#line 1104
  return;
  ldv_main_1: 
  {
#line 1110
  tmp___18 = ldv_undef_int();
  }
#line 1110
  if (tmp___18 != 0) {
    {
#line 1113
    ldv_1_ret_default = ldv_io_instance_probe_1_11(ldv_1_container_v4l2_file_operations->open,
                                                   ldv_1_resource_file);
#line 1115
    ldv_1_ret_default = ldv_filter_err_code(ldv_1_ret_default);
#line 1118
    tmp___17 = ldv_undef_int();
    }
#line 1118
    if (tmp___17 != 0) {
      {
#line 1120
      ldv_assume(ldv_1_ret_default == 0);
      }
#line 1127
      goto ldv_call_1;
    } else {
      {
#line 1131
      ldv_assume(ldv_1_ret_default != 0);
      }
#line 1138
      goto ldv_main_1;
    }
  } else {
    {
#line 1143
    ldv_free((void *)ldv_1_resource_file);
#line 1144
    ldv_free((void *)ldv_1_resource_struct_poll_table_struct_ptr);
#line 1145
    ldv_free((void *)ldv_1_resource_struct_v4l2_buffer_ptr);
#line 1146
    ldv_free((void *)ldv_1_resource_struct_v4l2_capability_ptr);
#line 1147
    ldv_free((void *)ldv_1_resource_struct_v4l2_dbg_chip_info_ptr);
#line 1148
    ldv_free((void *)ldv_1_resource_struct_v4l2_dbg_register_ptr);
#line 1149
    ldv_free((void *)ldv_1_resource_struct_v4l2_event_subscription_ptr);
#line 1150
    ldv_free((void *)ldv_1_resource_struct_v4l2_fh_ptr);
#line 1151
    ldv_free((void *)ldv_1_resource_struct_v4l2_fmtdesc_ptr);
#line 1152
    ldv_free((void *)ldv_1_resource_struct_v4l2_format_ptr);
#line 1153
    ldv_free((void *)ldv_1_resource_struct_v4l2_frmivalenum_ptr);
#line 1154
    ldv_free((void *)ldv_1_resource_struct_v4l2_frmsizeenum_ptr);
#line 1155
    ldv_free((void *)ldv_1_resource_struct_v4l2_input_ptr);
#line 1156
    ldv_free((void *)ldv_1_resource_struct_v4l2_jpegcompression_ptr);
#line 1157
    ldv_free((void *)ldv_1_resource_struct_v4l2_requestbuffers_ptr);
#line 1158
    ldv_free((void *)ldv_1_resource_struct_v4l2_streamparm_ptr);
#line 1159
    ldv_free((void *)ldv_1_resource_struct_video_device);
#line 1160
    ldv_free((void *)ldv_1_resource_struct_vm_area_struct_ptr);
    }
#line 1168
    return;
  }
#line 1171
  return;
  ldv_call_1: 
  {
#line 1177
  tmp___19 = ldv_undef_int();
  }
  {
#line 1178
  if (tmp___19 == 1) {
#line 1178
    goto case_1;
  } else {

  }
#line 1191
  if (tmp___19 == 2) {
#line 1191
    goto case_2;
  } else {

  }
#line 1206
  if (tmp___19 == 3) {
#line 1206
    goto case_3;
  } else {

  }
#line 1223
  if (tmp___19 == 4) {
#line 1223
    goto case_4;
  } else {

  }
#line 1242
  if (tmp___19 == 5) {
#line 1242
    goto case_5;
  } else {

  }
#line 1263
  if (tmp___19 == 6) {
#line 1263
    goto case_6;
  } else {

  }
#line 1286
  if (tmp___19 == 7) {
#line 1286
    goto case_7;
  } else {

  }
#line 1311
  if (tmp___19 == 8) {
#line 1311
    goto case_8;
  } else {

  }
#line 1338
  if (tmp___19 == 9) {
#line 1338
    goto case_9;
  } else {

  }
#line 1373
  if (tmp___19 == 10) {
#line 1373
    goto case_10;
  } else {

  }
#line 1404
  if (tmp___19 == 11) {
#line 1404
    goto case_11;
  } else {

  }
#line 1437
  if (tmp___19 == 12) {
#line 1437
    goto case_12;
  } else {

  }
#line 1472
  if (tmp___19 == 13) {
#line 1472
    goto case_13;
  } else {

  }
#line 1509
  if (tmp___19 == 14) {
#line 1509
    goto case_14;
  } else {

  }
#line 1548
  if (tmp___19 == 15) {
#line 1548
    goto case_15;
  } else {

  }
#line 1589
  if (tmp___19 == 16) {
#line 1589
    goto case_16;
  } else {

  }
#line 1632
  if (tmp___19 == 17) {
#line 1632
    goto case_17;
  } else {

  }
#line 1677
  if (tmp___19 == 18) {
#line 1677
    goto case_18;
  } else {

  }
#line 1732
  if (tmp___19 == 19) {
#line 1732
    goto case_19;
  } else {

  }
#line 1781
  if (tmp___19 == 20) {
#line 1781
    goto case_20;
  } else {

  }
#line 1832
  if (tmp___19 == 21) {
#line 1832
    goto case_21;
  } else {

  }
#line 1885
  if (tmp___19 == 22) {
#line 1885
    goto case_22;
  } else {

  }
#line 1940
  if (tmp___19 == 23) {
#line 1940
    goto case_23;
  } else {

  }
#line 1997
  if (tmp___19 == 24) {
#line 1997
    goto case_24;
  } else {

  }
#line 2056
  if (tmp___19 == 25) {
#line 2056
    goto case_25;
  } else {

  }
#line 2117
  if (tmp___19 == 26) {
#line 2117
    goto case_26;
  } else {

  }
#line 2186
  if (tmp___19 == 27) {
#line 2186
    goto case_27;
  } else {

  }
#line 2261
  if (tmp___19 == 28) {
#line 2261
    goto case_28;
  } else {

  }
#line 2328
  if (tmp___19 == 29) {
#line 2328
    goto case_29;
  } else {

  }
#line 2397
  if (tmp___19 == 30) {
#line 2397
    goto case_30;
  } else {

  }
#line 2468
  if (tmp___19 == 31) {
#line 2468
    goto case_31;
  } else {

  }
#line 2481
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1181
  ldv_io_instance_callback_1_53(ldv_1_callback_vidioc_unsubscribe_event, ldv_1_resource_struct_v4l2_fh_ptr,
                                ldv_1_resource_struct_v4l2_event_subscription_ptr);
  }
#line 1188
  goto ldv_call_1;
  case_2: /* CIL Label */ 
  {
#line 1194
  ldv_io_instance_callback_1_52(ldv_1_callback_vidioc_try_fmt_vid_cap, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_format_ptr);
  }
#line 1201
  goto ldv_call_1;
#line 1203
  goto ldv_call_1;
  case_3: /* CIL Label */ 
  {
#line 1209
  ldv_io_instance_callback_1_51(ldv_1_callback_vidioc_subscribe_event, ldv_1_resource_struct_v4l2_fh_ptr,
                                ldv_1_resource_struct_v4l2_event_subscription_ptr);
  }
#line 1216
  goto ldv_call_1;
#line 1218
  goto ldv_call_1;
#line 1220
  goto ldv_call_1;
  case_4: /* CIL Label */ 
  {
#line 1226
  ldv_io_instance_callback_1_50(ldv_1_callback_vidioc_streamon, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_enum_v4l2_buf_type);
  }
#line 1233
  goto ldv_call_1;
#line 1235
  goto ldv_call_1;
#line 1237
  goto ldv_call_1;
#line 1239
  goto ldv_call_1;
  case_5: /* CIL Label */ 
  {
#line 1245
  ldv_io_instance_callback_1_49(ldv_1_callback_vidioc_streamoff, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_enum_v4l2_buf_type);
  }
#line 1252
  goto ldv_call_1;
#line 1254
  goto ldv_call_1;
#line 1256
  goto ldv_call_1;
#line 1258
  goto ldv_call_1;
#line 1260
  goto ldv_call_1;
  case_6: /* CIL Label */ 
  {
#line 1266
  ldv_io_instance_callback_1_48(ldv_1_callback_vidioc_s_register, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_dbg_register_ptr);
  }
#line 1273
  goto ldv_call_1;
#line 1275
  goto ldv_call_1;
#line 1277
  goto ldv_call_1;
#line 1279
  goto ldv_call_1;
#line 1281
  goto ldv_call_1;
#line 1283
  goto ldv_call_1;
  case_7: /* CIL Label */ 
  {
#line 1289
  ldv_io_instance_callback_1_47(ldv_1_callback_vidioc_s_parm, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_streamparm_ptr);
  }
#line 1296
  goto ldv_call_1;
#line 1298
  goto ldv_call_1;
#line 1300
  goto ldv_call_1;
#line 1302
  goto ldv_call_1;
#line 1304
  goto ldv_call_1;
#line 1306
  goto ldv_call_1;
#line 1308
  goto ldv_call_1;
  case_8: /* CIL Label */ 
  {
#line 1314
  ldv_io_instance_callback_1_46(ldv_1_callback_vidioc_s_jpegcomp, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_jpegcompression_ptr);
  }
#line 1321
  goto ldv_call_1;
#line 1323
  goto ldv_call_1;
#line 1325
  goto ldv_call_1;
#line 1327
  goto ldv_call_1;
#line 1329
  goto ldv_call_1;
#line 1331
  goto ldv_call_1;
#line 1333
  goto ldv_call_1;
#line 1335
  goto ldv_call_1;
  case_9: /* CIL Label */ 
  {
#line 1344
  ldv_io_instance_callback_1_43(ldv_1_callback_vidioc_s_input, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_ldv_param_43_2_default);
  }
#line 1354
  goto ldv_call_1;
#line 1356
  goto ldv_call_1;
#line 1358
  goto ldv_call_1;
#line 1360
  goto ldv_call_1;
#line 1362
  goto ldv_call_1;
#line 1364
  goto ldv_call_1;
#line 1366
  goto ldv_call_1;
#line 1368
  goto ldv_call_1;
#line 1370
  goto ldv_call_1;
  case_10: /* CIL Label */ 
  {
#line 1376
  ldv_io_instance_callback_1_42(ldv_1_callback_vidioc_s_fmt_vid_cap, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_format_ptr);
  }
#line 1383
  goto ldv_call_1;
#line 1385
  goto ldv_call_1;
#line 1387
  goto ldv_call_1;
#line 1389
  goto ldv_call_1;
#line 1391
  goto ldv_call_1;
#line 1393
  goto ldv_call_1;
#line 1395
  goto ldv_call_1;
#line 1397
  goto ldv_call_1;
#line 1399
  goto ldv_call_1;
#line 1401
  goto ldv_call_1;
  case_11: /* CIL Label */ 
  {
#line 1407
  ldv_io_instance_callback_1_41(ldv_1_callback_vidioc_reqbufs, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_requestbuffers_ptr);
  }
#line 1414
  goto ldv_call_1;
#line 1416
  goto ldv_call_1;
#line 1418
  goto ldv_call_1;
#line 1420
  goto ldv_call_1;
#line 1422
  goto ldv_call_1;
#line 1424
  goto ldv_call_1;
#line 1426
  goto ldv_call_1;
#line 1428
  goto ldv_call_1;
#line 1430
  goto ldv_call_1;
#line 1432
  goto ldv_call_1;
#line 1434
  goto ldv_call_1;
  case_12: /* CIL Label */ 
  {
#line 1440
  ldv_io_instance_callback_1_40(ldv_1_callback_vidioc_querycap, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_capability_ptr);
  }
#line 1447
  goto ldv_call_1;
#line 1449
  goto ldv_call_1;
#line 1451
  goto ldv_call_1;
#line 1453
  goto ldv_call_1;
#line 1455
  goto ldv_call_1;
#line 1457
  goto ldv_call_1;
#line 1459
  goto ldv_call_1;
#line 1461
  goto ldv_call_1;
#line 1463
  goto ldv_call_1;
#line 1465
  goto ldv_call_1;
#line 1467
  goto ldv_call_1;
#line 1469
  goto ldv_call_1;
  case_13: /* CIL Label */ 
  {
#line 1475
  ldv_io_instance_callback_1_39(ldv_1_callback_vidioc_querybuf, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_buffer_ptr);
  }
#line 1482
  goto ldv_call_1;
#line 1484
  goto ldv_call_1;
#line 1486
  goto ldv_call_1;
#line 1488
  goto ldv_call_1;
#line 1490
  goto ldv_call_1;
#line 1492
  goto ldv_call_1;
#line 1494
  goto ldv_call_1;
#line 1496
  goto ldv_call_1;
#line 1498
  goto ldv_call_1;
#line 1500
  goto ldv_call_1;
#line 1502
  goto ldv_call_1;
#line 1504
  goto ldv_call_1;
#line 1506
  goto ldv_call_1;
  case_14: /* CIL Label */ 
  {
#line 1512
  ldv_io_instance_callback_1_38(ldv_1_callback_vidioc_qbuf, ldv_1_resource_file, (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_buffer_ptr);
  }
#line 1519
  goto ldv_call_1;
#line 1521
  goto ldv_call_1;
#line 1523
  goto ldv_call_1;
#line 1525
  goto ldv_call_1;
#line 1527
  goto ldv_call_1;
#line 1529
  goto ldv_call_1;
#line 1531
  goto ldv_call_1;
#line 1533
  goto ldv_call_1;
#line 1535
  goto ldv_call_1;
#line 1537
  goto ldv_call_1;
#line 1539
  goto ldv_call_1;
#line 1541
  goto ldv_call_1;
#line 1543
  goto ldv_call_1;
#line 1545
  goto ldv_call_1;
  case_15: /* CIL Label */ 
  {
#line 1551
  ldv_io_instance_callback_1_37(ldv_1_callback_vidioc_g_register, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_dbg_register_ptr);
  }
#line 1558
  goto ldv_call_1;
#line 1560
  goto ldv_call_1;
#line 1562
  goto ldv_call_1;
#line 1564
  goto ldv_call_1;
#line 1566
  goto ldv_call_1;
#line 1568
  goto ldv_call_1;
#line 1570
  goto ldv_call_1;
#line 1572
  goto ldv_call_1;
#line 1574
  goto ldv_call_1;
#line 1576
  goto ldv_call_1;
#line 1578
  goto ldv_call_1;
#line 1580
  goto ldv_call_1;
#line 1582
  goto ldv_call_1;
#line 1584
  goto ldv_call_1;
#line 1586
  goto ldv_call_1;
  case_16: /* CIL Label */ 
  {
#line 1592
  ldv_io_instance_callback_1_36(ldv_1_callback_vidioc_g_parm, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_streamparm_ptr);
  }
#line 1599
  goto ldv_call_1;
#line 1601
  goto ldv_call_1;
#line 1603
  goto ldv_call_1;
#line 1605
  goto ldv_call_1;
#line 1607
  goto ldv_call_1;
#line 1609
  goto ldv_call_1;
#line 1611
  goto ldv_call_1;
#line 1613
  goto ldv_call_1;
#line 1615
  goto ldv_call_1;
#line 1617
  goto ldv_call_1;
#line 1619
  goto ldv_call_1;
#line 1621
  goto ldv_call_1;
#line 1623
  goto ldv_call_1;
#line 1625
  goto ldv_call_1;
#line 1627
  goto ldv_call_1;
#line 1629
  goto ldv_call_1;
  case_17: /* CIL Label */ 
  {
#line 1635
  ldv_io_instance_callback_1_35(ldv_1_callback_vidioc_g_jpegcomp, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_jpegcompression_ptr);
  }
#line 1642
  goto ldv_call_1;
#line 1644
  goto ldv_call_1;
#line 1646
  goto ldv_call_1;
#line 1648
  goto ldv_call_1;
#line 1650
  goto ldv_call_1;
#line 1652
  goto ldv_call_1;
#line 1654
  goto ldv_call_1;
#line 1656
  goto ldv_call_1;
#line 1658
  goto ldv_call_1;
#line 1660
  goto ldv_call_1;
#line 1662
  goto ldv_call_1;
#line 1664
  goto ldv_call_1;
#line 1666
  goto ldv_call_1;
#line 1668
  goto ldv_call_1;
#line 1670
  goto ldv_call_1;
#line 1672
  goto ldv_call_1;
#line 1674
  goto ldv_call_1;
  case_18: /* CIL Label */ 
  {
#line 1679
  tmp___20 = ldv_xmalloc(4UL);
#line 1679
  ldv_1_ldv_param_32_2_default = (unsigned int *)tmp___20;
#line 1684
  ldv_io_instance_callback_1_32(ldv_1_callback_vidioc_g_input, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_ldv_param_32_2_default);
#line 1688
  ldv_free((void *)ldv_1_ldv_param_32_2_default);
  }
#line 1695
  goto ldv_call_1;
#line 1697
  goto ldv_call_1;
#line 1699
  goto ldv_call_1;
#line 1701
  goto ldv_call_1;
#line 1703
  goto ldv_call_1;
#line 1705
  goto ldv_call_1;
#line 1707
  goto ldv_call_1;
#line 1709
  goto ldv_call_1;
#line 1711
  goto ldv_call_1;
#line 1713
  goto ldv_call_1;
#line 1715
  goto ldv_call_1;
#line 1717
  goto ldv_call_1;
#line 1719
  goto ldv_call_1;
#line 1721
  goto ldv_call_1;
#line 1723
  goto ldv_call_1;
#line 1725
  goto ldv_call_1;
#line 1727
  goto ldv_call_1;
#line 1729
  goto ldv_call_1;
  case_19: /* CIL Label */ 
  {
#line 1735
  ldv_io_instance_callback_1_31(ldv_1_callback_vidioc_g_fmt_vid_cap, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_format_ptr);
  }
#line 1742
  goto ldv_call_1;
#line 1744
  goto ldv_call_1;
#line 1746
  goto ldv_call_1;
#line 1748
  goto ldv_call_1;
#line 1750
  goto ldv_call_1;
#line 1752
  goto ldv_call_1;
#line 1754
  goto ldv_call_1;
#line 1756
  goto ldv_call_1;
#line 1758
  goto ldv_call_1;
#line 1760
  goto ldv_call_1;
#line 1762
  goto ldv_call_1;
#line 1764
  goto ldv_call_1;
#line 1766
  goto ldv_call_1;
#line 1768
  goto ldv_call_1;
#line 1770
  goto ldv_call_1;
#line 1772
  goto ldv_call_1;
#line 1774
  goto ldv_call_1;
#line 1776
  goto ldv_call_1;
#line 1778
  goto ldv_call_1;
  case_20: /* CIL Label */ 
  {
#line 1784
  ldv_io_instance_callback_1_30(ldv_1_callback_vidioc_g_chip_info, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_dbg_chip_info_ptr);
  }
#line 1791
  goto ldv_call_1;
#line 1793
  goto ldv_call_1;
#line 1795
  goto ldv_call_1;
#line 1797
  goto ldv_call_1;
#line 1799
  goto ldv_call_1;
#line 1801
  goto ldv_call_1;
#line 1803
  goto ldv_call_1;
#line 1805
  goto ldv_call_1;
#line 1807
  goto ldv_call_1;
#line 1809
  goto ldv_call_1;
#line 1811
  goto ldv_call_1;
#line 1813
  goto ldv_call_1;
#line 1815
  goto ldv_call_1;
#line 1817
  goto ldv_call_1;
#line 1819
  goto ldv_call_1;
#line 1821
  goto ldv_call_1;
#line 1823
  goto ldv_call_1;
#line 1825
  goto ldv_call_1;
#line 1827
  goto ldv_call_1;
#line 1829
  goto ldv_call_1;
  case_21: /* CIL Label */ 
  {
#line 1835
  ldv_io_instance_callback_1_29(ldv_1_callback_vidioc_enum_input, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_input_ptr);
  }
#line 1842
  goto ldv_call_1;
#line 1844
  goto ldv_call_1;
#line 1846
  goto ldv_call_1;
#line 1848
  goto ldv_call_1;
#line 1850
  goto ldv_call_1;
#line 1852
  goto ldv_call_1;
#line 1854
  goto ldv_call_1;
#line 1856
  goto ldv_call_1;
#line 1858
  goto ldv_call_1;
#line 1860
  goto ldv_call_1;
#line 1862
  goto ldv_call_1;
#line 1864
  goto ldv_call_1;
#line 1866
  goto ldv_call_1;
#line 1868
  goto ldv_call_1;
#line 1870
  goto ldv_call_1;
#line 1872
  goto ldv_call_1;
#line 1874
  goto ldv_call_1;
#line 1876
  goto ldv_call_1;
#line 1878
  goto ldv_call_1;
#line 1880
  goto ldv_call_1;
#line 1882
  goto ldv_call_1;
  case_22: /* CIL Label */ 
  {
#line 1888
  ldv_io_instance_callback_1_28(ldv_1_callback_vidioc_enum_framesizes, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_frmsizeenum_ptr);
  }
#line 1895
  goto ldv_call_1;
#line 1897
  goto ldv_call_1;
#line 1899
  goto ldv_call_1;
#line 1901
  goto ldv_call_1;
#line 1903
  goto ldv_call_1;
#line 1905
  goto ldv_call_1;
#line 1907
  goto ldv_call_1;
#line 1909
  goto ldv_call_1;
#line 1911
  goto ldv_call_1;
#line 1913
  goto ldv_call_1;
#line 1915
  goto ldv_call_1;
#line 1917
  goto ldv_call_1;
#line 1919
  goto ldv_call_1;
#line 1921
  goto ldv_call_1;
#line 1923
  goto ldv_call_1;
#line 1925
  goto ldv_call_1;
#line 1927
  goto ldv_call_1;
#line 1929
  goto ldv_call_1;
#line 1931
  goto ldv_call_1;
#line 1933
  goto ldv_call_1;
#line 1935
  goto ldv_call_1;
#line 1937
  goto ldv_call_1;
  case_23: /* CIL Label */ 
  {
#line 1943
  ldv_io_instance_callback_1_27(ldv_1_callback_vidioc_enum_frameintervals, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_frmivalenum_ptr);
  }
#line 1950
  goto ldv_call_1;
#line 1952
  goto ldv_call_1;
#line 1954
  goto ldv_call_1;
#line 1956
  goto ldv_call_1;
#line 1958
  goto ldv_call_1;
#line 1960
  goto ldv_call_1;
#line 1962
  goto ldv_call_1;
#line 1964
  goto ldv_call_1;
#line 1966
  goto ldv_call_1;
#line 1968
  goto ldv_call_1;
#line 1970
  goto ldv_call_1;
#line 1972
  goto ldv_call_1;
#line 1974
  goto ldv_call_1;
#line 1976
  goto ldv_call_1;
#line 1978
  goto ldv_call_1;
#line 1980
  goto ldv_call_1;
#line 1982
  goto ldv_call_1;
#line 1984
  goto ldv_call_1;
#line 1986
  goto ldv_call_1;
#line 1988
  goto ldv_call_1;
#line 1990
  goto ldv_call_1;
#line 1992
  goto ldv_call_1;
#line 1994
  goto ldv_call_1;
  case_24: /* CIL Label */ 
  {
#line 2000
  ldv_io_instance_callback_1_26(ldv_1_callback_vidioc_enum_fmt_vid_cap, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_fmtdesc_ptr);
  }
#line 2007
  goto ldv_call_1;
#line 2009
  goto ldv_call_1;
#line 2011
  goto ldv_call_1;
#line 2013
  goto ldv_call_1;
#line 2015
  goto ldv_call_1;
#line 2017
  goto ldv_call_1;
#line 2019
  goto ldv_call_1;
#line 2021
  goto ldv_call_1;
#line 2023
  goto ldv_call_1;
#line 2025
  goto ldv_call_1;
#line 2027
  goto ldv_call_1;
#line 2029
  goto ldv_call_1;
#line 2031
  goto ldv_call_1;
#line 2033
  goto ldv_call_1;
#line 2035
  goto ldv_call_1;
#line 2037
  goto ldv_call_1;
#line 2039
  goto ldv_call_1;
#line 2041
  goto ldv_call_1;
#line 2043
  goto ldv_call_1;
#line 2045
  goto ldv_call_1;
#line 2047
  goto ldv_call_1;
#line 2049
  goto ldv_call_1;
#line 2051
  goto ldv_call_1;
#line 2053
  goto ldv_call_1;
  case_25: /* CIL Label */ 
  {
#line 2059
  ldv_io_instance_callback_1_25(ldv_1_callback_vidioc_dqbuf, ldv_1_resource_file,
                                (void *)ldv_1_resource_struct_poll_table_struct_ptr,
                                ldv_1_resource_struct_v4l2_buffer_ptr);
  }
#line 2066
  goto ldv_call_1;
#line 2068
  goto ldv_call_1;
#line 2070
  goto ldv_call_1;
#line 2072
  goto ldv_call_1;
#line 2074
  goto ldv_call_1;
#line 2076
  goto ldv_call_1;
#line 2078
  goto ldv_call_1;
#line 2080
  goto ldv_call_1;
#line 2082
  goto ldv_call_1;
#line 2084
  goto ldv_call_1;
#line 2086
  goto ldv_call_1;
#line 2088
  goto ldv_call_1;
#line 2090
  goto ldv_call_1;
#line 2092
  goto ldv_call_1;
#line 2094
  goto ldv_call_1;
#line 2096
  goto ldv_call_1;
#line 2098
  goto ldv_call_1;
#line 2100
  goto ldv_call_1;
#line 2102
  goto ldv_call_1;
#line 2104
  goto ldv_call_1;
#line 2106
  goto ldv_call_1;
#line 2108
  goto ldv_call_1;
#line 2110
  goto ldv_call_1;
#line 2112
  goto ldv_call_1;
#line 2114
  goto ldv_call_1;
  case_26: /* CIL Label */ 
  {
#line 2123
  ldv_io_instance_callback_1_22(ldv_1_callback_unlocked_ioctl, ldv_1_resource_file,
                                ldv_1_ldv_param_22_1_default, ldv_1_ldv_param_22_2_default);
  }
#line 2133
  goto ldv_call_1;
#line 2135
  goto ldv_call_1;
#line 2137
  goto ldv_call_1;
#line 2139
  goto ldv_call_1;
#line 2141
  goto ldv_call_1;
#line 2143
  goto ldv_call_1;
#line 2145
  goto ldv_call_1;
#line 2147
  goto ldv_call_1;
#line 2149
  goto ldv_call_1;
#line 2151
  goto ldv_call_1;
#line 2153
  goto ldv_call_1;
#line 2155
  goto ldv_call_1;
#line 2157
  goto ldv_call_1;
#line 2159
  goto ldv_call_1;
#line 2161
  goto ldv_call_1;
#line 2163
  goto ldv_call_1;
#line 2165
  goto ldv_call_1;
#line 2167
  goto ldv_call_1;
#line 2169
  goto ldv_call_1;
#line 2171
  goto ldv_call_1;
#line 2173
  goto ldv_call_1;
#line 2175
  goto ldv_call_1;
#line 2177
  goto ldv_call_1;
#line 2179
  goto ldv_call_1;
#line 2181
  goto ldv_call_1;
#line 2183
  goto ldv_call_1;
  case_27: /* CIL Label */ 
  {
#line 2188
  tmp___21 = ldv_xmalloc(1UL);
#line 2188
  ldv_1_ldv_param_19_1_default = (char *)tmp___21;
#line 2189
  tmp___22 = ldv_xmalloc(8UL);
#line 2189
  ldv_1_ldv_param_19_3_default = (long long *)tmp___22;
#line 2194
  ldv_io_instance_callback_1_19(ldv_1_callback_read, ldv_1_resource_file, ldv_1_ldv_param_19_1_default,
                                ldv_1_ldv_param_19_2_default, ldv_1_ldv_param_19_3_default);
#line 2198
  ldv_free((void *)ldv_1_ldv_param_19_1_default);
#line 2199
  ldv_free((void *)ldv_1_ldv_param_19_3_default);
  }
#line 2206
  goto ldv_call_1;
#line 2208
  goto ldv_call_1;
#line 2210
  goto ldv_call_1;
#line 2212
  goto ldv_call_1;
#line 2214
  goto ldv_call_1;
#line 2216
  goto ldv_call_1;
#line 2218
  goto ldv_call_1;
#line 2220
  goto ldv_call_1;
#line 2222
  goto ldv_call_1;
#line 2224
  goto ldv_call_1;
#line 2226
  goto ldv_call_1;
#line 2228
  goto ldv_call_1;
#line 2230
  goto ldv_call_1;
#line 2232
  goto ldv_call_1;
#line 2234
  goto ldv_call_1;
#line 2236
  goto ldv_call_1;
#line 2238
  goto ldv_call_1;
#line 2240
  goto ldv_call_1;
#line 2242
  goto ldv_call_1;
#line 2244
  goto ldv_call_1;
#line 2246
  goto ldv_call_1;
#line 2248
  goto ldv_call_1;
#line 2250
  goto ldv_call_1;
#line 2252
  goto ldv_call_1;
#line 2254
  goto ldv_call_1;
#line 2256
  goto ldv_call_1;
#line 2258
  goto ldv_call_1;
  case_28: /* CIL Label */ 
  {
#line 2264
  ldv_io_instance_callback_1_18(ldv_1_callback_poll, ldv_1_resource_file, ldv_1_resource_struct_poll_table_struct_ptr);
  }
#line 2271
  goto ldv_call_1;
#line 2273
  goto ldv_call_1;
#line 2275
  goto ldv_call_1;
#line 2277
  goto ldv_call_1;
#line 2279
  goto ldv_call_1;
#line 2281
  goto ldv_call_1;
#line 2283
  goto ldv_call_1;
#line 2285
  goto ldv_call_1;
#line 2287
  goto ldv_call_1;
#line 2289
  goto ldv_call_1;
#line 2291
  goto ldv_call_1;
#line 2293
  goto ldv_call_1;
#line 2295
  goto ldv_call_1;
#line 2297
  goto ldv_call_1;
#line 2299
  goto ldv_call_1;
#line 2301
  goto ldv_call_1;
#line 2303
  goto ldv_call_1;
#line 2305
  goto ldv_call_1;
#line 2307
  goto ldv_call_1;
#line 2309
  goto ldv_call_1;
#line 2311
  goto ldv_call_1;
#line 2313
  goto ldv_call_1;
#line 2315
  goto ldv_call_1;
#line 2317
  goto ldv_call_1;
#line 2319
  goto ldv_call_1;
#line 2321
  goto ldv_call_1;
#line 2323
  goto ldv_call_1;
#line 2325
  goto ldv_call_1;
  case_29: /* CIL Label */ 
  {
#line 2331
  ldv_io_instance_callback_1_17(ldv_1_callback_mmap, ldv_1_resource_file, ldv_1_resource_struct_vm_area_struct_ptr);
  }
#line 2338
  goto ldv_call_1;
#line 2340
  goto ldv_call_1;
#line 2342
  goto ldv_call_1;
#line 2344
  goto ldv_call_1;
#line 2346
  goto ldv_call_1;
#line 2348
  goto ldv_call_1;
#line 2350
  goto ldv_call_1;
#line 2352
  goto ldv_call_1;
#line 2354
  goto ldv_call_1;
#line 2356
  goto ldv_call_1;
#line 2358
  goto ldv_call_1;
#line 2360
  goto ldv_call_1;
#line 2362
  goto ldv_call_1;
#line 2364
  goto ldv_call_1;
#line 2366
  goto ldv_call_1;
#line 2368
  goto ldv_call_1;
#line 2370
  goto ldv_call_1;
#line 2372
  goto ldv_call_1;
#line 2374
  goto ldv_call_1;
#line 2376
  goto ldv_call_1;
#line 2378
  goto ldv_call_1;
#line 2380
  goto ldv_call_1;
#line 2382
  goto ldv_call_1;
#line 2384
  goto ldv_call_1;
#line 2386
  goto ldv_call_1;
#line 2388
  goto ldv_call_1;
#line 2390
  goto ldv_call_1;
#line 2392
  goto ldv_call_1;
#line 2394
  goto ldv_call_1;
  case_30: /* CIL Label */ 
  {
#line 2400
  ldv_io_instance_callback_1_4(ldv_1_callback_func_1_ptr, ldv_1_resource_struct_video_device);
  }
#line 2407
  goto ldv_call_1;
#line 2409
  goto ldv_call_1;
#line 2411
  goto ldv_call_1;
#line 2413
  goto ldv_call_1;
#line 2415
  goto ldv_call_1;
#line 2417
  goto ldv_call_1;
#line 2419
  goto ldv_call_1;
#line 2421
  goto ldv_call_1;
#line 2423
  goto ldv_call_1;
#line 2425
  goto ldv_call_1;
#line 2427
  goto ldv_call_1;
#line 2429
  goto ldv_call_1;
#line 2431
  goto ldv_call_1;
#line 2433
  goto ldv_call_1;
#line 2435
  goto ldv_call_1;
#line 2437
  goto ldv_call_1;
#line 2439
  goto ldv_call_1;
#line 2441
  goto ldv_call_1;
#line 2443
  goto ldv_call_1;
#line 2445
  goto ldv_call_1;
#line 2447
  goto ldv_call_1;
#line 2449
  goto ldv_call_1;
#line 2451
  goto ldv_call_1;
#line 2453
  goto ldv_call_1;
#line 2455
  goto ldv_call_1;
#line 2457
  goto ldv_call_1;
#line 2459
  goto ldv_call_1;
#line 2461
  goto ldv_call_1;
#line 2463
  goto ldv_call_1;
#line 2465
  goto ldv_call_1;
  case_31: /* CIL Label */ 
  {
#line 2471
  ldv_io_instance_release_1_2(ldv_1_container_v4l2_file_operations->release, ldv_1_resource_file);
  }
#line 2478
  goto ldv_main_1;
  switch_default: /* CIL Label */ 
  {
#line 2481
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2484
  return;
}
}
#line 3096 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 3100
  ldv_check_alloc_flags(flags);
#line 3101
  res = ldv_malloc_unknown_size();
#line 3102
  ldv_after_alloc(res);
  }
#line 3103
  return (res);
}
}
#line 3147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3150
  tmp = ldv_kzalloc(size, flags);
  }
#line 3150
  return (tmp);
}
}
#line 3185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_usb_submit_urb_97(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3188
  ldv_check_alloc_flags(flags);
#line 3189
  tmp = ldv_malloc_unknown_size();
  }
#line 3189
  return ((int )((long )tmp));
}
}
#line 3192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static struct urb *ldv_usb_alloc_urb_98(int ldv_func_arg1 , gfp_t flags ) 
{ 
  struct urb *res ;
  struct urb *tmp ;
  long tmp___0 ;

  {
  {
#line 3196
  tmp = ldv_linux_usb_urb_usb_alloc_urb();
#line 3196
  res = tmp;
#line 3198
  tmp___0 = ldv_is_err((void const   *)res);
#line 3198
  ldv_assume(tmp___0 == 0L);
#line 3202
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 3206
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 3210
  return (res);
}
}
#line 3214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void *ldv_usb_alloc_coherent_99(struct usb_device *ldv_func_arg1 , size_t ldv_func_arg2 ,
                                       gfp_t flags , dma_addr_t *ldv_func_arg4 ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 3218
  tmp = ldv_linux_usb_coherent_usb_alloc_coherent();
#line 3218
  res = tmp;
#line 3220
  tmp___0 = ldv_is_err((void const   *)res);
#line 3220
  ldv_assume(tmp___0 == 0L);
#line 3224
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 3228
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 3232
  return (res);
}
}
#line 3236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_usb_submit_urb_100(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3239
  ldv_check_alloc_flags(flags);
#line 3240
  tmp = ldv_malloc_unknown_size();
  }
#line 3240
  return ((int )((long )tmp));
}
}
#line 3243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_usb_free_coherent_101(struct usb_device *dev , size_t size , void *addr ,
                                      dma_addr_t dma ) 
{ 


  {
  {
#line 3246
  ldv_linux_usb_coherent_usb_free_coherent(addr);
  }
#line 3247
  return;
}
}
#line 3249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_usb_free_urb_102(struct urb *urb ) 
{ 


  {
  {
#line 3252
  ldv_linux_usb_urb_usb_free_urb(urb);
  }
#line 3253
  return;
}
}
#line 3255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_usb_free_coherent_103(struct usb_device *dev , size_t size , void *addr ,
                                      dma_addr_t dma ) 
{ 


  {
  {
#line 3258
  ldv_linux_usb_coherent_usb_free_coherent(addr);
  }
#line 3259
  return;
}
}
#line 3261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_usb_free_urb_104(struct urb *urb ) 
{ 


  {
  {
#line 3264
  ldv_linux_usb_urb_usb_free_urb(urb);
  }
#line 3265
  return;
}
}
#line 3267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_usb_submit_urb_105(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3270
  ldv_check_alloc_flags(flags);
#line 3271
  tmp = ldv_malloc_unknown_size();
  }
#line 3271
  return ((int )((long )tmp));
}
}
#line 3274 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_usb_submit_urb_106(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3277
  ldv_check_alloc_flags(flags);
#line 3278
  tmp = ldv_malloc_unknown_size();
  }
#line 3278
  return ((int )((long )tmp));
}
}
#line 3281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void *ldv_vmalloc_32_107(unsigned long ldv_func_arg1 ) 
{ 
  void *tmp ;

  {
  {
#line 3284
  ldv_check_alloc_nonatomic();
#line 3285
  tmp = ldv_malloc_unknown_size();
  }
#line 3285
  return (tmp);
}
}
#line 3288 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_usb_free_coherent_108(struct usb_device *dev , size_t size , void *addr ,
                                      dma_addr_t dma ) 
{ 


  {
  {
#line 3291
  ldv_linux_usb_coherent_usb_free_coherent(addr);
  }
#line 3292
  return;
}
}
#line 3294 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_usb_free_urb_109(struct urb *urb ) 
{ 


  {
  {
#line 3297
  ldv_linux_usb_urb_usb_free_urb(urb);
  }
#line 3298
  return;
}
}
#line 3300 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static struct urb *ldv_usb_alloc_urb_110(int ldv_func_arg1 , gfp_t flags ) 
{ 
  struct urb *res ;
  struct urb *tmp ;
  long tmp___0 ;

  {
  {
#line 3304
  tmp = ldv_linux_usb_urb_usb_alloc_urb();
#line 3304
  res = tmp;
#line 3306
  tmp___0 = ldv_is_err((void const   *)res);
#line 3306
  ldv_assume(tmp___0 == 0L);
#line 3310
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 3314
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 3318
  return (res);
}
}
#line 3322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void *ldv_usb_alloc_coherent_111(struct usb_device *ldv_func_arg1 , size_t ldv_func_arg2 ,
                                        gfp_t flags , dma_addr_t *ldv_func_arg4 ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 3326
  tmp = ldv_linux_usb_coherent_usb_alloc_coherent();
#line 3326
  res = tmp;
#line 3328
  tmp___0 = ldv_is_err((void const   *)res);
#line 3328
  ldv_assume(tmp___0 == 0L);
#line 3332
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 3336
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 3340
  return (res);
}
}
#line 3344 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_usb_submit_urb_112(struct urb *ldv_func_arg1 , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 3347
  ldv_check_alloc_flags(flags);
#line 3348
  tmp = ldv_malloc_unknown_size();
  }
#line 3348
  return ((int )((long )tmp));
}
}
#line 3351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_113(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3355
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3355
  return (tmp);
}
}
#line 3358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_114(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3362
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3363
  return;
}
}
#line 3365 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static bool ldv_try_module_get_115(struct module *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3368
  tmp = ldv_linux_kernel_module_try_module_get(ldv_func_arg1);
  }
#line 3368
  return (tmp != 0);
}
}
#line 3371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_module_put_116(struct module *ldv_func_arg1 ) 
{ 


  {
  {
#line 3374
  ldv_linux_kernel_module_module_put(ldv_func_arg1);
  }
#line 3375
  return;
}
}
#line 3377 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_117(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3381
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3381
  return (tmp);
}
}
#line 3384 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_118(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3388
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3388
  return (tmp);
}
}
#line 3391 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_119(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3395
  ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3396
  return;
}
}
#line 3398 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_module_put_120(struct module *ldv_func_arg1 ) 
{ 


  {
  {
#line 3401
  ldv_linux_kernel_module_module_put(ldv_func_arg1);
  }
#line 3402
  return;
}
}
#line 3404 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3408
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3409
  return;
}
}
#line 3411 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3415
  ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3416
  return;
}
}
#line 3418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_123(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3422
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3422
  return (tmp);
}
}
#line 3425 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_124(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3429
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3430
  return;
}
}
#line 3432 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_125(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3436
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3436
  return (tmp);
}
}
#line 3439 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_126(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3443
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3444
  return;
}
}
#line 3446 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_127(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3450
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3450
  return (tmp);
}
}
#line 3453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_128(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3457
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3458
  return;
}
}
#line 3460 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_129(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3464
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3464
  return (tmp);
}
}
#line 3467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_130(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3471
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3472
  return;
}
}
#line 3474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_131(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3478
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3478
  return (tmp);
}
}
#line 3481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_132(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3485
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3486
  return;
}
}
#line 3488 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_133(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3492
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3492
  return (tmp);
}
}
#line 3495 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_134(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3499
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3500
  return;
}
}
#line 3502 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_135(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3506
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3506
  return (tmp);
}
}
#line 3509 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_136(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3513
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3514
  return;
}
}
#line 3516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_lock_137(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3520
  ldv_linux_kernel_locking_mutex_mutex_lock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3521
  return;
}
}
#line 3523 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3527
  ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3528
  return;
}
}
#line 3530 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_139(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3534
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3534
  return (tmp);
}
}
#line 3537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3541
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3542
  return;
}
}
#line 3544 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_141(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3548
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3548
  return (tmp);
}
}
#line 3551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3555
  ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3556
  return;
}
}
#line 3558 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_mutex_lock_interruptible_143(struct mutex *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3562
  tmp = ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3562
  return (tmp);
}
}
#line 3565 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3569
  ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3570
  return;
}
}
#line 3572 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_lock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3576
  ldv_linux_kernel_locking_mutex_mutex_lock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3577
  return;
}
}
#line 3579 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3583
  ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3584
  return;
}
}
#line 3586 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_lock_147(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3590
  ldv_linux_kernel_locking_mutex_mutex_lock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3591
  return;
}
}
#line 3593 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_148(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3597
  ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3598
  return;
}
}
#line 3600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_lock_149(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3604
  ldv_linux_kernel_locking_mutex_mutex_lock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3605
  return;
}
}
#line 3607 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_mutex_unlock_150(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3611
  ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(ldv_func_arg1);
  }
#line 3612
  return;
}
}
#line 3614 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static int ldv_ldv_post_init_151(int ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 3618
  ldv_linux_net_register_reset_error_counter();
#line 3622
  ldv_linux_usb_register_reset_error_counter();
#line 3625
  tmp = ldv_post_init(ldv_func_arg1);
  }
#line 3625
  return (tmp);
}
}
#line 3628 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_ldv_check_final_state_152(void) 
{ 


  {
  {
#line 3632
  ldv_linux_arch_io_check_final_state();
#line 3636
  ldv_linux_block_genhd_check_final_state();
#line 3640
  ldv_linux_block_queue_check_final_state();
#line 3644
  ldv_linux_block_request_check_final_state();
#line 3648
  ldv_linux_drivers_base_class_check_final_state();
#line 3656
  ldv_linux_fs_char_dev_check_final_state();
#line 3660
  ldv_linux_fs_sysfs_check_final_state();
#line 3664
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 3668
  ldv_linux_kernel_module_check_final_state();
#line 3672
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 3676
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 3680
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 3684
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 3688
  ldv_linux_lib_idr_check_final_state();
#line 3692
  ldv_linux_mmc_sdio_func_check_final_state();
#line 3696
  ldv_linux_net_rtnetlink_check_final_state();
#line 3700
  ldv_linux_net_sock_check_final_state();
#line 3704
  ldv_linux_usb_coherent_check_final_state();
#line 3708
  ldv_linux_usb_gadget_check_final_state();
#line 3712
  ldv_linux_usb_urb_check_final_state();
  }
#line 3713
  return;
}
}
#line 3716 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_ldv_check_final_state_153(void) 
{ 


  {
  {
#line 3720
  ldv_linux_arch_io_check_final_state();
#line 3724
  ldv_linux_block_genhd_check_final_state();
#line 3728
  ldv_linux_block_queue_check_final_state();
#line 3732
  ldv_linux_block_request_check_final_state();
#line 3736
  ldv_linux_drivers_base_class_check_final_state();
#line 3744
  ldv_linux_fs_char_dev_check_final_state();
#line 3748
  ldv_linux_fs_sysfs_check_final_state();
#line 3752
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 3756
  ldv_linux_kernel_module_check_final_state();
#line 3760
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 3764
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 3768
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 3772
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 3776
  ldv_linux_lib_idr_check_final_state();
#line 3780
  ldv_linux_mmc_sdio_func_check_final_state();
#line 3784
  ldv_linux_net_rtnetlink_check_final_state();
#line 3788
  ldv_linux_net_sock_check_final_state();
#line 3792
  ldv_linux_usb_coherent_check_final_state();
#line 3796
  ldv_linux_usb_gadget_check_final_state();
#line 3800
  ldv_linux_usb_urb_check_final_state();
  }
#line 3801
  return;
}
}
#line 3804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_gspca.c.aux"
static void ldv_ldv_initialize_154(void) 
{ 


  {
  {
#line 3808
  ldv_linux_lib_find_bit_initialize();
  }
#line 3809
  return;
}
}
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_autogain_functions.c.aux"
static void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) ;
#line 388
void ldv_linux_kernel_locking_mutex_mutex_lock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) ;
#line 392
void ldv_linux_kernel_locking_mutex_mutex_unlock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) ;
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
static void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) ;
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
__inline static void v4l2_ctrl_lock(struct v4l2_ctrl *ctrl ) 
{ 


  {
  {
#line 378
  ldv_mutex_lock_95((ctrl->handler)->lock);
  }
#line 379
  return;
}
}
#line 385 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
__inline static void v4l2_ctrl_unlock(struct v4l2_ctrl *ctrl ) 
{ 


  {
  {
#line 387
  ldv_mutex_unlock_96((ctrl->handler)->lock);
  }
#line 388
  return;
}
}
#line 707
extern s32 v4l2_ctrl_g_ctrl(struct v4l2_ctrl * ) ;
#line 710
extern int __v4l2_ctrl_s_ctrl(struct v4l2_ctrl * , s32  ) ;
#line 721 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/media/v4l2-ctrls.h"
__inline static int v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl , s32 val ) 
{ 
  int rval ;

  {
  {
#line 725
  v4l2_ctrl_lock(ctrl);
#line 726
  rval = __v4l2_ctrl_s_ctrl(ctrl, val);
#line 727
  v4l2_ctrl_unlock(ctrl);
  }
#line 729
  return (rval);
}
}
#line 235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/gspca.h"
int gspca_expo_autogain(struct gspca_dev *gspca_dev , int avg_lum , int desired_avg_lum ,
                        int deadzone , int gain_knee , int exposure_knee ) ;
#line 237
int gspca_coarse_grained_expo_autogain(struct gspca_dev *gspca_dev , int avg_lum ,
                                       int desired_avg_lum , int deadzone ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/autogain_functions.c"
int gspca_expo_autogain(struct gspca_dev *gspca_dev , int avg_lum , int desired_avg_lum ,
                        int deadzone , int gain_knee , int exposure_knee ) 
{ 
  s32 gain ;
  s32 orig_gain ;
  s32 exposure ;
  s32 orig_exposure ;
  int i ;
  int steps ;
  int retval ;
  s32 tmp ;
  long ret ;
  int __x___0 ;

  {
  {
#line 36
  retval = 0;
#line 38
  tmp = v4l2_ctrl_g_ctrl(gspca_dev->__annonCompField87.autogain);
  }
#line 38
  if (tmp == 0) {
#line 39
    return (0);
  } else {

  }
  {
#line 41
  gain = v4l2_ctrl_g_ctrl(gspca_dev->__annonCompField87.gain);
#line 41
  orig_gain = gain;
#line 42
  exposure = v4l2_ctrl_g_ctrl(gspca_dev->__annonCompField87.exposure);
#line 42
  orig_exposure = exposure;
#line 46
  __x___0 = desired_avg_lum - avg_lum;
#line 46
  ret = (long )(__x___0 < 0 ? - __x___0 : __x___0);
#line 46
  steps = (int )(ret / (long )deadzone);
  }
#line 48
  if (gspca_debug > 3) {
    {
#line 48
    printk("\017%s: autogain: lum: %d, desired: %d, steps: %d", (char *)(& gspca_dev->v4l2_dev.name),
           avg_lum, desired_avg_lum, steps);
    }
  } else {

  }
#line 51
  i = 0;
#line 51
  goto ldv_34616;
  ldv_34615: ;
#line 52
  if (avg_lum > desired_avg_lum) {
#line 53
    if (gain > gain_knee) {
#line 54
      gain = gain - 1;
    } else
#line 55
    if (exposure > exposure_knee) {
#line 56
      exposure = exposure - 1;
    } else
#line 57
    if ((s64 )gain > (gspca_dev->__annonCompField87.gain)->default_value) {
#line 58
      gain = gain - 1;
    } else
#line 59
    if ((s64 )exposure > (gspca_dev->__annonCompField87.exposure)->minimum) {
#line 60
      exposure = exposure - 1;
    } else
#line 61
    if ((s64 )gain > (gspca_dev->__annonCompField87.gain)->minimum) {
#line 62
      gain = gain - 1;
    } else {
#line 64
      goto ldv_34614;
    }
  } else
#line 66
  if ((s64 )gain < (gspca_dev->__annonCompField87.gain)->default_value) {
#line 67
    gain = gain + 1;
  } else
#line 68
  if (exposure < exposure_knee) {
#line 69
    exposure = exposure + 1;
  } else
#line 70
  if (gain < gain_knee) {
#line 71
    gain = gain + 1;
  } else
#line 72
  if ((s64 )exposure < (gspca_dev->__annonCompField87.exposure)->maximum) {
#line 73
    exposure = exposure + 1;
  } else
#line 74
  if ((s64 )gain < (gspca_dev->__annonCompField87.gain)->maximum) {
#line 75
    gain = gain + 1;
  } else {
#line 77
    goto ldv_34614;
  }
#line 51
  i = i + 1;
  ldv_34616: ;
#line 51
  if (i < steps) {
#line 53
    goto ldv_34615;
  } else {

  }
  ldv_34614: ;
#line 81
  if (gain != orig_gain) {
    {
#line 82
    v4l2_ctrl_s_ctrl(gspca_dev->__annonCompField87.gain, gain);
#line 83
    retval = 1;
    }
  } else {

  }
#line 85
  if (exposure != orig_exposure) {
    {
#line 86
    v4l2_ctrl_s_ctrl(gspca_dev->__annonCompField87.exposure, exposure);
#line 87
    retval = 1;
    }
  } else {

  }
#line 90
  if (retval != 0) {
#line 91
    if (gspca_debug > 3) {
      {
#line 91
      printk("\017%s: autogain: changed gain: %d, expo: %d", (char *)(& gspca_dev->v4l2_dev.name),
             gain, exposure);
      }
    } else {

    }
  } else {

  }
#line 93
  return (retval);
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/autogain_functions.c"
static char const   __kstrtab_gspca_expo_autogain[20U]  = 
#line 95
  {      'g',      's',      'p',      'c', 
        'a',      '_',      'e',      'x', 
        'p',      'o',      '_',      'a', 
        'u',      't',      'o',      'g', 
        'a',      'i',      'n',      '\000'};
#line 95
struct kernel_symbol  const  __ksymtab_gspca_expo_autogain ;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/autogain_functions.c"
struct kernel_symbol  const  __ksymtab_gspca_expo_autogain  =    {(unsigned long )(& gspca_expo_autogain), (char const   *)(& __kstrtab_gspca_expo_autogain)};
#line 109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/autogain_functions.c"
int gspca_coarse_grained_expo_autogain(struct gspca_dev *gspca_dev , int avg_lum ,
                                       int desired_avg_lum , int deadzone ) 
{ 
  s32 gain_low ;
  s32 gain_high ;
  s32 gain ;
  s32 orig_gain ;
  s32 exposure ;
  s32 orig_exposure ;
  int steps ;
  int retval ;
  s32 tmp ;

  {
  {
#line 116
  retval = 0;
#line 118
  tmp = v4l2_ctrl_g_ctrl(gspca_dev->__annonCompField87.autogain);
  }
#line 118
  if (tmp == 0) {
#line 119
    return (0);
  } else {

  }
  {
#line 121
  gain = v4l2_ctrl_g_ctrl(gspca_dev->__annonCompField87.gain);
#line 121
  orig_gain = gain;
#line 122
  exposure = v4l2_ctrl_g_ctrl(gspca_dev->__annonCompField87.exposure);
#line 122
  orig_exposure = exposure;
#line 124
  gain_low = (s32 )((unsigned int )(((int )((unsigned int )(gspca_dev->__annonCompField87.gain)->maximum - (unsigned int )(gspca_dev->__annonCompField87.gain)->minimum) / 5) * 2) + (unsigned int )(gspca_dev->__annonCompField87.gain)->minimum);
#line 126
  gain_high = (s32 )((unsigned int )(((int )((unsigned int )(gspca_dev->__annonCompField87.gain)->maximum - (unsigned int )(gspca_dev->__annonCompField87.gain)->minimum) / 5) * 4) + (unsigned int )(gspca_dev->__annonCompField87.gain)->minimum);
#line 131
  steps = (desired_avg_lum - avg_lum) / deadzone;
  }
#line 133
  if (gspca_debug > 3) {
    {
#line 133
    printk("\017%s: autogain: lum: %d, desired: %d, steps: %d", (char *)(& gspca_dev->v4l2_dev.name),
           avg_lum, desired_avg_lum, steps);
    }
  } else {

  }
#line 136
  if (gain + steps > gain_high && (s64 )exposure < (gspca_dev->__annonCompField87.exposure)->maximum) {
#line 138
    gain = gain_high;
#line 139
    gspca_dev->__annonCompField87.exp_too_low_cnt = gspca_dev->__annonCompField87.exp_too_low_cnt + 1;
#line 140
    gspca_dev->__annonCompField87.exp_too_high_cnt = 0;
  } else
#line 141
  if (gain + steps < gain_low && (s64 )exposure > (gspca_dev->__annonCompField87.exposure)->minimum) {
#line 143
    gain = gain_low;
#line 144
    gspca_dev->__annonCompField87.exp_too_high_cnt = gspca_dev->__annonCompField87.exp_too_high_cnt + 1;
#line 145
    gspca_dev->__annonCompField87.exp_too_low_cnt = 0;
  } else {
#line 147
    gain = gain + steps;
#line 148
    if ((s64 )gain > (gspca_dev->__annonCompField87.gain)->maximum) {
#line 149
      gain = (s32 )(gspca_dev->__annonCompField87.gain)->maximum;
    } else
#line 150
    if ((s64 )gain < (gspca_dev->__annonCompField87.gain)->minimum) {
#line 151
      gain = (s32 )(gspca_dev->__annonCompField87.gain)->minimum;
    } else {

    }
#line 152
    gspca_dev->__annonCompField87.exp_too_high_cnt = 0;
#line 153
    gspca_dev->__annonCompField87.exp_too_low_cnt = 0;
  }
#line 156
  if (gspca_dev->__annonCompField87.exp_too_high_cnt > 3) {
#line 157
    exposure = exposure - 1;
#line 158
    gspca_dev->__annonCompField87.exp_too_high_cnt = 0;
  } else
#line 159
  if (gspca_dev->__annonCompField87.exp_too_low_cnt > 3) {
#line 160
    exposure = exposure + 1;
#line 161
    gspca_dev->__annonCompField87.exp_too_low_cnt = 0;
  } else {

  }
#line 164
  if (gain != orig_gain) {
    {
#line 165
    v4l2_ctrl_s_ctrl(gspca_dev->__annonCompField87.gain, gain);
#line 166
    retval = 1;
    }
  } else {

  }
#line 168
  if (exposure != orig_exposure) {
    {
#line 169
    v4l2_ctrl_s_ctrl(gspca_dev->__annonCompField87.exposure, exposure);
#line 170
    retval = 1;
    }
  } else {

  }
#line 173
  if (retval != 0) {
#line 174
    if (gspca_debug > 3) {
      {
#line 174
      printk("\017%s: autogain: changed gain: %d, expo: %d", (char *)(& gspca_dev->v4l2_dev.name),
             gain, exposure);
      }
    } else {

    }
  } else {

  }
#line 176
  return (retval);
}
}
#line 178 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/autogain_functions.c"
static char const   __kstrtab_gspca_coarse_grained_expo_autogain[35U]  = 
#line 178
  {      'g',      's',      'p',      'c', 
        'a',      '_',      'c',      'o', 
        'a',      'r',      's',      'e', 
        '_',      'g',      'r',      'a', 
        'i',      'n',      'e',      'd', 
        '_',      'e',      'x',      'p', 
        'o',      '_',      'a',      'u', 
        't',      'o',      'g',      'a', 
        'i',      'n',      '\000'};
#line 178
struct kernel_symbol  const  __ksymtab_gspca_coarse_grained_expo_autogain ;
#line 178 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/media/usb/gspca/autogain_functions.c"
struct kernel_symbol  const  __ksymtab_gspca_coarse_grained_expo_autogain  =    {(unsigned long )(& gspca_coarse_grained_expo_autogain), (char const   *)(& __kstrtab_gspca_coarse_grained_expo_autogain)};
#line 1282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_autogain_functions.c.aux"
static void ldv_mutex_lock_95(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1286
  ldv_linux_kernel_locking_mutex_mutex_lock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
  }
#line 1287
  return;
}
}
#line 1289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/weaver/.tmp_autogain_functions.c.aux"
static void ldv_mutex_unlock_96(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1293
  ldv_linux_kernel_locking_mutex_mutex_unlock_lock_of_v4l2_ctrl_handler(ldv_func_arg1);
  }
#line 1294
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/irq.linux_alloc_irq.bk.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) ;
#line 50 "/home/ubuntu/klever-work/linux/ldv/irq.h"
bool ldv_in_interrupt_context(void) ;
#line 24 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 27
  tmp = ldv_in_interrupt_context();
  }
#line 27
  if (tmp) {
#line 27
    tmp___0 = 0;
  } else {
#line 27
    tmp___0 = 1;
  }
  {
#line 27
  ldv_assert_linux_alloc_irq__wrong_flags(tmp___0 || flags == 32U);
  }
#line 28
  return;
}
}
#line 31 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) 
{ 
  bool tmp ;

  {
  {
#line 33
  tmp = ldv_in_interrupt_context();
  }
#line 33
  if ((int )tmp) {
    {
#line 36
    ldv_assert_linux_alloc_irq__nonatomic(0);
    }
  } else {

  }
#line 37
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/spinlock.linux_alloc_spinlock.bk.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
int ldv_exclusive_spin_is_locked(void) ;
#line 25 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_flags(gfp_t flags ) 
{ 
  int tmp ;

  {
#line 27
  if (flags != 32U && flags != 0U) {
    {
#line 29
    tmp = ldv_exclusive_spin_is_locked();
#line 29
    ldv_assert_linux_alloc_spinlock__wrong_flags(tmp == 0);
    }
  } else {

  }
#line 30
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_nonatomic(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_exclusive_spin_is_locked();
#line 37
  ldv_assert_linux_alloc_spinlock__nonatomic(tmp == 0);
  }
#line 38
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/usb lock.linux_alloc_usb_lock.bk.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_lock  =    1;
#line 26 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 28
  if (ldv_linux_alloc_usb_lock_lock == 2) {
    {
#line 31
    ldv_assert_linux_alloc_usb_lock__wrong_flags(flags == 16U || flags == 32U);
    }
  } else {

  }
#line 32
  return;
}
}
#line 36 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_alloc_usb_lock__nonatomic(ldv_linux_alloc_usb_lock_lock == 1);
  }
#line 40
  return;
}
}
#line 43 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_lock_device(void) 
{ 


  {
#line 46
  ldv_linux_alloc_usb_lock_lock = 2;
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_trylock_device(void) 
{ 
  int tmp ;

  {
#line 52
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 52
    tmp = ldv_undef_int();
    }
#line 52
    if (tmp != 0) {
#line 55
      ldv_linux_alloc_usb_lock_lock = 2;
#line 57
      return (1);
    } else {
#line 62
      return (0);
    }
  } else {
#line 62
    return (0);
  }
}
}
#line 67 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_lock_device_for_reset(void) 
{ 
  int tmp ;

  {
#line 69
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 69
    tmp = ldv_undef_int();
    }
#line 69
    if (tmp != 0) {
#line 72
      ldv_linux_alloc_usb_lock_lock = 2;
#line 74
      return (0);
    } else {
#line 79
      return (-1);
    }
  } else {
#line 79
    return (-1);
  }
}
}
#line 84 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_unlock_device(void) 
{ 


  {
#line 87
  ldv_linux_alloc_usb_lock_lock = 1;
#line 88
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 23
  v->counter = v->counter + i;
#line 24
  return;
}
}
#line 27 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 29
  v->counter = v->counter - i;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_sub_and_test(int i , atomic_t *v ) 
{ 


  {
#line 35
  v->counter = v->counter - i;
#line 36
  if (v->counter != 0) {
#line 37
    return (0);
  } else {

  }
#line 39
  return (1);
}
}
#line 43 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) 
{ 


  {
#line 45
  v->counter = v->counter + 1;
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_dec(atomic_t *v ) 
{ 


  {
#line 51
  v->counter = v->counter - 1;
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_dec_and_test(atomic_t *v ) 
{ 


  {
#line 57
  v->counter = v->counter - 1;
#line 58
  if (v->counter != 0) {
#line 59
    return (0);
  } else {

  }
#line 61
  return (1);
}
}
#line 65 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_and_test(atomic_t *v ) 
{ 


  {
#line 67
  v->counter = v->counter + 1;
#line 68
  if (v->counter != 0) {
#line 69
    return (0);
  } else {

  }
#line 71
  return (1);
}
}
#line 75 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) 
{ 


  {
#line 77
  v->counter = v->counter + i;
#line 78
  return (v->counter);
}
}
#line 82 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_negative(int i , atomic_t *v ) 
{ 


  {
#line 84
  v->counter = v->counter + i;
#line 85
  return (v->counter < 0);
}
}
#line 89 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_short(short *v ) 
{ 


  {
#line 91
  *v = (short )((unsigned int )((unsigned short )*v) + 1U);
#line 92
  return ((int )*v);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/io.linux_arch_io.bk.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/verifier/nondet.h"
void *ldv_undef_ptr(void) ;
#line 22 "/home/ubuntu/klever-work/linux/arch/io.c"
int ldv_linux_arch_io_iomem  =    0;
#line 25 "/home/ubuntu/klever-work/linux/arch/io.c"
void *ldv_linux_arch_io_io_mem_remap(void) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_undef_ptr();
#line 27
  ptr = tmp;
  }
#line 29
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 31
    ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem + 1;
#line 33
    return (ptr);
  } else {

  }
#line 36
  return (ptr);
}
}
#line 40 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_io_mem_unmap(void) 
{ 


  {
  {
#line 43
  ldv_assert_linux_arch_io__less_initial_decrement(ldv_linux_arch_io_iomem > 0);
#line 45
  ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem - 1;
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_arch_io__more_initial_at_exit(ldv_linux_arch_io_iomem == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/genhd.linux_block_genhd.bk.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) ;
#line 2
void ldv_assert_linux_block_genhd__double_allocation(int expr ) ;
#line 3
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) ;
#line 4
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) ;
#line 31 "/home/ubuntu/klever-work/linux/block/genhd.c"
static int ldv_linux_block_genhd_disk_state  =    0;
#line 34 "/home/ubuntu/klever-work/linux/block/genhd.c"
struct gendisk *ldv_linux_block_genhd_alloc_disk(void) 
{ 
  struct gendisk *res ;
  void *tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ptr();
#line 39
  res = (struct gendisk *)tmp;
#line 37
  ldv_assert_linux_block_genhd__double_allocation(ldv_linux_block_genhd_disk_state == 0);
  }
#line 41
  if ((unsigned long )res != (unsigned long )((struct gendisk *)0)) {
#line 43
    ldv_linux_block_genhd_disk_state = 1;
#line 45
    return (res);
  } else {

  }
#line 48
  return (res);
}
}
#line 52 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_add_disk(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_block_genhd__use_before_allocation(ldv_linux_block_genhd_disk_state == 1);
#line 57
  ldv_linux_block_genhd_disk_state = 2;
  }
#line 58
  return;
}
}
#line 61 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_del_gendisk(void) 
{ 


  {
  {
#line 64
  ldv_assert_linux_block_genhd__delete_before_add(ldv_linux_block_genhd_disk_state == 2);
#line 66
  ldv_linux_block_genhd_disk_state = 1;
  }
#line 67
  return;
}
}
#line 70 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_put_disk(struct gendisk *disk ) 
{ 


  {
#line 72
  if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
    {
#line 74
    ldv_assert_linux_block_genhd__free_before_allocation(ldv_linux_block_genhd_disk_state > 0);
#line 76
    ldv_linux_block_genhd_disk_state = 0;
    }
  } else {

  }
#line 78
  return;
}
}
#line 81 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_check_final_state(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_block_genhd__more_initial_at_exit(ldv_linux_block_genhd_disk_state == 0);
  }
#line 85
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/queue.linux_block_queue.bk.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) ;
#line 2
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/block/queue.c"
static int ldv_linux_block_queue_queue_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/block/queue.c"
struct request_queue *ldv_linux_block_queue_request_queue(void) 
{ 
  struct request_queue *res ;
  void *tmp ;

  {
  {
#line 38
  tmp = ldv_undef_ptr();
#line 38
  res = (struct request_queue *)tmp;
#line 36
  ldv_assert_linux_block_queue__double_allocation(ldv_linux_block_queue_queue_state == 0);
  }
#line 40
  if ((unsigned long )res != (unsigned long )((struct request_queue *)0)) {
#line 42
    ldv_linux_block_queue_queue_state = 1;
#line 44
    return (res);
  } else {

  }
#line 47
  return (res);
}
}
#line 51 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_blk_cleanup_queue(void) 
{ 


  {
  {
#line 54
  ldv_assert_linux_block_queue__use_before_allocation(ldv_linux_block_queue_queue_state == 1);
#line 56
  ldv_linux_block_queue_queue_state = 0;
  }
#line 57
  return;
}
}
#line 60 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_check_final_state(void) 
{ 


  {
  {
#line 63
  ldv_assert_linux_block_queue__more_initial_at_exit(ldv_linux_block_queue_queue_state == 0);
  }
#line 64
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/request.linux_block_request.bk.c"
void ldv_assert_linux_block_request__double_get(int expr ) ;
#line 2
void ldv_assert_linux_block_request__double_put(int expr ) ;
#line 3
void ldv_assert_linux_block_request__get_at_exit(int expr ) ;
#line 32 "/home/ubuntu/klever-work/linux/block/request.c"
int ldv_linux_block_request_blk_rq  =    0;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_get_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;

  {
  {
#line 40
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 43
  tmp = ldv_undef_ptr();
#line 43
  res = (struct request *)tmp;
  }
#line 46
  if ((mask == 16U || mask == 208U) || mask == 16U) {
    {
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
    }
  } else {

  }
#line 49
  if ((unsigned long )res != (unsigned long )((struct request *)0)) {
#line 51
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 54
  return (res);
}
}
#line 58 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_make_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 63
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 66
  tmp = ldv_undef_ptr();
#line 66
  res = (struct request *)tmp;
#line 67
  ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
  }
#line 70
  if (tmp___0 == 0L) {
#line 72
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 75
  return (res);
}
}
#line 79 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_put_blk_rq(void) 
{ 


  {
  {
#line 82
  ldv_assert_linux_block_request__double_put(ldv_linux_block_request_blk_rq == 1);
#line 84
  ldv_linux_block_request_blk_rq = 0;
  }
#line 85
  return;
}
}
#line 88 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_block_request__get_at_exit(ldv_linux_block_request_blk_rq == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/class.linux_drivers_base_class.bk.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_nonpositive(void) ;
#line 33 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_usb_gadget_class  =    0;
#line 36 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void *ldv_linux_drivers_base_class_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 41
  is_got = ldv_undef_ptr();
#line 44
  ldv_assume((int )((long )is_got));
#line 47
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 47
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 52
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 56
  return (is_got);
}
}
#line 60 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 65
  is_reg = ldv_undef_int_nonpositive();
  }
#line 68
  if (is_reg == 0) {
    {
#line 71
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 73
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 77
  return (is_reg);
}
}
#line 81 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_unregister_class(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_drivers_base_class__double_deregistration(ldv_linux_drivers_base_class_usb_gadget_class == 1);
#line 86
  ldv_linux_drivers_base_class_usb_gadget_class = 0;
  }
#line 87
  return;
}
}
#line 89 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 91
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 92
    return;
  } else {
    {
#line 91
    tmp = ldv_is_err((void const   *)cls);
    }
#line 91
    if (tmp != 0L) {
#line 92
      return;
    } else {

    }
  }
  {
#line 93
  ldv_linux_drivers_base_class_unregister_class();
  }
#line 94
  return;
}
}
#line 97 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_check_final_state(void) 
{ 


  {
  {
#line 100
  ldv_assert_linux_drivers_base_class__registered_at_exit(ldv_linux_drivers_base_class_usb_gadget_class == 0);
  }
#line 101
  return;
}
}
#line 35 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 26 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 28
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 29
    return ((dev->p)->driver_data);
  } else {

  }
#line 30
  return ((void *)0);
}
}
#line 39 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 41
  tmp = ldv_xzalloc(8UL);
#line 41
  dev->p = (struct device_private *)tmp;
#line 42
  (dev->p)->driver_data = data;
  }
#line 43
  return (0);
}
}
#line 31 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/ubuntu/klever-work/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 2176UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)master + 1U);
  }
#line 34
  return (master);
}
}
#line 20 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/ubuntu/klever-work/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/ubuntu/klever-work/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/char_dev.linux_fs_char_dev.bk.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_usb_gadget_chrdev  =    0;
#line 33 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 38
  is_reg = ldv_undef_int_nonpositive();
  }
#line 41
  if (is_reg == 0) {
    {
#line 43
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 45
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
#line 46
    if (major == 0) {
      {
#line 48
      is_reg = ldv_undef_int();
#line 49
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 54
  return (is_reg);
}
}
#line 58 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 70
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
  } else {

  }
#line 74
  return (is_reg);
}
}
#line 78 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_unregister_chrdev_region(void) 
{ 


  {
  {
#line 81
  ldv_assert_linux_fs_char_dev__double_deregistration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 1);
#line 83
  ldv_linux_fs_char_dev_usb_gadget_chrdev = 0;
  }
#line 84
  return;
}
}
#line 87 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_check_final_state(void) 
{ 


  {
  {
#line 90
  ldv_assert_linux_fs_char_dev__registered_at_exit(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
  }
#line 91
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/sysfs.linux_fs_sysfs.bk.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs  =    0;
#line 25 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs_create_group(void) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 28
  tmp = ldv_undef_int_nonpositive();
#line 28
  res = tmp;
  }
#line 30
  if (res == 0) {
#line 32
    ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs + 1;
#line 34
    return (0);
  } else {

  }
#line 37
  return (res);
}
}
#line 41 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_sysfs_remove_group(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_fs_sysfs__less_initial_decrement(ldv_linux_fs_sysfs_sysfs > 0);
#line 46
  ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs - 1;
  }
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_check_final_state(void) 
{ 


  {
  {
#line 53
  ldv_assert_linux_fs_sysfs__more_initial_at_exit(ldv_linux_fs_sysfs_sysfs == 0);
  }
#line 54
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/rwlock.linux_kernel_locking_rwlock.bk.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) ;
#line 6
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_rlock  =    1;
#line 25 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_wlock  =    1;
#line 28 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_lock(void) 
{ 


  {
  {
#line 31
  ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 33
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
  }
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_unlock(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(ldv_linux_kernel_locking_rwlock_rlock > 1);
#line 42
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + -1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_lock(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_locking_rwlock__double_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 51
  ldv_linux_kernel_locking_rwlock_wlock = 2;
  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_unlock(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(ldv_linux_kernel_locking_rwlock_wlock != 1);
#line 60
  ldv_linux_kernel_locking_rwlock_wlock = 1;
  }
#line 61
  return;
}
}
#line 64 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_read_trylock(void) 
{ 
  int tmp ;

  {
#line 67
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 67
    tmp = ldv_undef_int();
    }
#line 67
    if (tmp != 0) {
#line 69
      ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
#line 71
      return (1);
    } else {
#line 75
      return (0);
    }
  } else {
#line 75
    return (0);
  }
}
}
#line 80 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_write_trylock(void) 
{ 
  int tmp ;

  {
#line 83
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 83
    tmp = ldv_undef_int();
    }
#line 83
    if (tmp != 0) {
#line 85
      ldv_linux_kernel_locking_rwlock_wlock = 2;
#line 87
      return (1);
    } else {
#line 91
      return (0);
    }
  } else {
#line 91
    return (0);
  }
}
}
#line 96 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_check_final_state(void) 
{ 


  {
  {
#line 99
  ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(ldv_linux_kernel_locking_rwlock_rlock == 1);
#line 101
  ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(ldv_linux_kernel_locking_rwlock_wlock == 1);
  }
#line 102
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/module.linux_kernel_module.bk.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_module_refcounter  =    1;
#line 27 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_get(struct module *module ) 
{ 


  {
#line 30
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 32
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
  } else {

  }
#line 33
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_try_module_get(struct module *module ) 
{ 
  int tmp ;

  {
#line 40
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 42
    tmp = ldv_undef_int();
    }
#line 42
    if (tmp == 1) {
#line 44
      ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
#line 46
      return (1);
    } else {
#line 50
      return (0);
    }
  } else {

  }
#line 51
  return (0);
}
}
#line 56 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put(struct module *module ) 
{ 


  {
#line 59
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 61
    ldv_assert_linux_kernel_module__less_initial_decrement(ldv_linux_kernel_module_module_refcounter > 1);
#line 63
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter - 1;
    }
  } else {

  }
#line 65
  return;
}
}
#line 68 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put_and_exit(void) 
{ 


  {
  {
#line 71
  ldv_linux_kernel_module_module_put((struct module *)1);
  }
  LDV_LINUX_KERNEL_MODULE_STOP: ;
#line 73
  goto LDV_LINUX_KERNEL_MODULE_STOP;
}
}
#line 77 "/home/ubuntu/klever-work/linux/kernel/module.c"
unsigned int ldv_linux_kernel_module_module_refcount(void) 
{ 


  {
#line 80
  return ((unsigned int )(ldv_linux_kernel_module_module_refcounter + -1));
}
}
#line 84 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_check_final_state(void) 
{ 


  {
  {
#line 87
  ldv_assert_linux_kernel_module__more_initial_at_exit(ldv_linux_kernel_module_module_refcounter == 1);
  }
#line 88
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/srcu.linux_kernel_rcu_srcu.bk.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
int ldv_linux_kernel_rcu_srcu_srcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_srcu__more_unlocks(ldv_linux_kernel_rcu_srcu_srcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/lock bh.linux_kernel_rcu_update_lock_bh.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
int ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_lock_bh(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_unlock_bh(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/lock sched.linux_kernel_rcu_update_lock_sched.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
int ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_lock_sched(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_unlock_sched(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/lock.linux_kernel_rcu_update_lock.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
int ldv_linux_kernel_rcu_update_lock_rcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(ldv_linux_kernel_rcu_update_lock_rcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 53
  return;
}
}
#line 67 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_post_probe(int probe_ret_val ) ;
#line 21 "/home/ubuntu/klever-work/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 23
  ldv_assume(val <= 0);
  }
#line 24
  return (val);
}
}
#line 31 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 45
  return (tmp);
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.h"
void ldv_switch_to_interrupt_context(void) ;
#line 42
void ldv_switch_to_process_context(void) ;
#line 25 "/home/ubuntu/klever-work/linux/ldv/irq.c"
static bool __ldv_in_interrupt_context  =    0;
#line 27 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_interrupt_context(void) 
{ 


  {
#line 29
  __ldv_in_interrupt_context = 1;
#line 30
  return;
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_process_context(void) 
{ 


  {
#line 34
  __ldv_in_interrupt_context = 0;
#line 35
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/irq.c"
bool ldv_in_interrupt_context(void) 
{ 


  {
#line 39
  return (__ldv_in_interrupt_context);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/find_bit.linux_lib_find_bit.bk.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) ;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.h"
unsigned long ldv_undef_ulong(void) ;
#line 24 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_next_bit(unsigned long size , unsigned long offset ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 29
  tmp = ldv_undef_ulong();
#line 29
  nondet = tmp;
#line 27
  ldv_assert_linux_lib_find_bit__offset_out_of_range(offset <= size);
#line 30
  ldv_assume(nondet <= size);
#line 31
  ldv_assume(1);
  }
#line 32
  return (nondet);
}
}
#line 36 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_first_bit(unsigned long size ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ulong();
#line 39
  nondet = tmp;
#line 40
  ldv_assume(nondet <= size);
#line 41
  ldv_assume(1);
  }
#line 42
  return (nondet);
}
}
#line 46 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
void ldv_linux_lib_find_bit_initialize(void) 
{ 


  {
  {
#line 48
  ldv_assume(nr_cpu_ids > 0);
  }
#line 49
  return;
}
}
#line 24 "/home/ubuntu/klever-work/linux/mm/kzalloc.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 28
  ldv_check_alloc_flags(flags);
#line 29
  res = ldv_zalloc(size);
#line 30
  ldv_after_alloc(res);
  }
#line 32
  return (res);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/sdio_func.linux_mmc_sdio_func.bk.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) ;
#line 2
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) ;
#line 3
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) ;
#line 25 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
unsigned short ldv_linux_mmc_sdio_func_sdio_element  =    0U;
#line 28 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_context(struct sdio_func *func ) 
{ 


  {
  {
#line 31
  ldv_assert_linux_mmc_sdio_func__wrong_params((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
  }
#line 32
  return;
}
}
#line 35 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_claim_host(struct sdio_func *func ) 
{ 


  {
  {
#line 38
  ldv_assert_linux_mmc_sdio_func__double_claim((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
#line 41
  ldv_linux_mmc_sdio_func_sdio_element = (unsigned short )((func->card)->host)->index;
  }
#line 42
  return;
}
}
#line 45 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_release_host(struct sdio_func *func ) 
{ 


  {
  {
#line 48
  ldv_assert_linux_mmc_sdio_func__release_without_claim((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
#line 51
  ldv_linux_mmc_sdio_func_sdio_element = 0U;
  }
#line 52
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_mmc_sdio_func__unreleased_at_exit((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/register.linux_net_register.bk.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) ;
#line 105 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_register_netdev(void) ;
#line 30 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_linux_net_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_pre_register_netdev(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_net_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_net_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_net_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_net_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_net_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/rtnetlink.linux_net_rtnetlink.bk.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) ;
#line 2
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) ;
#line 3
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int rtnllocknumber  =    0;
#line 29 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_unlock(void) 
{ 


  {
  {
#line 32
  ldv_assert_linux_net_rtnetlink__double_unlock(rtnllocknumber == 1);
#line 34
  rtnllocknumber = 0;
  }
#line 35
  return;
}
}
#line 38 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_lock(void) 
{ 


  {
  {
#line 41
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 43
  rtnllocknumber = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_before_ieee80211_unregister_hw(void) 
{ 


  {
  {
#line 50
  ldv_linux_net_rtnetlink_past_rtnl_lock();
#line 52
  ldv_linux_net_rtnetlink_past_rtnl_unlock();
  }
#line 53
  return;
}
}
#line 56 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_is_locked(void) 
{ 
  int tmp ;

  {
#line 59
  if (rtnllocknumber != 0) {
#line 61
    return (rtnllocknumber);
  } else {
    {
#line 63
    tmp = ldv_undef_int();
    }
#line 63
    if (tmp != 0) {
#line 65
      return (1);
    } else {
#line 68
      return (0);
    }
  }
}
}
#line 72 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_trylock(void) 
{ 
  int tmp ;

  {
  {
#line 75
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 77
  tmp = ldv_linux_net_rtnetlink_rtnl_is_locked();
  }
#line 77
  if (tmp == 0) {
#line 79
    rtnllocknumber = 1;
#line 81
    return (1);
  } else {
#line 84
    return (0);
  }
}
}
#line 88 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_net_rtnetlink__lock_on_exit(rtnllocknumber == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/sock.linux_net_sock.bk.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) ;
#line 2
void ldv_assert_linux_net_sock__double_release(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/net/sock.c"
int locksocknumber  =    0;
#line 27 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_past_lock_sock_nested(void) 
{ 


  {
#line 30
  locksocknumber = locksocknumber + 1;
#line 31
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/net/sock.c"
bool ldv_linux_net_sock_lock_sock_fast(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_undef_int();
  }
#line 37
  if (tmp != 0) {
#line 39
    locksocknumber = locksocknumber + 1;
#line 41
    return (1);
  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_unlock_sock_fast(void) 
{ 


  {
  {
#line 51
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 53
  locksocknumber = locksocknumber - 1;
  }
#line 54
  return;
}
}
#line 57 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_before_release_sock(void) 
{ 


  {
  {
#line 60
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 62
  locksocknumber = locksocknumber - 1;
  }
#line 63
  return;
}
}
#line 66 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_check_final_state(void) 
{ 


  {
  {
#line 69
  ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(locksocknumber == 0);
  }
#line 70
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/coherent.linux_usb_coherent.bk.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/coherent.c"
int ldv_linux_usb_coherent_coherent_state  =    0;
#line 27 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void *ldv_linux_usb_coherent_usb_alloc_coherent(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 30
  tmp = ldv_undef_ptr();
#line 30
  arbitrary_memory = tmp;
  }
#line 32
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 34
    return (arbitrary_memory);
  } else {

  }
#line 37
  ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + 1;
#line 39
  return (arbitrary_memory);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_usb_free_coherent(void *addr ) 
{ 


  {
#line 45
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 47
    ldv_assert_linux_usb_coherent__less_initial_decrement(ldv_linux_usb_coherent_coherent_state > 0);
#line 49
    ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + -1;
    }
  } else {

  }
#line 51
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_usb_coherent__more_initial_at_exit(ldv_linux_usb_coherent_coherent_state == 0);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/dev.linux_usb_dev.bk.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_usb_dev__probe_failed(int expr ) ;
#line 4
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/dev.c"
ldv_map LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS  ;
#line 27 "/home/ubuntu/klever-work/linux/usb/dev.c"
struct usb_device *ldv_linux_usb_dev_usb_get_dev(struct usb_device *dev ) 
{ 


  {
#line 30
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
#line 32
    LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0 ? LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + 1 : 1;
  } else {

  }
#line 39
  return (dev);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_usb_put_dev(struct usb_device *dev ) 
{ 


  {
#line 46
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
    {
#line 48
    ldv_assert_linux_usb_dev__unincremented_counter_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0);
#line 50
    ldv_assert_linux_usb_dev__less_initial_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 0);
    }
#line 54
    if (LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 1) {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + -1;
    } else {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
    }
  } else {

  }
#line 56
  return;
}
}
#line 59 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_return_value_probe(int retval ) 
{ 


  {
#line 62
  if (retval != 0) {
    {
#line 64
    ldv_assert_linux_usb_dev__probe_failed(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
    }
  } else {

  }
#line 65
  return;
}
}
#line 69 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_initialize(void) 
{ 


  {
#line 72
  LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
#line 73
  return;
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_final_state(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_dev__more_initial_at_exit(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
  }
#line 80
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/gadget.linux_usb_gadget.bk.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) ;
#line 2
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) ;
#line 3
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) ;
#line 4
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) ;
#line 5
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) ;
#line 6
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) ;
#line 7
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) ;
#line 33 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_usb_gadget  =    0;
#line 37 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void *ldv_linux_usb_gadget_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 42
  is_got = ldv_undef_ptr();
#line 45
  ldv_assume((int )((long )is_got));
#line 48
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 48
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 54
  return (is_got);
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 72
  return (is_reg);
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_class(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 80
  return;
}
}
#line 82 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 84
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 85
    return;
  } else {
    {
#line 84
    tmp = ldv_is_err((void const   *)cls);
    }
#line 84
    if (tmp != 0L) {
#line 85
      return;
    } else {

    }
  }
  {
#line 86
  ldv_linux_usb_gadget_unregister_class();
  }
#line 87
  return;
}
}
#line 90 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 95
  is_reg = ldv_undef_int_nonpositive();
  }
#line 98
  if (is_reg == 0) {
    {
#line 100
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
#line 101
    if (major == 0) {
      {
#line 103
      is_reg = ldv_undef_int();
#line 104
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 109
  return (is_reg);
}
}
#line 113 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 118
  is_reg = ldv_undef_int_nonpositive();
  }
#line 121
  if (is_reg == 0) {
    {
#line 123
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 127
  return (is_reg);
}
}
#line 131 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_chrdev_region(void) 
{ 


  {
  {
#line 134
  ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 135
  return;
}
}
#line 138 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_usb_gadget(void) 
{ 
  int is_reg ;

  {
  {
#line 143
  is_reg = ldv_undef_int_nonpositive();
  }
#line 146
  if (is_reg == 0) {
    {
#line 148
    ldv_assert_linux_usb_gadget__double_usb_gadget_registration(ldv_linux_usb_gadget_usb_gadget == 0);
#line 150
    ldv_linux_usb_gadget_usb_gadget = 1;
    }
  } else {

  }
#line 154
  return (is_reg);
}
}
#line 158 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_usb_gadget(void) 
{ 


  {
  {
#line 161
  ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(ldv_linux_usb_gadget_usb_gadget == 1);
#line 163
  ldv_linux_usb_gadget_usb_gadget = 0;
  }
#line 164
  return;
}
}
#line 167 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_check_final_state(void) 
{ 


  {
  {
#line 170
  ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 171
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/register.linux_usb_register.bk.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) ;
#line 90 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_usb_register_driver(void) ;
#line 30 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_linux_usb_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_pre_usb_register_driver(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_usb_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_usb_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_usb_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_usb_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_usb_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/urb.linux_usb_urb.bk.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/usb/urb.c"
int ldv_linux_usb_urb_urb_state  =    0;
#line 29 "/home/ubuntu/klever-work/linux/usb/urb.c"
struct urb *ldv_linux_usb_urb_usb_alloc_urb(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 32
  tmp = ldv_undef_ptr();
#line 32
  arbitrary_memory = tmp;
  }
#line 34
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 36
    return ((struct urb *)arbitrary_memory);
  } else {

  }
#line 39
  ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + 1;
#line 41
  return ((struct urb *)arbitrary_memory);
}
}
#line 45 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_usb_free_urb(struct urb *urb ) 
{ 


  {
#line 46
  if ((unsigned long )urb != (unsigned long )((struct urb *)0)) {
    {
#line 48
    ldv_assert_linux_usb_urb__less_initial_decrement(ldv_linux_usb_urb_urb_state > 0);
#line 50
    ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + -1;
    }
  } else {

  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_check_final_state(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_usb_urb__more_initial_at_exit(ldv_linux_usb_urb_urb_state == 0);
  }
#line 59
  return;
}
}
#line 24 "/home/ubuntu/klever-work/verifier/common.h"
extern void ldv_assert(char const   * , int  ) ;
#line 45
void __builtin_trap(void) ;
#line 23 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_assume(int expression ) 
{ 


  {
#line 25
  if (expression == 0) {
    ldv_assume_label: ;
#line 29
    goto ldv_assume_label;
  } else {

  }
#line 31
  return;
}
}
#line 33 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_stop(void) 
{ 


  {
  ldv_stop_label: ;
#line 36
  goto ldv_stop_label;
}
}
#line 43 "/home/ubuntu/klever-work/verifier/common.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 45
  return (exp);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/common.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 56
  ldv_assert("", 0);
  }
#line 57
  return;
}
}
#line 29 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 30
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 37
extern void *external_allocated_data(void) ;
#line 40
void *ldv_calloc_unknown_size(void) ;
#line 41
void *ldv_zalloc_unknown_size(void) ;
#line 47
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 25 "/home/ubuntu/klever-work/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 26
extern void *calloc(size_t  , size_t  ) ;
#line 27
extern void free(void * ) ;
#line 28
extern void *memset(void * , int  , size_t  ) ;
#line 30 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp___1 = ldv_undef_int();
  }
#line 32
  if (tmp___1 != 0) {
    {
#line 33
    tmp = malloc(size);
#line 33
    res = tmp;
#line 34
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    ldv_assume(tmp___0 == 0L);
    }
#line 36
    return (res);
  } else {
#line 39
    return ((void *)0);
  }
}
}
#line 43 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 48
    tmp___0 = ldv_is_err((void const   *)res);
#line 48
    ldv_assume(tmp___0 == 0L);
    }
#line 49
    return (res);
  } else {
#line 52
    return ((void *)0);
  }
}
}
#line 56 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = ldv_calloc(1UL, size);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/ubuntu/klever-work/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 63
  free(s);
  }
#line 64
  return;
}
}
#line 66 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 68
  tmp = malloc(size);
#line 68
  res = tmp;
#line 69
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
#line 70
  ldv_assume(tmp___0 == 0L);
  }
#line 71
  return (res);
}
}
#line 74 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 76
  tmp = calloc(1UL, size);
#line 76
  res = tmp;
#line 77
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 78
  tmp___0 = ldv_is_err((void const   *)res);
#line 78
  ldv_assume(tmp___0 == 0L);
  }
#line 79
  return (res);
}
}
#line 82 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = ldv_undef_int();
  }
#line 84
  if (tmp___1 != 0) {
    {
#line 85
    tmp = external_allocated_data();
#line 85
    res = tmp;
#line 86
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 87
    tmp___0 = ldv_is_err((void const   *)res);
#line 87
    ldv_assume(tmp___0 == 0L);
    }
#line 88
    return (res);
  } else {
#line 91
    return ((void *)0);
  }
}
}
#line 95 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 97
  tmp___1 = ldv_undef_int();
  }
#line 97
  if (tmp___1 != 0) {
    {
#line 98
    tmp = external_allocated_data();
#line 98
    res = tmp;
#line 99
    memset(res, 0, 8UL);
#line 100
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 101
    tmp___0 = ldv_is_err((void const   *)res);
#line 101
    ldv_assume(tmp___0 == 0L);
    }
#line 102
    return (res);
  } else {
#line 105
    return ((void *)0);
  }
}
}
#line 109 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 111
  tmp = ldv_calloc_unknown_size();
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 116
  tmp = external_allocated_data();
#line 116
  res = tmp;
#line 117
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 118
  tmp___0 = ldv_is_err((void const   *)res);
#line 118
  ldv_assume(tmp___0 == 0L);
  }
#line 119
  return (res);
}
}
#line 27 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_negative(void) ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern void *__VERIFIER_nondet_pointer(void) ;
#line 40 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = __VERIFIER_nondet_int();
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/ubuntu/klever-work/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = __VERIFIER_nondet_pointer();
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 49
  tmp = __VERIFIER_nondet_ulong();
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 54
  tmp = ldv_undef_int();
#line 54
  ret = tmp;
#line 55
  ldv_assume(ret < 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 61
  tmp = ldv_undef_int();
#line 61
  ret = tmp;
#line 62
  ldv_assume(ret <= 0);
  }
#line 63
  return (ret);
}
}
#line 32 "/home/ubuntu/klever-work/verifier/thread.h"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) ;
#line 35
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) ;
#line 38
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) ;
#line 41
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) ;
#line 27 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) 
{ 


  {
#line 29
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
    {
#line 30
    (*function)(data);
    }
  } else {

  }
#line 31
  return (0);
}
}
#line 35 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) 
{ 
  int i ;

  {
#line 39
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
#line 40
    i = 0;
#line 40
    goto ldv_1179;
    ldv_1178: 
    {
#line 41
    (*function)(data);
#line 40
    i = i + 1;
    }
    ldv_1179: ;
#line 40
    if (i < ldv_thread_set->number) {
#line 42
      goto ldv_1178;
    } else {

    }

  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) 
{ 


  {
#line 56
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/mutex.linux_kernel_locking_mutex.bk.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode  ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 33
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 35
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
  }
#line 36
  return;
}
}
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 42
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 44
  tmp = ldv_undef_int();
  }
#line 44
  if (tmp != 0) {
#line 46
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 48
    return (0);
  } else {
#line 52
    return (-4);
  }
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 60
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode) {
#line 62
    return (1);
  } else {
    {
#line 65
    tmp = ldv_undef_int();
    }
#line 65
    if (tmp != 0) {
#line 67
      return (1);
    } else {
#line 71
      return (0);
    }
  }
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 79
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 82
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(lock);
  }
#line 82
  if (tmp != 0) {
#line 84
    return (0);
  } else {
#line 88
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 90
    return (1);
  }
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt ,
                                                                              struct mutex *lock ) 
{ 


  {
#line 98
  cnt->counter = cnt->counter - 1;
#line 101
  if (cnt->counter != 0) {
#line 103
    return (0);
  } else {
    {
#line 106
    ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(lock);
    }
#line 108
    return (1);
  }
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 116
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 118
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
  }
#line 119
  return;
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock  ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 126
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 128
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
  }
#line 129
  return;
}
}
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 135
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 137
  tmp = ldv_undef_int();
  }
#line 137
  if (tmp != 0) {
#line 139
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 141
    return (0);
  } else {
#line 145
    return (-4);
  }
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 153
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock) {
#line 155
    return (1);
  } else {
    {
#line 158
    tmp = ldv_undef_int();
    }
#line 158
    if (tmp != 0) {
#line 160
      return (1);
    } else {
#line 164
      return (0);
    }
  }
}
}
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 172
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 175
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(lock);
  }
#line 175
  if (tmp != 0) {
#line 177
    return (0);
  } else {
#line 181
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 183
    return (1);
  }
}
}
#line 188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_lock(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ 


  {
#line 191
  cnt->counter = cnt->counter - 1;
#line 194
  if (cnt->counter != 0) {
#line 196
    return (0);
  } else {
    {
#line 199
    ldv_linux_kernel_locking_mutex_mutex_lock_lock(lock);
    }
#line 201
    return (1);
  }
}
}
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 209
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 211
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
  }
#line 212
  return;
}
}
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler  ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 


  {
  {
#line 219
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler);
#line 221
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler = 1;
  }
#line 222
  return;
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 228
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler);
#line 230
  tmp = ldv_undef_int();
  }
#line 230
  if (tmp != 0) {
#line 232
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler = 1;
#line 234
    return (0);
  } else {
#line 238
    return (-4);
  }
}
}
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 246
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler) {
#line 248
    return (1);
  } else {
    {
#line 251
    tmp = ldv_undef_int();
    }
#line 251
    if (tmp != 0) {
#line 253
      return (1);
    } else {
#line 257
      return (0);
    }
  }
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 265
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler);
#line 268
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_lock_of_v4l2_ctrl_handler(lock);
  }
#line 268
  if (tmp != 0) {
#line 270
    return (0);
  } else {
#line 274
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler = 1;
#line 276
    return (1);
  }
}
}
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_lock_of_v4l2_ctrl_handler(atomic_t *cnt ,
                                                                                       struct mutex *lock ) 
{ 


  {
#line 284
  cnt->counter = cnt->counter - 1;
#line 287
  if (cnt->counter != 0) {
#line 289
    return (0);
  } else {
    {
#line 292
    ldv_linux_kernel_locking_mutex_mutex_lock_lock_of_v4l2_ctrl_handler(lock);
    }
#line 294
    return (1);
  }
}
}
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_lock_of_v4l2_ctrl_handler(struct mutex *lock ) 
{ 


  {
  {
#line 302
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler);
#line 304
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler = 0;
  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device  ;
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 312
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 314
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
  }
#line 315
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 321
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 323
  tmp = ldv_undef_int();
  }
#line 323
  if (tmp != 0) {
#line 325
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 327
    return (0);
  } else {
#line 331
    return (-4);
  }
}
}
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 339
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device) {
#line 341
    return (1);
  } else {
    {
#line 344
    tmp = ldv_undef_int();
    }
#line 344
    if (tmp != 0) {
#line 346
      return (1);
    } else {
#line 350
      return (0);
    }
  }
}
}
#line 355 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 358
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 361
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(lock);
  }
#line 361
  if (tmp != 0) {
#line 363
    return (0);
  } else {
#line 367
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 369
    return (1);
  }
}
}
#line 374 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt ,
                                                                             struct mutex *lock ) 
{ 


  {
#line 377
  cnt->counter = cnt->counter - 1;
#line 380
  if (cnt->counter != 0) {
#line 382
    return (0);
  } else {
    {
#line 385
    ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(lock);
    }
#line 387
    return (1);
  }
}
}
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 395
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 397
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
  }
#line 398
  return;
}
}
#line 399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev  ;
#line 402 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_queue_lock_of_gspca_dev(struct mutex *lock ) 
{ 


  {
  {
#line 405
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev);
#line 407
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev = 1;
  }
#line 408
  return;
}
}
#line 411 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_queue_lock_of_gspca_dev(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 414
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev);
#line 416
  tmp = ldv_undef_int();
  }
#line 416
  if (tmp != 0) {
#line 418
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev = 1;
#line 420
    return (0);
  } else {
#line 424
    return (-4);
  }
}
}
#line 429 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_queue_lock_of_gspca_dev(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 432
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev) {
#line 434
    return (1);
  } else {
    {
#line 437
    tmp = ldv_undef_int();
    }
#line 437
    if (tmp != 0) {
#line 439
      return (1);
    } else {
#line 443
      return (0);
    }
  }
}
}
#line 448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_queue_lock_of_gspca_dev(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 451
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev);
#line 454
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_queue_lock_of_gspca_dev(lock);
  }
#line 454
  if (tmp != 0) {
#line 456
    return (0);
  } else {
#line 460
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev = 1;
#line 462
    return (1);
  }
}
}
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_queue_lock_of_gspca_dev(atomic_t *cnt ,
                                                                                     struct mutex *lock ) 
{ 


  {
#line 470
  cnt->counter = cnt->counter - 1;
#line 473
  if (cnt->counter != 0) {
#line 475
    return (0);
  } else {
    {
#line 478
    ldv_linux_kernel_locking_mutex_mutex_lock_queue_lock_of_gspca_dev(lock);
    }
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_queue_lock_of_gspca_dev(struct mutex *lock ) 
{ 


  {
  {
#line 488
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev);
#line 490
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev = 0;
  }
#line 491
  return;
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev  ;
#line 495 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_usb_lock_of_gspca_dev(struct mutex *lock ) 
{ 


  {
  {
#line 498
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev);
#line 500
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev = 1;
  }
#line 501
  return;
}
}
#line 504 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_usb_lock_of_gspca_dev(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 507
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev);
#line 509
  tmp = ldv_undef_int();
  }
#line 509
  if (tmp != 0) {
#line 511
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev = 1;
#line 513
    return (0);
  } else {
#line 517
    return (-4);
  }
}
}
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_usb_lock_of_gspca_dev(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 525
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev) {
#line 527
    return (1);
  } else {
    {
#line 530
    tmp = ldv_undef_int();
    }
#line 530
    if (tmp != 0) {
#line 532
      return (1);
    } else {
#line 536
      return (0);
    }
  }
}
}
#line 541 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_usb_lock_of_gspca_dev(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 544
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev);
#line 547
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_usb_lock_of_gspca_dev(lock);
  }
#line 547
  if (tmp != 0) {
#line 549
    return (0);
  } else {
#line 553
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev = 1;
#line 555
    return (1);
  }
}
}
#line 560 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_usb_lock_of_gspca_dev(atomic_t *cnt ,
                                                                                   struct mutex *lock ) 
{ 


  {
#line 563
  cnt->counter = cnt->counter - 1;
#line 566
  if (cnt->counter != 0) {
#line 568
    return (0);
  } else {
    {
#line 571
    ldv_linux_kernel_locking_mutex_mutex_lock_usb_lock_of_gspca_dev(lock);
    }
#line 573
    return (1);
  }
}
}
#line 578 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_usb_lock_of_gspca_dev(struct mutex *lock ) 
{ 


  {
  {
#line 581
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev);
#line 583
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev = 0;
  }
#line 584
  return;
}
}
#line 586 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_initialize(void) 
{ 


  {
#line 589
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
#line 591
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
#line 593
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler = 0;
#line 595
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
#line 597
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev = 0;
#line 599
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev = 0;
#line 600
  return;
}
}
#line 603 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_check_final_state(void) 
{ 


  {
  {
#line 606
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 608
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 610
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock_of_v4l2_ctrl_handler);
#line 612
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 614
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_queue_lock_of_gspca_dev);
#line 616
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_usb_lock_of_gspca_dev);
  }
#line 617
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/spinlock.linux_kernel_locking_spinlock.bk.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct  =    1;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 28
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 30
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 32
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
  }
#line 33
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 41
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 43
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 52
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 54
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 57
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 60
  if (is_spin_held_by_another_thread != 0) {
#line 62
    return (0);
  } else {
#line 66
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 68
    return (1);
  }
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 76
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 78
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
  }
#line 79
  return;
}
}
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 87
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 90
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 92
    return (0);
  } else {
#line 96
    return (1);
  }
}
}
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_alloc_lock_of_task_struct(void) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct();
  }
#line 104
  return (tmp == 0);
}
}
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 113
  is_spin_contended = ldv_undef_int();
  }
#line 116
  if (is_spin_contended != 0) {
#line 118
    return (0);
  } else {
#line 122
    return (1);
  }
}
}
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_alloc_lock_of_task_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 132
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 134
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 137
  atomic_value_after_dec = ldv_undef_int();
  }
#line 140
  if (atomic_value_after_dec == 0) {
#line 142
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 144
    return (1);
  } else {

  }
#line 148
  return (0);
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode  =    1;
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_i_lock_of_inode(void) 
{ 


  {
  {
#line 156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 160
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
  }
#line 161
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_i_lock_of_inode(void) 
{ 


  {
  {
#line 167
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 169
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 171
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 1;
  }
#line 172
  return;
}
}
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 185
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 188
  if (is_spin_held_by_another_thread != 0) {
#line 190
    return (0);
  } else {
#line 194
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 196
    return (1);
  }
}
}
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_i_lock_of_inode(void) 
{ 


  {
  {
#line 204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
  }
#line 207
  return;
}
}
#line 210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 215
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 218
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1 && is_spin_held_by_another_thread == 0) {
#line 220
    return (0);
  } else {
#line 224
    return (1);
  }
}
}
#line 229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_i_lock_of_inode(void) 
{ 
  int tmp ;

  {
  {
#line 232
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode();
  }
#line 232
  return (tmp == 0);
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_i_lock_of_inode(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 241
  is_spin_contended = ldv_undef_int();
  }
#line 244
  if (is_spin_contended != 0) {
#line 246
    return (0);
  } else {
#line 250
    return (1);
  }
}
}
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_i_lock_of_inode(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 260
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 262
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 265
  atomic_value_after_dec = ldv_undef_int();
  }
#line 268
  if (atomic_value_after_dec == 0) {
#line 270
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 272
    return (1);
  } else {

  }
#line 276
  return (0);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock  =    1;
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock(void) 
{ 


  {
  {
#line 284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 288
  ldv_linux_kernel_locking_spinlock_spin_lock = 2;
  }
#line 289
  return;
}
}
#line 292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock(void) 
{ 


  {
  {
#line 295
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 297
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 299
  ldv_linux_kernel_locking_spinlock_spin_lock = 1;
  }
#line 300
  return;
}
}
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 313
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 316
  if (is_spin_held_by_another_thread != 0) {
#line 318
    return (0);
  } else {
#line 322
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 324
    return (1);
  }
}
}
#line 329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock(void) 
{ 


  {
  {
#line 332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
  }
#line 335
  return;
}
}
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 343
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 346
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 1 && is_spin_held_by_another_thread == 0) {
#line 348
    return (0);
  } else {
#line 352
    return (1);
  }
}
}
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock(void) 
{ 
  int tmp ;

  {
  {
#line 360
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock();
  }
#line 360
  return (tmp == 0);
}
}
#line 364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 369
  is_spin_contended = ldv_undef_int();
  }
#line 372
  if (is_spin_contended != 0) {
#line 374
    return (0);
  } else {
#line 378
    return (1);
  }
}
}
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 388
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 390
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 393
  atomic_value_after_dec = ldv_undef_int();
  }
#line 396
  if (atomic_value_after_dec == 0) {
#line 398
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 400
    return (1);
  } else {

  }
#line 404
  return (0);
}
}
#line 406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN  =    1;
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 416
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
  }
#line 417
  return;
}
}
#line 420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 423
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 425
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 427
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 1;
  }
#line 428
  return;
}
}
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 441
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 444
  if (is_spin_held_by_another_thread != 0) {
#line 446
    return (0);
  } else {
#line 450
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 452
    return (1);
  }
}
}
#line 457 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
  }
#line 463
  return;
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 471
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 474
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1 && is_spin_held_by_another_thread == 0) {
#line 476
    return (0);
  } else {
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int tmp ;

  {
  {
#line 488
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN();
  }
#line 488
  return (tmp == 0);
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 497
  is_spin_contended = ldv_undef_int();
  }
#line 500
  if (is_spin_contended != 0) {
#line 502
    return (0);
  } else {
#line 506
    return (1);
  }
}
}
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 516
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 518
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 521
  atomic_value_after_dec = ldv_undef_int();
  }
#line 524
  if (atomic_value_after_dec == 0) {
#line 526
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 528
    return (1);
  } else {

  }
#line 532
  return (0);
}
}
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data  =    1;
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 544
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
  }
#line 545
  return;
}
}
#line 548 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 551
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 553
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 555
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 1;
  }
#line 556
  return;
}
}
#line 559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 566
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 569
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 572
  if (is_spin_held_by_another_thread != 0) {
#line 574
    return (0);
  } else {
#line 578
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 580
    return (1);
  }
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 590
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
  }
#line 591
  return;
}
}
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 599
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 602
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1 && is_spin_held_by_another_thread == 0) {
#line 604
    return (0);
  } else {
#line 608
    return (1);
  }
}
}
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_node_size_lock_of_pglist_data(void) 
{ 
  int tmp ;

  {
  {
#line 616
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data();
  }
#line 616
  return (tmp == 0);
}
}
#line 620 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 625
  is_spin_contended = ldv_undef_int();
  }
#line 628
  if (is_spin_contended != 0) {
#line 630
    return (0);
  } else {
#line 634
    return (1);
  }
}
}
#line 639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_node_size_lock_of_pglist_data(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 644
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 646
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 649
  atomic_value_after_dec = ldv_undef_int();
  }
#line 652
  if (atomic_value_after_dec == 0) {
#line 654
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 656
    return (1);
  } else {

  }
#line 660
  return (0);
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_ptl  =    1;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_ptl(void) 
{ 


  {
  {
#line 668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 670
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 672
  ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
  }
#line 673
  return;
}
}
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_ptl(void) 
{ 


  {
  {
#line 679
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 681
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 683
  ldv_linux_kernel_locking_spinlock_spin_ptl = 1;
  }
#line 684
  return;
}
}
#line 687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 694
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 697
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 700
  if (is_spin_held_by_another_thread != 0) {
#line 702
    return (0);
  } else {
#line 706
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 708
    return (1);
  }
}
}
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_ptl(void) 
{ 


  {
  {
#line 716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 718
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
  }
#line 719
  return;
}
}
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 727
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 730
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 1 && is_spin_held_by_another_thread == 0) {
#line 732
    return (0);
  } else {
#line 736
    return (1);
  }
}
}
#line 741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_ptl(void) 
{ 
  int tmp ;

  {
  {
#line 744
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl();
  }
#line 744
  return (tmp == 0);
}
}
#line 748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_ptl(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 753
  is_spin_contended = ldv_undef_int();
  }
#line 756
  if (is_spin_contended != 0) {
#line 758
    return (0);
  } else {
#line 762
    return (1);
  }
}
}
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_ptl(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 772
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 774
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 777
  atomic_value_after_dec = ldv_undef_int();
  }
#line 780
  if (atomic_value_after_dec == 0) {
#line 782
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 784
    return (1);
  } else {

  }
#line 788
  return (0);
}
}
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct  =    1;
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 798
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 800
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
  }
#line 801
  return;
}
}
#line 804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 807
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 809
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 811
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 1;
  }
#line 812
  return;
}
}
#line 815 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 822
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 825
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 828
  if (is_spin_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 834
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 836
    return (1);
  }
}
}
#line 841 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 846
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
  }
#line 847
  return;
}
}
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 855
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 858
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 860
    return (0);
  } else {
#line 864
    return (1);
  }
}
}
#line 869 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_siglock_of_sighand_struct(void) 
{ 
  int tmp ;

  {
  {
#line 872
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct();
  }
#line 872
  return (tmp == 0);
}
}
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_siglock_of_sighand_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 881
  is_spin_contended = ldv_undef_int();
  }
#line 884
  if (is_spin_contended != 0) {
#line 886
    return (0);
  } else {
#line 890
    return (1);
  }
}
}
#line 895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_siglock_of_sighand_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 900
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 902
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 905
  atomic_value_after_dec = ldv_undef_int();
  }
#line 908
  if (atomic_value_after_dec == 0) {
#line 910
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 912
    return (1);
  } else {

  }
#line 916
  return (0);
}
}
#line 919 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_check_final_state(void) 
{ 


  {
  {
#line 922
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 926
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 928
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 930
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 932
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 934
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
  }
#line 935
  return;
}
}
#line 938 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_exclusive_spin_is_locked(void) 
{ 


  {
#line 941
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2) {
#line 943
    return (1);
  } else {

  }
#line 946
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2) {
#line 948
    return (1);
  } else {

  }
#line 951
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 2) {
#line 953
    return (1);
  } else {

  }
#line 956
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2) {
#line 958
    return (1);
  } else {

  }
#line 961
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2) {
#line 963
    return (1);
  } else {

  }
#line 966
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 2) {
#line 968
    return (1);
  } else {

  }
#line 971
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2) {
#line 973
    return (1);
  } else {

  }
#line 976
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/completion.linux_kernel_sched_completion.bk.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) ;
#line 2
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/sched/completion.c"
static int ldv_linux_kernel_sched_completion_completion  =    0;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion(void) 
{ 


  {
#line 33
  ldv_linux_kernel_sched_completion_completion = 1;
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_macro(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_sched_completion__double_init(ldv_linux_kernel_sched_completion_completion != 0);
#line 42
  ldv_linux_kernel_sched_completion_completion = 1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_wait_for_completion(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_sched_completion__wait_without_init(ldv_linux_kernel_sched_completion_completion != 0);
#line 51
  ldv_linux_kernel_sched_completion_completion = 2;
  }
#line 52
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/rsg/models/idr.linux_lib_idr.bk.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) ;
#line 2
void ldv_assert_linux_lib_idr__double_init(int expr ) ;
#line 3
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_lib_idr__not_initialized(int expr ) ;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/lib/idr.c"
static int ldv_linux_lib_idr_idr  =    0;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_init(void) 
{ 


  {
  {
#line 35
  ldv_assert_linux_lib_idr__double_init(ldv_linux_lib_idr_idr == 0);
#line 37
  ldv_linux_lib_idr_idr = 1;
  }
#line 38
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_alloc(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 46
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 48
  ldv_linux_lib_idr_idr = 2;
  }
#line 49
  return;
}
}
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_find(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 57
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 59
  ldv_linux_lib_idr_idr = 2;
  }
#line 60
  return;
}
}
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_remove(void) 
{ 


  {
  {
#line 66
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 68
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 70
  ldv_linux_lib_idr_idr = 2;
  }
#line 71
  return;
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_destroy(void) 
{ 


  {
  {
#line 77
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 79
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 81
  ldv_linux_lib_idr_idr = 3;
  }
#line 82
  return;
}
}
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_check_final_state(void) 
{ 


  {
  {
#line 88
  ldv_assert_linux_lib_idr__more_at_exit(ldv_linux_lib_idr_idr == 0 || ldv_linux_lib_idr_idr == 3);
  }
#line 89
  return;
}
}
#line 2 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
extern void __VERIFIER_error_linux_net_rtnetlink(void) ;
#line 3 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 6
  return;
}
}
#line 7 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) 
{ 


  {
#line 8
  if (! expr) {
    {
#line 9
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 10
  return;
}
}
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) 
{ 


  {
#line 12
  if (! expr) {
    {
#line 13
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 14
  return;
}
}
#line 15
extern void __VERIFIER_error_linux_kernel_locking_rwlock(void) ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) 
{ 


  {
#line 17
  if (! expr) {
    {
#line 18
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 19
  return;
}
}
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) 
{ 


  {
#line 21
  if (! expr) {
    {
#line 22
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 23
  return;
}
}
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) 
{ 


  {
#line 25
  if (! expr) {
    {
#line 26
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 27
  return;
}
}
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) 
{ 


  {
#line 29
  if (! expr) {
    {
#line 30
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 31
  return;
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) 
{ 


  {
#line 33
  if (! expr) {
    {
#line 34
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 35
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) 
{ 


  {
#line 37
  if (! expr) {
    {
#line 38
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 39
  return;
}
}
#line 40
extern void __VERIFIER_error_linux_lib_idr(void) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__double_init(int expr ) 
{ 


  {
#line 42
  if (! expr) {
    {
#line 43
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 44
  return;
}
}
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__not_initialized(int expr ) 
{ 


  {
#line 46
  if (! expr) {
    {
#line 47
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 48
  return;
}
}
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) 
{ 


  {
#line 50
  if (! expr) {
    {
#line 51
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 52
  return;
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) 
{ 


  {
#line 54
  if (! expr) {
    {
#line 55
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 56
  return;
}
}
#line 57
extern void __VERIFIER_error_linux_kernel_sched_completion(void) ;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) 
{ 


  {
#line 59
  if (! expr) {
    {
#line 60
    __VERIFIER_error_linux_kernel_sched_completion();
    }
  } else {

  }
#line 61
  return;
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) 
{ 


  {
#line 63
  if (! expr) {
    {
#line 64
    __VERIFIER_error_linux_kernel_sched_completion();
    }
  } else {

  }
#line 65
  return;
}
}
#line 66
extern void __VERIFIER_error_linux_net_register(void) ;
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) 
{ 


  {
#line 68
  if (! expr) {
    {
#line 69
    __VERIFIER_error_linux_net_register();
    }
  } else {

  }
#line 70
  return;
}
}
#line 71
extern void __VERIFIER_error_linux_fs_char_dev(void) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) 
{ 


  {
#line 73
  if (! expr) {
    {
#line 74
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 75
  return;
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) 
{ 


  {
#line 77
  if (! expr) {
    {
#line 78
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 79
  return;
}
}
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) 
{ 


  {
#line 81
  if (! expr) {
    {
#line 82
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 83
  return;
}
}
#line 84
extern void __VERIFIER_error_linux_kernel_rcu_srcu(void) ;
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) 
{ 


  {
#line 86
  if (! expr) {
    {
#line 87
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 88
  return;
}
}
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) 
{ 


  {
#line 90
  if (! expr) {
    {
#line 91
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 92
  return;
}
}
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) 
{ 


  {
#line 94
  if (! expr) {
    {
#line 95
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 96
  return;
}
}
#line 97
extern void __VERIFIER_error_linux_kernel_module(void) ;
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) 
{ 


  {
#line 99
  if (! expr) {
    {
#line 100
    __VERIFIER_error_linux_kernel_module();
    }
  } else {

  }
#line 101
  return;
}
}
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) 
{ 


  {
#line 103
  if (! expr) {
    {
#line 104
    __VERIFIER_error_linux_kernel_module();
    }
  } else {

  }
#line 105
  return;
}
}
#line 106
extern void __VERIFIER_error_linux_alloc_spinlock(void) ;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) 
{ 


  {
#line 108
  if (! expr) {
    {
#line 109
    __VERIFIER_error_linux_alloc_spinlock();
    }
  } else {

  }
#line 110
  return;
}
}
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) 
{ 


  {
#line 112
  if (! expr) {
    {
#line 113
    __VERIFIER_error_linux_alloc_spinlock();
    }
  } else {

  }
#line 114
  return;
}
}
#line 115
extern void __VERIFIER_error_linux_lib_find_bit(void) ;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) 
{ 


  {
#line 117
  if (! expr) {
    {
#line 118
    __VERIFIER_error_linux_lib_find_bit();
    }
  } else {

  }
#line 119
  return;
}
}
#line 120
extern void __VERIFIER_error_linux_mmc_sdio_func(void) ;
#line 121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) 
{ 


  {
#line 122
  if (! expr) {
    {
#line 123
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 124
  return;
}
}
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) 
{ 


  {
#line 126
  if (! expr) {
    {
#line 127
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 128
  return;
}
}
#line 129 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) 
{ 


  {
#line 130
  if (! expr) {
    {
#line 131
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 132
  return;
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) 
{ 


  {
#line 134
  if (! expr) {
    {
#line 135
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 136
  return;
}
}
#line 137
extern void __VERIFIER_error_linux_usb_coherent(void) ;
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) 
{ 


  {
#line 139
  if (! expr) {
    {
#line 140
    __VERIFIER_error_linux_usb_coherent();
    }
  } else {

  }
#line 141
  return;
}
}
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) 
{ 


  {
#line 143
  if (! expr) {
    {
#line 144
    __VERIFIER_error_linux_usb_coherent();
    }
  } else {

  }
#line 145
  return;
}
}
#line 146
extern void __VERIFIER_error_linux_kernel_rcu_update_lock(void) ;
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) 
{ 


  {
#line 148
  if (! expr) {
    {
#line 149
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 150
  return;
}
}
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) 
{ 


  {
#line 152
  if (! expr) {
    {
#line 153
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 154
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) 
{ 


  {
#line 156
  if (! expr) {
    {
#line 157
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 158
  return;
}
}
#line 159
extern void __VERIFIER_error_linux_net_sock(void) ;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) 
{ 


  {
#line 161
  if (! expr) {
    {
#line 162
    __VERIFIER_error_linux_net_sock();
    }
  } else {

  }
#line 163
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__double_release(int expr ) 
{ 


  {
#line 165
  if (! expr) {
    {
#line 166
    __VERIFIER_error_linux_net_sock();
    }
  } else {

  }
#line 167
  return;
}
}
#line 168
extern void __VERIFIER_error_linux_kernel_rcu_update_lock_bh(void) ;
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) 
{ 


  {
#line 170
  if (! expr) {
    {
#line 171
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 172
  return;
}
}
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) 
{ 


  {
#line 174
  if (! expr) {
    {
#line 175
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 176
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) 
{ 


  {
#line 178
  if (! expr) {
    {
#line 179
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 180
  return;
}
}
#line 181
extern void __VERIFIER_error_linux_usb_dev(void) ;
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) 
{ 


  {
#line 183
  if (! expr) {
    {
#line 184
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 185
  return;
}
}
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) 
{ 


  {
#line 187
  if (! expr) {
    {
#line 188
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 189
  return;
}
}
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) 
{ 


  {
#line 191
  if (! expr) {
    {
#line 192
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 193
  return;
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__probe_failed(int expr ) 
{ 


  {
#line 195
  if (! expr) {
    {
#line 196
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 197
  return;
}
}
#line 198
extern void __VERIFIER_error_linux_kernel_locking_mutex(void) ;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) 
{ 


  {
#line 200
  if (! expr) {
    {
#line 201
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 202
  return;
}
}
#line 203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 204
  if (! expr) {
    {
#line 205
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 206
  return;
}
}
#line 207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) 
{ 


  {
#line 208
  if (! expr) {
    {
#line 209
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 210
  return;
}
}
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 212
  if (! expr) {
    {
#line 213
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 214
  return;
}
}
#line 215
extern void __VERIFIER_error_linux_usb_gadget(void) ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 217
  if (! expr) {
    {
#line 218
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 219
  return;
}
}
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 221
  if (! expr) {
    {
#line 222
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 223
  return;
}
}
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 225
  if (! expr) {
    {
#line 226
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 227
  return;
}
}
#line 228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 229
  if (! expr) {
    {
#line 230
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 231
  return;
}
}
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) 
{ 


  {
#line 233
  if (! expr) {
    {
#line 234
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 235
  return;
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) 
{ 


  {
#line 237
  if (! expr) {
    {
#line 238
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 239
  return;
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) 
{ 


  {
#line 241
  if (! expr) {
    {
#line 242
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 243
  return;
}
}
#line 244
extern void __VERIFIER_error_linux_alloc_usb_lock(void) ;
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) 
{ 


  {
#line 246
  if (! expr) {
    {
#line 247
    __VERIFIER_error_linux_alloc_usb_lock();
    }
  } else {

  }
#line 248
  return;
}
}
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) 
{ 


  {
#line 250
  if (! expr) {
    {
#line 251
    __VERIFIER_error_linux_alloc_usb_lock();
    }
  } else {

  }
#line 252
  return;
}
}
#line 253
extern void __VERIFIER_error_linux_block_request(void) ;
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_get(int expr ) 
{ 


  {
#line 255
  if (! expr) {
    {
#line 256
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 257
  return;
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_put(int expr ) 
{ 


  {
#line 259
  if (! expr) {
    {
#line 260
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 261
  return;
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__get_at_exit(int expr ) 
{ 


  {
#line 263
  if (! expr) {
    {
#line 264
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 265
  return;
}
}
#line 266
extern void __VERIFIER_error_linux_alloc_irq(void) ;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) 
{ 


  {
#line 268
  if (! expr) {
    {
#line 269
    __VERIFIER_error_linux_alloc_irq();
    }
  } else {

  }
#line 270
  return;
}
}
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) 
{ 


  {
#line 272
  if (! expr) {
    {
#line 273
    __VERIFIER_error_linux_alloc_irq();
    }
  } else {

  }
#line 274
  return;
}
}
#line 275
extern void __VERIFIER_error_linux_drivers_base_class(void) ;
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) 
{ 


  {
#line 277
  if (! expr) {
    {
#line 278
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 279
  return;
}
}
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) 
{ 


  {
#line 281
  if (! expr) {
    {
#line 282
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 283
  return;
}
}
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) 
{ 


  {
#line 285
  if (! expr) {
    {
#line 286
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 287
  return;
}
}
#line 288
extern void __VERIFIER_error_linux_block_queue(void) ;
#line 289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) 
{ 


  {
#line 290
  if (! expr) {
    {
#line 291
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 292
  return;
}
}
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) 
{ 


  {
#line 294
  if (! expr) {
    {
#line 295
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 296
  return;
}
}
#line 297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) 
{ 


  {
#line 298
  if (! expr) {
    {
#line 299
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 300
  return;
}
}
#line 301
extern void __VERIFIER_error_linux_block_genhd(void) ;
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__double_allocation(int expr ) 
{ 


  {
#line 303
  if (! expr) {
    {
#line 304
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) 
{ 


  {
#line 307
  if (! expr) {
    {
#line 308
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 309
  return;
}
}
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) 
{ 


  {
#line 311
  if (! expr) {
    {
#line 312
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 313
  return;
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) 
{ 


  {
#line 315
  if (! expr) {
    {
#line 316
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 317
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) 
{ 


  {
#line 319
  if (! expr) {
    {
#line 320
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 321
  return;
}
}
#line 322
extern void __VERIFIER_error_linux_arch_io(void) ;
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) 
{ 


  {
#line 324
  if (! expr) {
    {
#line 325
    __VERIFIER_error_linux_arch_io();
    }
  } else {

  }
#line 326
  return;
}
}
#line 327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) 
{ 


  {
#line 328
  if (! expr) {
    {
#line 329
    __VERIFIER_error_linux_arch_io();
    }
  } else {

  }
#line 330
  return;
}
}
#line 331
extern void __VERIFIER_error_linux_usb_register(void) ;
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) 
{ 


  {
#line 333
  if (! expr) {
    {
#line 334
    __VERIFIER_error_linux_usb_register();
    }
  } else {

  }
#line 335
  return;
}
}
#line 336
extern void __VERIFIER_error_linux_fs_sysfs(void) ;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) 
{ 


  {
#line 338
  if (! expr) {
    {
#line 339
    __VERIFIER_error_linux_fs_sysfs();
    }
  } else {

  }
#line 340
  return;
}
}
#line 341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) 
{ 


  {
#line 342
  if (! expr) {
    {
#line 343
    __VERIFIER_error_linux_fs_sysfs();
    }
  } else {

  }
#line 344
  return;
}
}
#line 345
extern void __VERIFIER_error_linux_kernel_locking_spinlock(void) ;
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) 
{ 


  {
#line 347
  if (! expr) {
    {
#line 348
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 349
  return;
}
}
#line 350 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 351
  if (! expr) {
    {
#line 352
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 353
  return;
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) 
{ 


  {
#line 355
  if (! expr) {
    {
#line 356
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 357
  return;
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 359
  if (! expr) {
    {
#line 360
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 361
  return;
}
}
#line 362
extern void __VERIFIER_error_linux_usb_urb(void) ;
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) 
{ 


  {
#line 364
  if (! expr) {
    {
#line 365
    __VERIFIER_error_linux_usb_urb();
    }
  } else {

  }
#line 366
  return;
}
}
#line 367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) 
{ 


  {
#line 368
  if (! expr) {
    {
#line 369
    __VERIFIER_error_linux_usb_urb();
    }
  } else {

  }
#line 370
  return;
}
}
#line 371
extern void __VERIFIER_error_linux_kernel_rcu_update_lock_sched(void) ;
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) 
{ 


  {
#line 373
  if (! expr) {
    {
#line 374
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 375
  return;
}
}
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) 
{ 


  {
#line 377
  if (! expr) {
    {
#line 378
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 379
  return;
}
}
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/media/usb/gspca/gspca_main.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) 
{ 


  {
#line 381
  if (! expr) {
    {
#line 382
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 383
  return;
}
}
