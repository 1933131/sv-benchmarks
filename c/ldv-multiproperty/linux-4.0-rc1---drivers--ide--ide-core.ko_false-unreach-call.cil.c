/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef signed char s8;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned char u8;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned short u16;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef int s32;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned int u32;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef long long s64;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned short umode_t;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef _Bool bool;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_uid32_t uid_t;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_gid32_t gid_t;
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_loff_t loff_t;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __kernel_time_t time_t;
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __s32 int32_t;
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef __u32 uint32_t;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long sector_t;
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long blkcnt_t;
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 dma_addr_t;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int gfp_t;
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int fmode_t;
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned int oom_flags_t;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef u64 phys_addr_t;
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef phys_addr_t resource_size_t;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic_t_6 {
   int counter ;
};
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic_t_6 atomic_t;
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 186
struct hlist_node;
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_head {
   struct hlist_node *first ;
};
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct class;
#line 199
struct device;
#line 245
struct completion;
#line 280
struct gendisk;
#line 341
struct module;
#line 349
struct mutex;
#line 406
struct request_queue;
#line 417
struct request;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u16 __ticket_t;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef u32 __ticketpair_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct __raw_tickets {
   __ticket_t head ;
   __ticket_t tail ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
union __anonunion____missing_field_name_8 {
   __ticketpair_t head_tail ;
   struct __raw_tickets tickets ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct arch_spinlock {
   union __anonunion____missing_field_name_8 __annonCompField4 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
typedef struct arch_spinlock arch_spinlock_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/spinlock_types.h"
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/qrwlock_types.h"
typedef struct qrwlock arch_rwlock_t;
#line 15
struct task_struct;
#line 16
struct lockdep_map;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/page_types.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_10 {
   unsigned int a ;
   unsigned int b ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct __anonstruct____missing_field_name_11 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
union __anonunion____missing_field_name_9 {
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
   struct __anonstruct____missing_field_name_11 __annonCompField6 ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/ptrace.h"
struct desc_struct {
   union __anonunion____missing_field_name_9 __annonCompField7 ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pteval_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgdval_t;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef unsigned long pgprotval_t;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct __anonstruct_pte_t_12 {
   pteval_t pte ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
typedef struct __anonstruct_pte_t_12 pte_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_64_types.h"
struct pgprot {
   pgprotval_t pgprot ;
};
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct pgprot pgprot_t;
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct __anonstruct_pgd_t_13 pgd_t;
#line 361
struct page;
#line 361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
typedef struct page *pgtable_t;
#line 369
struct file;
#line 382
struct seq_file;
#line 420
struct thread_struct;
#line 422
struct mm_struct;
#line 423
struct cpumask;
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/init.h"
typedef void (*ctor_fn_t)(void);
#line 413 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
struct file_operations;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
union __anonunion____missing_field_name_16 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/vm86.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_16 __annonCompField8 ;
};
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bitmap.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bug.h"
struct cpumask {
   unsigned long bits[128U] ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
typedef struct cpumask *cpumask_var_t;
#line 161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct seq_operations;
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_21 {
   u64 rip ;
   u64 rdp ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_22 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_20 {
   struct __anonstruct____missing_field_name_21 __annonCompField12 ;
   struct __anonstruct____missing_field_name_22 __annonCompField13 ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_23 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_20 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_23 __annonCompField15 ;
};
#line 345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct ymmh_struct {
   u32 ymmh_space[64U] ;
};
#line 371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct lwp_struct {
   u8 reserved[128U] ;
};
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndreg {
   u64 lower_bound ;
   u64 upper_bound ;
};
#line 381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct bndcsr {
   u64 bndcfgu ;
   u64 bndstatus ;
};
#line 386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
   struct ymmh_struct ymmh ;
   struct lwp_struct lwp ;
   struct bndreg bndreg[4U] ;
   struct bndcsr bndcsr ;
};
#line 401 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct fpu {
   unsigned int last_cpu ;
   unsigned int has_fpu ;
   union thread_xstate *state ;
};
#line 465
struct kmem_cache;
#line 466
struct perf_event;
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long fs ;
   unsigned long gs ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
   unsigned long ptrace_dr7 ;
   unsigned long cr2 ;
   unsigned long trap_nr ;
   unsigned long error_code ;
   struct fpu fpu ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned char fpu_counter ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/atomic-long.h"
typedef atomic64_t atomic_long_t;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debug_locks.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stacktrace.h"
struct lockdep_subclass_key {
   char __one_byte ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
   unsigned long ip ;
};
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
};
#line 536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockdep.h"
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct __anonstruct____missing_field_name_27 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
union __anonunion____missing_field_name_26 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_27 __annonCompField17 ;
};
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
struct spinlock {
   union __anonunion____missing_field_name_26 __annonCompField18 ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_types.h"
typedef struct spinlock spinlock_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
struct __anonstruct_rwlock_t_28 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rwlock_types.h"
typedef struct __anonstruct_rwlock_t_28 rwlock_t;
#line 51 "/home/ubuntu/klever-work/linux/ldv/irq.h"
struct ldv_thread;
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct optimistic_spin_queue {
   atomic_t tail ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/osq_lock.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
#line 193
struct timespec;
#line 194
struct compat_timespec;
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_futex_30 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_nanosleep_31 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
#line 195
struct pollfd;
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct __anonstruct_poll_32 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
union __anonunion____missing_field_name_29 {
   struct __anonstruct_futex_30 futex ;
   struct __anonstruct_nanosleep_31 nanosleep ;
   struct __anonstruct_poll_32 poll ;
};
#line 195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_29 __annonCompField19 ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jump_label.h"
struct jump_entry;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
typedef u64 jump_label_t;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/jump_label.h"
struct jump_entry {
   jump_label_t code ;
   jump_label_t target ;
   jump_label_t key ;
};
#line 426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
struct seqcount {
   unsigned int sequence ;
   struct lockdep_map dep_map ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct seqcount seqcount_t;
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seqlock.h"
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
#line 43 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 1154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
union __anonunion____missing_field_name_46 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
#line 1155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct idr_layer {
   int prefix ;
   int layer ;
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_46 __annonCompField20 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
   int cur ;
   spinlock_t lock ;
   int id_free_cnt ;
   struct idr_layer *id_free ;
};
#line 124 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida_bitmap {
   long nr_busy ;
   unsigned long bitmap[15U] ;
};
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/idr.h"
struct rb_node {
   unsigned long __rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
#line 87
struct dentry;
#line 88
struct iattr;
#line 89
struct vm_area_struct;
#line 90
struct super_block;
#line 91
struct file_system_type;
#line 92
struct kernfs_open_node;
#line 93
struct kernfs_iattrs;
#line 115
struct kernfs_root;
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rbtree.h"
struct kernfs_elem_dir {
   unsigned long subdirs ;
   struct rb_root children ;
   struct kernfs_root *root ;
};
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
#line 88
struct kernfs_ops;
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
union __anonunion____missing_field_name_47 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
   union __anonunion____missing_field_name_47 __annonCompField21 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
   struct kernfs_iattrs *iattr ;
};
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
#line 170
struct vm_operations_struct;
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
#line 469
struct sock;
#line 470
struct kobject;
#line 471
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
#line 477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernfs.h"
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
#line 135 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/uapi/asm/stat.h"
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/highuid.h"
struct user_namespace;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kuid_t_48 {
   uid_t val ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kuid_t_48 kuid_t;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct __anonstruct_kgid_t_49 {
   gid_t val ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
typedef struct __anonstruct_kgid_t_49 kgid_t;
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uidgid.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct bin_attribute;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/stat.h"
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
#line 479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysfs.h"
struct kref {
   atomic_t refcount ;
};
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
union ktime {
   s64 tv64 ;
};
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ktime.h"
typedef union ktime ktime_t;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct tvec_base;
#line 268 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timekeeping.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   struct tvec_base *base ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   int slack ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
struct hrtimer;
#line 255
enum hrtimer_restart;
#line 266
struct workqueue_struct;
#line 267
struct work_struct;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset;
#line 52
struct kobj_type;
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
   char buf[2048U] ;
   int buflen ;
};
#line 130 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
#line 222
struct klist_node;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct __anonstruct_nodemask_t_50 {
   unsigned long bits[16U] ;
};
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_50 nodemask_t;
#line 520
struct path;
#line 521
struct inode;
#line 522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nodemask.h"
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
   struct user_namespace *user_ns ;
   void *private ;
};
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
#line 186
struct pinctrl;
#line 187
struct pinctrl_state;
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pinctrl/consumer.h"
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
#line 320
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
#line 327
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
#line 335
struct wakeup_source;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
   struct list_head clock_list ;
};
#line 540
struct dev_pm_qos;
#line 540 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
   int autosuspend_delay ;
   unsigned long last_busy ;
   unsigned long active_jiffies ;
   unsigned long suspended_jiffies ;
   unsigned long accounting_timestamp ;
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
};
#line 789 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore;
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct rw_semaphore {
   long count ;
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/x86_init.h"
struct pci_dev;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/topology.h"
struct pci_bus;
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
   unsigned short ia32_compat ;
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/xen/features.h"
struct bio_vec;
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io_apic.h"
struct device_node;
#line 1269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmzone.h"
struct llist_node;
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/llist.h"
struct llist_node {
   struct llist_node *next ;
};
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/smp.h"
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   u16 flags ;
};
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct dma_map_ops;
#line 421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/device.h"
struct pdev_archdata {

};
#line 14
struct device_private;
#line 15
struct device_driver;
#line 16
struct driver_private;
#line 17
struct subsys_private;
#line 18
struct bus_type;
#line 19
struct iommu_ops;
#line 20
struct iommu_group;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute;
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
#line 138
struct device_type;
#line 196
struct of_device_id;
#line 196
struct acpi_device_id;
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
#line 322
struct class_attribute;
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
#line 415 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
#line 486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
#line 652
struct acpi_device;
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct acpi_dev_node {
   struct acpi_device *companion ;
};
#line 659
struct dma_coherent_mem;
#line 659
struct cma;
#line 659 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct acpi_dev_node acpi_node ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
#line 806 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
   unsigned long active_count ;
   unsigned long relax_count ;
   unsigned long expire_count ;
   unsigned long wakeup_count ;
   bool active ;
   bool autosleep_enabled ;
};
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kdev_t.h"
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
#line 460 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct dmi_strmatch {
   unsigned char slot : 7 ;
   unsigned char exact_match : 1 ;
   char substr[79U] ;
};
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct dmi_system_id {
   int (*callback)(struct dmi_system_id  const  * ) ;
   char const   *ident ;
   struct dmi_strmatch matches[4U] ;
   void *driver_data ;
};
#line 474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mod_devicetable.h"
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
#line 84 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/plist.h"
struct plist_node {
   int prio ;
   struct list_head prio_list ;
   struct list_head node_list ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
   unsigned int saved_trap_nr ;
   unsigned int saved_tf ;
};
#line 66
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_151 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct __anonstruct____missing_field_name_152 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
};
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
union __anonunion____missing_field_name_150 {
   struct __anonstruct____missing_field_name_151 __annonCompField34 ;
   struct __anonstruct____missing_field_name_152 __annonCompField35 ;
};
#line 73
struct uprobe;
#line 73
struct return_instance;
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uprobes.h"
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
   struct return_instance *return_instances ;
   unsigned int depth ;
};
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct xol_area;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uprobes.h"
struct uprobes_state {
   struct xol_area *xol_area ;
};
#line 133
struct address_space;
#line 134
struct mem_cgroup;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
typedef void compound_page_dtor(struct page * );
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_153 {
   struct address_space *mapping ;
   void *s_mem ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_155 {
   unsigned long index ;
   void *freelist ;
   bool pfmemalloc ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_159 {
   unsigned short inuse ;
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_158 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_159 __annonCompField39 ;
   int units ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_157 {
   union __anonunion____missing_field_name_158 __annonCompField40 ;
   atomic_t _count ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_156 {
   unsigned long counters ;
   struct __anonstruct____missing_field_name_157 __annonCompField41 ;
   unsigned int active ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField38 ;
   union __anonunion____missing_field_name_156 __annonCompField42 ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_161 {
   struct page *next ;
   int pages ;
   int pobjects ;
};
#line 32
struct slab;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct____missing_field_name_162 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_160 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_161 __annonCompField44 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_162 __annonCompField45 ;
   pgtable_t pmd_huge_pte ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
union __anonunion____missing_field_name_163 {
   unsigned long private ;
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_153 __annonCompField37 ;
   struct __anonstruct____missing_field_name_154 __annonCompField43 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   union __anonunion____missing_field_name_163 __annonCompField47 ;
   struct mem_cgroup *mem_cgroup ;
};
#line 181 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct __anonstruct_shared_164 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
};
#line 248
struct anon_vma;
#line 248
struct mempolicy;
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct vm_area_struct {
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct __anonstruct_shared_164 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
#line 322 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
#line 335 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct task_rss_stat {
   int events ;
   int count[3U] ;
};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
#line 348
struct kioctx_table;
#line 349
struct linux_binfmt;
#line 349
struct mmu_notifier_mm;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
   unsigned long mmap_legacy_base ;
   unsigned long task_size ;
   unsigned long highest_vm_end ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long pinned_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long def_flags ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
   unsigned long numa_scan_offset ;
   int numa_scan_seq ;
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
#line 4 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/cputime_jiffies.h"
typedef unsigned long cputime_t;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sem_undo_list;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/shm.h"
struct user_struct;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shm.h"
struct sysv_shm {
   struct list_head shm_clist ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_166 {
   unsigned long sig[1U] ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_166 sigset_t;
#line 25
struct siginfo;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __signalfn_t(int  );
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __signalfn_t *__sighandler_t;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef void __restorefn_t(void);
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/signal-defs.h"
typedef __restorefn_t *__sigrestore_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/signal.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef union sigval sigval_t;
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__kill_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__timer_169 {
   __kernel_timer_t _tid ;
   int _overrun ;
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__rt_170 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigchld_171 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__addr_bnd_173 {
   void *_lower ;
   void *_upper ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigfault_172 {
   void *_addr ;
   short _addr_lsb ;
   struct __anonstruct__addr_bnd_173 _addr_bnd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_174 {
   long _band ;
   int _fd ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct __anonstruct__sigsys_175 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
union __anonunion__sifields_167 {
   int _pad[28U] ;
   struct __anonstruct__kill_168 _kill ;
   struct __anonstruct__timer_169 _timer ;
   struct __anonstruct__rt_170 _rt ;
   struct __anonstruct__sigchld_171 _sigchld ;
   struct __anonstruct__sigfault_172 _sigfault ;
   struct __anonstruct__sigpoll_174 _sigpoll ;
   struct __anonstruct__sigsys_175 _sigsys ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_167 _sifields ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
#line 443
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
#line 450
struct pid_namespace;
#line 450 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/signal.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
#line 174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pid.h"
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp_filter;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/seccomp.h"
struct seccomp {
   int mode ;
   struct seccomp_filter *filter ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rtmutex.h"
struct rt_mutex_waiter;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/resource.h"
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/resource.h"
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
#line 50
struct hrtimer_clock_base;
#line 51
struct hrtimer_cpu_base;
#line 60
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timerqueue.h"
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
   ktime_t offset ;
};
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   unsigned int cpu ;
   unsigned int active_bases ;
   unsigned int clock_was_set ;
   ktime_t expires_next ;
   int in_hrtirq ;
   int hres_active ;
   int hang_detected ;
   unsigned long nr_events ;
   unsigned long nr_retries ;
   unsigned long nr_hangs ;
   ktime_t max_hang_time ;
   struct hrtimer_clock_base clock_base[4U] ;
};
#line 453 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hrtimer.h"
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/task_io_accounting.h"
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/sysctl.h"
struct nsproxy;
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct assoc_array_ptr;
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sysctl.h"
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef int32_t key_serial_t;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
typedef uint32_t key_perm_t;
#line 35
struct key;
#line 36
struct signal_struct;
#line 37
struct cred;
#line 38
struct key_type;
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_180 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
#line 123
struct key_user;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_181 {
   time_t expiry ;
   time_t revoked_at ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct __anonstruct____missing_field_name_183 {
   struct key_type *type ;
   char *description ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_182 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_183 __annonCompField52 ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_type_data_184 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion_payload_186 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
union __anonunion____missing_field_name_185 {
   union __anonunion_payload_186 payload ;
   struct assoc_array keys ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_180 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_181 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   union __anonunion____missing_field_name_182 __annonCompField53 ;
   union __anonunion_type_data_184 type_data ;
   union __anonunion____missing_field_name_185 __annonCompField54 ;
};
#line 358
struct audit_context;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/selinux.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cred.h"
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct futex_pi_state;
#line 128
struct robust_list_head;
#line 129
struct bio_list;
#line 130
struct fs_struct;
#line 131
struct perf_event_context;
#line 132
struct blk_plug;
#line 182
struct cfs_rq;
#line 183
struct task_group;
#line 471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
#line 510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
#line 518 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
#line 525 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
#line 557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   raw_spinlock_t lock ;
};
#line 599
struct autogroup;
#line 600
struct tty_struct;
#line 600
struct taskstats;
#line 600
struct tty_audit_buf;
#line 600 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   unsigned long maxrss ;
   unsigned long cmaxrss ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   unsigned int audit_tty_log_passwd ;
   struct tty_audit_buf *tty_audit_buf ;
   struct rw_semaphore group_rwsem ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
   short oom_score_adj_min ;
   struct mutex cred_guard_mutex ;
};
#line 781 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
#line 824
struct backing_dev_info;
#line 825
struct reclaim_state;
#line 826 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
#line 1073
struct io_context;
#line 1107
struct pipe_inode_info;
#line 1109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   u32 inv_weight ;
};
#line 1116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_avg {
   u32 runnable_avg_sum ;
   u32 runnable_avg_period ;
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
};
#line 1128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
#line 1163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
#line 1195
struct rt_rq;
#line 1195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned long watchdog_stamp ;
   unsigned int time_slice ;
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
#line 1211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
   int dl_new ;
   int dl_boosted ;
   int dl_yielded ;
   struct hrtimer dl_timer ;
};
#line 1277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
   unsigned char may_oom : 1 ;
};
#line 1702
struct sched_class;
#line 1702
struct files_struct;
#line 1702
struct css_set;
#line 1702
struct compat_robust_list_head;
#line 1702
struct numa_group;
#line 1702
struct ftrace_ret_stack;
#line 1702 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   struct llist_node wake_entry ;
   int on_cpu ;
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
   unsigned long wakee_flip_decay_ts ;
   int wake_cpu ;
   int on_rq ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   int nr_cpus_allowed ;
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   unsigned char brk_randomized : 1 ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int jobctl ;
   unsigned int personality ;
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned long atomic_flags ;
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
   unsigned long hardirq_enable_ip ;
   unsigned long hardirq_disable_ip ;
   unsigned int hardirq_enable_event ;
   unsigned int hardirq_disable_event ;
   int hardirqs_enabled ;
   int hardirq_context ;
   unsigned long softirq_disable_ip ;
   unsigned long softirq_enable_ip ;
   unsigned int softirq_disable_event ;
   unsigned int softirq_enable_event ;
   int softirqs_enabled ;
   int softirq_context ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
   int cpuset_slab_spread_rotor ;
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
   short pref_node_fork ;
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
   unsigned int numa_scan_period_max ;
   int numa_preferred_nid ;
   unsigned long numa_migrate_retry ;
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
   unsigned long numa_faults_locality[2U] ;
   unsigned long numa_pages_migrated ;
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   int nr_dirtied ;
   int nr_dirtied_pause ;
   unsigned long dirty_paused_when ;
   int latency_record_count ;
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   unsigned int kasan_depth ;
   int curr_ret_stack ;
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
   unsigned long trace_recursion ;
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
   unsigned int sequential_io_avg ;
   unsigned long task_state_change ;
};
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/resource_ext.h"
struct hotplug_slot;
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/resource_ext.h"
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef int pci_power_t;
#line 137 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
#line 138
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
#line 247
struct pcie_link_state;
#line 248
struct pci_vpd;
#line 249
struct pci_sriov;
#line 250
struct pci_ats;
#line 251
struct proc_dir_entry;
#line 251
struct pci_driver;
#line 251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
union __anonunion____missing_field_name_191 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
#line 251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
   unsigned int d3cold_delay ;
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_191 __annonCompField58 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
#line 438
struct pci_ops;
#line 438
struct msi_controller;
#line 438 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char max_bus_speed ;
   unsigned char cur_bus_speed ;
   char name[48U] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
#line 558 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
#line 580 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
#line 604 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
#line 637 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
#line 1182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct scatterlist {
   unsigned long sg_magic ;
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bit_spinlock.h"
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
   int nid ;
   struct mem_cgroup *memcg ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/shrinker.h"
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
   long batch ;
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/page_ext.h"
struct file_ra_state;
#line 65
struct writeback_control;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
   pte_t *pte ;
};
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pci_64.h"
struct dma_attrs {
   unsigned long flags[1U] ;
};
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-attrs.h"
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-attrs.h"
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
   unsigned int orig_nents ;
};
#line 351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
};
#line 1889 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct mfd_cell;
#line 1890 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   char *driver_override ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/platform_device.h"
struct platform_driver {
   int (*probe)(struct platform_device * ) ;
   int (*remove)(struct platform_device * ) ;
   void (*shutdown)(struct platform_device * ) ;
   int (*suspend)(struct platform_device * , pm_message_t  ) ;
   int (*resume)(struct platform_device * ) ;
   struct device_driver driver ;
   struct platform_device_id  const  *id_table ;
   bool prevent_deferred_probe ;
};
#line 315
struct hlist_bl_node;
#line 315 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/platform_device.h"
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_bl.h"
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct __anonstruct____missing_field_name_193 {
   spinlock_t lock ;
   int count ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
union __anonunion____missing_field_name_192 {
   struct __anonstruct____missing_field_name_193 __annonCompField59 ;
};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rculist_bl.h"
struct lockref {
   union __anonunion____missing_field_name_192 __annonCompField60 ;
};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct vfsmount;
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct __anonstruct____missing_field_name_195 {
   u32 hash ;
   u32 len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
union __anonunion____missing_field_name_194 {
   struct __anonstruct____missing_field_name_195 __annonCompField61 ;
   u64 hash_len ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/lockref.h"
struct qstr {
   union __anonunion____missing_field_name_194 __annonCompField62 ;
   unsigned char const   *name ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations;
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
union __anonunion_d_u_196 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
#line 90 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry {
   unsigned int d_flags ;
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_196 d_u ;
};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
};
#line 555 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dcache.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/path.h"
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
};
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list_lru.h"
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct __anonstruct____missing_field_name_198 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
union __anonunion____missing_field_name_197 {
   struct __anonstruct____missing_field_name_198 __annonCompField63 ;
   struct callback_head callback_head ;
};
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_node {
   unsigned int path ;
   unsigned int count ;
   union __anonunion____missing_field_name_197 __annonCompField64 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/semaphore.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fiemap.h"
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-rwsem.h"
struct bio_set;
#line 28
struct bio;
#line 29
struct bio_integrity_payload;
#line 30
struct block_device;
#line 31
struct cgroup_subsys_state;
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
typedef void bio_end_io_t(struct bio * , int  );
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned int bi_idx ;
   unsigned int bi_bvec_done ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
union __anonunion____missing_field_name_199 {
   struct bio_integrity_payload *bi_integrity ;
};
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blk_types.h"
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
   unsigned int bi_seg_front_size ;
   unsigned int bi_seg_back_size ;
   atomic_t bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_199 __annonCompField65 ;
   unsigned short bi_vcnt ;
   unsigned short bi_max_vecs ;
   atomic_t bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/fs.h"
struct export_operations;
#line 61
struct hd_geometry;
#line 62
struct iovec;
#line 63
struct nameidata;
#line 64
struct kiocb;
#line 65
struct poll_table_struct;
#line 66
struct kstatfs;
#line 67
struct swap_info_struct;
#line 68
struct iov_iter;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_qfilestatv {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
   __u32 qfs_pad ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/dqblk_xfs.h"
struct fs_quota_statv {
   __s8 qs_version ;
   __u8 qs_pad1 ;
   __u16 qs_flags ;
   __u32 qs_incoredqs ;
   struct fs_qfilestatv qs_uquota ;
   struct fs_qfilestatv qs_gquota ;
   struct fs_qfilestatv qs_pquota ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
   __u64 qs_pad2[8U] ;
};
#line 212
struct dquot;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef __kernel_uid32_t projid_t;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
struct __anonstruct_kprojid_t_200 {
   projid_t val ;
};
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/projid.h"
typedef struct __anonstruct_kprojid_t_200 kprojid_t;
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
#line 164
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
typedef long long qsize_t;
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
union __anonunion____missing_field_name_201 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct kqid {
   union __anonunion____missing_field_name_201 __annonCompField66 ;
   enum quota_type type ;
};
#line 183 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
#line 205
struct quota_format_type;
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   struct mem_dqblk dq_dqb ;
};
#line 298 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct qc_dqblk {
   int d_fieldmask ;
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
   int d_spc_warns ;
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
};
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*get_xstatev)(struct super_block * , struct fs_quota_statv * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
#line 384 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
#line 430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[2U] ;
   struct mem_dqinfo info[2U] ;
   struct quota_format_ops  const  *ops[2U] ;
};
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
#line 394 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
   unsigned long nrshadows ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
#line 414
struct hd_struct;
#line 414 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
#line 531
struct posix_acl;
#line 532
struct inode_operations;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_204 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_205 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
#line 532
struct file_lock_context;
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion____missing_field_name_206 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
#line 532 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
   union __anonunion____missing_field_name_204 __annonCompField67 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned long i_state ;
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_205 __annonCompField68 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_206 __annonCompField69 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
#line 768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
};
#line 776 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   unsigned int mmap_miss ;
   loff_t prev_pos ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
union __anonunion_f_u_207 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file {
   union __anonunion_f_u_207 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
typedef void *fl_owner_t;
#line 884
struct file_lock;
#line 885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
#line 891 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   void (*lm_get_owner)(struct file_lock * , struct file_lock * ) ;
   void (*lm_put_owner)(struct file_lock * ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
#line 912
struct nlm_lockowner;
#line 913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_state;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
#line 19
struct fasync_struct;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct __anonstruct_afs_209 {
   struct list_head link ;
   int state ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
union __anonunion_fl_u_208 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_209 afs ;
};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nfs_fs_i.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   int fl_link_cpu ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   unsigned long fl_downgrade_time ;
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_208 fl_u ;
};
#line 965 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
#line 1021 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
#line 1194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
#line 1223
struct super_operations;
#line 1223
struct xattr_handler;
#line 1223
struct mtd_info;
#line 1223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
   unsigned long s_blocksize ;
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
};
#line 1461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
#line 1475
struct dir_context;
#line 1500 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
#line 1506
struct block_device_operations;
#line 1507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   void (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
#line 1570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
   int (*dentry_open)(struct dentry * , struct file * , struct cred  const  * ) ;
};
#line 1624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
#line 1856 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   int insn ;
   int fixup ;
};
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqhandler.h"
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqreturn.h"
typedef enum irqreturn irqreturn_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Addr;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u16 Elf64_Half;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u32 Elf64_Word;
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef __u64 Elf64_Xword;
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elf.h"
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string;
#line 62
struct kparam_array;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
union __anonunion____missing_field_name_218 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   struct kernel_param_ops  const  *ops ;
   u16 perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_218 __annonCompField73 ;
};
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
#line 496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/moduleparam.h"
struct mod_arch_specific {

};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_param_attrs;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
#line 205
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
#line 212
struct module_sect_attrs;
#line 212
struct module_notes_attrs;
#line 212
struct tracepoint;
#line 212
struct ftrace_event_call;
#line 212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
   unsigned int num_unused_gpl_syms ;
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   unsigned int init_ro_size ;
   unsigned int core_ro_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
   unsigned int core_num_syms ;
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
   unsigned int num_tracepoints ;
   struct tracepoint * const  *tracepoints_ptrs ;
   struct jump_entry *jump_entries ;
   unsigned int num_jump_entries ;
   unsigned int num_trace_bprintk_fmt ;
   char const   **trace_bprintk_fmt_start ;
   struct ftrace_event_call **trace_events ;
   unsigned int num_trace_events ;
   unsigned int num_ftrace_callsites ;
   unsigned long *ftrace_callsites ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
   unsigned long time_in_queue ;
};
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
#line 162
struct disk_events;
#line 163
struct timer_rand_state;
#line 163
struct blk_integrity;
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/flex_proportions.h"
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
   raw_spinlock_t lock ;
};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/writeback.h"
enum writeback_sync_modes {
    WB_SYNC_NONE = 0,
    WB_SYNC_ALL = 1
} ;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/writeback.h"
struct writeback_control {
   long nr_to_write ;
   long pages_skipped ;
   loff_t range_start ;
   loff_t range_end ;
   enum writeback_sync_modes sync_mode ;
   unsigned char for_kupdate : 1 ;
   unsigned char for_background : 1 ;
   unsigned char tagged_writepages : 1 ;
   unsigned char for_reclaim : 1 ;
   unsigned char range_cyclic : 1 ;
   unsigned char for_sync : 1 ;
};
#line 88
struct bdi_writeback;
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/backing-dev.h"
typedef int congested_fn(void * , int  );
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/backing-dev.h"
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long last_old_flush ;
   struct delayed_work dwork ;
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
};
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/backing-dev.h"
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   struct percpu_counter bdi_stat[4U] ;
   unsigned long bw_time_stamp ;
   unsigned long dirtied_stamp ;
   unsigned long written_stamp ;
   unsigned long write_bandwidth ;
   unsigned long avg_write_bandwidth ;
   unsigned long dirty_ratelimit ;
   unsigned long balanced_dirty_ratelimit ;
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
   unsigned int min_ratio ;
   unsigned int max_ratio ;
   unsigned int max_prop_frac ;
   struct bdi_writeback wb ;
   spinlock_t wb_lock ;
   struct list_head work_list ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
typedef void *mempool_alloc_t(gfp_t  , void * );
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
typedef void mempool_free_t(void * , void * );
#line 13 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
   int curr_nr ;
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
typedef struct mempool_s mempool_t;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
union __anonunion____missing_field_name_219 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
union __anonunion____missing_field_name_220 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mempool.h"
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_219 __annonCompField74 ;
   union __anonunion____missing_field_name_220 __annonCompField75 ;
   unsigned int flags ;
};
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/iocontext.h"
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
   int nr_batch_requests ;
   unsigned long last_waited ;
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
#line 312 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bio.h"
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
   unsigned short bip_vcnt ;
   unsigned short bip_max_vcnt ;
   unsigned short bip_flags ;
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
#line 525 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bio.h"
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
#line 646 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bio.h"
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/bsg.h"
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/bsg.h"
struct percpu_ref;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-refcount.h"
typedef void percpu_ref_func_t(struct percpu_ref * );
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-refcount.h"
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
#line 328
struct elevator_queue;
#line 330
struct blk_trace;
#line 332
struct bsg_job;
#line 333
struct blkcg_gq;
#line 334
struct blk_flush_queue;
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void rq_end_io_fn(struct request * , int  );
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
#line 71
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_SPECIAL = 7,
    REQ_TYPE_ATA_TASKFILE = 8,
    REQ_TYPE_ATA_PC = 9
} ;
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_221 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
};
#line 83
struct blk_mq_ctx;
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_222 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_223 {
   struct rb_node rb_node ;
   void *completion_data ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct __anonstruct_elv_225 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct __anonstruct_flush_226 {
   unsigned int seq ;
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
union __anonunion____missing_field_name_224 {
   struct __anonstruct_elv_225 elv ;
   struct __anonstruct_flush_226 flush ;
};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_221 __annonCompField76 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_222 __annonCompField77 ;
   union __anonunion____missing_field_name_223 __annonCompField78 ;
   union __anonunion____missing_field_name_224 __annonCompField79 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
   struct request_list *rl ;
   unsigned long long start_time_ns ;
   unsigned long long io_start_time_ns ;
   unsigned short nr_phys_segments ;
   unsigned short nr_integrity_segments ;
   unsigned short ioprio ;
   void *special ;
   int tag ;
   int errors ;
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
   unsigned int extra_len ;
   unsigned int sense_len ;
   unsigned int resid_len ;
   void *sense ;
   unsigned long deadline ;
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/hashtable.h"
struct elevator_type;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_dispatch_fn(struct request_queue * , int  );
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_may_queue_fn(struct request_queue * , int  );
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_init_icq_fn(struct io_cq * );
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_exit_icq_fn(struct io_cq * );
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_put_req_fn(struct request * );
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
typedef void elevator_exit_fn(struct elevator_queue * );
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void request_fn_proc(struct request_queue * );
#line 237 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void make_request_fn(struct request_queue * , struct bio * );
#line 238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int prep_rq_fn(struct request_queue * , struct request * );
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void unprep_rq_fn(struct request_queue * , struct request * );
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
#line 250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef void softirq_done_fn(struct request * );
#line 251 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int dma_drain_needed_fn(struct request * );
#line 252 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int lld_busy_fn(struct request_queue * );
#line 253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int bsg_job_fn(struct bsg_job * );
#line 254
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
   int max_depth ;
   int real_max_depth ;
   atomic_t refcnt ;
   int alloc_policy ;
   int next_tag ;
};
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct queue_limits {
   unsigned long bounce_pfn ;
   unsigned long seg_boundary_mask ;
   unsigned int max_hw_sectors ;
   unsigned int chunk_sectors ;
   unsigned int max_sectors ;
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
   unsigned int alignment_offset ;
   unsigned int io_min ;
   unsigned int io_opt ;
   unsigned int max_discard_sectors ;
   unsigned int max_write_same_sectors ;
   unsigned int discard_granularity ;
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
   unsigned short max_segments ;
   unsigned short max_integrity_segments ;
   unsigned char misaligned ;
   unsigned char discard_misaligned ;
   unsigned char cluster ;
   unsigned char discard_zeroes_data ;
   unsigned char raid_partial_stripes_expensive ;
};
#line 311
struct blk_mq_ops;
#line 311
struct blk_mq_hw_ctx;
#line 311
struct throtl_data;
#line 311
struct blk_mq_tag_set;
#line 311 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
   unsigned int nr_pending ;
   unsigned long nr_requests ;
   unsigned int nr_congestion_on ;
   unsigned int nr_congestion_off ;
   unsigned int nr_batching ;
   unsigned int dma_drain_size ;
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
   unsigned int dma_alignment ;
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
   unsigned int rq_timeout ;
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
   unsigned int sg_reserved_size ;
   int node ;
   struct blk_trace *blk_trace ;
   unsigned int flush_flags ;
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
   int mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
#line 1069 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
#line 1447 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
   unsigned short interval ;
   char const   *disk_name ;
};
#line 1476 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
typedef int integrity_processing_fn(struct blk_integrity_iter * );
#line 1477 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
   unsigned short interval ;
   unsigned short tag_size ;
   char const   *name ;
   struct kobject kobj ;
};
#line 1531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
#line 272 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/cdrom.h"
struct request_sense;
#line 696 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/cdrom.h"
struct request_sense {
   unsigned char error_code : 7 ;
   unsigned char valid : 1 ;
   __u8 segment_number ;
   unsigned char sense_key : 4 ;
   unsigned char reserved2 : 1 ;
   unsigned char ili : 1 ;
   unsigned char reserved1 : 2 ;
   __u8 information[4U] ;
   __u8 add_sense_len ;
   __u8 command_info[4U] ;
   __u8 asc ;
   __u8 ascq ;
   __u8 fruc ;
   __u8 sks[3U] ;
   __u8 asb[46U] ;
};
#line 320 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cdrom.h"
union __anonunion____missing_field_name_235 {
   unsigned long error_addr ;
   unsigned long feature_addr ;
};
#line 320 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cdrom.h"
union __anonunion____missing_field_name_236 {
   unsigned long status_addr ;
   unsigned long command_addr ;
};
#line 320 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cdrom.h"
struct ide_io_ports {
   unsigned long data_addr ;
   union __anonunion____missing_field_name_235 __annonCompField80 ;
   unsigned long nsect_addr ;
   unsigned long lbal_addr ;
   unsigned long lbam_addr ;
   unsigned long lbah_addr ;
   unsigned long device_addr ;
   union __anonunion____missing_field_name_236 __annonCompField81 ;
   unsigned long ctl_addr ;
   unsigned long irq_addr ;
};
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
typedef u8 hwif_chipset_t;
#line 199
enum ldv_28239 {
    ide_stopped = 0,
    ide_started = 1
} ;
#line 222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
typedef enum ldv_28239 ide_startstop_t;
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
union __anonunion____missing_field_name_238 {
   u8 error ;
   u8 feature ;
};
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
union __anonunion____missing_field_name_239 {
   u8 status ;
   u8 command ;
};
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_taskfile {
   u8 data ;
   union __anonunion____missing_field_name_238 __annonCompField83 ;
   u8 nsect ;
   u8 lbal ;
   u8 lbam ;
   u8 lbah ;
   u8 device ;
   union __anonunion____missing_field_name_239 __annonCompField84 ;
};
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct __anonstruct_out_241 {
   u8 tf ;
   u8 hob ;
};
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct __anonstruct_in_242 {
   u8 tf ;
   u8 hob ;
};
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct __anonstruct_valid_240 {
   struct __anonstruct_out_241 out ;
   struct __anonstruct_in_242 in ;
};
#line 283 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_cmd {
   struct ide_taskfile tf ;
   struct ide_taskfile hob ;
   struct __anonstruct_valid_240 valid ;
   u16 tf_flags ;
   u8 ftf_flags ;
   int protocol ;
   int sg_nents ;
   int orig_sg_nents ;
   int sg_dma_direction ;
   unsigned int nbytes ;
   unsigned int nleft ;
   unsigned int last_xfer_len ;
   struct scatterlist *cursg ;
   unsigned int cursg_ofs ;
   struct request *rq ;
};
#line 321 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_atapi_pc {
   u8 c[12U] ;
   int retries ;
   int error ;
   int req_xfer ;
   struct request *rq ;
   unsigned long flags ;
   unsigned long timeout ;
};
#line 347
struct ide_devset;
#line 348
struct ide_driver;
#line 349
struct ide_acpi_drive_link;
#line 350
struct ide_acpi_hwif_link;
#line 351
struct ide_drive_s;
#line 352 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_disk_ops {
   int (*check)(struct ide_drive_s * , char const   * ) ;
   int (*get_capacity)(struct ide_drive_s * ) ;
   void (*unlock_native_capacity)(struct ide_drive_s * ) ;
   void (*setup)(struct ide_drive_s * ) ;
   void (*flush)(struct ide_drive_s * ) ;
   int (*init_media)(struct ide_drive_s * , struct gendisk * ) ;
   int (*set_doorlock)(struct ide_drive_s * , struct gendisk * , int  ) ;
   ide_startstop_t (*do_request)(struct ide_drive_s * , struct request * , sector_t  ) ;
   int (*ioctl)(struct ide_drive_s * , struct block_device * , fmode_t  , unsigned int  ,
                unsigned long  ) ;
};
#line 433
struct ide_proc_devset;
#line 433
struct hwif_s;
#line 433 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_drive_s {
   char name[4U] ;
   char driver_req[10U] ;
   struct request_queue *queue ;
   struct request *rq ;
   void *driver_data ;
   u16 *id ;
   struct proc_dir_entry *proc ;
   struct ide_proc_devset  const  *settings ;
   struct hwif_s *hwif ;
   struct ide_disk_ops  const  *disk_ops ;
   unsigned long dev_flags ;
   unsigned long sleep ;
   unsigned long timeout ;
   u8 special_flags ;
   u8 select ;
   u8 retry_pio ;
   u8 waiting_for_dma ;
   u8 dma ;
   u8 init_speed ;
   u8 current_speed ;
   u8 desired_speed ;
   u8 pio_mode ;
   u8 dma_mode ;
   u8 dn ;
   u8 acoustic ;
   u8 media ;
   u8 ready_stat ;
   u8 mult_count ;
   u8 mult_req ;
   u8 io_32bit ;
   u8 bad_wstat ;
   u8 head ;
   u8 sect ;
   u8 bios_head ;
   u8 bios_sect ;
   u8 pc_delay ;
   unsigned int bios_cyl ;
   unsigned int cyl ;
   void *drive_data ;
   unsigned int failures ;
   unsigned int max_failures ;
   u64 probed_capacity ;
   u64 capacity64 ;
   int lun ;
   int crc_count ;
   unsigned long debug_mask ;
   struct ide_acpi_drive_link *acpidata ;
   struct list_head list ;
   struct device gendev ;
   struct completion gendev_rel_comp ;
   struct ide_atapi_pc *pc ;
   struct ide_atapi_pc *failed_pc ;
   int (*pc_callback)(struct ide_drive_s * , int  ) ;
   ide_startstop_t (*irq_handler)(struct ide_drive_s * ) ;
   unsigned long atapi_flags ;
   struct ide_atapi_pc request_sense_pc ;
   bool sense_rq_armed ;
   struct request sense_rq ;
   struct request_sense sense_data ;
};
#line 573 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
typedef struct ide_drive_s ide_drive_t;
#line 575 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_tp_ops {
   void (*exec_command)(struct hwif_s * , u8  ) ;
   u8 (*read_status)(struct hwif_s * ) ;
   u8 (*read_altstatus)(struct hwif_s * ) ;
   void (*write_devctl)(struct hwif_s * , u8  ) ;
   void (*dev_select)(ide_drive_t * ) ;
   void (*tf_load)(ide_drive_t * , struct ide_taskfile * , u8  ) ;
   void (*tf_read)(ide_drive_t * , struct ide_taskfile * , u8  ) ;
   void (*input_data)(ide_drive_t * , struct ide_cmd * , void * , unsigned int  ) ;
   void (*output_data)(ide_drive_t * , struct ide_cmd * , void * , unsigned int  ) ;
};
#line 602 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_port_ops {
   void (*init_dev)(ide_drive_t * ) ;
   void (*set_pio_mode)(struct hwif_s * , ide_drive_t * ) ;
   void (*set_dma_mode)(struct hwif_s * , ide_drive_t * ) ;
   int (*reset_poll)(ide_drive_t * ) ;
   void (*pre_reset)(ide_drive_t * ) ;
   void (*resetproc)(ide_drive_t * ) ;
   void (*maskproc)(ide_drive_t * , int  ) ;
   void (*quirkproc)(ide_drive_t * ) ;
   void (*clear_irq)(ide_drive_t * ) ;
   int (*test_irq)(struct hwif_s * ) ;
   u8 (*mdma_filter)(ide_drive_t * ) ;
   u8 (*udma_filter)(ide_drive_t * ) ;
   u8 (*cable_detect)(struct hwif_s * ) ;
};
#line 638 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_dma_ops {
   void (*dma_host_set)(struct ide_drive_s * , int  ) ;
   int (*dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
   void (*dma_start)(struct ide_drive_s * ) ;
   int (*dma_end)(struct ide_drive_s * ) ;
   int (*dma_test_irq)(struct ide_drive_s * ) ;
   void (*dma_lost_irq)(struct ide_drive_s * ) ;
   int (*dma_check)(struct ide_drive_s * , struct ide_cmd * ) ;
   int (*dma_timer_expiry)(struct ide_drive_s * ) ;
   void (*dma_clear)(struct ide_drive_s * ) ;
   u8 (*dma_sff_read_status)(struct hwif_s * ) ;
};
#line 660
struct ide_host;
#line 661 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct hwif_s {
   struct hwif_s *mate ;
   struct proc_dir_entry *proc ;
   struct ide_host *host ;
   char name[6U] ;
   struct ide_io_ports io_ports ;
   unsigned long sata_scr[3U] ;
   ide_drive_t *devices[3U] ;
   unsigned long port_flags ;
   u8 major ;
   u8 index ;
   u8 channel ;
   u32 host_flags ;
   u8 pio_mask ;
   u8 ultra_mask ;
   u8 mwdma_mask ;
   u8 swdma_mask ;
   u8 cbl ;
   hwif_chipset_t chipset ;
   struct device *dev ;
   void (*rw_disk)(ide_drive_t * , struct request * ) ;
   struct ide_tp_ops  const  *tp_ops ;
   struct ide_port_ops  const  *port_ops ;
   struct ide_dma_ops  const  *dma_ops ;
   unsigned int *dmatable_cpu ;
   dma_addr_t dmatable_dma ;
   int prd_max_nents ;
   int prd_ent_size ;
   struct scatterlist *sg_table ;
   int sg_max_nents ;
   struct ide_cmd cmd ;
   int rqsize ;
   int irq ;
   unsigned long dma_base ;
   unsigned long config_data ;
   unsigned long select_data ;
   unsigned long extra_base ;
   unsigned int extra_ports ;
   unsigned char present : 1 ;
   unsigned char busy : 1 ;
   struct device gendev ;
   struct device *portdev ;
   struct completion gendev_rel_comp ;
   void *hwif_data ;
   struct ide_acpi_hwif_link *acpidata ;
   ide_startstop_t (*handler)(ide_drive_t * ) ;
   unsigned char polling : 1 ;
   ide_drive_t *cur_dev ;
   struct request *rq ;
   struct timer_list timer ;
   unsigned long poll_timeout ;
   int (*expiry)(ide_drive_t * ) ;
   int req_gen ;
   int req_gen_timer ;
   spinlock_t lock ;
};
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
typedef struct hwif_s ide_hwif_t;
#line 768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_host {
   ide_hwif_t *ports[5U] ;
   unsigned int n_ports ;
   struct device *dev[2U] ;
   int (*init_chipset)(struct pci_dev * ) ;
   void (*get_lock)(irqreturn_t (*)(int  , void * ) , void * ) ;
   void (*release_lock)(void) ;
   irqreturn_t (*irq_handler)(int  , void * ) ;
   unsigned long host_flags ;
   int irq_flags ;
   void *host_priv ;
   ide_hwif_t *cur_port ;
   unsigned long volatile   host_busy ;
};
#line 806 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_devset {
   int (*get)(ide_drive_t * ) ;
   int (*set)(ide_drive_t * , int  ) ;
   unsigned int flags ;
};
#line 881 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_proc_devset {
   char const   *name ;
   struct ide_devset  const  *setting ;
   int min ;
   int max ;
   int (*mulf)(ide_drive_t * ) ;
   int (*divf)(ide_drive_t * ) ;
};
#line 921 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct __anonstruct_ide_proc_entry_t_243 {
   char const   *name ;
   umode_t mode ;
   struct file_operations  const  *proc_fops ;
};
#line 921 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
typedef struct __anonstruct_ide_proc_entry_t_243 ide_proc_entry_t;
#line 1006 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_driver {
   char const   *version ;
   ide_startstop_t (*do_request)(ide_drive_t * , struct request * , sector_t  ) ;
   struct device_driver gen_driver ;
   int (*probe)(ide_drive_t * ) ;
   void (*remove)(ide_drive_t * ) ;
   void (*resume)(ide_drive_t * ) ;
   void (*shutdown)(ide_drive_t * ) ;
   ide_proc_entry_t *(*proc_entries)(ide_drive_t * ) ;
   struct ide_proc_devset  const  *(*proc_devsets)(ide_drive_t * ) ;
};
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 237 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
struct chs_geom {
   unsigned int cyl ;
   u8 head ;
   u8 sect ;
};
#line 612 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_struct_interrupt_instance_11 {
   int arg0 ;
   enum irqreturn (*arg1)(int  , void * ) ;
   enum irqreturn (*arg2)(int  , void * ) ;
   void *arg3 ;
   int signal_pending ;
};
#line 620 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_struct_platform_instance_13 {
   int signal_pending ;
};
#line 624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_struct_timer_instance_36 {
   struct timer_list *arg0 ;
   int signal_pending ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 1031 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_ioctl_devset {
   unsigned int get_ioctl ;
   unsigned int set_ioctl ;
   struct ide_devset  const  *setting ;
};
#line 424 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/pgtable_types.h"
struct paravirt_callee_save {
   void *func ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/percpu-refcount.h"
struct request_pm_state;
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
struct request_pm_state {
   int pm_step ;
   u32 pm_state ;
   void *data ;
};
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
typedef ide_startstop_t ide_handler_t(ide_drive_t * );
#line 800 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
typedef int ide_expiry_t(ide_drive_t * );
#line 1521 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
typedef int ldv_func_ret_type___0;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 1332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct drive_list_entry {
   char const   *id_model ;
   char const   *id_firmware ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
union __anonunion____missing_field_name_237 {
   struct ide_io_ports io_ports ;
   unsigned long io_ports_array[10U] ;
};
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_hw {
   union __anonunion____missing_field_name_237 __annonCompField82 ;
   int irq ;
   struct device *dev ;
   struct device *parent ;
   unsigned long config ;
};
#line 574
struct ide_port_info;
#line 1195 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_pci_enablebit {
   u8 reg ;
   u8 mask ;
   u8 val ;
};
#line 1243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_port_info {
   char *name ;
   int (*init_chipset)(struct pci_dev * ) ;
   void (*get_lock)(irqreturn_t (*)(int  , void * ) , void * ) ;
   void (*release_lock)(void) ;
   void (*init_iops)(ide_hwif_t * ) ;
   void (*init_hwif)(ide_hwif_t * ) ;
   int (*init_dma)(ide_hwif_t * , struct ide_port_info  const  * ) ;
   struct ide_tp_ops  const  *tp_ops ;
   struct ide_port_ops  const  *port_ops ;
   struct ide_dma_ops  const  *dma_ops ;
   struct ide_pci_enablebit enablebits[2U] ;
   hwif_chipset_t chipset ;
   u16 max_sectors ;
   u32 host_flags ;
   int irq_flags ;
   u8 pio_mask ;
   u8 swdma_mask ;
   u8 mwdma_mask ;
   u8 udma_mask ;
};
#line 1611 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct ldv_struct_free_irq_39 {
   int arg0 ;
   int signal_pending ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
typedef int pao_T__;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
typedef int pao_T_____0;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
struct __anonstruct_b_214 {
   unsigned char data : 1 ;
   unsigned char error_feature : 1 ;
   unsigned char sector : 1 ;
   unsigned char nsector : 1 ;
   unsigned char lcyl : 1 ;
   unsigned char hcyl : 1 ;
   unsigned char select : 1 ;
   unsigned char status_command : 1 ;
   unsigned char data_hob : 1 ;
   unsigned char error_feature_hob : 1 ;
   unsigned char sector_hob : 1 ;
   unsigned char nsector_hob : 1 ;
   unsigned char lcyl_hob : 1 ;
   unsigned char hcyl_hob : 1 ;
   unsigned char select_hob : 1 ;
   unsigned char control_hob : 1 ;
};
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
union ide_reg_valid_s {
   unsigned short all ;
   struct __anonstruct_b_214 b ;
};
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdreg.h"
typedef union ide_reg_valid_s ide_reg_valid_t;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdreg.h"
struct ide_task_request_s {
   __u8 io_ports[8U] ;
   __u8 hob_ports[8U] ;
   ide_reg_valid_t out_flags ;
   ide_reg_valid_t in_flags ;
   int data_phase ;
   int req_cmd ;
   unsigned long out_size ;
   unsigned long in_size ;
};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/hdreg.h"
typedef struct ide_task_request_s ide_task_request_t;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 1543 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_pio_info {
   char const   *name ;
   int pio ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 1458 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_timing {
   u8 mode ;
   u8 setup ;
   u16 act8b ;
   u16 rec8b ;
   u16 cyc8b ;
   u16 active ;
   u16 recover ;
   u16 cycle ;
   u16 udma ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/types.h"
typedef unsigned long ulong;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u32 __le32;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/types.h"
typedef __u16 __le16;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 255
enum hrtimer_restart;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/property.h"
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2
} ;
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/property.h"
struct fwnode_handle {
   enum fwnode_type type ;
};
#line 162 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef u64 acpi_size;
#line 163 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef u64 acpi_io_address;
#line 428 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef u32 acpi_status;
#line 430 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef char *acpi_string;
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef void *acpi_handle;
#line 628 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
typedef u32 acpi_object_type;
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_integer_214 {
   acpi_object_type type ;
   u64 value ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_string_215 {
   acpi_object_type type ;
   u32 length ;
   char *pointer ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_buffer_216 {
   acpi_object_type type ;
   u32 length ;
   u8 *pointer ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_package_217 {
   acpi_object_type type ;
   u32 count ;
   union acpi_object *elements ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_reference_218 {
   acpi_object_type type ;
   acpi_object_type actual_type ;
   acpi_handle handle ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_processor_219 {
   acpi_object_type type ;
   u32 proc_id ;
   acpi_io_address pblk_address ;
   u32 pblk_length ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct __anonstruct_power_resource_220 {
   acpi_object_type type ;
   u32 system_level ;
   u32 resource_order ;
};
#line 884 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
union acpi_object {
   acpi_object_type type ;
   struct __anonstruct_integer_214 integer ;
   struct __anonstruct_string_215 string ;
   struct __anonstruct_buffer_216 buffer ;
   struct __anonstruct_package_217 package ;
   struct __anonstruct_reference_218 reference ;
   struct __anonstruct_processor_219 processor ;
   struct __anonstruct_power_resource_220 power_resource ;
};
#line 937 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct acpi_object_list {
   u32 count ;
   union acpi_object *pointer ;
};
#line 945 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct acpi_buffer {
   acpi_size length ;
   void *pointer ;
};
#line 1111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct acpi_pnp_device_id {
   u32 length ;
   char *string ;
};
#line 1135 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct acpi_pnp_device_id_list {
   u32 count ;
   u32 list_size ;
   struct acpi_pnp_device_id ids[1U] ;
};
#line 1141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/actypes.h"
struct acpi_device_info {
   u32 info_size ;
   u32 name ;
   acpi_object_type type ;
   u8 param_count ;
   u8 valid ;
   u8 flags ;
   u8 highest_dstates[4U] ;
   u8 lowest_dstates[5U] ;
   u32 current_status ;
   u64 address ;
   struct acpi_pnp_device_id hardware_id ;
   struct acpi_pnp_device_id unique_id ;
   struct acpi_pnp_device_id subsystem_id ;
   struct acpi_pnp_device_id_list compatible_id_list ;
};
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_driver;
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_hotplug_profile {
   struct kobject kobj ;
   int (*scan_dependent)(struct acpi_device * ) ;
   void (*notify_online)(struct acpi_device * ) ;
   bool enabled ;
   bool demand_offline ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_scan_handler {
   struct acpi_device_id  const  *ids ;
   struct list_head list_node ;
   bool (*match)(char * , struct acpi_device_id  const  ** ) ;
   int (*attach)(struct acpi_device * , struct acpi_device_id  const  * ) ;
   void (*detach)(struct acpi_device * ) ;
   void (*bind)(struct device * ) ;
   void (*unbind)(struct device * ) ;
   struct acpi_hotplug_profile hotplug ;
};
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_hotplug_context {
   struct acpi_device *self ;
   int (*notify)(struct acpi_device * , u32  ) ;
   void (*uevent)(struct acpi_device * , u32  ) ;
   void (*fixup)(struct acpi_device * ) ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_ops {
   int (*add)(struct acpi_device * ) ;
   int (*remove)(struct acpi_device * ) ;
   void (*notify)(struct acpi_device * , u32  ) ;
};
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_driver {
   char name[80U] ;
   char class[80U] ;
   struct acpi_device_id  const  *ids ;
   unsigned int flags ;
   struct acpi_device_ops ops ;
   struct device_driver drv ;
   struct module *owner ;
};
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_status {
   unsigned char present : 1 ;
   unsigned char enabled : 1 ;
   unsigned char show_in_ui : 1 ;
   unsigned char functional : 1 ;
   unsigned char battery_present : 1 ;
   unsigned int reserved : 27 ;
};
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_flags {
   unsigned char dynamic_status : 1 ;
   unsigned char removable : 1 ;
   unsigned char ejectable : 1 ;
   unsigned char power_manageable : 1 ;
   unsigned char match_driver : 1 ;
   unsigned char initialized : 1 ;
   unsigned char visited : 1 ;
   unsigned char hotplug_notify : 1 ;
   unsigned char is_dock_station : 1 ;
   unsigned int reserved : 23 ;
};
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_dir {
   struct proc_dir_entry *entry ;
};
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
typedef char acpi_bus_id[8U];
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
typedef unsigned long acpi_bus_address;
#line 226 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
typedef char acpi_device_name[40U];
#line 227 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
typedef char acpi_device_class[20U];
#line 233 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_pnp_type {
   unsigned char hardware_id : 1 ;
   unsigned char bus_address : 1 ;
   unsigned char platform_id : 1 ;
   unsigned int reserved : 29 ;
};
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_pnp {
   acpi_bus_id bus_id ;
   struct acpi_pnp_type type ;
   acpi_bus_address bus_address ;
   char *unique_id ;
   struct list_head ids ;
   acpi_device_name device_name ;
   acpi_device_class device_class ;
   union acpi_object *str_obj ;
};
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_power_flags {
   unsigned char explicit_get : 1 ;
   unsigned char power_resources : 1 ;
   unsigned char inrush_current : 1 ;
   unsigned char power_removed : 1 ;
   unsigned char ignore_parent : 1 ;
   unsigned char dsw_present : 1 ;
   unsigned int reserved : 26 ;
};
#line 269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct __anonstruct_flags_221 {
   unsigned char valid : 1 ;
   unsigned char os_accessible : 1 ;
   unsigned char explicit_set : 1 ;
   unsigned char reserved : 6 ;
};
#line 269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_power_state {
   struct __anonstruct_flags_221 flags ;
   int power ;
   int latency ;
   struct list_head resources ;
};
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_power {
   int state ;
   struct acpi_device_power_flags flags ;
   struct acpi_device_power_state states[5U] ;
};
#line 287 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_perf_flags {
   u8 reserved ;
};
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct __anonstruct_flags_222 {
   unsigned char valid : 1 ;
   unsigned char reserved : 7 ;
};
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_perf_state {
   struct __anonstruct_flags_222 flags ;
   u8 power ;
   u8 performance ;
   int latency ;
};
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_perf {
   int state ;
   struct acpi_device_perf_flags flags ;
   int state_count ;
   struct acpi_device_perf_state *states ;
};
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_wakeup_flags {
   unsigned char valid : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char notifier_present : 1 ;
   unsigned char enabled : 1 ;
};
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_wakeup_context {
   struct work_struct work ;
   struct device *dev ;
};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_wakeup {
   acpi_handle gpe_device ;
   u64 gpe_number ;
   u64 sleep_state ;
   struct list_head resources ;
   struct acpi_device_wakeup_flags flags ;
   struct acpi_device_wakeup_context context ;
   struct wakeup_source *ws ;
   int prepare_count ;
};
#line 341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device_data {
   union acpi_object  const  *pointer ;
   union acpi_object  const  *properties ;
   union acpi_object  const  *of_compatible ;
};
#line 348
struct acpi_gpio_mapping;
#line 349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
struct acpi_device {
   int device_type ;
   acpi_handle handle ;
   struct fwnode_handle fwnode ;
   struct acpi_device *parent ;
   struct list_head children ;
   struct list_head node ;
   struct list_head wakeup_list ;
   struct list_head del_list ;
   struct acpi_device_status status ;
   struct acpi_device_flags flags ;
   struct acpi_device_pnp pnp ;
   struct acpi_device_power power ;
   struct acpi_device_wakeup wakeup ;
   struct acpi_device_perf performance ;
   struct acpi_device_dir dir ;
   struct acpi_device_data data ;
   struct acpi_scan_handler *handler ;
   struct acpi_hotplug_context *hp ;
   struct acpi_driver *driver ;
   struct acpi_gpio_mapping  const  *driver_gpios ;
   void *driver_data ;
   struct device dev ;
   unsigned int physical_node_count ;
   unsigned int dep_unmet ;
   struct list_head physical_node_list ;
   struct mutex physical_node_lock ;
   void (*remove)(struct acpi_device * ) ;
};
#line 638 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/acpi.h"
struct acpi_gpio_params {
   unsigned int crs_entry_index ;
   unsigned int line_index ;
   bool active_low ;
};
#line 691 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/acpi.h"
struct acpi_gpio_mapping {
   char const   *name ;
   struct acpi_gpio_params  const  *data ;
   unsigned int size ;
};
#line 641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
struct GTM_buffer {
   u32 PIO_speed0 ;
   u32 DMA_speed0 ;
   u32 PIO_speed1 ;
   u32 DMA_speed1 ;
   u32 GTM_flags ;
};
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
struct ide_acpi_drive_link {
   acpi_handle obj_handle ;
   u8 idbuff[512U] ;
};
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
struct ide_acpi_hwif_link {
   ide_hwif_t *hwif ;
   acpi_handle obj_handle ;
   struct GTM_buffer gtm ;
   struct ide_acpi_drive_link master ;
   struct ide_acpi_drive_link slave ;
};
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct device_private {
   void *driver_data ;
};
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/int-ll64.h"
typedef short s16;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_worker {
   spinlock_t lock ;
   struct list_head work_list ;
   struct task_struct *task ;
   struct kthread_work *current_work ;
};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kthread.h"
struct kthread_work {
   struct list_head node ;
   void (*func)(struct kthread_work * ) ;
   struct kthread_worker *worker ;
};
#line 351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
struct dma_chan;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_device {
   struct device dev ;
   struct spi_master *master ;
   u32 max_speed_hz ;
   u8 chip_select ;
   u8 bits_per_word ;
   u16 mode ;
   int irq ;
   void *controller_state ;
   void *controller_data ;
   char modalias[32U] ;
   int cs_gpio ;
};
#line 151
struct spi_message;
#line 152
struct spi_transfer;
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_master {
   struct device dev ;
   struct list_head list ;
   s16 bus_num ;
   u16 num_chipselect ;
   u16 dma_alignment ;
   u16 mode_bits ;
   u32 bits_per_word_mask ;
   u32 min_speed_hz ;
   u32 max_speed_hz ;
   u16 flags ;
   spinlock_t bus_lock_spinlock ;
   struct mutex bus_lock_mutex ;
   bool bus_lock_flag ;
   int (*setup)(struct spi_device * ) ;
   int (*transfer)(struct spi_device * , struct spi_message * ) ;
   void (*cleanup)(struct spi_device * ) ;
   bool (*can_dma)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   bool queued ;
   struct kthread_worker kworker ;
   struct task_struct *kworker_task ;
   struct kthread_work pump_messages ;
   spinlock_t queue_lock ;
   struct list_head queue ;
   struct spi_message *cur_msg ;
   bool idling ;
   bool busy ;
   bool running ;
   bool rt ;
   bool auto_runtime_pm ;
   bool cur_msg_prepared ;
   bool cur_msg_mapped ;
   struct completion xfer_completion ;
   size_t max_dma_len ;
   int (*prepare_transfer_hardware)(struct spi_master * ) ;
   int (*transfer_one_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_transfer_hardware)(struct spi_master * ) ;
   int (*prepare_message)(struct spi_master * , struct spi_message * ) ;
   int (*unprepare_message)(struct spi_master * , struct spi_message * ) ;
   void (*set_cs)(struct spi_device * , bool  ) ;
   int (*transfer_one)(struct spi_master * , struct spi_device * , struct spi_transfer * ) ;
   int *cs_gpios ;
   struct dma_chan *dma_tx ;
   struct dma_chan *dma_rx ;
   void *dummy_rx ;
   void *dummy_tx ;
};
#line 506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_transfer {
   void const   *tx_buf ;
   void *rx_buf ;
   unsigned int len ;
   dma_addr_t tx_dma ;
   dma_addr_t rx_dma ;
   struct sg_table tx_sg ;
   struct sg_table rx_sg ;
   unsigned char cs_change : 1 ;
   unsigned char tx_nbits : 3 ;
   unsigned char rx_nbits : 3 ;
   u8 bits_per_word ;
   u16 delay_usecs ;
   u32 speed_hz ;
   struct list_head transfer_list ;
};
#line 630 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spi/spi.h"
struct spi_message {
   struct list_head transfers ;
   struct spi_device *spi ;
   unsigned char is_dma_mapped : 1 ;
   void (*complete)(void * ) ;
   void *context ;
   unsigned int frame_length ;
   unsigned int actual_length ;
   int status ;
   struct list_head queue ;
   void *state ;
};
#line 264 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/rcupdate.h"
struct notifier_block;
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
enum hrtimer_restart;
#line 720 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pm.h"
struct ratelimit_state {
   raw_spinlock_t lock ;
   int interval ;
   int burst ;
   int printed ;
   int missed ;
   unsigned long begin ;
};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/notifier.h"
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
};
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/pm.h"
typedef unsigned int mmc_pm_flag_t;
#line 26
struct mmc_card;
#line 27
struct sdio_func;
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
typedef void sdio_irq_handler_t(struct sdio_func * );
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func_tuple {
   struct sdio_func_tuple *next ;
   unsigned char code ;
   unsigned char size ;
   unsigned char data[0U] ;
};
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct sdio_func {
   struct mmc_card *card ;
   struct device dev ;
   sdio_irq_handler_t *irq_handler ;
   unsigned int num ;
   unsigned char class ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned int max_blksize ;
   unsigned int cur_blksize ;
   unsigned int enable_timeout ;
   unsigned int state ;
   u8 tmpbuf[4U] ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
};
#line 161
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
} ;
#line 167
struct led_trigger;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/sdio_func.h"
struct led_classdev {
   char const   *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev * , enum led_brightness  ) ;
   int (*brightness_set_sync)(struct led_classdev * , enum led_brightness  ) ;
   enum led_brightness (*brightness_get)(struct led_classdev * ) ;
   int (*blink_set)(struct led_classdev * , unsigned long * , unsigned long * ) ;
   struct device *dev ;
   struct attribute_group  const  **groups ;
   struct list_head node ;
   char const   *default_trigger ;
   unsigned long blink_delay_on ;
   unsigned long blink_delay_off ;
   struct timer_list blink_timer ;
   int blink_brightness ;
   void (*flash_resume)(struct led_classdev * ) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/leds.h"
struct led_trigger {
   char const   *name ;
   void (*activate)(struct led_classdev * ) ;
   void (*deactivate)(struct led_classdev * ) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};
#line 119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/debugfs.h"
struct fault_attr {
   unsigned long probability ;
   unsigned long interval ;
   atomic_t times ;
   atomic_t space ;
   unsigned long verbose ;
   u32 task_filter ;
   unsigned long stacktrace_depth ;
   unsigned long require_start ;
   unsigned long require_end ;
   unsigned long reject_start ;
   unsigned long reject_end ;
   unsigned long count ;
   struct ratelimit_state ratelimit_state ;
   struct dentry *dname ;
};
#line 653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_data;
#line 654
struct mmc_request;
#line 655 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
struct mmc_command {
   u32 opcode ;
   u32 arg ;
   u32 resp[4U] ;
   unsigned int flags ;
   unsigned int retries ;
   unsigned int error ;
   unsigned int busy_timeout ;
   bool sanitize_busy ;
   struct mmc_data *data ;
   struct mmc_request *mrq ;
};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_data {
   unsigned int timeout_ns ;
   unsigned int timeout_clks ;
   unsigned int blksz ;
   unsigned int blocks ;
   unsigned int error ;
   unsigned int flags ;
   unsigned int bytes_xfered ;
   struct mmc_command *stop ;
   struct mmc_request *mrq ;
   unsigned int sg_len ;
   struct scatterlist *sg ;
   s32 host_cookie ;
};
#line 127
struct mmc_host;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_request {
   struct mmc_command *sbc ;
   struct mmc_command *cmd ;
   struct mmc_data *data ;
   struct mmc_command *stop ;
   struct completion completion ;
   void (*done)(struct mmc_request * ) ;
   struct mmc_host *host ;
};
#line 139
struct mmc_async_req;
#line 214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/core.h"
struct mmc_cid {
   unsigned int manfid ;
   char prod_name[8U] ;
   unsigned char prv ;
   unsigned int serial ;
   unsigned short oemid ;
   unsigned short year ;
   unsigned char hwrev ;
   unsigned char fwrev ;
   unsigned char month ;
};
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_csd {
   unsigned char structure ;
   unsigned char mmca_vsn ;
   unsigned short cmdclass ;
   unsigned short tacc_clks ;
   unsigned int tacc_ns ;
   unsigned int c_size ;
   unsigned int r2w_factor ;
   unsigned int max_dtr ;
   unsigned int erase_size ;
   unsigned int read_blkbits ;
   unsigned int write_blkbits ;
   unsigned int capacity ;
   unsigned char read_partial : 1 ;
   unsigned char read_misalign : 1 ;
   unsigned char write_partial : 1 ;
   unsigned char write_misalign : 1 ;
   unsigned char dsr_imp : 1 ;
};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ext_csd {
   u8 rev ;
   u8 erase_group_def ;
   u8 sec_feature_support ;
   u8 rel_sectors ;
   u8 rel_param ;
   u8 part_config ;
   u8 cache_ctrl ;
   u8 rst_n_function ;
   u8 max_packed_writes ;
   u8 max_packed_reads ;
   u8 packed_event_en ;
   unsigned int part_time ;
   unsigned int sa_timeout ;
   unsigned int generic_cmd6_time ;
   unsigned int power_off_longtime ;
   u8 power_off_notification ;
   unsigned int hs_max_dtr ;
   unsigned int hs200_max_dtr ;
   unsigned int sectors ;
   unsigned int hc_erase_size ;
   unsigned int hc_erase_timeout ;
   unsigned int sec_trim_mult ;
   unsigned int sec_erase_mult ;
   unsigned int trim_timeout ;
   bool partition_setting_completed ;
   unsigned long long enhanced_area_offset ;
   unsigned int enhanced_area_size ;
   unsigned int cache_size ;
   bool hpi_en ;
   bool hpi ;
   unsigned int hpi_cmd ;
   bool bkops ;
   bool man_bkops_en ;
   unsigned int data_sector_size ;
   unsigned int data_tag_unit_size ;
   unsigned int boot_ro_lock ;
   bool boot_ro_lockable ;
   bool ffu_capable ;
   u8 fwrev[8U] ;
   u8 raw_exception_status ;
   u8 raw_partition_support ;
   u8 raw_rpmb_size_mult ;
   u8 raw_erased_mem_count ;
   u8 raw_ext_csd_structure ;
   u8 raw_card_type ;
   u8 out_of_int_time ;
   u8 raw_pwr_cl_52_195 ;
   u8 raw_pwr_cl_26_195 ;
   u8 raw_pwr_cl_52_360 ;
   u8 raw_pwr_cl_26_360 ;
   u8 raw_s_a_timeout ;
   u8 raw_hc_erase_gap_size ;
   u8 raw_erase_timeout_mult ;
   u8 raw_hc_erase_grp_size ;
   u8 raw_sec_trim_mult ;
   u8 raw_sec_erase_mult ;
   u8 raw_sec_feature_support ;
   u8 raw_trim_mult ;
   u8 raw_pwr_cl_200_195 ;
   u8 raw_pwr_cl_200_360 ;
   u8 raw_pwr_cl_ddr_52_195 ;
   u8 raw_pwr_cl_ddr_52_360 ;
   u8 raw_pwr_cl_ddr_200_360 ;
   u8 raw_bkops_status ;
   u8 raw_sectors[4U] ;
   unsigned int feature_support ;
};
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_scr {
   unsigned char sda_vsn ;
   unsigned char sda_spec3 ;
   unsigned char bus_widths ;
   unsigned char cmds ;
};
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_ssr {
   unsigned int au ;
   unsigned int erase_timeout ;
   unsigned int erase_offset ;
};
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sd_switch_caps {
   unsigned int hs_max_dtr ;
   unsigned int uhs_max_dtr ;
   unsigned int sd3_bus_mode ;
   unsigned int sd3_drv_type ;
   unsigned int sd3_curr_limit ;
};
#line 172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cccr {
   unsigned int sdio_vsn ;
   unsigned int sd_vsn ;
   unsigned char multi_block : 1 ;
   unsigned char low_speed : 1 ;
   unsigned char wide_bus : 1 ;
   unsigned char high_power : 1 ;
   unsigned char high_speed : 1 ;
   unsigned char disable_cd : 1 ;
};
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct sdio_cis {
   unsigned short vendor ;
   unsigned short device ;
   unsigned short blksize ;
   unsigned int max_dtr ;
};
#line 200
struct mmc_ios;
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_part {
   unsigned int size ;
   unsigned int part_cfg ;
   char name[20U] ;
   bool force_ro ;
   unsigned int area_type ;
};
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_card {
   struct mmc_host *host ;
   struct device dev ;
   u32 ocr ;
   unsigned int rca ;
   unsigned int type ;
   unsigned int state ;
   unsigned int quirks ;
   unsigned int erase_size ;
   unsigned int erase_shift ;
   unsigned int pref_erase ;
   u8 erased_byte ;
   u32 raw_cid[4U] ;
   u32 raw_csd[4U] ;
   u32 raw_scr[2U] ;
   struct mmc_cid cid ;
   struct mmc_csd csd ;
   struct mmc_ext_csd ext_csd ;
   struct sd_scr scr ;
   struct sd_ssr ssr ;
   struct sd_switch_caps sw_caps ;
   unsigned int sdio_funcs ;
   struct sdio_cccr cccr ;
   struct sdio_cis cis ;
   struct sdio_func *sdio_func[7U] ;
   struct sdio_func *sdio_single_irq ;
   unsigned int num_info ;
   char const   **info ;
   struct sdio_func_tuple *tuples ;
   unsigned int sd_bus_speed ;
   unsigned int mmc_avail_type ;
   struct dentry *debugfs_root ;
   struct mmc_part part[7U] ;
   unsigned int nr_parts ;
};
#line 519 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/card.h"
struct mmc_ios {
   unsigned int clock ;
   unsigned short vdd ;
   unsigned char bus_mode ;
   unsigned char chip_select ;
   unsigned char power_mode ;
   unsigned char bus_width ;
   unsigned char timing ;
   unsigned char signal_voltage ;
   unsigned char drv_type ;
};
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host_ops {
   int (*enable)(struct mmc_host * ) ;
   int (*disable)(struct mmc_host * ) ;
   void (*post_req)(struct mmc_host * , struct mmc_request * , int  ) ;
   void (*pre_req)(struct mmc_host * , struct mmc_request * , bool  ) ;
   void (*request)(struct mmc_host * , struct mmc_request * ) ;
   void (*set_ios)(struct mmc_host * , struct mmc_ios * ) ;
   int (*get_ro)(struct mmc_host * ) ;
   int (*get_cd)(struct mmc_host * ) ;
   void (*enable_sdio_irq)(struct mmc_host * , int  ) ;
   void (*init_card)(struct mmc_host * , struct mmc_card * ) ;
   int (*start_signal_voltage_switch)(struct mmc_host * , struct mmc_ios * ) ;
   int (*card_busy)(struct mmc_host * ) ;
   int (*execute_tuning)(struct mmc_host * , u32  ) ;
   int (*prepare_hs400_tuning)(struct mmc_host * , struct mmc_ios * ) ;
   int (*select_drive_strength)(unsigned int  , int  , int  ) ;
   void (*hw_reset)(struct mmc_host * ) ;
   void (*card_event)(struct mmc_host * ) ;
   int (*multi_io_quirk)(struct mmc_card * , unsigned int  , int  ) ;
};
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_async_req {
   struct mmc_request *mrq ;
   int (*err_check)(struct mmc_card * , struct mmc_async_req * ) ;
};
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_slot {
   int cd_irq ;
   void *handler_priv ;
};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_context_info {
   bool is_done_rcv ;
   bool is_new_req ;
   bool is_waiting_last_req ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
};
#line 196
struct regulator;
#line 197
struct mmc_pwrseq;
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_supply {
   struct regulator *vmmc ;
   struct regulator *vqmmc ;
};
#line 204
struct mmc_bus_ops;
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mmc/host.h"
struct mmc_host {
   struct device *parent ;
   struct device class_dev ;
   int index ;
   struct mmc_host_ops  const  *ops ;
   struct mmc_pwrseq *pwrseq ;
   unsigned int f_min ;
   unsigned int f_max ;
   unsigned int f_init ;
   u32 ocr_avail ;
   u32 ocr_avail_sdio ;
   u32 ocr_avail_sd ;
   u32 ocr_avail_mmc ;
   struct notifier_block pm_notify ;
   u32 max_current_330 ;
   u32 max_current_300 ;
   u32 max_current_180 ;
   u32 caps ;
   u32 caps2 ;
   mmc_pm_flag_t pm_caps ;
   int clk_requests ;
   unsigned int clk_delay ;
   bool clk_gated ;
   struct delayed_work clk_gate_work ;
   unsigned int clk_old ;
   spinlock_t clk_lock ;
   struct mutex clk_gate_mutex ;
   struct device_attribute clkgate_delay_attr ;
   unsigned long clkgate_delay ;
   unsigned int max_seg_size ;
   unsigned short max_segs ;
   unsigned short unused ;
   unsigned int max_req_size ;
   unsigned int max_blk_size ;
   unsigned int max_blk_count ;
   unsigned int max_busy_timeout ;
   spinlock_t lock ;
   struct mmc_ios ios ;
   unsigned char use_spi_crc : 1 ;
   unsigned char claimed : 1 ;
   unsigned char bus_dead : 1 ;
   unsigned char removed : 1 ;
   int rescan_disable ;
   int rescan_entered ;
   bool trigger_card_event ;
   struct mmc_card *card ;
   wait_queue_head_t wq ;
   struct task_struct *claimer ;
   int claim_cnt ;
   struct delayed_work detect ;
   int detect_change ;
   struct mmc_slot slot ;
   struct mmc_bus_ops  const  *bus_ops ;
   unsigned int bus_refs ;
   unsigned int sdio_irqs ;
   struct task_struct *sdio_irq_thread ;
   bool sdio_irq_pending ;
   atomic_t sdio_irq_thread_abort ;
   mmc_pm_flag_t pm_flags ;
   struct led_trigger *led ;
   bool regulator_enabled ;
   struct mmc_supply supply ;
   struct dentry *debugfs_root ;
   struct mmc_async_req *areq ;
   struct mmc_context_info context_info ;
   struct fault_attr fail_mmc_request ;
   unsigned int actual_clock ;
   unsigned int slotno ;
   int dsr_req ;
   u32 dsr ;
   unsigned long private[0U] ;
};
#line 24 "/home/ubuntu/klever-work/verifier/map.h"
typedef int ldv_map;
#line 27
struct usb_device;
#line 31 "/home/ubuntu/klever-work/verifier/nondet.h"
struct urb;
#line 8 "thread.c"
struct ldv_thread_set {
   int number ;
   struct ldv_thread **threads ;
};
#line 42 "/home/ubuntu/klever-work/verifier/thread.h"
struct ldv_thread {
   int identifier ;
   void (*function)(void * ) ;
};
#line 22 "/home/ubuntu/klever-work/verifier/set.h"
typedef _Bool ldv_set;
#line 1 "<compiler builtins>"
long __builtin_expect(long exp , long c ) ;
#line 28 "/home/ubuntu/klever-work/verifier/common.h"
void ldv_assume(int expression ) ;
#line 31
void ldv_stop(void) ;
#line 6 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) ;
#line 7
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) ;
#line 11
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) ;
#line 12
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) ;
#line 16
void ldv_linux_arch_io_check_final_state(void) ;
#line 20
void ldv_linux_block_genhd_check_final_state(void) ;
#line 24
void ldv_linux_block_queue_check_final_state(void) ;
#line 28
void ldv_linux_block_request_check_final_state(void) ;
#line 32
void *ldv_linux_drivers_base_class_create_class(void) ;
#line 33
int ldv_linux_drivers_base_class_register_class(void) ;
#line 36
void ldv_linux_drivers_base_class_destroy_class(struct class *cls ) ;
#line 37
void ldv_linux_drivers_base_class_check_final_state(void) ;
#line 48
void ldv_linux_fs_char_dev_check_final_state(void) ;
#line 52
void ldv_linux_fs_sysfs_check_final_state(void) ;
#line 56
void ldv_linux_kernel_locking_rwlock_check_final_state(void) ;
#line 60
void ldv_linux_kernel_module_check_final_state(void) ;
#line 64
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) ;
#line 65
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) ;
#line 69
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) ;
#line 70
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) ;
#line 74
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) ;
#line 75
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) ;
#line 79
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) ;
#line 80
void ldv_linux_kernel_rcu_srcu_check_final_state(void) ;
#line 84
void ldv_linux_lib_find_bit_initialize(void) ;
#line 88
void ldv_linux_lib_idr_check_final_state(void) ;
#line 92
void ldv_linux_mmc_sdio_func_check_final_state(void) ;
#line 96
void ldv_linux_net_register_reset_error_counter(void) ;
#line 97
void ldv_linux_net_register_check_return_value_probe(int retval ) ;
#line 101
void ldv_linux_net_rtnetlink_check_final_state(void) ;
#line 105
void ldv_linux_net_sock_check_final_state(void) ;
#line 110
void ldv_linux_usb_coherent_check_final_state(void) ;
#line 114
void *ldv_linux_usb_gadget_create_class(void) ;
#line 115
int ldv_linux_usb_gadget_register_class(void) ;
#line 118
void ldv_linux_usb_gadget_destroy_class(struct class *cls ) ;
#line 122
void ldv_linux_usb_gadget_check_final_state(void) ;
#line 126
void ldv_linux_usb_register_reset_error_counter(void) ;
#line 127
void ldv_linux_usb_register_check_return_value_probe(int retval ) ;
#line 132
void ldv_linux_usb_urb_check_final_state(void) ;
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 139
  ldv_linux_alloc_irq_check_alloc_nonatomic();
#line 143
  ldv_linux_alloc_usb_lock_check_alloc_nonatomic();
  }
#line 144
  return;
}
}
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_check_alloc_flags(gfp_t flags ) 
{ 


  {
  {
#line 150
  ldv_linux_alloc_irq_check_alloc_flags(flags);
#line 154
  ldv_linux_alloc_usb_lock_check_alloc_flags(flags);
  }
#line 155
  return;
}
}
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_check_for_read_section(void) 
{ 


  {
  {
#line 161
  ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section();
#line 165
  ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section();
#line 169
  ldv_linux_kernel_rcu_update_lock_check_for_read_section();
#line 173
  ldv_linux_kernel_rcu_srcu_check_for_read_section();
  }
#line 174
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void *ldv_create_class(void) 
{ 
  void *res1 ;
  void *tmp ;
  void *res2 ;
  void *tmp___0 ;

  {
  {
#line 180
  tmp = ldv_linux_drivers_base_class_create_class();
#line 180
  res1 = tmp;
#line 181
  tmp___0 = ldv_linux_usb_gadget_create_class();
#line 181
  res2 = tmp___0;
#line 182
  ldv_assume((unsigned long )res1 == (unsigned long )res2);
  }
#line 183
  return (res1);
}
}
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
int ldv_register_class(void) 
{ 
  int res1 ;
  int tmp ;
  int res2 ;
  int tmp___0 ;

  {
  {
#line 194
  tmp = ldv_linux_drivers_base_class_register_class();
#line 194
  res1 = tmp;
#line 195
  tmp___0 = ldv_linux_usb_gadget_register_class();
#line 195
  res2 = tmp___0;
#line 196
  ldv_assume(res1 == res2);
  }
#line 197
  return (res1);
}
}
#line 24 "/home/ubuntu/klever-work/linux/ldv/err.h"
long ldv_ptr_err(void const   *ptr ) ;
#line 22 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int(void) ;
#line 34 "/home/ubuntu/klever-work/linux/ldv/common.h"
static void ldv_ldv_initialize_102(void) ;
#line 47
int ldv_post_init(int init_ret_val ) ;
#line 50
static int ldv_ldv_post_init_99(int ldv_func_arg1 ) ;
#line 58
extern void ldv_pre_probe(void) ;
#line 61
static void ldv_ldv_pre_probe_103(void) ;
#line 67
int ldv_post_probe(int probe_ret_val ) ;
#line 70
static int ldv_ldv_post_probe_104(int retval ) ;
#line 122
static void ldv_ldv_check_final_state_100(void) ;
#line 126
static void ldv_ldv_check_final_state_101(void) ;
#line 32 "/home/ubuntu/klever-work/verifier/memory.h"
void ldv_free(void *s ) ;
#line 34
void *ldv_xmalloc(size_t size ) ;
#line 39
void *ldv_malloc_unknown_size(void) ;
#line 313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void *ldv_alloc_macro(gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 315
  ldv_check_alloc_flags(flags);
#line 316
  tmp = ldv_malloc_unknown_size();
  }
#line 316
  return (tmp);
}
}
#line 344
int ldv_linux_kernel_module_try_module_get(struct module *module ) ;
#line 346
void ldv_linux_kernel_module_module_put(struct module *module ) ;
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
extern int printk(char const   *  , ...) ;
#line 404 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern int sscanf(char const   * , char const   *  , ...) ;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 43
  tmp = __builtin_expect((unsigned long )ptr > 0xfffffffffffff000UL, 0L);
  }
#line 43
  return (tmp != 0L);
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.h"
void ldv_switch_to_interrupt_context(void) ;
#line 42
void ldv_switch_to_process_context(void) ;
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
extern int add_uevent_var(struct kobj_uevent_env * , char const   *  , ...) ;
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
extern int bus_register(struct bus_type * ) ;
#line 135
extern void bus_unregister(struct bus_type * ) ;
#line 485
static void ldv_class_destroy_98(struct class *cls ) ;
#line 1012
extern struct device *get_device(struct device * ) ;
#line 1013
extern void put_device(struct device * ) ;
#line 461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/module.h"
static bool ldv_try_module_get_96(struct module *ldv_func_arg1 ) ;
#line 467
static void ldv_module_put_97(struct module *ldv_func_arg1 ) ;
#line 923 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void proc_ide_create(void) ;
#line 924
void proc_ide_destroy(void) ;
#line 999
int generic_ide_suspend(struct device *dev , pm_message_t mesg ) ;
#line 1000
int generic_ide_resume(struct device *dev ) ;
#line 1029
int ide_device_get(ide_drive_t *drive ) ;
#line 1030
void ide_device_put(ide_drive_t *drive ) ;
#line 1043 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
int ide_vlb_clk  ;
#line 1044 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
int ide_pci_clk  ;
#line 1404
int ide_acpi_init(void) ;
#line 1429
void ide_port_apply_params(ide_hwif_t *hwif ) ;
#line 1511
char *ide_media_string(ide_drive_t *drive ) ;
#line 1513
struct attribute_group  const  *ide_dev_groups[2U] ;
#line 1514
struct bus_type ide_bus_type ;
#line 1515 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct class *ide_port_class  ;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
int ide_device_get(ide_drive_t *drive ) 
{ 
  struct device *host_dev ;
  struct module *module ;
  struct device *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 76
  tmp = get_device(& drive->gendev);
  }
#line 76
  if ((unsigned long )tmp == (unsigned long )((struct device *)0)) {
#line 77
    return (-6);
  } else {

  }
#line 79
  host_dev = ((drive->hwif)->host)->dev[0];
#line 80
  module = (unsigned long )host_dev != (unsigned long )((struct device *)0) ? (host_dev->driver)->owner : (struct module *)0;
#line 82
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 82
    tmp___0 = ldv_try_module_get_96(module);
    }
#line 82
    if (tmp___0) {
#line 82
      tmp___1 = 0;
    } else {
#line 82
      tmp___1 = 1;
    }
#line 82
    if (tmp___1) {
      {
#line 83
      put_device(& drive->gendev);
      }
#line 84
      return (-6);
    } else {

    }
  } else {

  }
#line 87
  return (0);
}
}
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static char const   __kstrtab_ide_device_get[15U]  = 
#line 89
  {      'i',      'd',      'e',      '_', 
        'd',      'e',      'v',      'i', 
        'c',      'e',      '_',      'g', 
        'e',      't',      '\000'};
#line 89
struct kernel_symbol  const  __ksymtab_ide_device_get ;
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
struct kernel_symbol  const  __ksymtab_ide_device_get  =    {(unsigned long )(& ide_device_get), (char const   *)(& __kstrtab_ide_device_get)};
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
void ide_device_put(ide_drive_t *drive ) 
{ 
  struct device *host_dev ;
  struct module *module ;

  {
  {
#line 101
  host_dev = ((drive->hwif)->host)->dev[0];
#line 102
  module = (unsigned long )host_dev != (unsigned long )((struct device *)0) ? (host_dev->driver)->owner : (struct module *)0;
#line 104
  ldv_module_put_97(module);
#line 106
  put_device(& drive->gendev);
  }
#line 107
  return;
}
}
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static char const   __kstrtab_ide_device_put[15U]  = 
#line 108
  {      'i',      'd',      'e',      '_', 
        'd',      'e',      'v',      'i', 
        'c',      'e',      '_',      'p', 
        'u',      't',      '\000'};
#line 108
struct kernel_symbol  const  __ksymtab_ide_device_put ;
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
struct kernel_symbol  const  __ksymtab_ide_device_put  =    {(unsigned long )(& ide_device_put), (char const   *)(& __kstrtab_ide_device_put)};
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static int ide_bus_match(struct device *dev , struct device_driver *drv ) 
{ 


  {
#line 112
  return (1);
}
}
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static int ide_uevent(struct device *dev , struct kobj_uevent_env *env ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 117
  __mptr = (struct device  const  *)dev;
#line 117
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 119
  tmp = ide_media_string(drive);
#line 119
  add_uevent_var(env, "MEDIA=%s", tmp);
#line 120
  add_uevent_var(env, "DRIVENAME=%s", (char *)(& drive->name));
#line 121
  tmp___0 = ide_media_string(drive);
#line 121
  add_uevent_var(env, "MODALIAS=ide:m-%s", tmp___0);
  }
#line 122
  return (0);
}
}
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static int generic_ide_probe(struct device *dev ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  struct ide_driver *drv ;
  struct device_driver  const  *__mptr___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 127
  __mptr = (struct device  const  *)dev;
#line 127
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 128
  __mptr___0 = (struct device_driver  const  *)dev->driver;
#line 128
  drv = (struct ide_driver *)__mptr___0 + 0xfffffffffffffff0UL;
#line 130
  if ((unsigned long )drv->probe != (unsigned long )((int (*)(ide_drive_t * ))0)) {
    {
#line 130
    tmp = (*(drv->probe))(drive);
#line 130
    tmp___0 = tmp;
    }
  } else {
#line 130
    tmp___0 = -19;
  }
#line 130
  return (tmp___0);
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static int generic_ide_remove(struct device *dev ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  struct ide_driver *drv ;
  struct device_driver  const  *__mptr___0 ;

  {
#line 135
  __mptr = (struct device  const  *)dev;
#line 135
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 136
  __mptr___0 = (struct device_driver  const  *)dev->driver;
#line 136
  drv = (struct ide_driver *)__mptr___0 + 0xfffffffffffffff0UL;
#line 138
  if ((unsigned long )drv->remove != (unsigned long )((void (*)(ide_drive_t * ))0)) {
    {
#line 139
    (*(drv->remove))(drive);
    }
  } else {

  }
#line 141
  return (0);
}
}
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static void generic_ide_shutdown(struct device *dev ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  struct ide_driver *drv ;
  struct device_driver  const  *__mptr___0 ;

  {
#line 146
  __mptr = (struct device  const  *)dev;
#line 146
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 147
  __mptr___0 = (struct device_driver  const  *)dev->driver;
#line 147
  drv = (struct ide_driver *)__mptr___0 + 0xfffffffffffffff0UL;
#line 149
  if ((unsigned long )dev->driver != (unsigned long )((struct device_driver *)0) && (unsigned long )drv->shutdown != (unsigned long )((void (*)(ide_drive_t * ))0)) {
    {
#line 150
    (*(drv->shutdown))(drive);
    }
  } else {

  }
#line 151
  return;
}
}
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
struct bus_type ide_bus_type  = 
#line 153
     {"ide", 0, 0, 0, 0, (struct attribute_group  const  **)(& ide_dev_groups), 0, & ide_bus_match,
    & ide_uevent, & generic_ide_probe, & generic_ide_remove, & generic_ide_shutdown,
    0, 0, & generic_ide_suspend, & generic_ide_resume, 0, 0, 0, {{{(char)0}, {(char)0},
                                                                  {(char)0}, {(char)0},
                                                                  {(char)0}, {(char)0},
                                                                  {(char)0}, {(char)0}}}};
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static char const   __kstrtab_ide_bus_type[13U]  = 
#line 165
  {      'i',      'd',      'e',      '_', 
        'b',      'u',      's',      '_', 
        't',      'y',      'p',      'e', 
        '\000'};
#line 165
struct kernel_symbol  const  __ksymtab_ide_bus_type ;
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
struct kernel_symbol  const  __ksymtab_ide_bus_type  =    {(unsigned long )(& ide_bus_type), (char const   *)(& __kstrtab_ide_bus_type)};
#line 168 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static char const   __kstrtab_ide_vlb_clk[12U]  = 
#line 168
  {      'i',      'd',      'e',      '_', 
        'v',      'l',      'b',      '_', 
        'c',      'l',      'k',      '\000'};
#line 168
struct kernel_symbol  const  __ksymtab_ide_vlb_clk ;
#line 168 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
struct kernel_symbol  const  __ksymtab_ide_vlb_clk  =    {(unsigned long )(& ide_vlb_clk), (char const   *)(& __kstrtab_ide_vlb_clk)};
#line 174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static char const   __kstrtab_ide_pci_clk[12U]  = 
#line 174
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        'c',      'l',      'k',      '\000'};
#line 174
struct kernel_symbol  const  __ksymtab_ide_pci_clk ;
#line 174 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
struct kernel_symbol  const  __ksymtab_ide_pci_clk  =    {(unsigned long )(& ide_pci_clk), (char const   *)(& __kstrtab_ide_pci_clk)};
#line 179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static int ide_set_dev_param_mask(char const   *s , struct kernel_param  const  *kp ) 
{ 
  int a ;
  int b ;
  int i ;
  int j ;
  unsigned int *dev_param_mask ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 181
  j = 1;
#line 182
  dev_param_mask = (unsigned int *)kp->__annonCompField73.arg;
#line 185
  tmp = sscanf(s, "%d.%d:%d", & a, & b, & j);
  }
#line 185
  if (tmp != 3) {
    {
#line 185
    tmp___0 = sscanf(s, "%d.%d", & a, & b);
    }
#line 185
    if (tmp___0 != 2) {
#line 187
      return (-22);
    } else {

    }
  } else {

  }
#line 189
  i = a * 2 + b;
#line 191
  if ((i > 19 || j < 0) || j > 1) {
#line 192
    return (-22);
  } else {

  }
#line 194
  if (j != 0) {
#line 195
    *dev_param_mask = *dev_param_mask | (unsigned int )(1 << i);
  } else {
#line 197
    *dev_param_mask = *dev_param_mask & (unsigned int )(~ (1 << i));
  }
#line 199
  return (0);
}
}
#line 208 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static unsigned int ide_nodma  ;
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static unsigned int ide_noflush  ;
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static unsigned int ide_nohpa  ;
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static unsigned int ide_noprobe  ;
#line 228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static unsigned int ide_nowerr  ;
#line 233 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static unsigned int ide_cdroms  ;
#line 244 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static unsigned int ide_disks  ;
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static struct chs_geom ide_disks_chs[20U]  ;
#line 247 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static int ide_set_disk_chs(char const   *str , struct kernel_param *kp ) 
{ 
  int a ;
  int b ;
  int c ;
  int h ;
  int s ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 249
  c = 0;
#line 249
  h = 0;
#line 249
  s = 0;
#line 249
  j = 1;
#line 253
  tmp = sscanf(str, "%d.%d:%d,%d,%d", & a, & b, & c, & h, & s);
  }
#line 253
  if (tmp != 5) {
    {
#line 253
    tmp___0 = sscanf(str, "%d.%d:%d", & a, & b, & j);
    }
#line 253
    if (tmp___0 != 3) {
#line 255
      return (-22);
    } else {

    }
  } else {

  }
#line 257
  i = a * 2 + b;
#line 259
  if ((i > 19 || j < 0) || j > 1) {
#line 260
    return (-22);
  } else {

  }
#line 262
  if (h > 255 || s > 255) {
#line 263
    return (-22);
  } else {

  }
#line 265
  if (j != 0) {
#line 266
    ide_disks = ide_disks | (unsigned int )(1 << i);
  } else {
#line 268
    ide_disks = ide_disks & (unsigned int )(~ (1 << i));
  }
#line 270
  ide_disks_chs[i].cyl = (unsigned int )c;
#line 271
  ide_disks_chs[i].head = (u8 )h;
#line 272
  ide_disks_chs[i].sect = (u8 )s;
#line 274
  return (0);
}
}
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static void ide_dev_apply_params(ide_drive_t *drive , u8 unit ) 
{ 
  int i ;
  unsigned int tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;

  {
#line 282
  i = (int )(drive->hwif)->index * 2 + (int )unit;
#line 284
  if ((ide_nodma & (unsigned int )(1 << i)) != 0U) {
    {
#line 285
    printk("\016ide: disallowing DMA for %s\n", (char *)(& drive->name));
#line 286
    drive->dev_flags = drive->dev_flags | 65536UL;
    }
  } else {

  }
#line 288
  if ((ide_noflush & (unsigned int )(1 << i)) != 0U) {
    {
#line 289
    printk("\016ide: disabling flush requests for %s\n", (char *)(& drive->name));
#line 291
    drive->dev_flags = drive->dev_flags | 8UL;
    }
  } else {

  }
#line 293
  if ((ide_nohpa & (unsigned int )(1 << i)) != 0U) {
    {
#line 294
    printk("\016ide: disabling Host Protected Area for %s\n", (char *)(& drive->name));
#line 296
    drive->dev_flags = drive->dev_flags | 128UL;
    }
  } else {

  }
#line 298
  if ((ide_noprobe & (unsigned int )(1 << i)) != 0U) {
    {
#line 299
    printk("\016ide: skipping probe for %s\n", (char *)(& drive->name));
#line 300
    drive->dev_flags = drive->dev_flags | 512UL;
    }
  } else {

  }
#line 302
  if ((ide_nowerr & (unsigned int )(1 << i)) != 0U) {
    {
#line 303
    printk("\016ide: ignoring the ATA_DF bit for %s\n", (char *)(& drive->name));
#line 305
    drive->bad_wstat = 129U;
    }
  } else {

  }
#line 307
  if ((ide_cdroms & (unsigned int )(1 << i)) != 0U) {
    {
#line 308
    printk("\016ide: forcing %s as a CD-ROM\n", (char *)(& drive->name));
#line 309
    drive->dev_flags = drive->dev_flags | 64UL;
#line 310
    drive->media = 5U;
#line 312
    drive->ready_stat = 0U;
    }
  } else {

  }
#line 314
  if ((ide_disks & (unsigned int )(1 << i)) != 0U) {
    {
#line 315
    tmp = ide_disks_chs[i].cyl;
#line 315
    drive->bios_cyl = tmp;
#line 315
    drive->cyl = tmp;
#line 316
    tmp___0 = ide_disks_chs[i].head;
#line 316
    drive->bios_head = tmp___0;
#line 316
    drive->head = tmp___0;
#line 317
    tmp___1 = ide_disks_chs[i].sect;
#line 317
    drive->bios_sect = tmp___1;
#line 317
    drive->sect = tmp___1;
#line 319
    printk("\016ide: forcing %s as a disk (%d/%d/%d)\n", (char *)(& drive->name),
           drive->cyl, (int )drive->head, (int )drive->sect);
#line 323
    drive->dev_flags = drive->dev_flags | 4160UL;
#line 324
    drive->media = 32U;
#line 325
    drive->ready_stat = 64U;
    }
  } else {

  }
#line 327
  return;
}
}
#line 329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static unsigned int ide_ignore_cable  ;
#line 331 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static int ide_set_ignore_cable(char const   *s , struct kernel_param *kp ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 333
  j = 1;
#line 337
  tmp = sscanf(s, "%d:%d", & i, & j);
  }
#line 337
  if (tmp != 2) {
    {
#line 337
    tmp___0 = sscanf(s, "%d", & i);
    }
#line 337
    if (tmp___0 != 1) {
#line 338
      return (-22);
    } else {

    }
  } else {

  }
#line 340
  if ((i > 9 || j < 0) || j > 1) {
#line 341
    return (-22);
  } else {

  }
#line 343
  if (j != 0) {
#line 344
    ide_ignore_cable = ide_ignore_cable | (unsigned int )(1 << i);
  } else {
#line 346
    ide_ignore_cable = ide_ignore_cable & (unsigned int )(~ (1 << i));
  }
#line 348
  return (0);
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
void ide_port_apply_params(ide_hwif_t *hwif ) 
{ 
  ide_drive_t *drive ;
  int i ;

  {
#line 359
  if ((ide_ignore_cable & (unsigned int )(1 << (int )hwif->index)) != 0U) {
    {
#line 360
    printk("\016ide: ignoring cable detection for %s\n", (char *)(& hwif->name));
#line 362
    hwif->cbl = 3U;
    }
  } else {

  }
#line 365
  i = 0;
#line 365
  goto ldv_39347;
  ldv_39346: 
  {
#line 366
  ide_dev_apply_params(drive, (int )((u8 )i));
#line 365
  i = i + 1;
  }
  ldv_39347: 
#line 365
  drive = hwif->devices[i];
#line 365
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 367
    goto ldv_39346;
  } else {

  }

#line 372
  return;
}
}
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static int ide_init(void) 
{ 
  int ret ;
  void *tmp ;
  long tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 376
  printk("\016Uniform Multi-Platform E-IDE driver\n");
#line 378
  ret = bus_register(& ide_bus_type);
  }
#line 379
  if (ret < 0) {
    {
#line 380
    printk("\fIDE: bus_register error: %d\n", ret);
    }
#line 381
    return (ret);
  } else {

  }
  {
#line 384
  tmp = ldv_create_class();
#line 384
  ide_port_class = (struct class *)tmp;
#line 385
  tmp___1 = IS_ERR((void const   *)ide_port_class);
  }
#line 385
  if ((int )tmp___1) {
    {
#line 386
    tmp___0 = PTR_ERR((void const   *)ide_port_class);
#line 386
    ret = (int )tmp___0;
    }
#line 387
    goto out_port_class;
  } else {

  }
  {
#line 390
  ide_acpi_init();
#line 392
  proc_ide_create();
  }
#line 394
  return (0);
  out_port_class: 
  {
#line 397
  bus_unregister(& ide_bus_type);
  }
#line 399
  return (ret);
}
}
#line 402 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide.c"
static void ide_exit(void) 
{ 


  {
  {
#line 404
  proc_ide_destroy();
#line 406
  ldv_class_destroy_98(ide_port_class);
#line 408
  bus_unregister(& ide_bus_type);
  }
#line 409
  return;
}
}
#line 631 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_EMGentry_exit_ide_exit_41_2(void (*arg0)(void) ) ;
#line 632
int ldv_EMGentry_init_ide_init_41_23(int (*arg0)(void) ) ;
#line 634
void ldv_dispatch_deregister_dummy_factory_14_41_4(void) ;
#line 635
void ldv_dispatch_deregister_dummy_resourceless_instance_10_41_5(void) ;
#line 636
void ldv_dispatch_deregister_dummy_resourceless_instance_11_41_6(void) ;
#line 637
void ldv_dispatch_deregister_dummy_resourceless_instance_12_41_7(void) ;
#line 638
void ldv_dispatch_deregister_dummy_resourceless_instance_8_41_8(void) ;
#line 639
void ldv_dispatch_deregister_dummy_resourceless_instance_9_41_9(void) ;
#line 640
void ldv_dispatch_deregister_file_operations_instance_4_41_10(void) ;
#line 641
void ldv_dispatch_deregister_platform_instance_7_41_11(void) ;
#line 642
void ldv_dispatch_instance_register_37_3(struct timer_list *arg0 ) ;
#line 643
void ldv_dispatch_pm_deregister_13_5(void) ;
#line 644
void ldv_dispatch_pm_register_13_6(void) ;
#line 645
void ldv_dispatch_register_dummy_factory_14_41_12(void) ;
#line 646
void ldv_dispatch_register_dummy_resourceless_instance_10_41_13(void) ;
#line 647
void ldv_dispatch_register_dummy_resourceless_instance_11_41_14(void) ;
#line 648
void ldv_dispatch_register_dummy_resourceless_instance_12_41_15(void) ;
#line 649
void ldv_dispatch_register_dummy_resourceless_instance_8_41_16(void) ;
#line 650
void ldv_dispatch_register_dummy_resourceless_instance_9_41_17(void) ;
#line 651
void ldv_dispatch_register_file_operations_instance_4_41_18(void) ;
#line 652
void ldv_dispatch_register_platform_instance_7_41_19(void) ;
#line 653
void ldv_dummy_resourceless_instance_callback_14_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 654
void ldv_dummy_resourceless_instance_callback_15_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 655
void ldv_dummy_resourceless_instance_callback_16_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 656
void ldv_dummy_resourceless_instance_callback_17_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 657
void ldv_dummy_resourceless_instance_callback_18_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 658
void ldv_dummy_resourceless_instance_callback_19_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 659
void ldv_dummy_resourceless_instance_callback_20_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 660
void ldv_dummy_resourceless_instance_callback_21_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 661
void ldv_dummy_resourceless_instance_callback_23_3(int (*arg0)(struct dmi_system_id * ) ,
                                                   struct dmi_system_id *arg1 ) ;
#line 662
void ldv_dummy_resourceless_instance_callback_24_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 663
void ldv_dummy_resourceless_instance_callback_24_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) ;
#line 664
void ldv_dummy_resourceless_instance_callback_24_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 665
void ldv_dummy_resourceless_instance_callback_24_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 666
void ldv_dummy_resourceless_instance_callback_24_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 667
void ldv_dummy_resourceless_instance_callback_24_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 668
void ldv_dummy_resourceless_instance_callback_24_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 669
void ldv_dummy_resourceless_instance_callback_24_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) ;
#line 670
void ldv_dummy_resourceless_instance_callback_24_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 671
void ldv_dummy_resourceless_instance_callback_24_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) ;
#line 672
void ldv_dummy_resourceless_instance_callback_25_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 673
void ldv_dummy_resourceless_instance_callback_25_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) ;
#line 674
void ldv_dummy_resourceless_instance_callback_25_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 675
void ldv_dummy_resourceless_instance_callback_25_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 676
void ldv_dummy_resourceless_instance_callback_25_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 677
void ldv_dummy_resourceless_instance_callback_25_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 678
void ldv_dummy_resourceless_instance_callback_25_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 679
void ldv_dummy_resourceless_instance_callback_25_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) ;
#line 680
void ldv_dummy_resourceless_instance_callback_25_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 681
void ldv_dummy_resourceless_instance_callback_25_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) ;
#line 682
void ldv_dummy_resourceless_instance_callback_26_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 683
void ldv_dummy_resourceless_instance_callback_26_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) ;
#line 684
void ldv_dummy_resourceless_instance_callback_26_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 685
void ldv_dummy_resourceless_instance_callback_26_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 686
void ldv_dummy_resourceless_instance_callback_26_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 687
void ldv_dummy_resourceless_instance_callback_26_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 688
void ldv_dummy_resourceless_instance_callback_26_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 689
void ldv_dummy_resourceless_instance_callback_26_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) ;
#line 690
void ldv_dummy_resourceless_instance_callback_26_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 691
void ldv_dummy_resourceless_instance_callback_26_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) ;
#line 692
void ldv_dummy_resourceless_instance_callback_27_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 693
void ldv_dummy_resourceless_instance_callback_27_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) ;
#line 694
void ldv_dummy_resourceless_instance_callback_27_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 695
void ldv_dummy_resourceless_instance_callback_27_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 696
void ldv_dummy_resourceless_instance_callback_27_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 697
void ldv_dummy_resourceless_instance_callback_27_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 698
void ldv_dummy_resourceless_instance_callback_27_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 699
void ldv_dummy_resourceless_instance_callback_27_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) ;
#line 700
void ldv_dummy_resourceless_instance_callback_27_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 701
void ldv_dummy_resourceless_instance_callback_27_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) ;
#line 702
void ldv_dummy_resourceless_instance_callback_28_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 703
void ldv_dummy_resourceless_instance_callback_28_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) ;
#line 704
void ldv_dummy_resourceless_instance_callback_28_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 705
void ldv_dummy_resourceless_instance_callback_28_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 706
void ldv_dummy_resourceless_instance_callback_28_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 707
void ldv_dummy_resourceless_instance_callback_28_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 708
void ldv_dummy_resourceless_instance_callback_28_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 709
void ldv_dummy_resourceless_instance_callback_28_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) ;
#line 710
void ldv_dummy_resourceless_instance_callback_28_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 711
void ldv_dummy_resourceless_instance_callback_28_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) ;
#line 712
void ldv_dummy_resourceless_instance_callback_29_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 713
void ldv_dummy_resourceless_instance_callback_29_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) ;
#line 714
void ldv_dummy_resourceless_instance_callback_29_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 715
void ldv_dummy_resourceless_instance_callback_29_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 716
void ldv_dummy_resourceless_instance_callback_29_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 717
void ldv_dummy_resourceless_instance_callback_29_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 718
void ldv_dummy_resourceless_instance_callback_29_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 719
void ldv_dummy_resourceless_instance_callback_29_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) ;
#line 720
void ldv_dummy_resourceless_instance_callback_29_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 721
void ldv_dummy_resourceless_instance_callback_29_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) ;
#line 722
void ldv_dummy_resourceless_instance_callback_30_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 723
void ldv_dummy_resourceless_instance_callback_30_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) ;
#line 724
void ldv_dummy_resourceless_instance_callback_30_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 725
void ldv_dummy_resourceless_instance_callback_30_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 726
void ldv_dummy_resourceless_instance_callback_30_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 727
void ldv_dummy_resourceless_instance_callback_30_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 728
void ldv_dummy_resourceless_instance_callback_30_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 729
void ldv_dummy_resourceless_instance_callback_30_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) ;
#line 730
void ldv_dummy_resourceless_instance_callback_30_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 731
void ldv_dummy_resourceless_instance_callback_30_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) ;
#line 732
void ldv_dummy_resourceless_instance_callback_31_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 733
void ldv_dummy_resourceless_instance_callback_31_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) ;
#line 734
void ldv_dummy_resourceless_instance_callback_31_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 735
void ldv_dummy_resourceless_instance_callback_31_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 736
void ldv_dummy_resourceless_instance_callback_31_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 737
void ldv_dummy_resourceless_instance_callback_31_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 738
void ldv_dummy_resourceless_instance_callback_31_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) ;
#line 739
void ldv_dummy_resourceless_instance_callback_31_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) ;
#line 740
void ldv_dummy_resourceless_instance_callback_31_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 741
void ldv_dummy_resourceless_instance_callback_31_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) ;
#line 742
void ldv_dummy_resourceless_instance_callback_32_10(void (*arg0)(struct ide_drive_s * ,
                                                                 struct ide_cmd * ,
                                                                 void * , unsigned int  ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ,
                                                    void *arg3 , unsigned int arg4 ) ;
#line 743
void ldv_dummy_resourceless_instance_callback_32_13(void (*arg0)(struct ide_drive_s * ,
                                                                 struct ide_cmd * ,
                                                                 void * , unsigned int  ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ,
                                                    void *arg3 , unsigned int arg4 ) ;
#line 744
void ldv_dummy_resourceless_instance_callback_32_16(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 745
void ldv_dummy_resourceless_instance_callback_32_17(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) ;
#line 746
void ldv_dummy_resourceless_instance_callback_32_18(void (*arg0)(struct ide_drive_s * ,
                                                                 struct ide_taskfile * ,
                                                                 unsigned char  ) ,
                                                    struct ide_drive_s *arg1 , struct ide_taskfile *arg2 ,
                                                    unsigned char arg3 ) ;
#line 747
void ldv_dummy_resourceless_instance_callback_32_21(void (*arg0)(struct ide_drive_s * ,
                                                                 struct ide_taskfile * ,
                                                                 unsigned char  ) ,
                                                    struct ide_drive_s *arg1 , struct ide_taskfile *arg2 ,
                                                    unsigned char arg3 ) ;
#line 748
void ldv_dummy_resourceless_instance_callback_32_24(void (*arg0)(struct hwif_s * ,
                                                                 unsigned char  ) ,
                                                    struct hwif_s *arg1 , unsigned char arg2 ) ;
#line 749
void ldv_dummy_resourceless_instance_callback_32_3(void (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) ;
#line 750
void ldv_dummy_resourceless_instance_callback_32_7(void (*arg0)(struct hwif_s * ,
                                                                unsigned char  ) ,
                                                   struct hwif_s *arg1 , unsigned char arg2 ) ;
#line 751
void ldv_dummy_resourceless_instance_callback_33_3(int (*arg0)(char * , struct kernel_param * ) ,
                                                   char *arg1 , struct kernel_param *arg2 ) ;
#line 752
void ldv_dummy_resourceless_instance_callback_34_3(int (*arg0)(char * , struct kernel_param * ) ,
                                                   char *arg1 , struct kernel_param *arg2 ) ;
#line 753
void ldv_dummy_resourceless_instance_callback_35_3(int (*arg0)(char * , struct kernel_param * ) ,
                                                   char *arg1 , struct kernel_param *arg2 ) ;
#line 754
void ldv_entry_EMGentry_41(void *arg0 ) ;
#line 755
void main(void) ;
#line 756
void ldv_file_operations_file_operations_instance_0(void *arg0 ) ;
#line 757
void ldv_file_operations_file_operations_instance_1(void *arg0 ) ;
#line 758
void ldv_file_operations_file_operations_instance_10(void *arg0 ) ;
#line 759
void ldv_file_operations_file_operations_instance_2(void *arg0 ) ;
#line 760
void ldv_file_operations_file_operations_instance_3(void *arg0 ) ;
#line 761
void ldv_file_operations_file_operations_instance_4(void *arg0 ) ;
#line 762
void ldv_file_operations_file_operations_instance_5(void *arg0 ) ;
#line 763
void ldv_file_operations_file_operations_instance_6(void *arg0 ) ;
#line 764
void ldv_file_operations_file_operations_instance_7(void *arg0 ) ;
#line 765
void ldv_file_operations_file_operations_instance_8(void *arg0 ) ;
#line 766
void ldv_file_operations_file_operations_instance_9(void *arg0 ) ;
#line 767
void ldv_file_operations_instance_write_0_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 768
void ldv_file_operations_instance_write_1_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 769
void ldv_file_operations_instance_write_2_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 770
void ldv_file_operations_instance_write_4_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 771
void ldv_file_operations_instance_write_5_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 772
void ldv_file_operations_instance_write_6_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 773
void ldv_file_operations_instance_write_7_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 774
void ldv_file_operations_instance_write_8_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 775
void ldv_file_operations_instance_write_9_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 777
enum irqreturn ldv_interrupt_instance_handler_11_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                   int arg1 , void *arg2 ) ;
#line 778
void ldv_interrupt_instance_thread_11_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                        void *arg2 ) ;
#line 779
void ldv_interrupt_interrupt_instance_11(void *arg0 ) ;
#line 780
int ldv_platform_instance_probe_13_14(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) ;
#line 781
void ldv_platform_instance_release_13_3(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) ;
#line 782
void ldv_pm_ops_instance_complete_12_3(void (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 783
void ldv_pm_ops_instance_freeze_12_15(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 784
void ldv_pm_ops_instance_freeze_late_12_14(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 785
void ldv_pm_ops_instance_freeze_noirq_12_12(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 786
void ldv_pm_ops_instance_poweroff_12_9(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 787
void ldv_pm_ops_instance_poweroff_late_12_8(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 788
void ldv_pm_ops_instance_poweroff_noirq_12_6(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 789
void ldv_pm_ops_instance_prepare_12_22(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 790
void ldv_pm_ops_instance_restore_12_4(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 791
void ldv_pm_ops_instance_restore_early_12_7(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 792
void ldv_pm_ops_instance_restore_noirq_12_5(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 793
void ldv_pm_ops_instance_resume_12_16(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 794
void ldv_pm_ops_instance_resume_early_12_17(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 795
void ldv_pm_ops_instance_resume_noirq_12_19(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 796
void ldv_pm_ops_instance_runtime_idle_12_27(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 797
void ldv_pm_ops_instance_runtime_resume_12_24(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 798
void ldv_pm_ops_instance_runtime_suspend_12_25(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 799
void ldv_pm_ops_instance_suspend_12_21(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 800
void ldv_pm_ops_instance_suspend_late_12_18(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 801
void ldv_pm_ops_instance_suspend_noirq_12_20(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 802
void ldv_pm_ops_instance_thaw_12_10(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 803
void ldv_pm_ops_instance_thaw_early_12_13(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 804
void ldv_pm_ops_instance_thaw_noirq_12_11(int (*arg0)(struct device * ) , struct device *arg1 ) ;
#line 805
void ldv_pm_platform_instance_13(void *arg0 ) ;
#line 806
void ldv_pm_pm_ops_instance_12(void *arg0 ) ;
#line 808
void ldv_struct_device_attribute_dummy_resourceless_instance_14(void *arg0 ) ;
#line 809
void ldv_struct_device_attribute_dummy_resourceless_instance_15(void *arg0 ) ;
#line 810
void ldv_struct_device_attribute_dummy_resourceless_instance_16(void *arg0 ) ;
#line 811
void ldv_struct_device_attribute_dummy_resourceless_instance_17(void *arg0 ) ;
#line 812
void ldv_struct_device_attribute_dummy_resourceless_instance_18(void *arg0 ) ;
#line 813
void ldv_struct_device_attribute_dummy_resourceless_instance_19(void *arg0 ) ;
#line 814
void ldv_struct_device_attribute_dummy_resourceless_instance_20(void *arg0 ) ;
#line 815
void ldv_struct_device_attribute_dummy_resourceless_instance_21(void *arg0 ) ;
#line 816
void ldv_struct_device_attribute_dummy_resourceless_instance_22(void *arg0 ) ;
#line 817
void ldv_struct_dmi_system_id_dummy_resourceless_instance_23(void *arg0 ) ;
#line 818
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_24(void *arg0 ) ;
#line 819
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_25(void *arg0 ) ;
#line 820
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_26(void *arg0 ) ;
#line 821
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_27(void *arg0 ) ;
#line 822
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_28(void *arg0 ) ;
#line 823
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_29(void *arg0 ) ;
#line 824
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_30(void *arg0 ) ;
#line 825
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_31(void *arg0 ) ;
#line 826
void ldv_struct_ide_tp_ops_dummy_resourceless_instance_32(void *arg0 ) ;
#line 827
void ldv_struct_kernel_param_ops_dummy_resourceless_instance_33(void *arg0 ) ;
#line 828
void ldv_struct_kernel_param_ops_dummy_resourceless_instance_34(void *arg0 ) ;
#line 829
void ldv_struct_kernel_param_ops_dummy_resourceless_instance_35(void *arg0 ) ;
#line 830
void ldv_timer_dummy_factory_37(void *arg0 ) ;
#line 831
void ldv_timer_instance_callback_36_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) ;
#line 832
void ldv_timer_timer_instance_36(void *arg0 ) ;
#line 835 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_11  ;
#line 836 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_12  ;
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_13  ;
#line 838 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_23  ;
#line 839 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_24  ;
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_25  ;
#line 841 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_26  ;
#line 842 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_27  ;
#line 843 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_28  ;
#line 844 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_29  ;
#line 845 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_30  ;
#line 846 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_31  ;
#line 847 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_32  ;
#line 848 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_33  ;
#line 849 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_34  ;
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_35  ;
#line 851 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_36  ;
#line 852 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_37  ;
#line 853 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
struct ldv_thread ldv_thread_41  ;
#line 859 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_EMGentry_exit_ide_exit_41_2(void (*arg0)(void) ) 
{ 


  {
  {
#line 860
  ide_exit();
  }
#line 861
  return;
}
}
#line 864 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
int ldv_EMGentry_init_ide_init_41_23(int (*arg0)(void) ) 
{ 
  int tmp ;

  {
  {
#line 865
  tmp = ide_init();
  }
#line 865
  return (tmp);
}
}
#line 869 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_deregister_dummy_factory_14_41_4(void) 
{ 


  {
#line 873
  return;
}
}
#line 877 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_10_41_5(void) 
{ 


  {
#line 895
  return;
}
}
#line 899 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_11_41_6(void) 
{ 


  {
#line 903
  return;
}
}
#line 907 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_12_41_7(void) 
{ 


  {
#line 915
  return;
}
}
#line 919 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_8_41_8(void) 
{ 


  {
#line 939
  return;
}
}
#line 943 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_deregister_dummy_resourceless_instance_9_41_9(void) 
{ 


  {
#line 947
  return;
}
}
#line 951 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_deregister_file_operations_instance_4_41_10(void) 
{ 


  {
#line 975
  return;
}
}
#line 979 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_deregister_platform_instance_7_41_11(void) 
{ 


  {
#line 983
  return;
}
}
#line 987 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_instance_register_37_3(struct timer_list *arg0 ) 
{ 
  struct ldv_struct_timer_instance_36 *cf_arg_36 ;
  void *tmp ;

  {
  {
#line 990
  tmp = ldv_xmalloc(16UL);
#line 990
  cf_arg_36 = (struct ldv_struct_timer_instance_36 *)tmp;
#line 991
  cf_arg_36->arg0 = arg0;
#line 992
  ldv_timer_timer_instance_36((void *)cf_arg_36);
  }
#line 993
  return;
}
}
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_pm_deregister_13_5(void) 
{ 


  {
#line 1001
  return;
}
}
#line 1005 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_pm_register_13_6(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_12 ;
  void *tmp ;

  {
  {
#line 1008
  tmp = ldv_xmalloc(4UL);
#line 1008
  cf_arg_12 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1009
  ldv_pm_pm_ops_instance_12((void *)cf_arg_12);
  }
#line 1010
  return;
}
}
#line 1014 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_register_dummy_factory_14_41_12(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_37 ;
  void *tmp ;

  {
  {
#line 1017
  tmp = ldv_xmalloc(4UL);
#line 1017
  cf_arg_37 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1018
  ldv_timer_dummy_factory_37((void *)cf_arg_37);
  }
#line 1019
  return;
}
}
#line 1023 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_10_41_13(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_24 ;
  struct ldv_struct_platform_instance_13 *cf_arg_25 ;
  struct ldv_struct_platform_instance_13 *cf_arg_26 ;
  struct ldv_struct_platform_instance_13 *cf_arg_27 ;
  struct ldv_struct_platform_instance_13 *cf_arg_28 ;
  struct ldv_struct_platform_instance_13 *cf_arg_29 ;
  struct ldv_struct_platform_instance_13 *cf_arg_30 ;
  struct ldv_struct_platform_instance_13 *cf_arg_31 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 1033
  tmp = ldv_xmalloc(4UL);
#line 1033
  cf_arg_24 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1034
  ldv_struct_ide_proc_devset_dummy_resourceless_instance_24((void *)cf_arg_24);
#line 1035
  tmp___0 = ldv_xmalloc(4UL);
#line 1035
  cf_arg_25 = (struct ldv_struct_platform_instance_13 *)tmp___0;
#line 1036
  ldv_struct_ide_proc_devset_dummy_resourceless_instance_25((void *)cf_arg_25);
#line 1037
  tmp___1 = ldv_xmalloc(4UL);
#line 1037
  cf_arg_26 = (struct ldv_struct_platform_instance_13 *)tmp___1;
#line 1038
  ldv_struct_ide_proc_devset_dummy_resourceless_instance_26((void *)cf_arg_26);
#line 1039
  tmp___2 = ldv_xmalloc(4UL);
#line 1039
  cf_arg_27 = (struct ldv_struct_platform_instance_13 *)tmp___2;
#line 1040
  ldv_struct_ide_proc_devset_dummy_resourceless_instance_27((void *)cf_arg_27);
#line 1041
  tmp___3 = ldv_xmalloc(4UL);
#line 1041
  cf_arg_28 = (struct ldv_struct_platform_instance_13 *)tmp___3;
#line 1042
  ldv_struct_ide_proc_devset_dummy_resourceless_instance_28((void *)cf_arg_28);
#line 1043
  tmp___4 = ldv_xmalloc(4UL);
#line 1043
  cf_arg_29 = (struct ldv_struct_platform_instance_13 *)tmp___4;
#line 1044
  ldv_struct_ide_proc_devset_dummy_resourceless_instance_29((void *)cf_arg_29);
#line 1045
  tmp___5 = ldv_xmalloc(4UL);
#line 1045
  cf_arg_30 = (struct ldv_struct_platform_instance_13 *)tmp___5;
#line 1046
  ldv_struct_ide_proc_devset_dummy_resourceless_instance_30((void *)cf_arg_30);
#line 1047
  tmp___6 = ldv_xmalloc(4UL);
#line 1047
  cf_arg_31 = (struct ldv_struct_platform_instance_13 *)tmp___6;
#line 1048
  ldv_struct_ide_proc_devset_dummy_resourceless_instance_31((void *)cf_arg_31);
  }
#line 1049
  return;
}
}
#line 1053 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_11_41_14(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_32 ;
  void *tmp ;

  {
  {
#line 1056
  tmp = ldv_xmalloc(4UL);
#line 1056
  cf_arg_32 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1057
  ldv_struct_ide_tp_ops_dummy_resourceless_instance_32((void *)cf_arg_32);
  }
#line 1058
  return;
}
}
#line 1062 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_12_41_15(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_33 ;
  struct ldv_struct_platform_instance_13 *cf_arg_34 ;
  struct ldv_struct_platform_instance_13 *cf_arg_35 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1067
  tmp = ldv_xmalloc(4UL);
#line 1067
  cf_arg_33 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1068
  ldv_struct_kernel_param_ops_dummy_resourceless_instance_33((void *)cf_arg_33);
#line 1069
  tmp___0 = ldv_xmalloc(4UL);
#line 1069
  cf_arg_34 = (struct ldv_struct_platform_instance_13 *)tmp___0;
#line 1070
  ldv_struct_kernel_param_ops_dummy_resourceless_instance_34((void *)cf_arg_34);
#line 1071
  tmp___1 = ldv_xmalloc(4UL);
#line 1071
  cf_arg_35 = (struct ldv_struct_platform_instance_13 *)tmp___1;
#line 1072
  ldv_struct_kernel_param_ops_dummy_resourceless_instance_35((void *)cf_arg_35);
  }
#line 1073
  return;
}
}
#line 1077 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_8_41_16(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_16 ;
  struct ldv_struct_platform_instance_13 *cf_arg_17 ;
  struct ldv_struct_platform_instance_13 *cf_arg_18 ;
  struct ldv_struct_platform_instance_13 *cf_arg_19 ;
  struct ldv_struct_platform_instance_13 *cf_arg_20 ;
  struct ldv_struct_platform_instance_13 *cf_arg_21 ;
  struct ldv_struct_platform_instance_13 *cf_arg_22 ;
  struct ldv_struct_platform_instance_13 *cf_arg_14 ;
  struct ldv_struct_platform_instance_13 *cf_arg_15 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 1088
  tmp = ldv_xmalloc(4UL);
#line 1088
  cf_arg_16 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1089
  ldv_struct_device_attribute_dummy_resourceless_instance_16((void *)cf_arg_16);
#line 1090
  tmp___0 = ldv_xmalloc(4UL);
#line 1090
  cf_arg_17 = (struct ldv_struct_platform_instance_13 *)tmp___0;
#line 1091
  ldv_struct_device_attribute_dummy_resourceless_instance_17((void *)cf_arg_17);
#line 1092
  tmp___1 = ldv_xmalloc(4UL);
#line 1092
  cf_arg_18 = (struct ldv_struct_platform_instance_13 *)tmp___1;
#line 1093
  ldv_struct_device_attribute_dummy_resourceless_instance_18((void *)cf_arg_18);
#line 1094
  tmp___2 = ldv_xmalloc(4UL);
#line 1094
  cf_arg_19 = (struct ldv_struct_platform_instance_13 *)tmp___2;
#line 1095
  ldv_struct_device_attribute_dummy_resourceless_instance_19((void *)cf_arg_19);
#line 1096
  tmp___3 = ldv_xmalloc(4UL);
#line 1096
  cf_arg_20 = (struct ldv_struct_platform_instance_13 *)tmp___3;
#line 1097
  ldv_struct_device_attribute_dummy_resourceless_instance_20((void *)cf_arg_20);
#line 1098
  tmp___4 = ldv_xmalloc(4UL);
#line 1098
  cf_arg_21 = (struct ldv_struct_platform_instance_13 *)tmp___4;
#line 1099
  ldv_struct_device_attribute_dummy_resourceless_instance_21((void *)cf_arg_21);
#line 1100
  tmp___5 = ldv_xmalloc(4UL);
#line 1100
  cf_arg_22 = (struct ldv_struct_platform_instance_13 *)tmp___5;
#line 1101
  ldv_struct_device_attribute_dummy_resourceless_instance_22((void *)cf_arg_22);
#line 1102
  tmp___6 = ldv_xmalloc(4UL);
#line 1102
  cf_arg_14 = (struct ldv_struct_platform_instance_13 *)tmp___6;
#line 1103
  ldv_struct_device_attribute_dummy_resourceless_instance_14((void *)cf_arg_14);
#line 1104
  tmp___7 = ldv_xmalloc(4UL);
#line 1104
  cf_arg_15 = (struct ldv_struct_platform_instance_13 *)tmp___7;
#line 1105
  ldv_struct_device_attribute_dummy_resourceless_instance_15((void *)cf_arg_15);
  }
#line 1106
  return;
}
}
#line 1110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_register_dummy_resourceless_instance_9_41_17(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_23 ;
  void *tmp ;

  {
  {
#line 1113
  tmp = ldv_xmalloc(4UL);
#line 1113
  cf_arg_23 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1114
  ldv_struct_dmi_system_id_dummy_resourceless_instance_23((void *)cf_arg_23);
  }
#line 1115
  return;
}
}
#line 1119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_register_file_operations_instance_4_41_18(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_0 ;
  struct ldv_struct_platform_instance_13 *cf_arg_1 ;
  struct ldv_struct_platform_instance_13 *cf_arg_2 ;
  struct ldv_struct_platform_instance_13 *cf_arg_3 ;
  struct ldv_struct_platform_instance_13 *cf_arg_4 ;
  struct ldv_struct_platform_instance_13 *cf_arg_5 ;
  struct ldv_struct_platform_instance_13 *cf_arg_6 ;
  struct ldv_struct_platform_instance_13 *cf_arg_7 ;
  struct ldv_struct_platform_instance_13 *cf_arg_8 ;
  struct ldv_struct_platform_instance_13 *cf_arg_9 ;
  struct ldv_struct_platform_instance_13 *cf_arg_10 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 1132
  tmp = ldv_xmalloc(4UL);
#line 1132
  cf_arg_0 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1133
  ldv_file_operations_file_operations_instance_0((void *)cf_arg_0);
#line 1134
  tmp___0 = ldv_xmalloc(4UL);
#line 1134
  cf_arg_1 = (struct ldv_struct_platform_instance_13 *)tmp___0;
#line 1135
  ldv_file_operations_file_operations_instance_1((void *)cf_arg_1);
#line 1136
  tmp___1 = ldv_xmalloc(4UL);
#line 1136
  cf_arg_2 = (struct ldv_struct_platform_instance_13 *)tmp___1;
#line 1137
  ldv_file_operations_file_operations_instance_2((void *)cf_arg_2);
#line 1138
  tmp___2 = ldv_xmalloc(4UL);
#line 1138
  cf_arg_3 = (struct ldv_struct_platform_instance_13 *)tmp___2;
#line 1139
  ldv_file_operations_file_operations_instance_3((void *)cf_arg_3);
#line 1140
  tmp___3 = ldv_xmalloc(4UL);
#line 1140
  cf_arg_4 = (struct ldv_struct_platform_instance_13 *)tmp___3;
#line 1141
  ldv_file_operations_file_operations_instance_4((void *)cf_arg_4);
#line 1142
  tmp___4 = ldv_xmalloc(4UL);
#line 1142
  cf_arg_5 = (struct ldv_struct_platform_instance_13 *)tmp___4;
#line 1143
  ldv_file_operations_file_operations_instance_5((void *)cf_arg_5);
#line 1144
  tmp___5 = ldv_xmalloc(4UL);
#line 1144
  cf_arg_6 = (struct ldv_struct_platform_instance_13 *)tmp___5;
#line 1145
  ldv_file_operations_file_operations_instance_6((void *)cf_arg_6);
#line 1146
  tmp___6 = ldv_xmalloc(4UL);
#line 1146
  cf_arg_7 = (struct ldv_struct_platform_instance_13 *)tmp___6;
#line 1147
  ldv_file_operations_file_operations_instance_7((void *)cf_arg_7);
#line 1148
  tmp___7 = ldv_xmalloc(4UL);
#line 1148
  cf_arg_8 = (struct ldv_struct_platform_instance_13 *)tmp___7;
#line 1149
  ldv_file_operations_file_operations_instance_8((void *)cf_arg_8);
#line 1150
  tmp___8 = ldv_xmalloc(4UL);
#line 1150
  cf_arg_9 = (struct ldv_struct_platform_instance_13 *)tmp___8;
#line 1151
  ldv_file_operations_file_operations_instance_9((void *)cf_arg_9);
#line 1152
  tmp___9 = ldv_xmalloc(4UL);
#line 1152
  cf_arg_10 = (struct ldv_struct_platform_instance_13 *)tmp___9;
#line 1153
  ldv_file_operations_file_operations_instance_10((void *)cf_arg_10);
  }
#line 1154
  return;
}
}
#line 1158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dispatch_register_platform_instance_7_41_19(void) 
{ 
  struct ldv_struct_platform_instance_13 *cf_arg_13 ;
  void *tmp ;

  {
  {
#line 1161
  tmp = ldv_xmalloc(4UL);
#line 1161
  cf_arg_13 = (struct ldv_struct_platform_instance_13 *)tmp;
#line 1162
  ldv_pm_platform_instance_13((void *)cf_arg_13);
  }
#line 1163
  return;
}
}
#line 1167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_14_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 1168
  (*arg0)(arg1, arg2, arg3);
  }
#line 1169
  return;
}
}
#line 1172 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_15_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1173
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1174
  return;
}
}
#line 1177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_16_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1178
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1179
  return;
}
}
#line 1182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_17_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1183
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1184
  return;
}
}
#line 1187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_18_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1188
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1189
  return;
}
}
#line 1192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_19_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1193
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1194
  return;
}
}
#line 1197 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_20_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 1198
  (*arg0)(arg1, arg2, arg3);
  }
#line 1199
  return;
}
}
#line 1202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_21_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 1203
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1204
  return;
}
}
#line 1207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_33_3(int (*arg0)(char * , struct kernel_param * ) ,
                                                   char *arg1 , struct kernel_param *arg2 ) 
{ 


  {
  {
#line 1208
  ide_set_disk_chs((char const   *)arg1, arg2);
  }
#line 1209
  return;
}
}
#line 1212 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_34_3(int (*arg0)(char * , struct kernel_param * ) ,
                                                   char *arg1 , struct kernel_param *arg2 ) 
{ 


  {
  {
#line 1213
  ide_set_ignore_cable((char const   *)arg1, arg2);
  }
#line 1214
  return;
}
}
#line 1217 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_dummy_resourceless_instance_callback_35_3(int (*arg0)(char * , struct kernel_param * ) ,
                                                   char *arg1 , struct kernel_param *arg2 ) 
{ 


  {
  {
#line 1218
  ide_set_dev_param_mask((char const   *)arg1, (struct kernel_param  const  *)arg2);
  }
#line 1219
  return;
}
}
#line 1222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_entry_EMGentry_41(void *arg0 ) 
{ 
  void (*ldv_41_exit_ide_exit_default)(void) ;
  int (*ldv_41_init_ide_init_default)(void) ;
  int ldv_41_ret_default ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1231
  ldv_41_ret_default = ldv_EMGentry_init_ide_init_41_23(ldv_41_init_ide_init_default);
#line 1233
  ldv_41_ret_default = ldv_ldv_post_init_99(ldv_41_ret_default);
#line 1236
  tmp___0 = ldv_undef_int();
  }
#line 1236
  if (tmp___0 != 0) {
    {
#line 1238
    ldv_assume(ldv_41_ret_default != 0);
#line 1242
    ldv_ldv_check_final_state_100();
#line 1243
    ldv_stop();
    }
#line 1247
    return;
  } else {
    {
#line 1251
    ldv_assume(ldv_41_ret_default == 0);
#line 1254
    tmp = ldv_undef_int();
    }
#line 1254
    if (tmp != 0) {
      {
#line 1256
      ldv_dispatch_register_platform_instance_7_41_19();
#line 1260
      ldv_dispatch_register_file_operations_instance_4_41_18();
#line 1264
      ldv_dispatch_register_dummy_resourceless_instance_9_41_17();
#line 1268
      ldv_dispatch_register_dummy_resourceless_instance_8_41_16();
#line 1272
      ldv_dispatch_register_dummy_resourceless_instance_12_41_15();
#line 1276
      ldv_dispatch_register_dummy_resourceless_instance_11_41_14();
#line 1280
      ldv_dispatch_register_dummy_resourceless_instance_10_41_13();
#line 1284
      ldv_dispatch_register_dummy_factory_14_41_12();
#line 1288
      ldv_dispatch_deregister_platform_instance_7_41_11();
#line 1292
      ldv_dispatch_deregister_file_operations_instance_4_41_10();
#line 1296
      ldv_dispatch_deregister_dummy_resourceless_instance_9_41_9();
#line 1300
      ldv_dispatch_deregister_dummy_resourceless_instance_8_41_8();
#line 1304
      ldv_dispatch_deregister_dummy_resourceless_instance_12_41_7();
#line 1308
      ldv_dispatch_deregister_dummy_resourceless_instance_11_41_6();
#line 1312
      ldv_dispatch_deregister_dummy_resourceless_instance_10_41_5();
#line 1316
      ldv_dispatch_deregister_dummy_factory_14_41_4();
      }
    } else {

    }
    {
#line 1327
    ldv_EMGentry_exit_ide_exit_41_2(ldv_41_exit_ide_exit_default);
#line 1331
    ldv_ldv_check_final_state_101();
#line 1332
    ldv_stop();
    }
#line 1336
    return;
  }
#line 1339
  return;
}
}
#line 1344 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void main(void) 
{ 


  {
  {
#line 1345
  ldv_ldv_initialize_102();
#line 1346
  ldv_entry_EMGentry_41((void *)0);
  }
#line 1347
  return;
}
}
#line 1351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_0_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1352
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1353
  return;
}
}
#line 1356 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_1_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1357
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1358
  return;
}
}
#line 1361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_2_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1362
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1363
  return;
}
}
#line 1366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_4_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1367
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1368
  return;
}
}
#line 1371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_5_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1372
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1373
  return;
}
}
#line 1376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_6_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1377
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1378
  return;
}
}
#line 1381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_7_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1382
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1383
  return;
}
}
#line 1386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_8_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1387
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1388
  return;
}
}
#line 1391 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_file_operations_instance_write_9_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 1392
  (*arg0)(arg1, arg2, arg3, arg4);
  }
#line 1393
  return;
}
}
#line 1396 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
enum irqreturn ldv_interrupt_instance_handler_11_5(enum irqreturn (*arg0)(int  , void * ) ,
                                                   int arg1 , void *arg2 ) 
{ 
  enum irqreturn tmp ;

  {
  {
#line 1397
  tmp = (*arg0)(arg1, arg2);
  }
#line 1397
  return (tmp);
}
}
#line 1401 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_interrupt_instance_thread_11_3(enum irqreturn (*arg0)(int  , void * ) , int arg1 ,
                                        void *arg2 ) 
{ 


  {
  {
#line 1402
  (*arg0)(arg1, arg2);
  }
#line 1403
  return;
}
}
#line 1406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_interrupt_interrupt_instance_11(void *arg0 ) 
{ 
  enum irqreturn (*ldv_11_callback_handler)(int  , void * ) ;
  void *ldv_11_data_data ;
  int ldv_11_line_line ;
  enum irqreturn ldv_11_ret_val_default ;
  enum irqreturn (*ldv_11_thread_thread)(int  , void * ) ;
  struct ldv_struct_interrupt_instance_11 *data ;
  int tmp ;

  {
#line 1415
  data = (struct ldv_struct_interrupt_instance_11 *)arg0;
#line 1420
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_interrupt_instance_11 *)0)) {
    {
#line 1421
    ldv_11_line_line = data->arg0;
#line 1422
    ldv_11_callback_handler = data->arg1;
#line 1423
    ldv_11_thread_thread = data->arg2;
#line 1424
    ldv_11_data_data = data->arg3;
#line 1425
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 1431
  ldv_switch_to_interrupt_context();
  }
#line 1432
  if ((unsigned long )ldv_11_callback_handler != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                      void * ))0)) {
    {
#line 1434
    ldv_11_ret_val_default = ldv_interrupt_instance_handler_11_5(ldv_11_callback_handler,
                                                                 ldv_11_line_line,
                                                                 ldv_11_data_data);
    }
  } else {

  }
  {
#line 1437
  ldv_switch_to_process_context();
#line 1440
  tmp = ldv_undef_int();
  }
#line 1440
  if (tmp != 0) {
    {
#line 1442
    ldv_assume((unsigned int )ldv_11_ret_val_default == 2U);
    }
#line 1446
    if ((unsigned long )ldv_11_thread_thread != (unsigned long )((enum irqreturn (*)(int  ,
                                                                                     void * ))0)) {
      {
#line 1448
      ldv_interrupt_instance_thread_11_3(ldv_11_thread_thread, ldv_11_line_line, ldv_11_data_data);
      }
    } else {

    }
  } else {
    {
#line 1455
    ldv_assume((unsigned int )ldv_11_ret_val_default != 2U);
    }
  }
#line 1464
  return;
#line 1466
  return;
}
}
#line 1471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
int ldv_platform_instance_probe_13_14(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) 
{ 
  int tmp ;

  {
  {
#line 1472
  tmp = (*arg0)(arg1);
  }
#line 1472
  return (tmp);
}
}
#line 1476 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_platform_instance_release_13_3(int (*arg0)(struct platform_device * ) , struct platform_device *arg1 ) 
{ 


  {
  {
#line 1477
  (*arg0)(arg1);
  }
#line 1478
  return;
}
}
#line 1481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_complete_12_3(void (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1482
  (*arg0)(arg1);
  }
#line 1483
  return;
}
}
#line 1486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_freeze_12_15(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1487
  (*arg0)(arg1);
  }
#line 1488
  return;
}
}
#line 1491 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_freeze_late_12_14(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1492
  (*arg0)(arg1);
  }
#line 1493
  return;
}
}
#line 1496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_freeze_noirq_12_12(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1497
  (*arg0)(arg1);
  }
#line 1498
  return;
}
}
#line 1501 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_poweroff_12_9(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1502
  (*arg0)(arg1);
  }
#line 1503
  return;
}
}
#line 1506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_poweroff_late_12_8(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1507
  (*arg0)(arg1);
  }
#line 1508
  return;
}
}
#line 1511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_poweroff_noirq_12_6(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1512
  (*arg0)(arg1);
  }
#line 1513
  return;
}
}
#line 1516 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_prepare_12_22(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1517
  (*arg0)(arg1);
  }
#line 1518
  return;
}
}
#line 1521 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_restore_12_4(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1522
  (*arg0)(arg1);
  }
#line 1523
  return;
}
}
#line 1526 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_restore_early_12_7(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1527
  (*arg0)(arg1);
  }
#line 1528
  return;
}
}
#line 1531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_restore_noirq_12_5(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1532
  (*arg0)(arg1);
  }
#line 1533
  return;
}
}
#line 1536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_resume_12_16(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1537
  generic_ide_resume(arg1);
  }
#line 1538
  return;
}
}
#line 1541 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_resume_early_12_17(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1542
  (*arg0)(arg1);
  }
#line 1543
  return;
}
}
#line 1546 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_resume_noirq_12_19(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1547
  (*arg0)(arg1);
  }
#line 1548
  return;
}
}
#line 1551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_runtime_idle_12_27(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1552
  (*arg0)(arg1);
  }
#line 1553
  return;
}
}
#line 1556 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_runtime_resume_12_24(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1557
  (*arg0)(arg1);
  }
#line 1558
  return;
}
}
#line 1561 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_runtime_suspend_12_25(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1562
  (*arg0)(arg1);
  }
#line 1563
  return;
}
}
#line 1566 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_suspend_12_21(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1567
  (*arg0)(arg1);
  }
#line 1568
  return;
}
}
#line 1571 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_suspend_late_12_18(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1572
  (*arg0)(arg1);
  }
#line 1573
  return;
}
}
#line 1576 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_suspend_noirq_12_20(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1577
  (*arg0)(arg1);
  }
#line 1578
  return;
}
}
#line 1581 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_thaw_12_10(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1582
  (*arg0)(arg1);
  }
#line 1583
  return;
}
}
#line 1586 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_thaw_early_12_13(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1587
  (*arg0)(arg1);
  }
#line 1588
  return;
}
}
#line 1591 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_ops_instance_thaw_noirq_12_11(int (*arg0)(struct device * ) , struct device *arg1 ) 
{ 


  {
  {
#line 1592
  (*arg0)(arg1);
  }
#line 1593
  return;
}
}
#line 1596 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_platform_instance_13(void *arg0 ) 
{ 
  struct platform_driver *ldv_13_container_platform_driver ;
  struct platform_device *ldv_13_ldv_param_14_0_default ;
  struct platform_device *ldv_13_ldv_param_3_0_default ;
  int ldv_13_probed_default ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 1605
  ldv_13_probed_default = 1;
#line 1616
  goto ldv_main_13;
#line 1618
  return;
  ldv_main_13: 
  {
#line 1624
  tmp___1 = ldv_undef_int();
  }
#line 1624
  if (tmp___1 != 0) {
    {
#line 1626
    tmp = ldv_xmalloc(1464UL);
#line 1626
    ldv_13_ldv_param_14_0_default = (struct platform_device *)tmp;
#line 1631
    ldv_ldv_pre_probe_103();
    }
#line 1632
    if ((unsigned long )ldv_13_container_platform_driver->probe != (unsigned long )((int (*)(struct platform_device * ))0)) {
      {
#line 1634
      ldv_13_probed_default = ldv_platform_instance_probe_13_14(ldv_13_container_platform_driver->probe,
                                                                ldv_13_ldv_param_14_0_default);
      }
    } else {

    }
    {
#line 1637
    ldv_13_probed_default = ldv_ldv_post_probe_104(ldv_13_probed_default);
#line 1641
    ldv_free((void *)ldv_13_ldv_param_14_0_default);
#line 1644
    tmp___0 = ldv_undef_int();
    }
#line 1644
    if (tmp___0 != 0) {
      {
#line 1646
      ldv_assume(ldv_13_probed_default == 0);
      }
#line 1653
      goto ldv_call_13;
    } else {
      {
#line 1657
      ldv_assume(ldv_13_probed_default != 0);
      }
#line 1664
      goto ldv_main_13;
    }
  } else {
#line 1676
    return;
  }
#line 1679
  return;
  ldv_call_13: 
  {
#line 1685
  tmp___2 = ldv_undef_int();
  }
  {
#line 1686
  if (tmp___2 == 1) {
#line 1686
    goto case_1;
  } else {

  }
#line 1713
  if (tmp___2 == 2) {
#line 1713
    goto case_2;
  } else {

  }
#line 1725
  if (tmp___2 == 3) {
#line 1725
    goto case_3;
  } else {

  }
#line 1743
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1688
  tmp___3 = ldv_xmalloc(1464UL);
#line 1688
  ldv_13_ldv_param_3_0_default = (struct platform_device *)tmp___3;
  }
#line 1692
  if ((unsigned long )ldv_13_container_platform_driver->remove != (unsigned long )((int (*)(struct platform_device * ))0)) {
    {
#line 1694
    ldv_platform_instance_release_13_3(ldv_13_container_platform_driver->remove, ldv_13_ldv_param_3_0_default);
    }
  } else {

  }
  {
#line 1699
  ldv_free((void *)ldv_13_ldv_param_3_0_default);
#line 1703
  ldv_13_probed_default = 1;
  }
#line 1710
  goto ldv_main_13;
  case_2: /* CIL Label */ ;
#line 1722
  goto ldv_call_13;
  case_3: /* CIL Label */ 
  {
#line 1727
  ldv_dispatch_pm_register_13_6();
#line 1731
  ldv_dispatch_pm_deregister_13_5();
  }
#line 1738
  goto ldv_call_13;
#line 1740
  goto ldv_call_13;
  switch_default: /* CIL Label */ 
  {
#line 1743
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1746
  return;
}
}
#line 1751 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_pm_pm_ops_instance_12(void *arg0 ) 
{ 
  struct device *ldv_12_device_device ;
  struct dev_pm_ops *ldv_12_pm_ops_dev_pm_ops ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1764
  goto ldv_do_12;
#line 1766
  return;
  ldv_do_12: 
  {
#line 1772
  tmp = ldv_undef_int();
  }
  {
#line 1773
  if (tmp == 1) {
#line 1773
    goto case_1;
  } else {

  }
#line 1788
  if (tmp == 2) {
#line 1788
    goto case_2;
  } else {

  }
#line 1810
  if (tmp == 3) {
#line 1810
    goto case_3;
  } else {

  }
#line 1980
  if (tmp == 4) {
#line 1980
    goto case_4;
  } else {

  }
#line 1989
  goto switch_default___0;
  case_1: /* CIL Label */ ;
#line 1775
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->runtime_idle != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1777
    ldv_pm_ops_instance_runtime_idle_12_27(ldv_12_pm_ops_dev_pm_ops->runtime_idle,
                                           ldv_12_device_device);
    }
  } else {

  }
#line 1785
  goto ldv_do_12;
  case_2: /* CIL Label */ ;
#line 1790
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->runtime_suspend != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1792
    ldv_pm_ops_instance_runtime_suspend_12_25(ldv_12_pm_ops_dev_pm_ops->runtime_suspend,
                                              ldv_12_device_device);
    }
  } else {

  }
#line 1797
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->runtime_resume != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1799
    ldv_pm_ops_instance_runtime_resume_12_24(ldv_12_pm_ops_dev_pm_ops->runtime_resume,
                                             ldv_12_device_device);
    }
  } else {

  }
#line 1807
  goto ldv_do_12;
  case_3: /* CIL Label */ ;
#line 1812
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->prepare != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1814
    ldv_pm_ops_instance_prepare_12_22(ldv_12_pm_ops_dev_pm_ops->prepare, ldv_12_device_device);
    }
  } else {

  }
  {
#line 1818
  tmp___0 = ldv_undef_int();
  }
  {
#line 1819
  if (tmp___0 == 1) {
#line 1819
    goto case_1___0;
  } else {

  }
#line 1866
  if (tmp___0 == 2) {
#line 1866
    goto case_2___0;
  } else {

  }
#line 1915
  if (tmp___0 == 3) {
#line 1915
    goto case_3___0;
  } else {

  }
#line 1964
  goto switch_default;
  case_1___0: /* CIL Label */ ;
#line 1821
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->suspend != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1823
    ldv_pm_ops_instance_suspend_12_21(ldv_12_pm_ops_dev_pm_ops->suspend, ldv_12_device_device);
    }
  } else {

  }
  {
#line 1827
  tmp___1 = ldv_undef_int();
  }
#line 1827
  if (tmp___1 != 0) {
#line 1829
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->suspend_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1831
      ldv_pm_ops_instance_suspend_noirq_12_20(ldv_12_pm_ops_dev_pm_ops->suspend_noirq,
                                              ldv_12_device_device);
      }
    } else {

    }
#line 1836
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->resume_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1838
      ldv_pm_ops_instance_resume_noirq_12_19(ldv_12_pm_ops_dev_pm_ops->resume_noirq,
                                             ldv_12_device_device);
      }
    } else {

    }
  } else {
#line 1845
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->suspend_late != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1847
      ldv_pm_ops_instance_suspend_late_12_18(ldv_12_pm_ops_dev_pm_ops->suspend_late,
                                             ldv_12_device_device);
      }
    } else {

    }
#line 1852
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->resume_early != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1854
      ldv_pm_ops_instance_resume_early_12_17(ldv_12_pm_ops_dev_pm_ops->resume_early,
                                             ldv_12_device_device);
      }
    } else {

    }
  }
  {
#line 1861
  ldv_pm_ops_instance_resume_12_16(ldv_12_pm_ops_dev_pm_ops->resume, ldv_12_device_device);
  }
#line 1864
  goto ldv_40805;
  case_2___0: /* CIL Label */ ;
#line 1868
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->freeze != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1870
    ldv_pm_ops_instance_freeze_12_15(ldv_12_pm_ops_dev_pm_ops->freeze, ldv_12_device_device);
    }
  } else {

  }
  {
#line 1874
  tmp___2 = ldv_undef_int();
  }
#line 1874
  if (tmp___2 != 0) {
#line 1876
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->freeze_late != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1878
      ldv_pm_ops_instance_freeze_late_12_14(ldv_12_pm_ops_dev_pm_ops->freeze_late,
                                            ldv_12_device_device);
      }
    } else {

    }
#line 1883
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->thaw_early != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1885
      ldv_pm_ops_instance_thaw_early_12_13(ldv_12_pm_ops_dev_pm_ops->thaw_early, ldv_12_device_device);
      }
    } else {

    }
  } else {
#line 1892
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->freeze_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1894
      ldv_pm_ops_instance_freeze_noirq_12_12(ldv_12_pm_ops_dev_pm_ops->freeze_noirq,
                                             ldv_12_device_device);
      }
    } else {

    }
#line 1899
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->thaw_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1901
      ldv_pm_ops_instance_thaw_noirq_12_11(ldv_12_pm_ops_dev_pm_ops->thaw_noirq, ldv_12_device_device);
      }
    } else {

    }
  }
#line 1907
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->thaw != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1909
    ldv_pm_ops_instance_thaw_12_10(ldv_12_pm_ops_dev_pm_ops->thaw, ldv_12_device_device);
    }
  } else {

  }
#line 1913
  goto ldv_40805;
  case_3___0: /* CIL Label */ ;
#line 1917
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->poweroff != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1919
    ldv_pm_ops_instance_poweroff_12_9(ldv_12_pm_ops_dev_pm_ops->poweroff, ldv_12_device_device);
    }
  } else {

  }
  {
#line 1923
  tmp___3 = ldv_undef_int();
  }
#line 1923
  if (tmp___3 != 0) {
#line 1925
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->poweroff_late != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1927
      ldv_pm_ops_instance_poweroff_late_12_8(ldv_12_pm_ops_dev_pm_ops->poweroff_late,
                                             ldv_12_device_device);
      }
    } else {

    }
#line 1932
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->restore_early != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1934
      ldv_pm_ops_instance_restore_early_12_7(ldv_12_pm_ops_dev_pm_ops->restore_early,
                                             ldv_12_device_device);
      }
    } else {

    }
  } else {
#line 1941
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->poweroff_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1943
      ldv_pm_ops_instance_poweroff_noirq_12_6(ldv_12_pm_ops_dev_pm_ops->poweroff_noirq,
                                              ldv_12_device_device);
      }
    } else {

    }
#line 1948
    if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->restore_noirq != (unsigned long )((int (*)(struct device * ))0)) {
      {
#line 1950
      ldv_pm_ops_instance_restore_noirq_12_5(ldv_12_pm_ops_dev_pm_ops->restore_noirq,
                                             ldv_12_device_device);
      }
    } else {

    }
  }
#line 1956
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->restore != (unsigned long )((int (*)(struct device * ))0)) {
    {
#line 1958
    ldv_pm_ops_instance_restore_12_4(ldv_12_pm_ops_dev_pm_ops->restore, ldv_12_device_device);
    }
  } else {

  }
#line 1962
  goto ldv_40805;
  switch_default: /* CIL Label */ 
  {
#line 1964
  ldv_stop();
  }
  switch_break___0: /* CIL Label */ ;
  }
  ldv_40805: ;
#line 1967
  if ((unsigned long )ldv_12_pm_ops_dev_pm_ops->complete != (unsigned long )((void (*)(struct device * ))0)) {
    {
#line 1969
    ldv_pm_ops_instance_complete_12_3(ldv_12_pm_ops_dev_pm_ops->complete, ldv_12_device_device);
    }
  } else {

  }
#line 1977
  goto ldv_do_12;
  case_4: /* CIL Label */ ;
#line 1986
  return;
  switch_default___0: /* CIL Label */ 
  {
#line 1989
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1992
  return;
}
}
#line 1997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_dmi_system_id_dummy_resourceless_instance_23(void *arg0 ) 
{ 
  int (*ldv_23_callback_callback)(struct dmi_system_id * ) ;
  struct dmi_system_id *ldv_23_container_struct_dmi_system_id ;
  int tmp ;

  {
#line 2010
  goto ldv_call_23;
#line 2012
  return;
  ldv_call_23: 
  {
#line 2018
  tmp = ldv_undef_int();
  }
#line 2018
  if (tmp != 0) {
    {
#line 2021
    ldv_dummy_resourceless_instance_callback_23_3(ldv_23_callback_callback, ldv_23_container_struct_dmi_system_id);
    }
#line 2028
    goto ldv_call_23;
  } else {
#line 2036
    return;
  }
#line 2039
  return;
}
}
#line 2044 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_24(void *arg0 ) 
{ 
  int (*ldv_24_callback_dma_end)(struct ide_drive_s * ) ;
  void (*ldv_24_callback_dma_host_set)(struct ide_drive_s * , int  ) ;
  void (*ldv_24_callback_dma_lost_irq)(struct ide_drive_s * ) ;
  int (*ldv_24_callback_dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
  unsigned char (*ldv_24_callback_dma_sff_read_status)(struct hwif_s * ) ;
  void (*ldv_24_callback_dma_start)(struct ide_drive_s * ) ;
  int (*ldv_24_callback_dma_test_irq)(struct ide_drive_s * ) ;
  int (*ldv_24_callback_dma_timer_expiry)(struct ide_drive_s * ) ;
  int (*ldv_24_callback_get)(struct ide_drive_s * ) ;
  int (*ldv_24_callback_set)(struct ide_drive_s * , int  ) ;
  struct hwif_s *ldv_24_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_24_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_24_container_struct_ide_drive_s_ptr ;
  int ldv_24_ldv_param_17_1_default ;
  int ldv_24_ldv_param_7_1_default ;
  int tmp ;

  {
#line 2070
  goto ldv_call_24;
#line 2072
  return;
  ldv_call_24: 
  {
#line 2078
  tmp = ldv_undef_int();
  }
  {
#line 2079
  if (tmp == 1) {
#line 2079
    goto case_1;
  } else {

  }
#line 2098
  if (tmp == 2) {
#line 2098
    goto case_2;
  } else {

  }
#line 2113
  if (tmp == 3) {
#line 2113
    goto case_3;
  } else {

  }
#line 2130
  if (tmp == 4) {
#line 2130
    goto case_4;
  } else {

  }
#line 2149
  if (tmp == 5) {
#line 2149
    goto case_5;
  } else {

  }
#line 2170
  if (tmp == 6) {
#line 2170
    goto case_6;
  } else {

  }
#line 2193
  if (tmp == 7) {
#line 2193
    goto case_7;
  } else {

  }
#line 2218
  if (tmp == 8) {
#line 2218
    goto case_8;
  } else {

  }
#line 2245
  if (tmp == 9) {
#line 2245
    goto case_9;
  } else {

  }
#line 2280
  if (tmp == 10) {
#line 2280
    goto case_10;
  } else {

  }
#line 2311
  if (tmp == 11) {
#line 2311
    goto case_11;
  } else {

  }
#line 2320
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2085
  ldv_dummy_resourceless_instance_callback_24_17(ldv_24_callback_set, ldv_24_container_struct_ide_drive_s_ptr,
                                                 ldv_24_ldv_param_17_1_default);
  }
#line 2095
  goto ldv_call_24;
  case_2: /* CIL Label */ 
  {
#line 2101
  ldv_dummy_resourceless_instance_callback_24_16(ldv_24_callback_get, ldv_24_container_struct_ide_drive_s_ptr);
  }
#line 2108
  goto ldv_call_24;
#line 2110
  goto ldv_call_24;
  case_3: /* CIL Label */ 
  {
#line 2116
  ldv_dummy_resourceless_instance_callback_24_15(ldv_24_callback_dma_timer_expiry,
                                                 ldv_24_container_struct_ide_drive_s_ptr);
  }
#line 2123
  goto ldv_call_24;
#line 2125
  goto ldv_call_24;
#line 2127
  goto ldv_call_24;
  case_4: /* CIL Label */ 
  {
#line 2133
  ldv_dummy_resourceless_instance_callback_24_14(ldv_24_callback_dma_test_irq, ldv_24_container_struct_ide_drive_s_ptr);
  }
#line 2140
  goto ldv_call_24;
#line 2142
  goto ldv_call_24;
#line 2144
  goto ldv_call_24;
#line 2146
  goto ldv_call_24;
  case_5: /* CIL Label */ 
  {
#line 2152
  ldv_dummy_resourceless_instance_callback_24_13(ldv_24_callback_dma_start, ldv_24_container_struct_ide_drive_s_ptr);
  }
#line 2159
  goto ldv_call_24;
#line 2161
  goto ldv_call_24;
#line 2163
  goto ldv_call_24;
#line 2165
  goto ldv_call_24;
#line 2167
  goto ldv_call_24;
  case_6: /* CIL Label */ 
  {
#line 2173
  ldv_dummy_resourceless_instance_callback_24_12(ldv_24_callback_dma_sff_read_status,
                                                 ldv_24_container_struct_hwif_s_ptr);
  }
#line 2180
  goto ldv_call_24;
#line 2182
  goto ldv_call_24;
#line 2184
  goto ldv_call_24;
#line 2186
  goto ldv_call_24;
#line 2188
  goto ldv_call_24;
#line 2190
  goto ldv_call_24;
  case_7: /* CIL Label */ 
  {
#line 2196
  ldv_dummy_resourceless_instance_callback_24_11(ldv_24_callback_dma_setup, ldv_24_container_struct_ide_drive_s_ptr,
                                                 ldv_24_container_struct_ide_cmd_ptr);
  }
#line 2203
  goto ldv_call_24;
#line 2205
  goto ldv_call_24;
#line 2207
  goto ldv_call_24;
#line 2209
  goto ldv_call_24;
#line 2211
  goto ldv_call_24;
#line 2213
  goto ldv_call_24;
#line 2215
  goto ldv_call_24;
  case_8: /* CIL Label */ 
  {
#line 2221
  ldv_dummy_resourceless_instance_callback_24_10(ldv_24_callback_dma_lost_irq, ldv_24_container_struct_ide_drive_s_ptr);
  }
#line 2228
  goto ldv_call_24;
#line 2230
  goto ldv_call_24;
#line 2232
  goto ldv_call_24;
#line 2234
  goto ldv_call_24;
#line 2236
  goto ldv_call_24;
#line 2238
  goto ldv_call_24;
#line 2240
  goto ldv_call_24;
#line 2242
  goto ldv_call_24;
  case_9: /* CIL Label */ 
  {
#line 2251
  ldv_dummy_resourceless_instance_callback_24_7(ldv_24_callback_dma_host_set, ldv_24_container_struct_ide_drive_s_ptr,
                                                ldv_24_ldv_param_7_1_default);
  }
#line 2261
  goto ldv_call_24;
#line 2263
  goto ldv_call_24;
#line 2265
  goto ldv_call_24;
#line 2267
  goto ldv_call_24;
#line 2269
  goto ldv_call_24;
#line 2271
  goto ldv_call_24;
#line 2273
  goto ldv_call_24;
#line 2275
  goto ldv_call_24;
#line 2277
  goto ldv_call_24;
  case_10: /* CIL Label */ 
  {
#line 2283
  ldv_dummy_resourceless_instance_callback_24_3(ldv_24_callback_dma_end, ldv_24_container_struct_ide_drive_s_ptr);
  }
#line 2290
  goto ldv_call_24;
#line 2292
  goto ldv_call_24;
#line 2294
  goto ldv_call_24;
#line 2296
  goto ldv_call_24;
#line 2298
  goto ldv_call_24;
#line 2300
  goto ldv_call_24;
#line 2302
  goto ldv_call_24;
#line 2304
  goto ldv_call_24;
#line 2306
  goto ldv_call_24;
#line 2308
  goto ldv_call_24;
  case_11: /* CIL Label */ ;
#line 2317
  return;
  switch_default: /* CIL Label */ 
  {
#line 2320
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2323
  return;
}
}
#line 2328 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_25(void *arg0 ) 
{ 
  int (*ldv_25_callback_dma_end)(struct ide_drive_s * ) ;
  void (*ldv_25_callback_dma_host_set)(struct ide_drive_s * , int  ) ;
  void (*ldv_25_callback_dma_lost_irq)(struct ide_drive_s * ) ;
  int (*ldv_25_callback_dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
  unsigned char (*ldv_25_callback_dma_sff_read_status)(struct hwif_s * ) ;
  void (*ldv_25_callback_dma_start)(struct ide_drive_s * ) ;
  int (*ldv_25_callback_dma_test_irq)(struct ide_drive_s * ) ;
  int (*ldv_25_callback_dma_timer_expiry)(struct ide_drive_s * ) ;
  int (*ldv_25_callback_get)(struct ide_drive_s * ) ;
  int (*ldv_25_callback_set)(struct ide_drive_s * , int  ) ;
  struct hwif_s *ldv_25_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_25_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_25_container_struct_ide_drive_s_ptr ;
  int ldv_25_ldv_param_17_1_default ;
  int ldv_25_ldv_param_7_1_default ;
  int tmp ;

  {
#line 2354
  goto ldv_call_25;
#line 2356
  return;
  ldv_call_25: 
  {
#line 2362
  tmp = ldv_undef_int();
  }
  {
#line 2363
  if (tmp == 1) {
#line 2363
    goto case_1;
  } else {

  }
#line 2382
  if (tmp == 2) {
#line 2382
    goto case_2;
  } else {

  }
#line 2397
  if (tmp == 3) {
#line 2397
    goto case_3;
  } else {

  }
#line 2414
  if (tmp == 4) {
#line 2414
    goto case_4;
  } else {

  }
#line 2433
  if (tmp == 5) {
#line 2433
    goto case_5;
  } else {

  }
#line 2454
  if (tmp == 6) {
#line 2454
    goto case_6;
  } else {

  }
#line 2477
  if (tmp == 7) {
#line 2477
    goto case_7;
  } else {

  }
#line 2502
  if (tmp == 8) {
#line 2502
    goto case_8;
  } else {

  }
#line 2529
  if (tmp == 9) {
#line 2529
    goto case_9;
  } else {

  }
#line 2564
  if (tmp == 10) {
#line 2564
    goto case_10;
  } else {

  }
#line 2595
  if (tmp == 11) {
#line 2595
    goto case_11;
  } else {

  }
#line 2604
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2369
  ldv_dummy_resourceless_instance_callback_25_17(ldv_25_callback_set, ldv_25_container_struct_ide_drive_s_ptr,
                                                 ldv_25_ldv_param_17_1_default);
  }
#line 2379
  goto ldv_call_25;
  case_2: /* CIL Label */ 
  {
#line 2385
  ldv_dummy_resourceless_instance_callback_25_16(ldv_25_callback_get, ldv_25_container_struct_ide_drive_s_ptr);
  }
#line 2392
  goto ldv_call_25;
#line 2394
  goto ldv_call_25;
  case_3: /* CIL Label */ 
  {
#line 2400
  ldv_dummy_resourceless_instance_callback_25_15(ldv_25_callback_dma_timer_expiry,
                                                 ldv_25_container_struct_ide_drive_s_ptr);
  }
#line 2407
  goto ldv_call_25;
#line 2409
  goto ldv_call_25;
#line 2411
  goto ldv_call_25;
  case_4: /* CIL Label */ 
  {
#line 2417
  ldv_dummy_resourceless_instance_callback_25_14(ldv_25_callback_dma_test_irq, ldv_25_container_struct_ide_drive_s_ptr);
  }
#line 2424
  goto ldv_call_25;
#line 2426
  goto ldv_call_25;
#line 2428
  goto ldv_call_25;
#line 2430
  goto ldv_call_25;
  case_5: /* CIL Label */ 
  {
#line 2436
  ldv_dummy_resourceless_instance_callback_25_13(ldv_25_callback_dma_start, ldv_25_container_struct_ide_drive_s_ptr);
  }
#line 2443
  goto ldv_call_25;
#line 2445
  goto ldv_call_25;
#line 2447
  goto ldv_call_25;
#line 2449
  goto ldv_call_25;
#line 2451
  goto ldv_call_25;
  case_6: /* CIL Label */ 
  {
#line 2457
  ldv_dummy_resourceless_instance_callback_25_12(ldv_25_callback_dma_sff_read_status,
                                                 ldv_25_container_struct_hwif_s_ptr);
  }
#line 2464
  goto ldv_call_25;
#line 2466
  goto ldv_call_25;
#line 2468
  goto ldv_call_25;
#line 2470
  goto ldv_call_25;
#line 2472
  goto ldv_call_25;
#line 2474
  goto ldv_call_25;
  case_7: /* CIL Label */ 
  {
#line 2480
  ldv_dummy_resourceless_instance_callback_25_11(ldv_25_callback_dma_setup, ldv_25_container_struct_ide_drive_s_ptr,
                                                 ldv_25_container_struct_ide_cmd_ptr);
  }
#line 2487
  goto ldv_call_25;
#line 2489
  goto ldv_call_25;
#line 2491
  goto ldv_call_25;
#line 2493
  goto ldv_call_25;
#line 2495
  goto ldv_call_25;
#line 2497
  goto ldv_call_25;
#line 2499
  goto ldv_call_25;
  case_8: /* CIL Label */ 
  {
#line 2505
  ldv_dummy_resourceless_instance_callback_25_10(ldv_25_callback_dma_lost_irq, ldv_25_container_struct_ide_drive_s_ptr);
  }
#line 2512
  goto ldv_call_25;
#line 2514
  goto ldv_call_25;
#line 2516
  goto ldv_call_25;
#line 2518
  goto ldv_call_25;
#line 2520
  goto ldv_call_25;
#line 2522
  goto ldv_call_25;
#line 2524
  goto ldv_call_25;
#line 2526
  goto ldv_call_25;
  case_9: /* CIL Label */ 
  {
#line 2535
  ldv_dummy_resourceless_instance_callback_25_7(ldv_25_callback_dma_host_set, ldv_25_container_struct_ide_drive_s_ptr,
                                                ldv_25_ldv_param_7_1_default);
  }
#line 2545
  goto ldv_call_25;
#line 2547
  goto ldv_call_25;
#line 2549
  goto ldv_call_25;
#line 2551
  goto ldv_call_25;
#line 2553
  goto ldv_call_25;
#line 2555
  goto ldv_call_25;
#line 2557
  goto ldv_call_25;
#line 2559
  goto ldv_call_25;
#line 2561
  goto ldv_call_25;
  case_10: /* CIL Label */ 
  {
#line 2567
  ldv_dummy_resourceless_instance_callback_25_3(ldv_25_callback_dma_end, ldv_25_container_struct_ide_drive_s_ptr);
  }
#line 2574
  goto ldv_call_25;
#line 2576
  goto ldv_call_25;
#line 2578
  goto ldv_call_25;
#line 2580
  goto ldv_call_25;
#line 2582
  goto ldv_call_25;
#line 2584
  goto ldv_call_25;
#line 2586
  goto ldv_call_25;
#line 2588
  goto ldv_call_25;
#line 2590
  goto ldv_call_25;
#line 2592
  goto ldv_call_25;
  case_11: /* CIL Label */ ;
#line 2601
  return;
  switch_default: /* CIL Label */ 
  {
#line 2604
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2607
  return;
}
}
#line 2612 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_26(void *arg0 ) 
{ 
  int (*ldv_26_callback_dma_end)(struct ide_drive_s * ) ;
  void (*ldv_26_callback_dma_host_set)(struct ide_drive_s * , int  ) ;
  void (*ldv_26_callback_dma_lost_irq)(struct ide_drive_s * ) ;
  int (*ldv_26_callback_dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
  unsigned char (*ldv_26_callback_dma_sff_read_status)(struct hwif_s * ) ;
  void (*ldv_26_callback_dma_start)(struct ide_drive_s * ) ;
  int (*ldv_26_callback_dma_test_irq)(struct ide_drive_s * ) ;
  int (*ldv_26_callback_dma_timer_expiry)(struct ide_drive_s * ) ;
  int (*ldv_26_callback_get)(struct ide_drive_s * ) ;
  int (*ldv_26_callback_set)(struct ide_drive_s * , int  ) ;
  struct hwif_s *ldv_26_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_26_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_26_container_struct_ide_drive_s_ptr ;
  int ldv_26_ldv_param_17_1_default ;
  int ldv_26_ldv_param_7_1_default ;
  int tmp ;

  {
#line 2638
  goto ldv_call_26;
#line 2640
  return;
  ldv_call_26: 
  {
#line 2646
  tmp = ldv_undef_int();
  }
  {
#line 2647
  if (tmp == 1) {
#line 2647
    goto case_1;
  } else {

  }
#line 2666
  if (tmp == 2) {
#line 2666
    goto case_2;
  } else {

  }
#line 2681
  if (tmp == 3) {
#line 2681
    goto case_3;
  } else {

  }
#line 2698
  if (tmp == 4) {
#line 2698
    goto case_4;
  } else {

  }
#line 2717
  if (tmp == 5) {
#line 2717
    goto case_5;
  } else {

  }
#line 2738
  if (tmp == 6) {
#line 2738
    goto case_6;
  } else {

  }
#line 2761
  if (tmp == 7) {
#line 2761
    goto case_7;
  } else {

  }
#line 2786
  if (tmp == 8) {
#line 2786
    goto case_8;
  } else {

  }
#line 2813
  if (tmp == 9) {
#line 2813
    goto case_9;
  } else {

  }
#line 2848
  if (tmp == 10) {
#line 2848
    goto case_10;
  } else {

  }
#line 2879
  if (tmp == 11) {
#line 2879
    goto case_11;
  } else {

  }
#line 2888
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2653
  ldv_dummy_resourceless_instance_callback_26_17(ldv_26_callback_set, ldv_26_container_struct_ide_drive_s_ptr,
                                                 ldv_26_ldv_param_17_1_default);
  }
#line 2663
  goto ldv_call_26;
  case_2: /* CIL Label */ 
  {
#line 2669
  ldv_dummy_resourceless_instance_callback_26_16(ldv_26_callback_get, ldv_26_container_struct_ide_drive_s_ptr);
  }
#line 2676
  goto ldv_call_26;
#line 2678
  goto ldv_call_26;
  case_3: /* CIL Label */ 
  {
#line 2684
  ldv_dummy_resourceless_instance_callback_26_15(ldv_26_callback_dma_timer_expiry,
                                                 ldv_26_container_struct_ide_drive_s_ptr);
  }
#line 2691
  goto ldv_call_26;
#line 2693
  goto ldv_call_26;
#line 2695
  goto ldv_call_26;
  case_4: /* CIL Label */ 
  {
#line 2701
  ldv_dummy_resourceless_instance_callback_26_14(ldv_26_callback_dma_test_irq, ldv_26_container_struct_ide_drive_s_ptr);
  }
#line 2708
  goto ldv_call_26;
#line 2710
  goto ldv_call_26;
#line 2712
  goto ldv_call_26;
#line 2714
  goto ldv_call_26;
  case_5: /* CIL Label */ 
  {
#line 2720
  ldv_dummy_resourceless_instance_callback_26_13(ldv_26_callback_dma_start, ldv_26_container_struct_ide_drive_s_ptr);
  }
#line 2727
  goto ldv_call_26;
#line 2729
  goto ldv_call_26;
#line 2731
  goto ldv_call_26;
#line 2733
  goto ldv_call_26;
#line 2735
  goto ldv_call_26;
  case_6: /* CIL Label */ 
  {
#line 2741
  ldv_dummy_resourceless_instance_callback_26_12(ldv_26_callback_dma_sff_read_status,
                                                 ldv_26_container_struct_hwif_s_ptr);
  }
#line 2748
  goto ldv_call_26;
#line 2750
  goto ldv_call_26;
#line 2752
  goto ldv_call_26;
#line 2754
  goto ldv_call_26;
#line 2756
  goto ldv_call_26;
#line 2758
  goto ldv_call_26;
  case_7: /* CIL Label */ 
  {
#line 2764
  ldv_dummy_resourceless_instance_callback_26_11(ldv_26_callback_dma_setup, ldv_26_container_struct_ide_drive_s_ptr,
                                                 ldv_26_container_struct_ide_cmd_ptr);
  }
#line 2771
  goto ldv_call_26;
#line 2773
  goto ldv_call_26;
#line 2775
  goto ldv_call_26;
#line 2777
  goto ldv_call_26;
#line 2779
  goto ldv_call_26;
#line 2781
  goto ldv_call_26;
#line 2783
  goto ldv_call_26;
  case_8: /* CIL Label */ 
  {
#line 2789
  ldv_dummy_resourceless_instance_callback_26_10(ldv_26_callback_dma_lost_irq, ldv_26_container_struct_ide_drive_s_ptr);
  }
#line 2796
  goto ldv_call_26;
#line 2798
  goto ldv_call_26;
#line 2800
  goto ldv_call_26;
#line 2802
  goto ldv_call_26;
#line 2804
  goto ldv_call_26;
#line 2806
  goto ldv_call_26;
#line 2808
  goto ldv_call_26;
#line 2810
  goto ldv_call_26;
  case_9: /* CIL Label */ 
  {
#line 2819
  ldv_dummy_resourceless_instance_callback_26_7(ldv_26_callback_dma_host_set, ldv_26_container_struct_ide_drive_s_ptr,
                                                ldv_26_ldv_param_7_1_default);
  }
#line 2829
  goto ldv_call_26;
#line 2831
  goto ldv_call_26;
#line 2833
  goto ldv_call_26;
#line 2835
  goto ldv_call_26;
#line 2837
  goto ldv_call_26;
#line 2839
  goto ldv_call_26;
#line 2841
  goto ldv_call_26;
#line 2843
  goto ldv_call_26;
#line 2845
  goto ldv_call_26;
  case_10: /* CIL Label */ 
  {
#line 2851
  ldv_dummy_resourceless_instance_callback_26_3(ldv_26_callback_dma_end, ldv_26_container_struct_ide_drive_s_ptr);
  }
#line 2858
  goto ldv_call_26;
#line 2860
  goto ldv_call_26;
#line 2862
  goto ldv_call_26;
#line 2864
  goto ldv_call_26;
#line 2866
  goto ldv_call_26;
#line 2868
  goto ldv_call_26;
#line 2870
  goto ldv_call_26;
#line 2872
  goto ldv_call_26;
#line 2874
  goto ldv_call_26;
#line 2876
  goto ldv_call_26;
  case_11: /* CIL Label */ ;
#line 2885
  return;
  switch_default: /* CIL Label */ 
  {
#line 2888
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 2891
  return;
}
}
#line 2896 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_27(void *arg0 ) 
{ 
  int (*ldv_27_callback_dma_end)(struct ide_drive_s * ) ;
  void (*ldv_27_callback_dma_host_set)(struct ide_drive_s * , int  ) ;
  void (*ldv_27_callback_dma_lost_irq)(struct ide_drive_s * ) ;
  int (*ldv_27_callback_dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
  unsigned char (*ldv_27_callback_dma_sff_read_status)(struct hwif_s * ) ;
  void (*ldv_27_callback_dma_start)(struct ide_drive_s * ) ;
  int (*ldv_27_callback_dma_test_irq)(struct ide_drive_s * ) ;
  int (*ldv_27_callback_dma_timer_expiry)(struct ide_drive_s * ) ;
  int (*ldv_27_callback_get)(struct ide_drive_s * ) ;
  int (*ldv_27_callback_set)(struct ide_drive_s * , int  ) ;
  struct hwif_s *ldv_27_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_27_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_27_container_struct_ide_drive_s_ptr ;
  int ldv_27_ldv_param_17_1_default ;
  int ldv_27_ldv_param_7_1_default ;
  int tmp ;

  {
#line 2922
  goto ldv_call_27;
#line 2924
  return;
  ldv_call_27: 
  {
#line 2930
  tmp = ldv_undef_int();
  }
  {
#line 2931
  if (tmp == 1) {
#line 2931
    goto case_1;
  } else {

  }
#line 2950
  if (tmp == 2) {
#line 2950
    goto case_2;
  } else {

  }
#line 2965
  if (tmp == 3) {
#line 2965
    goto case_3;
  } else {

  }
#line 2982
  if (tmp == 4) {
#line 2982
    goto case_4;
  } else {

  }
#line 3001
  if (tmp == 5) {
#line 3001
    goto case_5;
  } else {

  }
#line 3022
  if (tmp == 6) {
#line 3022
    goto case_6;
  } else {

  }
#line 3045
  if (tmp == 7) {
#line 3045
    goto case_7;
  } else {

  }
#line 3070
  if (tmp == 8) {
#line 3070
    goto case_8;
  } else {

  }
#line 3097
  if (tmp == 9) {
#line 3097
    goto case_9;
  } else {

  }
#line 3132
  if (tmp == 10) {
#line 3132
    goto case_10;
  } else {

  }
#line 3163
  if (tmp == 11) {
#line 3163
    goto case_11;
  } else {

  }
#line 3172
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2937
  ldv_dummy_resourceless_instance_callback_27_17(ldv_27_callback_set, ldv_27_container_struct_ide_drive_s_ptr,
                                                 ldv_27_ldv_param_17_1_default);
  }
#line 2947
  goto ldv_call_27;
  case_2: /* CIL Label */ 
  {
#line 2953
  ldv_dummy_resourceless_instance_callback_27_16(ldv_27_callback_get, ldv_27_container_struct_ide_drive_s_ptr);
  }
#line 2960
  goto ldv_call_27;
#line 2962
  goto ldv_call_27;
  case_3: /* CIL Label */ 
  {
#line 2968
  ldv_dummy_resourceless_instance_callback_27_15(ldv_27_callback_dma_timer_expiry,
                                                 ldv_27_container_struct_ide_drive_s_ptr);
  }
#line 2975
  goto ldv_call_27;
#line 2977
  goto ldv_call_27;
#line 2979
  goto ldv_call_27;
  case_4: /* CIL Label */ 
  {
#line 2985
  ldv_dummy_resourceless_instance_callback_27_14(ldv_27_callback_dma_test_irq, ldv_27_container_struct_ide_drive_s_ptr);
  }
#line 2992
  goto ldv_call_27;
#line 2994
  goto ldv_call_27;
#line 2996
  goto ldv_call_27;
#line 2998
  goto ldv_call_27;
  case_5: /* CIL Label */ 
  {
#line 3004
  ldv_dummy_resourceless_instance_callback_27_13(ldv_27_callback_dma_start, ldv_27_container_struct_ide_drive_s_ptr);
  }
#line 3011
  goto ldv_call_27;
#line 3013
  goto ldv_call_27;
#line 3015
  goto ldv_call_27;
#line 3017
  goto ldv_call_27;
#line 3019
  goto ldv_call_27;
  case_6: /* CIL Label */ 
  {
#line 3025
  ldv_dummy_resourceless_instance_callback_27_12(ldv_27_callback_dma_sff_read_status,
                                                 ldv_27_container_struct_hwif_s_ptr);
  }
#line 3032
  goto ldv_call_27;
#line 3034
  goto ldv_call_27;
#line 3036
  goto ldv_call_27;
#line 3038
  goto ldv_call_27;
#line 3040
  goto ldv_call_27;
#line 3042
  goto ldv_call_27;
  case_7: /* CIL Label */ 
  {
#line 3048
  ldv_dummy_resourceless_instance_callback_27_11(ldv_27_callback_dma_setup, ldv_27_container_struct_ide_drive_s_ptr,
                                                 ldv_27_container_struct_ide_cmd_ptr);
  }
#line 3055
  goto ldv_call_27;
#line 3057
  goto ldv_call_27;
#line 3059
  goto ldv_call_27;
#line 3061
  goto ldv_call_27;
#line 3063
  goto ldv_call_27;
#line 3065
  goto ldv_call_27;
#line 3067
  goto ldv_call_27;
  case_8: /* CIL Label */ 
  {
#line 3073
  ldv_dummy_resourceless_instance_callback_27_10(ldv_27_callback_dma_lost_irq, ldv_27_container_struct_ide_drive_s_ptr);
  }
#line 3080
  goto ldv_call_27;
#line 3082
  goto ldv_call_27;
#line 3084
  goto ldv_call_27;
#line 3086
  goto ldv_call_27;
#line 3088
  goto ldv_call_27;
#line 3090
  goto ldv_call_27;
#line 3092
  goto ldv_call_27;
#line 3094
  goto ldv_call_27;
  case_9: /* CIL Label */ 
  {
#line 3103
  ldv_dummy_resourceless_instance_callback_27_7(ldv_27_callback_dma_host_set, ldv_27_container_struct_ide_drive_s_ptr,
                                                ldv_27_ldv_param_7_1_default);
  }
#line 3113
  goto ldv_call_27;
#line 3115
  goto ldv_call_27;
#line 3117
  goto ldv_call_27;
#line 3119
  goto ldv_call_27;
#line 3121
  goto ldv_call_27;
#line 3123
  goto ldv_call_27;
#line 3125
  goto ldv_call_27;
#line 3127
  goto ldv_call_27;
#line 3129
  goto ldv_call_27;
  case_10: /* CIL Label */ 
  {
#line 3135
  ldv_dummy_resourceless_instance_callback_27_3(ldv_27_callback_dma_end, ldv_27_container_struct_ide_drive_s_ptr);
  }
#line 3142
  goto ldv_call_27;
#line 3144
  goto ldv_call_27;
#line 3146
  goto ldv_call_27;
#line 3148
  goto ldv_call_27;
#line 3150
  goto ldv_call_27;
#line 3152
  goto ldv_call_27;
#line 3154
  goto ldv_call_27;
#line 3156
  goto ldv_call_27;
#line 3158
  goto ldv_call_27;
#line 3160
  goto ldv_call_27;
  case_11: /* CIL Label */ ;
#line 3169
  return;
  switch_default: /* CIL Label */ 
  {
#line 3172
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 3175
  return;
}
}
#line 3180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_28(void *arg0 ) 
{ 
  int (*ldv_28_callback_dma_end)(struct ide_drive_s * ) ;
  void (*ldv_28_callback_dma_host_set)(struct ide_drive_s * , int  ) ;
  void (*ldv_28_callback_dma_lost_irq)(struct ide_drive_s * ) ;
  int (*ldv_28_callback_dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
  unsigned char (*ldv_28_callback_dma_sff_read_status)(struct hwif_s * ) ;
  void (*ldv_28_callback_dma_start)(struct ide_drive_s * ) ;
  int (*ldv_28_callback_dma_test_irq)(struct ide_drive_s * ) ;
  int (*ldv_28_callback_dma_timer_expiry)(struct ide_drive_s * ) ;
  int (*ldv_28_callback_get)(struct ide_drive_s * ) ;
  int (*ldv_28_callback_set)(struct ide_drive_s * , int  ) ;
  struct hwif_s *ldv_28_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_28_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_28_container_struct_ide_drive_s_ptr ;
  int ldv_28_ldv_param_17_1_default ;
  int ldv_28_ldv_param_7_1_default ;
  int tmp ;

  {
#line 3206
  goto ldv_call_28;
#line 3208
  return;
  ldv_call_28: 
  {
#line 3214
  tmp = ldv_undef_int();
  }
  {
#line 3215
  if (tmp == 1) {
#line 3215
    goto case_1;
  } else {

  }
#line 3234
  if (tmp == 2) {
#line 3234
    goto case_2;
  } else {

  }
#line 3249
  if (tmp == 3) {
#line 3249
    goto case_3;
  } else {

  }
#line 3266
  if (tmp == 4) {
#line 3266
    goto case_4;
  } else {

  }
#line 3285
  if (tmp == 5) {
#line 3285
    goto case_5;
  } else {

  }
#line 3306
  if (tmp == 6) {
#line 3306
    goto case_6;
  } else {

  }
#line 3329
  if (tmp == 7) {
#line 3329
    goto case_7;
  } else {

  }
#line 3354
  if (tmp == 8) {
#line 3354
    goto case_8;
  } else {

  }
#line 3381
  if (tmp == 9) {
#line 3381
    goto case_9;
  } else {

  }
#line 3416
  if (tmp == 10) {
#line 3416
    goto case_10;
  } else {

  }
#line 3447
  if (tmp == 11) {
#line 3447
    goto case_11;
  } else {

  }
#line 3456
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 3221
  ldv_dummy_resourceless_instance_callback_28_17(ldv_28_callback_set, ldv_28_container_struct_ide_drive_s_ptr,
                                                 ldv_28_ldv_param_17_1_default);
  }
#line 3231
  goto ldv_call_28;
  case_2: /* CIL Label */ 
  {
#line 3237
  ldv_dummy_resourceless_instance_callback_28_16(ldv_28_callback_get, ldv_28_container_struct_ide_drive_s_ptr);
  }
#line 3244
  goto ldv_call_28;
#line 3246
  goto ldv_call_28;
  case_3: /* CIL Label */ 
  {
#line 3252
  ldv_dummy_resourceless_instance_callback_28_15(ldv_28_callback_dma_timer_expiry,
                                                 ldv_28_container_struct_ide_drive_s_ptr);
  }
#line 3259
  goto ldv_call_28;
#line 3261
  goto ldv_call_28;
#line 3263
  goto ldv_call_28;
  case_4: /* CIL Label */ 
  {
#line 3269
  ldv_dummy_resourceless_instance_callback_28_14(ldv_28_callback_dma_test_irq, ldv_28_container_struct_ide_drive_s_ptr);
  }
#line 3276
  goto ldv_call_28;
#line 3278
  goto ldv_call_28;
#line 3280
  goto ldv_call_28;
#line 3282
  goto ldv_call_28;
  case_5: /* CIL Label */ 
  {
#line 3288
  ldv_dummy_resourceless_instance_callback_28_13(ldv_28_callback_dma_start, ldv_28_container_struct_ide_drive_s_ptr);
  }
#line 3295
  goto ldv_call_28;
#line 3297
  goto ldv_call_28;
#line 3299
  goto ldv_call_28;
#line 3301
  goto ldv_call_28;
#line 3303
  goto ldv_call_28;
  case_6: /* CIL Label */ 
  {
#line 3309
  ldv_dummy_resourceless_instance_callback_28_12(ldv_28_callback_dma_sff_read_status,
                                                 ldv_28_container_struct_hwif_s_ptr);
  }
#line 3316
  goto ldv_call_28;
#line 3318
  goto ldv_call_28;
#line 3320
  goto ldv_call_28;
#line 3322
  goto ldv_call_28;
#line 3324
  goto ldv_call_28;
#line 3326
  goto ldv_call_28;
  case_7: /* CIL Label */ 
  {
#line 3332
  ldv_dummy_resourceless_instance_callback_28_11(ldv_28_callback_dma_setup, ldv_28_container_struct_ide_drive_s_ptr,
                                                 ldv_28_container_struct_ide_cmd_ptr);
  }
#line 3339
  goto ldv_call_28;
#line 3341
  goto ldv_call_28;
#line 3343
  goto ldv_call_28;
#line 3345
  goto ldv_call_28;
#line 3347
  goto ldv_call_28;
#line 3349
  goto ldv_call_28;
#line 3351
  goto ldv_call_28;
  case_8: /* CIL Label */ 
  {
#line 3357
  ldv_dummy_resourceless_instance_callback_28_10(ldv_28_callback_dma_lost_irq, ldv_28_container_struct_ide_drive_s_ptr);
  }
#line 3364
  goto ldv_call_28;
#line 3366
  goto ldv_call_28;
#line 3368
  goto ldv_call_28;
#line 3370
  goto ldv_call_28;
#line 3372
  goto ldv_call_28;
#line 3374
  goto ldv_call_28;
#line 3376
  goto ldv_call_28;
#line 3378
  goto ldv_call_28;
  case_9: /* CIL Label */ 
  {
#line 3387
  ldv_dummy_resourceless_instance_callback_28_7(ldv_28_callback_dma_host_set, ldv_28_container_struct_ide_drive_s_ptr,
                                                ldv_28_ldv_param_7_1_default);
  }
#line 3397
  goto ldv_call_28;
#line 3399
  goto ldv_call_28;
#line 3401
  goto ldv_call_28;
#line 3403
  goto ldv_call_28;
#line 3405
  goto ldv_call_28;
#line 3407
  goto ldv_call_28;
#line 3409
  goto ldv_call_28;
#line 3411
  goto ldv_call_28;
#line 3413
  goto ldv_call_28;
  case_10: /* CIL Label */ 
  {
#line 3419
  ldv_dummy_resourceless_instance_callback_28_3(ldv_28_callback_dma_end, ldv_28_container_struct_ide_drive_s_ptr);
  }
#line 3426
  goto ldv_call_28;
#line 3428
  goto ldv_call_28;
#line 3430
  goto ldv_call_28;
#line 3432
  goto ldv_call_28;
#line 3434
  goto ldv_call_28;
#line 3436
  goto ldv_call_28;
#line 3438
  goto ldv_call_28;
#line 3440
  goto ldv_call_28;
#line 3442
  goto ldv_call_28;
#line 3444
  goto ldv_call_28;
  case_11: /* CIL Label */ ;
#line 3453
  return;
  switch_default: /* CIL Label */ 
  {
#line 3456
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 3459
  return;
}
}
#line 3464 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_29(void *arg0 ) 
{ 
  int (*ldv_29_callback_dma_end)(struct ide_drive_s * ) ;
  void (*ldv_29_callback_dma_host_set)(struct ide_drive_s * , int  ) ;
  void (*ldv_29_callback_dma_lost_irq)(struct ide_drive_s * ) ;
  int (*ldv_29_callback_dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
  unsigned char (*ldv_29_callback_dma_sff_read_status)(struct hwif_s * ) ;
  void (*ldv_29_callback_dma_start)(struct ide_drive_s * ) ;
  int (*ldv_29_callback_dma_test_irq)(struct ide_drive_s * ) ;
  int (*ldv_29_callback_dma_timer_expiry)(struct ide_drive_s * ) ;
  int (*ldv_29_callback_get)(struct ide_drive_s * ) ;
  int (*ldv_29_callback_set)(struct ide_drive_s * , int  ) ;
  struct hwif_s *ldv_29_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_29_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_29_container_struct_ide_drive_s_ptr ;
  int ldv_29_ldv_param_17_1_default ;
  int ldv_29_ldv_param_7_1_default ;
  int tmp ;

  {
#line 3490
  goto ldv_call_29;
#line 3492
  return;
  ldv_call_29: 
  {
#line 3498
  tmp = ldv_undef_int();
  }
  {
#line 3499
  if (tmp == 1) {
#line 3499
    goto case_1;
  } else {

  }
#line 3518
  if (tmp == 2) {
#line 3518
    goto case_2;
  } else {

  }
#line 3533
  if (tmp == 3) {
#line 3533
    goto case_3;
  } else {

  }
#line 3550
  if (tmp == 4) {
#line 3550
    goto case_4;
  } else {

  }
#line 3569
  if (tmp == 5) {
#line 3569
    goto case_5;
  } else {

  }
#line 3590
  if (tmp == 6) {
#line 3590
    goto case_6;
  } else {

  }
#line 3613
  if (tmp == 7) {
#line 3613
    goto case_7;
  } else {

  }
#line 3638
  if (tmp == 8) {
#line 3638
    goto case_8;
  } else {

  }
#line 3665
  if (tmp == 9) {
#line 3665
    goto case_9;
  } else {

  }
#line 3700
  if (tmp == 10) {
#line 3700
    goto case_10;
  } else {

  }
#line 3731
  if (tmp == 11) {
#line 3731
    goto case_11;
  } else {

  }
#line 3740
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 3505
  ldv_dummy_resourceless_instance_callback_29_17(ldv_29_callback_set, ldv_29_container_struct_ide_drive_s_ptr,
                                                 ldv_29_ldv_param_17_1_default);
  }
#line 3515
  goto ldv_call_29;
  case_2: /* CIL Label */ 
  {
#line 3521
  ldv_dummy_resourceless_instance_callback_29_16(ldv_29_callback_get, ldv_29_container_struct_ide_drive_s_ptr);
  }
#line 3528
  goto ldv_call_29;
#line 3530
  goto ldv_call_29;
  case_3: /* CIL Label */ 
  {
#line 3536
  ldv_dummy_resourceless_instance_callback_29_15(ldv_29_callback_dma_timer_expiry,
                                                 ldv_29_container_struct_ide_drive_s_ptr);
  }
#line 3543
  goto ldv_call_29;
#line 3545
  goto ldv_call_29;
#line 3547
  goto ldv_call_29;
  case_4: /* CIL Label */ 
  {
#line 3553
  ldv_dummy_resourceless_instance_callback_29_14(ldv_29_callback_dma_test_irq, ldv_29_container_struct_ide_drive_s_ptr);
  }
#line 3560
  goto ldv_call_29;
#line 3562
  goto ldv_call_29;
#line 3564
  goto ldv_call_29;
#line 3566
  goto ldv_call_29;
  case_5: /* CIL Label */ 
  {
#line 3572
  ldv_dummy_resourceless_instance_callback_29_13(ldv_29_callback_dma_start, ldv_29_container_struct_ide_drive_s_ptr);
  }
#line 3579
  goto ldv_call_29;
#line 3581
  goto ldv_call_29;
#line 3583
  goto ldv_call_29;
#line 3585
  goto ldv_call_29;
#line 3587
  goto ldv_call_29;
  case_6: /* CIL Label */ 
  {
#line 3593
  ldv_dummy_resourceless_instance_callback_29_12(ldv_29_callback_dma_sff_read_status,
                                                 ldv_29_container_struct_hwif_s_ptr);
  }
#line 3600
  goto ldv_call_29;
#line 3602
  goto ldv_call_29;
#line 3604
  goto ldv_call_29;
#line 3606
  goto ldv_call_29;
#line 3608
  goto ldv_call_29;
#line 3610
  goto ldv_call_29;
  case_7: /* CIL Label */ 
  {
#line 3616
  ldv_dummy_resourceless_instance_callback_29_11(ldv_29_callback_dma_setup, ldv_29_container_struct_ide_drive_s_ptr,
                                                 ldv_29_container_struct_ide_cmd_ptr);
  }
#line 3623
  goto ldv_call_29;
#line 3625
  goto ldv_call_29;
#line 3627
  goto ldv_call_29;
#line 3629
  goto ldv_call_29;
#line 3631
  goto ldv_call_29;
#line 3633
  goto ldv_call_29;
#line 3635
  goto ldv_call_29;
  case_8: /* CIL Label */ 
  {
#line 3641
  ldv_dummy_resourceless_instance_callback_29_10(ldv_29_callback_dma_lost_irq, ldv_29_container_struct_ide_drive_s_ptr);
  }
#line 3648
  goto ldv_call_29;
#line 3650
  goto ldv_call_29;
#line 3652
  goto ldv_call_29;
#line 3654
  goto ldv_call_29;
#line 3656
  goto ldv_call_29;
#line 3658
  goto ldv_call_29;
#line 3660
  goto ldv_call_29;
#line 3662
  goto ldv_call_29;
  case_9: /* CIL Label */ 
  {
#line 3671
  ldv_dummy_resourceless_instance_callback_29_7(ldv_29_callback_dma_host_set, ldv_29_container_struct_ide_drive_s_ptr,
                                                ldv_29_ldv_param_7_1_default);
  }
#line 3681
  goto ldv_call_29;
#line 3683
  goto ldv_call_29;
#line 3685
  goto ldv_call_29;
#line 3687
  goto ldv_call_29;
#line 3689
  goto ldv_call_29;
#line 3691
  goto ldv_call_29;
#line 3693
  goto ldv_call_29;
#line 3695
  goto ldv_call_29;
#line 3697
  goto ldv_call_29;
  case_10: /* CIL Label */ 
  {
#line 3703
  ldv_dummy_resourceless_instance_callback_29_3(ldv_29_callback_dma_end, ldv_29_container_struct_ide_drive_s_ptr);
  }
#line 3710
  goto ldv_call_29;
#line 3712
  goto ldv_call_29;
#line 3714
  goto ldv_call_29;
#line 3716
  goto ldv_call_29;
#line 3718
  goto ldv_call_29;
#line 3720
  goto ldv_call_29;
#line 3722
  goto ldv_call_29;
#line 3724
  goto ldv_call_29;
#line 3726
  goto ldv_call_29;
#line 3728
  goto ldv_call_29;
  case_11: /* CIL Label */ ;
#line 3737
  return;
  switch_default: /* CIL Label */ 
  {
#line 3740
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 3743
  return;
}
}
#line 3748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_30(void *arg0 ) 
{ 
  int (*ldv_30_callback_dma_end)(struct ide_drive_s * ) ;
  void (*ldv_30_callback_dma_host_set)(struct ide_drive_s * , int  ) ;
  void (*ldv_30_callback_dma_lost_irq)(struct ide_drive_s * ) ;
  int (*ldv_30_callback_dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
  unsigned char (*ldv_30_callback_dma_sff_read_status)(struct hwif_s * ) ;
  void (*ldv_30_callback_dma_start)(struct ide_drive_s * ) ;
  int (*ldv_30_callback_dma_test_irq)(struct ide_drive_s * ) ;
  int (*ldv_30_callback_dma_timer_expiry)(struct ide_drive_s * ) ;
  int (*ldv_30_callback_get)(struct ide_drive_s * ) ;
  int (*ldv_30_callback_set)(struct ide_drive_s * , int  ) ;
  struct hwif_s *ldv_30_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_30_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_30_container_struct_ide_drive_s_ptr ;
  int ldv_30_ldv_param_17_1_default ;
  int ldv_30_ldv_param_7_1_default ;
  int tmp ;

  {
#line 3774
  goto ldv_call_30;
#line 3776
  return;
  ldv_call_30: 
  {
#line 3782
  tmp = ldv_undef_int();
  }
  {
#line 3783
  if (tmp == 1) {
#line 3783
    goto case_1;
  } else {

  }
#line 3802
  if (tmp == 2) {
#line 3802
    goto case_2;
  } else {

  }
#line 3817
  if (tmp == 3) {
#line 3817
    goto case_3;
  } else {

  }
#line 3834
  if (tmp == 4) {
#line 3834
    goto case_4;
  } else {

  }
#line 3853
  if (tmp == 5) {
#line 3853
    goto case_5;
  } else {

  }
#line 3874
  if (tmp == 6) {
#line 3874
    goto case_6;
  } else {

  }
#line 3897
  if (tmp == 7) {
#line 3897
    goto case_7;
  } else {

  }
#line 3922
  if (tmp == 8) {
#line 3922
    goto case_8;
  } else {

  }
#line 3949
  if (tmp == 9) {
#line 3949
    goto case_9;
  } else {

  }
#line 3984
  if (tmp == 10) {
#line 3984
    goto case_10;
  } else {

  }
#line 4015
  if (tmp == 11) {
#line 4015
    goto case_11;
  } else {

  }
#line 4024
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 3789
  ldv_dummy_resourceless_instance_callback_30_17(ldv_30_callback_set, ldv_30_container_struct_ide_drive_s_ptr,
                                                 ldv_30_ldv_param_17_1_default);
  }
#line 3799
  goto ldv_call_30;
  case_2: /* CIL Label */ 
  {
#line 3805
  ldv_dummy_resourceless_instance_callback_30_16(ldv_30_callback_get, ldv_30_container_struct_ide_drive_s_ptr);
  }
#line 3812
  goto ldv_call_30;
#line 3814
  goto ldv_call_30;
  case_3: /* CIL Label */ 
  {
#line 3820
  ldv_dummy_resourceless_instance_callback_30_15(ldv_30_callback_dma_timer_expiry,
                                                 ldv_30_container_struct_ide_drive_s_ptr);
  }
#line 3827
  goto ldv_call_30;
#line 3829
  goto ldv_call_30;
#line 3831
  goto ldv_call_30;
  case_4: /* CIL Label */ 
  {
#line 3837
  ldv_dummy_resourceless_instance_callback_30_14(ldv_30_callback_dma_test_irq, ldv_30_container_struct_ide_drive_s_ptr);
  }
#line 3844
  goto ldv_call_30;
#line 3846
  goto ldv_call_30;
#line 3848
  goto ldv_call_30;
#line 3850
  goto ldv_call_30;
  case_5: /* CIL Label */ 
  {
#line 3856
  ldv_dummy_resourceless_instance_callback_30_13(ldv_30_callback_dma_start, ldv_30_container_struct_ide_drive_s_ptr);
  }
#line 3863
  goto ldv_call_30;
#line 3865
  goto ldv_call_30;
#line 3867
  goto ldv_call_30;
#line 3869
  goto ldv_call_30;
#line 3871
  goto ldv_call_30;
  case_6: /* CIL Label */ 
  {
#line 3877
  ldv_dummy_resourceless_instance_callback_30_12(ldv_30_callback_dma_sff_read_status,
                                                 ldv_30_container_struct_hwif_s_ptr);
  }
#line 3884
  goto ldv_call_30;
#line 3886
  goto ldv_call_30;
#line 3888
  goto ldv_call_30;
#line 3890
  goto ldv_call_30;
#line 3892
  goto ldv_call_30;
#line 3894
  goto ldv_call_30;
  case_7: /* CIL Label */ 
  {
#line 3900
  ldv_dummy_resourceless_instance_callback_30_11(ldv_30_callback_dma_setup, ldv_30_container_struct_ide_drive_s_ptr,
                                                 ldv_30_container_struct_ide_cmd_ptr);
  }
#line 3907
  goto ldv_call_30;
#line 3909
  goto ldv_call_30;
#line 3911
  goto ldv_call_30;
#line 3913
  goto ldv_call_30;
#line 3915
  goto ldv_call_30;
#line 3917
  goto ldv_call_30;
#line 3919
  goto ldv_call_30;
  case_8: /* CIL Label */ 
  {
#line 3925
  ldv_dummy_resourceless_instance_callback_30_10(ldv_30_callback_dma_lost_irq, ldv_30_container_struct_ide_drive_s_ptr);
  }
#line 3932
  goto ldv_call_30;
#line 3934
  goto ldv_call_30;
#line 3936
  goto ldv_call_30;
#line 3938
  goto ldv_call_30;
#line 3940
  goto ldv_call_30;
#line 3942
  goto ldv_call_30;
#line 3944
  goto ldv_call_30;
#line 3946
  goto ldv_call_30;
  case_9: /* CIL Label */ 
  {
#line 3955
  ldv_dummy_resourceless_instance_callback_30_7(ldv_30_callback_dma_host_set, ldv_30_container_struct_ide_drive_s_ptr,
                                                ldv_30_ldv_param_7_1_default);
  }
#line 3965
  goto ldv_call_30;
#line 3967
  goto ldv_call_30;
#line 3969
  goto ldv_call_30;
#line 3971
  goto ldv_call_30;
#line 3973
  goto ldv_call_30;
#line 3975
  goto ldv_call_30;
#line 3977
  goto ldv_call_30;
#line 3979
  goto ldv_call_30;
#line 3981
  goto ldv_call_30;
  case_10: /* CIL Label */ 
  {
#line 3987
  ldv_dummy_resourceless_instance_callback_30_3(ldv_30_callback_dma_end, ldv_30_container_struct_ide_drive_s_ptr);
  }
#line 3994
  goto ldv_call_30;
#line 3996
  goto ldv_call_30;
#line 3998
  goto ldv_call_30;
#line 4000
  goto ldv_call_30;
#line 4002
  goto ldv_call_30;
#line 4004
  goto ldv_call_30;
#line 4006
  goto ldv_call_30;
#line 4008
  goto ldv_call_30;
#line 4010
  goto ldv_call_30;
#line 4012
  goto ldv_call_30;
  case_11: /* CIL Label */ ;
#line 4021
  return;
  switch_default: /* CIL Label */ 
  {
#line 4024
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 4027
  return;
}
}
#line 4032 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_proc_devset_dummy_resourceless_instance_31(void *arg0 ) 
{ 
  int (*ldv_31_callback_dma_end)(struct ide_drive_s * ) ;
  void (*ldv_31_callback_dma_host_set)(struct ide_drive_s * , int  ) ;
  void (*ldv_31_callback_dma_lost_irq)(struct ide_drive_s * ) ;
  int (*ldv_31_callback_dma_setup)(struct ide_drive_s * , struct ide_cmd * ) ;
  unsigned char (*ldv_31_callback_dma_sff_read_status)(struct hwif_s * ) ;
  void (*ldv_31_callback_dma_start)(struct ide_drive_s * ) ;
  int (*ldv_31_callback_dma_test_irq)(struct ide_drive_s * ) ;
  int (*ldv_31_callback_dma_timer_expiry)(struct ide_drive_s * ) ;
  int (*ldv_31_callback_get)(struct ide_drive_s * ) ;
  int (*ldv_31_callback_set)(struct ide_drive_s * , int  ) ;
  struct hwif_s *ldv_31_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_31_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_31_container_struct_ide_drive_s_ptr ;
  int ldv_31_ldv_param_17_1_default ;
  int ldv_31_ldv_param_7_1_default ;
  int tmp ;

  {
#line 4058
  goto ldv_call_31;
#line 4060
  return;
  ldv_call_31: 
  {
#line 4066
  tmp = ldv_undef_int();
  }
  {
#line 4067
  if (tmp == 1) {
#line 4067
    goto case_1;
  } else {

  }
#line 4086
  if (tmp == 2) {
#line 4086
    goto case_2;
  } else {

  }
#line 4101
  if (tmp == 3) {
#line 4101
    goto case_3;
  } else {

  }
#line 4118
  if (tmp == 4) {
#line 4118
    goto case_4;
  } else {

  }
#line 4137
  if (tmp == 5) {
#line 4137
    goto case_5;
  } else {

  }
#line 4158
  if (tmp == 6) {
#line 4158
    goto case_6;
  } else {

  }
#line 4181
  if (tmp == 7) {
#line 4181
    goto case_7;
  } else {

  }
#line 4206
  if (tmp == 8) {
#line 4206
    goto case_8;
  } else {

  }
#line 4233
  if (tmp == 9) {
#line 4233
    goto case_9;
  } else {

  }
#line 4268
  if (tmp == 10) {
#line 4268
    goto case_10;
  } else {

  }
#line 4299
  if (tmp == 11) {
#line 4299
    goto case_11;
  } else {

  }
#line 4308
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 4073
  ldv_dummy_resourceless_instance_callback_31_17(ldv_31_callback_set, ldv_31_container_struct_ide_drive_s_ptr,
                                                 ldv_31_ldv_param_17_1_default);
  }
#line 4083
  goto ldv_call_31;
  case_2: /* CIL Label */ 
  {
#line 4089
  ldv_dummy_resourceless_instance_callback_31_16(ldv_31_callback_get, ldv_31_container_struct_ide_drive_s_ptr);
  }
#line 4096
  goto ldv_call_31;
#line 4098
  goto ldv_call_31;
  case_3: /* CIL Label */ 
  {
#line 4104
  ldv_dummy_resourceless_instance_callback_31_15(ldv_31_callback_dma_timer_expiry,
                                                 ldv_31_container_struct_ide_drive_s_ptr);
  }
#line 4111
  goto ldv_call_31;
#line 4113
  goto ldv_call_31;
#line 4115
  goto ldv_call_31;
  case_4: /* CIL Label */ 
  {
#line 4121
  ldv_dummy_resourceless_instance_callback_31_14(ldv_31_callback_dma_test_irq, ldv_31_container_struct_ide_drive_s_ptr);
  }
#line 4128
  goto ldv_call_31;
#line 4130
  goto ldv_call_31;
#line 4132
  goto ldv_call_31;
#line 4134
  goto ldv_call_31;
  case_5: /* CIL Label */ 
  {
#line 4140
  ldv_dummy_resourceless_instance_callback_31_13(ldv_31_callback_dma_start, ldv_31_container_struct_ide_drive_s_ptr);
  }
#line 4147
  goto ldv_call_31;
#line 4149
  goto ldv_call_31;
#line 4151
  goto ldv_call_31;
#line 4153
  goto ldv_call_31;
#line 4155
  goto ldv_call_31;
  case_6: /* CIL Label */ 
  {
#line 4161
  ldv_dummy_resourceless_instance_callback_31_12(ldv_31_callback_dma_sff_read_status,
                                                 ldv_31_container_struct_hwif_s_ptr);
  }
#line 4168
  goto ldv_call_31;
#line 4170
  goto ldv_call_31;
#line 4172
  goto ldv_call_31;
#line 4174
  goto ldv_call_31;
#line 4176
  goto ldv_call_31;
#line 4178
  goto ldv_call_31;
  case_7: /* CIL Label */ 
  {
#line 4184
  ldv_dummy_resourceless_instance_callback_31_11(ldv_31_callback_dma_setup, ldv_31_container_struct_ide_drive_s_ptr,
                                                 ldv_31_container_struct_ide_cmd_ptr);
  }
#line 4191
  goto ldv_call_31;
#line 4193
  goto ldv_call_31;
#line 4195
  goto ldv_call_31;
#line 4197
  goto ldv_call_31;
#line 4199
  goto ldv_call_31;
#line 4201
  goto ldv_call_31;
#line 4203
  goto ldv_call_31;
  case_8: /* CIL Label */ 
  {
#line 4209
  ldv_dummy_resourceless_instance_callback_31_10(ldv_31_callback_dma_lost_irq, ldv_31_container_struct_ide_drive_s_ptr);
  }
#line 4216
  goto ldv_call_31;
#line 4218
  goto ldv_call_31;
#line 4220
  goto ldv_call_31;
#line 4222
  goto ldv_call_31;
#line 4224
  goto ldv_call_31;
#line 4226
  goto ldv_call_31;
#line 4228
  goto ldv_call_31;
#line 4230
  goto ldv_call_31;
  case_9: /* CIL Label */ 
  {
#line 4239
  ldv_dummy_resourceless_instance_callback_31_7(ldv_31_callback_dma_host_set, ldv_31_container_struct_ide_drive_s_ptr,
                                                ldv_31_ldv_param_7_1_default);
  }
#line 4249
  goto ldv_call_31;
#line 4251
  goto ldv_call_31;
#line 4253
  goto ldv_call_31;
#line 4255
  goto ldv_call_31;
#line 4257
  goto ldv_call_31;
#line 4259
  goto ldv_call_31;
#line 4261
  goto ldv_call_31;
#line 4263
  goto ldv_call_31;
#line 4265
  goto ldv_call_31;
  case_10: /* CIL Label */ 
  {
#line 4271
  ldv_dummy_resourceless_instance_callback_31_3(ldv_31_callback_dma_end, ldv_31_container_struct_ide_drive_s_ptr);
  }
#line 4278
  goto ldv_call_31;
#line 4280
  goto ldv_call_31;
#line 4282
  goto ldv_call_31;
#line 4284
  goto ldv_call_31;
#line 4286
  goto ldv_call_31;
#line 4288
  goto ldv_call_31;
#line 4290
  goto ldv_call_31;
#line 4292
  goto ldv_call_31;
#line 4294
  goto ldv_call_31;
#line 4296
  goto ldv_call_31;
  case_11: /* CIL Label */ ;
#line 4305
  return;
  switch_default: /* CIL Label */ 
  {
#line 4308
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 4311
  return;
}
}
#line 4316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_ide_tp_ops_dummy_resourceless_instance_32(void *arg0 ) 
{ 
  void (*ldv_32_callback_dev_select)(struct ide_drive_s * ) ;
  void (*ldv_32_callback_exec_command)(struct hwif_s * , unsigned char  ) ;
  void (*ldv_32_callback_input_data)(struct ide_drive_s * , struct ide_cmd * , void * ,
                                     unsigned int  ) ;
  void (*ldv_32_callback_output_data)(struct ide_drive_s * , struct ide_cmd * , void * ,
                                      unsigned int  ) ;
  unsigned char (*ldv_32_callback_read_altstatus)(struct hwif_s * ) ;
  unsigned char (*ldv_32_callback_read_status)(struct hwif_s * ) ;
  void (*ldv_32_callback_tf_load)(struct ide_drive_s * , struct ide_taskfile * , unsigned char  ) ;
  void (*ldv_32_callback_tf_read)(struct ide_drive_s * , struct ide_taskfile * , unsigned char  ) ;
  void (*ldv_32_callback_write_devctl)(struct hwif_s * , unsigned char  ) ;
  struct hwif_s *ldv_32_container_struct_hwif_s_ptr ;
  struct ide_cmd *ldv_32_container_struct_ide_cmd_ptr ;
  struct ide_drive_s *ldv_32_container_struct_ide_drive_s_ptr ;
  struct ide_taskfile *ldv_32_container_struct_ide_taskfile_ptr ;
  unsigned int ldv_32_ldv_param_10_3_default ;
  unsigned int ldv_32_ldv_param_13_3_default ;
  unsigned char ldv_32_ldv_param_18_2_default ;
  unsigned char ldv_32_ldv_param_21_2_default ;
  unsigned char ldv_32_ldv_param_24_1_default ;
  unsigned char ldv_32_ldv_param_7_1_default ;
  int tmp ;

  {
#line 4346
  goto ldv_call_32;
#line 4348
  return;
  ldv_call_32: 
  {
#line 4354
  tmp = ldv_undef_int();
  }
  {
#line 4355
  if (tmp == 1) {
#line 4355
    goto case_1;
  } else {

  }
#line 4374
  if (tmp == 2) {
#line 4374
    goto case_2;
  } else {

  }
#line 4395
  if (tmp == 3) {
#line 4395
    goto case_3;
  } else {

  }
#line 4418
  if (tmp == 4) {
#line 4418
    goto case_4;
  } else {

  }
#line 4437
  if (tmp == 5) {
#line 4437
    goto case_5;
  } else {

  }
#line 4458
  if (tmp == 6) {
#line 4458
    goto case_6;
  } else {

  }
#line 4487
  if (tmp == 7) {
#line 4487
    goto case_7;
  } else {

  }
#line 4518
  if (tmp == 8) {
#line 4518
    goto case_8;
  } else {

  }
#line 4551
  if (tmp == 9) {
#line 4551
    goto case_9;
  } else {

  }
#line 4580
  if (tmp == 10) {
#line 4580
    goto case_10;
  } else {

  }
#line 4589
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 4361
  ldv_dummy_resourceless_instance_callback_32_24(ldv_32_callback_write_devctl, ldv_32_container_struct_hwif_s_ptr,
                                                 (int )ldv_32_ldv_param_24_1_default);
  }
#line 4371
  goto ldv_call_32;
  case_2: /* CIL Label */ 
  {
#line 4380
  ldv_dummy_resourceless_instance_callback_32_21(ldv_32_callback_tf_read, ldv_32_container_struct_ide_drive_s_ptr,
                                                 ldv_32_container_struct_ide_taskfile_ptr,
                                                 (int )ldv_32_ldv_param_21_2_default);
  }
#line 4390
  goto ldv_call_32;
#line 4392
  goto ldv_call_32;
  case_3: /* CIL Label */ 
  {
#line 4401
  ldv_dummy_resourceless_instance_callback_32_18(ldv_32_callback_tf_load, ldv_32_container_struct_ide_drive_s_ptr,
                                                 ldv_32_container_struct_ide_taskfile_ptr,
                                                 (int )ldv_32_ldv_param_18_2_default);
  }
#line 4411
  goto ldv_call_32;
#line 4413
  goto ldv_call_32;
#line 4415
  goto ldv_call_32;
  case_4: /* CIL Label */ 
  {
#line 4421
  ldv_dummy_resourceless_instance_callback_32_17(ldv_32_callback_read_status, ldv_32_container_struct_hwif_s_ptr);
  }
#line 4428
  goto ldv_call_32;
#line 4430
  goto ldv_call_32;
#line 4432
  goto ldv_call_32;
#line 4434
  goto ldv_call_32;
  case_5: /* CIL Label */ 
  {
#line 4440
  ldv_dummy_resourceless_instance_callback_32_16(ldv_32_callback_read_altstatus, ldv_32_container_struct_hwif_s_ptr);
  }
#line 4447
  goto ldv_call_32;
#line 4449
  goto ldv_call_32;
#line 4451
  goto ldv_call_32;
#line 4453
  goto ldv_call_32;
#line 4455
  goto ldv_call_32;
  case_6: /* CIL Label */ 
  {
#line 4464
  ldv_dummy_resourceless_instance_callback_32_13(ldv_32_callback_output_data, ldv_32_container_struct_ide_drive_s_ptr,
                                                 ldv_32_container_struct_ide_cmd_ptr,
                                                 (void *)ldv_32_container_struct_hwif_s_ptr,
                                                 ldv_32_ldv_param_13_3_default);
  }
#line 4474
  goto ldv_call_32;
#line 4476
  goto ldv_call_32;
#line 4478
  goto ldv_call_32;
#line 4480
  goto ldv_call_32;
#line 4482
  goto ldv_call_32;
#line 4484
  goto ldv_call_32;
  case_7: /* CIL Label */ 
  {
#line 4493
  ldv_dummy_resourceless_instance_callback_32_10(ldv_32_callback_input_data, ldv_32_container_struct_ide_drive_s_ptr,
                                                 ldv_32_container_struct_ide_cmd_ptr,
                                                 (void *)ldv_32_container_struct_hwif_s_ptr,
                                                 ldv_32_ldv_param_10_3_default);
  }
#line 4503
  goto ldv_call_32;
#line 4505
  goto ldv_call_32;
#line 4507
  goto ldv_call_32;
#line 4509
  goto ldv_call_32;
#line 4511
  goto ldv_call_32;
#line 4513
  goto ldv_call_32;
#line 4515
  goto ldv_call_32;
  case_8: /* CIL Label */ 
  {
#line 4524
  ldv_dummy_resourceless_instance_callback_32_7(ldv_32_callback_exec_command, ldv_32_container_struct_hwif_s_ptr,
                                                (int )ldv_32_ldv_param_7_1_default);
  }
#line 4534
  goto ldv_call_32;
#line 4536
  goto ldv_call_32;
#line 4538
  goto ldv_call_32;
#line 4540
  goto ldv_call_32;
#line 4542
  goto ldv_call_32;
#line 4544
  goto ldv_call_32;
#line 4546
  goto ldv_call_32;
#line 4548
  goto ldv_call_32;
  case_9: /* CIL Label */ 
  {
#line 4554
  ldv_dummy_resourceless_instance_callback_32_3(ldv_32_callback_dev_select, ldv_32_container_struct_ide_drive_s_ptr);
  }
#line 4561
  goto ldv_call_32;
#line 4563
  goto ldv_call_32;
#line 4565
  goto ldv_call_32;
#line 4567
  goto ldv_call_32;
#line 4569
  goto ldv_call_32;
#line 4571
  goto ldv_call_32;
#line 4573
  goto ldv_call_32;
#line 4575
  goto ldv_call_32;
#line 4577
  goto ldv_call_32;
  case_10: /* CIL Label */ ;
#line 4586
  return;
  switch_default: /* CIL Label */ 
  {
#line 4589
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
#line 4592
  return;
}
}
#line 4597 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_kernel_param_ops_dummy_resourceless_instance_33(void *arg0 ) 
{ 
  int (*ldv_33_callback_set)(char * , struct kernel_param * ) ;
  struct kernel_param *ldv_33_container_struct_kernel_param ;
  char *ldv_33_ldv_param_3_0_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 4611
  goto ldv_call_33;
#line 4613
  return;
  ldv_call_33: 
  {
#line 4619
  tmp___0 = ldv_undef_int();
  }
#line 4619
  if (tmp___0 != 0) {
    {
#line 4621
    tmp = ldv_xmalloc(1UL);
#line 4621
    ldv_33_ldv_param_3_0_default = (char *)tmp;
#line 4626
    ldv_dummy_resourceless_instance_callback_33_3(ldv_33_callback_set, ldv_33_ldv_param_3_0_default,
                                                  ldv_33_container_struct_kernel_param);
#line 4630
    ldv_free((void *)ldv_33_ldv_param_3_0_default);
    }
#line 4637
    goto ldv_call_33;
  } else {
#line 4645
    return;
  }
#line 4648
  return;
}
}
#line 4653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_kernel_param_ops_dummy_resourceless_instance_34(void *arg0 ) 
{ 
  int (*ldv_34_callback_set)(char * , struct kernel_param * ) ;
  struct kernel_param *ldv_34_container_struct_kernel_param ;
  char *ldv_34_ldv_param_3_0_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 4667
  goto ldv_call_34;
#line 4669
  return;
  ldv_call_34: 
  {
#line 4675
  tmp___0 = ldv_undef_int();
  }
#line 4675
  if (tmp___0 != 0) {
    {
#line 4677
    tmp = ldv_xmalloc(1UL);
#line 4677
    ldv_34_ldv_param_3_0_default = (char *)tmp;
#line 4682
    ldv_dummy_resourceless_instance_callback_34_3(ldv_34_callback_set, ldv_34_ldv_param_3_0_default,
                                                  ldv_34_container_struct_kernel_param);
#line 4686
    ldv_free((void *)ldv_34_ldv_param_3_0_default);
    }
#line 4693
    goto ldv_call_34;
  } else {
#line 4701
    return;
  }
#line 4704
  return;
}
}
#line 4709 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_struct_kernel_param_ops_dummy_resourceless_instance_35(void *arg0 ) 
{ 
  int (*ldv_35_callback_set)(char * , struct kernel_param * ) ;
  struct kernel_param *ldv_35_container_struct_kernel_param ;
  char *ldv_35_ldv_param_3_0_default ;
  void *tmp ;
  int tmp___0 ;

  {
#line 4723
  goto ldv_call_35;
#line 4725
  return;
  ldv_call_35: 
  {
#line 4731
  tmp___0 = ldv_undef_int();
  }
#line 4731
  if (tmp___0 != 0) {
    {
#line 4733
    tmp = ldv_xmalloc(1UL);
#line 4733
    ldv_35_ldv_param_3_0_default = (char *)tmp;
#line 4738
    ldv_dummy_resourceless_instance_callback_35_3(ldv_35_callback_set, ldv_35_ldv_param_3_0_default,
                                                  ldv_35_container_struct_kernel_param);
#line 4742
    ldv_free((void *)ldv_35_ldv_param_3_0_default);
    }
#line 4749
    goto ldv_call_35;
  } else {
#line 4757
    return;
  }
#line 4760
  return;
}
}
#line 4765 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_timer_dummy_factory_37(void *arg0 ) 
{ 
  struct timer_list *ldv_37_container_timer_list ;

  {
  {
#line 4774
  ldv_dispatch_instance_register_37_3(ldv_37_container_timer_list);
  }
#line 4787
  return;
#line 4789
  return;
}
}
#line 4794 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_timer_instance_callback_36_2(void (*arg0)(unsigned long  ) , unsigned long arg1 ) 
{ 


  {
  {
#line 4795
  (*arg0)(arg1);
  }
#line 4796
  return;
}
}
#line 4799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
void ldv_timer_timer_instance_36(void *arg0 ) 
{ 
  struct timer_list *ldv_36_container_timer_list ;
  struct ldv_struct_timer_instance_36 *data ;

  {
#line 4804
  data = (struct ldv_struct_timer_instance_36 *)arg0;
#line 4809
  if ((unsigned long )data != (unsigned long )((struct ldv_struct_timer_instance_36 *)0)) {
    {
#line 4810
    ldv_36_container_timer_list = data->arg0;
#line 4811
    ldv_free((void *)data);
    }
  } else {

  }
  {
#line 4817
  ldv_switch_to_interrupt_context();
  }
#line 4818
  if ((unsigned long )ldv_36_container_timer_list->function != (unsigned long )((void (*)(unsigned long  ))0)) {
    {
#line 4820
    ldv_timer_instance_callback_36_2(ldv_36_container_timer_list->function, ldv_36_container_timer_list->data);
    }
  } else {

  }
  {
#line 4823
  ldv_switch_to_process_context();
  }
#line 4831
  return;
#line 4833
  return;
}
}
#line 4880 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  {
#line 4883
  tmp = ldv_ptr_err(ptr);
  }
#line 4883
  return (tmp);
}
}
#line 5527 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static bool ldv_try_module_get_96(struct module *ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 5530
  tmp = ldv_linux_kernel_module_try_module_get(ldv_func_arg1);
  }
#line 5530
  return (tmp != 0);
}
}
#line 5533 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static void ldv_module_put_97(struct module *ldv_func_arg1 ) 
{ 


  {
  {
#line 5536
  ldv_linux_kernel_module_module_put(ldv_func_arg1);
  }
#line 5537
  return;
}
}
#line 5539 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static void ldv_class_destroy_98(struct class *cls ) 
{ 


  {
  {
#line 5543
  ldv_linux_drivers_base_class_destroy_class(cls);
#line 5547
  ldv_linux_usb_gadget_destroy_class(cls);
  }
#line 5548
  return;
}
}
#line 5551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static int ldv_ldv_post_init_99(int ldv_func_arg1 ) 
{ 
  int tmp ;

  {
  {
#line 5555
  ldv_linux_net_register_reset_error_counter();
#line 5559
  ldv_linux_usb_register_reset_error_counter();
#line 5562
  tmp = ldv_post_init(ldv_func_arg1);
  }
#line 5562
  return (tmp);
}
}
#line 5565 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static void ldv_ldv_check_final_state_100(void) 
{ 


  {
  {
#line 5569
  ldv_linux_arch_io_check_final_state();
#line 5573
  ldv_linux_block_genhd_check_final_state();
#line 5577
  ldv_linux_block_queue_check_final_state();
#line 5581
  ldv_linux_block_request_check_final_state();
#line 5585
  ldv_linux_drivers_base_class_check_final_state();
#line 5593
  ldv_linux_fs_char_dev_check_final_state();
#line 5597
  ldv_linux_fs_sysfs_check_final_state();
#line 5601
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 5605
  ldv_linux_kernel_module_check_final_state();
#line 5609
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 5613
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 5617
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 5621
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 5625
  ldv_linux_lib_idr_check_final_state();
#line 5629
  ldv_linux_mmc_sdio_func_check_final_state();
#line 5633
  ldv_linux_net_rtnetlink_check_final_state();
#line 5637
  ldv_linux_net_sock_check_final_state();
#line 5641
  ldv_linux_usb_coherent_check_final_state();
#line 5645
  ldv_linux_usb_gadget_check_final_state();
#line 5649
  ldv_linux_usb_urb_check_final_state();
  }
#line 5650
  return;
}
}
#line 5653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static void ldv_ldv_check_final_state_101(void) 
{ 


  {
  {
#line 5657
  ldv_linux_arch_io_check_final_state();
#line 5661
  ldv_linux_block_genhd_check_final_state();
#line 5665
  ldv_linux_block_queue_check_final_state();
#line 5669
  ldv_linux_block_request_check_final_state();
#line 5673
  ldv_linux_drivers_base_class_check_final_state();
#line 5681
  ldv_linux_fs_char_dev_check_final_state();
#line 5685
  ldv_linux_fs_sysfs_check_final_state();
#line 5689
  ldv_linux_kernel_locking_rwlock_check_final_state();
#line 5693
  ldv_linux_kernel_module_check_final_state();
#line 5697
  ldv_linux_kernel_rcu_update_lock_bh_check_final_state();
#line 5701
  ldv_linux_kernel_rcu_update_lock_sched_check_final_state();
#line 5705
  ldv_linux_kernel_rcu_update_lock_check_final_state();
#line 5709
  ldv_linux_kernel_rcu_srcu_check_final_state();
#line 5713
  ldv_linux_lib_idr_check_final_state();
#line 5717
  ldv_linux_mmc_sdio_func_check_final_state();
#line 5721
  ldv_linux_net_rtnetlink_check_final_state();
#line 5725
  ldv_linux_net_sock_check_final_state();
#line 5729
  ldv_linux_usb_coherent_check_final_state();
#line 5733
  ldv_linux_usb_gadget_check_final_state();
#line 5737
  ldv_linux_usb_urb_check_final_state();
  }
#line 5738
  return;
}
}
#line 5741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static void ldv_ldv_initialize_102(void) 
{ 


  {
  {
#line 5745
  ldv_linux_lib_find_bit_initialize();
  }
#line 5746
  return;
}
}
#line 5749 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static void ldv_ldv_pre_probe_103(void) 
{ 


  {
  {
#line 5753
  ldv_linux_net_register_reset_error_counter();
#line 5757
  ldv_linux_usb_register_reset_error_counter();
#line 5760
  ldv_pre_probe();
  }
#line 5761
  return;
}
}
#line 5763 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide.c.aux"
static int ldv_ldv_post_probe_104(int retval ) 
{ 
  int tmp ;

  {
  {
#line 5767
  ldv_linux_net_register_check_return_value_probe(retval);
#line 5771
  ldv_linux_usb_register_check_return_value_probe(retval);
#line 5774
  tmp = ldv_post_probe(retval);
  }
#line 5774
  return (tmp);
}
}
#line 217 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
void *ldv_kzalloc(size_t size , gfp_t flags ) ;
#line 311
extern void ldv_after_alloc(void * ) ;
#line 369
static void ldv_mutex_lock_96(struct mutex *ldv_func_arg1 ) ;
#line 373
static void ldv_mutex_lock_98(struct mutex *ldv_func_arg1 ) ;
#line 395
void ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(struct mutex *lock ) ;
#line 399
void ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(struct mutex *lock ) ;
#line 430
struct request *ldv_linux_block_request_blk_get_request(gfp_t mask ) ;
#line 432
void ldv_linux_block_request_put_blk_rq(void) ;
#line 235 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void might_fault(void) ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void * , void const   * , size_t  ) ;
#line 57
extern void *__memset(void * , int  , size_t  ) ;
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
static void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) ;
#line 197
static void ldv_mutex_unlock_99(struct mutex *ldv_func_arg1 ) ;
#line 214 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/capability.h"
extern bool capable(int  ) ;
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 418
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 585
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 645 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
#line 647
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
#line 667
extern void __copy_from_user_overflow(void) ;
#line 672
extern void __copy_to_user_overflow(void) ;
#line 688 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 690
  sz = -1;
#line 692
  might_fault();
#line 712
  tmp = __builtin_expect(sz < 0, 1L);
  }
#line 712
  if (tmp != 0L) {
    {
#line 713
    n = _copy_from_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 712
    tmp___0 = __builtin_expect((unsigned long )sz >= n, 1L);
    }
#line 712
    if (tmp___0 != 0L) {
      {
#line 713
      n = _copy_from_user(to, from, (unsigned int )n);
      }
    } else {
      {
#line 717
      __copy_from_user_overflow();
      }
    }
  }
#line 719
  return (n);
}
}
#line 723 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/uaccess.h"
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 725
  sz = -1;
#line 727
  might_fault();
#line 730
  tmp = __builtin_expect(sz < 0, 1L);
  }
#line 730
  if (tmp != 0L) {
    {
#line 731
    n = _copy_to_user(to, from, (unsigned int )n);
    }
  } else {
    {
#line 730
    tmp___0 = __builtin_expect((unsigned long )sz >= n, 1L);
    }
#line 730
    if (tmp___0 != 0L) {
      {
#line 731
      n = _copy_to_user(to, from, (unsigned int )n);
      }
    } else {
      {
#line 735
      __copy_to_user_overflow();
      }
    }
  }
#line 737
  return (n);
}
}
#line 952 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static void ata_id_to_hd_driveid(u16 *id ) 
{ 


  {
#line 954
  return;
}
}
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
static void ldv_blk_put_request_101(struct request *ldv_func_arg1 ) ;
#line 803
static void ldv_blk_put_request_103(struct request *ldv_func_arg1 ) ;
#line 809
static struct request *ldv_blk_get_request_100(struct request_queue *ldv_func_arg1 ,
                                               int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 813
static struct request *ldv_blk_get_request_102(struct request_queue *ldv_func_arg1 ,
                                               int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 876
extern int blk_execute_rq(struct request_queue * , struct gendisk * , struct request * ,
                          int  ) ;
#line 805 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct mutex ide_setting_mtx ;
#line 876
struct ide_devset  const  ide_devset_io_32bit ;
#line 877
struct ide_devset  const  ide_devset_keepsettings ;
#line 878
struct ide_devset  const  ide_devset_pio_mode ;
#line 879
struct ide_devset  const  ide_devset_unmaskirq ;
#line 880
struct ide_devset  const  ide_devset_using_dma ;
#line 1038
int ide_setting_ioctl(ide_drive_t *drive , struct block_device *bdev , unsigned int cmd ,
                      unsigned long arg , struct ide_ioctl_devset  const  *s ) ;
#line 1041
int generic_ide_ioctl(ide_drive_t *drive , struct block_device *bdev , unsigned int cmd ,
                      unsigned long arg ) ;
#line 1073
int ide_devset_execute(ide_drive_t *drive , struct ide_devset  const  *setting , int arg ) ;
#line 1149
int ide_raw_taskfile(ide_drive_t *drive , struct ide_cmd *cmd , u8 *buf , u16 nsect ) ;
#line 1150
int ide_no_data_taskfile(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 1152
int ide_taskfile_ioctl(ide_drive_t *drive , unsigned long arg ) ;
#line 1347
u8 ide_find_dma_mode(ide_drive_t *drive , u8 req_mode ) ;
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static struct ide_ioctl_devset  const  ide_ioctl_settings[6U]  = {      {777U, 804U, & ide_devset_io_32bit}, 
        {776U, 803U, & ide_devset_keepsettings}, 
        {770U, 802U, & ide_devset_unmaskirq}, 
        {779U, 806U, & ide_devset_using_dma}, 
        {4294967295U, 807U, & ide_devset_pio_mode}, 
        {0U, 0U, 0}};
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
int ide_setting_ioctl(ide_drive_t *drive , struct block_device *bdev , unsigned int cmd ,
                      unsigned long arg , struct ide_ioctl_devset  const  *s ) 
{ 
  struct ide_devset  const  *ds ;
  int err ;
  int __ret_pu ;
  long __pu_val ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
#line 24
  err = -95;
#line 26
  goto ldv_38289;
  ldv_38288: ;
#line 27
  if ((unsigned long )ds->get != (unsigned long )((int (*/* const  */)(ide_drive_t * ))0) && (unsigned int )s->get_ioctl == cmd) {
#line 28
    goto read_val;
  } else
#line 29
  if ((unsigned long )ds->set != (unsigned long )((int (*/* const  */)(ide_drive_t * ,
                                                                       int  ))0) && (unsigned int )s->set_ioctl == cmd) {
#line 30
    goto set_val;
  } else {

  }
#line 26
  s = s + 1;
  ldv_38289: 
#line 26
  ds = s->setting;
#line 26
  if ((unsigned long )ds != (unsigned long )((struct ide_devset  const  *)0)) {
#line 28
    goto ldv_38288;
  } else {

  }

#line 33
  return (err);
  read_val: 
  {
#line 36
  ldv_mutex_lock_96(& ide_setting_mtx);
#line 37
  err = (*(ds->get))(drive);
#line 38
  ldv_mutex_unlock_97(& ide_setting_mtx);
  }
#line 39
  if (err >= 0) {
    {
#line 39
    might_fault();
#line 39
    __pu_val = (long )err;
    }
    {
#line 39
    if (8UL == 1UL) {
#line 39
      goto case_1;
    } else {

    }
#line 39
    if (8UL == 2UL) {
#line 39
      goto case_2;
    } else {

    }
#line 39
    if (8UL == 4UL) {
#line 39
      goto case_4;
    } else {

    }
#line 39
    if (8UL == 8UL) {
#line 39
      goto case_8;
    } else {

    }
#line 39
    goto switch_default;
    case_1: /* CIL Label */ 
#line 39
    __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 39
    goto ldv_38294;
    case_2: /* CIL Label */ 
#line 39
    __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 39
    goto ldv_38294;
    case_4: /* CIL Label */ 
#line 39
    __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 39
    goto ldv_38294;
    case_8: /* CIL Label */ 
#line 39
    __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 39
    goto ldv_38294;
    switch_default: /* CIL Label */ 
#line 39
    __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 39
    goto ldv_38294;
    switch_break: /* CIL Label */ ;
    }
    ldv_38294: 
#line 39
    tmp = __ret_pu;
  } else {
#line 39
    tmp = err;
  }
#line 39
  return (tmp);
  set_val: ;
#line 42
  if ((unsigned long )bdev != (unsigned long )bdev->bd_contains) {
#line 43
    err = -22;
  } else {
    {
#line 45
    tmp___0 = capable(21);
    }
#line 45
    if (tmp___0) {
#line 45
      tmp___1 = 0;
    } else {
#line 45
      tmp___1 = 1;
    }
#line 45
    if (tmp___1) {
#line 46
      err = -13;
    } else {
      {
#line 48
      ldv_mutex_lock_98(& ide_setting_mtx);
#line 49
      err = ide_devset_execute(drive, ds, (int )arg);
#line 50
      ldv_mutex_unlock_99(& ide_setting_mtx);
      }
    }
  }
#line 53
  return (err);
}
}
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static char const   __kstrtab_ide_setting_ioctl[18U]  = 
#line 55
  {      'i',      'd',      'e',      '_', 
        's',      'e',      't',      't', 
        'i',      'n',      'g',      '_', 
        'i',      'o',      'c',      't', 
        'l',      '\000'};
#line 55
struct kernel_symbol  const  __ksymtab_ide_setting_ioctl ;
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
struct kernel_symbol  const  __ksymtab_ide_setting_ioctl  =    {(unsigned long )(& ide_setting_ioctl), (char const   *)(& __kstrtab_ide_setting_ioctl)};
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static int ide_get_identity_ioctl(ide_drive_t *drive , unsigned int cmd , unsigned long arg ) 
{ 
  u16 *id ;
  int size ;
  int rc ;
  void *tmp ;
  unsigned long tmp___0 ;

  {
#line 60
  id = (u16 *)0U;
#line 61
  size = cmd == 781U ? 512 : 142;
#line 62
  rc = 0;
#line 64
  if ((drive->dev_flags & 256UL) == 0UL) {
#line 65
    rc = -42;
#line 66
    goto out;
  } else {

  }
  {
#line 70
  tmp = kmalloc(512UL, 208U);
#line 70
  id = (u16 *)tmp;
  }
#line 71
  if ((unsigned long )id == (unsigned long )((u16 *)0U)) {
#line 72
    rc = -12;
#line 73
    goto out;
  } else {

  }
  {
#line 76
  __memcpy((void *)id, (void const   *)drive->id, (size_t )size);
#line 77
  ata_id_to_hd_driveid(id);
#line 79
  tmp___0 = copy_to_user((void *)arg, (void const   *)id, (unsigned long )size);
  }
#line 79
  if (tmp___0 != 0UL) {
#line 80
    rc = -14;
  } else {

  }
  {
#line 82
  kfree((void const   *)id);
  }
  out: ;
#line 84
  return (rc);
}
}
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static int ide_get_nice_ioctl(ide_drive_t *drive , unsigned long arg ) 
{ 
  int __ret_pu ;
  long __pu_val ;

  {
  {
#line 89
  might_fault();
#line 89
  __pu_val = (long )(((drive->dev_flags & 16UL) != 0UL) | ((drive->dev_flags & 32UL) != 0UL ? 8 : 0));
  }
  {
#line 89
  if (8UL == 1UL) {
#line 89
    goto case_1;
  } else {

  }
#line 89
  if (8UL == 2UL) {
#line 89
    goto case_2;
  } else {

  }
#line 89
  if (8UL == 4UL) {
#line 89
    goto case_4;
  } else {

  }
#line 89
  if (8UL == 8UL) {
#line 89
    goto case_8;
  } else {

  }
#line 89
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 89
  goto ldv_38327;
  case_2: /* CIL Label */ 
#line 89
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 89
  goto ldv_38327;
  case_4: /* CIL Label */ 
#line 89
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 89
  goto ldv_38327;
  case_8: /* CIL Label */ 
#line 89
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 89
  goto ldv_38327;
  switch_default: /* CIL Label */ 
#line 89
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 89
  goto ldv_38327;
  switch_break: /* CIL Label */ ;
  }
  ldv_38327: ;
#line 89
  return (__ret_pu);
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static int ide_set_nice_ioctl(ide_drive_t *drive , unsigned long arg ) 
{ 


  {
#line 97
  if (arg != (arg & 9UL)) {
#line 98
    return (-1);
  } else {

  }
#line 100
  if ((int )arg & 1 && (unsigned int )drive->media != 1U) {
#line 102
    return (-1);
  } else {

  }
#line 104
  if ((int )arg & 1) {
#line 105
    drive->dev_flags = drive->dev_flags | 16UL;
  } else {
#line 107
    drive->dev_flags = drive->dev_flags & 0xffffffffffffffefUL;
  }
#line 109
  if ((arg & 8UL) != 0UL) {
#line 110
    drive->dev_flags = drive->dev_flags | 32UL;
  } else {
#line 112
    drive->dev_flags = drive->dev_flags & 0xffffffffffffffdfUL;
  }
#line 114
  return (0);
}
}
#line 117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static int ide_cmd_ioctl(ide_drive_t *drive , unsigned long arg ) 
{ 
  u8 *buf ;
  int bufsize ;
  int err ;
  u8 args[4U] ;
  u8 xfer_rate ;
  struct ide_cmd cmd ;
  struct ide_taskfile *tf ;
  struct request *rq ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 119
  buf = (u8 *)0U;
#line 120
  bufsize = 0;
#line 120
  err = 0;
#line 121
  xfer_rate = 0U;
#line 123
  tf = & cmd.tf;
#line 125
  if ((unsigned long )((void *)arg) == (unsigned long )((void *)0)) {
    {
#line 128
    rq = ldv_blk_get_request_100(drive->queue, 0, 16U);
#line 129
    rq->cmd_type = 8;
#line 130
    err = blk_execute_rq(drive->queue, (struct gendisk *)0, rq, 0);
#line 131
    ldv_blk_put_request_101(rq);
    }
#line 133
    return (err);
  } else {

  }
  {
#line 136
  tmp = copy_from_user((void *)(& args), (void const   *)arg, 4UL);
  }
#line 136
  if (tmp != 0UL) {
#line 137
    return (-14);
  } else {

  }
  {
#line 139
  __memset((void *)(& cmd), 0, 80UL);
#line 140
  tf->__annonCompField83.feature = args[2];
  }
#line 141
  if ((unsigned int )args[0] == 176U) {
#line 142
    tf->nsect = args[3];
#line 143
    tf->lbal = args[1];
#line 144
    tf->lbam = 79U;
#line 145
    tf->lbah = 194U;
#line 146
    cmd.valid.out.tf = 62U;
#line 147
    cmd.valid.in.tf = 4U;
  } else {
#line 149
    tf->nsect = args[1];
#line 150
    cmd.valid.out.tf = 6U;
#line 151
    cmd.valid.in.tf = 4U;
  }
#line 153
  tf->__annonCompField84.command = args[0];
#line 154
  cmd.protocol = (unsigned int )args[3] != 0U ? 2 : 1;
#line 156
  if ((unsigned int )args[3] != 0U) {
    {
#line 157
    cmd.tf_flags = (u16 )((unsigned int )cmd.tf_flags | 16U);
#line 158
    bufsize = (int )args[3] * 512;
#line 159
    tmp___0 = kzalloc((size_t )bufsize, 208U);
#line 159
    buf = (u8 *)tmp___0;
    }
#line 160
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
#line 161
      return (-12);
    } else {

    }
  } else {

  }
#line 164
  if (((unsigned int )tf->__annonCompField84.command == 239U && (unsigned int )tf->__annonCompField83.feature == 3U) && (unsigned int )tf->nsect > 15U) {
    {
#line 167
    xfer_rate = ide_find_dma_mode(drive, (int )tf->nsect);
    }
#line 168
    if ((int )xfer_rate != (int )tf->nsect) {
#line 169
      err = -22;
#line 170
      goto abort;
    } else {

    }
#line 173
    cmd.tf_flags = (u16 )((unsigned int )cmd.tf_flags | 256U);
  } else {

  }
  {
#line 176
  err = ide_raw_taskfile(drive, & cmd, buf, (int )args[3]);
#line 178
  args[0] = tf->__annonCompField84.status;
#line 179
  args[1] = tf->__annonCompField83.error;
#line 180
  args[2] = tf->nsect;
  }
  abort: 
  {
#line 182
  tmp___1 = copy_to_user((void *)arg, (void const   *)(& args), 4UL);
  }
#line 182
  if (tmp___1 != 0UL) {
#line 183
    err = -14;
  } else {

  }
#line 184
  if ((unsigned long )buf != (unsigned long )((u8 *)0U)) {
    {
#line 185
    tmp___2 = copy_to_user((void *)(arg + 4UL), (void const   *)buf, (unsigned long )bufsize);
    }
#line 185
    if (tmp___2 != 0UL) {
#line 186
      err = -14;
    } else {

    }
    {
#line 187
    kfree((void const   *)buf);
    }
  } else {

  }
#line 189
  return (err);
}
}
#line 192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static int ide_task_ioctl(ide_drive_t *drive , unsigned long arg ) 
{ 
  void *p ;
  int err ;
  u8 args[7U] ;
  struct ide_cmd cmd ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 194
  p = (void *)arg;
#line 195
  err = 0;
#line 199
  tmp = copy_from_user((void *)(& args), (void const   *)p, 7UL);
  }
#line 199
  if (tmp != 0UL) {
#line 200
    return (-14);
  } else {

  }
  {
#line 202
  __memset((void *)(& cmd), 0, 80UL);
#line 203
  __memcpy((void *)(& cmd.tf.__annonCompField83.feature), (void const   *)(& args) + 1U,
           6UL);
#line 204
  cmd.tf.__annonCompField84.command = args[0];
#line 205
  cmd.valid.out.tf = 126U;
#line 206
  cmd.valid.in.tf = 124U;
#line 208
  err = ide_no_data_taskfile(drive, & cmd);
#line 210
  args[0] = cmd.tf.__annonCompField84.command;
#line 211
  __memcpy((void *)(& args) + 1U, (void const   *)(& cmd.tf.__annonCompField83.feature),
           6UL);
#line 213
  tmp___0 = copy_to_user(p, (void const   *)(& args), 7UL);
  }
#line 213
  if (tmp___0 != 0UL) {
#line 214
    err = -14;
  } else {

  }
#line 216
  return (err);
}
}
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static int generic_drive_reset(ide_drive_t *drive ) 
{ 
  struct request *rq ;
  int ret ;
  int tmp ;

  {
  {
#line 222
  ret = 0;
#line 224
  rq = ldv_blk_get_request_102(drive->queue, 0, 16U);
#line 225
  rq->cmd_type = 7;
#line 226
  rq->cmd_len = 1U;
#line 227
  *(rq->cmd) = 32U;
#line 228
  tmp = blk_execute_rq(drive->queue, (struct gendisk *)0, rq, 1);
  }
#line 228
  if (tmp != 0) {
#line 229
    ret = rq->errors;
  } else {

  }
  {
#line 230
  ldv_blk_put_request_103(rq);
  }
#line 231
  return (ret);
}
}
#line 234 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
int generic_ide_ioctl(ide_drive_t *drive , struct block_device *bdev , unsigned int cmd ,
                      unsigned long arg ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  bool tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  bool tmp___18 ;
  int tmp___19 ;
  int __ret_pu ;
  long __pu_val ;
  bool tmp___20 ;
  int tmp___21 ;

  {
  {
#line 239
  err = ide_setting_ioctl(drive, bdev, cmd, arg, (struct ide_ioctl_devset  const  *)(& ide_ioctl_settings));
  }
#line 240
  if (err != -95) {
#line 241
    return (err);
  } else {

  }
  {
#line 244
  if (cmd == 775U) {
#line 244
    goto case_775;
  } else {

  }
#line 245
  if (cmd == 781U) {
#line 245
    goto case_781;
  } else {

  }
#line 249
  if (cmd == 780U) {
#line 249
    goto case_780;
  } else {

  }
#line 251
  if (cmd == 809U) {
#line 251
    goto case_809;
  } else {

  }
#line 256
  if (cmd == 797U) {
#line 256
    goto case_797;
  } else {

  }
#line 263
  if (cmd == 799U) {
#line 263
    goto case_799;
  } else {

  }
#line 267
  if (cmd == 798U) {
#line 267
    goto case_798;
  } else {

  }
#line 271
  if (cmd == 796U) {
#line 271
    goto case_796;
  } else {

  }
#line 275
  if (cmd == 794U) {
#line 275
    goto case_794;
  } else {

  }
#line 281
  if (cmd == 813U) {
#line 281
    goto case_813;
  } else {

  }
#line 285
  goto switch_default___0;
  case_775: /* CIL Label */ ;
  case_781: /* CIL Label */ ;
#line 246
  if ((unsigned long )bdev != (unsigned long )bdev->bd_contains) {
#line 247
    return (-22);
  } else {

  }
  {
#line 248
  tmp = ide_get_identity_ioctl(drive, cmd, arg);
  }
#line 248
  return (tmp);
  case_780: /* CIL Label */ 
  {
#line 250
  tmp___0 = ide_get_nice_ioctl(drive, arg);
  }
#line 250
  return (tmp___0);
  case_809: /* CIL Label */ 
  {
#line 252
  tmp___1 = capable(21);
  }
#line 252
  if (tmp___1) {
#line 252
    tmp___2 = 0;
  } else {
#line 252
    tmp___2 = 1;
  }
#line 252
  if (tmp___2) {
#line 253
    return (-13);
  } else {

  }
  {
#line 254
  tmp___3 = ide_set_nice_ioctl(drive, arg);
  }
#line 254
  return (tmp___3);
  case_797: /* CIL Label */ 
  {
#line 257
  tmp___4 = capable(21);
  }
#line 257
  if (tmp___4) {
#line 257
    tmp___5 = 0;
  } else {
#line 257
    tmp___5 = 1;
  }
#line 257
  if (tmp___5) {
#line 258
    return (-13);
  } else {
    {
#line 257
    tmp___6 = capable(17);
    }
#line 257
    if (tmp___6) {
#line 257
      tmp___7 = 0;
    } else {
#line 257
      tmp___7 = 1;
    }
#line 257
    if (tmp___7) {
#line 258
      return (-13);
    } else {

    }
  }
#line 259
  if ((unsigned int )drive->media == 32U) {
    {
#line 260
    tmp___8 = ide_taskfile_ioctl(drive, arg);
    }
#line 260
    return (tmp___8);
  } else {

  }
#line 261
  return (-42);
  case_799: /* CIL Label */ 
  {
#line 264
  tmp___9 = capable(17);
  }
#line 264
  if (tmp___9) {
#line 264
    tmp___10 = 0;
  } else {
#line 264
    tmp___10 = 1;
  }
#line 264
  if (tmp___10) {
#line 265
    return (-13);
  } else {

  }
  {
#line 266
  tmp___11 = ide_cmd_ioctl(drive, arg);
  }
#line 266
  return (tmp___11);
  case_798: /* CIL Label */ 
  {
#line 268
  tmp___12 = capable(17);
  }
#line 268
  if (tmp___12) {
#line 268
    tmp___13 = 0;
  } else {
#line 268
    tmp___13 = 1;
  }
#line 268
  if (tmp___13) {
#line 269
    return (-13);
  } else {

  }
  {
#line 270
  tmp___14 = ide_task_ioctl(drive, arg);
  }
#line 270
  return (tmp___14);
  case_796: /* CIL Label */ 
  {
#line 272
  tmp___15 = capable(21);
  }
#line 272
  if (tmp___15) {
#line 272
    tmp___16 = 0;
  } else {
#line 272
    tmp___16 = 1;
  }
#line 272
  if (tmp___16) {
#line 273
    return (-13);
  } else {

  }
  {
#line 274
  tmp___17 = generic_drive_reset(drive);
  }
#line 274
  return (tmp___17);
  case_794: /* CIL Label */ 
  {
#line 276
  tmp___18 = capable(21);
  }
#line 276
  if (tmp___18) {
#line 276
    tmp___19 = 0;
  } else {
#line 276
    tmp___19 = 1;
  }
#line 276
  if (tmp___19) {
#line 277
    return (-13);
  } else {

  }
  {
#line 278
  might_fault();
#line 278
  __pu_val = 1L;
  }
  {
#line 278
  if (8UL == 1UL) {
#line 278
    goto case_1;
  } else {

  }
#line 278
  if (8UL == 2UL) {
#line 278
    goto case_2;
  } else {

  }
#line 278
  if (8UL == 4UL) {
#line 278
    goto case_4;
  } else {

  }
#line 278
  if (8UL == 8UL) {
#line 278
    goto case_8;
  } else {

  }
#line 278
  goto switch_default;
  case_1: /* CIL Label */ 
#line 278
  __asm__  volatile   ("call __put_user_1": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 278
  goto ldv_38382;
  case_2: /* CIL Label */ 
#line 278
  __asm__  volatile   ("call __put_user_2": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 278
  goto ldv_38382;
  case_4: /* CIL Label */ 
#line 278
  __asm__  volatile   ("call __put_user_4": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 278
  goto ldv_38382;
  case_8: /* CIL Label */ 
#line 278
  __asm__  volatile   ("call __put_user_8": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 278
  goto ldv_38382;
  switch_default: /* CIL Label */ 
#line 278
  __asm__  volatile   ("call __put_user_X": "=a" (__ret_pu): "0" (__pu_val), "c" ((long *)arg): "ebx");
#line 278
  goto ldv_38382;
  switch_break___0: /* CIL Label */ ;
  }
  ldv_38382: ;
#line 278
  if (__ret_pu != 0) {
#line 279
    return (-14);
  } else {

  }
#line 280
  return (0);
  case_813: /* CIL Label */ 
  {
#line 282
  tmp___20 = capable(21);
  }
#line 282
  if (tmp___20) {
#line 282
    tmp___21 = 0;
  } else {
#line 282
    tmp___21 = 1;
  }
#line 282
  if (tmp___21) {
#line 283
    return (-13);
  } else {

  }
#line 284
  return (-95);
  switch_default___0: /* CIL Label */ ;
#line 286
  return (-22);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
static char const   __kstrtab_generic_ide_ioctl[18U]  = 
#line 289
  {      'g',      'e',      'n',      'e', 
        'r',      'i',      'c',      '_', 
        'i',      'd',      'e',      '_', 
        'i',      'o',      'c',      't', 
        'l',      '\000'};
#line 289
struct kernel_symbol  const  __ksymtab_generic_ide_ioctl ;
#line 289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-ioctls.c"
struct kernel_symbol  const  __ksymtab_generic_ide_ioctl  =    {(unsigned long )(& generic_ide_ioctl), (char const   *)(& __kstrtab_generic_ide_ioctl)};
#line 1133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 1137
  ldv_check_alloc_flags(flags);
#line 1138
  res = ldv_malloc_unknown_size();
#line 1139
  ldv_after_alloc(res);
  }
#line 1140
  return (res);
}
}
#line 1184 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
#line 1187
  tmp = ldv_kzalloc(size, flags);
  }
#line 1187
  return (tmp);
}
}
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
static void ldv_mutex_lock_96(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1331
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(ldv_func_arg1);
  }
#line 1332
  return;
}
}
#line 1334 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
static void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1338
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(ldv_func_arg1);
  }
#line 1339
  return;
}
}
#line 1341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
static void ldv_mutex_lock_98(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1345
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(ldv_func_arg1);
  }
#line 1346
  return;
}
}
#line 1348 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
static void ldv_mutex_unlock_99(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1352
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(ldv_func_arg1);
  }
#line 1353
  return;
}
}
#line 1355 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
static struct request *ldv_blk_get_request_100(struct request_queue *ldv_func_arg1 ,
                                               int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1358
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1358
  return (tmp);
}
}
#line 1361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
static void ldv_blk_put_request_101(struct request *ldv_func_arg1 ) 
{ 


  {
  {
#line 1364
  ldv_linux_block_request_put_blk_rq();
  }
#line 1365
  return;
}
}
#line 1367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
static struct request *ldv_blk_get_request_102(struct request_queue *ldv_func_arg1 ,
                                               int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1370
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1370
  return (tmp);
}
}
#line 1373 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-ioctls.c.aux"
static void ldv_blk_put_request_103(struct request *ldv_func_arg1 ) 
{ 


  {
  {
#line 1376
  ldv_linux_block_request_put_blk_rq();
  }
#line 1377
  return;
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt_types.h"
extern struct pv_irq_ops pv_irq_ops ;
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 117
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
#line 119
  return;
}
}
#line 131 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static void clear_bit_unlock(long nr , unsigned long volatile   *addr ) 
{ 


  {
  {
#line 133
  __asm__  volatile   ("": : : "memory");
#line 134
  clear_bit(nr, addr);
  }
#line 135
  return;
}
}
#line 204 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
#line 206
  __asm__  volatile   ("":);
#line 206
  return (0);

#line 206
  return (1);
}
}
#line 217 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int test_and_set_bit_lock(long nr , unsigned long volatile   *addr ) 
{ 
  int tmp ;

  {
  {
#line 219
  tmp = test_and_set_bit(nr, addr);
  }
#line 219
  return (tmp);
}
}
#line 166 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern void __might_sleep(char const   * , int  , int  ) ;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/bug.h"
extern void warn_slowpath_null(char const   * , int const    ) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
extern int ( /* missing proto */  __builtin_unreachable)() ;
#line 812 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_disable(void) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  {
#line 814
  __edi = __edi;
#line 814
  __esi = __esi;
#line 814
  __edx = __edx;
#line 814
  __ecx = __ecx;
#line 814
  __eax = __eax;
#line 814
  tmp = __builtin_expect((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0),
                         0L);
  }
#line 814
  if (tmp != 0L) {
    {
#line 814
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (814), "i" (12UL));
#line 814
    __builtin_unreachable();
    }
  } else {

  }
#line 814
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (46UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 816
  return;
}
}
#line 21 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqflags.h"
extern void trace_hardirqs_off(void) ;
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
extern void __ldv_linux_kernel_locking_spinlock_spin_lock(spinlock_t * ) ;
#line 489
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96(spinlock_t *ldv_func_arg1 ) ;
#line 493
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_110(spinlock_t *ldv_func_arg1 ) ;
#line 497
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_115(spinlock_t *ldv_func_arg1 ) ;
#line 537
void ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s(void) ;
#line 538
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_hwif_s(void) ;
#line 561
void ldv_linux_kernel_locking_spinlock_spin_lock_queue_lock_of_request_queue(void) ;
#line 562
void ldv_linux_kernel_locking_spinlock_spin_unlock_queue_lock_of_request_queue(void) ;
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock_api_smp.h"
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
#line 41
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
#line 43
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
#line 45
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
#line 340 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
  {
#line 342
  _raw_spin_lock_irq(& lock->__annonCompField18.rlock);
  }
#line 343
  return;
}
}
#line 366
__inline static void ldv_spin_lock_irq_99(spinlock_t *lock ) ;
#line 370
__inline static void ldv_spin_lock_irq_101(spinlock_t *lock ) ;
#line 374
__inline static void ldv_spin_lock_irq_99(spinlock_t *lock ) ;
#line 378
__inline static void ldv_spin_lock_irq_99(spinlock_t *lock ) ;
#line 382
__inline static void ldv_spin_lock_irq_101(spinlock_t *lock ) ;
#line 386
__inline static void ldv_spin_lock_irq_101(spinlock_t *lock ) ;
#line 390
__inline static void ldv_spin_lock_irq_99(spinlock_t *lock ) ;
#line 394
__inline static void ldv_spin_lock_irq_99(spinlock_t *lock ) ;
#line 395 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  {
#line 397
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
  }
#line 398
  return;
}
}
#line 431
__inline static void ldv_spin_unlock_112(spinlock_t *lock ) ;
#line 435
__inline static void ldv_spin_unlock_112(spinlock_t *lock ) ;
#line 449 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
  {
#line 451
  _raw_spin_unlock_irq(& lock->__annonCompField18.rlock);
  }
#line 452
  return;
}
}
#line 465
__inline static void ldv_spin_unlock_irq_98(spinlock_t *lock ) ;
#line 469
__inline static void ldv_spin_unlock_irq_100(spinlock_t *lock ) ;
#line 473
__inline static void ldv_spin_unlock_irq_98(spinlock_t *lock ) ;
#line 477
__inline static void ldv_spin_unlock_irq_100(spinlock_t *lock ) ;
#line 481
__inline static void ldv_spin_unlock_irq_100(spinlock_t *lock ) ;
#line 485
__inline static void ldv_spin_unlock_irq_100(spinlock_t *lock ) ;
#line 486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 488
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
  }
#line 489
  return;
}
}
#line 518
__inline static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock , unsigned long flags ) ;
#line 522
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 526
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 530
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
extern unsigned long volatile   jiffies ;
#line 283
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
extern int del_timer(struct timer_list * ) ;
#line 178
static int ldv_del_timer_116(struct timer_list *ldv_func_arg1 ) ;
#line 240
extern void add_timer(struct timer_list * ) ;
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
extern void disable_irq(unsigned int  ) ;
#line 189
extern void enable_irq(unsigned int  ) ;
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
extern void blk_requeue_request(struct request_queue * , struct request * ) ;
#line 814
extern void blk_delay_queue(struct request_queue * , unsigned long  ) ;
#line 878 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
__inline static sector_t blk_rq_pos(struct request  const  *rq ) 
{ 


  {
#line 880
  return ((sector_t )rq->__sector);
}
}
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
__inline static unsigned int blk_rq_bytes(struct request  const  *rq ) 
{ 


  {
#line 885
  return ((unsigned int )rq->__data_len);
}
}
#line 895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
__inline static unsigned int blk_rq_sectors(struct request  const  *rq ) 
{ 
  unsigned int tmp ;

  {
  {
#line 897
  tmp = blk_rq_bytes(rq);
  }
#line 897
  return (tmp >> 9);
}
}
#line 959
extern struct request *blk_peek_request(struct request_queue * ) ;
#line 961
extern struct request *blk_fetch_request(struct request_queue * ) ;
#line 979
extern bool blk_end_request(struct request * , int  , unsigned int  ) ;
#line 1051
extern int blk_rq_map_sg(struct request_queue * , struct request * , struct scatterlist * ) ;
#line 1003 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
ide_startstop_t ide_start_power_step(ide_drive_t *drive , struct request *rq ) ;
#line 1004
void ide_complete_pm_rq(ide_drive_t *drive , struct request *rq ) ;
#line 1005
void ide_check_pm_state(ide_drive_t *drive , struct request *rq ) ;
#line 1046
int ide_end_rq(ide_drive_t *drive , struct request *rq , int error , unsigned int nr_bytes ) ;
#line 1047
void ide_kill_rq(ide_drive_t *drive , struct request *rq ) ;
#line 1055
void ide_pad_transfer(ide_drive_t *drive , int write , int len ) ;
#line 1057
ide_startstop_t ide_error(ide_drive_t *drive , char const   *msg , u8 stat ) ;
#line 1066
int ide_wait_stat(ide_startstop_t *startstop , ide_drive_t *drive , u8 good , u8 bad ,
                  unsigned long timeout ) ;
#line 1068
ide_startstop_t ide_do_park_unpark(ide_drive_t *drive , struct request *rq ) ;
#line 1069
ide_startstop_t ide_do_devset(ide_drive_t *drive , struct request *rq ) ;
#line 1071
ide_startstop_t ide_do_reset(ide_drive_t *drive ) ;
#line 1076
void ide_complete_cmd(ide_drive_t *drive , struct ide_cmd *cmd , u8 stat , u8 err ) ;
#line 1077
int ide_complete_rq(ide_drive_t *drive , int error , unsigned int nr_bytes ) ;
#line 1079
void ide_tf_readback(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 1080
void ide_tf_dump(char const   *s , struct ide_cmd *cmd ) ;
#line 1143
ide_startstop_t do_rw_taskfile(ide_drive_t *drive , struct ide_cmd *orig_cmd ) ;
#line 1157
int ide_config_drive_speed(ide_drive_t *drive , u8 speed ) ;
#line 1163
void ide_stall_queue(ide_drive_t *drive , unsigned long timeout ) ;
#line 1165
void ide_timer_expiry(unsigned long data ) ;
#line 1166
irqreturn_t ide_intr(int irq , void *dev_id ) ;
#line 1167
void do_ide_request(struct request_queue *q ) ;
#line 1168
void ide_requeue_and_plug(ide_drive_t *drive , struct request *rq ) ;
#line 1330
void ide_map_sg(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 1331
void ide_init_sg_cmd(struct ide_cmd *cmd , unsigned int nr_bytes ) ;
#line 1356
void ide_dma_on(ide_drive_t *drive ) ;
#line 1383
ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive , int error ) ;
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
int ide_end_rq(ide_drive_t *drive , struct request *rq , int error , unsigned int nr_bytes ) 
{ 
  bool tmp ;

  {
#line 64
  if ((drive->dev_flags & 16777216UL) != 0UL && (unsigned int )drive->retry_pio <= 3U) {
    {
#line 66
    drive->dev_flags = drive->dev_flags & 0xfffffffffeffffffUL;
#line 67
    ide_dma_on(drive);
    }
  } else {

  }
  {
#line 70
  tmp = blk_end_request(rq, error, nr_bytes);
  }
#line 70
  return ((int )tmp);
}
}
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static char const   __kstrtab_ide_end_rq[11U]  = 
#line 72
  {      'i',      'd',      'e',      '_', 
        'e',      'n',      'd',      '_', 
        'r',      'q',      '\000'};
#line 72
struct kernel_symbol  const  __ksymtab_ide_end_rq ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
struct kernel_symbol  const  __ksymtab_ide_end_rq  =    {(unsigned long )(& ide_end_rq), (char const   *)(& __kstrtab_ide_end_rq)};
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void ide_complete_cmd(ide_drive_t *drive , struct ide_cmd *cmd , u8 stat , u8 err ) 
{ 
  struct ide_tp_ops  const  *tp_ops ;
  struct ide_taskfile *tf ;
  struct request *rq ;
  u8 tf_cmd ;
  u8 data[2U] ;
  struct ide_cmd *orig_cmd ;

  {
#line 76
  tp_ops = (drive->hwif)->tp_ops;
#line 77
  tf = & cmd->tf;
#line 78
  rq = cmd->rq;
#line 79
  tf_cmd = tf->__annonCompField84.command;
#line 81
  tf->__annonCompField83.error = err;
#line 82
  tf->__annonCompField84.status = stat;
#line 84
  if (((int )cmd->ftf_flags & 8) != 0) {
    {
#line 87
    (*(tp_ops->input_data))(drive, cmd, (void *)(& data), 2U);
#line 89
    cmd->tf.data = data[0];
#line 90
    cmd->hob.data = data[1];
    }
  } else {

  }
  {
#line 93
  ide_tf_readback(drive, cmd);
  }
#line 95
  if (((int )cmd->tf_flags & 4) != 0 && (unsigned int )tf_cmd == 225U) {
#line 97
    if ((unsigned int )tf->lbal != 196U) {
      {
#line 98
      printk("\v%s: head unload failed!\n", (char *)(& drive->name));
#line 100
      ide_tf_dump((char const   *)(& drive->name), cmd);
      }
    } else {
#line 102
      drive->dev_flags = drive->dev_flags | 134217728UL;
    }
  } else {

  }
#line 105
  if ((unsigned long )rq != (unsigned long )((struct request *)0) && (unsigned int )rq->cmd_type == 8U) {
#line 106
    orig_cmd = (struct ide_cmd *)rq->special;
#line 108
    if (((int )cmd->tf_flags & 32) != 0) {
      {
#line 109
      kfree((void const   *)orig_cmd);
      }
    } else {
      {
#line 111
      __memcpy((void *)orig_cmd, (void const   *)cmd, 80UL);
      }
    }
  } else {

  }
#line 113
  return;
}
}
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
int ide_complete_rq(ide_drive_t *drive , int error , unsigned int nr_bytes ) 
{ 
  ide_hwif_t *hwif ;
  struct request *rq ;
  int rc ;
  unsigned int tmp ;

  {
#line 117
  hwif = drive->hwif;
#line 118
  rq = hwif->rq;
#line 125
  if ((rq->cmd_flags & 14ULL) != 0ULL && error <= 0) {
    {
#line 126
    tmp = blk_rq_sectors((struct request  const  *)rq);
#line 126
    nr_bytes = tmp << 9;
    }
  } else {

  }
  {
#line 128
  rc = ide_end_rq(drive, rq, error, nr_bytes);
  }
#line 129
  if (rc == 0) {
#line 130
    hwif->rq = (struct request *)0;
  } else {

  }
#line 132
  return (rc);
}
}
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static char const   __kstrtab_ide_complete_rq[16U]  = 
#line 134
  {      'i',      'd',      'e',      '_', 
        'c',      'o',      'm',      'p', 
        'l',      'e',      't',      'e', 
        '_',      'r',      'q',      '\000'};
#line 134
struct kernel_symbol  const  __ksymtab_ide_complete_rq ;
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
struct kernel_symbol  const  __ksymtab_ide_complete_rq  =    {(unsigned long )(& ide_complete_rq), (char const   *)(& __kstrtab_ide_complete_rq)};
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void ide_kill_rq(ide_drive_t *drive , struct request *rq ) 
{ 
  u8 drv_req ;
  u8 media ;
  unsigned int tmp ;

  {
#line 138
  drv_req = (u8 )((unsigned int )rq->cmd_type == 7U && (unsigned long )rq->rq_disk != (unsigned long )((struct gendisk *)0));
#line 139
  media = drive->media;
#line 141
  drive->failed_pc = (struct ide_atapi_pc *)0;
#line 143
  if ((unsigned int )media <= 1U && (unsigned int )drv_req != 0U) {
#line 144
    rq->errors = 0;
  } else
#line 146
  if ((unsigned int )media == 1U) {
#line 147
    rq->errors = 101;
  } else
#line 148
  if ((unsigned int )rq->cmd_type != 1U && rq->errors == 0) {
#line 149
    rq->errors = -5;
  } else {

  }
  {
#line 152
  tmp = blk_rq_bytes((struct request  const  *)rq);
#line 152
  ide_complete_rq(drive, -5, tmp);
  }
#line 153
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static void ide_tf_set_specify_cmd(ide_drive_t *drive , struct ide_taskfile *tf ) 
{ 


  {
#line 157
  tf->nsect = drive->sect;
#line 158
  tf->lbal = drive->sect;
#line 159
  tf->lbam = (u8 )drive->cyl;
#line 160
  tf->lbah = (u8 )(drive->cyl >> 8);
#line 161
  tf->device = (u8 )((int )((signed char )((unsigned int )drive->head + 255U)) | (int )((signed char )drive->select));
#line 162
  tf->__annonCompField84.command = 145U;
#line 163
  return;
}
}
#line 165 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static void ide_tf_set_restore_cmd(ide_drive_t *drive , struct ide_taskfile *tf ) 
{ 


  {
#line 167
  tf->nsect = drive->sect;
#line 168
  tf->__annonCompField84.command = 16U;
#line 169
  return;
}
}
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static void ide_tf_set_setmult_cmd(ide_drive_t *drive , struct ide_taskfile *tf ) 
{ 


  {
#line 173
  tf->nsect = drive->mult_req;
#line 174
  tf->__annonCompField84.command = 198U;
#line 175
  return;
}
}
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static ide_startstop_t do_special(ide_drive_t *drive ) 
{ 
  struct ide_cmd cmd ;

  {
#line 193
  if ((unsigned int )drive->media != 32U) {
#line 194
    drive->special_flags = 0U;
#line 195
    drive->mult_req = 0U;
#line 196
    return (0);
  } else {

  }
  {
#line 199
  __memset((void *)(& cmd), 0, 80UL);
#line 200
  cmd.protocol = 1;
  }
#line 202
  if ((int )drive->special_flags & 1) {
    {
#line 203
    drive->special_flags = (unsigned int )drive->special_flags & 254U;
#line 204
    ide_tf_set_specify_cmd(drive, & cmd.tf);
    }
  } else
#line 205
  if (((int )drive->special_flags & 2) != 0) {
    {
#line 206
    drive->special_flags = (unsigned int )drive->special_flags & 253U;
#line 207
    ide_tf_set_restore_cmd(drive, & cmd.tf);
    }
  } else
#line 208
  if (((int )drive->special_flags & 4) != 0) {
    {
#line 209
    drive->special_flags = (unsigned int )drive->special_flags & 251U;
#line 210
    ide_tf_set_setmult_cmd(drive, & cmd.tf);
    }
  } else {
    {
#line 212
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-io.c"),
                         "i" (212), "i" (12UL));
#line 212
    __builtin_unreachable();
    }
  }
  {
#line 214
  cmd.valid.out.tf = 126U;
#line 215
  cmd.valid.in.tf = 124U;
#line 216
  cmd.tf_flags = 4U;
#line 218
  do_rw_taskfile(drive, & cmd);
  }
#line 220
  return (1);
}
}
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void ide_map_sg(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  ide_hwif_t *hwif ;
  struct scatterlist *sg ;
  struct request *rq ;

  {
  {
#line 225
  hwif = drive->hwif;
#line 226
  sg = hwif->sg_table;
#line 227
  rq = cmd->rq;
#line 229
  cmd->sg_nents = blk_rq_map_sg(drive->queue, rq, sg);
  }
#line 230
  return;
}
}
#line 231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static char const   __kstrtab_ide_map_sg[11U]  = 
#line 231
  {      'i',      'd',      'e',      '_', 
        'm',      'a',      'p',      '_', 
        's',      'g',      '\000'};
#line 231
struct kernel_symbol  const  __ksymtab_ide_map_sg ;
#line 231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
struct kernel_symbol  const  __ksymtab_ide_map_sg  =    {(unsigned long )(& ide_map_sg), (char const   *)(& __kstrtab_ide_map_sg)};
#line 233 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void ide_init_sg_cmd(struct ide_cmd *cmd , unsigned int nr_bytes ) 
{ 
  unsigned int tmp ;

  {
#line 235
  tmp = nr_bytes;
#line 235
  cmd->nleft = tmp;
#line 235
  cmd->nbytes = tmp;
#line 236
  cmd->cursg_ofs = 0U;
#line 237
  cmd->cursg = (struct scatterlist *)0;
#line 238
  return;
}
}
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static char const   __kstrtab_ide_init_sg_cmd[16U]  = 
#line 239
  {      'i',      'd',      'e',      '_', 
        'i',      'n',      'i',      't', 
        '_',      's',      'g',      '_', 
        'c',      'm',      'd',      '\000'};
#line 239
struct kernel_symbol  const  __ksymtab_ide_init_sg_cmd ;
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
struct kernel_symbol  const  __ksymtab_ide_init_sg_cmd  =    {(unsigned long )(& ide_init_sg_cmd), (char const   *)(& __kstrtab_ide_init_sg_cmd)};
#line 253 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static ide_startstop_t execute_drive_cmd(ide_drive_t *drive , struct request *rq ) 
{ 
  struct ide_cmd *cmd ;
  unsigned int tmp ;
  ide_startstop_t tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 256
  cmd = (struct ide_cmd *)rq->special;
#line 258
  if ((unsigned long )cmd != (unsigned long )((struct ide_cmd *)0)) {
#line 259
    if (cmd->protocol == 2) {
      {
#line 260
      tmp = blk_rq_sectors((struct request  const  *)rq);
#line 260
      ide_init_sg_cmd(cmd, tmp << 9);
#line 261
      ide_map_sg(drive, cmd);
      }
    } else {

    }
    {
#line 264
    tmp___0 = do_rw_taskfile(drive, cmd);
    }
#line 264
    return (tmp___0);
  } else {

  }
  {
#line 274
  rq->errors = 0;
#line 275
  tmp___1 = blk_rq_bytes((struct request  const  *)rq);
#line 275
  ide_complete_rq(drive, 0, tmp___1);
  }
#line 277
  return (0);
}
}
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static ide_startstop_t ide_special_rq(ide_drive_t *drive , struct request *rq ) 
{ 
  u8 cmd ;
  ide_startstop_t tmp ;
  ide_startstop_t tmp___0 ;
  ide_startstop_t tmp___1 ;

  {
#line 282
  cmd = *(rq->cmd);
  {
#line 285
  if ((int )cmd == 34) {
#line 285
    goto case_34;
  } else {

  }
#line 286
  if ((int )cmd == 35) {
#line 286
    goto case_35;
  } else {

  }
#line 288
  if ((int )cmd == 33) {
#line 288
    goto case_33;
  } else {

  }
#line 290
  if ((int )cmd == 32) {
#line 290
    goto case_32;
  } else {

  }
#line 292
  goto switch_default;
  case_34: /* CIL Label */ ;
  case_35: /* CIL Label */ 
  {
#line 287
  tmp = ide_do_park_unpark(drive, rq);
  }
#line 287
  return (tmp);
  case_33: /* CIL Label */ 
  {
#line 289
  tmp___0 = ide_do_devset(drive, rq);
  }
#line 289
  return (tmp___0);
  case_32: /* CIL Label */ 
  {
#line 291
  tmp___1 = ide_do_reset(drive);
  }
#line 291
  return (tmp___1);
  switch_default: /* CIL Label */ 
  {
#line 293
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-io.c"),
                       "i" (293), "i" (12UL));
#line 293
  __builtin_unreachable();
  }
  switch_break: /* CIL Label */ ;
  }
#line 295
  return ((enum ldv_28239 )0);
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static ide_startstop_t start_request(ide_drive_t *drive , struct request *rq ) 
{ 
  ide_startstop_t startstop ;
  long tmp ;
  int tmp___0 ;
  struct ide_driver *drv ;
  ide_startstop_t tmp___1 ;
  struct request_pm_state *pm ;
  ide_startstop_t tmp___2 ;
  sector_t tmp___3 ;
  ide_startstop_t tmp___4 ;
  ide_startstop_t tmp___5 ;

  {
  {
#line 310
  tmp = __builtin_expect((rq->cmd_flags & 524288ULL) == 0ULL, 0L);
  }
#line 310
  if (tmp != 0L) {
    {
#line 310
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-io.c"),
                         "i" (310), "i" (12UL));
#line 310
    __builtin_unreachable();
    }
  } else {

  }
#line 318
  if (drive->max_failures != 0U && drive->failures > drive->max_failures) {
#line 319
    rq->cmd_flags = rq->cmd_flags | 8388608ULL;
#line 320
    goto kill_rq;
  } else {

  }
#line 323
  if ((unsigned int )rq->cmd_type - 4U <= 1U) {
    {
#line 324
    ide_check_pm_state(drive, rq);
    }
  } else {

  }
  {
#line 326
  (*(((drive->hwif)->tp_ops)->dev_select))(drive);
#line 327
  tmp___0 = ide_wait_stat(& startstop, drive, (int )drive->ready_stat, 136, 1250UL);
  }
#line 327
  if (tmp___0 != 0) {
    {
#line 329
    printk("\v%s: drive not ready for command\n", (char *)(& drive->name));
    }
#line 330
    return (startstop);
  } else {

  }
#line 333
  if ((unsigned int )drive->special_flags == 0U) {
#line 340
    if ((unsigned int )drive->current_speed == 255U) {
      {
#line 341
      ide_config_drive_speed(drive, (int )drive->desired_speed);
      }
    } else {

    }
#line 343
    if ((unsigned int )rq->cmd_type == 8U) {
      {
#line 344
      tmp___1 = execute_drive_cmd(drive, rq);
      }
#line 344
      return (tmp___1);
    } else
#line 345
    if ((unsigned int )rq->cmd_type - 4U <= 1U) {
      {
#line 346
      pm = (struct request_pm_state *)rq->special;
#line 351
      startstop = ide_start_power_step(drive, rq);
      }
#line 352
      if ((unsigned int )startstop == 0U && pm->pm_step == 5) {
        {
#line 354
        ide_complete_pm_rq(drive, rq);
        }
      } else {

      }
#line 355
      return (startstop);
    } else
#line 356
    if ((unsigned long )rq->rq_disk == (unsigned long )((struct gendisk *)0) && (unsigned int )rq->cmd_type == 7U) {
      {
#line 365
      tmp___2 = ide_special_rq(drive, rq);
      }
#line 365
      return (tmp___2);
    } else {

    }
    {
#line 367
    drv = *((struct ide_driver **)(rq->rq_disk)->private_data);
#line 369
    tmp___3 = blk_rq_pos((struct request  const  *)rq);
#line 369
    tmp___4 = (*(drv->do_request))(drive, rq, tmp___3);
    }
#line 369
    return (tmp___4);
  } else {

  }
  {
#line 371
  tmp___5 = do_special(drive);
  }
#line 371
  return (tmp___5);
  kill_rq: 
  {
#line 373
  ide_kill_rq(drive, rq);
  }
#line 374
  return (0);
}
}
#line 386 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void ide_stall_queue(ide_drive_t *drive , unsigned long timeout ) 
{ 


  {
#line 388
  if (timeout > 7500UL) {
#line 389
    timeout = 7500UL;
  } else {

  }
#line 390
  drive->sleep = timeout + (unsigned long )jiffies;
#line 391
  drive->dev_flags = drive->dev_flags | 262144UL;
#line 392
  return;
}
}
#line 393 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static char const   __kstrtab_ide_stall_queue[16U]  = 
#line 393
  {      'i',      'd',      'e',      '_', 
        's',      't',      'a',      'l', 
        'l',      '_',      'q',      'u', 
        'e',      'u',      'e',      '\000'};
#line 393
struct kernel_symbol  const  __ksymtab_ide_stall_queue ;
#line 393 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
struct kernel_symbol  const  __ksymtab_ide_stall_queue  =    {(unsigned long )(& ide_stall_queue), (char const   *)(& __kstrtab_ide_stall_queue)};
#line 395 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
__inline static int ide_lock_port(ide_hwif_t *hwif ) 
{ 


  {
#line 397
  if ((unsigned int )*((unsigned char *)hwif + 388UL) != 0U) {
#line 398
    return (1);
  } else {

  }
#line 400
  hwif->busy = 1U;
#line 402
  return (0);
}
}
#line 405 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
__inline static void ide_unlock_port(ide_hwif_t *hwif ) 
{ 


  {
#line 407
  hwif->busy = 0U;
#line 408
  return;
}
}
#line 410 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
__inline static int ide_lock_host(struct ide_host *host , ide_hwif_t *hwif ) 
{ 
  int rc ;

  {
#line 412
  rc = 0;
#line 414
  if ((host->host_flags & 1048576UL) != 0UL) {
    {
#line 415
    rc = test_and_set_bit_lock(0L, & host->host_busy);
    }
#line 416
    if (rc == 0) {
#line 417
      if ((unsigned long )host->get_lock != (unsigned long )((void (*)(irqreturn_t (*)(int  ,
                                                                                       void * ) ,
                                                                       void * ))0)) {
        {
#line 418
        (*(host->get_lock))(& ide_intr, (void *)hwif);
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 421
  return (rc);
}
}
#line 424 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
__inline static void ide_unlock_host(struct ide_host *host ) 
{ 


  {
#line 426
  if ((host->host_flags & 1048576UL) != 0UL) {
#line 427
    if ((unsigned long )host->release_lock != (unsigned long )((void (*)(void))0)) {
      {
#line 428
      (*(host->release_lock))();
      }
    } else {

    }
    {
#line 429
    clear_bit_unlock(0L, & host->host_busy);
    }
  } else {

  }
#line 431
  return;
}
}
#line 433 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static void __ide_requeue_and_plug(struct request_queue *q , struct request *rq ) 
{ 
  struct request *tmp ;

  {
#line 435
  if ((unsigned long )rq != (unsigned long )((struct request *)0)) {
    {
#line 436
    blk_requeue_request(q, rq);
    }
  } else {

  }
#line 437
  if ((unsigned long )rq != (unsigned long )((struct request *)0)) {
    {
#line 439
    blk_delay_queue(q, 3UL);
    }
  } else {
    {
#line 437
    tmp = blk_peek_request(q);
    }
#line 437
    if ((unsigned long )tmp != (unsigned long )((struct request *)0)) {
      {
#line 439
      blk_delay_queue(q, 3UL);
      }
    } else {

    }
  }
#line 440
  return;
}
}
#line 443 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void ide_requeue_and_plug(ide_drive_t *drive , struct request *rq ) 
{ 
  struct request_queue *q ;
  unsigned long flags ;

  {
  {
#line 445
  q = drive->queue;
#line 448
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96(q->queue_lock);
#line 449
  __ide_requeue_and_plug(q, rq);
#line 450
  ldv_spin_unlock_irqrestore_97(q->queue_lock, flags);
  }
#line 451
  return;
}
}
#line 456 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void do_ide_request(struct request_queue *q ) 
{ 
  ide_drive_t *drive ;
  ide_hwif_t *hwif ;
  struct ide_host *host ;
  struct request *rq ;
  ide_startstop_t startstop ;
  unsigned long queue_run_ms ;
  int tmp ;
  ide_hwif_t *prev_port ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  unsigned long left ;
  unsigned int tmp___3 ;
  ide_drive_t *cur_dev ;
  int tmp___4 ;

  {
  {
#line 458
  drive = (ide_drive_t *)q->queuedata;
#line 459
  hwif = drive->hwif;
#line 460
  host = hwif->host;
#line 461
  rq = (struct request *)0;
#line 463
  queue_run_ms = 3UL;
#line 465
  ldv_spin_unlock_irq_98(q->queue_lock);
#line 468
  __might_sleep("drivers/ide/ide-io.c", 468, 0);
#line 470
  tmp = ide_lock_host(host, hwif);
  }
#line 470
  if (tmp != 0) {
#line 471
    goto plug_device_2;
  } else {

  }
  {
#line 473
  ldv_spin_lock_irq_99(& hwif->lock);
#line 475
  tmp___4 = ide_lock_port(hwif);
  }
#line 475
  if (tmp___4 == 0) {
    {
#line 478
    __ret_warn_once = (unsigned long )hwif->rq != (unsigned long )((struct request *)0);
#line 478
    tmp___2 = __builtin_expect(__ret_warn_once != 0, 0L);
    }
#line 478
    if (tmp___2 != 0L) {
      {
#line 478
      __ret_warn_on = ! __warned;
#line 478
      tmp___0 = __builtin_expect(__ret_warn_on != 0, 0L);
      }
#line 478
      if (tmp___0 != 0L) {
        {
#line 478
        warn_slowpath_null("drivers/ide/ide-io.c", 478);
        }
      } else {

      }
      {
#line 478
      tmp___1 = __builtin_expect(__ret_warn_on != 0, 0L);
      }
#line 478
      if (tmp___1 != 0L) {
#line 478
        __warned = 1;
      } else {

      }
    } else {

    }
    {
#line 478
    __builtin_expect(__ret_warn_once != 0, 0L);
    }
    repeat: 
#line 480
    prev_port = (hwif->host)->cur_port;
#line 482
    if ((drive->dev_flags & 262144UL) != 0UL && (long )((unsigned long )jiffies - drive->sleep) < 0L) {
      {
#line 483
      left = (unsigned long )jiffies - drive->sleep;
#line 485
      tmp___3 = jiffies_to_msecs(left + 1UL);
#line 485
      queue_run_ms = (unsigned long )tmp___3;
#line 486
      ide_unlock_port(hwif);
      }
#line 487
      goto plug_device;
    } else {

    }
#line 490
    if (((hwif->host)->host_flags & 1048576UL) != 0UL && (unsigned long )hwif != (unsigned long )prev_port) {
#line 492
      cur_dev = (unsigned long )prev_port != (unsigned long )((ide_hwif_t *)0) ? prev_port->cur_dev : (ide_drive_t *)0;
#line 499
      if ((unsigned long )cur_dev != (unsigned long )((ide_drive_t *)0) && (cur_dev->dev_flags & 0xffffffff80000000UL) == 0UL) {
        {
#line 501
        (*((prev_port->tp_ops)->write_devctl))(prev_port, 10);
        }
      } else {

      }
#line 505
      (hwif->host)->cur_port = hwif;
    } else {

    }
    {
#line 507
    hwif->cur_dev = drive;
#line 508
    drive->dev_flags = drive->dev_flags & 0xfffffffff7fbffffUL;
#line 510
    ldv_spin_unlock_irq_100(& hwif->lock);
#line 511
    ldv_spin_lock_irq_101(q->queue_lock);
    }
#line 516
    if ((unsigned long )rq == (unsigned long )((struct request *)0)) {
      {
#line 517
      rq = blk_fetch_request(drive->queue);
      }
    } else {

    }
    {
#line 519
    ldv_spin_unlock_irq_98(q->queue_lock);
#line 520
    ldv_spin_lock_irq_99(& hwif->lock);
    }
#line 522
    if ((unsigned long )rq == (unsigned long )((struct request *)0)) {
      {
#line 523
      ide_unlock_port(hwif);
      }
#line 524
      goto out;
    } else {

    }
#line 540
    if (((drive->dev_flags & 131072UL) != 0UL && (unsigned int )rq->cmd_type - 4U > 1U) && (rq->cmd_flags & 33554432ULL) == 0ULL) {
      {
#line 544
      ide_unlock_port(hwif);
      }
#line 545
      goto plug_device;
    } else {

    }
    {
#line 548
    hwif->rq = rq;
#line 550
    ldv_spin_unlock_irq_100(& hwif->lock);
#line 551
    startstop = start_request(drive, rq);
#line 552
    ldv_spin_lock_irq_99(& hwif->lock);
    }
#line 554
    if ((unsigned int )startstop == 0U) {
#line 555
      rq = hwif->rq;
#line 556
      hwif->rq = (struct request *)0;
#line 557
      goto repeat;
    } else {

    }
  } else {
#line 560
    goto plug_device;
  }
  out: 
  {
#line 562
  ldv_spin_unlock_irq_100(& hwif->lock);
  }
#line 563
  if ((unsigned long )rq == (unsigned long )((struct request *)0)) {
    {
#line 564
    ide_unlock_host(host);
    }
  } else {

  }
  {
#line 565
  ldv_spin_lock_irq_101(q->queue_lock);
  }
#line 566
  return;
  plug_device: 
  {
#line 569
  ldv_spin_unlock_irq_100(& hwif->lock);
#line 570
  ide_unlock_host(host);
  }
  plug_device_2: 
  {
#line 572
  ldv_spin_lock_irq_101(q->queue_lock);
#line 573
  __ide_requeue_and_plug(q, rq);
  }
#line 574
  return;
}
}
#line 576 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static int drive_is_ready(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u8 stat ;
  int tmp ;

  {
#line 578
  hwif = drive->hwif;
#line 579
  stat = 0U;
#line 581
  if ((unsigned int )drive->waiting_for_dma != 0U) {
    {
#line 582
    tmp = (*((hwif->dma_ops)->dma_test_irq))(drive);
    }
#line 582
    return (tmp);
  } else {

  }
#line 584
  if (hwif->io_ports.ctl_addr != 0UL && (hwif->host_flags & 67108864U) == 0U) {
    {
#line 586
    stat = (*((hwif->tp_ops)->read_altstatus))(hwif);
    }
  } else {
    {
#line 589
    stat = (*((hwif->tp_ops)->read_status))(hwif);
    }
  }
#line 591
  if ((int )((signed char )stat) < 0) {
#line 593
    return (0);
  } else {

  }
#line 596
  return (1);
}
}
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void ide_timer_expiry(unsigned long data ) 
{ 
  ide_hwif_t *hwif ;
  ide_drive_t *drive ;
  ide_handler_t *handler ;
  unsigned long flags ;
  int wait ;
  int plug_device ;
  struct request *rq_in_flight ;
  ide_expiry_t *expiry ;
  ide_startstop_t startstop ;
  u8 tmp ;
  int tmp___0 ;

  {
  {
#line 615
  hwif = (ide_hwif_t *)data;
#line 616
  drive = drive;
#line 619
  wait = -1;
#line 620
  plug_device = 0;
#line 621
  rq_in_flight = rq_in_flight;
#line 623
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_110(& hwif->lock);
#line 625
  handler = hwif->handler;
  }
#line 627
  if ((unsigned long )handler == (unsigned long )((ide_handler_t *)0) || hwif->req_gen != hwif->req_gen_timer) {

  } else {
#line 635
    expiry = hwif->expiry;
#line 636
    startstop = 0;
#line 638
    drive = hwif->cur_dev;
#line 640
    if ((unsigned long )expiry != (unsigned long )((ide_expiry_t *)0)) {
      {
#line 641
      wait = (*expiry)(drive);
      }
#line 642
      if (wait > 0) {
        {
#line 644
        hwif->timer.expires = (unsigned long )jiffies + (unsigned long )wait;
#line 645
        hwif->req_gen_timer = hwif->req_gen;
#line 646
        add_timer(& hwif->timer);
#line 647
        ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
        }
#line 648
        return;
      } else {

      }
    } else {

    }
    {
#line 651
    hwif->handler = (ide_startstop_t (*)(ide_drive_t * ))0;
#line 652
    hwif->expiry = (int (*)(ide_drive_t * ))0;
#line 658
    ldv_spin_unlock_112(& hwif->lock);
#line 660
    disable_irq((unsigned int )hwif->irq);
#line 662
    arch_local_irq_disable();
#line 662
    trace_hardirqs_off();
    }
#line 663
    if ((unsigned int )*((unsigned char *)hwif + 1928UL) != 0U) {
      {
#line 664
      startstop = (*handler)(drive);
      }
    } else {
      {
#line 665
      tmp___0 = drive_is_ready(drive);
      }
#line 665
      if (tmp___0 != 0) {
#line 666
        if ((unsigned int )drive->waiting_for_dma != 0U) {
          {
#line 667
          (*((hwif->dma_ops)->dma_lost_irq))(drive);
          }
        } else {

        }
#line 668
        if ((unsigned long )hwif->port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )(hwif->port_ops)->clear_irq != (unsigned long )((void (*/* const  */)(ide_drive_t * ))0)) {
          {
#line 669
          (*((hwif->port_ops)->clear_irq))(drive);
          }
        } else {

        }
        {
#line 671
        printk("\f%s: lost interrupt\n", (char *)(& drive->name));
#line 673
        startstop = (*handler)(drive);
        }
      } else
#line 675
      if ((unsigned int )drive->waiting_for_dma != 0U) {
        {
#line 676
        startstop = ide_dma_timeout_retry(drive, wait);
        }
      } else {
        {
#line 678
        tmp = (*((hwif->tp_ops)->read_status))(hwif);
#line 678
        startstop = ide_error(drive, "irq timeout", (int )tmp);
        }
      }
    }
    {
#line 681
    ldv_spin_lock_irq_99(& hwif->lock);
#line 682
    enable_irq((unsigned int )hwif->irq);
    }
#line 683
    if ((unsigned int )startstop == 0U && (unsigned int )*((unsigned char *)hwif + 1928UL) == 0U) {
      {
#line 684
      rq_in_flight = hwif->rq;
#line 685
      hwif->rq = (struct request *)0;
#line 686
      ide_unlock_port(hwif);
#line 687
      plug_device = 1;
      }
    } else {

    }
  }
  {
#line 690
  ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
  }
#line 692
  if (plug_device != 0) {
    {
#line 693
    ide_unlock_host(hwif->host);
#line 694
    ide_requeue_and_plug(drive, rq_in_flight);
    }
  } else {

  }
#line 696
  return;
}
}
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static void unexpected_intr(int irq , ide_hwif_t *hwif ) 
{ 
  u8 stat ;
  u8 tmp ;
  unsigned long last_msgtime ;
  unsigned long count ;

  {
  {
#line 729
  tmp = (*((hwif->tp_ops)->read_status))(hwif);
#line 729
  stat = tmp;
  }
#line 731
  if (((int )stat & 201) != 64) {
#line 734
    count = count + 1UL;
#line 736
    if ((long )((last_msgtime - (unsigned long )jiffies) + 250UL) < 0L) {
      {
#line 737
      last_msgtime = jiffies;
#line 738
      printk("\v%s: unexpected interrupt, status=0x%02x, count=%ld\n", (char *)(& hwif->name),
             (int )stat, count);
      }
    } else {

    }
  } else {

  }
#line 743
  return;
}
}
#line 770 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
irqreturn_t ide_intr(int irq , void *dev_id ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_host *host ;
  ide_drive_t *drive ;
  ide_handler_t *handler ;
  unsigned long flags ;
  ide_startstop_t startstop ;
  irqreturn_t irq_ret ;
  int plug_device ;
  struct request *rq_in_flight ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 772
  hwif = (ide_hwif_t *)dev_id;
#line 773
  host = hwif->host;
#line 774
  drive = drive;
#line 778
  irq_ret = 0;
#line 779
  plug_device = 0;
#line 780
  rq_in_flight = rq_in_flight;
#line 782
  if ((host->host_flags & 1048576UL) != 0UL) {
#line 783
    if ((unsigned long )hwif != (unsigned long )host->cur_port) {
#line 784
      goto out_early;
    } else {

    }
  } else {

  }
  {
#line 787
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_115(& hwif->lock);
  }
#line 789
  if ((unsigned long )hwif->port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )(hwif->port_ops)->test_irq != (unsigned long )((int (*/* const  */)(struct hwif_s * ))0)) {
    {
#line 789
    tmp = (*((hwif->port_ops)->test_irq))(hwif);
    }
#line 789
    if (tmp == 0) {
#line 791
      goto out;
    } else {

    }
  } else {

  }
#line 793
  handler = hwif->handler;
#line 795
  if ((unsigned long )handler == (unsigned long )((ide_handler_t *)0) || (unsigned int )*((unsigned char *)hwif + 1928UL) != 0U) {
#line 808
    if ((host->irq_flags & 128) == 0) {
      {
#line 813
      unexpected_intr(irq, hwif);
      }
    } else {
      {
#line 819
      (*((hwif->tp_ops)->read_status))(hwif);
      }
    }
#line 821
    goto out;
  } else {

  }
  {
#line 824
  drive = hwif->cur_dev;
#line 826
  tmp___0 = drive_is_ready(drive);
  }
#line 826
  if (tmp___0 == 0) {
#line 834
    goto out;
  } else {

  }
  {
#line 836
  hwif->handler = (ide_startstop_t (*)(ide_drive_t * ))0;
#line 837
  hwif->expiry = (int (*)(ide_drive_t * ))0;
#line 838
  hwif->req_gen = hwif->req_gen + 1;
#line 839
  ldv_del_timer_116(& hwif->timer);
#line 840
  ldv_spin_unlock_112(& hwif->lock);
  }
#line 842
  if ((unsigned long )hwif->port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )(hwif->port_ops)->clear_irq != (unsigned long )((void (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 843
    (*((hwif->port_ops)->clear_irq))(drive);
    }
  } else {

  }
  {
#line 849
  startstop = (*handler)(drive);
#line 851
  ldv_spin_lock_irq_99(& hwif->lock);
  }
#line 859
  if ((unsigned int )startstop == 0U && (unsigned int )*((unsigned char *)hwif + 1928UL) == 0U) {
    {
#line 860
    tmp___1 = __builtin_expect((unsigned long )hwif->handler != (unsigned long )((ide_startstop_t (*)(ide_drive_t * ))0),
                               0L);
    }
#line 860
    if (tmp___1 != 0L) {
      {
#line 860
      __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-io.c"),
                           "i" (860), "i" (12UL));
#line 860
      __builtin_unreachable();
      }
    } else {

    }
    {
#line 861
    rq_in_flight = hwif->rq;
#line 862
    hwif->rq = (struct request *)0;
#line 863
    ide_unlock_port(hwif);
#line 864
    plug_device = 1;
    }
  } else {

  }
#line 866
  irq_ret = 1;
  out: 
  {
#line 868
  ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
  }
  out_early: ;
#line 870
  if (plug_device != 0) {
    {
#line 871
    ide_unlock_host(hwif->host);
#line 872
    ide_requeue_and_plug(drive, rq_in_flight);
    }
  } else {

  }
#line 875
  return (irq_ret);
}
}
#line 877 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static char const   __kstrtab_ide_intr[9U]  = 
#line 877
  {      'i',      'd',      'e',      '_', 
        'i',      'n',      't',      'r', 
        '\000'};
#line 877
struct kernel_symbol  const  __ksymtab_ide_intr ;
#line 877 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
struct kernel_symbol  const  __ksymtab_ide_intr  =    {(unsigned long )(& ide_intr), (char const   *)(& __kstrtab_ide_intr)};
#line 879 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
void ide_pad_transfer(ide_drive_t *drive , int write , int len ) 
{ 
  ide_hwif_t *hwif ;
  u8 buf[4U] ;
  unsigned int tmp ;
  int _min1 ;
  int _min2 ;
  int _min1___0 ;
  int _min2___0 ;

  {
#line 881
  hwif = drive->hwif;
#line 882
  buf[0] = 0U;
#line 882
  tmp = 1U;
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (tmp >= 4U) {
#line 882
      goto while_break;
    } else {

    }
#line 882
    buf[tmp] = (unsigned char)0;
#line 882
    tmp = tmp + 1U;
  }
  while_break: /* CIL Label */ ;
  }
#line 884
  goto ldv_39436;
  ldv_39435: ;
#line 885
  if (write != 0) {
    {
#line 886
    _min1 = 4;
#line 886
    _min2 = len;
#line 886
    (*((hwif->tp_ops)->output_data))(drive, (struct ide_cmd *)0, (void *)(& buf),
                                     (unsigned int )(_min1 < _min2 ? _min1 : _min2));
    }
  } else {
    {
#line 888
    _min1___0 = 4;
#line 888
    _min2___0 = len;
#line 888
    (*((hwif->tp_ops)->input_data))(drive, (struct ide_cmd *)0, (void *)(& buf), (unsigned int )(_min1___0 < _min2___0 ? _min1___0 : _min2___0));
    }
  }
#line 889
  len = len + -4;
  ldv_39436: ;
#line 884
  if (len > 0) {
#line 886
    goto ldv_39435;
  } else {

  }

#line 891
  return;
}
}
#line 892 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
static char const   __kstrtab_ide_pad_transfer[17U]  = 
#line 892
  {      'i',      'd',      'e',      '_', 
        'p',      'a',      'd',      '_', 
        't',      'r',      'a',      'n', 
        's',      'f',      'e',      'r', 
        '\000'};
#line 892
struct kernel_symbol  const  __ksymtab_ide_pad_transfer ;
#line 892 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io.c"
struct kernel_symbol  const  __ksymtab_ide_pad_transfer  =    {(unsigned long )(& ide_pad_transfer), (char const   *)(& __kstrtab_ide_pad_transfer)};
#line 631 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
int ldv_del_timer(int arg0 , struct timer_list *arg1 ) ;
#line 632
void ldv_dispatch_instance_deregister_38_1(struct timer_list *arg0 ) ;
#line 641 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
int ldv_del_timer(int arg0 , struct timer_list *arg1 ) 
{ 
  struct timer_list *ldv_38_timer_list_timer_list ;

  {
  {
#line 647
  ldv_38_timer_list_timer_list = arg1;
#line 651
  ldv_dispatch_instance_deregister_38_1(ldv_38_timer_list_timer_list);
  }
#line 655
  return (arg0);
#line 657
  return (arg0);
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
void ldv_dispatch_instance_deregister_38_1(struct timer_list *arg0 ) 
{ 


  {
#line 666
  return;
}
}
#line 1359 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1362
  ldv_linux_kernel_locking_spinlock_spin_lock_queue_lock_of_request_queue();
#line 1364
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1365
  return;
}
}
#line 1367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
__inline static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 1370
  ldv_linux_kernel_locking_spinlock_spin_unlock_queue_lock_of_request_queue();
#line 1372
  spin_unlock_irqrestore(lock, flags);
  }
#line 1373
  return;
}
}
#line 1375 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
__inline static void ldv_spin_unlock_irq_98(spinlock_t *lock ) 
{ 


  {
  {
#line 1378
  ldv_linux_kernel_locking_spinlock_spin_unlock_queue_lock_of_request_queue();
#line 1380
  spin_unlock_irq(lock);
  }
#line 1381
  return;
}
}
#line 1383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
__inline static void ldv_spin_lock_irq_99(spinlock_t *lock ) 
{ 


  {
  {
#line 1386
  ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s();
#line 1388
  spin_lock_irq(lock);
  }
#line 1389
  return;
}
}
#line 1391 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
__inline static void ldv_spin_unlock_irq_100(spinlock_t *lock ) 
{ 


  {
  {
#line 1394
  ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_hwif_s();
#line 1396
  spin_unlock_irq(lock);
  }
#line 1397
  return;
}
}
#line 1399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
__inline static void ldv_spin_lock_irq_101(spinlock_t *lock ) 
{ 


  {
  {
#line 1402
  ldv_linux_kernel_locking_spinlock_spin_lock_queue_lock_of_request_queue();
#line 1404
  spin_lock_irq(lock);
  }
#line 1405
  return;
}
}
#line 1471 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_110(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1474
  ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s();
#line 1476
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1477
  return;
}
}
#line 1479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  {
#line 1482
  ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_hwif_s();
#line 1484
  spin_unlock_irqrestore(lock, flags);
  }
#line 1485
  return;
}
}
#line 1487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
__inline static void ldv_spin_unlock_112(spinlock_t *lock ) 
{ 


  {
  {
#line 1490
  ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_hwif_s();
#line 1492
  spin_unlock(lock);
  }
#line 1493
  return;
}
}
#line 1511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_115(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1514
  ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s();
#line 1516
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1517
  return;
}
}
#line 1519 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io.c.aux"
static int ldv_del_timer_116(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1523
  tmp = del_timer(ldv_func_arg1);
#line 1523
  ldv_func_res = tmp;
#line 1526
  tmp___0 = ldv_del_timer(ldv_func_res, ldv_func_arg1);
  }
#line 1526
  return (tmp___0);
#line 1528
  return (ldv_func_res);
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/swab.h"
__inline static __u16 __swab16p(__u16 const   *p ) 
{ 
  __u16 tmp ;

  {
  {
#line 159
  tmp = __fswab16((int )*p);
  }
#line 159
  return (tmp);
}
}
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/uapi/linux/swab.h"
__inline static void __swab16s(__u16 *p ) 
{ 


  {
  {
#line 228
  *p = __swab16p((__u16 const   *)p);
  }
#line 229
  return;
}
}
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern int strcmp(char const   * , char const   * ) ;
#line 71 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/string.h"
extern char *strstr(char const   * , char const   * ) ;
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  {
#line 804
  __edi = __edi;
#line 804
  __esi = __esi;
#line 804
  __edx = __edx;
#line 804
  __ecx = __ecx;
#line 804
  __eax = __eax;
#line 804
  tmp = __builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  }
#line 804
  if (tmp != 0L) {
    {
#line 804
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (804), "i" (12UL));
#line 804
    __builtin_unreachable();
    }
  } else {

  }
#line 804
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
#line 804
  __ret = __eax;
#line 804
  return (__ret);
}
}
#line 807 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static void arch_local_irq_restore(unsigned long f ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  {
#line 809
  __edi = __edi;
#line 809
  __esi = __esi;
#line 809
  __edx = __edx;
#line 809
  __ecx = __ecx;
#line 809
  __eax = __eax;
#line 809
  tmp = __builtin_expect((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0),
                         0L);
  }
#line 809
  if (tmp != 0L) {
    {
#line 809
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (809), "i" (12UL));
#line 809
    __builtin_unreachable();
    }
  } else {

  }
#line 809
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
#line 811
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/irqflags.h"
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
#line 157
  return ((flags & 512UL) == 0UL);
}
}
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/irqflags.h"
extern void trace_hardirqs_on(void) ;
#line 489 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-iops.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___0(spinlock_t *ldv_func_arg1 ) ;
#line 493
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_98(spinlock_t *ldv_func_arg1 ) ;
#line 454 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 458
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 374 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
extern void touch_softlockup_watchdog(void) ;
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/delay.h"
extern void __const_udelay(unsigned long  ) ;
#line 725 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_is_sata(u16 const   *id ) 
{ 


  {
#line 733
  if ((unsigned int )((unsigned short )*(id + 93UL)) == 0U && (int )((short )*(id + 80UL)) > 31) {
#line 734
    return (1);
  } else {

  }
#line 735
  return (0);
}
}
#line 833 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_is_cfa(u16 const   *id ) 
{ 


  {
#line 835
  if ((unsigned int )*id == 33930U || (unsigned int )*id == 33866U) {
#line 837
    return (1);
  } else {

  }
#line 846
  return (((int )*(id + 83UL) & 49156) == 16388);
}
}
#line 1049 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void __ide_set_handler(ide_drive_t *drive , ide_handler_t *handler , unsigned int timeout ) ;
#line 1050
void ide_set_handler(ide_drive_t *drive , ide_handler_t *handler , unsigned int timeout ) ;
#line 1052
void ide_execute_command(ide_drive_t *drive , struct ide_cmd *cmd , ide_handler_t *handler ,
                         unsigned int timeout ) ;
#line 1059
void ide_fix_driveid(u16 *id ) ;
#line 1061
void ide_fixstring(u8 *s , int const   bytecount , int const   byteswap ) ;
#line 1065
int __ide_wait_stat(ide_drive_t *drive , u8 good , u8 bad , unsigned long timeout ,
                    u8 *rstat ) ;
#line 1094
void SELECT_MASK(ide_drive_t *drive , int mask ) ;
#line 1096
u8 ide_read_error(ide_drive_t *drive ) ;
#line 1154
int ide_dev_read_id(ide_drive_t *drive , u8 cmd , u16 *id , int irq_ctx ) ;
#line 1156
int ide_driveid_update(ide_drive_t *drive ) ;
#line 1158
u8 eighty_ninty_three(ide_drive_t *drive ) ;
#line 1161
int ide_wait_not_busy(ide_hwif_t *hwif , unsigned long timeout ) ;
#line 1341
int ide_in_drive_list(u16 *id , struct drive_list_entry  const  *table ) ;
#line 1354
void ide_dma_off_quietly(ide_drive_t *drive ) ;
#line 1426
void ide_check_nien_quirk_list(ide_drive_t *drive ) ;
#line 1457
u8 ide_dump_status(ide_drive_t *drive , char const   *msg , u8 stat ) ;
#line 19 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/nmi.h"
extern void touch_nmi_watchdog(void) ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
void SELECT_MASK(ide_drive_t *drive , int mask ) 
{ 
  struct ide_port_ops  const  *port_ops ;

  {
#line 32
  port_ops = (drive->hwif)->port_ops;
#line 34
  if ((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->maskproc != (unsigned long )((void (*/* const  */)(ide_drive_t * ,
                                                                                                                                                                     int  ))0)) {
    {
#line 35
    (*(port_ops->maskproc))(drive, mask);
    }
  } else {

  }
#line 36
  return;
}
}
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
u8 ide_read_error(ide_drive_t *drive ) 
{ 
  struct ide_taskfile tf ;

  {
  {
#line 42
  (*(((drive->hwif)->tp_ops)->tf_read))(drive, & tf, 2);
  }
#line 44
  return (tf.__annonCompField83.error);
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
static char const   __kstrtab_ide_read_error[15U]  = 
#line 46
  {      'i',      'd',      'e',      '_', 
        'r',      'e',      'a',      'd', 
        '_',      'e',      'r',      'r', 
        'o',      'r',      '\000'};
#line 46
struct kernel_symbol  const  __ksymtab_ide_read_error ;
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
struct kernel_symbol  const  __ksymtab_ide_read_error  =    {(unsigned long )(& ide_read_error), (char const   *)(& __kstrtab_ide_read_error)};
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
void ide_fix_driveid(u16 *id ) 
{ 


  {
#line 50
  return;
}
}
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
void ide_fixstring(u8 *s , int const   bytecount , int const   byteswap ) 
{ 
  u8 *p ;
  u8 *end ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;

  {
#line 71
  end = s + (unsigned long )((int )bytecount & -2);
#line 73
  if ((int )byteswap != 0) {
#line 75
    p = s;
#line 75
    goto ldv_39149;
    ldv_39148: 
    {
#line 76
    __swab16s((__u16 *)p);
#line 75
    p = p + 2UL;
    }
    ldv_39149: ;
#line 75
    if ((unsigned long )p != (unsigned long )end) {
#line 77
      goto ldv_39148;
    } else {

    }

  } else {

  }
#line 80
  p = s;
#line 81
  goto ldv_39152;
  ldv_39151: 
#line 82
  s = s + 1;
  ldv_39152: ;
#line 81
  if ((unsigned long )s != (unsigned long )end && (unsigned int )*s == 32U) {
#line 83
    goto ldv_39151;
  } else {

  }

#line 84
  goto ldv_39155;
  ldv_39154: 
#line 85
  tmp___0 = s;
#line 85
  s = s + 1;
#line 85
  if ((unsigned int )*tmp___0 != 32U || (((unsigned long )s != (unsigned long )end && (unsigned int )*s != 0U) && (unsigned int )*s != 32U)) {
#line 86
    tmp = p;
#line 86
    p = p + 1;
#line 86
    *tmp = *(s + 0xffffffffffffffffUL);
  } else {

  }
  ldv_39155: ;
#line 84
  if ((unsigned long )s != (unsigned long )end && (unsigned int )*s != 0U) {
#line 86
    goto ldv_39154;
  } else {

  }

#line 89
  goto ldv_39158;
  ldv_39157: 
#line 90
  tmp___1 = p;
#line 90
  p = p + 1;
#line 90
  *tmp___1 = 0U;
  ldv_39158: ;
#line 89
  if ((unsigned long )p != (unsigned long )end) {
#line 91
    goto ldv_39157;
  } else {

  }

#line 96
  return;
}
}
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
static char const   __kstrtab_ide_fixstring[14U]  = 
#line 92
  {      'i',      'd',      'e',      '_', 
        'f',      'i',      'x',      's', 
        't',      'r',      'i',      'n', 
        'g',      '\000'};
#line 92
struct kernel_symbol  const  __ksymtab_ide_fixstring ;
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
struct kernel_symbol  const  __ksymtab_ide_fixstring  =    {(unsigned long )(& ide_fixstring), (char const   *)(& __kstrtab_ide_fixstring)};
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
int __ide_wait_stat(ide_drive_t *drive , u8 good , u8 bad , unsigned long timeout ,
                    u8 *rstat ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_tp_ops  const  *tp_ops ;
  unsigned long flags ;
  int i ;
  u8 stat ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 108
  hwif = drive->hwif;
#line 109
  tp_ops = hwif->tp_ops;
#line 114
  __const_udelay(4295UL);
#line 115
  stat = (*(tp_ops->read_status))(hwif);
  }
#line 117
  if ((int )((signed char )stat) < 0) {
    {
#line 118
    flags = arch_local_save_flags();
#line 120
    timeout = timeout + (unsigned long )jiffies;
    }
#line 121
    goto ldv_39202;
    ldv_39201: ;
#line 122
    if ((long )(timeout - (unsigned long )jiffies) < 0L) {
      {
#line 128
      stat = (*(tp_ops->read_status))(hwif);
      }
#line 129
      if ((int )((signed char )stat) >= 0) {
#line 130
        goto ldv_39190;
      } else {

      }
      {
#line 132
      tmp = arch_irqs_disabled_flags(flags);
      }
#line 132
      if (tmp != 0) {
        {
#line 132
        arch_local_irq_restore(flags);
#line 132
        trace_hardirqs_off();
        }
      } else {
        {
#line 132
        trace_hardirqs_on();
#line 132
        arch_local_irq_restore(flags);
        }
      }
#line 133
      *rstat = stat;
#line 134
      return (-16);
    } else {

    }
    ldv_39202: 
    {
#line 121
    stat = (*(tp_ops->read_status))(hwif);
    }
#line 121
    if ((int )((signed char )stat) < 0) {
#line 123
      goto ldv_39201;
    } else {

    }
    ldv_39190: 
    {
#line 137
    tmp___0 = arch_irqs_disabled_flags(flags);
    }
#line 137
    if (tmp___0 != 0) {
      {
#line 137
      arch_local_irq_restore(flags);
#line 137
      trace_hardirqs_off();
      }
    } else {
      {
#line 137
      trace_hardirqs_on();
#line 137
      arch_local_irq_restore(flags);
      }
    }
  } else {

  }
#line 146
  i = 0;
#line 146
  goto ldv_39214;
  ldv_39213: 
  {
#line 147
  __const_udelay(4295UL);
#line 148
  stat = (*(tp_ops->read_status))(hwif);
  }
#line 150
  if (((int )stat & ((int )good | (int )bad)) == (int )good) {
#line 151
    *rstat = stat;
#line 152
    return (0);
  } else {

  }
#line 146
  i = i + 1;
  ldv_39214: ;
#line 146
  if (i <= 9) {
#line 148
    goto ldv_39213;
  } else {

  }
#line 155
  *rstat = stat;
#line 156
  return (-14);
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
int ide_wait_stat(ide_startstop_t *startstop , ide_drive_t *drive , u8 good , u8 bad ,
                  unsigned long timeout ) 
{ 
  int err ;
  u8 stat ;
  char *s ;

  {
#line 171
  if (drive->max_failures != 0U && drive->failures > drive->max_failures) {
#line 172
    *startstop = 0;
#line 173
    return (1);
  } else {

  }
  {
#line 176
  err = __ide_wait_stat(drive, (int )good, (int )bad, timeout, & stat);
  }
#line 178
  if (err != 0) {
    {
#line 179
    s = err == -16 ? (char *)"status timeout" : (char *)"status error";
#line 180
    *startstop = ide_error(drive, (char const   *)s, (int )stat);
    }
  } else {

  }
#line 183
  return (err);
}
}
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
static char const   __kstrtab_ide_wait_stat[14U]  = 
#line 185
  {      'i',      'd',      'e',      '_', 
        'w',      'a',      'i',      't', 
        '_',      's',      't',      'a', 
        't',      '\000'};
#line 185
struct kernel_symbol  const  __ksymtab_ide_wait_stat ;
#line 185 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
struct kernel_symbol  const  __ksymtab_ide_wait_stat  =    {(unsigned long )(& ide_wait_stat), (char const   *)(& __kstrtab_ide_wait_stat)};
#line 196 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
int ide_in_drive_list(u16 *id , struct drive_list_entry  const  *table ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
#line 198
  goto ldv_39242;
  ldv_39241: 
  {
#line 199
  tmp = strcmp(table->id_model, (char const   *)id + 27U);
  }
#line 199
  if (tmp == 0) {
#line 199
    if ((unsigned long )table->id_firmware == (unsigned long )((char const   */* const  */)0)) {
#line 202
      return (1);
    } else {
      {
#line 199
      tmp___0 = strstr((char const   *)id + 23U, table->id_firmware);
      }
#line 199
      if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
#line 202
        return (1);
      } else {

      }
    }
  } else {

  }
#line 198
  table = table + 1;
  ldv_39242: ;
#line 198
  if ((unsigned long )table->id_model != (unsigned long )((char const   */* const  */)0)) {
#line 200
    goto ldv_39241;
  } else {

  }

#line 203
  return (0);
}
}
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
static char const   __kstrtab_ide_in_drive_list[18U]  = 
#line 205
  {      'i',      'd',      'e',      '_', 
        'i',      'n',      '_',      'd', 
        'r',      'i',      'v',      'e', 
        '_',      'l',      'i',      's', 
        't',      '\000'};
#line 205
struct kernel_symbol  const  __ksymtab_ide_in_drive_list ;
#line 205 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
struct kernel_symbol  const  __ksymtab_ide_in_drive_list  =    {(unsigned long )(& ide_in_drive_list), (char const   *)(& __kstrtab_ide_in_drive_list)};
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
static struct drive_list_entry  const  ivb_list[10U]  = 
#line 211
  {      {"QUANTUM FIREBALLlct10 05", "A03.0900"}, 
        {"QUANTUM FIREBALLlct20 30", "APL.0900"}, 
        {"TSSTcorp CDDVDW SH-S202J", "SB00"}, 
        {"TSSTcorp CDDVDW SH-S202J", "SB01"}, 
        {"TSSTcorp CDDVDW SH-S202N", "SB00"}, 
        {"TSSTcorp CDDVDW SH-S202N", "SB01"}, 
        {"TSSTcorp CDDVDW SH-S202H", "SB00"}, 
        {"TSSTcorp CDDVDW SH-S202H", "SB01"}, 
        {"SAMSUNG SP0822N", "WA100-10"}, 
        {(char const   *)0, (char const   *)0}};
#line 228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
u8 eighty_ninty_three(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u16 *id ;
  int ivb ;
  int tmp ;
  bool tmp___0 ;
  char const   *model ;
  char *tmp___1 ;

  {
  {
#line 230
  hwif = drive->hwif;
#line 231
  id = drive->id;
#line 232
  tmp = ide_in_drive_list(id, (struct drive_list_entry  const  *)(& ivb_list));
#line 232
  ivb = tmp;
  }
#line 234
  if ((unsigned int )hwif->cbl == 6U || (unsigned int )hwif->cbl == 3U) {
#line 235
    return (1U);
  } else {

  }
#line 237
  if (ivb != 0) {
    {
#line 238
    printk("\017%s: skipping word 93 validity check\n", (char *)(& drive->name));
    }
  } else {

  }
  {
#line 241
  tmp___0 = ata_id_is_sata((u16 const   *)id);
  }
#line 241
  if ((int )tmp___0 && ivb == 0) {
#line 242
    return (1U);
  } else {

  }
#line 244
  if ((unsigned int )hwif->cbl != 2U && ivb == 0) {
#line 245
    goto no_80w;
  } else {

  }
#line 253
  if (((int )*(id + 93UL) & 16384) != 0) {
#line 254
    return (1U);
  } else {

  }
#line 256
  if (ivb != 0) {
    {
#line 257
    model = (char const   *)id + 27U;
#line 259
    tmp___1 = strstr(model, "TSSTcorp CDDVDW SH-S202");
    }
#line 259
    if ((unsigned long )tmp___1 != (unsigned long )((char *)0)) {
#line 264
      if ((unsigned int )hwif->cbl == 2U) {
#line 265
        return (1U);
      } else {

      }
    } else
#line 268
    if (((int )*(id + 93UL) & 8192) != 0) {
#line 269
      return (1U);
    } else {

    }
  } else {

  }
  no_80w: ;
#line 273
  if ((drive->dev_flags & 1048576UL) != 0UL) {
#line 274
    return (0U);
  } else {

  }
  {
#line 276
  printk("\f%s: %s side 80-wire cable detection failed, limiting max speed to UDMA33\n",
         (char *)(& drive->name), (unsigned int )hwif->cbl == 2U ? (char *)"drive" : (char *)"host");
#line 281
  drive->dev_flags = drive->dev_flags | 1048576UL;
  }
#line 283
  return (0U);
}
}
#line 286 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
static char const   *nien_quirk_list[10U]  = 
#line 286
  {      "QUANTUM FIREBALLlct08 08",      "QUANTUM FIREBALLP KA6.4",      "QUANTUM FIREBALLP KA9.1",      "QUANTUM FIREBALLP KX13.6", 
        "QUANTUM FIREBALLP KX20.5",      "QUANTUM FIREBALLP KX27.3",      "QUANTUM FIREBALLP LM20.4",      "QUANTUM FIREBALLP LM20.5", 
        "FUJITSU MHZ2160BH G2",      (char const   *)0};
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
void ide_check_nien_quirk_list(ide_drive_t *drive ) 
{ 
  char const   **list ;
  char const   *m ;
  char *tmp ;

  {
#line 301
  m = (char const   *)drive->id + 27U;
#line 303
  list = (char const   **)(& nien_quirk_list);
#line 303
  goto ldv_39268;
  ldv_39267: 
  {
#line 304
  tmp = strstr(m, *list);
  }
#line 304
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 305
    drive->dev_flags = drive->dev_flags | 0xffffffff80000000UL;
#line 306
    return;
  } else {

  }
#line 303
  list = list + 1;
  ldv_39268: ;
#line 303
  if ((unsigned long )*list != (unsigned long )((char const   *)0)) {
#line 305
    goto ldv_39267;
  } else {

  }

#line 310
  return;
}
}
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
int ide_driveid_update(ide_drive_t *drive ) 
{ 
  u16 *id ;
  int rc ;
  void *tmp ;

  {
  {
#line 315
  tmp = kmalloc(512UL, 32U);
#line 315
  id = (u16 *)tmp;
  }
#line 316
  if ((unsigned long )id == (unsigned long )((u16 *)0U)) {
#line 317
    return (0);
  } else {

  }
  {
#line 319
  SELECT_MASK(drive, 1);
#line 320
  rc = ide_dev_read_id(drive, 236, id, 1);
#line 321
  SELECT_MASK(drive, 0);
  }
#line 323
  if (rc != 0) {
#line 324
    goto out_err;
  } else {

  }
  {
#line 326
  *(drive->id + 88UL) = *(id + 88UL);
#line 327
  *(drive->id + 63UL) = *(id + 63UL);
#line 328
  *(drive->id + 62UL) = *(id + 62UL);
#line 329
  *(drive->id + 163UL) = *(id + 163UL);
#line 332
  kfree((void const   *)id);
  }
#line 334
  return (1);
  out_err: ;
#line 336
  if (rc == 2) {
    {
#line 337
    printk("\v%s: %s: bad status\n", (char *)(& drive->name), "ide_driveid_update");
    }
  } else {

  }
  {
#line 338
  kfree((void const   *)id);
  }
#line 339
  return (0);
}
}
#line 342 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
int ide_config_drive_speed(ide_drive_t *drive , u8 speed ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_tp_ops  const  *tp_ops ;
  struct ide_taskfile tf ;
  u16 *id ;
  u16 i ;
  int error ;
  u8 stat ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 344
  hwif = drive->hwif;
#line 345
  tp_ops = hwif->tp_ops;
#line 347
  id = drive->id;
#line 348
  error = 0;
#line 352
  if ((unsigned long )hwif->dma_ops != (unsigned long )((struct ide_dma_ops  const  *)0)) {
    {
#line 353
    (*((hwif->dma_ops)->dma_host_set))(drive, 0);
    }
  } else {

  }
#line 357
  if (((int )speed & 248) == 8 && ((int )*(drive->id + 49UL) & 2048) == 0) {
#line 358
    goto skip;
  } else {

  }
  {
#line 367
  __const_udelay(4295UL);
#line 368
  (*(tp_ops->dev_select))(drive);
#line 369
  SELECT_MASK(drive, 1);
#line 370
  __const_udelay(4295UL);
#line 371
  (*(tp_ops->write_devctl))(hwif, 10);
#line 373
  __memset((void *)(& tf), 0, 8UL);
#line 374
  tf.__annonCompField83.feature = 3U;
#line 375
  tf.nsect = speed;
#line 377
  (*(tp_ops->tf_load))(drive, & tf, 6);
#line 379
  (*(tp_ops->exec_command))(hwif, 239);
  }
#line 381
  if ((drive->dev_flags & 0xffffffff80000000UL) != 0UL) {
    {
#line 382
    (*(tp_ops->write_devctl))(hwif, 8);
    }
  } else {

  }
  {
#line 384
  error = __ide_wait_stat(drive, (int )drive->ready_stat, 137, 2500UL, & stat);
#line 388
  SELECT_MASK(drive, 0);
  }
#line 390
  if (error != 0) {
    {
#line 391
    ide_dump_status(drive, "set_drive_speed_status", (int )stat);
    }
#line 392
    return (error);
  } else {

  }
#line 395
  if ((unsigned int )speed > 15U) {
    {
#line 396
    *(id + 88UL) = (unsigned int )*(id + 88UL) & 255U;
#line 397
    *(id + 63UL) = (unsigned int )*(id + 63UL) & 63743U;
#line 398
    *(id + 62UL) = (unsigned int )*(id + 62UL) & 63743U;
#line 399
    tmp = ata_id_is_cfa((u16 const   *)id);
    }
#line 399
    if ((int )tmp) {
#line 400
      *(id + 163UL) = (unsigned int )*(id + 163UL) & 61951U;
    } else {

    }
  } else {
    {
#line 401
    tmp___0 = ata_id_is_cfa((u16 const   *)id);
    }
#line 401
    if ((int )tmp___0) {
#line 402
      *(id + 163UL) = (unsigned int )*(id + 163UL) & 65087U;
    } else {

    }
  }
  skip: ;
#line 406
  if ((unsigned int )speed > 15U && (drive->dev_flags & 2UL) != 0UL) {
    {
#line 407
    (*((hwif->dma_ops)->dma_host_set))(drive, 1);
    }
  } else
#line 408
  if ((unsigned long )hwif->dma_ops != (unsigned long )((struct ide_dma_ops  const  *)0)) {
    {
#line 409
    ide_dma_off_quietly(drive);
    }
  } else {

  }
#line 412
  if ((unsigned int )speed > 63U) {
#line 413
    i = (u16 )(1 << ((int )speed + -64));
#line 414
    *(id + 88UL) = (u16 )((int )((short )*(id + 88UL)) | ((int )((short )((int )i << 8)) | (int )((short )i)));
  } else {
    {
#line 415
    tmp___2 = ata_id_is_cfa((u16 const   *)id);
    }
#line 415
    if ((int )tmp___2 && (unsigned int )speed > 34U) {
#line 416
      i = (unsigned int )((u16 )speed) + 65502U;
#line 417
      *(id + 163UL) = (u16 )((int )((short )*(id + 163UL)) | (int )((short )((int )i << 9)));
    } else
#line 418
    if ((unsigned int )speed > 31U) {
#line 419
      i = (u16 )(1 << ((int )speed + -32));
#line 420
      *(id + 63UL) = (u16 )((int )((short )*(id + 63UL)) | ((int )((short )((int )i << 8)) | (int )((short )i)));
    } else
#line 421
    if ((unsigned int )speed > 15U) {
#line 422
      i = (u16 )(1 << ((int )speed + -16));
#line 423
      *(id + 62UL) = (u16 )((int )((short )*(id + 62UL)) | ((int )((short )((int )i << 8)) | (int )((short )i)));
    } else {
      {
#line 424
      tmp___1 = ata_id_is_cfa((u16 const   *)id);
      }
#line 424
      if ((int )tmp___1 && (unsigned int )speed > 12U) {
#line 425
        i = (unsigned int )((u16 )speed) + 65524U;
#line 426
        *(id + 163UL) = (u16 )((int )((short )*(id + 163UL)) | (int )((short )((int )i << 6)));
      } else {

      }
    }
  }
#line 429
  if ((unsigned int )drive->init_speed == 0U) {
#line 430
    drive->init_speed = speed;
  } else {

  }
#line 431
  drive->current_speed = speed;
#line 432
  return (error);
}
}
#line 444 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
void __ide_set_handler(ide_drive_t *drive , ide_handler_t *handler , unsigned int timeout ) 
{ 
  ide_hwif_t *hwif ;
  long tmp ;

  {
  {
#line 447
  hwif = drive->hwif;
#line 449
  tmp = __builtin_expect((unsigned long )hwif->handler != (unsigned long )((ide_startstop_t (*)(ide_drive_t * ))0),
                         0L);
  }
#line 449
  if (tmp != 0L) {
    {
#line 449
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-iops.c"),
                         "i" (449), "i" (12UL));
#line 449
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 450
  hwif->handler = handler;
#line 451
  hwif->timer.expires = (unsigned long )jiffies + (unsigned long )timeout;
#line 452
  hwif->req_gen_timer = hwif->req_gen;
#line 453
  add_timer(& hwif->timer);
  }
#line 454
  return;
}
}
#line 456 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
void ide_set_handler(ide_drive_t *drive , ide_handler_t *handler , unsigned int timeout ) 
{ 
  ide_hwif_t *hwif ;
  unsigned long flags ;

  {
  {
#line 459
  hwif = drive->hwif;
#line 462
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___0(& hwif->lock);
#line 463
  __ide_set_handler(drive, handler, timeout);
#line 464
  ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
  }
#line 465
  return;
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
static char const   __kstrtab_ide_set_handler[16U]  = 
#line 466
  {      'i',      'd',      'e',      '_', 
        's',      'e',      't',      '_', 
        'h',      'a',      'n',      'd', 
        'l',      'e',      'r',      '\000'};
#line 466
struct kernel_symbol  const  __ksymtab_ide_set_handler ;
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
struct kernel_symbol  const  __ksymtab_ide_set_handler  =    {(unsigned long )(& ide_set_handler), (char const   *)(& __kstrtab_ide_set_handler)};
#line 481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
void ide_execute_command(ide_drive_t *drive , struct ide_cmd *cmd , ide_handler_t *handler ,
                         unsigned int timeout ) 
{ 
  ide_hwif_t *hwif ;
  unsigned long flags ;

  {
  {
#line 484
  hwif = drive->hwif;
#line 487
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_98(& hwif->lock);
  }
#line 488
  if ((unsigned int )cmd->protocol - 6U > 1U || (int )drive->atapi_flags & 1) {
    {
#line 491
    __ide_set_handler(drive, handler, timeout);
    }
  } else {

  }
  {
#line 492
  (*((hwif->tp_ops)->exec_command))(hwif, (int )cmd->tf.__annonCompField84.command);
#line 499
  __const_udelay(2000UL);
#line 500
  ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
  }
#line 501
  return;
}
}
#line 507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-iops.c"
int ide_wait_not_busy(ide_hwif_t *hwif , unsigned long timeout ) 
{ 
  u8 stat ;
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 509
  stat = 0U;
#line 511
  goto ldv_39329;
  ldv_39328: ;
#line 516
  if (1) {
    {
#line 516
    __const_udelay(4295000UL);
    }
  } else {
#line 516
    __ms = 1UL;
#line 516
    goto ldv_39326;
    ldv_39325: 
    {
#line 516
    __const_udelay(4295000UL);
    }
    ldv_39326: 
#line 516
    tmp = __ms;
#line 516
    __ms = __ms - 1UL;
#line 516
    if (tmp != 0UL) {
#line 518
      goto ldv_39325;
    } else {

    }

  }
  {
#line 517
  stat = (*((hwif->tp_ops)->read_status))(hwif);
  }
#line 518
  if ((int )((signed char )stat) >= 0) {
#line 519
    return (0);
  } else {

  }
#line 525
  if ((unsigned int )stat == 255U) {
#line 526
    return (-19);
  } else {

  }
  {
#line 527
  touch_softlockup_watchdog();
#line 528
  touch_nmi_watchdog();
  }
  ldv_39329: 
#line 511
  tmp___0 = timeout;
#line 511
  timeout = timeout - 1UL;
#line 511
  if (tmp___0 != 0UL) {
#line 513
    goto ldv_39328;
  } else {

  }

#line 530
  return (-16);
}
}
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-iops.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___0(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1330
  ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s();
#line 1332
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1333
  return;
}
}
#line 1343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-iops.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_98(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1346
  ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s();
#line 1348
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1349
  return;
}
}
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
extern struct dma_map_ops *dma_ops ;
#line 1005 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
extern void blk_queue_bounce_limit(struct request_queue * , u64  ) ;
#line 1454 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void ide_toggle_bounce(ide_drive_t *drive , int on ) ;
#line 1456
u64 ide_get_lba_addr(struct ide_cmd *cmd , int lba48 ) ;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
void ide_toggle_bounce(ide_drive_t *drive , int on ) 
{ 
  u64 addr ;
  struct device *dev ;

  {
#line 20
  addr = 0xffffffffffffffffULL;
#line 22
  if (dma_ops->is_phys == 0) {
#line 23
    addr = 0xffffffffffffffffULL;
  } else
#line 24
  if (on != 0 && (unsigned int )drive->media == 32U) {
#line 25
    dev = (drive->hwif)->dev;
#line 27
    if ((unsigned long )dev != (unsigned long )((struct device *)0) && (unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL)) {
#line 28
      addr = *(dev->dma_mask);
    } else {

    }
  } else {

  }
#line 31
  if ((unsigned long )drive->queue != (unsigned long )((struct request_queue *)0)) {
    {
#line 32
    blk_queue_bounce_limit(drive->queue, addr);
    }
  } else {

  }
#line 33
  return;
}
}
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
u64 ide_get_lba_addr(struct ide_cmd *cmd , int lba48 ) 
{ 
  struct ide_taskfile *tf ;
  u32 high ;
  u32 low ;

  {
#line 37
  tf = & cmd->tf;
#line 40
  low = (u32 )((((int )tf->lbah << 16) | ((int )tf->lbam << 8)) | (int )tf->lbal);
#line 41
  if (lba48 != 0) {
#line 42
    tf = & cmd->hob;
#line 43
    high = (u32 )((((int )tf->lbah << 16) | ((int )tf->lbam << 8)) | (int )tf->lbal);
  } else {
#line 45
    high = (u32 )tf->device & 15U;
  }
#line 47
  return (((unsigned long long )high << 24) | (unsigned long long )low);
}
}
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
static char const   __kstrtab_ide_get_lba_addr[17U]  = 
#line 49
  {      'i',      'd',      'e',      '_', 
        'g',      'e',      't',      '_', 
        'l',      'b',      'a',      '_', 
        'a',      'd',      'd',      'r', 
        '\000'};
#line 49
struct kernel_symbol  const  __ksymtab_ide_get_lba_addr ;
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
struct kernel_symbol  const  __ksymtab_ide_get_lba_addr  =    {(unsigned long )(& ide_get_lba_addr), (char const   *)(& __kstrtab_ide_get_lba_addr)};
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
static void ide_dump_sector(ide_drive_t *drive ) 
{ 
  struct ide_cmd cmd ;
  struct ide_taskfile *tf ;
  u8 lba48 ;
  u64 tmp ;

  {
  {
#line 54
  tf = & cmd.tf;
#line 55
  lba48 = (drive->dev_flags & 2097152UL) != 0UL;
#line 57
  __memset((void *)(& cmd), 0, 80UL);
  }
#line 58
  if ((unsigned int )lba48 != 0U) {
#line 59
    cmd.valid.in.tf = 56U;
#line 60
    cmd.valid.in.hob = 56U;
#line 61
    cmd.tf_flags = 1U;
  } else {
#line 63
    cmd.valid.in.tf = 120U;
  }
  {
#line 65
  ide_tf_readback(drive, & cmd);
  }
#line 67
  if ((unsigned int )lba48 != 0U || ((int )tf->device & 64) != 0) {
    {
#line 68
    tmp = ide_get_lba_addr(& cmd, (int )lba48);
#line 68
    printk(", LBAsect=%llu", tmp);
    }
  } else {
    {
#line 71
    printk(", CHS=%d/%d/%d", ((int )tf->lbah << 8) + (int )tf->lbam, (int )tf->device & 15,
           (int )tf->lbal);
    }
  }
#line 73
  return;
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
static void ide_dump_ata_error(ide_drive_t *drive , u8 err ) 
{ 
  struct request *rq ;
  sector_t tmp ;

  {
  {
#line 77
  printk("{ ");
  }
#line 78
  if (((int )err & 4) != 0) {
    {
#line 79
    printk("DriveStatusError ");
    }
  } else {

  }
#line 80
  if ((int )((signed char )err) < 0) {
    {
#line 81
    printk("%s", ((int )err & 4) != 0 ? (char *)"BadCRC " : (char *)"BadSector ");
    }
  } else {

  }
#line 83
  if (((int )err & 64) != 0) {
    {
#line 84
    printk("UncorrectableError ");
    }
  } else {

  }
#line 85
  if (((int )err & 16) != 0) {
    {
#line 86
    printk("SectorIdNotFound ");
    }
  } else {

  }
#line 87
  if (((int )err & 2) != 0) {
    {
#line 88
    printk("TrackZeroNotFound ");
    }
  } else {

  }
#line 89
  if ((int )err & 1) {
    {
#line 90
    printk("AddrMarkNotFound ");
    }
  } else {

  }
  {
#line 91
  printk("}");
  }
#line 92
  if (((int )err & 132) == 128 || ((int )err & 81) != 0) {
    {
#line 94
    rq = (drive->hwif)->rq;
#line 96
    ide_dump_sector(drive);
    }
#line 98
    if ((unsigned long )rq != (unsigned long )((struct request *)0)) {
      {
#line 99
      tmp = blk_rq_pos((struct request  const  *)rq);
#line 99
      printk(", sector=%llu", (unsigned long long )tmp);
      }
    } else {

    }
  } else {

  }
  {
#line 102
  printk("\n");
  }
#line 103
  return;
}
}
#line 105 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
static void ide_dump_atapi_error(ide_drive_t *drive , u8 err ) 
{ 


  {
  {
#line 107
  printk("{ ");
  }
#line 108
  if ((int )err & 1) {
    {
#line 109
    printk("IllegalLengthIndication ");
    }
  } else {

  }
#line 110
  if (((int )err & 2) != 0) {
    {
#line 111
    printk("EndOfMedia ");
    }
  } else {

  }
#line 112
  if (((int )err & 4) != 0) {
    {
#line 113
    printk("AbortedCommand ");
    }
  } else {

  }
#line 114
  if (((int )err & 8) != 0) {
    {
#line 115
    printk("MediaChangeRequested ");
    }
  } else {

  }
#line 116
  if (((int )err & 240) != 0) {
    {
#line 117
    printk("LastFailedSense=0x%02x ", (int )err >> 4);
    }
  } else {

  }
  {
#line 119
  printk("}\n");
  }
#line 120
  return;
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
u8 ide_dump_status(ide_drive_t *drive , char const   *msg , u8 stat ) 
{ 
  u8 err ;

  {
  {
#line 135
  err = 0U;
#line 137
  printk("\v%s: %s: status=0x%02x { ", (char *)(& drive->name), msg, (int )stat);
  }
#line 138
  if ((int )((signed char )stat) < 0) {
    {
#line 139
    printk("Busy ");
    }
  } else {
#line 141
    if (((int )stat & 64) != 0) {
      {
#line 142
      printk("DriveReady ");
      }
    } else {

    }
#line 143
    if (((int )stat & 32) != 0) {
      {
#line 144
      printk("DeviceFault ");
      }
    } else {

    }
#line 145
    if (((int )stat & 16) != 0) {
      {
#line 146
      printk("SeekComplete ");
      }
    } else {

    }
#line 147
    if (((int )stat & 8) != 0) {
      {
#line 148
      printk("DataRequest ");
      }
    } else {

    }
#line 149
    if (((int )stat & 4) != 0) {
      {
#line 150
      printk("CorrectedError ");
      }
    } else {

    }
#line 151
    if (((int )stat & 2) != 0) {
      {
#line 152
      printk("Index ");
      }
    } else {

    }
#line 153
    if ((int )stat & 1) {
      {
#line 154
      printk("Error ");
      }
    } else {

    }
  }
  {
#line 156
  printk("}\n");
  }
#line 157
  if (((int )stat & 129) == 1) {
    {
#line 158
    err = ide_read_error(drive);
#line 159
    printk("\v%s: %s: error=0x%02x ", (char *)(& drive->name), msg, (int )err);
    }
#line 160
    if ((unsigned int )drive->media == 32U) {
      {
#line 161
      ide_dump_ata_error(drive, (int )err);
      }
    } else {
      {
#line 163
      ide_dump_atapi_error(drive, (int )err);
      }
    }
  } else {

  }
  {
#line 166
  printk("\v%s: possibly failed opcode: 0x%02x\n", (char *)(& drive->name), (int )(drive->hwif)->cmd.tf.__annonCompField84.command);
  }
#line 169
  return (err);
}
}
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
static char const   __kstrtab_ide_dump_status[16U]  = 
#line 171
  {      'i',      'd',      'e',      '_', 
        'd',      'u',      'm',      'p', 
        '_',      's',      't',      'a', 
        't',      'u',      's',      '\000'};
#line 171
struct kernel_symbol  const  __ksymtab_ide_dump_status ;
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-lib.c"
struct kernel_symbol  const  __ksymtab_ide_dump_status  =    {(unsigned long )(& ide_dump_status), (char const   *)(& __kstrtab_ide_dump_status)};
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
void ldv_linux_kernel_sched_completion_init_completion_gendev_rel_comp_of_hwif_s(void) ;
#line 250
void ldv_linux_kernel_sched_completion_wait_for_completion_gendev_rel_comp_of_hwif_s(void) ;
#line 252
void ldv_linux_kernel_sched_completion_init_completion_gendev_rel_comp_of_ide_drive_s(void) ;
#line 253
void ldv_linux_kernel_sched_completion_wait_for_completion_gendev_rel_comp_of_ide_drive_s(void) ;
#line 41 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_zalloc_unknown_size(void) ;
#line 369 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_lock_96___0(struct mutex *ldv_func_arg1 ) ;
#line 373
static void ldv_mutex_lock_102(struct mutex *ldv_func_arg1 ) ;
#line 377
static void ldv_mutex_lock_104(struct mutex *ldv_func_arg1 ) ;
#line 381
static void ldv_mutex_lock_107(struct mutex *ldv_func_arg1 ) ;
#line 385
static void ldv_mutex_lock_109(struct mutex *ldv_func_arg1 ) ;
#line 400
void ldv_linux_kernel_locking_mutex_mutex_lock_ide_cfg_mtx(struct mutex *lock ) ;
#line 404
void ldv_linux_kernel_locking_mutex_mutex_unlock_ide_cfg_mtx(struct mutex *lock ) ;
#line 430
void ldv_linux_block_queue_blk_cleanup_queue(void) ;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/export.h"
extern struct module __this_module ;
#line 360 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static unsigned long ffz(unsigned long word ) 
{ 


  {
#line 362
  __asm__  ("rep; bsf %1,%0": "=r" (word): "r" (~ word));
#line 365
  return (word);
}
}
#line 389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern int sprintf(char * , char const   *  , ...) ;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/list.h"
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
#line 27
  list->next = list;
#line 28
  list->prev = list;
#line 29
  return;
}
}
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/percpu.h"
extern void __bad_percpu_size(void) ;
#line 65 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern char *strcpy(char * , char const   * ) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/string.h"
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
#line 822 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/paravirt.h"
__inline static unsigned long arch_local_irq_save(void) 
{ 
  unsigned long f ;

  {
  {
#line 826
  f = arch_local_save_flags();
#line 827
  arch_local_irq_disable();
  }
#line 828
  return (f);
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
static void ldv_mutex_unlock_97___0(struct mutex *ldv_func_arg1 ) ;
#line 197
static void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) ;
#line 201
static void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1 ) ;
#line 205
static void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) ;
#line 209
static void ldv_mutex_unlock_112(struct mutex *ldv_func_arg1 ) ;
#line 8 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
extern int __preempt_count ;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;

  {
  {
#line 22
  if (4UL == 1UL) {
#line 22
    goto case_1;
  } else {

  }
#line 22
  if (4UL == 2UL) {
#line 22
    goto case_2;
  } else {

  }
#line 22
  if (4UL == 4UL) {
#line 22
    goto case_4;
  } else {

  }
#line 22
  if (4UL == 8UL) {
#line 22
    goto case_8;
  } else {

  }
#line 22
  goto switch_default;
  case_1: /* CIL Label */ 
#line 22
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_7274;
  case_2: /* CIL Label */ 
#line 22
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_7274;
  case_4: /* CIL Label */ 
#line 22
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_7274;
  case_8: /* CIL Label */ 
#line 22
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
#line 22
  goto ldv_7274;
  switch_default: /* CIL Label */ 
  {
#line 22
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7274: ;
#line 22
  return (pfo_ret__ & 2147483647);
}
}
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
#line 301
  return (& lock->__annonCompField18.rlock);
}
}
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/completion.h"
__inline static void ldv_init_completion_100(struct completion *x ) ;
#line 93
__inline static void ldv_init_completion_101(struct completion *x ) ;
#line 99
extern void wait_for_completion(struct completion * ) ;
#line 102
static void ldv_wait_for_completion_106(struct completion *ldv_func_arg1 ) ;
#line 106
static void ldv_wait_for_completion_111(struct completion *ldv_func_arg1 ) ;
#line 122
extern void complete(struct completion * ) ;
#line 94 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
#line 819 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
extern int dev_set_name(struct device * , char const   *  , ...) ;
#line 822 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static int dev_to_node(struct device *dev ) 
{ 


  {
#line 824
  return (dev->numa_node);
}
}
#line 845 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 847
  dev->driver_data = data;
#line 848
  return;
}
}
#line 924
extern int device_register(struct device * ) ;
#line 925
extern void device_unregister(struct device * ) ;
#line 987
extern struct device *device_create(struct class * , struct device * , dev_t  , void * ,
                                    char const   *  , ...) ;
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 600
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) ;
#line 226 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
extern void sg_init_table(struct scatterlist * , unsigned int  ) ;
#line 2193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
extern int register_blkdev(unsigned int  , char const   * ) ;
#line 2194
extern void unregister_blkdev(unsigned int  , char const   * ) ;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kmod.h"
extern int __request_module(bool  , char const   *  , ...) ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
#line 128 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/interrupt.h"
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
  {
#line 131
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
  }
#line 131
  return (tmp);
}
}
#line 137
__inline static int ldv_request_irq_98(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
#line 146
extern void free_irq(unsigned int  , void * ) ;
#line 149
static void ldv_free_irq_110(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
#line 620 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/genhd.h"
extern struct kobject *get_disk(struct gendisk * ) ;
#line 622
extern void blk_register_region(dev_t  , unsigned long  , struct module * , struct kobject *(*)(dev_t  ,
                                                                                                int * ,
                                                                                                void * ) ,
                                int (*)(dev_t  , void * ) , void * ) ;
#line 627
extern void blk_unregister_region(dev_t  , unsigned long  ) ;
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/delay.h"
extern void msleep(unsigned int  ) ;
#line 712 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static unsigned int ata_id_major_version(u16 const   *id ) 
{ 
  unsigned int mver ;

  {
#line 716
  if ((unsigned int )((unsigned short )*(id + 80UL)) == 65535U) {
#line 717
    return (0U);
  } else {

  }
#line 719
  mver = 14U;
#line 719
  goto ldv_34621;
  ldv_34620: ;
#line 720
  if (((int )*(id + 80UL) >> (int )mver) & 1) {
#line 721
    goto ldv_34619;
  } else {

  }
#line 719
  mver = mver - 1U;
  ldv_34621: ;
#line 719
  if (mver != 0U) {
#line 721
    goto ldv_34620;
  } else {

  }
  ldv_34619: ;
#line 722
  return (mver);
}
}
#line 756 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_has_unload(u16 const   *id ) 
{ 
  unsigned int tmp ;

  {
  {
#line 758
  tmp = ata_id_major_version(id);
  }
#line 758
  if (tmp > 6U && ((unsigned int )*(id + 84UL) & 57344U) == 24576U) {
#line 761
    return (1);
  } else {

  }
#line 762
  return (0);
}
}
#line 821 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_current_chs_valid(u16 const   *id ) 
{ 


  {
#line 826
  return ((bool )(((((int )*(id + 53UL) & 1 && (unsigned int )((unsigned short )*(id + 54UL)) != 0U) && (unsigned int )((unsigned short )*(id + 55UL)) != 0U) && (unsigned int )((unsigned short )*(id + 55UL)) <= 16U) && (unsigned int )((unsigned short )*(id + 56UL)) != 0U));
}
}
#line 998 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
extern struct request_queue *blk_init_queue_node(request_fn_proc * , spinlock_t * ,
                                                 int  ) ;
#line 1003
extern void blk_cleanup_queue(struct request_queue * ) ;
#line 1006
static void ldv_blk_cleanup_queue_99(struct request_queue *ldv_func_arg1 ) ;
#line 1011
extern void blk_queue_max_hw_sectors(struct request_queue * , unsigned int  ) ;
#line 1013
extern void blk_queue_max_segments(struct request_queue * , unsigned short  ) ;
#line 1042
extern void blk_queue_segment_boundary(struct request_queue * , unsigned long  ) ;
#line 601 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_tp_ops  const  default_tp_ops ;
#line 925
void ide_proc_register_port(ide_hwif_t *hwif ) ;
#line 926
void ide_proc_port_register_devices(ide_hwif_t *hwif ) ;
#line 927
void ide_proc_unregister_device(ide_drive_t *drive ) ;
#line 928
void ide_proc_unregister_port(ide_hwif_t *hwif ) ;
#line 1063
int ide_busy_sleep(ide_drive_t *drive , unsigned long timeout , int altstatus ) ;
#line 1170
void ide_init_disk(struct gendisk *disk , ide_drive_t *drive ) ;
#line 1194
int ide_hwif_setup_dma(ide_hwif_t *hwif , struct ide_port_info  const  *d ) ;
#line 1357
int ide_set_dma(ide_drive_t *drive ) ;
#line 1362
void ide_release_dma_engine(ide_hwif_t *hwif ) ;
#line 1409
void ide_acpi_init_port(ide_hwif_t *hwif ) ;
#line 1410
void ide_acpi_port_init_devices(ide_hwif_t *hwif ) ;
#line 1423
void ide_register_region(struct gendisk *disk ) ;
#line 1424
void ide_unregister_region(struct gendisk *disk ) ;
#line 1427
void ide_undecoded_slave(ide_drive_t *dev1 ) ;
#line 1430
int ide_sysfs_register_port(ide_hwif_t *hwif ) ;
#line 1432
struct ide_host *ide_host_alloc(struct ide_port_info  const  *d , struct ide_hw **hws ,
                                unsigned int n_ports ) ;
#line 1434
void ide_host_free(struct ide_host *host ) ;
#line 1435
int ide_host_register(struct ide_host *host , struct ide_port_info  const  *d , struct ide_hw **hws ) ;
#line 1437
int ide_host_add(struct ide_port_info  const  *d , struct ide_hw **hws , unsigned int n_ports ,
                 struct ide_host **hostp ) ;
#line 1439
void ide_host_remove(struct ide_host *host ) ;
#line 1441
void ide_port_unregister_devices(ide_hwif_t *hwif ) ;
#line 1442
void ide_port_scan(ide_hwif_t *hwif ) ;
#line 1499
void ide_set_pio(ide_drive_t *drive , u8 req_pio ) ;
#line 1506 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
__inline static void ide_set_max_pio(ide_drive_t *drive ) 
{ 


  {
  {
#line 1508
  ide_set_pio(drive, 255);
  }
#line 1509
  return;
}
}
#line 1522 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
__inline static int hwif_to_node(ide_hwif_t *hwif ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1524
  if ((unsigned long )hwif->dev != (unsigned long )((struct device *)0)) {
    {
#line 1524
    tmp = dev_to_node(hwif->dev);
#line 1524
    tmp___0 = tmp;
    }
  } else {
#line 1524
    tmp___0 = -1;
  }
#line 1524
  return (tmp___0);
}
}
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void generic_id(ide_drive_t *drive ) 
{ 
  u16 *id ;
  u16 tmp ;
  u16 tmp___0 ;
  u16 tmp___1 ;

  {
#line 53
  id = drive->id;
#line 55
  tmp = (u16 )drive->cyl;
#line 55
  *(id + 1UL) = tmp;
#line 55
  *(id + 54UL) = tmp;
#line 56
  tmp___0 = (u16 )drive->head;
#line 56
  *(id + 3UL) = tmp___0;
#line 56
  *(id + 55UL) = tmp___0;
#line 57
  tmp___1 = (u16 )drive->sect;
#line 57
  *(id + 6UL) = tmp___1;
#line 57
  *(id + 56UL) = tmp___1;
#line 58
  return;
}
}
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_disk_init_chs(ide_drive_t *drive ) 
{ 
  u16 *id ;
  unsigned int tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  bool tmp___2 ;

  {
#line 62
  id = drive->id;
#line 65
  if ((drive->cyl == 0U || (unsigned int )drive->head == 0U) || (unsigned int )drive->sect == 0U) {
#line 66
    tmp = (unsigned int )*(id + 1UL);
#line 66
    drive->bios_cyl = tmp;
#line 66
    drive->cyl = tmp;
#line 67
    tmp___0 = (u8 )*(id + 3UL);
#line 67
    drive->bios_head = tmp___0;
#line 67
    drive->head = tmp___0;
#line 68
    tmp___1 = (u8 )*(id + 6UL);
#line 68
    drive->bios_sect = tmp___1;
#line 68
    drive->sect = tmp___1;
  } else {

  }
  {
#line 72
  tmp___2 = ata_id_current_chs_valid((u16 const   *)id);
  }
#line 72
  if ((int )tmp___2) {
#line 73
    drive->cyl = (unsigned int )*(id + 54UL);
#line 74
    drive->head = (u8 )*(id + 55UL);
#line 75
    drive->sect = (u8 )*(id + 56UL);
  } else {

  }
#line 79
  if (((unsigned int )drive->head > 16U && (unsigned int )*(id + 3UL) != 0U) && (unsigned int )*(id + 3UL) <= 16U) {
#line 80
    drive->cyl = (unsigned int )*(id + 1UL);
#line 81
    drive->head = (u8 )*(id + 3UL);
#line 82
    drive->sect = (u8 )*(id + 6UL);
  } else {

  }
#line 84
  return;
}
}
#line 86 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_disk_init_mult_count(ide_drive_t *drive ) 
{ 
  u16 *id ;
  u8 max_multsect ;

  {
#line 88
  id = drive->id;
#line 89
  max_multsect = (u8 )*(id + 47UL);
#line 91
  if ((unsigned int )max_multsect != 0U) {
#line 92
    if ((unsigned int )max_multsect > 3U) {
#line 93
      *(id + 59UL) = (unsigned int )((u16 )max_multsect) | 256U;
    } else {
#line 95
      *(id + 59UL) = (unsigned int )*(id + 59UL) & 65024U;
    }
#line 97
    drive->mult_req = (u8 )*(id + 59UL);
#line 99
    if ((unsigned int )drive->mult_req != 0U) {
#line 100
      drive->special_flags = (u8 )((unsigned int )drive->special_flags | 4U);
    } else {

    }
  } else {

  }
#line 102
  return;
}
}
#line 104 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_classify_ata_dev(ide_drive_t *drive ) 
{ 
  u16 *id ;
  char *m ;
  int is_cfa ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 106
  id = drive->id;
#line 107
  m = (char *)id + 27U;
#line 108
  tmp = ata_id_is_cfa((u16 const   *)id);
#line 108
  is_cfa = (int )tmp;
  }
#line 111
  if (is_cfa == 0 && ((int )*id & 128) != 0) {
#line 112
    drive->dev_flags = drive->dev_flags | 1024UL;
  } else {

  }
  {
#line 114
  drive->media = 32U;
#line 116
  tmp___0 = ata_id_has_unload((u16 const   *)drive->id);
  }
#line 116
  if (tmp___0) {
#line 116
    tmp___1 = 0;
  } else {
#line 116
    tmp___1 = 1;
  }
#line 116
  if (tmp___1) {
#line 117
    drive->dev_flags = drive->dev_flags | 67108864UL;
  } else {

  }
  {
#line 119
  printk("\016%s: %s, %s DISK drive\n", (char *)(& drive->name), m, is_cfa != 0 ? (char *)"CFA" : (char *)"ATA");
  }
#line 121
  return;
}
}
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_classify_atapi_dev(ide_drive_t *drive ) 
{ 
  u16 *id ;
  char *m ;
  u8 type ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 125
  id = drive->id;
#line 126
  m = (char *)id + 27U;
#line 127
  type = (unsigned int )((u8 )((int )*id >> 8)) & 31U;
#line 129
  printk("\016%s: %s, ATAPI ", (char *)(& drive->name), m);
  }
  {
#line 131
  if ((int )type == 0) {
#line 131
    goto case_0;
  } else {

  }
#line 145
  if ((int )type == 5) {
#line 145
    goto case_5;
  } else {

  }
#line 157
  if ((int )type == 1) {
#line 157
    goto case_1;
  } else {

  }
#line 160
  if ((int )type == 7) {
#line 160
    goto case_7;
  } else {

  }
#line 164
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 132
  tmp___2 = strstr((char const   *)m, "CD-ROM");
  }
#line 132
  if ((unsigned long )tmp___2 == (unsigned long )((char *)0)) {
    {
#line 133
    tmp = strstr((char const   *)m, "oppy");
    }
#line 133
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
      {
#line 133
      tmp___0 = strstr((char const   *)m, "poyp");
      }
#line 133
      if ((unsigned long )tmp___0 == (unsigned long )((char *)0)) {
        {
#line 133
        tmp___1 = strstr((char const   *)m, "ZIP");
        }
#line 133
        if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
          {
#line 136
          printk("cdrom or floppy?, assuming ");
          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 137
    if ((unsigned int )drive->media != 5U) {
      {
#line 138
      printk("FLOPPY");
#line 139
      drive->dev_flags = drive->dev_flags | 1024UL;
      }
#line 140
      goto ldv_39106;
    } else {

    }
  } else {

  }
#line 144
  type = 5U;
  case_5: /* CIL Label */ 
  {
#line 146
  drive->dev_flags = drive->dev_flags | 1024UL;
#line 155
  printk("CD/DVD-ROM");
  }
#line 156
  goto ldv_39106;
  case_1: /* CIL Label */ 
  {
#line 158
  printk("TAPE");
  }
#line 159
  goto ldv_39106;
  case_7: /* CIL Label */ 
  {
#line 161
  printk("OPTICAL");
#line 162
  drive->dev_flags = drive->dev_flags | 1024UL;
  }
#line 163
  goto ldv_39106;
  switch_default: /* CIL Label */ 
  {
#line 165
  printk("UNKNOWN (type %d)", (int )type);
  }
#line 166
  goto ldv_39106;
  switch_break: /* CIL Label */ ;
  }
  ldv_39106: 
  {
#line 169
  printk(" drive\n");
#line 170
  drive->media = type;
#line 172
  drive->ready_stat = 0U;
  }
#line 173
  if (((int )*id & 96) == 32) {
#line 174
    drive->atapi_flags = drive->atapi_flags | 1UL;
  } else {

  }
#line 175
  drive->dev_flags = drive->dev_flags | 32768UL;
#line 177
  drive->dev_flags = drive->dev_flags | 67108864UL;
#line 178
  return;
}
}
#line 191 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void do_identify(ide_drive_t *drive , u8 cmd , u16 *id ) 
{ 
  ide_hwif_t *hwif ;
  char *m ;
  unsigned long flags ;
  int bswap ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 193
  hwif = drive->hwif;
#line 194
  m = (char *)id + 27U;
#line 196
  bswap = 1;
#line 199
  flags = arch_local_irq_save();
#line 199
  trace_hardirqs_off();
#line 201
  (*((hwif->tp_ops)->input_data))(drive, (struct ide_cmd *)0, (void *)id, 512U);
#line 202
  tmp = arch_irqs_disabled_flags(flags);
  }
#line 202
  if (tmp != 0) {
    {
#line 202
    arch_local_irq_restore(flags);
#line 202
    trace_hardirqs_off();
    }
  } else {
    {
#line 202
    trace_hardirqs_on();
#line 202
    arch_local_irq_restore(flags);
    }
  }
  {
#line 204
  drive->dev_flags = drive->dev_flags | 256UL;
#line 209
  ide_fix_driveid(id);
  }
#line 215
  if ((unsigned int )cmd == 161U) {
#line 216
    if ((((int )((signed char )*m) == 78 && (int )((signed char )*(m + 1UL)) == 69) || ((int )((signed char )*m) == 70 && (int )((signed char )*(m + 1UL)) == 88)) || ((int )((signed char )*m) == 80 && (int )((signed char )*(m + 1UL)) == 105)) {
#line 220
      bswap = bswap ^ 1;
    } else {

    }
  } else {

  }
  {
#line 223
  ide_fixstring((u8 *)m, 40, bswap);
#line 224
  ide_fixstring((u8 *)id + 23U, 8, bswap);
#line 225
  ide_fixstring((u8 *)id + 10U, 20, bswap);
#line 228
  *(m + 39UL) = 0;
#line 230
  tmp___0 = strstr((char const   *)m, "E X A B Y T E N E S T");
  }
#line 230
  if ((unsigned long )tmp___0 != (unsigned long )((char *)0)) {
#line 231
    drive->dev_flags = drive->dev_flags & 0xffffffffffffffbfUL;
  } else {
#line 233
    drive->dev_flags = drive->dev_flags | 64UL;
  }
#line 234
  return;
}
}
#line 250 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
int ide_dev_read_id(ide_drive_t *drive , u8 cmd , u16 *id , int irq_ctx ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_io_ports *io_ports ;
  struct ide_tp_ops  const  *tp_ops ;
  int use_altstatus ;
  int rc ;
  unsigned long timeout ;
  u8 s ;
  u8 a ;
  unsigned long __ms ;
  unsigned long tmp ;
  struct ide_taskfile tf ;

  {
#line 252
  hwif = drive->hwif;
#line 253
  io_ports = & hwif->io_ports;
#line 254
  tp_ops = hwif->tp_ops;
#line 255
  use_altstatus = 0;
#line 257
  s = 0U;
#line 257
  a = 0U;
#line 263
  if (io_ports->ctl_addr != 0UL) {
    {
#line 264
    (*(tp_ops->write_devctl))(hwif, 10);
    }
  } else {

  }
#line 267
  if (irq_ctx != 0) {
#line 268
    __ms = 50UL;
#line 268
    goto ldv_39149;
    ldv_39148: 
    {
#line 268
    __const_udelay(4295000UL);
    }
    ldv_39149: 
#line 268
    tmp = __ms;
#line 268
    __ms = __ms - 1UL;
#line 268
    if (tmp != 0UL) {
#line 270
      goto ldv_39148;
    } else {

    }

  } else {
    {
#line 270
    msleep(50U);
    }
  }
#line 272
  if (io_ports->ctl_addr != 0UL && (hwif->host_flags & 67108864U) == 0U) {
    {
#line 274
    a = (*(tp_ops->read_altstatus))(hwif);
#line 275
    s = (*(tp_ops->read_status))(hwif);
    }
#line 276
    if ((((int )a ^ (int )s) & -3) != 0) {
      {
#line 278
      printk("\016%s: probing with STATUS(0x%02x) instead of ALTSTATUS(0x%02x)\n",
             (char *)(& drive->name), (int )s, (int )a);
      }
    } else {
#line 283
      use_altstatus = 1;
    }
  } else {

  }
#line 289
  if ((unsigned int )cmd == 161U) {
    {
#line 292
    __memset((void *)(& tf), 0, 8UL);
#line 294
    (*(tp_ops->tf_load))(drive, & tf, 2);
    }
  } else {

  }
  {
#line 298
  (*(tp_ops->exec_command))(hwif, (int )cmd);
#line 300
  timeout = (unsigned int )cmd == 236U ? 3750UL : 1250UL;
  }
#line 303
  if (irq_ctx != 0) {
    {
#line 304
    rc = __ide_wait_stat(drive, 8, 129, timeout, & s);
    }
#line 305
    if (rc != 0) {
#line 306
      return (1);
    } else {

    }
  } else {
    {
#line 308
    rc = ide_busy_sleep(drive, timeout, use_altstatus);
    }
#line 309
    if (rc != 0) {
#line 310
      return (1);
    } else {

    }
    {
#line 312
    msleep(50U);
#line 313
    s = (*(tp_ops->read_status))(hwif);
    }
  }
#line 316
  if (((int )s & 137) == 8) {
    {
#line 318
    do_identify(drive, (int )cmd, id);
#line 320
    rc = 0;
#line 322
    (*(tp_ops->read_status))(hwif);
    }
  } else {
#line 325
    rc = 2;
  }
#line 327
  return (rc);
}
}
#line 330 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
int ide_busy_sleep(ide_drive_t *drive , unsigned long timeout , int altstatus ) 
{ 
  ide_hwif_t *hwif ;
  u8 stat ;
  u8 tmp ;
  u8 tmp___0 ;

  {
#line 332
  hwif = drive->hwif;
#line 335
  timeout = timeout + (unsigned long )jiffies;
  ldv_39165: 
  {
#line 338
  msleep(50U);
  }
#line 339
  if (altstatus != 0) {
    {
#line 339
    tmp = (*((hwif->tp_ops)->read_altstatus))(hwif);
#line 339
    stat = tmp;
    }
  } else {
    {
#line 339
    tmp___0 = (*((hwif->tp_ops)->read_status))(hwif);
#line 339
    stat = tmp___0;
    }
  }
#line 341
  if ((int )((signed char )stat) >= 0) {
#line 342
    return (0);
  } else {

  }
#line 343
  if ((long )((unsigned long )jiffies - timeout) < 0L) {
#line 345
    goto ldv_39165;
  } else {

  }
  {
#line 345
  printk("\v%s: timeout in %s\n", (char *)(& drive->name), "ide_busy_sleep");
  }
#line 347
  return (1);
}
}
#line 350 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static u8 ide_read_device(ide_drive_t *drive ) 
{ 
  struct ide_taskfile tf ;

  {
  {
#line 354
  (*(((drive->hwif)->tp_ops)->tf_read))(drive, & tf, 64);
  }
#line 356
  return (tf.device);
}
}
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int do_probe(ide_drive_t *drive , u8 cmd ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_tp_ops  const  *tp_ops ;
  u16 *id ;
  int rc ;
  u8 present ;
  u8 stat ;
  u8 tmp ;

  {
#line 382
  hwif = drive->hwif;
#line 383
  tp_ops = hwif->tp_ops;
#line 384
  id = drive->id;
#line 386
  present = (drive->dev_flags & 64UL) != 0UL;
#line 389
  if ((unsigned int )present != 0U && ((unsigned int )drive->media != 32U && (unsigned int )cmd == 236U)) {
#line 390
    return (4);
  } else {

  }
  {
#line 401
  msleep(50U);
#line 402
  (*(tp_ops->dev_select))(drive);
#line 403
  msleep(50U);
#line 405
  tmp = ide_read_device(drive);
  }
#line 405
  if ((int )tmp != (int )drive->select && (unsigned int )present == 0U) {
#line 406
    if ((int )drive->dn & 1) {
      {
#line 408
      (*(tp_ops->dev_select))(hwif->devices[0]);
#line 410
      msleep(50U);
      }
    } else {

    }
#line 413
    return (3);
  } else {

  }
  {
#line 416
  stat = (*(tp_ops->read_status))(hwif);
  }
#line 418
  if ((((int )stat & 192) == 64 || (unsigned int )present != 0U) || (unsigned int )cmd == 161U) {
    {
#line 420
    rc = ide_dev_read_id(drive, (int )cmd, id, 0);
    }
#line 421
    if (rc != 0) {
      {
#line 423
      rc = ide_dev_read_id(drive, (int )cmd, id, 0);
      }
    } else {

    }
    {
#line 425
    stat = (*(tp_ops->read_status))(hwif);
    }
#line 427
    if ((unsigned int )stat == 192U) {
#line 428
      return (4);
    } else {

    }
#line 430
    if (rc == 1 && (unsigned int )cmd == 161U) {
      {
#line 431
      printk("\v%s: no response (status = 0x%02x), resetting drive\n", (char *)(& drive->name),
             (int )stat);
#line 433
      msleep(50U);
#line 434
      (*(tp_ops->dev_select))(drive);
#line 435
      msleep(50U);
#line 436
      (*(tp_ops->exec_command))(hwif, 8);
#line 437
      ide_busy_sleep(drive, 7500UL, 0);
#line 438
      rc = ide_dev_read_id(drive, (int )cmd, id, 0);
      }
    } else {

    }
    {
#line 442
    stat = (*(tp_ops->read_status))(hwif);
    }
#line 444
    if (rc == 1) {
      {
#line 445
      printk("\v%s: no response (status = 0x%02x)\n", (char *)(& drive->name), (int )stat);
      }
    } else {

    }
  } else {
#line 449
    rc = 3;
  }
#line 451
  if ((int )drive->dn & 1) {
    {
#line 453
    (*(tp_ops->dev_select))(hwif->devices[0]);
#line 454
    msleep(50U);
#line 456
    (*(tp_ops->read_status))(hwif);
    }
  } else {

  }
#line 458
  return (rc);
}
}
#line 473 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static u8 probe_for_drive(ide_drive_t *drive ) 
{ 
  char *m ;
  int rc ;
  u8 cmd ;

  {
  {
#line 479
  drive->dev_flags = drive->dev_flags & 0xfffffffffffffeffUL;
#line 481
  m = (char *)drive->id + 27U;
#line 482
  strcpy(m, "UNKNOWN");
  }
#line 485
  if ((drive->dev_flags & 512UL) == 0UL) {
    {
#line 487
    cmd = 236U;
#line 488
    rc = do_probe(drive, (int )cmd);
    }
#line 489
    if (rc > 1) {
      {
#line 491
      cmd = 161U;
#line 492
      rc = do_probe(drive, (int )cmd);
      }
    } else {

    }
#line 495
    if ((drive->dev_flags & 64UL) == 0UL) {
#line 496
      return (0U);
    } else {

    }
#line 499
    if ((drive->dev_flags & 256UL) == 0UL) {
#line 500
      if ((unsigned int )drive->media == 32U) {
        {
#line 501
        printk("\016%s: non-IDE drive, CHS=%d/%d/%d\n", (char *)(& drive->name), drive->cyl,
               (int )drive->head, (int )drive->sect);
        }
      } else
#line 504
      if ((unsigned int )drive->media == 5U) {
        {
#line 505
        printk("\016%s: ATAPI cdrom (?)\n", (char *)(& drive->name));
        }
      } else {
        {
#line 508
        printk("\f%s: Unknown device on bus refused identification. Ignoring.\n",
               (char *)(& drive->name));
#line 509
        drive->dev_flags = drive->dev_flags & 0xffffffffffffffbfUL;
        }
      }
    } else
#line 512
    if ((unsigned int )cmd == 161U) {
      {
#line 513
      ide_classify_atapi_dev(drive);
      }
    } else {
      {
#line 515
      ide_classify_ata_dev(drive);
      }
    }
  } else {

  }
#line 519
  if ((drive->dev_flags & 64UL) == 0UL) {
#line 520
    return (0U);
  } else {

  }
#line 523
  if ((drive->dev_flags & 256UL) == 0UL) {
    {
#line 524
    generic_id(drive);
    }
#line 525
    return (1U);
  } else {

  }
#line 528
  if ((unsigned int )drive->media == 32U) {
    {
#line 529
    ide_disk_init_chs(drive);
#line 530
    ide_disk_init_mult_count(drive);
    }
  } else {

  }
#line 533
  return (1U);
}
}
#line 536 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void hwif_release_dev(struct device *dev ) 
{ 
  ide_hwif_t *hwif ;
  struct device  const  *__mptr ;

  {
  {
#line 538
  __mptr = (struct device  const  *)dev;
#line 538
  hwif = (ide_hwif_t *)__mptr + 0xfffffffffffffe78UL;
#line 540
  complete(& hwif->gendev_rel_comp);
  }
#line 541
  return;
}
}
#line 543 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int ide_register_port(ide_hwif_t *hwif ) 
{ 
  int ret ;
  long tmp ;
  bool tmp___0 ;

  {
  {
#line 548
  dev_set_name(& hwif->gendev, "%s", (char *)(& hwif->name));
#line 549
  dev_set_drvdata(& hwif->gendev, (void *)hwif);
  }
#line 550
  if ((unsigned long )hwif->gendev.parent == (unsigned long )((struct device *)0)) {
#line 551
    hwif->gendev.parent = hwif->dev;
  } else {

  }
  {
#line 552
  hwif->gendev.release = & hwif_release_dev;
#line 554
  ret = device_register(& hwif->gendev);
  }
#line 555
  if (ret < 0) {
    {
#line 556
    printk("\fIDE: %s: device_register error: %d\n", "ide_register_port", ret);
    }
#line 558
    goto out;
  } else {

  }
  {
#line 561
  hwif->portdev = device_create(ide_port_class, & hwif->gendev, 0U, (void *)hwif,
                                "%s", (char *)(& hwif->name));
#line 563
  tmp___0 = IS_ERR((void const   *)hwif->portdev);
  }
#line 563
  if ((int )tmp___0) {
    {
#line 564
    tmp = PTR_ERR((void const   *)hwif->portdev);
#line 564
    ret = (int )tmp;
#line 565
    device_unregister(& hwif->gendev);
    }
  } else {

  }
  out: ;
#line 568
  return (ret);
}
}
#line 597 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int ide_port_wait_ready(ide_hwif_t *hwif ) 
{ 
  struct ide_tp_ops  const  *tp_ops ;
  ide_drive_t *drive ;
  int i ;
  int rc ;
  unsigned long __ms ;
  unsigned long tmp ;
  unsigned long __ms___0 ;
  unsigned long tmp___0 ;

  {
  {
#line 599
  tp_ops = hwif->tp_ops;
#line 603
  printk("\017Probing IDE interface %s...\n", (char *)(& hwif->name));
  }
#line 607
  if (1) {
    {
#line 607
    __const_udelay(8590000UL);
    }
  } else {
#line 607
    __ms = 2UL;
#line 607
    goto ldv_39209;
    ldv_39208: 
    {
#line 607
    __const_udelay(4295000UL);
    }
    ldv_39209: 
#line 607
    tmp = __ms;
#line 607
    __ms = __ms - 1UL;
#line 607
    if (tmp != 0UL) {
#line 609
      goto ldv_39208;
    } else {

    }

  }
  {
#line 613
  rc = ide_wait_not_busy(hwif, 35000UL);
  }
#line 614
  if (rc != 0) {
#line 615
    return (rc);
  } else {

  }
#line 618
  i = 0;
#line 618
  goto ldv_39217;
  ldv_39216: ;
#line 620
  if (*((unsigned long *)drive + 10UL) != 512UL) {
    {
#line 622
    (*(tp_ops->dev_select))(drive);
#line 623
    (*(tp_ops->write_devctl))(hwif, 8);
    }
#line 624
    if (1) {
      {
#line 624
      __const_udelay(8590000UL);
      }
    } else {
#line 624
      __ms___0 = 2UL;
#line 624
      goto ldv_39213;
      ldv_39212: 
      {
#line 624
      __const_udelay(4295000UL);
      }
      ldv_39213: 
#line 624
      tmp___0 = __ms___0;
#line 624
      __ms___0 = __ms___0 - 1UL;
#line 624
      if (tmp___0 != 0UL) {
#line 626
        goto ldv_39212;
      } else {

      }

    }
    {
#line 625
    rc = ide_wait_not_busy(hwif, 35000UL);
    }
#line 626
    if (rc != 0) {
#line 627
      goto out;
    } else {

    }
  } else {
    {
#line 629
    printk("\017%s: ide_wait_not_busy() skipped\n", (char *)(& drive->name));
    }
  }
#line 618
  i = i + 1;
  ldv_39217: 
#line 618
  drive = hwif->devices[i];
#line 618
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 620
    goto ldv_39216;
  } else {

  }

  out: ;
#line 634
  if (i != 0) {
    {
#line 635
    (*(tp_ops->dev_select))(hwif->devices[0]);
    }
  } else {

  }
#line 637
  return (rc);
}
}
#line 649 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
void ide_undecoded_slave(ide_drive_t *dev1 ) 
{ 
  ide_drive_t *dev0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 651
  dev0 = (dev1->hwif)->devices[0];
#line 653
  if (((int )dev1->dn & 1) == 0 || (dev0->dev_flags & 64UL) == 0UL) {
#line 654
    return;
  } else {

  }
  {
#line 657
  tmp = strcmp((char const   *)dev0->id + 27U, (char const   *)dev1->id + 27U);
  }
#line 657
  if (tmp != 0) {
#line 659
    return;
  } else {

  }
  {
#line 662
  tmp___0 = strncmp((char const   *)dev0->id + 10U, (char const   *)dev1->id + 10U,
                    20UL);
  }
#line 662
  if (tmp___0 != 0) {
#line 664
    return;
  } else {

  }
#line 667
  if ((int )((signed char )*((char *)dev0->id + 10U)) == 0) {
#line 668
    return;
  } else {

  }
  {
#line 671
  printk("\fide-probe: ignoring undecoded slave\n");
#line 673
  dev1->dev_flags = dev1->dev_flags & 0xffffffffffffffbfUL;
  }
#line 674
  return;
}
}
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_undecoded_slave[20U]  = 
#line 676
  {      'i',      'd',      'e',      '_', 
        'u',      'n',      'd',      'e', 
        'c',      'o',      'd',      'e', 
        'd',      '_',      's',      'l', 
        'a',      'v',      'e',      '\000'};
#line 676
struct kernel_symbol  const  __ksymtab_ide_undecoded_slave ;
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_undecoded_slave  =    {(unsigned long )(& ide_undecoded_slave), (char const   *)(& __kstrtab_ide_undecoded_slave)};
#line 678 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int ide_probe_port(ide_hwif_t *hwif ) 
{ 
  ide_drive_t *drive ;
  unsigned int irqd ;
  int i ;
  int rc ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 682
  rc = -19;
#line 684
  tmp = __builtin_expect((long )*((unsigned char *)hwif + 388UL) & 1L, 0L);
  }
#line 684
  if (tmp != 0L) {
    {
#line 684
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-probe.c"),
                         "i" (684), "i" (12UL));
#line 684
    __builtin_unreachable();
    }
  } else {

  }
#line 686
  if (((hwif->devices[0])->dev_flags & 512UL) != 0UL && ((hwif->devices[1])->dev_flags & 512UL) != 0UL) {
#line 688
    return (-13);
  } else {

  }
#line 694
  irqd = (unsigned int )hwif->irq;
#line 695
  if (irqd != 0U) {
    {
#line 696
    disable_irq((unsigned int )hwif->irq);
    }
  } else {

  }
  {
#line 698
  tmp___0 = ide_port_wait_ready(hwif);
  }
#line 698
  if (tmp___0 == -16) {
    {
#line 699
    printk("\017%s: Wait for ready failed before probe !\n", (char *)(& hwif->name));
    }
  } else {

  }
#line 705
  i = 0;
#line 705
  goto ldv_39238;
  ldv_39237: 
  {
#line 706
  probe_for_drive(drive);
  }
#line 707
  if ((drive->dev_flags & 64UL) != 0UL) {
#line 708
    rc = 0;
  } else {

  }
#line 705
  i = i + 1;
  ldv_39238: 
#line 705
  drive = hwif->devices[i];
#line 705
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 707
    goto ldv_39237;
  } else {

  }

#line 715
  if (irqd != 0U) {
    {
#line 716
    enable_irq(irqd);
    }
  } else {

  }
#line 718
  return (rc);
}
}
#line 721 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_port_tune_devices(ide_hwif_t *hwif ) 
{ 
  struct ide_port_ops  const  *port_ops ;
  ide_drive_t *drive ;
  int i ;

  {
#line 723
  port_ops = hwif->port_ops;
#line 727
  i = 0;
#line 727
  goto ldv_39247;
  ldv_39246: ;
#line 727
  if ((drive->dev_flags & 64UL) != 0UL) {
    {
#line 728
    ide_check_nien_quirk_list(drive);
    }
#line 730
    if ((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->quirkproc != (unsigned long )((void (*/* const  */)(ide_drive_t * ))0)) {
      {
#line 731
      (*(port_ops->quirkproc))(drive);
      }
    } else {

    }
  } else {

  }
#line 727
  i = i + 1;
  ldv_39247: 
#line 727
  drive = hwif->devices[i];
#line 727
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 729
    goto ldv_39246;
  } else {

  }
#line 734
  i = 0;
#line 734
  goto ldv_39250;
  ldv_39249: ;
#line 734
  if ((drive->dev_flags & 64UL) != 0UL) {
    {
#line 735
    ide_set_max_pio(drive);
#line 737
    drive->dev_flags = drive->dev_flags | 32UL;
    }
#line 739
    if ((unsigned long )hwif->dma_ops != (unsigned long )((struct ide_dma_ops  const  *)0)) {
      {
#line 740
      ide_set_dma(drive);
      }
    } else {

    }
  } else {

  }
#line 734
  i = i + 1;
  ldv_39250: 
#line 734
  drive = hwif->devices[i];
#line 734
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 736
    goto ldv_39249;
  } else {

  }

#line 741
  return;
}
}
#line 747 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int ide_init_queue(ide_drive_t *drive ) 
{ 
  struct request_queue *q ;
  ide_hwif_t *hwif ;
  int max_sectors ;
  int max_sg_entries ;
  int tmp ;

  {
  {
#line 750
  hwif = drive->hwif;
#line 751
  max_sectors = 256;
#line 752
  max_sg_entries = 256;
#line 762
  tmp = hwif_to_node(hwif);
#line 762
  q = blk_init_queue_node(& do_ide_request, (spinlock_t *)0, tmp);
  }
#line 763
  if ((unsigned long )q == (unsigned long )((struct request_queue *)0)) {
#line 764
    return (1);
  } else {

  }
  {
#line 766
  q->queuedata = (void *)drive;
#line 767
  blk_queue_segment_boundary(q, 65535UL);
  }
#line 769
  if (hwif->rqsize < max_sectors) {
#line 770
    max_sectors = hwif->rqsize;
  } else {

  }
  {
#line 771
  blk_queue_max_hw_sectors(q, (unsigned int )max_sectors);
  }
#line 783
  if (dma_ops->is_phys == 0) {
#line 784
    max_sg_entries = max_sg_entries >> 1;
  } else {

  }
  {
#line 787
  blk_queue_max_segments(q, (int )((unsigned short )max_sg_entries));
#line 790
  drive->queue = q;
#line 793
  ide_toggle_bounce(drive, 1);
  }
#line 795
  return (0);
}
}
#line 798 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static struct mutex ide_cfg_mtx  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "ide_cfg_mtx.wait_lock",
                                                           0, 0UL}}}}, {& ide_cfg_mtx.wait_list,
                                                                        & ide_cfg_mtx.wait_list},
    0, (void *)(& ide_cfg_mtx), {0, {0, 0}, "ide_cfg_mtx", 0, 0UL}};
#line 804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int ide_port_setup_devices(ide_hwif_t *hwif ) 
{ 
  ide_drive_t *drive ;
  int i ;
  int j ;
  int tmp ;

  {
  {
#line 807
  j = 0;
#line 809
  ldv_mutex_lock_96___0(& ide_cfg_mtx);
#line 810
  i = 0;
  }
#line 810
  goto ldv_39269;
  ldv_39268: ;
#line 810
  if ((drive->dev_flags & 64UL) != 0UL) {
    {
#line 811
    tmp = ide_init_queue(drive);
    }
#line 811
    if (tmp != 0) {
      {
#line 812
      printk("\vide: failed to init %s\n", (char *)(& drive->name));
#line 814
      drive->dev_flags = drive->dev_flags & 0xffffffffffffffbfUL;
      }
#line 815
      goto ldv_39267;
    } else {

    }
#line 818
    j = j + 1;
  } else {

  }
  ldv_39267: 
#line 810
  i = i + 1;
  ldv_39269: 
#line 810
  drive = hwif->devices[i];
#line 810
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 812
    goto ldv_39268;
  } else {

  }
  {
#line 820
  ldv_mutex_unlock_97___0(& ide_cfg_mtx);
  }
#line 822
  return (j);
}
}
#line 825 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_host_enable_irqs(struct ide_host *host ) 
{ 
  ide_hwif_t *hwif ;
  int i ;

  {
#line 830
  i = 0;
#line 830
  goto ldv_39278;
  ldv_39277: ;
#line 831
  if ((unsigned long )hwif == (unsigned long )((ide_hwif_t *)0)) {
#line 832
    goto ldv_39276;
  } else {

  }
  {
#line 835
  (*((hwif->tp_ops)->read_status))(hwif);
  }
#line 838
  if (hwif->io_ports.ctl_addr != 0UL) {
    {
#line 839
    (*((hwif->tp_ops)->write_devctl))(hwif, 8);
    }
  } else {

  }
  ldv_39276: 
#line 830
  i = i + 1;
  ldv_39278: 
#line 830
  hwif = host->ports[i];
#line 830
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0) || i <= 3) {
#line 832
    goto ldv_39277;
  } else {

  }

#line 837
  return;
}
}
#line 846 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int init_irq(ide_hwif_t *hwif ) 
{ 
  struct ide_io_ports *io_ports ;
  struct ide_host *host ;
  irqreturn_t (*irq_handler)(int  , void * ) ;
  int sa ;
  int tmp ;

  {
#line 848
  io_ports = & hwif->io_ports;
#line 849
  host = hwif->host;
#line 850
  irq_handler = host->irq_handler;
#line 851
  sa = host->irq_flags;
#line 853
  if ((unsigned long )irq_handler == (unsigned long )((irqreturn_t (*)(int  , void * ))0)) {
#line 854
    irq_handler = & ide_intr;
  } else {

  }
#line 856
  if ((unsigned long )host->get_lock == (unsigned long )((void (*)(irqreturn_t (*)(int  ,
                                                                                   void * ) ,
                                                                   void * ))0)) {
    {
#line 857
    tmp = ldv_request_irq_98((unsigned int )hwif->irq, irq_handler, (unsigned long )sa,
                             (char const   *)(& hwif->name), (void *)hwif);
    }
#line 857
    if (tmp != 0) {
#line 858
      goto out_up;
    } else {

    }
  } else {

  }
  {
#line 861
  printk("\016%s at 0x%03lx-0x%03lx,0x%03lx on irq %d", (char *)(& hwif->name), io_ports->data_addr,
         io_ports->__annonCompField81.status_addr, io_ports->ctl_addr, hwif->irq);
  }
#line 868
  if (((hwif->host)->host_flags & 1048576UL) != 0UL) {
    {
#line 869
    printk(" (serialized)");
    }
  } else {

  }
  {
#line 870
  printk("\n");
  }
#line 872
  return (0);
  out_up: ;
#line 874
  return (1);
}
}
#line 877 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int ata_lock(dev_t dev , void *data ) 
{ 


  {
#line 880
  return (0);
}
}
#line 883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static struct kobject *ata_probe(dev_t dev , int *part , void *data ) 
{ 
  ide_hwif_t *hwif ;
  int unit ;
  ide_drive_t *drive ;

  {
#line 885
  hwif = (ide_hwif_t *)data;
#line 886
  unit = *part >> 6;
#line 887
  drive = hwif->devices[unit];
#line 889
  if ((drive->dev_flags & 64UL) == 0UL) {
#line 890
    return ((struct kobject *)0);
  } else {

  }
#line 892
  if ((unsigned int )drive->media == 32U) {
    {
#line 893
    __request_module(1, "ide-disk");
    }
  } else {

  }
#line 894
  if ((unsigned int )drive->media == 5U || (unsigned int )drive->media == 7U) {
    {
#line 895
    __request_module(1, "ide-cd");
    }
  } else {

  }
#line 896
  if ((unsigned int )drive->media == 1U) {
    {
#line 897
    __request_module(1, "ide-tape");
    }
  } else {

  }
#line 898
  if ((unsigned int )drive->media == 0U) {
    {
#line 899
    __request_module(1, "ide-floppy");
    }
  } else {

  }
#line 901
  return ((struct kobject *)0);
}
}
#line 904 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static struct kobject *exact_match(dev_t dev , int *part , void *data ) 
{ 
  struct gendisk *p ;

  {
#line 906
  p = (struct gendisk *)data;
#line 907
  *part = *part & 63;
#line 908
  return (& p->part0.__dev.kobj);
}
}
#line 911 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int exact_lock(dev_t dev , void *data ) 
{ 
  struct gendisk *p ;
  struct kobject *tmp ;

  {
  {
#line 913
  p = (struct gendisk *)data;
#line 915
  tmp = get_disk(p);
  }
#line 915
  if ((unsigned long )tmp == (unsigned long )((struct kobject *)0)) {
#line 916
    return (-1);
  } else {

  }
#line 917
  return (0);
}
}
#line 920 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
void ide_register_region(struct gendisk *disk ) 
{ 


  {
  {
#line 922
  blk_register_region((dev_t )((disk->major << 20) | disk->first_minor), (unsigned long )disk->minors,
                      (struct module *)0, & exact_match, & exact_lock, (void *)disk);
  }
#line 924
  return;
}
}
#line 926 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_register_region[20U]  = 
#line 926
  {      'i',      'd',      'e',      '_', 
        'r',      'e',      'g',      'i', 
        's',      't',      'e',      'r', 
        '_',      'r',      'e',      'g', 
        'i',      'o',      'n',      '\000'};
#line 926
struct kernel_symbol  const  __ksymtab_ide_register_region ;
#line 926 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_register_region  =    {(unsigned long )(& ide_register_region), (char const   *)(& __kstrtab_ide_register_region)};
#line 928 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
void ide_unregister_region(struct gendisk *disk ) 
{ 


  {
  {
#line 930
  blk_unregister_region((dev_t )((disk->major << 20) | disk->first_minor), (unsigned long )disk->minors);
  }
#line 932
  return;
}
}
#line 934 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_unregister_region[22U]  = 
#line 934
  {      'i',      'd',      'e',      '_', 
        'u',      'n',      'r',      'e', 
        'g',      'i',      's',      't', 
        'e',      'r',      '_',      'r', 
        'e',      'g',      'i',      'o', 
        'n',      '\000'};
#line 934
struct kernel_symbol  const  __ksymtab_ide_unregister_region ;
#line 934 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_unregister_region  =    {(unsigned long )(& ide_unregister_region), (char const   *)(& __kstrtab_ide_unregister_region)};
#line 936 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
void ide_init_disk(struct gendisk *disk , ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  unsigned int unit ;

  {
  {
#line 938
  hwif = drive->hwif;
#line 939
  unit = (unsigned int )drive->dn & 1U;
#line 941
  disk->major = (int )hwif->major;
#line 942
  disk->first_minor = (int )(unit << 6);
#line 943
  sprintf((char *)(& disk->disk_name), "hd%c", ((unsigned int )((int )hwif->index * 2) + unit) + 97U);
#line 944
  disk->queue = drive->queue;
  }
#line 945
  return;
}
}
#line 947 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_init_disk[14U]  = 
#line 947
  {      'i',      'd',      'e',      '_', 
        'i',      'n',      'i',      't', 
        '_',      'd',      'i',      's', 
        'k',      '\000'};
#line 947
struct kernel_symbol  const  __ksymtab_ide_init_disk ;
#line 947 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_init_disk  =    {(unsigned long )(& ide_init_disk), (char const   *)(& __kstrtab_ide_init_disk)};
#line 949 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void drive_release_dev(struct device *dev ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;

  {
  {
#line 951
  __mptr = (struct device  const  *)dev;
#line 951
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 953
  ide_proc_unregister_device(drive);
#line 955
  ldv_blk_cleanup_queue_99(drive->queue);
#line 956
  drive->queue = (struct request_queue *)0;
#line 958
  drive->dev_flags = drive->dev_flags & 0xffffffffffffffbfUL;
#line 960
  complete(& drive->gendev_rel_comp);
  }
#line 961
  return;
}
}
#line 963 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int hwif_init(ide_hwif_t *hwif ) 
{ 
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 965
  if (hwif->irq == 0) {
    {
#line 966
    printk("\v%s: disabled, no IRQ\n", (char *)(& hwif->name));
    }
#line 967
    return (0);
  } else {

  }
  {
#line 970
  tmp = register_blkdev((unsigned int )hwif->major, (char const   *)(& hwif->name));
  }
#line 970
  if (tmp != 0) {
#line 971
    return (0);
  } else {

  }
#line 973
  if (hwif->sg_max_nents == 0) {
#line 974
    hwif->sg_max_nents = 256;
  } else {

  }
  {
#line 976
  tmp___0 = kmalloc((unsigned long )hwif->sg_max_nents * 40UL, 208U);
#line 976
  hwif->sg_table = (struct scatterlist *)tmp___0;
  }
#line 978
  if ((unsigned long )hwif->sg_table == (unsigned long )((struct scatterlist *)0)) {
    {
#line 979
    printk("\v%s: unable to allocate SG table.\n", (char *)(& hwif->name));
    }
#line 980
    goto out;
  } else {

  }
  {
#line 983
  sg_init_table(hwif->sg_table, (unsigned int )hwif->sg_max_nents);
#line 985
  tmp___1 = init_irq(hwif);
  }
#line 985
  if (tmp___1 != 0) {
    {
#line 986
    printk("\v%s: disabled, unable to get IRQ %d\n", (char *)(& hwif->name), hwif->irq);
    }
#line 988
    goto out;
  } else {

  }
  {
#line 991
  blk_register_region((dev_t )((int )hwif->major << 20), 128UL, & __this_module, & ata_probe,
                      & ata_lock, (void *)hwif);
  }
#line 993
  return (1);
  out: 
  {
#line 996
  unregister_blkdev((unsigned int )hwif->major, (char const   *)(& hwif->name));
  }
#line 997
  return (0);
}
}
#line 1000 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void hwif_register_devices(ide_hwif_t *hwif ) 
{ 
  ide_drive_t *drive ;
  unsigned int i ;
  struct device *dev ;
  int ret ;

  {
#line 1005
  i = 0U;
#line 1005
  goto ldv_39364;
  ldv_39363: ;
#line 1005
  if ((drive->dev_flags & 64UL) != 0UL) {
    {
#line 1006
    dev = & drive->gendev;
#line 1009
    dev_set_name(dev, "%u.%u", (int )hwif->index, i);
#line 1010
    dev_set_drvdata(dev, (void *)drive);
#line 1011
    dev->parent = & hwif->gendev;
#line 1012
    dev->bus = & ide_bus_type;
#line 1013
    dev->release = & drive_release_dev;
#line 1015
    ret = device_register(dev);
    }
#line 1016
    if (ret < 0) {
      {
#line 1017
      printk("\fIDE: %s: device_register error: %d\n", "hwif_register_devices", ret);
      }
    } else {

    }
  } else {

  }
#line 1005
  i = i + 1U;
  ldv_39364: 
#line 1005
  drive = hwif->devices[i];
#line 1005
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1U) {
#line 1007
    goto ldv_39363;
  } else {

  }

#line 1012
  return;
}
}
#line 1022 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_port_init_devices(ide_hwif_t *hwif ) 
{ 
  struct ide_port_ops  const  *port_ops ;
  ide_drive_t *drive ;
  int i ;

  {
#line 1024
  port_ops = hwif->port_ops;
#line 1028
  i = 0;
#line 1028
  goto ldv_39373;
  ldv_39372: 
#line 1029
  drive->dn = (unsigned int )((u8 )i) + (unsigned int )hwif->channel * 2U;
#line 1031
  if ((hwif->host_flags & 16777216U) != 0U) {
#line 1032
    drive->io_32bit = 1U;
  } else {

  }
#line 1033
  if ((hwif->host_flags & 1073741824U) != 0U) {
#line 1034
    drive->dev_flags = drive->dev_flags | 16384UL;
  } else {

  }
#line 1035
  if ((hwif->host_flags & 33554432U) != 0U) {
#line 1036
    drive->dev_flags = drive->dev_flags | 4UL;
  } else {

  }
#line 1037
  if ((int )hwif->host_flags < 0) {
#line 1038
    drive->dev_flags = drive->dev_flags | 8192UL;
  } else {

  }
#line 1040
  drive->pio_mode = 8U;
#line 1042
  if ((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->init_dev != (unsigned long )((void (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 1043
    (*(port_ops->init_dev))(drive);
    }
  } else {

  }
#line 1028
  i = i + 1;
  ldv_39373: 
#line 1028
  drive = hwif->devices[i];
#line 1028
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 1030
    goto ldv_39372;
  } else {

  }

#line 1035
  return;
}
}
#line 1047 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_init_port(ide_hwif_t *hwif , unsigned int port , struct ide_port_info  const  *d ) 
{ 
  int rc ;

  {
#line 1050
  hwif->channel = (u8 )port;
#line 1052
  hwif->chipset = (unsigned int )((unsigned char )d->chipset) != 0U ? (hwif_chipset_t )d->chipset : 2U;
#line 1054
  if ((unsigned long )d->init_iops != (unsigned long )((void (*/* const  */)(ide_hwif_t * ))0)) {
    {
#line 1055
    (*(d->init_iops))(hwif);
    }
  } else {

  }
#line 1058
  hwif->host_flags = hwif->host_flags | (u32 )d->host_flags;
#line 1059
  hwif->pio_mask = d->pio_mask;
#line 1061
  if ((unsigned long )d->tp_ops != (unsigned long )((struct ide_tp_ops  const  */* const  */)0)) {
#line 1062
    hwif->tp_ops = d->tp_ops;
  } else {

  }
#line 1065
  if ((hwif->host_flags & 2097152U) == 0U || (unsigned int )hwif->channel == 0U) {
#line 1066
    hwif->port_ops = d->port_ops;
  } else {

  }
#line 1068
  hwif->swdma_mask = d->swdma_mask;
#line 1069
  hwif->mwdma_mask = d->mwdma_mask;
#line 1070
  hwif->ultra_mask = d->udma_mask;
#line 1072
  if (((unsigned int )d->host_flags & 16384U) == 0U) {
#line 1075
    hwif->dma_ops = d->dma_ops;
#line 1077
    if ((unsigned long )d->init_dma != (unsigned long )((int (*/* const  */)(ide_hwif_t * ,
                                                                             struct ide_port_info  const  * ))0)) {
      {
#line 1078
      rc = (*(d->init_dma))(hwif, d);
      }
    } else {
      {
#line 1080
      rc = ide_hwif_setup_dma(hwif, d);
      }
    }
#line 1082
    if (rc < 0) {
      {
#line 1083
      printk("\016%s: DMA disabled\n", (char *)(& hwif->name));
#line 1085
      hwif->dma_ops = (struct ide_dma_ops  const  *)0;
#line 1086
      hwif->dma_base = 0UL;
#line 1087
      hwif->swdma_mask = 0U;
#line 1088
      hwif->mwdma_mask = 0U;
#line 1089
      hwif->ultra_mask = 0U;
      }
    } else {

    }
  } else {

  }
#line 1093
  if (((unsigned int )d->host_flags & 1048576U) != 0U || (((unsigned int )d->host_flags & 134217728U) != 0U && hwif->dma_base != 0UL)) {
#line 1095
    (hwif->host)->host_flags = (hwif->host)->host_flags | 1048576UL;
  } else {

  }
#line 1097
  if ((unsigned int )((unsigned short )d->max_sectors) != 0U) {
#line 1098
    hwif->rqsize = (int )d->max_sectors;
  } else
#line 1100
  if (*((unsigned int *)hwif + 43UL) != 0U) {
#line 1102
    hwif->rqsize = 256;
  } else {
#line 1104
    hwif->rqsize = 65536;
  }
#line 1108
  if ((unsigned long )d->init_hwif != (unsigned long )((void (*/* const  */)(ide_hwif_t * ))0)) {
    {
#line 1109
    (*(d->init_hwif))(hwif);
    }
  } else {

  }
#line 1110
  return;
}
}
#line 1112 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_port_cable_detect(ide_hwif_t *hwif ) 
{ 
  struct ide_port_ops  const  *port_ops ;

  {
#line 1114
  port_ops = hwif->port_ops;
#line 1116
  if (((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->cable_detect != (unsigned long )((u8 (*/* const  */)(struct hwif_s * ))0)) && ((int )hwif->ultra_mask & 120) != 0) {
#line 1117
    if ((unsigned int )hwif->cbl != 3U) {
      {
#line 1118
      hwif->cbl = (*(port_ops->cable_detect))(hwif);
      }
    } else {

    }
  } else {

  }
#line 1119
  return;
}
}
#line 1122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static u8 const   ide_hwif_to_major[10U]  = 
#line 1122
  {      3U,      22U,      33U,      34U, 
        56U,      57U,      88U,      89U, 
        90U,      91U};
#line 1126 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_port_init_devices_data(ide_hwif_t *hwif ) 
{ 
  ide_drive_t *drive ;
  int i ;
  u8 j ;
  u16 *saved_id ;

  {
#line 1131
  i = 0;
#line 1131
  goto ldv_39394;
  ldv_39393: 
  {
#line 1132
  j = (unsigned int )hwif->index * 2U + (unsigned int )((u8 )i);
#line 1133
  saved_id = drive->id;
#line 1135
  __memset((void *)drive, 0, 2240UL);
#line 1136
  __memset((void *)saved_id, 0, 512UL);
#line 1137
  drive->id = saved_id;
#line 1139
  drive->media = 32U;
#line 1140
  drive->select = (u8 )((int )((signed char )(i << 4)) | -96);
#line 1141
  drive->hwif = hwif;
#line 1142
  drive->ready_stat = 64U;
#line 1143
  drive->bad_wstat = 161U;
#line 1144
  drive->special_flags = 3U;
#line 1146
  drive->name[0] = 104;
#line 1147
  drive->name[1] = 100;
#line 1148
  drive->name[2] = (char )((unsigned int )j + 97U);
#line 1149
  drive->max_failures = 1U;
#line 1151
  INIT_LIST_HEAD(& drive->list);
#line 1152
  ldv_init_completion_100(& drive->gendev_rel_comp);
#line 1131
  i = i + 1;
  }
  ldv_39394: 
#line 1131
  drive = hwif->devices[i];
#line 1131
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 1133
    goto ldv_39393;
  } else {

  }

#line 1138
  return;
}
}
#line 1156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_init_port_data(ide_hwif_t *hwif , unsigned int index ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
  {
#line 1159
  hwif->index = (u8 )index;
#line 1160
  hwif->major = ide_hwif_to_major[index];
#line 1162
  hwif->name[0] = 105;
#line 1163
  hwif->name[1] = 100;
#line 1164
  hwif->name[2] = 101;
#line 1165
  hwif->name[3] = (char )((unsigned int )((unsigned char )index) + 48U);
#line 1167
  spinlock_check(& hwif->lock);
#line 1167
  __raw_spin_lock_init(& hwif->lock.__annonCompField18.rlock, "&(&hwif->lock)->rlock",
                       & __key);
#line 1169
  init_timer_key(& hwif->timer, 0U, "(&hwif->timer)", & __key___0);
#line 1170
  hwif->timer.function = & ide_timer_expiry;
#line 1171
  hwif->timer.data = (unsigned long )hwif;
#line 1173
  ldv_init_completion_101(& hwif->gendev_rel_comp);
#line 1175
  hwif->tp_ops = & default_tp_ops;
#line 1177
  ide_port_init_devices_data(hwif);
  }
#line 1178
  return;
}
}
#line 1180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_init_port_hw(ide_hwif_t *hwif , struct ide_hw *hw ) 
{ 


  {
  {
#line 1182
  __memcpy((void *)(& hwif->io_ports), (void const   *)(& hw->__annonCompField82.io_ports),
           80UL);
#line 1183
  hwif->irq = hw->irq;
#line 1184
  hwif->dev = hw->dev;
#line 1185
  hwif->gendev.parent = (unsigned long )hw->parent != (unsigned long )((struct device *)0) ? hw->parent : hw->dev;
#line 1186
  hwif->config_data = hw->config;
  }
#line 1187
  return;
}
}
#line 1189 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static unsigned int ide_indexes  ;
#line 1198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int ide_find_port_slot(struct ide_port_info  const  *d ) 
{ 
  int idx ;
  u8 bootable ;
  u8 i ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
#line 1200
  idx = -2;
#line 1201
  bootable = (u8 )((unsigned long )d == (unsigned long )((struct ide_port_info  const  *)0) || ((unsigned int )d->host_flags & 8192U) == 0U);
#line 1202
  i = (u8 )((unsigned long )d != (unsigned long )((struct ide_port_info  const  *)0) && ((unsigned int )d->host_flags & 8U) != 0U);
#line 1214
  ldv_mutex_lock_102(& ide_cfg_mtx);
  }
#line 1215
  if ((unsigned int )bootable != 0U) {
#line 1216
    if ((ide_indexes | (unsigned int )i) != 1023U) {
      {
#line 1217
      tmp = ffz((unsigned long )(ide_indexes | (unsigned int )i));
#line 1217
      idx = (int )tmp;
      }
    } else {

    }
  } else
#line 1219
  if ((ide_indexes | 3U) != 1023U) {
    {
#line 1220
    tmp___0 = ffz((unsigned long )(ide_indexes | 3U));
#line 1220
    idx = (int )tmp___0;
    }
  } else
#line 1221
  if ((ide_indexes & 3U) != 3U) {
    {
#line 1222
    tmp___1 = ffz((unsigned long )ide_indexes);
#line 1222
    idx = (int )tmp___1;
    }
  } else {

  }
#line 1224
  if (idx >= 0) {
#line 1225
    ide_indexes = ide_indexes | (unsigned int )(1 << idx);
  } else {

  }
  {
#line 1226
  ldv_mutex_unlock_103(& ide_cfg_mtx);
  }
#line 1228
  return (idx);
}
}
#line 1231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_free_port_slot(int idx ) 
{ 


  {
  {
#line 1233
  ldv_mutex_lock_104(& ide_cfg_mtx);
#line 1234
  ide_indexes = ide_indexes & (unsigned int )(~ (1 << idx));
#line 1235
  ldv_mutex_unlock_105(& ide_cfg_mtx);
  }
#line 1236
  return;
}
}
#line 1238 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_port_free_devices(ide_hwif_t *hwif ) 
{ 
  ide_drive_t *drive ;
  int i ;

  {
#line 1243
  i = 0;
#line 1243
  goto ldv_39422;
  ldv_39421: 
  {
#line 1244
  kfree((void const   *)drive->id);
#line 1245
  kfree((void const   *)drive);
#line 1243
  i = i + 1;
  }
  ldv_39422: 
#line 1243
  drive = hwif->devices[i];
#line 1243
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 1245
    goto ldv_39421;
  } else {

  }

#line 1250
  return;
}
}
#line 1249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static int ide_port_alloc_devices(ide_hwif_t *hwif , int node ) 
{ 
  int i ;
  ide_drive_t *drive ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1253
  i = 0;
#line 1253
  goto ldv_39432;
  ldv_39431: 
  {
#line 1256
  tmp = kzalloc_node(2240UL, 208U, node);
#line 1256
  drive = (ide_drive_t *)tmp;
  }
#line 1257
  if ((unsigned long )drive == (unsigned long )((ide_drive_t *)0)) {
#line 1258
    goto out_nomem;
  } else {

  }
  {
#line 1268
  tmp___0 = kzalloc_node(512UL, 208U, node);
#line 1268
  drive->id = (u16 *)tmp___0;
  }
#line 1269
  if ((unsigned long )drive->id == (unsigned long )((u16 *)0U)) {
#line 1270
    goto out_nomem;
  } else {

  }
#line 1272
  hwif->devices[i] = drive;
#line 1253
  i = i + 1;
  ldv_39432: ;
#line 1253
  if (i <= 1) {
#line 1255
    goto ldv_39431;
  } else {

  }

#line 1274
  return (0);
  out_nomem: 
  {
#line 1277
  ide_port_free_devices(hwif);
  }
#line 1278
  return (-12);
}
}
#line 1281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct ide_host *ide_host_alloc(struct ide_port_info  const  *d , struct ide_hw **hws ,
                                unsigned int n_ports ) 
{ 
  struct ide_host *host ;
  struct device *dev ;
  int node ;
  int tmp ;
  int tmp___0 ;
  int i ;
  void *tmp___1 ;
  ide_hwif_t *hwif ;
  int idx ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1285
  dev = (unsigned long )*hws != (unsigned long )((struct ide_hw *)0) ? (*hws)->dev : (struct device *)0;
#line 1286
  if ((unsigned long )dev != (unsigned long )((struct device *)0)) {
    {
#line 1286
    tmp = dev_to_node(dev);
#line 1286
    tmp___0 = tmp;
    }
  } else {
#line 1286
    tmp___0 = -1;
  }
  {
#line 1286
  node = tmp___0;
#line 1289
  tmp___1 = kzalloc_node(136UL, 208U, node);
#line 1289
  host = (struct ide_host *)tmp___1;
  }
#line 1290
  if ((unsigned long )host == (unsigned long )((struct ide_host *)0)) {
#line 1291
    return ((struct ide_host *)0);
  } else {

  }
#line 1293
  i = 0;
#line 1293
  goto ldv_39447;
  ldv_39446: ;
#line 1297
  if ((unsigned long )*(hws + (unsigned long )i) == (unsigned long )((struct ide_hw *)0)) {
#line 1298
    goto ldv_39445;
  } else {

  }
  {
#line 1300
  tmp___2 = kzalloc_node(4096UL, 208U, node);
#line 1300
  hwif = (ide_hwif_t *)tmp___2;
  }
#line 1301
  if ((unsigned long )hwif == (unsigned long )((ide_hwif_t *)0)) {
#line 1302
    goto ldv_39445;
  } else {

  }
  {
#line 1304
  tmp___3 = ide_port_alloc_devices(hwif, node);
  }
#line 1304
  if (tmp___3 < 0) {
    {
#line 1305
    kfree((void const   *)hwif);
    }
#line 1306
    goto ldv_39445;
  } else {

  }
  {
#line 1309
  idx = ide_find_port_slot(d);
  }
#line 1310
  if (idx < 0) {
    {
#line 1311
    printk("\v%s: no free slot for interface\n", (unsigned long )d != (unsigned long )((struct ide_port_info  const  *)0) ? d->name : (char */* const  */)"ide");
#line 1313
    ide_port_free_devices(hwif);
#line 1314
    kfree((void const   *)hwif);
    }
#line 1315
    goto ldv_39445;
  } else {

  }
  {
#line 1318
  ide_init_port_data(hwif, (unsigned int )idx);
#line 1320
  hwif->host = host;
#line 1322
  host->ports[i] = hwif;
#line 1323
  host->n_ports = host->n_ports + 1U;
  }
  ldv_39445: 
#line 1293
  i = i + 1;
  ldv_39447: ;
#line 1293
  if ((unsigned int )i < n_ports) {
#line 1295
    goto ldv_39446;
  } else {

  }

#line 1326
  if (host->n_ports == 0U) {
    {
#line 1327
    kfree((void const   *)host);
    }
#line 1328
    return ((struct ide_host *)0);
  } else {

  }
#line 1331
  host->dev[0] = dev;
#line 1333
  if ((unsigned long )d != (unsigned long )((struct ide_port_info  const  *)0)) {
#line 1334
    host->init_chipset = d->init_chipset;
#line 1335
    host->get_lock = d->get_lock;
#line 1336
    host->release_lock = d->release_lock;
#line 1337
    host->host_flags = (unsigned long )d->host_flags;
#line 1338
    host->irq_flags = d->irq_flags;
  } else {

  }
#line 1341
  return (host);
}
}
#line 1343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_host_alloc[15U]  = 
#line 1343
  {      'i',      'd',      'e',      '_', 
        'h',      'o',      's',      't', 
        '_',      'a',      'l',      'l', 
        'o',      'c',      '\000'};
#line 1343
struct kernel_symbol  const  __ksymtab_ide_host_alloc ;
#line 1343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_host_alloc  =    {(unsigned long )(& ide_host_alloc), (char const   *)(& __kstrtab_ide_host_alloc)};
#line 1345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_port_free(ide_hwif_t *hwif ) 
{ 


  {
  {
#line 1347
  ide_port_free_devices(hwif);
#line 1348
  ide_free_port_slot((int )hwif->index);
#line 1349
  kfree((void const   *)hwif);
  }
#line 1350
  return;
}
}
#line 1352 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_disable_port(ide_hwif_t *hwif ) 
{ 
  struct ide_host *host ;
  int i ;

  {
  {
#line 1354
  host = hwif->host;
#line 1357
  printk("\016%s: disabling port\n", (char *)(& hwif->name));
#line 1359
  i = 0;
  }
#line 1359
  goto ldv_39467;
  ldv_39466: ;
#line 1360
  if ((unsigned long )host->ports[i] == (unsigned long )hwif) {
#line 1361
    host->ports[i] = (ide_hwif_t *)0;
#line 1362
    host->n_ports = host->n_ports - 1U;
  } else {

  }
#line 1359
  i = i + 1;
  ldv_39467: ;
#line 1359
  if (i <= 3) {
#line 1361
    goto ldv_39466;
  } else {

  }
  {
#line 1366
  ide_port_free(hwif);
  }
#line 1367
  return;
}
}
#line 1369 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
int ide_host_register(struct ide_host *host , struct ide_port_info  const  *d , struct ide_hw **hws ) 
{ 
  ide_hwif_t *hwif ;
  ide_hwif_t *mate ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1372
  mate = (ide_hwif_t *)0;
#line 1373
  j = 0;
#line 1375
  i = 0;
#line 1375
  goto ldv_39480;
  ldv_39479: ;
#line 1376
  if ((unsigned long )hwif == (unsigned long )((ide_hwif_t *)0)) {
#line 1377
    mate = (ide_hwif_t *)0;
#line 1378
    goto ldv_39478;
  } else {

  }
  {
#line 1381
  ide_init_port_hw(hwif, *(hws + (unsigned long )i));
#line 1382
  ide_port_apply_params(hwif);
  }
#line 1384
  if ((i & 1) != 0 && (unsigned long )mate != (unsigned long )((ide_hwif_t *)0)) {
#line 1385
    hwif->mate = mate;
#line 1386
    mate->mate = hwif;
  } else {

  }
  {
#line 1389
  mate = i & 1 ? (ide_hwif_t *)0 : hwif;
#line 1391
  ide_init_port(hwif, (unsigned int )i & 1U, d);
#line 1392
  ide_port_cable_detect(hwif);
#line 1394
  hwif->port_flags = hwif->port_flags | 1UL;
#line 1396
  ide_port_init_devices(hwif);
  }
  ldv_39478: 
#line 1375
  i = i + 1;
  ldv_39480: 
#line 1375
  hwif = host->ports[i];
#line 1375
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0) || i <= 3) {
#line 1377
    goto ldv_39479;
  } else {

  }
#line 1399
  i = 0;
#line 1399
  goto ldv_39484;
  ldv_39483: ;
#line 1400
  if ((unsigned long )hwif == (unsigned long )((ide_hwif_t *)0)) {
#line 1401
    goto ldv_39482;
  } else {

  }
  {
#line 1403
  tmp = ide_probe_port(hwif);
  }
#line 1403
  if (tmp == 0) {
#line 1404
    hwif->present = 1U;
  } else {

  }
#line 1406
  hwif->port_flags = hwif->port_flags & 0xfffffffffffffffeUL;
#line 1408
  if (((hwif->host_flags & 4194304U) == 0U || (unsigned long )hwif->mate == (unsigned long )((struct hwif_s *)0)) || (unsigned int )*((unsigned char *)hwif->mate + 388UL) == 0U) {
    {
#line 1410
    tmp___0 = ide_register_port(hwif);
    }
#line 1410
    if (tmp___0 != 0) {
      {
#line 1411
      ide_disable_port(hwif);
      }
#line 1412
      goto ldv_39482;
    } else {

    }
  } else {

  }
#line 1416
  if ((unsigned int )*((unsigned char *)hwif + 388UL) != 0U) {
    {
#line 1417
    ide_port_tune_devices(hwif);
    }
  } else {

  }
  ldv_39482: 
#line 1399
  i = i + 1;
  ldv_39484: 
#line 1399
  hwif = host->ports[i];
#line 1399
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0) || i <= 3) {
#line 1401
    goto ldv_39483;
  } else {

  }
  {
#line 1420
  ide_host_enable_irqs(host);
#line 1422
  i = 0;
  }
#line 1422
  goto ldv_39488;
  ldv_39487: ;
#line 1423
  if ((unsigned long )hwif == (unsigned long )((ide_hwif_t *)0)) {
#line 1424
    goto ldv_39486;
  } else {

  }
  {
#line 1426
  tmp___1 = hwif_init(hwif);
  }
#line 1426
  if (tmp___1 == 0) {
    {
#line 1427
    printk("\016%s: failed to initialize IDE interface\n", (char *)(& hwif->name));
#line 1429
    device_unregister(& hwif->gendev);
#line 1430
    ide_disable_port(hwif);
    }
#line 1431
    goto ldv_39486;
  } else {

  }
#line 1434
  if ((unsigned int )*((unsigned char *)hwif + 388UL) != 0U) {
    {
#line 1435
    tmp___2 = ide_port_setup_devices(hwif);
    }
#line 1435
    if (tmp___2 == 0) {
#line 1436
      hwif->present = 0U;
#line 1437
      goto ldv_39486;
    } else {

    }
  } else {

  }
  {
#line 1440
  j = j + 1;
#line 1442
  ide_acpi_init_port(hwif);
  }
#line 1444
  if ((unsigned int )*((unsigned char *)hwif + 388UL) != 0U) {
    {
#line 1445
    ide_acpi_port_init_devices(hwif);
    }
  } else {

  }
  ldv_39486: 
#line 1422
  i = i + 1;
  ldv_39488: 
#line 1422
  hwif = host->ports[i];
#line 1422
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0) || i <= 3) {
#line 1424
    goto ldv_39487;
  } else {

  }
#line 1448
  i = 0;
#line 1448
  goto ldv_39492;
  ldv_39491: ;
#line 1449
  if ((unsigned long )hwif == (unsigned long )((ide_hwif_t *)0)) {
#line 1450
    goto ldv_39490;
  } else {

  }
  {
#line 1452
  ide_sysfs_register_port(hwif);
#line 1453
  ide_proc_register_port(hwif);
  }
#line 1455
  if ((unsigned int )*((unsigned char *)hwif + 388UL) != 0U) {
    {
#line 1456
    ide_proc_port_register_devices(hwif);
#line 1457
    hwif_register_devices(hwif);
    }
  } else {

  }
  ldv_39490: 
#line 1448
  i = i + 1;
  ldv_39492: 
#line 1448
  hwif = host->ports[i];
#line 1448
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0) || i <= 3) {
#line 1450
    goto ldv_39491;
  } else {

  }

#line 1461
  return (j != 0 ? 0 : -1);
}
}
#line 1463 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_host_register[18U]  = 
#line 1463
  {      'i',      'd',      'e',      '_', 
        'h',      'o',      's',      't', 
        '_',      'r',      'e',      'g', 
        'i',      's',      't',      'e', 
        'r',      '\000'};
#line 1463
struct kernel_symbol  const  __ksymtab_ide_host_register ;
#line 1463 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_host_register  =    {(unsigned long )(& ide_host_register), (char const   *)(& __kstrtab_ide_host_register)};
#line 1465 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
int ide_host_add(struct ide_port_info  const  *d , struct ide_hw **hws , unsigned int n_ports ,
                 struct ide_host **hostp ) 
{ 
  struct ide_host *host ;
  int rc ;

  {
  {
#line 1471
  host = ide_host_alloc(d, hws, n_ports);
  }
#line 1472
  if ((unsigned long )host == (unsigned long )((struct ide_host *)0)) {
#line 1473
    return (-12);
  } else {

  }
  {
#line 1475
  rc = ide_host_register(host, d, hws);
  }
#line 1476
  if (rc != 0) {
    {
#line 1477
    ide_host_free(host);
    }
#line 1478
    return (rc);
  } else {

  }
#line 1481
  if ((unsigned long )hostp != (unsigned long )((struct ide_host **)0)) {
#line 1482
    *hostp = host;
  } else {

  }
#line 1484
  return (0);
}
}
#line 1486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_host_add[13U]  = 
#line 1486
  {      'i',      'd',      'e',      '_', 
        'h',      'o',      's',      't', 
        '_',      'a',      'd',      'd', 
        '\000'};
#line 1486
struct kernel_symbol  const  __ksymtab_ide_host_add ;
#line 1486 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_host_add  =    {(unsigned long )(& ide_host_add), (char const   *)(& __kstrtab_ide_host_add)};
#line 1488 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void __ide_port_unregister_devices(ide_hwif_t *hwif ) 
{ 
  ide_drive_t *drive ;
  int i ;

  {
#line 1493
  i = 0;
#line 1493
  goto ldv_39527;
  ldv_39526: ;
#line 1493
  if ((drive->dev_flags & 64UL) != 0UL) {
    {
#line 1494
    device_unregister(& drive->gendev);
#line 1495
    ldv_wait_for_completion_106(& drive->gendev_rel_comp);
    }
  } else {

  }
#line 1493
  i = i + 1;
  ldv_39527: 
#line 1493
  drive = hwif->devices[i];
#line 1493
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 1495
    goto ldv_39526;
  } else {

  }

#line 1500
  return;
}
}
#line 1499 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
void ide_port_unregister_devices(ide_hwif_t *hwif ) 
{ 


  {
  {
#line 1501
  ldv_mutex_lock_107(& ide_cfg_mtx);
#line 1502
  __ide_port_unregister_devices(hwif);
#line 1503
  hwif->present = 0U;
#line 1504
  ide_port_init_devices_data(hwif);
#line 1505
  ldv_mutex_unlock_108(& ide_cfg_mtx);
  }
#line 1506
  return;
}
}
#line 1507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_port_unregister_devices[28U]  = 
#line 1507
  {      'i',      'd',      'e',      '_', 
        'p',      'o',      'r',      't', 
        '_',      'u',      'n',      'r', 
        'e',      'g',      'i',      's', 
        't',      'e',      'r',      '_', 
        'd',      'e',      'v',      'i', 
        'c',      'e',      's',      '\000'};
#line 1507
struct kernel_symbol  const  __ksymtab_ide_port_unregister_devices ;
#line 1507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_port_unregister_devices  =    {(unsigned long )(& ide_port_unregister_devices), (char const   *)(& __kstrtab_ide_port_unregister_devices)};
#line 1523 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static void ide_unregister(ide_hwif_t *hwif ) 
{ 
  int tmp ;
  long tmp___0 ;
  unsigned long _flags ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1525
  tmp = preempt_count();
#line 1525
  tmp___0 = __builtin_expect(((unsigned long )tmp & 2096896UL) != 0UL, 0L);
  }
#line 1525
  if (tmp___0 != 0L) {
    {
#line 1525
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-probe.c"),
                         "i" (1525), "i" (12UL));
#line 1525
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 1526
  _flags = arch_local_save_flags();
#line 1526
  tmp___1 = arch_irqs_disabled_flags(_flags);
#line 1526
  tmp___2 = __builtin_expect(tmp___1 != 0, 0L);
  }
#line 1526
  if (tmp___2 != 0L) {
    {
#line 1526
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-probe.c"),
                         "i" (1526), "i" (12UL));
#line 1526
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 1528
  ldv_mutex_lock_109(& ide_cfg_mtx);
  }
#line 1530
  if ((unsigned int )*((unsigned char *)hwif + 388UL) != 0U) {
    {
#line 1531
    __ide_port_unregister_devices(hwif);
#line 1532
    hwif->present = 0U;
    }
  } else {

  }
  {
#line 1535
  ide_proc_unregister_port(hwif);
  }
#line 1537
  if ((unsigned long )(hwif->host)->get_lock == (unsigned long )((void (*)(irqreturn_t (*)(int  ,
                                                                                           void * ) ,
                                                                           void * ))0)) {
    {
#line 1538
    ldv_free_irq_110((unsigned int )hwif->irq, (void *)hwif);
    }
  } else {

  }
  {
#line 1540
  device_unregister(hwif->portdev);
#line 1541
  device_unregister(& hwif->gendev);
#line 1542
  ldv_wait_for_completion_111(& hwif->gendev_rel_comp);
#line 1547
  blk_unregister_region((dev_t )((int )hwif->major << 20), 128UL);
#line 1548
  kfree((void const   *)hwif->sg_table);
#line 1549
  unregister_blkdev((unsigned int )hwif->major, (char const   *)(& hwif->name));
#line 1551
  ide_release_dma_engine(hwif);
#line 1553
  ldv_mutex_unlock_112(& ide_cfg_mtx);
  }
#line 1554
  return;
}
}
#line 1556 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
void ide_host_free(struct ide_host *host ) 
{ 
  ide_hwif_t *hwif ;
  int i ;

  {
#line 1561
  i = 0;
#line 1561
  goto ldv_39557;
  ldv_39556: ;
#line 1562
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0)) {
    {
#line 1563
    ide_port_free(hwif);
    }
  } else {

  }
#line 1561
  i = i + 1;
  ldv_39557: 
#line 1561
  hwif = host->ports[i];
#line 1561
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0) || i <= 3) {
#line 1563
    goto ldv_39556;
  } else {

  }
  {
#line 1566
  kfree((void const   *)host);
  }
#line 1567
  return;
}
}
#line 1568 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_host_free[14U]  = 
#line 1568
  {      'i',      'd',      'e',      '_', 
        'h',      'o',      's',      't', 
        '_',      'f',      'r',      'e', 
        'e',      '\000'};
#line 1568
struct kernel_symbol  const  __ksymtab_ide_host_free ;
#line 1568 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_host_free  =    {(unsigned long )(& ide_host_free), (char const   *)(& __kstrtab_ide_host_free)};
#line 1570 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
void ide_host_remove(struct ide_host *host ) 
{ 
  ide_hwif_t *hwif ;
  int i ;

  {
#line 1575
  i = 0;
#line 1575
  goto ldv_39572;
  ldv_39571: ;
#line 1576
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0)) {
    {
#line 1577
    ide_unregister(hwif);
    }
  } else {

  }
#line 1575
  i = i + 1;
  ldv_39572: 
#line 1575
  hwif = host->ports[i];
#line 1575
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0) || i <= 3) {
#line 1577
    goto ldv_39571;
  } else {

  }
  {
#line 1580
  ide_host_free(host);
  }
#line 1581
  return;
}
}
#line 1582 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_host_remove[16U]  = 
#line 1582
  {      'i',      'd',      'e',      '_', 
        'h',      'o',      's',      't', 
        '_',      'r',      'e',      'm', 
        'o',      'v',      'e',      '\000'};
#line 1582
struct kernel_symbol  const  __ksymtab_ide_host_remove ;
#line 1582 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_host_remove  =    {(unsigned long )(& ide_host_remove), (char const   *)(& __kstrtab_ide_host_remove)};
#line 1584 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
void ide_port_scan(ide_hwif_t *hwif ) 
{ 
  int rc ;

  {
  {
#line 1588
  ide_port_apply_params(hwif);
#line 1589
  ide_port_cable_detect(hwif);
#line 1591
  hwif->port_flags = hwif->port_flags | 1UL;
#line 1593
  ide_port_init_devices(hwif);
#line 1595
  rc = ide_probe_port(hwif);
#line 1597
  hwif->port_flags = hwif->port_flags & 0xfffffffffffffffeUL;
  }
#line 1599
  if (rc < 0) {
#line 1600
    return;
  } else {

  }
  {
#line 1602
  hwif->present = 1U;
#line 1604
  ide_port_tune_devices(hwif);
#line 1605
  ide_port_setup_devices(hwif);
#line 1606
  ide_acpi_port_init_devices(hwif);
#line 1607
  hwif_register_devices(hwif);
#line 1608
  ide_proc_port_register_devices(hwif);
  }
#line 1609
  return;
}
}
#line 1610 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
static char const   __kstrtab_ide_port_scan[14U]  = 
#line 1610
  {      'i',      'd',      'e',      '_', 
        'p',      'o',      'r',      't', 
        '_',      's',      'c',      'a', 
        'n',      '\000'};
#line 1610
struct kernel_symbol  const  __ksymtab_ide_port_scan ;
#line 1610 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-probe.c"
struct kernel_symbol  const  __ksymtab_ide_port_scan  =    {(unsigned long )(& ide_port_scan), (char const   *)(& __kstrtab_ide_port_scan)};
#line 631 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
void ldv_dispatch_irq_deregister_39_1(int arg0 ) ;
#line 632
void ldv_dispatch_irq_register_40_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) ;
#line 633
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) ;
#line 635
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) ;
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
void ldv_dispatch_irq_deregister_39_1(int arg0 ) 
{ 


  {
#line 647
  return;
}
}
#line 651 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
void ldv_dispatch_irq_register_40_2(int arg0 , enum irqreturn (*arg1)(int  , void * ) ,
                                    enum irqreturn (*arg2)(int  , void * ) , void *arg3 ) 
{ 
  struct ldv_struct_interrupt_instance_11 *cf_arg_11 ;
  void *tmp ;

  {
  {
#line 654
  tmp = ldv_xmalloc(40UL);
#line 654
  cf_arg_11 = (struct ldv_struct_interrupt_instance_11 *)tmp;
#line 655
  cf_arg_11->arg0 = arg0;
#line 656
  cf_arg_11->arg1 = arg1;
#line 657
  cf_arg_11->arg2 = arg2;
#line 658
  cf_arg_11->arg3 = arg3;
#line 659
  ldv_interrupt_interrupt_instance_11((void *)cf_arg_11);
  }
#line 660
  return;
}
}
#line 664 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
void ldv_free_irq(void *arg0 , int arg1 , void *arg2 ) 
{ 
  int ldv_39_line_line ;

  {
  {
#line 670
  ldv_39_line_line = arg1;
#line 674
  ldv_dispatch_irq_deregister_39_1(ldv_39_line_line);
  }
#line 678
  return;
#line 680
  return;
}
}
#line 685 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
int ldv_request_irq(int arg0 , unsigned int arg1 , enum irqreturn (*arg2)(int  , void * ) ,
                    unsigned long arg3 , char *arg4 , void *arg5 ) 
{ 
  enum irqreturn (*ldv_40_callback_handler)(int  , void * ) ;
  void *ldv_40_data_data ;
  int ldv_40_line_line ;
  enum irqreturn (*ldv_40_thread_thread)(int  , void * ) ;
  int tmp ;

  {
  {
#line 695
  tmp = ldv_undef_int();
  }
#line 695
  if (tmp != 0) {
    {
#line 697
    ldv_assume(arg0 == 0);
#line 698
    ldv_40_line_line = (int )arg1;
#line 699
    ldv_40_callback_handler = arg2;
#line 700
    ldv_40_thread_thread = (enum irqreturn (*)(int  , void * ))0;
#line 701
    ldv_40_data_data = arg5;
#line 705
    ldv_dispatch_irq_register_40_2(ldv_40_line_line, ldv_40_callback_handler, ldv_40_thread_thread,
                                   ldv_40_data_data);
    }
#line 709
    return (arg0);
  } else {
    {
#line 713
    ldv_assume(arg0 != 0);
    }
#line 717
    return (arg0);
  }
#line 720
  return (arg0);
}
}
#line 1277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
__inline static void *kzalloc_node(size_t size , gfp_t flags , int node ) 
{ 
  void *res ;

  {
  {
#line 1281
  ldv_check_alloc_flags(flags);
#line 1282
  res = ldv_zalloc_unknown_size();
#line 1283
  ldv_after_alloc(res);
  }
#line 1284
  return (res);
}
}
#line 1414 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_lock_96___0(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1418
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1419
  return;
}
}
#line 1421 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_unlock_97___0(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1425
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1426
  return;
}
}
#line 1428 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
__inline static int ldv_request_irq_98(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1432
  tmp = request_irq(irq, handler, flags, name, dev);
#line 1432
  ldv_func_res = tmp;
#line 1435
  tmp___0 = ldv_request_irq(ldv_func_res, irq, handler, flags, (char *)name, dev);
  }
#line 1435
  return (tmp___0);
#line 1437
  return (ldv_func_res);
}
}
#line 1440 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_blk_cleanup_queue_99(struct request_queue *ldv_func_arg1 ) 
{ 


  {
  {
#line 1443
  ldv_linux_block_queue_blk_cleanup_queue();
#line 1445
  blk_cleanup_queue(ldv_func_arg1);
  }
#line 1446
  return;
}
}
#line 1448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
__inline static void ldv_init_completion_100(struct completion *x ) 
{ 


  {
  {
#line 1451
  ldv_linux_kernel_sched_completion_init_completion_gendev_rel_comp_of_ide_drive_s();
  }
#line 1452
  return;
}
}
#line 1454 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
__inline static void ldv_init_completion_101(struct completion *x ) 
{ 


  {
  {
#line 1457
  ldv_linux_kernel_sched_completion_init_completion_gendev_rel_comp_of_hwif_s();
  }
#line 1458
  return;
}
}
#line 1460 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_lock_102(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1464
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1465
  return;
}
}
#line 1467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_unlock_103(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1471
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1472
  return;
}
}
#line 1474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_lock_104(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1478
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1479
  return;
}
}
#line 1481 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_unlock_105(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1485
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1486
  return;
}
}
#line 1488 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_wait_for_completion_106(struct completion *ldv_func_arg1 ) 
{ 


  {
  {
#line 1491
  ldv_linux_kernel_sched_completion_wait_for_completion_gendev_rel_comp_of_ide_drive_s();
#line 1493
  wait_for_completion(ldv_func_arg1);
  }
#line 1494
  return;
}
}
#line 1496 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_lock_107(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1500
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1501
  return;
}
}
#line 1503 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_unlock_108(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1507
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1508
  return;
}
}
#line 1510 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_lock_109(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1514
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1515
  return;
}
}
#line 1517 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_free_irq_110(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  {
#line 1520
  free_irq(ldv_func_arg1, ldv_func_arg2);
#line 1523
  ldv_free_irq((void *)0, (int )ldv_func_arg1, ldv_func_arg2);
  }
#line 1524
  return;
}
}
#line 1526 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_wait_for_completion_111(struct completion *ldv_func_arg1 ) 
{ 


  {
  {
#line 1529
  ldv_linux_kernel_sched_completion_wait_for_completion_gendev_rel_comp_of_hwif_s();
#line 1531
  wait_for_completion(ldv_func_arg1);
  }
#line 1532
  return;
}
}
#line 1534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-probe.c.aux"
static void ldv_mutex_unlock_112(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1538
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_cfg_mtx(ldv_func_arg1);
  }
#line 1539
  return;
}
}
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/ioctl.h"
extern void *memdup_user(void const   * , size_t  ) ;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/err.h"
__inline static long PTR_ERR(void const   *ptr ) ;
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;

  {
#line 72
  pao_ID__ = 0;
  {
#line 72
  if (4UL == 1UL) {
#line 72
    goto case_1;
  } else {

  }
#line 72
  if (4UL == 2UL) {
#line 72
    goto case_2;
  } else {

  }
#line 72
  if (4UL == 4UL) {
#line 72
    goto case_4;
  } else {

  }
#line 72
  if (4UL == 8UL) {
#line 72
    goto case_8;
  } else {

  }
#line 72
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
#line 72
  goto ldv_7291;
  case_2: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_7291;
  case_4: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
#line 72
  goto ldv_7291;
  case_8: /* CIL Label */ ;
#line 72
  if (pao_ID__ == 1) {
#line 72
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 72
  if (pao_ID__ == -1) {
#line 72
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 72
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
#line 72
  goto ldv_7291;
  switch_default: /* CIL Label */ 
  {
#line 72
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7291: ;
#line 74
  return;
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/preempt.h"
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
#line 77
  pao_ID__ = 0;
  {
#line 77
  if (4UL == 1UL) {
#line 77
    goto case_1;
  } else {

  }
#line 77
  if (4UL == 2UL) {
#line 77
    goto case_2;
  } else {

  }
#line 77
  if (4UL == 4UL) {
#line 77
    goto case_4;
  } else {

  }
#line 77
  if (4UL == 8UL) {
#line 77
    goto case_8;
  } else {

  }
#line 77
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
#line 77
  goto ldv_7303;
  case_2: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_7303;
  case_4: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
#line 77
  goto ldv_7303;
  case_8: /* CIL Label */ ;
#line 77
  if (pao_ID__ == 1) {
#line 77
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
#line 77
  if (pao_ID__ == -1) {
#line 77
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
#line 77
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
#line 77
  goto ldv_7303;
  switch_default: /* CIL Label */ 
  {
#line 77
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_7303: ;
#line 79
  return;
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/page-flags.h"
__inline static int PageHighMem(struct page  const  *page ) 
{ 


  {
#line 257
  return (0);
}
}
#line 976 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mm.h"
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
#line 978
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 98
  tmp = __builtin_expect(sg->sg_magic != 2271560481UL, 0L);
  }
#line 98
  if (tmp != 0L) {
    {
#line 98
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (98), "i" (12UL));
#line 98
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 99
  tmp___0 = __builtin_expect((long )((int )sg->page_link) & 1L, 0L);
  }
#line 99
  if (tmp___0 != 0L) {
    {
#line 99
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (99), "i" (12UL));
#line 99
    __builtin_unreachable();
    }
  } else {

  }
#line 101
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
#line 224
extern struct scatterlist *sg_next(struct scatterlist * ) ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uaccess.h"
__inline static void pagefault_disable(void) 
{ 


  {
  {
#line 18
  __preempt_count_add(1);
#line 23
  __asm__  volatile   ("": : : "memory");
  }
#line 24
  return;
}
}
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/uaccess.h"
__inline static void pagefault_enable(void) 
{ 


  {
  {
#line 33
  __asm__  volatile   ("": : : "memory");
#line 34
  __preempt_count_sub(1);
  }
#line 35
  return;
}
}
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/highmem.h"
__inline static void *kmap_atomic(struct page *page ) 
{ 
  void *tmp ;

  {
  {
#line 68
  pagefault_disable();
#line 69
  tmp = lowmem_page_address((struct page  const  *)page);
  }
#line 69
  return (tmp);
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/highmem.h"
__inline static void __kunmap_atomic(void *addr ) 
{ 


  {
  {
#line 75
  pagefault_enable();
  }
#line 76
  return;
}
}
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
static void ldv_blk_put_request_97(struct request *ldv_func_arg1 ) ;
#line 805
static struct request *ldv_blk_get_request_96(struct request_queue *ldv_func_arg1 ,
                                              int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 864
extern int blk_rq_map_kern(struct request_queue * , struct request * , void * , unsigned int  ,
                           gfp_t  ) ;
#line 1145 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void ide_pio_bytes(ide_drive_t *drive , struct ide_cmd *cmd , unsigned int write ,
                   unsigned int len ) ;
#line 1147
void ide_finish_cmd(ide_drive_t *drive , struct ide_cmd *cmd , u8 stat ) ;
#line 1159
int taskfile_lib_get_identify(ide_drive_t *drive , u8 *buf ) ;
#line 1359
ide_startstop_t ide_dma_intr(ide_drive_t *drive ) ;
#line 1364
int ide_dma_prepare(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 1500
int ide_set_xfer_rate(ide_drive_t *drive , u8 rate ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
void ide_tf_readback(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_tp_ops  const  *tp_ops ;

  {
  {
#line 29
  hwif = drive->hwif;
#line 30
  tp_ops = hwif->tp_ops;
#line 33
  (*(tp_ops->write_devctl))(hwif, 8);
#line 35
  (*(tp_ops->tf_read))(drive, & cmd->tf, (int )cmd->valid.in.tf);
  }
#line 37
  if ((int )cmd->tf_flags & 1) {
    {
#line 38
    (*(tp_ops->write_devctl))(hwif, 136);
#line 40
    (*(tp_ops->tf_read))(drive, & cmd->hob, (int )cmd->valid.in.hob);
    }
  } else {

  }
#line 42
  return;
}
}
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
void ide_tf_dump(char const   *s , struct ide_cmd *cmd ) 
{ 


  {
#line 46
  return;
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
int taskfile_lib_get_identify(ide_drive_t *drive , u8 *buf ) 
{ 
  struct ide_cmd cmd ;
  int tmp ;

  {
  {
#line 61
  __memset((void *)(& cmd), 0, 80UL);
#line 62
  cmd.tf.nsect = 1U;
  }
#line 63
  if ((unsigned int )drive->media == 32U) {
#line 64
    cmd.tf.__annonCompField84.command = 236U;
  } else {
#line 66
    cmd.tf.__annonCompField84.command = 161U;
  }
  {
#line 67
  cmd.valid.out.tf = 126U;
#line 68
  cmd.valid.in.tf = 124U;
#line 69
  cmd.protocol = 2;
#line 71
  tmp = ide_raw_taskfile(drive, & cmd, buf, 1);
  }
#line 71
  return (tmp);
}
}
#line 74
static ide_startstop_t task_no_data_intr(ide_drive_t *drive ) ;
#line 75
static ide_startstop_t pre_task_out_intr(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 76
static ide_startstop_t task_pio_intr(ide_drive_t *drive ) ;
#line 78 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
ide_startstop_t do_rw_taskfile(ide_drive_t *drive , struct ide_cmd *orig_cmd ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_cmd *cmd ;
  struct ide_taskfile *tf ;
  ide_handler_t *handler ;
  struct ide_tp_ops  const  *tp_ops ;
  struct ide_dma_ops  const  *dma_ops___0 ;
  u8 data[2U] ;
  u8 HIHI ;
  ide_startstop_t tmp ;
  int tmp___0 ;

  {
#line 80
  hwif = drive->hwif;
#line 81
  cmd = & hwif->cmd;
#line 82
  tf = & cmd->tf;
#line 83
  handler = (ide_handler_t *)0;
#line 84
  tp_ops = hwif->tp_ops;
#line 85
  dma_ops___0 = hwif->dma_ops;
#line 87
  if ((orig_cmd->protocol == 2 && ((int )orig_cmd->tf_flags & 128) != 0) && (unsigned int )drive->mult_count == 0U) {
    {
#line 90
    printk("\v%s: multimode not set!\n", (char *)(& drive->name));
    }
#line 91
    return (0);
  } else {

  }
#line 94
  if ((int )orig_cmd->ftf_flags & 1) {
#line 95
    orig_cmd->ftf_flags = (u8 )((unsigned int )orig_cmd->ftf_flags | 2U);
  } else {

  }
  {
#line 97
  __memcpy((void *)cmd, (void const   *)orig_cmd, 80UL);
  }
#line 99
  if (((int )cmd->tf_flags & 8) == 0) {
    {
#line 100
    ide_tf_dump((char const   *)(& drive->name), cmd);
#line 101
    (*(tp_ops->write_devctl))(hwif, 8);
    }
#line 103
    if (((int )cmd->ftf_flags & 4) != 0) {
      {
#line 104
      data[0] = cmd->tf.data;
#line 104
      data[1] = cmd->hob.data;
#line 106
      (*(tp_ops->output_data))(drive, cmd, (void *)(& data), 2U);
      }
    } else {

    }
#line 109
    if (((int )cmd->valid.out.tf & 64) != 0) {
#line 110
      HIHI = (int )cmd->tf_flags & 1 ? 224U : 239U;
#line 113
      if (((int )cmd->ftf_flags & 1) == 0) {
#line 114
        cmd->tf.device = (u8 )((int )cmd->tf.device & (int )HIHI);
      } else {

      }
#line 115
      cmd->tf.device = (u8 )((int )cmd->tf.device | (int )drive->select);
    } else {

    }
    {
#line 118
    (*(tp_ops->tf_load))(drive, & cmd->hob, (int )cmd->valid.out.hob);
#line 119
    (*(tp_ops->tf_load))(drive, & cmd->tf, (int )cmd->valid.out.tf);
    }
  } else {

  }
  {
#line 123
  if (cmd->protocol == 2) {
#line 123
    goto case_2;
  } else {

  }
#line 131
  if (cmd->protocol == 1) {
#line 131
    goto case_1;
  } else {

  }
#line 136
  if (cmd->protocol == 3) {
#line 136
    goto case_3;
  } else {

  }
#line 142
  goto switch_default;
  case_2: /* CIL Label */ ;
#line 124
  if (((int )cmd->tf_flags & 2) != 0) {
    {
#line 125
    (*(tp_ops->exec_command))(hwif, (int )tf->__annonCompField84.command);
#line 126
    __const_udelay(2000UL);
#line 127
    tmp = pre_task_out_intr(drive, cmd);
    }
#line 127
    return (tmp);
  } else {

  }
#line 129
  handler = & task_pio_intr;
  case_1: /* CIL Label */ ;
#line 132
  if ((unsigned long )handler == (unsigned long )((ide_handler_t *)0)) {
#line 133
    handler = & task_no_data_intr;
  } else {

  }
  {
#line 134
  ide_execute_command(drive, cmd, handler, 7500U);
  }
#line 135
  return (1);
  case_3: /* CIL Label */ 
  {
#line 137
  tmp___0 = ide_dma_prepare(drive, cmd);
  }
#line 137
  if (tmp___0 != 0) {
#line 138
    return (0);
  } else {

  }
  {
#line 139
  hwif->expiry = (int (*)(ide_drive_t * ))dma_ops___0->dma_timer_expiry;
#line 140
  ide_execute_command(drive, cmd, & ide_dma_intr, 5000U);
#line 141
  (*(dma_ops___0->dma_start))(drive);
  }
  switch_default: /* CIL Label */ ;
#line 143
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 146 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static char const   __kstrtab_do_rw_taskfile[15U]  = 
#line 146
  {      'd',      'o',      '_',      'r', 
        'w',      '_',      't',      'a', 
        's',      'k',      'f',      'i', 
        'l',      'e',      '\000'};
#line 146
struct kernel_symbol  const  __ksymtab_do_rw_taskfile ;
#line 146 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
struct kernel_symbol  const  __ksymtab_do_rw_taskfile  =    {(unsigned long )(& do_rw_taskfile), (char const   *)(& __kstrtab_do_rw_taskfile)};
#line 148 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static ide_startstop_t task_no_data_intr(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_cmd *cmd ;
  struct ide_taskfile *tf ;
  int custom ;
  int retries ;
  u8 stat ;
  int tmp ;
  u8 tmp___0 ;
  ide_startstop_t tmp___1 ;
  struct request *rq ;

  {
#line 150
  hwif = drive->hwif;
#line 151
  cmd = & hwif->cmd;
#line 152
  tf = & cmd->tf;
#line 153
  custom = ((int )cmd->tf_flags & 4) != 0;
#line 154
  retries = custom != 0 && (unsigned int )tf->__annonCompField84.command == 145U ? 5 : 1;
  ldv_38332: 
  {
#line 160
  stat = (*((hwif->tp_ops)->read_status))(hwif);
  }
#line 161
  if ((int )((signed char )stat) >= 0) {
#line 162
    goto ldv_38331;
  } else {
#line 161
    tmp = retries;
#line 161
    retries = retries - 1;
#line 161
    if (tmp == 0) {
#line 162
      goto ldv_38331;
    } else {

    }
  }
  {
#line 163
  __const_udelay(42950UL);
  }
#line 164
  goto ldv_38332;
  ldv_38331: ;
#line 166
  if (((int )stat & 201) != 64) {
#line 167
    if (custom != 0 && (unsigned int )tf->__annonCompField84.command == 198U) {
      {
#line 168
      tmp___0 = 0U;
#line 168
      drive->mult_count = tmp___0;
#line 168
      drive->mult_req = tmp___0;
#line 169
      drive->special_flags = (u8 )((unsigned int )drive->special_flags | 2U);
#line 170
      ide_dump_status(drive, "task_no_data_intr", (int )stat);
      }
#line 171
      return (0);
    } else
#line 172
    if (custom != 0 && (unsigned int )tf->__annonCompField84.command == 145U) {
#line 173
      if (((int )stat & 9) == 0) {
        {
#line 174
        ide_set_handler(drive, & task_no_data_intr, 7500U);
        }
#line 176
        return (1);
      } else {

      }
    } else {

    }
    {
#line 179
    tmp___1 = ide_error(drive, "task_no_data_intr", (int )stat);
    }
#line 179
    return (tmp___1);
  } else {

  }
#line 182
  if (custom != 0 && (unsigned int )tf->__annonCompField84.command == 198U) {
#line 183
    drive->mult_count = drive->mult_req;
  } else {

  }
#line 185
  if ((custom == 0 || (unsigned int )tf->__annonCompField84.command == 225U) || (unsigned int )tf->__annonCompField84.command == 229U) {
#line 187
    rq = hwif->rq;
#line 189
    if ((unsigned int )rq->cmd_type - 4U <= 1U) {
      {
#line 190
      ide_complete_pm_rq(drive, rq);
      }
    } else {
      {
#line 192
      ide_finish_cmd(drive, cmd, (int )stat);
      }
    }
  } else {

  }
#line 195
  return (0);
}
}
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static u8 wait_drive_not_busy(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  int retries ;
  u8 stat ;

  {
#line 200
  hwif = drive->hwif;
#line 208
  retries = 0;
#line 208
  goto ldv_38343;
  ldv_38342: 
  {
#line 209
  stat = (*((hwif->tp_ops)->read_status))(hwif);
  }
#line 211
  if ((int )((signed char )stat) < 0) {
    {
#line 212
    __const_udelay(42950UL);
    }
  } else {
#line 214
    goto ldv_38341;
  }
#line 208
  retries = retries + 1;
  ldv_38343: ;
#line 208
  if (retries <= 999) {
#line 210
    goto ldv_38342;
  } else {

  }
  ldv_38341: ;
#line 217
  if ((int )((signed char )stat) < 0) {
    {
#line 218
    printk("\v%s: drive still BUSY!\n", (char *)(& drive->name));
    }
  } else {

  }
#line 220
  return (stat);
}
}
#line 271
extern void __compiletime_assert_271(void) ;
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
void ide_pio_bytes(ide_drive_t *drive , struct ide_cmd *cmd , unsigned int write ,
                   unsigned int len ) 
{ 
  ide_hwif_t *hwif ;
  struct scatterlist *sg ;
  struct scatterlist *cursg ;
  unsigned long flags ;
  struct page *page ;
  unsigned int offset ;
  u8 *buf ;
  struct scatterlist *tmp ;
  unsigned int nr_bytes ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  int page_is_high ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  void *tmp___0 ;
  struct scatterlist *tmp___1 ;
  bool __cond ;
  int tmp___2 ;

  {
#line 226
  hwif = drive->hwif;
#line 227
  sg = hwif->sg_table;
#line 228
  cursg = cmd->cursg;
#line 229
  flags = flags;
#line 234
  cursg = cmd->cursg;
#line 235
  if ((unsigned long )cursg == (unsigned long )((struct scatterlist *)0)) {
#line 236
    tmp = sg;
#line 236
    cmd->cursg = tmp;
#line 236
    cursg = tmp;
  } else {

  }
#line 238
  goto ldv_38383;
  ldv_38382: 
  {
#line 239
  _min1 = len;
#line 239
  _min2 = cursg->length - cmd->cursg_ofs;
#line 239
  nr_bytes = _min1 < _min2 ? _min1 : _min2;
#line 242
  page = sg_page(cursg);
#line 243
  offset = cursg->offset + cmd->cursg_ofs;
#line 246
  page = (struct page *)-24189255811072L + ((unsigned long )(((long )page + 24189255811072L) / 64L) + (unsigned long )(offset >> 12));
#line 247
  offset = offset & 4095U;
#line 249
  __min1 = nr_bytes;
#line 249
  __min2 = 4096U - offset;
#line 249
  nr_bytes = __min1 < __min2 ? __min1 : __min2;
#line 251
  page_is_high = PageHighMem((struct page  const  *)page);
  }
#line 252
  if (page_is_high != 0) {
    {
#line 253
    flags = arch_local_irq_save();
#line 253
    trace_hardirqs_off();
    }
  } else {

  }
  {
#line 255
  tmp___0 = kmap_atomic(page);
#line 255
  buf = (u8 *)tmp___0 + (unsigned long )offset;
#line 257
  cmd->nleft = cmd->nleft - nr_bytes;
#line 258
  cmd->cursg_ofs = cmd->cursg_ofs + nr_bytes;
  }
#line 260
  if (cmd->cursg_ofs == cursg->length) {
    {
#line 261
    tmp___1 = sg_next(cmd->cursg);
#line 261
    cmd->cursg = tmp___1;
#line 261
    cursg = tmp___1;
#line 262
    cmd->cursg_ofs = 0U;
    }
  } else {

  }
#line 266
  if (write != 0U) {
    {
#line 267
    (*((hwif->tp_ops)->output_data))(drive, cmd, (void *)buf, nr_bytes);
    }
  } else {
    {
#line 269
    (*((hwif->tp_ops)->input_data))(drive, cmd, (void *)buf, nr_bytes);
    }
  }
#line 271
  __cond = 0;
#line 271
  if ((int )__cond) {
    {
#line 271
    __compiletime_assert_271();
    }
  } else {

  }
  {
#line 271
  __kunmap_atomic((void *)buf);
  }
#line 273
  if (page_is_high != 0) {
    {
#line 274
    tmp___2 = arch_irqs_disabled_flags(flags);
    }
#line 274
    if (tmp___2 != 0) {
      {
#line 274
      arch_local_irq_restore(flags);
#line 274
      trace_hardirqs_off();
      }
    } else {
      {
#line 274
      trace_hardirqs_on();
#line 274
      arch_local_irq_restore(flags);
      }
    }
  } else {

  }
#line 276
  len = len - nr_bytes;
  ldv_38383: ;
#line 238
  if (len != 0U) {
#line 240
    goto ldv_38382;
  } else {

  }

#line 245
  return;
}
}
#line 279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static char const   __kstrtab_ide_pio_bytes[14U]  = 
#line 279
  {      'i',      'd',      'e',      '_', 
        'p',      'i',      'o',      '_', 
        'b',      'y',      't',      'e', 
        's',      '\000'};
#line 279
struct kernel_symbol  const  __ksymtab_ide_pio_bytes ;
#line 279 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
struct kernel_symbol  const  __ksymtab_ide_pio_bytes  =    {(unsigned long )(& ide_pio_bytes), (char const   *)(& __kstrtab_ide_pio_bytes)};
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static void ide_pio_datablock(ide_drive_t *drive , struct ide_cmd *cmd , unsigned int write ) 
{ 
  unsigned int nr_bytes ;
  u8 saved_io_32bit ;
  unsigned int __min1 ;
  unsigned int __min2 ;

  {
#line 286
  saved_io_32bit = drive->io_32bit;
#line 288
  if (((int )cmd->tf_flags & 64) != 0) {
#line 289
    (cmd->rq)->errors = 0;
  } else {

  }
#line 291
  if (((int )cmd->tf_flags & 16) != 0) {
#line 292
    drive->io_32bit = 0U;
  } else {

  }
  {
#line 294
  touch_softlockup_watchdog();
  }
#line 296
  if (((int )cmd->tf_flags & 128) != 0) {
#line 297
    __min1 = cmd->nleft;
#line 297
    __min2 = (unsigned int )((int )drive->mult_count << 9);
#line 297
    nr_bytes = __min1 < __min2 ? __min1 : __min2;
  } else {
#line 299
    nr_bytes = 512U;
  }
  {
#line 301
  ide_pio_bytes(drive, cmd, write, nr_bytes);
#line 303
  drive->io_32bit = saved_io_32bit;
  }
#line 304
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static void ide_error_cmd(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  int nr_bytes ;

  {
#line 308
  if (((int )cmd->tf_flags & 64) != 0) {
#line 309
    nr_bytes = (int )(cmd->nbytes - cmd->nleft);
#line 311
    if (cmd->protocol == 2 && (((int )cmd->tf_flags & 2) != 0 || cmd->nleft == 0U)) {
#line 313
      if (((int )cmd->tf_flags & 128) != 0) {
#line 314
        nr_bytes = nr_bytes - ((int )drive->mult_count << 9);
      } else {
#line 316
        nr_bytes = nr_bytes + -512;
      }
    } else {

    }
#line 319
    if (nr_bytes > 0) {
      {
#line 320
      ide_complete_rq(drive, 0, (unsigned int )nr_bytes);
      }
    } else {

    }
  } else {

  }
#line 322
  return;
}
}
#line 324 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
void ide_finish_cmd(ide_drive_t *drive , struct ide_cmd *cmd , u8 stat ) 
{ 
  struct request *rq ;
  u8 err ;
  u8 tmp ;
  u8 nsect ;
  u8 set_xfer ;
  unsigned int tmp___0 ;

  {
  {
#line 326
  rq = (drive->hwif)->rq;
#line 327
  tmp = ide_read_error(drive);
#line 327
  err = tmp;
#line 327
  nsect = cmd->tf.nsect;
#line 328
  set_xfer = ((int )cmd->tf_flags & 256) != 0;
#line 330
  ide_complete_cmd(drive, cmd, (int )stat, (int )err);
#line 331
  rq->errors = (int )err;
  }
#line 333
  if ((unsigned int )err == 0U && (unsigned int )set_xfer != 0U) {
    {
#line 334
    ide_set_xfer_rate(drive, (int )nsect);
#line 335
    ide_driveid_update(drive);
    }
  } else {

  }
  {
#line 338
  tmp___0 = blk_rq_bytes((struct request  const  *)rq);
#line 338
  ide_complete_rq(drive, (unsigned int )err != 0U ? -5 : 0, tmp___0);
  }
#line 339
  return;
}
}
#line 344 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static ide_startstop_t task_pio_intr(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_cmd *cmd ;
  u8 stat ;
  u8 tmp ;
  u8 write ;
  unsigned int tmp___0 ;
  ide_startstop_t tmp___1 ;

  {
  {
#line 346
  hwif = drive->hwif;
#line 347
  cmd = & (drive->hwif)->cmd;
#line 348
  tmp = (*((hwif->tp_ops)->read_status))(hwif);
#line 348
  stat = tmp;
#line 349
  write = ((int )cmd->tf_flags & 2) != 0;
  }
#line 351
  if ((unsigned int )write == 0U) {
#line 353
    if ((int )stat & 1) {
#line 354
      goto out_err;
    } else {

    }
#line 357
    if (((int )stat & 8) == 0) {
#line 359
      if (((int )stat & 192) == 64) {
#line 360
        goto out_end;
      } else {

      }
#line 363
      goto out_wait;
    } else {

    }
  } else {
#line 366
    if (((unsigned int )stat & ((unsigned int )drive->bad_wstat | 80U)) != 80U) {
#line 367
      goto out_err;
    } else {

    }
#line 370
    if ((((int )stat & 8) == 0) ^ (cmd->nleft == 0U)) {
#line 371
      goto out_err;
    } else {

    }
  }
#line 374
  if ((unsigned int )write != 0U && cmd->nleft == 0U) {
#line 375
    goto out_end;
  } else {

  }
  {
#line 378
  ide_pio_datablock(drive, cmd, (unsigned int )write);
  }
#line 381
  if ((unsigned int )write == 0U && cmd->nleft == 0U) {
    {
#line 382
    stat = wait_drive_not_busy(drive);
    }
#line 383
    if (((int )stat & 137) != 0) {
#line 384
      goto out_err;
    } else {

    }
#line 386
    goto out_end;
  } else {

  }
  out_wait: 
  {
#line 390
  ide_set_handler(drive, & task_pio_intr, 7500U);
  }
#line 391
  return (1);
  out_end: ;
#line 393
  if (((int )cmd->tf_flags & 64) == 0) {
    {
#line 394
    ide_finish_cmd(drive, cmd, (int )stat);
    }
  } else {
    {
#line 396
    tmp___0 = blk_rq_sectors((struct request  const  *)cmd->rq);
#line 396
    ide_complete_rq(drive, 0, tmp___0 << 9);
    }
  }
#line 397
  return (0);
  out_err: 
  {
#line 399
  ide_error_cmd(drive, cmd);
#line 400
  tmp___1 = ide_error(drive, "task_pio_intr", (int )stat);
  }
#line 400
  return (tmp___1);
}
}
#line 403 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static ide_startstop_t pre_task_out_intr(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  ide_startstop_t startstop ;
  int tmp ;

  {
  {
#line 408
  tmp = ide_wait_stat(& startstop, drive, 8, (int )drive->bad_wstat, 250UL);
  }
#line 408
  if (tmp != 0) {
    {
#line 410
    printk("\v%s: no DRQ after issuing %sWRITE%s\n", (char *)(& drive->name), ((int )cmd->tf_flags & 128) != 0 ? (char *)"MULT" : (char *)"",
           (drive->dev_flags & 2097152UL) != 0UL ? (char *)"_EXT" : (char *)"");
    }
#line 413
    return (startstop);
  } else {

  }
#line 416
  if ((drive->dev_flags & 4UL) == 0UL) {
    {
#line 417
    arch_local_irq_disable();
#line 417
    trace_hardirqs_off();
    }
  } else {

  }
  {
#line 419
  ide_set_handler(drive, & task_pio_intr, 7500U);
#line 421
  ide_pio_datablock(drive, cmd, 1U);
  }
#line 423
  return (1);
}
}
#line 426 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
int ide_raw_taskfile(ide_drive_t *drive , struct ide_cmd *cmd , u8 *buf , u16 nsect ) 
{ 
  struct request *rq ;
  int error ;
  int rw ;

  {
  {
#line 431
  rw = ((int )cmd->tf_flags & 2) != 0;
#line 433
  rq = ldv_blk_get_request_96(drive->queue, rw, 16U);
#line 434
  rq->cmd_type = 8;
  }
#line 442
  if ((unsigned int )nsect != 0U) {
    {
#line 443
    error = blk_rq_map_kern(drive->queue, rq, (void *)buf, (unsigned int )((int )nsect * 512),
                            16U);
    }
#line 445
    if (error != 0) {
#line 446
      goto put_req;
    } else {

    }
  } else {

  }
  {
#line 449
  rq->special = (void *)cmd;
#line 450
  cmd->rq = rq;
#line 452
  error = blk_execute_rq(drive->queue, (struct gendisk *)0, rq, 0);
  }
  put_req: 
  {
#line 455
  ldv_blk_put_request_97(rq);
  }
#line 456
  return (error);
}
}
#line 458 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static char const   __kstrtab_ide_raw_taskfile[17U]  = 
#line 458
  {      'i',      'd',      'e',      '_', 
        'r',      'a',      'w',      '_', 
        't',      'a',      's',      'k', 
        'f',      'i',      'l',      'e', 
        '\000'};
#line 458
struct kernel_symbol  const  __ksymtab_ide_raw_taskfile ;
#line 458 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
struct kernel_symbol  const  __ksymtab_ide_raw_taskfile  =    {(unsigned long )(& ide_raw_taskfile), (char const   *)(& __kstrtab_ide_raw_taskfile)};
#line 460 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
int ide_no_data_taskfile(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  int tmp ;

  {
  {
#line 462
  cmd->protocol = 1;
#line 464
  tmp = ide_raw_taskfile(drive, cmd, (u8 *)0U, 0);
  }
#line 464
  return (tmp);
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
static char const   __kstrtab_ide_no_data_taskfile[21U]  = 
#line 466
  {      'i',      'd',      'e',      '_', 
        'n',      'o',      '_',      'd', 
        'a',      't',      'a',      '_', 
        't',      'a',      's',      'k', 
        'f',      'i',      'l',      'e', 
        '\000'};
#line 466
struct kernel_symbol  const  __ksymtab_ide_no_data_taskfile ;
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
struct kernel_symbol  const  __ksymtab_ide_no_data_taskfile  =    {(unsigned long )(& ide_no_data_taskfile), (char const   *)(& __kstrtab_ide_no_data_taskfile)};
#line 469 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-taskfile.c"
int ide_taskfile_ioctl(ide_drive_t *drive , unsigned long arg ) 
{ 
  ide_task_request_t *req_task ;
  struct ide_cmd cmd ;
  u8 *outbuf ;
  u8 *inbuf ;
  u8 *data_buf ;
  int err ;
  int tasksize ;
  unsigned int taskin ;
  unsigned int taskout ;
  u16 nsect ;
  char *buf ;
  void *tmp ;
  long tmp___0 ;
  bool tmp___1 ;
  int outtotal ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  int intotal ;
  void *tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int outtotal___0 ;
  unsigned long tmp___7 ;
  int intotal___0 ;
  unsigned long tmp___8 ;

  {
  {
#line 473
  outbuf = (u8 *)0U;
#line 474
  inbuf = (u8 *)0U;
#line 475
  data_buf = (u8 *)0U;
#line 476
  err = 0;
#line 477
  tasksize = 48;
#line 478
  taskin = 0U;
#line 479
  taskout = 0U;
#line 480
  nsect = 0U;
#line 481
  buf = (char *)arg;
#line 483
  tmp = memdup_user((void const   *)buf, (size_t )tasksize);
#line 483
  req_task = (ide_task_request_t *)tmp;
#line 484
  tmp___1 = IS_ERR((void const   *)req_task);
  }
#line 484
  if ((int )tmp___1) {
    {
#line 485
    tmp___0 = PTR_ERR((void const   *)req_task);
    }
#line 485
    return ((int )tmp___0);
  } else {

  }
#line 487
  taskout = (unsigned int )req_task->out_size;
#line 488
  taskin = (unsigned int )req_task->in_size;
#line 490
  if (taskin > 65536U || taskout > 65536U) {
#line 491
    err = -22;
#line 492
    goto abort;
  } else {

  }
#line 495
  if (taskout != 0U) {
    {
#line 496
    outtotal = tasksize;
#line 497
    tmp___2 = kzalloc((size_t )taskout, 208U);
#line 497
    outbuf = (u8 *)tmp___2;
    }
#line 498
    if ((unsigned long )outbuf == (unsigned long )((u8 *)0U)) {
#line 499
      err = -12;
#line 500
      goto abort;
    } else {

    }
    {
#line 502
    tmp___3 = copy_from_user((void *)outbuf, (void const   *)buf + (unsigned long )outtotal,
                             (unsigned long )taskout);
    }
#line 502
    if (tmp___3 != 0UL) {
#line 503
      err = -14;
#line 504
      goto abort;
    } else {

    }
  } else {

  }
#line 508
  if (taskin != 0U) {
    {
#line 509
    intotal = (int )((unsigned int )tasksize + taskout);
#line 510
    tmp___4 = kzalloc((size_t )taskin, 208U);
#line 510
    inbuf = (u8 *)tmp___4;
    }
#line 511
    if ((unsigned long )inbuf == (unsigned long )((u8 *)0U)) {
#line 512
      err = -12;
#line 513
      goto abort;
    } else {

    }
    {
#line 515
    tmp___5 = copy_from_user((void *)inbuf, (void const   *)buf + (unsigned long )intotal,
                             (unsigned long )taskin);
    }
#line 515
    if (tmp___5 != 0UL) {
#line 516
      err = -14;
#line 517
      goto abort;
    } else {

    }
  } else {

  }
  {
#line 521
  __memset((void *)(& cmd), 0, 80UL);
#line 523
  __memcpy((void *)(& cmd.hob), (void const   *)(& req_task->hob_ports), 6UL);
#line 524
  __memcpy((void *)(& cmd.tf), (void const   *)(& req_task->io_ports), 8UL);
#line 526
  cmd.valid.out.tf = 64U;
#line 527
  cmd.valid.in.tf = 124U;
#line 528
  cmd.tf_flags = 16U;
  }
#line 530
  if ((drive->dev_flags & 2097152UL) != 0UL) {
#line 531
    cmd.tf_flags = (u16 )((unsigned int )cmd.tf_flags | 1U);
#line 532
    cmd.valid.in.hob = 62U;
  } else {

  }
#line 535
  if ((unsigned int )req_task->out_flags.all != 0U) {
#line 536
    cmd.ftf_flags = (u8 )((unsigned int )cmd.ftf_flags | 1U);
#line 538
    if ((unsigned int )*((unsigned char *)req_task + 16UL) != 0U) {
#line 539
      cmd.ftf_flags = (u8 )((unsigned int )cmd.ftf_flags | 4U);
    } else {

    }
#line 541
    if ((unsigned int )*((unsigned char *)req_task + 17UL) != 0U) {
#line 542
      cmd.valid.out.hob = (u8 )((unsigned int )cmd.valid.out.hob | 4U);
    } else {

    }
#line 543
    if ((unsigned int )*((unsigned char *)req_task + 17UL) != 0U) {
#line 544
      cmd.valid.out.hob = (u8 )((unsigned int )cmd.valid.out.hob | 8U);
    } else {

    }
#line 545
    if ((unsigned int )*((unsigned char *)req_task + 17UL) != 0U) {
#line 546
      cmd.valid.out.hob = (u8 )((unsigned int )cmd.valid.out.hob | 16U);
    } else {

    }
#line 547
    if ((unsigned int )*((unsigned char *)req_task + 17UL) != 0U) {
#line 548
      cmd.valid.out.hob = (u8 )((unsigned int )cmd.valid.out.hob | 32U);
    } else {

    }
#line 550
    if ((unsigned int )*((unsigned char *)req_task + 16UL) != 0U) {
#line 551
      cmd.valid.out.tf = (u8 )((unsigned int )cmd.valid.out.tf | 2U);
    } else {

    }
#line 552
    if ((unsigned int )*((unsigned char *)req_task + 16UL) != 0U) {
#line 553
      cmd.valid.out.tf = (u8 )((unsigned int )cmd.valid.out.tf | 4U);
    } else {

    }
#line 554
    if ((unsigned int )*((unsigned char *)req_task + 16UL) != 0U) {
#line 555
      cmd.valid.out.tf = (u8 )((unsigned int )cmd.valid.out.tf | 8U);
    } else {

    }
#line 556
    if ((unsigned int )*((unsigned char *)req_task + 16UL) != 0U) {
#line 557
      cmd.valid.out.tf = (u8 )((unsigned int )cmd.valid.out.tf | 16U);
    } else {

    }
#line 558
    if ((unsigned int )*((unsigned char *)req_task + 16UL) != 0U) {
#line 559
      cmd.valid.out.tf = (u8 )((unsigned int )cmd.valid.out.tf | 32U);
    } else {

    }
  } else {
#line 561
    cmd.valid.out.tf = (u8 )((unsigned int )cmd.valid.out.tf | 62U);
#line 562
    if ((int )cmd.tf_flags & 1) {
#line 563
      cmd.valid.out.hob = (u8 )((unsigned int )cmd.valid.out.hob | 62U);
    } else {

    }
  }
#line 566
  if ((unsigned int )*((unsigned char *)req_task + 20UL) != 0U) {
#line 567
    cmd.ftf_flags = (u8 )((unsigned int )cmd.ftf_flags | 8U);
  } else {

  }
#line 569
  if (req_task->req_cmd == 4) {
#line 571
    if (req_task->data_phase == 128 || req_task->data_phase == 32) {
#line 573
      cmd.tf_flags = (u16 )((unsigned int )cmd.tf_flags | 2U);
    } else {

    }
  } else {

  }
#line 576
  cmd.protocol = 3;
  {
#line 579
  if (req_task->data_phase == 8) {
#line 579
    goto case_8;
  } else {

  }
#line 589
  if (req_task->data_phase == 4) {
#line 589
    goto case_4;
  } else {

  }
#line 592
  if (req_task->data_phase == 256) {
#line 592
    goto case_256;
  } else {

  }
#line 593
  if (req_task->data_phase == 64) {
#line 593
    goto case_64;
  } else {

  }
#line 598
  if (req_task->data_phase == 2) {
#line 598
    goto case_2;
  } else {

  }
#line 608
  if (req_task->data_phase == 1) {
#line 608
    goto case_1;
  } else {

  }
#line 611
  if (req_task->data_phase == 128) {
#line 611
    goto case_128;
  } else {

  }
#line 612
  if (req_task->data_phase == 32) {
#line 612
    goto case_32;
  } else {

  }
#line 616
  if (req_task->data_phase == 0) {
#line 616
    goto case_0;
  } else {

  }
#line 619
  goto switch_default;
  case_8: /* CIL Label */ ;
#line 580
  if ((unsigned int )drive->mult_count == 0U) {
    {
#line 582
    printk("\v%s: %s Multimode Write multcount is not set\n", (char *)(& drive->name),
           "ide_taskfile_ioctl");
#line 584
    err = -1;
    }
#line 585
    goto abort;
  } else {

  }
#line 587
  cmd.tf_flags = (u16 )((unsigned int )cmd.tf_flags | 128U);
  case_4: /* CIL Label */ 
#line 590
  cmd.protocol = 2;
  case_256: /* CIL Label */ ;
  case_64: /* CIL Label */ 
#line 594
  cmd.tf_flags = (u16 )((unsigned int )cmd.tf_flags | 2U);
#line 595
  nsect = (u16 )(taskout / 512U);
#line 596
  data_buf = outbuf;
#line 597
  goto ldv_38490;
  case_2: /* CIL Label */ ;
#line 599
  if ((unsigned int )drive->mult_count == 0U) {
    {
#line 601
    printk("\v%s: %s Multimode Read multcount is not set\n", (char *)(& drive->name),
           "ide_taskfile_ioctl");
#line 603
    err = -1;
    }
#line 604
    goto abort;
  } else {

  }
#line 606
  cmd.tf_flags = (u16 )((unsigned int )cmd.tf_flags | 128U);
  case_1: /* CIL Label */ 
#line 609
  cmd.protocol = 2;
  case_128: /* CIL Label */ ;
  case_32: /* CIL Label */ 
#line 613
  nsect = (u16 )(taskin / 512U);
#line 614
  data_buf = inbuf;
#line 615
  goto ldv_38490;
  case_0: /* CIL Label */ 
#line 617
  cmd.protocol = 1;
#line 618
  goto ldv_38490;
  switch_default: /* CIL Label */ 
#line 620
  err = -14;
#line 621
  goto abort;
  switch_break: /* CIL Label */ ;
  }
  ldv_38490: ;
#line 624
  if (req_task->req_cmd == 0) {
#line 625
    nsect = 0U;
  } else
#line 626
  if ((unsigned int )nsect == 0U) {
#line 627
    nsect = (u16 )((int )((short )((int )cmd.hob.nsect << 8)) | (int )((short )cmd.tf.nsect));
#line 629
    if ((unsigned int )nsect == 0U) {
      {
#line 630
      printk("\v%s: in/out command without data\n", (char *)(& drive->name));
#line 632
      err = -14;
      }
#line 633
      goto abort;
    } else {

    }
  } else {

  }
  {
#line 637
  err = ide_raw_taskfile(drive, & cmd, data_buf, (int )nsect);
#line 639
  __memcpy((void *)(& req_task->hob_ports), (void const   *)(& cmd.hob), 6UL);
#line 640
  __memcpy((void *)(& req_task->io_ports), (void const   *)(& cmd.tf), 8UL);
  }
#line 642
  if (((int )cmd.ftf_flags & 2) != 0 && (unsigned int )req_task->in_flags.all == 0U) {
#line 644
    req_task->in_flags.all = 254U;
#line 645
    if ((drive->dev_flags & 2097152UL) != 0UL) {
#line 646
      req_task->in_flags.all = (unsigned int )req_task->in_flags.all | 15360U;
    } else {

    }
  } else {

  }
  {
#line 649
  tmp___6 = copy_to_user((void *)buf, (void const   *)req_task, (unsigned long )tasksize);
  }
#line 649
  if (tmp___6 != 0UL) {
#line 650
    err = -14;
#line 651
    goto abort;
  } else {

  }
#line 653
  if (taskout != 0U) {
    {
#line 654
    outtotal___0 = tasksize;
#line 655
    tmp___7 = copy_to_user((void *)buf + (unsigned long )outtotal___0, (void const   *)outbuf,
                           (unsigned long )taskout);
    }
#line 655
    if (tmp___7 != 0UL) {
#line 656
      err = -14;
#line 657
      goto abort;
    } else {

    }
  } else {

  }
#line 660
  if (taskin != 0U) {
    {
#line 661
    intotal___0 = (int )((unsigned int )tasksize + taskout);
#line 662
    tmp___8 = copy_to_user((void *)buf + (unsigned long )intotal___0, (void const   *)inbuf,
                           (unsigned long )taskin);
    }
#line 662
    if (tmp___8 != 0UL) {
#line 663
      err = -14;
#line 664
      goto abort;
    } else {

    }
  } else {

  }
  abort: 
  {
#line 668
  kfree((void const   *)req_task);
#line 669
  kfree((void const   *)outbuf);
#line 670
  kfree((void const   *)inbuf);
  }
#line 672
  return (err);
}
}
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-taskfile.c.aux"
static struct request *ldv_blk_get_request_96(struct request_queue *ldv_func_arg1 ,
                                              int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1330
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1330
  return (tmp);
}
}
#line 1333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-taskfile.c.aux"
static void ldv_blk_put_request_97(struct request *ldv_func_arg1 ) 
{ 


  {
  {
#line 1336
  ldv_linux_block_request_put_blk_rq();
  }
#line 1337
  return;
}
}
#line 489 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-pm.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_100(spinlock_t *ldv_func_arg1 ) ;
#line 493
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_102(spinlock_t *ldv_func_arg1 ) ;
#line 454 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock , unsigned long flags ) ;
#line 458
__inline static void ldv_spin_unlock_irqrestore_97(spinlock_t *lock , unsigned long flags ) ;
#line 557 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_has_flush(u16 const   *id ) 
{ 


  {
#line 559
  if (((int )*(id + 83UL) & 49152) != 16384) {
#line 560
    return (0);
  } else {

  }
#line 561
  return (((int )*(id + 83UL) & 4096) != 0);
}
}
#line 564 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_flush_enabled(u16 const   *id ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 566
  tmp = ata_id_has_flush(id);
  }
#line 566
  if (tmp) {
#line 566
    tmp___0 = 0;
  } else {
#line 566
    tmp___0 = 1;
  }
#line 566
  if (tmp___0) {
#line 567
    return (0);
  } else {

  }
#line 568
  if (((int )*(id + 87UL) & 49152) != 16384) {
#line 569
    return (0);
  } else {

  }
#line 570
  return (((int )*(id + 86UL) & 4096) != 0);
}
}
#line 573 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_has_flush_ext(u16 const   *id ) 
{ 


  {
#line 575
  if (((int )*(id + 83UL) & 49152) != 16384) {
#line 576
    return (0);
  } else {

  }
#line 577
  return (((int )*(id + 83UL) & 8192) != 0);
}
}
#line 580 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_flush_ext_enabled(u16 const   *id ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 582
  tmp = ata_id_has_flush_ext(id);
  }
#line 582
  if (tmp) {
#line 582
    tmp___0 = 0;
  } else {
#line 582
    tmp___0 = 1;
  }
#line 582
  if (tmp___0) {
#line 583
    return (0);
  } else {

  }
#line 584
  if (((int )*(id + 87UL) & 49152) != 16384) {
#line 585
    return (0);
  } else {

  }
#line 590
  return (((int )*(id + 86UL) & 9216) == 9216);
}
}
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
static void ldv_blk_put_request_97___0(struct request *ldv_func_arg1 ) ;
#line 803
static void ldv_blk_put_request_99(struct request *ldv_func_arg1 ) ;
#line 809
static struct request *ldv_blk_get_request_96___0(struct request_queue *ldv_func_arg1 ,
                                                  int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 813
static struct request *ldv_blk_get_request_98(struct request_queue *ldv_func_arg1 ,
                                              int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 861
extern void blk_start_queue(struct request_queue * ) ;
#line 862
extern void blk_stop_queue(struct request_queue * ) ;
#line 1002 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void ide_complete_power_step(ide_drive_t *drive , struct request *rq ) ;
#line 1405
bool ide_port_acpi(ide_hwif_t *hwif ) ;
#line 1406
int ide_acpi_exec_tfs(ide_drive_t *drive ) ;
#line 1407
void ide_acpi_get_timing(ide_hwif_t *hwif ) ;
#line 1408
void ide_acpi_push_timing(ide_hwif_t *hwif ) ;
#line 1411
void ide_acpi_set_state(ide_hwif_t *hwif , int on ) ;
#line 1527 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
__inline static ide_drive_t *ide_get_pair_dev(ide_drive_t *drive ) 
{ 
  ide_drive_t *peer ;

  {
#line 1529
  peer = (drive->hwif)->devices[(int )((unsigned int )drive->dn ^ 1U) & 1];
#line 1531
  return ((peer->dev_flags & 64UL) != 0UL ? peer : (ide_drive_t *)0);
}
}
#line 5 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pm.c"
int generic_ide_suspend(struct device *dev , pm_message_t mesg ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  ide_drive_t *pair ;
  ide_drive_t *tmp ;
  ide_hwif_t *hwif ;
  struct request *rq ;
  struct request_pm_state rqpm ;
  int ret ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 7
  __mptr = (struct device  const  *)dev;
#line 7
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 8
  tmp = ide_get_pair_dev(drive);
#line 8
  pair = tmp;
#line 9
  hwif = drive->hwif;
#line 14
  tmp___0 = ide_port_acpi(hwif);
  }
#line 14
  if ((int )tmp___0) {
#line 16
    if (((int )drive->dn & 1) == 0 || (unsigned long )pair == (unsigned long )((ide_drive_t *)0)) {
      {
#line 17
      ide_acpi_get_timing(hwif);
      }
    } else {

    }
  } else {

  }
  {
#line 20
  __memset((void *)(& rqpm), 0, 16UL);
#line 21
  rq = ldv_blk_get_request_96___0(drive->queue, 0, 16U);
#line 22
  rq->cmd_type = 4;
#line 23
  rq->special = (void *)(& rqpm);
#line 24
  rqpm.pm_step = 0;
  }
#line 25
  if (mesg.event == 8) {
#line 26
    mesg.event = 1;
  } else {

  }
  {
#line 27
  rqpm.pm_state = (u32 )mesg.event;
#line 29
  ret = blk_execute_rq(drive->queue, (struct gendisk *)0, rq, 0);
#line 30
  ldv_blk_put_request_97___0(rq);
  }
#line 32
  if (ret == 0) {
    {
#line 32
    tmp___1 = ide_port_acpi(hwif);
    }
#line 32
    if ((int )tmp___1) {
#line 34
      if (((int )drive->dn & 1) != 0 || (unsigned long )pair == (unsigned long )((ide_drive_t *)0)) {
        {
#line 35
        ide_acpi_set_state(hwif, 0);
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 38
  return (ret);
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pm.c"
int generic_ide_resume(struct device *dev ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  ide_drive_t *pair ;
  ide_drive_t *tmp ;
  ide_hwif_t *hwif ;
  struct request *rq ;
  struct request_pm_state rqpm ;
  int err ;
  bool tmp___0 ;
  struct ide_driver *drv ;
  struct device_driver  const  *__mptr___0 ;

  {
  {
#line 43
  __mptr = (struct device  const  *)dev;
#line 43
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 44
  tmp = ide_get_pair_dev(drive);
#line 44
  pair = tmp;
#line 45
  hwif = drive->hwif;
#line 50
  tmp___0 = ide_port_acpi(hwif);
  }
#line 50
  if ((int )tmp___0) {
#line 52
    if (((int )drive->dn & 1) == 0 || (unsigned long )pair == (unsigned long )((ide_drive_t *)0)) {
      {
#line 53
      ide_acpi_set_state(hwif, 1);
#line 54
      ide_acpi_push_timing(hwif);
      }
    } else {

    }
    {
#line 57
    ide_acpi_exec_tfs(drive);
    }
  } else {

  }
  {
#line 60
  __memset((void *)(& rqpm), 0, 16UL);
#line 61
  rq = ldv_blk_get_request_98(drive->queue, 0, 16U);
#line 62
  rq->cmd_type = 5;
#line 63
  rq->cmd_flags = rq->cmd_flags | 33554432ULL;
#line 64
  rq->special = (void *)(& rqpm);
#line 65
  rqpm.pm_step = 2;
#line 66
  rqpm.pm_state = 0U;
#line 68
  err = blk_execute_rq(drive->queue, (struct gendisk *)0, rq, 1);
#line 69
  ldv_blk_put_request_99(rq);
  }
#line 71
  if (err == 0 && (unsigned long )dev->driver != (unsigned long )((struct device_driver *)0)) {
#line 72
    __mptr___0 = (struct device_driver  const  *)dev->driver;
#line 72
    drv = (struct ide_driver *)__mptr___0 + 0xfffffffffffffff0UL;
#line 74
    if ((unsigned long )drv->resume != (unsigned long )((void (*)(ide_drive_t * ))0)) {
      {
#line 75
      (*(drv->resume))(drive);
      }
    } else {

    }
  } else {

  }
#line 78
  return (err);
}
}
#line 81 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pm.c"
void ide_complete_power_step(ide_drive_t *drive , struct request *rq ) 
{ 
  struct request_pm_state *pm ;

  {
#line 83
  pm = (struct request_pm_state *)rq->special;
#line 89
  if ((unsigned int )drive->media != 32U) {
#line 90
    return;
  } else {

  }
  {
#line 93
  if (pm->pm_step == 0) {
#line 93
    goto case_0;
  } else {

  }
#line 99
  if (pm->pm_step == 1) {
#line 99
    goto case_1;
  } else {

  }
#line 102
  if (pm->pm_step == 2) {
#line 102
    goto case_2;
  } else {

  }
#line 105
  if (pm->pm_step == 3) {
#line 105
    goto case_3;
  } else {

  }
#line 92
  goto switch_break;
  case_0: /* CIL Label */ ;
#line 94
  if (pm->pm_state == 1U) {
#line 95
    pm->pm_step = 5;
  } else {
#line 97
    pm->pm_step = 1;
  }
#line 98
  goto ldv_38267;
  case_1: /* CIL Label */ 
#line 100
  pm->pm_step = 5;
#line 101
  goto ldv_38267;
  case_2: /* CIL Label */ 
#line 103
  pm->pm_step = 3;
#line 104
  goto ldv_38267;
  case_3: /* CIL Label */ 
#line 106
  pm->pm_step = 4;
#line 107
  goto ldv_38267;
  switch_break: /* CIL Label */ ;
  }
  ldv_38267: ;
#line 110
  return;
}
}
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pm.c"
ide_startstop_t ide_start_power_step(ide_drive_t *drive , struct request *rq ) 
{ 
  struct request_pm_state *pm ;
  struct ide_cmd cmd ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  ide_startstop_t tmp___2 ;

  {
#line 113
  pm = (struct request_pm_state *)rq->special;
#line 114
  cmd.tf.data = (unsigned char)0;
#line 114
  cmd.tf.__annonCompField83.error = (unsigned char)0;
#line 114
  cmd.tf.nsect = (unsigned char)0;
#line 114
  cmd.tf.lbal = (unsigned char)0;
#line 114
  cmd.tf.lbam = (unsigned char)0;
#line 114
  cmd.tf.lbah = (unsigned char)0;
#line 114
  cmd.tf.device = (unsigned char)0;
#line 114
  cmd.tf.__annonCompField84.status = (unsigned char)0;
#line 114
  cmd.hob.data = (unsigned char)0;
#line 114
  cmd.hob.__annonCompField83.error = (unsigned char)0;
#line 114
  cmd.hob.nsect = (unsigned char)0;
#line 114
  cmd.hob.lbal = (unsigned char)0;
#line 114
  cmd.hob.lbam = (unsigned char)0;
#line 114
  cmd.hob.lbah = (unsigned char)0;
#line 114
  cmd.hob.device = (unsigned char)0;
#line 114
  cmd.hob.__annonCompField84.status = (unsigned char)0;
#line 114
  cmd.valid.out.tf = (unsigned char)0;
#line 114
  cmd.valid.out.hob = (unsigned char)0;
#line 114
  cmd.valid.in.tf = (unsigned char)0;
#line 114
  cmd.valid.in.hob = (unsigned char)0;
#line 114
  cmd.tf_flags = (unsigned short)0;
#line 114
  cmd.ftf_flags = (unsigned char)0;
#line 114
  cmd.protocol = 0;
#line 114
  cmd.sg_nents = 0;
#line 114
  cmd.orig_sg_nents = 0;
#line 114
  cmd.sg_dma_direction = 0;
#line 114
  cmd.nbytes = 0U;
#line 114
  cmd.nleft = 0U;
#line 114
  cmd.last_xfer_len = 0U;
#line 114
  cmd.cursg = 0;
#line 114
  cmd.cursg_ofs = 0U;
#line 114
  cmd.rq = 0;
  {
#line 117
  if (pm->pm_step == 0) {
#line 117
    goto case_0;
  } else {

  }
#line 131
  if (pm->pm_step == 1) {
#line 131
    goto case_1;
  } else {

  }
#line 134
  if (pm->pm_step == 2) {
#line 134
    goto case_2;
  } else {

  }
#line 144
  if (pm->pm_step == 3) {
#line 144
    goto case_3;
  } else {

  }
#line 147
  if (pm->pm_step == 4) {
#line 147
    goto case_4;
  } else {

  }
#line 116
  goto switch_break;
  case_0: /* CIL Label */ ;
#line 118
  if ((unsigned int )drive->media != 32U) {
#line 119
    goto ldv_38278;
  } else {

  }
  {
#line 121
  tmp = ata_id_flush_enabled((u16 const   *)drive->id);
  }
#line 121
  if (tmp) {
#line 121
    tmp___0 = 0;
  } else {
#line 121
    tmp___0 = 1;
  }
#line 121
  if (tmp___0 || (drive->dev_flags & 4194304UL) == 0UL) {
    {
#line 123
    ide_complete_power_step(drive, rq);
    }
#line 124
    return (0);
  } else {

  }
  {
#line 126
  tmp___1 = ata_id_flush_ext_enabled((u16 const   *)drive->id);
  }
#line 126
  if ((int )tmp___1) {
#line 127
    cmd.tf.__annonCompField84.command = 234U;
  } else {
#line 129
    cmd.tf.__annonCompField84.command = 231U;
  }
#line 130
  goto out_do_tf;
  case_1: /* CIL Label */ 
#line 132
  cmd.tf.__annonCompField84.command = 224U;
#line 133
  goto out_do_tf;
  case_2: /* CIL Label */ 
  {
#line 135
  ide_set_max_pio(drive);
  }
#line 139
  if ((unsigned int )drive->media != 32U) {
#line 140
    pm->pm_step = 4;
  } else {
    {
#line 142
    ide_complete_power_step(drive, rq);
    }
  }
#line 143
  return (0);
  case_3: /* CIL Label */ 
#line 145
  cmd.tf.__annonCompField84.command = 225U;
#line 146
  goto out_do_tf;
  case_4: /* CIL Label */ ;
#line 153
  if ((unsigned long )(drive->hwif)->dma_ops == (unsigned long )((struct ide_dma_ops  const  *)0)) {
#line 154
    goto ldv_38278;
  } else {

  }
  {
#line 158
  ide_set_dma(drive);
  }
#line 159
  goto ldv_38278;
  switch_break: /* CIL Label */ ;
  }
  ldv_38278: 
#line 162
  pm->pm_step = 5;
#line 164
  return (0);
  out_do_tf: 
  {
#line 167
  cmd.valid.out.tf = 126U;
#line 168
  cmd.valid.in.tf = 124U;
#line 169
  cmd.protocol = 1;
#line 171
  tmp___2 = do_rw_taskfile(drive, & cmd);
  }
#line 171
  return (tmp___2);
}
}
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pm.c"
void ide_complete_pm_rq(ide_drive_t *drive , struct request *rq ) 
{ 
  struct request_queue *q ;
  struct request_pm_state *pm ;
  unsigned long flags ;
  bool tmp ;

  {
  {
#line 184
  q = drive->queue;
#line 185
  pm = (struct request_pm_state *)rq->special;
#line 188
  ide_complete_power_step(drive, rq);
  }
#line 189
  if (pm->pm_step != 5) {
#line 190
    return;
  } else {

  }
  {
#line 196
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_100(q->queue_lock);
  }
#line 197
  if ((unsigned int )rq->cmd_type == 4U) {
    {
#line 198
    blk_stop_queue(q);
    }
  } else {
#line 200
    drive->dev_flags = drive->dev_flags & 0xfffffffffffdffffUL;
  }
  {
#line 201
  ldv_spin_unlock_irqrestore_97(q->queue_lock, flags);
#line 203
  (drive->hwif)->rq = (struct request *)0;
#line 205
  tmp = blk_end_request(rq, 0, 0U);
  }
#line 205
  if ((int )tmp) {
    {
#line 206
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-pm.c"),
                         "i" (206), "i" (12UL));
#line 206
    __builtin_unreachable();
    }
  } else {

  }
#line 208
  return;
}
}
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pm.c"
void ide_check_pm_state(ide_drive_t *drive , struct request *rq ) 
{ 
  struct request_pm_state *pm ;
  ide_hwif_t *hwif ;
  struct ide_tp_ops  const  *tp_ops ;
  struct request_queue *q ;
  unsigned long flags ;
  int rc ;

  {
#line 211
  pm = (struct request_pm_state *)rq->special;
#line 213
  if ((unsigned int )rq->cmd_type == 4U && pm->pm_step == 0) {
#line 216
    drive->dev_flags = drive->dev_flags | 131072UL;
  } else
#line 217
  if ((unsigned int )rq->cmd_type == 5U && pm->pm_step == 2) {
    {
#line 227
    hwif = drive->hwif;
#line 228
    tp_ops = hwif->tp_ops;
#line 229
    q = drive->queue;
#line 235
    rc = ide_wait_not_busy(hwif, 35000UL);
    }
#line 236
    if (rc != 0) {
      {
#line 237
      printk("\f%s: bus not ready on wakeup\n", (char *)(& drive->name));
      }
    } else {

    }
    {
#line 238
    (*(tp_ops->dev_select))(drive);
#line 239
    (*(tp_ops->write_devctl))(hwif, 8);
#line 240
    rc = ide_wait_not_busy(hwif, 100000UL);
    }
#line 241
    if (rc != 0) {
      {
#line 242
      printk("\f%s: drive not ready on wakeup\n", (char *)(& drive->name));
      }
    } else {

    }
    {
#line 244
    ldv___ldv_linux_kernel_locking_spinlock_spin_lock_102(q->queue_lock);
#line 245
    blk_start_queue(q);
#line 246
    ldv_spin_unlock_irqrestore_97(q->queue_lock, flags);
    }
  } else {

  }
#line 248
  return;
}
}
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-pm.c.aux"
static struct request *ldv_blk_get_request_96___0(struct request_queue *ldv_func_arg1 ,
                                                  int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1330
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1330
  return (tmp);
}
}
#line 1333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-pm.c.aux"
static void ldv_blk_put_request_97___0(struct request *ldv_func_arg1 ) 
{ 


  {
  {
#line 1336
  ldv_linux_block_request_put_blk_rq();
  }
#line 1337
  return;
}
}
#line 1339 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-pm.c.aux"
static struct request *ldv_blk_get_request_98(struct request_queue *ldv_func_arg1 ,
                                              int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1342
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1342
  return (tmp);
}
}
#line 1345 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-pm.c.aux"
static void ldv_blk_put_request_99(struct request *ldv_func_arg1 ) 
{ 


  {
  {
#line 1348
  ldv_linux_block_request_put_blk_rq();
  }
#line 1349
  return;
}
}
#line 1351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-pm.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_100(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1354
  ldv_linux_kernel_locking_spinlock_spin_lock_queue_lock_of_request_queue();
#line 1356
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1357
  return;
}
}
#line 1367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-pm.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_102(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1370
  ldv_linux_kernel_locking_spinlock_spin_lock_queue_lock_of_request_queue();
#line 1372
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1373
  return;
}
}
#line 369 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-park.c.aux"
static void ldv_mutex_lock_105(struct mutex *ldv_func_arg1 ) ;
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern int kstrtoll(char const   * , unsigned int  , long long * ) ;
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
__inline static int kstrtol(char const   *s , unsigned int base , long *res ) 
{ 
  int tmp ;

  {
  {
#line 314
  tmp = kstrtoll(s, base, (long long *)res);
  }
#line 314
  return (tmp);
}
}
#line 392
extern int snprintf(char * , size_t  , char const   *  , ...) ;
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
static void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1 ) ;
#line 366 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_lock_irq_99(spinlock_t *lock ) ;
#line 370
__inline static void ldv_spin_lock_irq_99(spinlock_t *lock ) ;
#line 433
__inline static void ldv_spin_unlock_irq_100(spinlock_t *lock ) ;
#line 437
__inline static void ldv_spin_unlock_irq_100(spinlock_t *lock ) ;
#line 441
__inline static void ldv_spin_unlock_irq_100(spinlock_t *lock ) ;
#line 149 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
#line 291 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/jiffies.h"
extern unsigned long msecs_to_jiffies(unsigned int const    ) ;
#line 178 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/timer.h"
static int ldv_del_timer_97(struct timer_list *ldv_func_arg1 ) ;
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/elevator.h"
extern void elv_add_request(struct request_queue * , struct request * , int  ) ;
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
static void ldv_blk_put_request_101___0(struct request *ldv_func_arg1 ) ;
#line 805
static struct request *ldv_blk_get_request_100___0(struct request_queue *ldv_func_arg1 ,
                                                   int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 809
static struct request *ldv_blk_get_request_102___0(struct request_queue *ldv_func_arg1 ,
                                                   int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 862
extern void blk_run_queue(struct request_queue * ) ;
#line 1106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
wait_queue_head_t ide_park_wq ;
#line 1107
ssize_t ide_park_show(struct device *dev , struct device_attribute *attr , char *buf ) ;
#line 1109
ssize_t ide_park_store(struct device *dev , struct device_attribute *attr , char const   *buf ,
                       size_t len ) ;
#line 7 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-park.c"
wait_queue_head_t ide_park_wq  =    {{{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "ide_park_wq.lock",
                                                      0, 0UL}}}}, {& ide_park_wq.task_list,
                                                                   & ide_park_wq.task_list}};
#line 9 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-park.c"
static void issue_park_cmd(ide_drive_t *drive , unsigned long timeout ) 
{ 
  ide_hwif_t *hwif ;
  struct request_queue *q ;
  struct request *rq ;
  int rc ;
  int reset_timer ;
  int start_queue ;
  int tmp ;
  bool tmp___0 ;

  {
  {
#line 11
  hwif = drive->hwif;
#line 12
  q = drive->queue;
#line 16
  timeout = timeout + (unsigned long )jiffies;
#line 17
  ldv_spin_lock_irq_99(& hwif->lock);
  }
#line 18
  if ((drive->dev_flags & 134217728UL) != 0UL) {
    {
#line 19
    reset_timer = (long )(timeout - drive->sleep) < 0L;
#line 20
    start_queue = 0;
#line 22
    drive->sleep = timeout;
#line 23
    __wake_up(& ide_park_wq, 3U, 0, (void *)0);
    }
#line 24
    if (reset_timer != 0) {
      {
#line 24
      tmp = ldv_del_timer_97(& hwif->timer);
      }
#line 24
      if (tmp != 0) {
#line 25
        start_queue = 1;
      } else {

      }
    } else {

    }
    {
#line 26
    ldv_spin_unlock_irq_100(& hwif->lock);
    }
#line 28
    if (start_queue != 0) {
      {
#line 29
      blk_run_queue(q);
      }
    } else {

    }
#line 30
    return;
  } else {

  }
  {
#line 32
  ldv_spin_unlock_irq_100(& hwif->lock);
#line 34
  rq = ldv_blk_get_request_100___0(q, 0, 16U);
#line 35
  *(rq->cmd) = 34U;
#line 36
  rq->cmd_len = 1U;
#line 37
  rq->cmd_type = 7;
#line 38
  rq->special = (void *)(& timeout);
#line 39
  rc = blk_execute_rq(q, (struct gendisk *)0, rq, 1);
#line 40
  ldv_blk_put_request_101___0(rq);
  }
#line 41
  if (rc != 0) {
#line 42
    goto out;
  } else {

  }
  {
#line 48
  rq = ldv_blk_get_request_102___0(q, 0, 0U);
#line 49
  tmp___0 = IS_ERR((void const   *)rq);
  }
#line 49
  if ((int )tmp___0) {
#line 50
    goto out;
  } else {

  }
  {
#line 52
  *(rq->cmd) = 35U;
#line 53
  rq->cmd_len = 1U;
#line 54
  rq->cmd_type = 7;
#line 55
  elv_add_request(q, rq, 1);
  }
  out: ;
#line 58
  return;
}
}
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-park.c"
ide_startstop_t ide_do_park_unpark(ide_drive_t *drive , struct request *rq ) 
{ 
  struct ide_cmd cmd ;
  struct ide_taskfile *tf ;
  ide_startstop_t tmp ;

  {
  {
#line 64
  tf = & cmd.tf;
#line 66
  __memset((void *)(& cmd), 0, 80UL);
  }
#line 67
  if ((unsigned int )*(rq->cmd) == 34U) {
#line 68
    drive->sleep = *((unsigned long *)rq->special);
#line 69
    drive->dev_flags = drive->dev_flags | 262144UL;
#line 70
    tf->__annonCompField84.command = 225U;
#line 71
    tf->__annonCompField83.feature = 68U;
#line 72
    tf->lbal = 76U;
#line 73
    tf->lbam = 78U;
#line 74
    tf->lbah = 85U;
#line 75
    cmd.valid.out.tf = 126U;
#line 76
    cmd.valid.in.tf = 124U;
  } else {
#line 78
    tf->__annonCompField84.command = 229U;
  }
  {
#line 80
  cmd.tf_flags = (u16 )((unsigned int )cmd.tf_flags | 4U);
#line 81
  cmd.protocol = 1;
#line 83
  cmd.rq = rq;
#line 85
  tmp = do_rw_taskfile(drive, & cmd);
  }
#line 85
  return (tmp);
}
}
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-park.c"
ssize_t ide_park_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  ide_hwif_t *hwif ;
  unsigned long now ;
  unsigned int msecs ;
  int tmp ;

  {
#line 91
  __mptr = (struct device  const  *)dev;
#line 91
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 92
  hwif = drive->hwif;
#line 96
  if ((drive->dev_flags & 67108864UL) != 0UL) {
#line 97
    return (-95L);
  } else {

  }
  {
#line 99
  ldv_spin_lock_irq_99(& hwif->lock);
#line 100
  now = jiffies;
  }
#line 102
  if ((drive->dev_flags & 134217728UL) != 0UL && (long )(now - drive->sleep) < 0L) {
    {
#line 103
    msecs = jiffies_to_msecs(drive->sleep - now);
    }
  } else {
#line 105
    msecs = 0U;
  }
  {
#line 106
  ldv_spin_unlock_irq_100(& hwif->lock);
#line 108
  tmp = snprintf(buf, 20UL, "%u\n", msecs);
  }
#line 108
  return ((ssize_t )tmp);
}
}
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-park.c"
ssize_t ide_park_store(struct device *dev , struct device_attribute *attr , char const   *buf ,
                       size_t len ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  long input ;
  int rc ;
  unsigned long tmp ;

  {
  {
#line 115
  __mptr = (struct device  const  *)dev;
#line 115
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 119
  rc = kstrtol(buf, 10U, & input);
  }
#line 120
  if (rc != 0) {
#line 121
    return ((ssize_t )rc);
  } else {

  }
#line 122
  if (input < -2L) {
#line 123
    return (-22L);
  } else {

  }
#line 124
  if (input > 30000L) {
#line 125
    input = 30000L;
#line 126
    rc = -75;
  } else {

  }
  {
#line 129
  ldv_mutex_lock_105(& ide_setting_mtx);
  }
#line 130
  if (input >= 0L) {
#line 131
    if ((drive->dev_flags & 67108864UL) != 0UL) {
#line 132
      rc = -95;
    } else
#line 133
    if (input != 0L || (drive->dev_flags & 134217728UL) != 0UL) {
      {
#line 134
      tmp = msecs_to_jiffies((unsigned int const   )input);
#line 134
      issue_park_cmd(drive, tmp);
      }
    } else {

    }
  } else
#line 136
  if ((unsigned int )drive->media == 32U) {
    {
#line 138
    if (input == -1L) {
#line 138
      goto case_neg_1;
    } else {

    }
#line 141
    if (input == -2L) {
#line 141
      goto case_neg_2;
    } else {

    }
#line 137
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 139
    drive->dev_flags = drive->dev_flags & 0xfffffffffbffffffUL;
#line 140
    goto ldv_38298;
    case_neg_2: /* CIL Label */ 
#line 142
    drive->dev_flags = drive->dev_flags | 67108864UL;
#line 143
    goto ldv_38298;
    switch_break: /* CIL Label */ ;
    }
    ldv_38298: ;
  } else {
#line 146
    rc = -95;
  }
  {
#line 148
  ldv_mutex_unlock_106(& ide_setting_mtx);
  }
#line 150
  return ((ssize_t )(rc != 0 ? (size_t )rc : len));
}
}
#line 1337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-park.c.aux"
static int ldv_del_timer_97(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1341
  tmp = del_timer(ldv_func_arg1);
#line 1341
  ldv_func_res = tmp;
#line 1344
  tmp___0 = ldv_del_timer(ldv_func_res, ldv_func_arg1);
  }
#line 1344
  return (tmp___0);
#line 1346
  return (ldv_func_res);
}
}
#line 1365 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-park.c.aux"
static struct request *ldv_blk_get_request_100___0(struct request_queue *ldv_func_arg1 ,
                                                   int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1368
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1368
  return (tmp);
}
}
#line 1371 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-park.c.aux"
static void ldv_blk_put_request_101___0(struct request *ldv_func_arg1 ) 
{ 


  {
  {
#line 1374
  ldv_linux_block_request_put_blk_rq();
  }
#line 1375
  return;
}
}
#line 1377 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-park.c.aux"
static struct request *ldv_blk_get_request_102___0(struct request_queue *ldv_func_arg1 ,
                                                   int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1380
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1380
  return (tmp);
}
}
#line 1399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-park.c.aux"
static void ldv_mutex_lock_105(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1403
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(ldv_func_arg1);
  }
#line 1404
  return;
}
}
#line 1406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-park.c.aux"
static void ldv_mutex_unlock_106(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 1410
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(ldv_func_arg1);
  }
#line 1411
  return;
}
}
#line 560 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
extern int device_create_file(struct device * , struct device_attribute  const  * ) ;
#line 840 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 842
  return ((void *)dev->driver_data);
}
}
#line 4 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
char *ide_media_string(ide_drive_t *drive ) 
{ 


  {
  {
#line 7
  if ((int )drive->media == 32) {
#line 7
    goto case_32;
  } else {

  }
#line 9
  if ((int )drive->media == 5) {
#line 9
    goto case_5;
  } else {

  }
#line 11
  if ((int )drive->media == 1) {
#line 11
    goto case_1;
  } else {

  }
#line 13
  if ((int )drive->media == 0) {
#line 13
    goto case_0;
  } else {

  }
#line 15
  if ((int )drive->media == 7) {
#line 15
    goto case_7;
  } else {

  }
#line 17
  goto switch_default;
  case_32: /* CIL Label */ ;
#line 8
  return ((char *)"disk");
  case_5: /* CIL Label */ ;
#line 10
  return ((char *)"cdrom");
  case_1: /* CIL Label */ ;
#line 12
  return ((char *)"tape");
  case_0: /* CIL Label */ ;
#line 14
  return ((char *)"floppy");
  case_7: /* CIL Label */ ;
#line 16
  return ((char *)"optical");
  switch_default: /* CIL Label */ ;
#line 18
  return ((char *)"UNKNOWN");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static ssize_t media_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 25
  __mptr = (struct device  const  *)dev;
#line 25
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 26
  tmp = ide_media_string(drive);
#line 26
  tmp___0 = sprintf(buf, "%s\n", tmp);
  }
#line 26
  return ((ssize_t )tmp___0);
}
}
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_media  =    {{"media", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & media_show,
    0};
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static ssize_t drivename_show(struct device *dev , struct device_attribute *attr ,
                              char *buf ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 33
  __mptr = (struct device  const  *)dev;
#line 33
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 34
  tmp = sprintf(buf, "%s\n", (char *)(& drive->name));
  }
#line 34
  return ((ssize_t )tmp);
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_drivename  =    {{"drivename", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & drivename_show, 0};
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static ssize_t modalias_show(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 41
  __mptr = (struct device  const  *)dev;
#line 41
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 42
  tmp = ide_media_string(drive);
#line 42
  tmp___0 = sprintf(buf, "ide:m-%s\n", tmp);
  }
#line 42
  return ((ssize_t )tmp___0);
}
}
#line 44 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_modalias  =    {{"modalias", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & modalias_show, 0};
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static ssize_t model_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 49
  __mptr = (struct device  const  *)dev;
#line 49
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 50
  tmp = sprintf(buf, "%s\n", (char *)drive->id + 27U);
  }
#line 50
  return ((ssize_t )tmp);
}
}
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_model  =    {{"model", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & model_show,
    0};
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static ssize_t firmware_show(struct device *dev , struct device_attribute *attr ,
                             char *buf ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 57
  __mptr = (struct device  const  *)dev;
#line 57
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 58
  tmp = sprintf(buf, "%s\n", (char *)drive->id + 23U);
  }
#line 58
  return ((ssize_t )tmp);
}
}
#line 60 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_firmware  =    {{"firmware", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                      {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & firmware_show, 0};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static ssize_t serial_show(struct device *dev , struct device_attribute *attr , char *buf ) 
{ 
  ide_drive_t *drive ;
  struct device  const  *__mptr ;
  int tmp ;

  {
  {
#line 65
  __mptr = (struct device  const  *)dev;
#line 65
  drive = (ide_drive_t *)__mptr + 0xffffffffffffff30UL;
#line 66
  tmp = sprintf(buf, "%s\n", (char *)drive->id + 10U);
  }
#line 66
  return ((ssize_t )tmp);
}
}
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_serial  =    {{"serial", 256U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                    {(char)0}, {(char)0}, {(char)0}}}}, & serial_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_unload_heads  =    {{"unload_heads", 420U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                          {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & ide_park_show, & ide_park_store};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct attribute *ide_attrs[8U]  = 
#line 72
  {      & dev_attr_media.attr,      & dev_attr_drivename.attr,      & dev_attr_modalias.attr,      & dev_attr_model.attr, 
        & dev_attr_firmware.attr,      & dev_attr_serial.attr,      & dev_attr_unload_heads.attr,      (struct attribute *)0};
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct attribute_group  const  ide_attr_group  =    {0, 0, (struct attribute **)(& ide_attrs), 0};
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
struct attribute_group  const  *ide_dev_groups[2U]  = {      & ide_attr_group,      (struct attribute_group  const  *)0};
#line 92 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static ssize_t store_delete_devices(struct device *portdev , struct device_attribute *attr ,
                                    char const   *buf , size_t n ) 
{ 
  ide_hwif_t *hwif ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 96
  tmp = dev_get_drvdata((struct device  const  *)portdev);
#line 96
  hwif = (ide_hwif_t *)tmp;
#line 98
  tmp___0 = strncmp(buf, "1", n);
  }
#line 98
  if (tmp___0 != 0) {
#line 99
    return (-22L);
  } else {

  }
  {
#line 101
  ide_port_unregister_devices(hwif);
  }
#line 103
  return ((ssize_t )n);
}
}
#line 106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_delete_devices  =    {{"delete_devices", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    (ssize_t (*)(struct device * , struct device_attribute * , char * ))0, & store_delete_devices};
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static ssize_t store_scan(struct device *portdev , struct device_attribute *attr ,
                          char const   *buf , size_t n ) 
{ 
  ide_hwif_t *hwif ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 112
  tmp = dev_get_drvdata((struct device  const  *)portdev);
#line 112
  hwif = (ide_hwif_t *)tmp;
#line 114
  tmp___0 = strncmp(buf, "1", n);
  }
#line 114
  if (tmp___0 != 0) {
#line 115
    return (-22L);
  } else {

  }
  {
#line 117
  ide_port_unregister_devices(hwif);
#line 118
  ide_port_scan(hwif);
  }
#line 120
  return ((ssize_t )n);
}
}
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute dev_attr_scan  =    {{"scan", 128U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                  {(char)0}, {(char)0}, {(char)0}}}}, (ssize_t (*)(struct device * ,
                                                                                   struct device_attribute * ,
                                                                                   char * ))0,
    & store_scan};
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
static struct device_attribute *ide_port_attrs[3U]  = {      & dev_attr_delete_devices,      & dev_attr_scan,      (struct device_attribute *)0};
#line 131 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-sysfs.c"
int ide_sysfs_register_port(ide_hwif_t *hwif ) 
{ 
  int i ;
  int rc ;

  {
#line 133
  rc = rc;
#line 135
  i = 0;
#line 135
  goto ldv_38318;
  ldv_38317: 
  {
#line 136
  rc = device_create_file(hwif->portdev, (struct device_attribute  const  *)ide_port_attrs[i]);
  }
#line 137
  if (rc != 0) {
#line 138
    goto ldv_38316;
  } else {

  }
#line 135
  i = i + 1;
  ldv_38318: ;
#line 135
  if ((unsigned long )ide_port_attrs[i] != (unsigned long )((struct device_attribute *)0)) {
#line 137
    goto ldv_38317;
  } else {

  }
  ldv_38316: ;
#line 141
  return (rc);
}
}
#line 632 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_14_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 633
void ldv_dummy_resourceless_instance_callback_15_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 635
void ldv_dummy_resourceless_instance_callback_16_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 637
void ldv_dummy_resourceless_instance_callback_17_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 639
void ldv_dummy_resourceless_instance_callback_18_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 641
void ldv_dummy_resourceless_instance_callback_19_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 644
void ldv_dummy_resourceless_instance_callback_20_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 645
void ldv_dummy_resourceless_instance_callback_21_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 647
void ldv_dummy_resourceless_instance_callback_22_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) ;
#line 648
void ldv_dummy_resourceless_instance_callback_22_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) ;
#line 660 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_14  ;
#line 661 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_15  ;
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_16  ;
#line 663 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_17  ;
#line 664 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_18  ;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_19  ;
#line 666 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_20  ;
#line 667 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_21  ;
#line 668 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
struct ldv_thread ldv_thread_22  ;
#line 674 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_14_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 675
  store_delete_devices(arg1, arg2, (char const   *)arg3, arg4);
  }
#line 676
  return;
}
}
#line 679 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_15_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 680
  drivename_show(arg1, arg2, arg3);
  }
#line 681
  return;
}
}
#line 684 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_16_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 685
  firmware_show(arg1, arg2, arg3);
  }
#line 686
  return;
}
}
#line 689 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_17_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 690
  media_show(arg1, arg2, arg3);
  }
#line 691
  return;
}
}
#line 694 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_18_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 695
  modalias_show(arg1, arg2, arg3);
  }
#line 696
  return;
}
}
#line 699 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_19_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 700
  model_show(arg1, arg2, arg3);
  }
#line 701
  return;
}
}
#line 704 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_20_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 705
  store_scan(arg1, arg2, (char const   *)arg3, arg4);
  }
#line 706
  return;
}
}
#line 709 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_21_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 710
  serial_show(arg1, arg2, arg3);
  }
#line 711
  return;
}
}
#line 714 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_22_3(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * ) , struct device *arg1 ,
                                                   struct device_attribute *arg2 ,
                                                   char *arg3 ) 
{ 


  {
  {
#line 715
  ide_park_show(arg1, arg2, arg3);
  }
#line 716
  return;
}
}
#line 719 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_dummy_resourceless_instance_callback_22_9(long (*arg0)(struct device * ,
                                                                struct device_attribute * ,
                                                                char * , unsigned long  ) ,
                                                   struct device *arg1 , struct device_attribute *arg2 ,
                                                   char *arg3 , unsigned long arg4 ) 
{ 


  {
  {
#line 720
  ide_park_store(arg1, arg2, (char const   *)arg3, arg4);
  }
#line 721
  return;
}
}
#line 724 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_14(void *arg0 ) 
{ 
  long (*ldv_14_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_14_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_14_container_struct_device_attribute ;
  struct device *ldv_14_container_struct_device_ptr ;
  char *ldv_14_ldv_param_3_2_default ;
  char *ldv_14_ldv_param_9_2_default ;
  unsigned long ldv_14_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 742
  goto ldv_call_14;
#line 744
  return;
  ldv_call_14: 
  {
#line 750
  tmp___2 = ldv_undef_int();
  }
#line 750
  if (tmp___2 != 0) {
    {
#line 752
    tmp = ldv_xmalloc(1UL);
#line 752
    ldv_14_ldv_param_3_2_default = (char *)tmp;
#line 755
    tmp___1 = ldv_undef_int();
    }
#line 755
    if (tmp___1 != 0) {
      {
#line 757
      tmp___0 = ldv_xmalloc(1UL);
#line 757
      ldv_14_ldv_param_9_2_default = (char *)tmp___0;
#line 762
      ldv_dummy_resourceless_instance_callback_14_9(ldv_14_callback_store, ldv_14_container_struct_device_ptr,
                                                    ldv_14_container_struct_device_attribute,
                                                    ldv_14_ldv_param_9_2_default,
                                                    ldv_14_ldv_param_9_3_default);
#line 766
      ldv_free((void *)ldv_14_ldv_param_9_2_default);
      }
    } else
#line 772
    if ((unsigned long )ldv_14_callback_show != (unsigned long )((long (*)(struct device * ,
                                                                           struct device_attribute * ,
                                                                           char * ))0)) {
      {
#line 774
      ldv_dummy_resourceless_instance_callback_14_3(ldv_14_callback_show, ldv_14_container_struct_device_ptr,
                                                    ldv_14_container_struct_device_attribute,
                                                    ldv_14_ldv_param_3_2_default);
      }
    } else {

    }
    {
#line 780
    ldv_free((void *)ldv_14_ldv_param_3_2_default);
    }
#line 787
    goto ldv_call_14;
  } else {
#line 795
    return;
  }
#line 798
  return;
}
}
#line 803 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_15(void *arg0 ) 
{ 
  long (*ldv_15_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_15_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_15_container_struct_device_attribute ;
  struct device *ldv_15_container_struct_device_ptr ;
  char *ldv_15_ldv_param_3_2_default ;
  char *ldv_15_ldv_param_9_2_default ;
  unsigned long ldv_15_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 821
  goto ldv_call_15;
#line 823
  return;
  ldv_call_15: 
  {
#line 829
  tmp___2 = ldv_undef_int();
  }
#line 829
  if (tmp___2 != 0) {
    {
#line 831
    tmp = ldv_xmalloc(1UL);
#line 831
    ldv_15_ldv_param_3_2_default = (char *)tmp;
#line 834
    tmp___1 = ldv_undef_int();
    }
#line 834
    if (tmp___1 != 0) {
      {
#line 836
      tmp___0 = ldv_xmalloc(1UL);
#line 836
      ldv_15_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 840
      if ((unsigned long )ldv_15_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                              struct device_attribute * ,
                                                                              char * ,
                                                                              unsigned long  ))0)) {
        {
#line 842
        ldv_dummy_resourceless_instance_callback_15_9(ldv_15_callback_store, ldv_15_container_struct_device_ptr,
                                                      ldv_15_container_struct_device_attribute,
                                                      ldv_15_ldv_param_9_2_default,
                                                      ldv_15_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 847
      ldv_free((void *)ldv_15_ldv_param_9_2_default);
      }
    } else {
      {
#line 854
      ldv_dummy_resourceless_instance_callback_15_3(ldv_15_callback_show, ldv_15_container_struct_device_ptr,
                                                    ldv_15_container_struct_device_attribute,
                                                    ldv_15_ldv_param_3_2_default);
      }
    }
    {
#line 859
    ldv_free((void *)ldv_15_ldv_param_3_2_default);
    }
#line 866
    goto ldv_call_15;
  } else {
#line 874
    return;
  }
#line 877
  return;
}
}
#line 882 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_16(void *arg0 ) 
{ 
  long (*ldv_16_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_16_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_16_container_struct_device_attribute ;
  struct device *ldv_16_container_struct_device_ptr ;
  char *ldv_16_ldv_param_3_2_default ;
  char *ldv_16_ldv_param_9_2_default ;
  unsigned long ldv_16_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 900
  goto ldv_call_16;
#line 902
  return;
  ldv_call_16: 
  {
#line 908
  tmp___2 = ldv_undef_int();
  }
#line 908
  if (tmp___2 != 0) {
    {
#line 910
    tmp = ldv_xmalloc(1UL);
#line 910
    ldv_16_ldv_param_3_2_default = (char *)tmp;
#line 913
    tmp___1 = ldv_undef_int();
    }
#line 913
    if (tmp___1 != 0) {
      {
#line 915
      tmp___0 = ldv_xmalloc(1UL);
#line 915
      ldv_16_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 919
      if ((unsigned long )ldv_16_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                              struct device_attribute * ,
                                                                              char * ,
                                                                              unsigned long  ))0)) {
        {
#line 921
        ldv_dummy_resourceless_instance_callback_16_9(ldv_16_callback_store, ldv_16_container_struct_device_ptr,
                                                      ldv_16_container_struct_device_attribute,
                                                      ldv_16_ldv_param_9_2_default,
                                                      ldv_16_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 926
      ldv_free((void *)ldv_16_ldv_param_9_2_default);
      }
    } else {
      {
#line 933
      ldv_dummy_resourceless_instance_callback_16_3(ldv_16_callback_show, ldv_16_container_struct_device_ptr,
                                                    ldv_16_container_struct_device_attribute,
                                                    ldv_16_ldv_param_3_2_default);
      }
    }
    {
#line 938
    ldv_free((void *)ldv_16_ldv_param_3_2_default);
    }
#line 945
    goto ldv_call_16;
  } else {
#line 953
    return;
  }
#line 956
  return;
}
}
#line 961 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_17(void *arg0 ) 
{ 
  long (*ldv_17_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_17_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_17_container_struct_device_attribute ;
  struct device *ldv_17_container_struct_device_ptr ;
  char *ldv_17_ldv_param_3_2_default ;
  char *ldv_17_ldv_param_9_2_default ;
  unsigned long ldv_17_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 979
  goto ldv_call_17;
#line 981
  return;
  ldv_call_17: 
  {
#line 987
  tmp___2 = ldv_undef_int();
  }
#line 987
  if (tmp___2 != 0) {
    {
#line 989
    tmp = ldv_xmalloc(1UL);
#line 989
    ldv_17_ldv_param_3_2_default = (char *)tmp;
#line 992
    tmp___1 = ldv_undef_int();
    }
#line 992
    if (tmp___1 != 0) {
      {
#line 994
      tmp___0 = ldv_xmalloc(1UL);
#line 994
      ldv_17_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 998
      if ((unsigned long )ldv_17_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                              struct device_attribute * ,
                                                                              char * ,
                                                                              unsigned long  ))0)) {
        {
#line 1000
        ldv_dummy_resourceless_instance_callback_17_9(ldv_17_callback_store, ldv_17_container_struct_device_ptr,
                                                      ldv_17_container_struct_device_attribute,
                                                      ldv_17_ldv_param_9_2_default,
                                                      ldv_17_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 1005
      ldv_free((void *)ldv_17_ldv_param_9_2_default);
      }
    } else {
      {
#line 1012
      ldv_dummy_resourceless_instance_callback_17_3(ldv_17_callback_show, ldv_17_container_struct_device_ptr,
                                                    ldv_17_container_struct_device_attribute,
                                                    ldv_17_ldv_param_3_2_default);
      }
    }
    {
#line 1017
    ldv_free((void *)ldv_17_ldv_param_3_2_default);
    }
#line 1024
    goto ldv_call_17;
  } else {
#line 1032
    return;
  }
#line 1035
  return;
}
}
#line 1040 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_18(void *arg0 ) 
{ 
  long (*ldv_18_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_18_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_18_container_struct_device_attribute ;
  struct device *ldv_18_container_struct_device_ptr ;
  char *ldv_18_ldv_param_3_2_default ;
  char *ldv_18_ldv_param_9_2_default ;
  unsigned long ldv_18_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1058
  goto ldv_call_18;
#line 1060
  return;
  ldv_call_18: 
  {
#line 1066
  tmp___2 = ldv_undef_int();
  }
#line 1066
  if (tmp___2 != 0) {
    {
#line 1068
    tmp = ldv_xmalloc(1UL);
#line 1068
    ldv_18_ldv_param_3_2_default = (char *)tmp;
#line 1071
    tmp___1 = ldv_undef_int();
    }
#line 1071
    if (tmp___1 != 0) {
      {
#line 1073
      tmp___0 = ldv_xmalloc(1UL);
#line 1073
      ldv_18_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 1077
      if ((unsigned long )ldv_18_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                              struct device_attribute * ,
                                                                              char * ,
                                                                              unsigned long  ))0)) {
        {
#line 1079
        ldv_dummy_resourceless_instance_callback_18_9(ldv_18_callback_store, ldv_18_container_struct_device_ptr,
                                                      ldv_18_container_struct_device_attribute,
                                                      ldv_18_ldv_param_9_2_default,
                                                      ldv_18_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 1084
      ldv_free((void *)ldv_18_ldv_param_9_2_default);
      }
    } else {
      {
#line 1091
      ldv_dummy_resourceless_instance_callback_18_3(ldv_18_callback_show, ldv_18_container_struct_device_ptr,
                                                    ldv_18_container_struct_device_attribute,
                                                    ldv_18_ldv_param_3_2_default);
      }
    }
    {
#line 1096
    ldv_free((void *)ldv_18_ldv_param_3_2_default);
    }
#line 1103
    goto ldv_call_18;
  } else {
#line 1111
    return;
  }
#line 1114
  return;
}
}
#line 1119 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_19(void *arg0 ) 
{ 
  long (*ldv_19_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_19_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_19_container_struct_device_attribute ;
  struct device *ldv_19_container_struct_device_ptr ;
  char *ldv_19_ldv_param_3_2_default ;
  char *ldv_19_ldv_param_9_2_default ;
  unsigned long ldv_19_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1137
  goto ldv_call_19;
#line 1139
  return;
  ldv_call_19: 
  {
#line 1145
  tmp___2 = ldv_undef_int();
  }
#line 1145
  if (tmp___2 != 0) {
    {
#line 1147
    tmp = ldv_xmalloc(1UL);
#line 1147
    ldv_19_ldv_param_3_2_default = (char *)tmp;
#line 1150
    tmp___1 = ldv_undef_int();
    }
#line 1150
    if (tmp___1 != 0) {
      {
#line 1152
      tmp___0 = ldv_xmalloc(1UL);
#line 1152
      ldv_19_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 1156
      if ((unsigned long )ldv_19_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                              struct device_attribute * ,
                                                                              char * ,
                                                                              unsigned long  ))0)) {
        {
#line 1158
        ldv_dummy_resourceless_instance_callback_19_9(ldv_19_callback_store, ldv_19_container_struct_device_ptr,
                                                      ldv_19_container_struct_device_attribute,
                                                      ldv_19_ldv_param_9_2_default,
                                                      ldv_19_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 1163
      ldv_free((void *)ldv_19_ldv_param_9_2_default);
      }
    } else {
      {
#line 1170
      ldv_dummy_resourceless_instance_callback_19_3(ldv_19_callback_show, ldv_19_container_struct_device_ptr,
                                                    ldv_19_container_struct_device_attribute,
                                                    ldv_19_ldv_param_3_2_default);
      }
    }
    {
#line 1175
    ldv_free((void *)ldv_19_ldv_param_3_2_default);
    }
#line 1182
    goto ldv_call_19;
  } else {
#line 1190
    return;
  }
#line 1193
  return;
}
}
#line 1198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_20(void *arg0 ) 
{ 
  long (*ldv_20_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_20_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_20_container_struct_device_attribute ;
  struct device *ldv_20_container_struct_device_ptr ;
  char *ldv_20_ldv_param_3_2_default ;
  char *ldv_20_ldv_param_9_2_default ;
  unsigned long ldv_20_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1216
  goto ldv_call_20;
#line 1218
  return;
  ldv_call_20: 
  {
#line 1224
  tmp___2 = ldv_undef_int();
  }
#line 1224
  if (tmp___2 != 0) {
    {
#line 1226
    tmp = ldv_xmalloc(1UL);
#line 1226
    ldv_20_ldv_param_3_2_default = (char *)tmp;
#line 1229
    tmp___1 = ldv_undef_int();
    }
#line 1229
    if (tmp___1 != 0) {
      {
#line 1231
      tmp___0 = ldv_xmalloc(1UL);
#line 1231
      ldv_20_ldv_param_9_2_default = (char *)tmp___0;
#line 1236
      ldv_dummy_resourceless_instance_callback_20_9(ldv_20_callback_store, ldv_20_container_struct_device_ptr,
                                                    ldv_20_container_struct_device_attribute,
                                                    ldv_20_ldv_param_9_2_default,
                                                    ldv_20_ldv_param_9_3_default);
#line 1240
      ldv_free((void *)ldv_20_ldv_param_9_2_default);
      }
    } else
#line 1246
    if ((unsigned long )ldv_20_callback_show != (unsigned long )((long (*)(struct device * ,
                                                                           struct device_attribute * ,
                                                                           char * ))0)) {
      {
#line 1248
      ldv_dummy_resourceless_instance_callback_20_3(ldv_20_callback_show, ldv_20_container_struct_device_ptr,
                                                    ldv_20_container_struct_device_attribute,
                                                    ldv_20_ldv_param_3_2_default);
      }
    } else {

    }
    {
#line 1254
    ldv_free((void *)ldv_20_ldv_param_3_2_default);
    }
#line 1261
    goto ldv_call_20;
  } else {
#line 1269
    return;
  }
#line 1272
  return;
}
}
#line 1277 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_21(void *arg0 ) 
{ 
  long (*ldv_21_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_21_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_21_container_struct_device_attribute ;
  struct device *ldv_21_container_struct_device_ptr ;
  char *ldv_21_ldv_param_3_2_default ;
  char *ldv_21_ldv_param_9_2_default ;
  unsigned long ldv_21_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1295
  goto ldv_call_21;
#line 1297
  return;
  ldv_call_21: 
  {
#line 1303
  tmp___2 = ldv_undef_int();
  }
#line 1303
  if (tmp___2 != 0) {
    {
#line 1305
    tmp = ldv_xmalloc(1UL);
#line 1305
    ldv_21_ldv_param_3_2_default = (char *)tmp;
#line 1308
    tmp___1 = ldv_undef_int();
    }
#line 1308
    if (tmp___1 != 0) {
      {
#line 1310
      tmp___0 = ldv_xmalloc(1UL);
#line 1310
      ldv_21_ldv_param_9_2_default = (char *)tmp___0;
      }
#line 1314
      if ((unsigned long )ldv_21_callback_store != (unsigned long )((long (*)(struct device * ,
                                                                              struct device_attribute * ,
                                                                              char * ,
                                                                              unsigned long  ))0)) {
        {
#line 1316
        ldv_dummy_resourceless_instance_callback_21_9(ldv_21_callback_store, ldv_21_container_struct_device_ptr,
                                                      ldv_21_container_struct_device_attribute,
                                                      ldv_21_ldv_param_9_2_default,
                                                      ldv_21_ldv_param_9_3_default);
        }
      } else {

      }
      {
#line 1321
      ldv_free((void *)ldv_21_ldv_param_9_2_default);
      }
    } else {
      {
#line 1328
      ldv_dummy_resourceless_instance_callback_21_3(ldv_21_callback_show, ldv_21_container_struct_device_ptr,
                                                    ldv_21_container_struct_device_attribute,
                                                    ldv_21_ldv_param_3_2_default);
      }
    }
    {
#line 1333
    ldv_free((void *)ldv_21_ldv_param_3_2_default);
    }
#line 1340
    goto ldv_call_21;
  } else {
#line 1348
    return;
  }
#line 1351
  return;
}
}
#line 1356 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-sysfs.c.aux"
void ldv_struct_device_attribute_dummy_resourceless_instance_22(void *arg0 ) 
{ 
  long (*ldv_22_callback_show)(struct device * , struct device_attribute * , char * ) ;
  long (*ldv_22_callback_store)(struct device * , struct device_attribute * , char * ,
                                unsigned long  ) ;
  struct device_attribute *ldv_22_container_struct_device_attribute ;
  struct device *ldv_22_container_struct_device_ptr ;
  char *ldv_22_ldv_param_3_2_default ;
  char *ldv_22_ldv_param_9_2_default ;
  unsigned long ldv_22_ldv_param_9_3_default ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1374
  goto ldv_call_22;
#line 1376
  return;
  ldv_call_22: 
  {
#line 1382
  tmp___2 = ldv_undef_int();
  }
#line 1382
  if (tmp___2 != 0) {
    {
#line 1384
    tmp = ldv_xmalloc(1UL);
#line 1384
    ldv_22_ldv_param_3_2_default = (char *)tmp;
#line 1387
    tmp___1 = ldv_undef_int();
    }
#line 1387
    if (tmp___1 != 0) {
      {
#line 1389
      tmp___0 = ldv_xmalloc(1UL);
#line 1389
      ldv_22_ldv_param_9_2_default = (char *)tmp___0;
#line 1394
      ldv_dummy_resourceless_instance_callback_22_9(ldv_22_callback_store, ldv_22_container_struct_device_ptr,
                                                    ldv_22_container_struct_device_attribute,
                                                    ldv_22_ldv_param_9_2_default,
                                                    ldv_22_ldv_param_9_3_default);
#line 1398
      ldv_free((void *)ldv_22_ldv_param_9_2_default);
      }
    } else {
      {
#line 1405
      ldv_dummy_resourceless_instance_callback_22_3(ldv_22_callback_show, ldv_22_container_struct_device_ptr,
                                                    ldv_22_container_struct_device_attribute,
                                                    ldv_22_ldv_param_3_2_default);
      }
    }
    {
#line 1410
    ldv_free((void *)ldv_22_ldv_param_3_2_default);
    }
#line 1417
    goto ldv_call_22;
  } else {
#line 1425
    return;
  }
#line 1428
  return;
}
}
#line 489 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___1(spinlock_t *ldv_func_arg1 ) ;
#line 454 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 799 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
static void ldv_blk_put_request_99___0(struct request *ldv_func_arg1 ) ;
#line 805
static struct request *ldv_blk_get_request_98___0(struct request_queue *ldv_func_arg1 ,
                                                  int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 1355 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void ide_dma_off(ide_drive_t *drive ) ;
#line 6 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
struct mutex ide_setting_mtx  =    {{1}, {{{{{0U}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "ide_setting_mtx.wait_lock",
                                                           0, 0UL}}}}, {& ide_setting_mtx.wait_list,
                                                                        & ide_setting_mtx.wait_list},
    0, (void *)(& ide_setting_mtx), {0, {0, 0}, "ide_setting_mtx", 0, 0UL}};
#line 8 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int get_io_32bit(ide_drive_t *drive ) 
{ 


  {
#line 8
  return ((int )drive->io_32bit);
}
}
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int set_io_32bit(ide_drive_t *drive , int arg ) 
{ 


  {
#line 12
  if ((drive->dev_flags & 16384UL) != 0UL) {
#line 13
    return (-1);
  } else {

  }
#line 15
  if ((unsigned int )arg > 3U) {
#line 16
    return (-22);
  } else {

  }
#line 18
  drive->io_32bit = (u8 )arg;
#line 20
  return (0);
}
}
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int get_ksettings(ide_drive_t *drive ) 
{ 


  {
#line 23
  return ((int )drive->dev_flags & 1);
}
}
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int set_ksettings(ide_drive_t *drive , int arg ) 
{ 


  {
#line 27
  if ((unsigned int )arg > 1U) {
#line 28
    return (-22);
  } else {

  }
#line 30
  if (arg != 0) {
#line 31
    drive->dev_flags = drive->dev_flags | 1UL;
  } else {
#line 33
    drive->dev_flags = drive->dev_flags & 0xfffffffffffffffeUL;
  }
#line 35
  return (0);
}
}
#line 38 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int get_using_dma(ide_drive_t *drive ) 
{ 


  {
#line 38
  return ((drive->dev_flags & 2UL) != 0UL);
}
}
#line 40 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int set_using_dma(ide_drive_t *drive , int arg ) 
{ 
  int err ;
  int tmp ;

  {
#line 43
  err = -1;
#line 45
  if ((unsigned int )arg > 1U) {
#line 46
    return (-22);
  } else {

  }
#line 48
  if (((int )*(drive->id + 49UL) & 256) == 0) {
#line 49
    goto out;
  } else {

  }
#line 51
  if ((unsigned long )(drive->hwif)->dma_ops == (unsigned long )((struct ide_dma_ops  const  *)0)) {
#line 52
    goto out;
  } else {

  }
#line 54
  err = 0;
#line 56
  if (arg != 0) {
    {
#line 57
    tmp = ide_set_dma(drive);
    }
#line 57
    if (tmp != 0) {
#line 58
      err = -5;
    } else {

    }
  } else {
    {
#line 60
    ide_dma_off(drive);
    }
  }
  out: ;
#line 63
  return (err);
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int set_pio_mode_abuse(ide_hwif_t *hwif , u8 req_pio ) 
{ 


  {
  {
#line 78
  if ((int )req_pio == 202) {
#line 78
    goto case_202;
  } else {

  }
#line 79
  if ((int )req_pio == 201) {
#line 79
    goto case_201;
  } else {

  }
#line 80
  if ((int )req_pio == 200) {
#line 80
    goto case_200;
  } else {

  }
#line 81
  if ((int )req_pio == 102) {
#line 81
    goto case_102;
  } else {

  }
#line 82
  if ((int )req_pio == 101) {
#line 82
    goto case_101;
  } else {

  }
#line 83
  if ((int )req_pio == 100) {
#line 83
    goto case_100;
  } else {

  }
#line 85
  if ((int )req_pio == 9) {
#line 85
    goto case_9;
  } else {

  }
#line 86
  if ((int )req_pio == 8) {
#line 86
    goto case_8;
  } else {

  }
#line 88
  if ((int )req_pio == 7) {
#line 88
    goto case_7;
  } else {

  }
#line 89
  if ((int )req_pio == 6) {
#line 89
    goto case_6;
  } else {

  }
#line 91
  goto switch_default;
  case_202: /* CIL Label */ ;
  case_201: /* CIL Label */ ;
  case_200: /* CIL Label */ ;
  case_102: /* CIL Label */ ;
  case_101: /* CIL Label */ ;
  case_100: /* CIL Label */ ;
#line 84
  return ((hwif->host_flags & 64U) != 0U);
  case_9: /* CIL Label */ ;
  case_8: /* CIL Label */ ;
#line 87
  return ((hwif->host_flags & 16U) != 0U);
  case_7: /* CIL Label */ ;
  case_6: /* CIL Label */ ;
#line 90
  return ((hwif->host_flags & 32U) != 0U);
  switch_default: /* CIL Label */ ;
#line 92
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 96 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int set_pio_mode(ide_drive_t *drive , int arg ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_port_ops  const  *port_ops ;
  unsigned long flags ;
  int keep_dma ;
  int tmp ;

  {
#line 98
  hwif = drive->hwif;
#line 99
  port_ops = hwif->port_ops;
#line 101
  if ((unsigned int )arg > 255U) {
#line 102
    return (-22);
  } else {

  }
#line 104
  if (((unsigned long )port_ops == (unsigned long )((struct ide_port_ops  const  *)0) || (unsigned long )port_ops->set_pio_mode == (unsigned long )((void (*/* const  */)(struct hwif_s * ,
                                                                                                                                                                          ide_drive_t * ))0)) || (hwif->host_flags & 512U) != 0U) {
#line 106
    return (-38);
  } else {

  }
  {
#line 108
  tmp = set_pio_mode_abuse(drive->hwif, (int )((u8 )arg));
  }
#line 108
  if (tmp != 0) {
#line 109
    drive->pio_mode = (unsigned int )((u8 )arg) + 8U;
#line 111
    if ((unsigned int )arg - 8U <= 1U) {
      {
#line 115
      ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___1(& hwif->lock);
#line 116
      (*(port_ops->set_pio_mode))(hwif, drive);
#line 117
      ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
      }
    } else {
      {
#line 119
      (*(port_ops->set_pio_mode))(hwif, drive);
      }
    }
  } else {
    {
#line 121
    keep_dma = (drive->dev_flags & 2UL) != 0UL;
#line 123
    ide_set_pio(drive, (int )((u8 )arg));
    }
#line 125
    if ((hwif->host_flags & 128U) != 0U) {
#line 126
      if (keep_dma != 0) {
        {
#line 127
        ide_dma_on(drive);
        }
      } else {

      }
    } else {

    }
  }
#line 131
  return (0);
}
}
#line 134 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int get_unmaskirq(ide_drive_t *drive ) 
{ 


  {
#line 134
  return ((drive->dev_flags & 4UL) != 0UL);
}
}
#line 136 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
static int set_unmaskirq(ide_drive_t *drive , int arg ) 
{ 


  {
#line 138
  if ((drive->dev_flags & 8192UL) != 0UL) {
#line 139
    return (-1);
  } else {

  }
#line 141
  if ((unsigned int )arg > 1U) {
#line 142
    return (-22);
  } else {

  }
#line 144
  if (arg != 0) {
#line 145
    drive->dev_flags = drive->dev_flags | 4UL;
  } else {
#line 147
    drive->dev_flags = drive->dev_flags & 0xfffffffffffffffbUL;
  }
#line 149
  return (0);
}
}
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
struct ide_devset  const  ide_devset_io_32bit  =    {& get_io_32bit, & set_io_32bit, 1U};
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
struct ide_devset  const  ide_devset_keepsettings  =    {& get_ksettings, & set_ksettings, 1U};
#line 154 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
struct ide_devset  const  ide_devset_unmaskirq  =    {& get_unmaskirq, & set_unmaskirq, 1U};
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
struct ide_devset  const  ide_devset_using_dma  =    {& get_using_dma, & set_using_dma, 1U};
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
struct ide_devset  const  ide_devset_pio_mode  =    {(int (*)(ide_drive_t * ))0, & set_pio_mode, 1U};
#line 158 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
int ide_devset_execute(ide_drive_t *drive , struct ide_devset  const  *setting , int arg ) 
{ 
  struct request_queue *q ;
  struct request *rq ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 161
  q = drive->queue;
#line 163
  ret = 0;
#line 165
  if (((unsigned int )setting->flags & 1U) == 0U) {
    {
#line 166
    tmp = (*(setting->set))(drive, arg);
    }
#line 166
    return (tmp);
  } else {

  }
  {
#line 168
  rq = ldv_blk_get_request_98___0(q, 0, 16U);
#line 169
  rq->cmd_type = 7;
#line 170
  rq->cmd_len = 5U;
#line 171
  *(rq->cmd) = 33U;
#line 172
  *((int *)rq->cmd + 1U) = arg;
#line 173
  rq->special = (void *)setting->set;
#line 175
  tmp___0 = blk_execute_rq(q, (struct gendisk *)0, rq, 0);
  }
#line 175
  if (tmp___0 != 0) {
#line 176
    ret = rq->errors;
  } else {

  }
  {
#line 177
  ldv_blk_put_request_99___0(rq);
  }
#line 179
  return (ret);
}
}
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-devsets.c"
ide_startstop_t ide_do_devset(ide_drive_t *drive , struct request *rq ) 
{ 
  int err ;
  int (*setfunc)(ide_drive_t * , int  ) ;
  unsigned int tmp ;

  {
  {
#line 184
  setfunc = (int (*)(ide_drive_t * , int  ))rq->special;
#line 186
  err = (*setfunc)(drive, *((int *)rq->cmd + 1U));
  }
#line 187
  if (err != 0) {
#line 188
    rq->errors = err;
  } else {

  }
  {
#line 189
  tmp = blk_rq_bytes((struct request  const  *)rq);
#line 189
  ide_complete_rq(drive, err, tmp);
  }
#line 190
  return (0);
}
}
#line 647 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_24_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) 
{ 


  {
  {
#line 648
  set_pio_mode(arg1, arg2);
  }
#line 649
  return;
}
}
#line 652 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_25_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 653
  get_io_32bit(arg1);
  }
#line 654
  return;
}
}
#line 657 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_25_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) 
{ 


  {
  {
#line 658
  set_io_32bit(arg1, arg2);
  }
#line 659
  return;
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_26_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 663
  get_ksettings(arg1);
  }
#line 664
  return;
}
}
#line 667 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_26_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) 
{ 


  {
  {
#line 668
  set_ksettings(arg1, arg2);
  }
#line 669
  return;
}
}
#line 672 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_29_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 673
  get_unmaskirq(arg1);
  }
#line 674
  return;
}
}
#line 677 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_29_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) 
{ 


  {
  {
#line 678
  set_unmaskirq(arg1, arg2);
  }
#line 679
  return;
}
}
#line 682 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_30_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 683
  get_using_dma(arg1);
  }
#line 684
  return;
}
}
#line 687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
void ldv_dummy_resourceless_instance_callback_30_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) 
{ 


  {
  {
#line 688
  set_using_dma(arg1, arg2);
  }
#line 689
  return;
}
}
#line 1381 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___1(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1384
  ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s();
#line 1386
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1387
  return;
}
}
#line 1397 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
static struct request *ldv_blk_get_request_98___0(struct request_queue *ldv_func_arg1 ,
                                                  int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1400
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1400
  return (tmp);
}
}
#line 1403 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-devsets.c.aux"
static void ldv_blk_put_request_99___0(struct request *ldv_func_arg1 ) 
{ 


  {
  {
#line 1406
  ldv_linux_block_request_put_blk_rq();
  }
#line 1407
  return;
}
}
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned char readb(void const volatile   *addr ) 
{ 
  unsigned char ret ;

  {
#line 54
  __asm__  volatile   ("movb %1,%0": "=q" (ret): "m" (*((unsigned char volatile   *)addr)): "memory");
#line 54
  return (ret);
}
}
#line 55 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned short readw(void const volatile   *addr ) 
{ 
  unsigned short ret ;

  {
#line 55
  __asm__  volatile   ("movw %1,%0": "=r" (ret): "m" (*((unsigned short volatile   *)addr)): "memory");
#line 55
  return (ret);
}
}
#line 56 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
#line 56
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
#line 56
  return (ret);
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void writeb(unsigned char val , void volatile   *addr ) 
{ 


  {
#line 62
  __asm__  volatile   ("movb %0,%1": : "q" (val), "m" (*((unsigned char volatile   *)addr)): "memory");
#line 63
  return;
}
}
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void writew(unsigned short val , void volatile   *addr ) 
{ 


  {
#line 63
  __asm__  volatile   ("movw %0,%1": : "r" (val), "m" (*((unsigned short volatile   *)addr)): "memory");
#line 64
  return;
}
}
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
#line 64
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
#line 65
  return;
}
}
#line 313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void outb(unsigned char value , int port ) 
{ 


  {
#line 313
  __asm__  volatile   ("outb %b0, %w1": : "a" (value), "Nd" (port));
#line 314
  return;
}
}
#line 313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static unsigned char inb(int port ) 
{ 
  unsigned char value ;

  {
#line 313
  __asm__  volatile   ("inb %w1, %b0": "=a" (value): "Nd" (port));
#line 313
  return (value);
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void outsw(int port , void const   *addr , unsigned long count ) 
{ 


  {
#line 314
  __asm__  volatile   ("rep; outsw": "+S" (addr), "+c" (count): "d" (port));
#line 315
  return;
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void insw(int port , void *addr , unsigned long count ) 
{ 


  {
#line 314
  __asm__  volatile   ("rep; insw": "+D" (addr), "+c" (count): "d" (port));
#line 315
  return;
}
}
#line 315 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void outsl(int port , void const   *addr , unsigned long count ) 
{ 


  {
#line 315
  __asm__  volatile   ("rep; outsl": "+S" (addr), "+c" (count): "d" (port));
#line 316
  return;
}
}
#line 315 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void insl(int port , void *addr , unsigned long count ) 
{ 


  {
#line 315
  __asm__  volatile   ("rep; insl": "+D" (addr), "+c" (count): "d" (port));
#line 316
  return;
}
}
#line 1082 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void ide_exec_command(ide_hwif_t *hwif , u8 cmd ) ;
#line 1083
u8 ide_read_status(ide_hwif_t *hwif ) ;
#line 1084
u8 ide_read_altstatus(ide_hwif_t *hwif ) ;
#line 1085
void ide_write_devctl(ide_hwif_t *hwif , u8 ctl ) ;
#line 1087
void ide_dev_select(ide_drive_t *drive ) ;
#line 1088
void ide_tf_load(ide_drive_t *drive , struct ide_taskfile *tf , u8 valid ) ;
#line 1089
void ide_tf_read(ide_drive_t *drive , struct ide_taskfile *tf , u8 valid ) ;
#line 1091
void ide_input_data(ide_drive_t *drive , struct ide_cmd *cmd , void *buf , unsigned int len ) ;
#line 1092
void ide_output_data(ide_drive_t *drive , struct ide_cmd *cmd , void *buf , unsigned int len ) ;
#line 8 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/ide_iops.h"
__inline static void __ide_mm_insw(void *port , void *addr , u32 count ) 
{ 
  u32 tmp ;

  {
#line 10
  goto ldv_38193;
  ldv_38192: 
  {
#line 11
  *((u16 *)addr) = readw((void const volatile   *)port);
#line 12
  addr = addr + 2UL;
  }
  ldv_38193: 
#line 10
  tmp = count;
#line 10
  count = count - 1U;
#line 10
  if (tmp != 0U) {
#line 12
    goto ldv_38192;
  } else {

  }

#line 17
  return;
}
}
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/ide_iops.h"
__inline static void __ide_mm_insl(void *port , void *addr , u32 count ) 
{ 
  u32 tmp ;

  {
#line 18
  goto ldv_38201;
  ldv_38200: 
  {
#line 19
  *((u32 *)addr) = readl((void const volatile   *)port);
#line 20
  addr = addr + 4UL;
  }
  ldv_38201: 
#line 18
  tmp = count;
#line 18
  count = count - 1U;
#line 18
  if (tmp != 0U) {
#line 20
    goto ldv_38200;
  } else {

  }

#line 25
  return;
}
}
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/ide_iops.h"
__inline static void __ide_mm_outsw(void *port , void *addr , u32 count ) 
{ 
  u32 tmp ;

  {
#line 26
  goto ldv_38209;
  ldv_38208: 
  {
#line 27
  writew((int )*((u16 *)addr), (void volatile   *)port);
#line 28
  addr = addr + 2UL;
  }
  ldv_38209: 
#line 26
  tmp = count;
#line 26
  count = count - 1U;
#line 26
  if (tmp != 0U) {
#line 28
    goto ldv_38208;
  } else {

  }

#line 33
  return;
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/ide_iops.h"
__inline static void __ide_mm_outsl(void *port , void *addr , u32 count ) 
{ 
  u32 tmp ;

  {
#line 34
  goto ldv_38217;
  ldv_38216: 
  {
#line 35
  writel(*((u32 *)addr), (void volatile   *)port);
#line 36
  addr = addr + 4UL;
  }
  ldv_38217: 
#line 34
  tmp = count;
#line 34
  count = count - 1U;
#line 34
  if (tmp != 0U) {
#line 36
    goto ldv_38216;
  } else {

  }

#line 41
  return;
}
}
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static u8 ide_inb(unsigned long port ) 
{ 
  unsigned char tmp ;

  {
  {
#line 19
  tmp = inb((int )port);
  }
#line 19
  return (tmp);
}
}
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static void ide_outb(u8 val , unsigned long port ) 
{ 


  {
  {
#line 24
  outb((int )val, (int )port);
  }
#line 25
  return;
}
}
#line 31 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static u8 ide_mm_inb(unsigned long port ) 
{ 
  unsigned char tmp ;

  {
  {
#line 33
  tmp = readb((void const volatile   *)port);
  }
#line 33
  return (tmp);
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static void ide_mm_outb(u8 value , unsigned long port ) 
{ 


  {
  {
#line 38
  writeb((int )value, (void volatile   *)port);
  }
#line 39
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
void ide_exec_command(ide_hwif_t *hwif , u8 cmd ) 
{ 


  {
#line 43
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 44
    writeb((int )cmd, (void volatile   *)hwif->io_ports.__annonCompField81.command_addr);
    }
  } else {
    {
#line 46
    outb((int )cmd, (int )hwif->io_ports.__annonCompField81.command_addr);
    }
  }
#line 47
  return;
}
}
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_exec_command[17U]  = 
#line 48
  {      'i',      'd',      'e',      '_', 
        'e',      'x',      'e',      'c', 
        '_',      'c',      'o',      'm', 
        'm',      'a',      'n',      'd', 
        '\000'};
#line 48
struct kernel_symbol  const  __ksymtab_ide_exec_command ;
#line 48 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_exec_command  =    {(unsigned long )(& ide_exec_command), (char const   *)(& __kstrtab_ide_exec_command)};
#line 50 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
u8 ide_read_status(ide_hwif_t *hwif ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
#line 52
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 53
    tmp = readb((void const volatile   *)hwif->io_ports.__annonCompField81.status_addr);
    }
#line 53
    return (tmp);
  } else {
    {
#line 55
    tmp___0 = inb((int )hwif->io_ports.__annonCompField81.status_addr);
    }
#line 55
    return (tmp___0);
  }
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_read_status[16U]  = 
#line 57
  {      'i',      'd',      'e',      '_', 
        'r',      'e',      'a',      'd', 
        '_',      's',      't',      'a', 
        't',      'u',      's',      '\000'};
#line 57
struct kernel_symbol  const  __ksymtab_ide_read_status ;
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_read_status  =    {(unsigned long )(& ide_read_status), (char const   *)(& __kstrtab_ide_read_status)};
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
u8 ide_read_altstatus(ide_hwif_t *hwif ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
#line 61
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 62
    tmp = readb((void const volatile   *)hwif->io_ports.ctl_addr);
    }
#line 62
    return (tmp);
  } else {
    {
#line 64
    tmp___0 = inb((int )hwif->io_ports.ctl_addr);
    }
#line 64
    return (tmp___0);
  }
}
}
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_read_altstatus[19U]  = 
#line 66
  {      'i',      'd',      'e',      '_', 
        'r',      'e',      'a',      'd', 
        '_',      'a',      'l',      't', 
        's',      't',      'a',      't', 
        'u',      's',      '\000'};
#line 66
struct kernel_symbol  const  __ksymtab_ide_read_altstatus ;
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_read_altstatus  =    {(unsigned long )(& ide_read_altstatus), (char const   *)(& __kstrtab_ide_read_altstatus)};
#line 68 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
void ide_write_devctl(ide_hwif_t *hwif , u8 ctl ) 
{ 


  {
#line 70
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 71
    writeb((int )ctl, (void volatile   *)hwif->io_ports.ctl_addr);
    }
  } else {
    {
#line 73
    outb((int )ctl, (int )hwif->io_ports.ctl_addr);
    }
  }
#line 74
  return;
}
}
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_write_devctl[17U]  = 
#line 75
  {      'i',      'd',      'e',      '_', 
        'w',      'r',      'i',      't', 
        'e',      '_',      'd',      'e', 
        'v',      'c',      't',      'l', 
        '\000'};
#line 75
struct kernel_symbol  const  __ksymtab_ide_write_devctl ;
#line 75 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_write_devctl  =    {(unsigned long )(& ide_write_devctl), (char const   *)(& __kstrtab_ide_write_devctl)};
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
void ide_dev_select(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u8 select ;

  {
#line 79
  hwif = drive->hwif;
#line 80
  select = (u8 )((unsigned int )drive->select | 160U);
#line 82
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 83
    writeb((int )select, (void volatile   *)hwif->io_ports.device_addr);
    }
  } else {
    {
#line 85
    outb((int )select, (int )hwif->io_ports.device_addr);
    }
  }
#line 86
  return;
}
}
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_dev_select[15U]  = 
#line 87
  {      'i',      'd',      'e',      '_', 
        'd',      'e',      'v',      '_', 
        's',      'e',      'l',      'e', 
        'c',      't',      '\000'};
#line 87
struct kernel_symbol  const  __ksymtab_ide_dev_select ;
#line 87 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_dev_select  =    {(unsigned long )(& ide_dev_select), (char const   *)(& __kstrtab_ide_dev_select)};
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
void ide_tf_load(ide_drive_t *drive , struct ide_taskfile *tf , u8 valid ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_io_ports *io_ports ;
  void (*tf_outb)(u8  , unsigned long  ) ;
  u8 mmio ;

  {
#line 91
  hwif = drive->hwif;
#line 92
  io_ports = & hwif->io_ports;
#line 94
  mmio = (hwif->host_flags & 65536U) != 0U;
#line 96
  if ((unsigned int )mmio != 0U) {
#line 97
    tf_outb = & ide_mm_outb;
  } else {
#line 99
    tf_outb = & ide_outb;
  }
#line 101
  if (((int )valid & 2) != 0) {
    {
#line 102
    (*tf_outb)((int )tf->__annonCompField83.feature, io_ports->__annonCompField80.feature_addr);
    }
  } else {

  }
#line 103
  if (((int )valid & 4) != 0) {
    {
#line 104
    (*tf_outb)((int )tf->nsect, io_ports->nsect_addr);
    }
  } else {

  }
#line 105
  if (((int )valid & 8) != 0) {
    {
#line 106
    (*tf_outb)((int )tf->lbal, io_ports->lbal_addr);
    }
  } else {

  }
#line 107
  if (((int )valid & 16) != 0) {
    {
#line 108
    (*tf_outb)((int )tf->lbam, io_ports->lbam_addr);
    }
  } else {

  }
#line 109
  if (((int )valid & 32) != 0) {
    {
#line 110
    (*tf_outb)((int )tf->lbah, io_ports->lbah_addr);
    }
  } else {

  }
#line 111
  if (((int )valid & 64) != 0) {
    {
#line 112
    (*tf_outb)((int )tf->device, io_ports->device_addr);
    }
  } else {

  }
#line 113
  return;
}
}
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_tf_load[12U]  = 
#line 114
  {      'i',      'd',      'e',      '_', 
        't',      'f',      '_',      'l', 
        'o',      'a',      'd',      '\000'};
#line 114
struct kernel_symbol  const  __ksymtab_ide_tf_load ;
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_tf_load  =    {(unsigned long )(& ide_tf_load), (char const   *)(& __kstrtab_ide_tf_load)};
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
void ide_tf_read(ide_drive_t *drive , struct ide_taskfile *tf , u8 valid ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_io_ports *io_ports ;
  u8 (*tf_inb)(unsigned long  ) ;
  u8 mmio ;

  {
#line 118
  hwif = drive->hwif;
#line 119
  io_ports = & hwif->io_ports;
#line 121
  mmio = (hwif->host_flags & 65536U) != 0U;
#line 123
  if ((unsigned int )mmio != 0U) {
#line 124
    tf_inb = & ide_mm_inb;
  } else {
#line 126
    tf_inb = & ide_inb;
  }
#line 128
  if (((int )valid & 2) != 0) {
    {
#line 129
    tf->__annonCompField83.error = (*tf_inb)(io_ports->__annonCompField80.feature_addr);
    }
  } else {

  }
#line 130
  if (((int )valid & 4) != 0) {
    {
#line 131
    tf->nsect = (*tf_inb)(io_ports->nsect_addr);
    }
  } else {

  }
#line 132
  if (((int )valid & 8) != 0) {
    {
#line 133
    tf->lbal = (*tf_inb)(io_ports->lbal_addr);
    }
  } else {

  }
#line 134
  if (((int )valid & 16) != 0) {
    {
#line 135
    tf->lbam = (*tf_inb)(io_ports->lbam_addr);
    }
  } else {

  }
#line 136
  if (((int )valid & 32) != 0) {
    {
#line 137
    tf->lbah = (*tf_inb)(io_ports->lbah_addr);
    }
  } else {

  }
#line 138
  if (((int )valid & 64) != 0) {
    {
#line 139
    tf->device = (*tf_inb)(io_ports->device_addr);
    }
  } else {

  }
#line 140
  return;
}
}
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_tf_read[12U]  = 
#line 141
  {      'i',      'd',      'e',      '_', 
        't',      'f',      '_',      'r', 
        'e',      'a',      'd',      '\000'};
#line 141
struct kernel_symbol  const  __ksymtab_ide_tf_read ;
#line 141 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_tf_read  =    {(unsigned long )(& ide_tf_read), (char const   *)(& __kstrtab_ide_tf_read)};
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static void ata_vlb_sync(unsigned long port ) 
{ 


  {
  {
#line 152
  inb((int )port);
#line 153
  inb((int )port);
#line 154
  inb((int )port);
  }
#line 155
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
void ide_input_data(ide_drive_t *drive , struct ide_cmd *cmd , void *buf , unsigned int len ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_io_ports *io_ports ;
  unsigned long data_addr ;
  unsigned int words ;
  u8 io_32bit ;
  u8 mmio ;
  unsigned long flags ;
  int tmp ;

  {
#line 167
  hwif = drive->hwif;
#line 168
  io_ports = & hwif->io_ports;
#line 169
  data_addr = io_ports->data_addr;
#line 170
  words = (len + 1U) >> 1;
#line 171
  io_32bit = drive->io_32bit;
#line 172
  mmio = (hwif->host_flags & 65536U) != 0U;
#line 174
  if ((unsigned int )io_32bit != 0U) {
#line 175
    flags = flags;
#line 177
    if (((int )io_32bit & 2) != 0 && (unsigned int )mmio == 0U) {
      {
#line 178
      flags = arch_local_irq_save();
#line 178
      trace_hardirqs_off();
#line 179
      ata_vlb_sync(io_ports->nsect_addr);
      }
    } else {

    }
#line 182
    words = words >> 1;
#line 183
    if ((unsigned int )mmio != 0U) {
      {
#line 184
      __ide_mm_insl((void *)data_addr, buf, words);
      }
    } else {
      {
#line 186
      insl((int )data_addr, buf, (unsigned long )words);
      }
    }
#line 188
    if (((int )io_32bit & 2) != 0 && (unsigned int )mmio == 0U) {
      {
#line 189
      tmp = arch_irqs_disabled_flags(flags);
      }
#line 189
      if (tmp != 0) {
        {
#line 189
        arch_local_irq_restore(flags);
#line 189
        trace_hardirqs_off();
        }
      } else {
        {
#line 189
        trace_hardirqs_on();
#line 189
        arch_local_irq_restore(flags);
        }
      }
    } else {

    }
#line 191
    if (((len + 1U) & 3U) <= 1U) {
#line 192
      return;
    } else {

    }
#line 194
    buf = buf + ((unsigned long )len & 4294967292UL);
#line 195
    words = 1U;
  } else {

  }
#line 198
  if ((unsigned int )mmio != 0U) {
    {
#line 199
    __ide_mm_insw((void *)data_addr, buf, words);
    }
  } else {
    {
#line 201
    insw((int )data_addr, buf, (unsigned long )words);
    }
  }
#line 202
  return;
}
}
#line 203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_input_data[15U]  = 
#line 203
  {      'i',      'd',      'e',      '_', 
        'i',      'n',      'p',      'u', 
        't',      '_',      'd',      'a', 
        't',      'a',      '\000'};
#line 203
struct kernel_symbol  const  __ksymtab_ide_input_data ;
#line 203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_input_data  =    {(unsigned long )(& ide_input_data), (char const   *)(& __kstrtab_ide_input_data)};
#line 208 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
void ide_output_data(ide_drive_t *drive , struct ide_cmd *cmd , void *buf , unsigned int len ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_io_ports *io_ports ;
  unsigned long data_addr ;
  unsigned int words ;
  u8 io_32bit ;
  u8 mmio ;
  unsigned long flags ;
  int tmp ;

  {
#line 211
  hwif = drive->hwif;
#line 212
  io_ports = & hwif->io_ports;
#line 213
  data_addr = io_ports->data_addr;
#line 214
  words = (len + 1U) >> 1;
#line 215
  io_32bit = drive->io_32bit;
#line 216
  mmio = (hwif->host_flags & 65536U) != 0U;
#line 218
  if ((unsigned int )io_32bit != 0U) {
#line 219
    flags = flags;
#line 221
    if (((int )io_32bit & 2) != 0 && (unsigned int )mmio == 0U) {
      {
#line 222
      flags = arch_local_irq_save();
#line 222
      trace_hardirqs_off();
#line 223
      ata_vlb_sync(io_ports->nsect_addr);
      }
    } else {

    }
#line 226
    words = words >> 1;
#line 227
    if ((unsigned int )mmio != 0U) {
      {
#line 228
      __ide_mm_outsl((void *)data_addr, buf, words);
      }
    } else {
      {
#line 230
      outsl((int )data_addr, (void const   *)buf, (unsigned long )words);
      }
    }
#line 232
    if (((int )io_32bit & 2) != 0 && (unsigned int )mmio == 0U) {
      {
#line 233
      tmp = arch_irqs_disabled_flags(flags);
      }
#line 233
      if (tmp != 0) {
        {
#line 233
        arch_local_irq_restore(flags);
#line 233
        trace_hardirqs_off();
        }
      } else {
        {
#line 233
        trace_hardirqs_on();
#line 233
        arch_local_irq_restore(flags);
        }
      }
    } else {

    }
#line 235
    if (((len + 1U) & 3U) <= 1U) {
#line 236
      return;
    } else {

    }
#line 238
    buf = buf + ((unsigned long )len & 4294967292UL);
#line 239
    words = 1U;
  } else {

  }
#line 242
  if ((unsigned int )mmio != 0U) {
    {
#line 243
    __ide_mm_outsw((void *)data_addr, buf, words);
    }
  } else {
    {
#line 245
    outsw((int )data_addr, (void const   *)buf, (unsigned long )words);
    }
  }
#line 246
  return;
}
}
#line 247 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
static char const   __kstrtab_ide_output_data[16U]  = 
#line 247
  {      'i',      'd',      'e',      '_', 
        'o',      'u',      't',      'p', 
        'u',      't',      '_',      'd', 
        'a',      't',      'a',      '\000'};
#line 247
struct kernel_symbol  const  __ksymtab_ide_output_data ;
#line 247 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct kernel_symbol  const  __ksymtab_ide_output_data  =    {(unsigned long )(& ide_output_data), (char const   *)(& __kstrtab_ide_output_data)};
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-io-std.c"
struct ide_tp_ops  const  default_tp_ops  = 
#line 249
     {& ide_exec_command, & ide_read_status, & ide_read_altstatus, & ide_write_devctl,
    & ide_dev_select, & ide_tf_load, & ide_tf_read, & ide_input_data, & ide_output_data};
#line 647 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_10(void (*arg0)(struct ide_drive_s * ,
                                                                 struct ide_cmd * ,
                                                                 void * , unsigned int  ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ,
                                                    void *arg3 , unsigned int arg4 ) 
{ 


  {
  {
#line 648
  ide_input_data(arg1, arg2, arg3, arg4);
  }
#line 649
  return;
}
}
#line 652 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_13(void (*arg0)(struct ide_drive_s * ,
                                                                 struct ide_cmd * ,
                                                                 void * , unsigned int  ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ,
                                                    void *arg3 , unsigned int arg4 ) 
{ 


  {
  {
#line 653
  ide_output_data(arg1, arg2, arg3, arg4);
  }
#line 654
  return;
}
}
#line 657 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_16(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 658
  ide_read_altstatus(arg1);
  }
#line 659
  return;
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_17(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 663
  ide_read_status(arg1);
  }
#line 664
  return;
}
}
#line 667 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_18(void (*arg0)(struct ide_drive_s * ,
                                                                 struct ide_taskfile * ,
                                                                 unsigned char  ) ,
                                                    struct ide_drive_s *arg1 , struct ide_taskfile *arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 668
  ide_tf_load(arg1, arg2, (int )arg3);
  }
#line 669
  return;
}
}
#line 672 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_21(void (*arg0)(struct ide_drive_s * ,
                                                                 struct ide_taskfile * ,
                                                                 unsigned char  ) ,
                                                    struct ide_drive_s *arg1 , struct ide_taskfile *arg2 ,
                                                    unsigned char arg3 ) 
{ 


  {
  {
#line 673
  ide_tf_read(arg1, arg2, (int )arg3);
  }
#line 674
  return;
}
}
#line 677 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_24(void (*arg0)(struct hwif_s * ,
                                                                 unsigned char  ) ,
                                                    struct hwif_s *arg1 , unsigned char arg2 ) 
{ 


  {
  {
#line 678
  ide_write_devctl(arg1, (int )arg2);
  }
#line 679
  return;
}
}
#line 682 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_3(void (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 683
  ide_dev_select(arg1);
  }
#line 684
  return;
}
}
#line 687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-io-std.c.aux"
void ldv_dummy_resourceless_instance_callback_32_7(void (*arg0)(struct hwif_s * ,
                                                                unsigned char  ) ,
                                                   struct hwif_s *arg1 , unsigned char arg2 ) 
{ 


  {
  {
#line 688
  ide_exec_command(arg1, (int )arg2);
  }
#line 689
  return;
}
}
#line 10 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
extern struct task_struct *current_task ;
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/current.h"
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  {
#line 14
  if (8UL == 1UL) {
#line 14
    goto case_1;
  } else {

  }
#line 14
  if (8UL == 2UL) {
#line 14
    goto case_2;
  } else {

  }
#line 14
  if (8UL == 4UL) {
#line 14
    goto case_4;
  } else {

  }
#line 14
  if (8UL == 8UL) {
#line 14
    goto case_8;
  } else {

  }
#line 14
  goto switch_default;
  case_1: /* CIL Label */ 
#line 14
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3552;
  case_2: /* CIL Label */ 
#line 14
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3552;
  case_4: /* CIL Label */ 
#line 14
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3552;
  case_8: /* CIL Label */ 
#line 14
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
#line 14
  goto ldv_3552;
  switch_default: /* CIL Label */ 
  {
#line 14
  __bad_percpu_size();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_3552: ;
#line 14
  return (pfo_ret__);
}
}
#line 489 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-eh.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___2(spinlock_t *ldv_func_arg1 ) ;
#line 493
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_99(spinlock_t *ldv_func_arg1 ) ;
#line 454 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/spinlock.h"
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 458
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 462
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 466
__inline static void ldv_spin_unlock_irqrestore_111(spinlock_t *lock , unsigned long flags ) ;
#line 911 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/wait.h"
extern void prepare_to_wait(wait_queue_head_t * , wait_queue_t * , int  ) ;
#line 914
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
#line 918
extern int autoremove_wake_function(wait_queue_t * , unsigned int  , int  , void * ) ;
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/sched.h"
extern long schedule_timeout_uninterruptible(long  ) ;
#line 1358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void ide_check_dma_crc(ide_drive_t *drive ) ;
#line 7 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static ide_startstop_t ide_ata_error(ide_drive_t *drive , struct request *rq , u8 stat ,
                                     u8 err ) 
{ 
  ide_hwif_t *hwif ;
  u8 tmp ;
  int nsect ;
  u8 tmp___0 ;
  ide_startstop_t tmp___1 ;

  {
#line 10
  hwif = drive->hwif;
#line 12
  if ((int )((signed char )stat) < 0 || (((int )stat & 32) != 0 && (drive->dev_flags & 8388608UL) == 0UL)) {
#line 15
    rq->errors = rq->errors | 3;
  } else
#line 16
  if ((int )stat & 1) {
#line 18
    if ((unsigned int )err == 4U) {
#line 19
      if ((drive->dev_flags & 33554432UL) != 0UL) {
        {
#line 19
        tmp = (*((hwif->tp_ops)->read_status))(hwif);
        }
#line 19
        if ((unsigned int )tmp == 145U) {
#line 22
          return (0);
        } else {

        }
      } else {

      }
    } else
#line 23
    if (((int )err & 132) == 132) {
#line 25
      drive->crc_count = drive->crc_count + 1;
    } else
#line 26
    if (((int )err & 192) != 0) {
#line 28
      rq->errors = 8;
    } else
#line 29
    if (((int )err & 2) != 0) {
#line 31
      rq->errors = rq->errors | 1;
    } else {

    }
  } else {

  }
#line 35
  if ((((int )stat & 8) != 0 && ((int )rq->cmd_flags & 1) == 0) && (hwif->host_flags & 524288U) == 0U) {
    {
#line 37
    nsect = (unsigned int )drive->mult_count != 0U ? (int )drive->mult_count : 1;
#line 39
    ide_pad_transfer(drive, 0, nsect * 512);
    }
  } else {

  }
#line 42
  if (rq->errors > 7 || (rq->cmd_flags & 14ULL) != 0ULL) {
    {
#line 43
    ide_kill_rq(drive, rq);
    }
#line 44
    return (0);
  } else {

  }
  {
#line 47
  tmp___0 = (*((hwif->tp_ops)->read_status))(hwif);
  }
#line 47
  if (((int )tmp___0 & 136) != 0) {
#line 48
    rq->errors = rq->errors | 3;
  } else {

  }
#line 50
  if ((rq->errors & 3) == 3) {
    {
#line 51
    rq->errors = rq->errors + 1;
#line 52
    tmp___1 = ide_do_reset(drive);
    }
#line 52
    return (tmp___1);
  } else {

  }
#line 55
  if (rq->errors & 1) {
#line 56
    drive->special_flags = (u8 )((unsigned int )drive->special_flags | 2U);
  } else {

  }
#line 58
  rq->errors = rq->errors + 1;
#line 60
  return (0);
}
}
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static ide_startstop_t ide_atapi_error(ide_drive_t *drive , struct request *rq , u8 stat ,
                                       u8 err ) 
{ 
  ide_hwif_t *hwif ;
  u8 tmp ;
  ide_startstop_t tmp___0 ;

  {
#line 66
  hwif = drive->hwif;
#line 68
  if ((int )((signed char )stat) < 0 || (((int )stat & 32) != 0 && (drive->dev_flags & 8388608UL) == 0UL)) {
#line 71
    rq->errors = rq->errors | 3;
  } else {

  }
  {
#line 76
  tmp = (*((hwif->tp_ops)->read_status))(hwif);
  }
#line 76
  if (((int )tmp & 136) != 0) {
    {
#line 78
    (*((hwif->tp_ops)->exec_command))(hwif, 225);
    }
  } else {

  }
#line 80
  if (rq->errors > 7) {
    {
#line 81
    ide_kill_rq(drive, rq);
    }
  } else {
#line 83
    if ((rq->errors & 3) == 3) {
      {
#line 84
      rq->errors = rq->errors + 1;
#line 85
      tmp___0 = ide_do_reset(drive);
      }
#line 85
      return (tmp___0);
    } else {

    }
#line 87
    rq->errors = rq->errors + 1;
  }
#line 90
  return (0);
}
}
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static ide_startstop_t __ide_error(ide_drive_t *drive , struct request *rq , u8 stat ,
                                   u8 err ) 
{ 
  ide_startstop_t tmp ;
  ide_startstop_t tmp___0 ;

  {
#line 96
  if ((unsigned int )drive->media == 32U) {
    {
#line 97
    tmp = ide_ata_error(drive, rq, (int )stat, (int )err);
    }
#line 97
    return (tmp);
  } else {

  }
  {
#line 98
  tmp___0 = ide_atapi_error(drive, rq, (int )stat, (int )err);
  }
#line 98
  return (tmp___0);
}
}
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
ide_startstop_t ide_error(ide_drive_t *drive , char const   *msg , u8 stat ) 
{ 
  struct request *rq ;
  u8 err ;
  struct ide_cmd *cmd ;
  unsigned int tmp ;
  ide_startstop_t tmp___0 ;

  {
  {
#line 119
  err = ide_dump_status(drive, msg, (int )stat);
#line 121
  rq = (drive->hwif)->rq;
  }
#line 122
  if ((unsigned long )rq == (unsigned long )((struct request *)0)) {
#line 123
    return (0);
  } else {

  }
#line 126
  if ((unsigned int )rq->cmd_type != 1U) {
#line 127
    if ((unsigned int )rq->cmd_type == 8U) {
#line 128
      cmd = (struct ide_cmd *)rq->special;
#line 130
      if ((unsigned long )cmd != (unsigned long )((struct ide_cmd *)0)) {
        {
#line 131
        ide_complete_cmd(drive, cmd, (int )stat, (int )err);
        }
      } else {

      }
    } else
#line 132
    if ((unsigned int )rq->cmd_type - 4U <= 1U) {
      {
#line 133
      rq->errors = 1;
#line 134
      ide_complete_pm_rq(drive, rq);
      }
#line 135
      return (0);
    } else {

    }
    {
#line 137
    rq->errors = (int )err;
#line 138
    tmp = blk_rq_bytes((struct request  const  *)rq);
#line 138
    ide_complete_rq(drive, (unsigned int )err != 0U ? -5 : 0, tmp);
    }
#line 139
    return (0);
  } else {

  }
  {
#line 142
  tmp___0 = __ide_error(drive, rq, (int )stat, (int )err);
  }
#line 142
  return (tmp___0);
}
}
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static char const   __kstrtab_ide_error[10U]  = 
#line 144
  {      'i',      'd',      'e',      '_', 
        'e',      'r',      'r',      'o', 
        'r',      '\000'};
#line 144
struct kernel_symbol  const  __ksymtab_ide_error ;
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
struct kernel_symbol  const  __ksymtab_ide_error  =    {(unsigned long )(& ide_error), (char const   *)(& __kstrtab_ide_error)};
#line 146 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
__inline static void ide_complete_drive_reset(ide_drive_t *drive , int err ) 
{ 
  struct request *rq ;
  unsigned int tmp ;

  {
#line 148
  rq = (drive->hwif)->rq;
#line 150
  if (((unsigned long )rq != (unsigned long )((struct request *)0) && (unsigned int )rq->cmd_type == 7U) && (unsigned int )*(rq->cmd) == 32U) {
#line 152
    if (err <= 0 && rq->errors == 0) {
#line 153
      rq->errors = -5;
    } else {

    }
    {
#line 154
    tmp = blk_rq_bytes((struct request  const  *)rq);
#line 154
    ide_complete_rq(drive, err, tmp);
    }
  } else {

  }
#line 156
  return;
}
}
#line 159
static ide_startstop_t do_reset1(ide_drive_t *drive , int do_not_try_atapi ) ;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static ide_startstop_t atapi_reset_pollfunc(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_tp_ops  const  *tp_ops ;
  u8 stat ;
  ide_startstop_t tmp ;

  {
  {
#line 169
  hwif = drive->hwif;
#line 170
  tp_ops = hwif->tp_ops;
#line 173
  (*(tp_ops->dev_select))(drive);
#line 174
  __const_udelay(42950UL);
#line 175
  stat = (*(tp_ops->read_status))(hwif);
  }
#line 177
  if ((int )((signed char )stat) >= 0) {
    {
#line 178
    printk("\016%s: ATAPI reset complete\n", (char *)(& drive->name));
    }
  } else {
#line 180
    if ((long )((unsigned long )jiffies - hwif->poll_timeout) < 0L) {
      {
#line 181
      ide_set_handler(drive, & atapi_reset_pollfunc, 12U);
      }
#line 183
      return (1);
    } else {

    }
    {
#line 186
    hwif->polling = 0U;
#line 187
    printk("\v%s: ATAPI reset timed-out, status=0x%02x\n", (char *)(& drive->name),
           (int )stat);
#line 190
    tmp = do_reset1(drive, 1);
    }
#line 190
    return (tmp);
  }
  {
#line 193
  hwif->polling = 0U;
#line 194
  ide_complete_drive_reset(drive, 0);
  }
#line 195
  return (0);
}
}
#line 198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static void ide_reset_report_error(ide_hwif_t *hwif , u8 err ) 
{ 
  char const   *err_master_vals[6U] ;
  u8 err_master ;

  {
  {
#line 200
  err_master_vals[0] = (char const   *)0;
#line 200
  err_master_vals[1] = "passed";
#line 200
  err_master_vals[2] = "formatter device error";
#line 200
  err_master_vals[3] = "sector buffer error";
#line 200
  err_master_vals[4] = "ECC circuitry error";
#line 200
  err_master_vals[5] = "controlling MPU error";
#line 205
  err_master = (unsigned int )err & 127U;
#line 207
  printk("\v%s: reset: master: ", (char *)(& hwif->name));
  }
#line 208
  if ((unsigned int )err_master - 1U <= 4U) {
    {
#line 209
    printk("%s", err_master_vals[(int )err_master]);
    }
  } else {
    {
#line 211
    printk("error (0x%02x?)", (int )err);
    }
  }
#line 212
  if ((int )((signed char )err) < 0) {
    {
#line 213
    printk("; slave: failed");
    }
  } else {

  }
  {
#line 214
  printk("\n");
  }
#line 215
  return;
}
}
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static ide_startstop_t reset_pollfunc(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_port_ops  const  *port_ops ;
  u8 tmp ;
  int err ;

  {
#line 225
  hwif = drive->hwif;
#line 226
  port_ops = hwif->port_ops;
#line 228
  err = 0;
#line 230
  if ((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->reset_poll != (unsigned long )((int (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 231
    err = (*(port_ops->reset_poll))(drive);
    }
#line 232
    if (err != 0) {
      {
#line 233
      printk("\v%s: host reset_poll failure for %s.\n", (char *)(& hwif->name), (char *)(& drive->name));
      }
#line 235
      goto out;
    } else {

    }
  } else {

  }
  {
#line 239
  tmp = (*((hwif->tp_ops)->read_status))(hwif);
  }
#line 241
  if ((int )((signed char )tmp) < 0) {
#line 242
    if ((long )((unsigned long )jiffies - hwif->poll_timeout) < 0L) {
      {
#line 243
      ide_set_handler(drive, & reset_pollfunc, 12U);
      }
#line 245
      return (1);
    } else {

    }
    {
#line 247
    printk("\v%s: reset timed-out, status=0x%02x\n", (char *)(& hwif->name), (int )tmp);
#line 249
    drive->failures = drive->failures + 1U;
#line 250
    err = -5;
    }
  } else {
    {
#line 252
    tmp = ide_read_error(drive);
    }
#line 254
    if ((unsigned int )tmp == 1U) {
      {
#line 255
      printk("\016%s: reset: success\n", (char *)(& hwif->name));
#line 256
      drive->failures = 0U;
      }
    } else {
      {
#line 258
      ide_reset_report_error(hwif, (int )tmp);
#line 259
      drive->failures = drive->failures + 1U;
#line 260
      err = -5;
      }
    }
  }
  out: 
  {
#line 264
  hwif->polling = 0U;
#line 265
  ide_complete_drive_reset(drive, err);
  }
#line 266
  return (0);
}
}
#line 269 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static void ide_disk_pre_reset(ide_drive_t *drive ) 
{ 
  int legacy ;

  {
#line 271
  legacy = ((int )*(drive->id + 86UL) & 1024) == 0;
#line 273
  drive->special_flags = legacy != 0 ? 3U : 0U;
#line 276
  drive->mult_count = 0U;
#line 277
  drive->dev_flags = drive->dev_flags & 0xfffffffff7ffffffUL;
#line 279
  if (*((unsigned long *)drive + 10UL) == 0UL) {
#line 281
    drive->mult_req = 0U;
  } else {

  }
#line 283
  if ((int )drive->mult_req != (int )drive->mult_count) {
#line 284
    drive->special_flags = (u8 )((unsigned int )drive->special_flags | 4U);
  } else {

  }
#line 285
  return;
}
}
#line 287 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static void pre_reset(ide_drive_t *drive ) 
{ 
  struct ide_port_ops  const  *port_ops ;

  {
#line 289
  port_ops = (drive->hwif)->port_ops;
#line 291
  if ((unsigned int )drive->media == 32U) {
    {
#line 292
    ide_disk_pre_reset(drive);
    }
  } else {
#line 294
    drive->dev_flags = drive->dev_flags | 524288UL;
  }
#line 296
  if ((drive->dev_flags & 2UL) != 0UL) {
#line 297
    if (drive->crc_count != 0) {
      {
#line 298
      ide_check_dma_crc(drive);
      }
    } else {
      {
#line 300
      ide_dma_off(drive);
      }
    }
  } else {

  }
#line 303
  if ((drive->dev_flags & 1UL) == 0UL) {
#line 304
    if ((drive->dev_flags & 2UL) == 0UL) {
#line 305
      drive->dev_flags = drive->dev_flags & 0xfffffffffffffffbUL;
#line 306
      drive->io_32bit = 0U;
    } else {

    }
#line 308
    return;
  } else {

  }
#line 311
  if ((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->pre_reset != (unsigned long )((void (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 312
    (*(port_ops->pre_reset))(drive);
    }
  } else {

  }
#line 314
  if ((unsigned int )drive->current_speed != 255U) {
#line 315
    drive->desired_speed = drive->current_speed;
  } else {

  }
#line 316
  drive->current_speed = 255U;
#line 317
  return;
}
}
#line 334 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static ide_startstop_t do_reset1(ide_drive_t *drive , int do_not_try_atapi ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_io_ports *io_ports ;
  struct ide_tp_ops  const  *tp_ops ;
  struct ide_port_ops  const  *port_ops ;
  ide_drive_t *tdrive ;
  unsigned long flags ;
  unsigned long timeout ;
  int i ;
  wait_queue_t wait ;
  struct task_struct *tmp ;
  long tmp___0 ;
  unsigned long now ;
  long tmp___1 ;

  {
  {
#line 336
  hwif = drive->hwif;
#line 337
  io_ports = & hwif->io_ports;
#line 338
  tp_ops = hwif->tp_ops;
#line 343
  tmp = get_current();
#line 343
  wait.flags = 0U;
#line 343
  wait.private = (void *)tmp;
#line 343
  wait.func = & autoremove_wake_function;
#line 343
  wait.task_list.next = & wait.task_list;
#line 343
  wait.task_list.prev = & wait.task_list;
#line 345
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___2(& hwif->lock);
#line 348
  tmp___0 = __builtin_expect((unsigned long )hwif->handler != (unsigned long )((ide_startstop_t (*)(ide_drive_t * ))0),
                             0L);
  }
#line 348
  if (tmp___0 != 0L) {
    {
#line 348
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-eh.c"),
                         "i" (348), "i" (12UL));
#line 348
    __builtin_unreachable();
    }
  } else {

  }
#line 351
  if ((unsigned int )drive->media != 32U && do_not_try_atapi == 0) {
    {
#line 352
    pre_reset(drive);
#line 353
    (*(tp_ops->dev_select))(drive);
#line 354
    __const_udelay(85900UL);
#line 355
    (*(tp_ops->exec_command))(hwif, 8);
#line 356
    __const_udelay(2000UL);
#line 357
    hwif->poll_timeout = (unsigned long )jiffies + 7500UL;
#line 358
    hwif->polling = 1U;
#line 359
    __ide_set_handler(drive, & atapi_reset_pollfunc, 12U);
#line 360
    ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
    }
#line 361
    return (1);
  } else {

  }
  ldv_38371: 
  {
#line 368
  prepare_to_wait(& ide_park_wq, & wait, 2);
#line 369
  timeout = jiffies;
#line 370
  i = 0;
  }
#line 370
  goto ldv_38362;
  ldv_38361: ;
#line 370
  if ((tdrive->dev_flags & 64UL) != 0UL) {
#line 372
    if ((tdrive->dev_flags & 134217728UL) != 0UL && (long )(timeout - tdrive->sleep) < 0L) {
#line 373
      timeout = tdrive->sleep;
    } else {

    }
  } else {

  }
#line 370
  i = i + 1;
  ldv_38362: 
#line 370
  tdrive = hwif->devices[i];
#line 370
  if ((unsigned long )tdrive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 372
    goto ldv_38361;
  } else {

  }
#line 376
  now = jiffies;
#line 377
  if ((long )(now - timeout) >= 0L) {
#line 378
    goto ldv_38370;
  } else {

  }
  {
#line 380
  ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
#line 381
  tmp___1 = schedule_timeout_uninterruptible((long )(timeout - now));
#line 381
  timeout = (unsigned long )tmp___1;
#line 382
  ldv___ldv_linux_kernel_locking_spinlock_spin_lock_99(& hwif->lock);
  }
#line 383
  if (timeout != 0UL) {
#line 385
    goto ldv_38371;
  } else {

  }
  ldv_38370: 
  {
#line 384
  finish_wait(& ide_park_wq, & wait);
#line 390
  i = 0;
  }
#line 390
  goto ldv_38373;
  ldv_38372: 
  {
#line 391
  pre_reset(tdrive);
#line 390
  i = i + 1;
  }
  ldv_38373: 
#line 390
  tdrive = hwif->devices[i];
#line 390
  if ((unsigned long )tdrive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 392
    goto ldv_38372;
  } else {

  }

#line 393
  if (io_ports->ctl_addr == 0UL) {
    {
#line 394
    ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
#line 395
    ide_complete_drive_reset(drive, -6);
    }
#line 396
    return (0);
  } else {

  }
  {
#line 408
  (*(tp_ops->write_devctl))(hwif, 14);
#line 410
  __const_udelay(42950UL);
#line 412
  (*(tp_ops->write_devctl))(hwif, (drive->dev_flags & 0xffffffff80000000UL) != 0UL ? 8 : 10);
#line 416
  __const_udelay(42950UL);
#line 417
  hwif->poll_timeout = (unsigned long )jiffies + 7500UL;
#line 418
  hwif->polling = 1U;
#line 419
  __ide_set_handler(drive, & reset_pollfunc, 12U);
#line 426
  port_ops = hwif->port_ops;
  }
#line 427
  if ((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->resetproc != (unsigned long )((void (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 428
    (*(port_ops->resetproc))(drive);
    }
  } else {

  }
  {
#line 430
  ldv_spin_unlock_irqrestore_111(& hwif->lock, flags);
  }
#line 431
  return (1);
}
}
#line 438 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
ide_startstop_t ide_do_reset(ide_drive_t *drive ) 
{ 
  ide_startstop_t tmp ;

  {
  {
#line 440
  tmp = do_reset1(drive, 0);
  }
#line 440
  return (tmp);
}
}
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
static char const   __kstrtab_ide_do_reset[13U]  = 
#line 442
  {      'i',      'd',      'e',      '_', 
        'd',      'o',      '_',      'r', 
        'e',      's',      'e',      't', 
        '\000'};
#line 442
struct kernel_symbol  const  __ksymtab_ide_do_reset ;
#line 442 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-eh.c"
struct kernel_symbol  const  __ksymtab_ide_do_reset  =    {(unsigned long )(& ide_do_reset), (char const   *)(& __kstrtab_ide_do_reset)};
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-eh.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_96___2(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1330
  ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s();
#line 1332
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1333
  return;
}
}
#line 1351 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-eh.c.aux"
static void ldv___ldv_linux_kernel_locking_spinlock_spin_lock_99(spinlock_t *ldv_func_arg1 ) 
{ 


  {
  {
#line 1354
  ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s();
#line 1356
  __ldv_linux_kernel_locking_spinlock_spin_lock(ldv_func_arg1);
  }
#line 1357
  return;
}
}
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/string_64.h"
extern size_t strlen(char const   * ) ;
#line 1494 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
int ide_scan_pio_blacklist(char *model ) ;
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pio-blacklist.c"
static struct ide_pio_info ide_pio_blacklist[50U]  = 
#line 15 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pio-blacklist.c"
  {      {"Conner Peripherals 540MB - CFS540A", 3}, 
        {"WDC AC2700", 3}, 
        {"WDC AC2540", 3}, 
        {"WDC AC2420", 3}, 
        {"WDC AC2340", 3}, 
        {"WDC AC2250", 0}, 
        {"WDC AC2200", 0}, 
        {"WDC AC21200", 4}, 
        {"WDC AC2120", 0}, 
        {"WDC AC2850", 3}, 
        {"WDC AC1270", 3}, 
        {"WDC AC1170", 1}, 
        {"WDC AC1210", 1}, 
        {"WDC AC280", 0}, 
        {"WDC AC31000", 3}, 
        {"WDC AC31200", 3}, 
        {"Maxtor 7131 AT", 1}, 
        {"Maxtor 7171 AT", 1}, 
        {"Maxtor 7213 AT", 1}, 
        {"Maxtor 7245 AT", 1}, 
        {"Maxtor 7345 AT", 1}, 
        {"Maxtor 7546 AT", 3}, 
        {"Maxtor 7540 AV", 3}, 
        {"SAMSUNG SHD-3121A", 1}, 
        {"SAMSUNG SHD-3122A", 1}, 
        {"SAMSUNG SHD-3172A", 1}, 
        {"ST5660A", 3}, 
        {"ST3660A", 3}, 
        {"ST3630A", 3}, 
        {"ST3655A", 3}, 
        {"ST3391A", 3}, 
        {"ST3390A", 1}, 
        {"ST3600A", 1}, 
        {"ST3290A", 0}, 
        {"ST3144A", 0}, 
        {"ST3491A", 1}, 
        {"QUANTUM ELS127A", 0}, 
        {"QUANTUM ELS170A", 0}, 
        {"QUANTUM LPS240A", 0}, 
        {"QUANTUM LPS210A", 3}, 
        {"QUANTUM LPS270A", 3}, 
        {"QUANTUM LPS365A", 3}, 
        {"QUANTUM LPS540A", 3}, 
        {"QUANTUM LIGHTNING 540A", 3}, 
        {"QUANTUM LIGHTNING 730A", 3}, 
        {"QUANTUM FIREBALL_540", 3}, 
        {"QUANTUM FIREBALL_640", 3}, 
        {"QUANTUM FIREBALL_1080", 3}, 
        {"QUANTUM FIREBALL_1280", 3}, 
        {(char const   *)0, 0}};
#line 86 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-pio-blacklist.c"
int ide_scan_pio_blacklist(char *model ) 
{ 
  struct ide_pio_info *p ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 90
  p = (struct ide_pio_info *)(& ide_pio_blacklist);
#line 90
  goto ldv_38196;
  ldv_38195: 
  {
#line 91
  tmp = strlen(p->name);
#line 91
  tmp___0 = strncmp(p->name, (char const   *)model, tmp);
  }
#line 91
  if (tmp___0 == 0) {
#line 92
    return (p->pio);
  } else {

  }
#line 90
  p = p + 1;
  ldv_38196: ;
#line 90
  if ((unsigned long )p->name != (unsigned long )((char const   *)0)) {
#line 92
    goto ldv_38195;
  } else {

  }

#line 94
  return (-1);
}
}
#line 437 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/bitops.h"
__inline static int fls(int x ) 
{ 
  int r ;

  {
#line 451
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
#line 464
  return (r + 1);
}
}
#line 854 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ata.h"
__inline static bool ata_id_pio_need_iordy(u16 const   *id , u8 const   pio ) 
{ 
  bool tmp ;

  {
#line 857
  if ((unsigned int )((unsigned char )pio) > 4U) {
    {
#line 857
    tmp = ata_id_is_cfa(id);
    }
#line 857
    if ((int )tmp) {
#line 858
      return (0);
    } else {

    }
  } else {

  }
#line 860
  if ((unsigned int )((unsigned char )pio) > 2U) {
#line 861
    return (1);
  } else {

  }
#line 863
  return (((int )*(id + 49UL) & 2048) != 0);
}
}
#line 1495 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
char const   *ide_xfer_verbose(u8 mode ) ;
#line 1496
int ide_pio_need_iordy(ide_drive_t *drive , u8 const   pio ) ;
#line 1497
int ide_set_pio_mode(ide_drive_t *drive , u8 const   mode ) ;
#line 1498
int ide_set_dma_mode(ide_drive_t *drive , u8 const   mode ) ;
#line 9 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static char const   *udma_str[8U]  = 
#line 9 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
  {      "UDMA/16",      "UDMA/25",      "UDMA/33",      "UDMA/44", 
        "UDMA/66",      "UDMA/100",      "UDMA/133",      "UDMA7"};
#line 12 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static char const   *mwdma_str[5U]  = {      "MWDMA0",      "MWDMA1",      "MWDMA2",      "MWDMA3", 
        "MWDMA4"};
#line 14 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static char const   *swdma_str[3U]  = {      "SWDMA0",      "SWDMA1",      "SWDMA2"};
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static char const   *pio_str[7U]  = {      "PIO0",      "PIO1",      "PIO2",      "PIO3", 
        "PIO4",      "PIO5",      "PIO6"};
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
char const   *ide_xfer_verbose(u8 mode ) 
{ 
  char const   *s ;
  u8 i ;

  {
#line 30
  i = (unsigned int )mode & 15U;
#line 32
  if ((unsigned int )mode - 64U <= 7U) {
#line 33
    s = udma_str[(int )i];
  } else
#line 34
  if ((unsigned int )mode - 32U <= 4U) {
#line 35
    s = mwdma_str[(int )i];
  } else
#line 36
  if ((unsigned int )mode - 16U <= 2U) {
#line 37
    s = swdma_str[(int )i];
  } else
#line 38
  if ((unsigned int )mode - 8U <= 6U) {
#line 39
    s = pio_str[(int )i & 7];
  } else
#line 40
  if ((unsigned int )mode == 0U) {
#line 41
    s = "PIO SLOW";
  } else {
#line 43
    s = "XFER ERROR";
  }
#line 45
  return (s);
}
}
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static char const   __kstrtab_ide_xfer_verbose[17U]  = 
#line 47
  {      'i',      'd',      'e',      '_', 
        'x',      'f',      'e',      'r', 
        '_',      'v',      'e',      'r', 
        'b',      'o',      's',      'e', 
        '\000'};
#line 47
struct kernel_symbol  const  __ksymtab_ide_xfer_verbose ;
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
struct kernel_symbol  const  __ksymtab_ide_xfer_verbose  =    {(unsigned long )(& ide_xfer_verbose), (char const   *)(& __kstrtab_ide_xfer_verbose)};
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static u8 ide_get_best_pio_mode(ide_drive_t *drive , u8 mode_wanted , u8 max_mode ) 
{ 
  u16 *id ;
  int pio_mode ;
  int overridden ;
  u8 __min1 ;
  u8 __min2 ;
  int __min1___0 ;
  int __min2___0 ;
  bool tmp ;

  {
#line 64
  id = drive->id;
#line 65
  pio_mode = -1;
#line 65
  overridden = 0;
#line 67
  if ((unsigned int )mode_wanted != 255U) {
#line 68
    __min1 = mode_wanted;
#line 68
    __min2 = max_mode;
#line 68
    return ((u8 )((int )__min1 < (int )__min2 ? __min1 : __min2));
  } else {

  }
#line 70
  if (((drive->hwif)->host_flags & 4U) == 0U) {
    {
#line 71
    pio_mode = ide_scan_pio_blacklist((char *)id + 27U);
    }
  } else {

  }
#line 73
  if (pio_mode != -1) {
    {
#line 74
    printk("\016%s: is on PIO blacklist\n", (char *)(& drive->name));
    }
  } else {
#line 76
    pio_mode = (int )*(id + 51UL) >> 8;
#line 77
    if (pio_mode > 2) {
#line 78
      pio_mode = 2;
#line 79
      overridden = 1;
    } else {

    }
#line 82
    if (((int )*(id + 53UL) & 2) != 0) {
      {
#line 83
      tmp = ata_id_is_cfa((u16 const   *)id);
      }
#line 83
      if ((int )tmp && ((int )*(id + 163UL) & 7) != 0) {
#line 84
        __min1___0 = 2;
#line 84
        __min2___0 = (int )*(id + 163UL) & 7;
#line 84
        pio_mode = (__min1___0 < __min2___0 ? __min1___0 : __min2___0) + 4;
      } else
#line 86
      if (((int )*(id + 49UL) & 2048) != 0) {
#line 87
        if (((int )*(id + 64UL) & 7) != 0) {
#line 88
          overridden = 0;
#line 89
          if (((int )*(id + 64UL) & 4) != 0) {
#line 90
            pio_mode = 5;
          } else
#line 91
          if (((int )*(id + 64UL) & 2) != 0) {
#line 92
            pio_mode = 4;
          } else {
#line 94
            pio_mode = 3;
          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 99
    if (overridden != 0) {
      {
#line 100
      printk("\016%s: tPIO > 2, assuming tPIO = 2\n", (char *)(& drive->name));
      }
    } else {

    }
  }
#line 104
  if (pio_mode > (int )max_mode) {
#line 105
    pio_mode = (int )max_mode;
  } else {

  }
#line 107
  return ((u8 )pio_mode);
}
}
#line 110 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
int ide_pio_need_iordy(ide_drive_t *drive , u8 const   pio ) 
{ 
  bool tmp ;

  {
#line 116
  if ((unsigned int )((unsigned char )pio) == 0U && (int )(drive->hwif)->port_flags & 1) {
#line 117
    return (0);
  } else {

  }
  {
#line 118
  tmp = ata_id_pio_need_iordy((u16 const   *)drive->id, (int )pio);
  }
#line 118
  return ((int )tmp);
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static char const   __kstrtab_ide_pio_need_iordy[19U]  = 
#line 120
  {      'i',      'd',      'e',      '_', 
        'p',      'i',      'o',      '_', 
        'n',      'e',      'e',      'd', 
        '_',      'i',      'o',      'r', 
        'd',      'y',      '\000'};
#line 120
struct kernel_symbol  const  __ksymtab_ide_pio_need_iordy ;
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
struct kernel_symbol  const  __ksymtab_ide_pio_need_iordy  =    {(unsigned long )(& ide_pio_need_iordy), (char const   *)(& __kstrtab_ide_pio_need_iordy)};
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
int ide_set_pio_mode(ide_drive_t *drive , u8 const   mode ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_port_ops  const  *port_ops ;
  int tmp ;
  int tmp___0 ;

  {
#line 124
  hwif = drive->hwif;
#line 125
  port_ops = hwif->port_ops;
#line 127
  if ((hwif->host_flags & 512U) != 0U) {
#line 128
    return (0);
  } else {

  }
#line 130
  if ((unsigned long )port_ops == (unsigned long )((struct ide_port_ops  const  *)0) || (unsigned long )port_ops->set_pio_mode == (unsigned long )((void (*/* const  */)(struct hwif_s * ,
                                                                                                                                                                         ide_drive_t * ))0)) {
#line 131
    return (-1);
  } else {

  }
#line 137
  if ((unsigned long )port_ops->set_dma_mode == (unsigned long )((void (*/* const  */)(struct hwif_s * ,
                                                                                       ide_drive_t * ))0)) {
    {
#line 138
    drive->pio_mode = mode;
#line 139
    (*(port_ops->set_pio_mode))(hwif, drive);
    }
#line 140
    return (0);
  } else {

  }
#line 143
  if ((hwif->host_flags & 256U) != 0U) {
    {
#line 144
    tmp = ide_config_drive_speed(drive, (int )mode);
    }
#line 144
    if (tmp != 0) {
#line 145
      return (-1);
    } else {

    }
    {
#line 146
    drive->pio_mode = mode;
#line 147
    (*(port_ops->set_pio_mode))(hwif, drive);
    }
#line 148
    return (0);
  } else {
    {
#line 150
    drive->pio_mode = mode;
#line 151
    (*(port_ops->set_pio_mode))(hwif, drive);
#line 152
    tmp___0 = ide_config_drive_speed(drive, (int )mode);
    }
#line 152
    return (tmp___0);
  }
}
}
#line 156 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
int ide_set_dma_mode(ide_drive_t *drive , u8 const   mode ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_port_ops  const  *port_ops ;
  int tmp ;
  int tmp___0 ;

  {
#line 158
  hwif = drive->hwif;
#line 159
  port_ops = hwif->port_ops;
#line 161
  if ((hwif->host_flags & 512U) != 0U) {
#line 162
    return (0);
  } else {

  }
#line 164
  if ((unsigned long )port_ops == (unsigned long )((struct ide_port_ops  const  *)0) || (unsigned long )port_ops->set_dma_mode == (unsigned long )((void (*/* const  */)(struct hwif_s * ,
                                                                                                                                                                         ide_drive_t * ))0)) {
#line 165
    return (-1);
  } else {

  }
#line 167
  if ((hwif->host_flags & 256U) != 0U) {
    {
#line 168
    tmp = ide_config_drive_speed(drive, (int )mode);
    }
#line 168
    if (tmp != 0) {
#line 169
      return (-1);
    } else {

    }
    {
#line 170
    drive->dma_mode = mode;
#line 171
    (*(port_ops->set_dma_mode))(hwif, drive);
    }
#line 172
    return (0);
  } else {
    {
#line 174
    drive->dma_mode = mode;
#line 175
    (*(port_ops->set_dma_mode))(hwif, drive);
#line 176
    tmp___0 = ide_config_drive_speed(drive, (int )mode);
    }
#line 176
    return (tmp___0);
  }
}
}
#line 179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static char const   __kstrtab_ide_set_dma_mode[17U]  = 
#line 179
  {      'i',      'd',      'e',      '_', 
        's',      'e',      't',      '_', 
        'd',      'm',      'a',      '_', 
        'm',      'o',      'd',      'e', 
        '\000'};
#line 179
struct kernel_symbol  const  __ksymtab_ide_set_dma_mode ;
#line 179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
struct kernel_symbol  const  __ksymtab_ide_set_dma_mode  =    {(unsigned long )(& ide_set_dma_mode), (char const   *)(& __kstrtab_ide_set_dma_mode)};
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
void ide_set_pio(ide_drive_t *drive , u8 req_pio ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_port_ops  const  *port_ops ;
  u8 host_pio ;
  u8 pio ;
  long tmp ;
  int tmp___0 ;

  {
#line 184
  hwif = drive->hwif;
#line 185
  port_ops = hwif->port_ops;
#line 188
  if (((unsigned long )port_ops == (unsigned long )((struct ide_port_ops  const  *)0) || (unsigned long )port_ops->set_pio_mode == (unsigned long )((void (*/* const  */)(struct hwif_s * ,
                                                                                                                                                                          ide_drive_t * ))0)) || (hwif->host_flags & 512U) != 0U) {
#line 190
    return;
  } else {

  }
  {
#line 192
  tmp = __builtin_expect((unsigned int )hwif->pio_mask == 0U, 0L);
  }
#line 192
  if (tmp != 0L) {
    {
#line 192
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-xfer-mode.c"),
                         "i" (192), "i" (12UL));
#line 192
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 194
  tmp___0 = fls((int )hwif->pio_mask);
#line 194
  host_pio = (unsigned int )((u8 )tmp___0) + 255U;
#line 196
  pio = ide_get_best_pio_mode(drive, (int )req_pio, (int )host_pio);
#line 203
  printk("\017%s: host max PIO%d wanted PIO%d%s selected PIO%d\n", (char *)(& drive->name),
         (int )host_pio, (int )req_pio, (unsigned int )req_pio == 255U ? (char *)"(auto-tune)" : (char *)"",
         (int )pio);
#line 207
  ide_set_pio_mode(drive, (int )((unsigned int )pio + 8U));
  }
#line 208
  return;
}
}
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static char const   __kstrtab_ide_set_pio[12U]  = 
#line 209
  {      'i',      'd',      'e',      '_', 
        's',      'e',      't',      '_', 
        'p',      'i',      'o',      '\000'};
#line 209
struct kernel_symbol  const  __ksymtab_ide_set_pio ;
#line 209 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
struct kernel_symbol  const  __ksymtab_ide_set_pio  =    {(unsigned long )(& ide_set_pio), (char const   *)(& __kstrtab_ide_set_pio)};
#line 222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
static u8 ide_rate_filter(ide_drive_t *drive , u8 speed ) 
{ 
  ide_hwif_t *hwif ;
  u8 mode ;
  u8 tmp ;
  int tmp___0 ;
  u8 _min1 ;
  u8 _min2 ;

  {
  {
#line 224
  hwif = drive->hwif;
#line 225
  tmp = ide_find_dma_mode(drive, (int )speed);
#line 225
  mode = tmp;
  }
#line 227
  if ((unsigned int )mode == 0U) {
#line 228
    if ((unsigned int )hwif->pio_mask != 0U) {
      {
#line 229
      tmp___0 = fls((int )hwif->pio_mask);
#line 229
      mode = (unsigned int )((u8 )tmp___0) + 7U;
      }
    } else {
#line 231
      mode = 12U;
    }
  } else {

  }
#line 236
  _min1 = speed;
#line 236
  _min2 = mode;
#line 236
  return ((u8 )((int )_min1 < (int )_min2 ? _min1 : _min2));
}
}
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-xfer-mode.c"
int ide_set_xfer_rate(ide_drive_t *drive , u8 rate ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_port_ops  const  *port_ops ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 251
  hwif = drive->hwif;
#line 252
  port_ops = hwif->port_ops;
#line 254
  if (((unsigned long )port_ops == (unsigned long )((struct ide_port_ops  const  *)0) || (unsigned long )port_ops->set_dma_mode == (unsigned long )((void (*/* const  */)(struct hwif_s * ,
                                                                                                                                                                          ide_drive_t * ))0)) || (hwif->host_flags & 512U) != 0U) {
#line 256
    return (-1);
  } else {

  }
  {
#line 258
  rate = ide_rate_filter(drive, (int )rate);
#line 260
  tmp = __builtin_expect((unsigned int )rate <= 7U, 0L);
  }
#line 260
  if (tmp != 0L) {
    {
#line 260
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-xfer-mode.c"),
                         "i" (260), "i" (12UL));
#line 260
    __builtin_unreachable();
    }
  } else {

  }
#line 262
  if ((unsigned int )rate - 8U <= 6U) {
    {
#line 263
    tmp___0 = ide_set_pio_mode(drive, (int )rate);
    }
#line 263
    return (tmp___0);
  } else {

  }
  {
#line 265
  tmp___1 = ide_set_dma_mode(drive, (int )rate);
  }
#line 265
  return (tmp___1);
}
}
#line 1487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
struct ide_timing *ide_timing_find_mode(u8 speed ) ;
#line 1488
u16 ide_pio_cycle_time(ide_drive_t *drive , u8 pio ) ;
#line 1489
void ide_timing_merge(struct ide_timing *a , struct ide_timing *b , struct ide_timing *m ,
                      unsigned int what ) ;
#line 1491
int ide_timing_compute(ide_drive_t *drive , u8 speed , struct ide_timing *t , int T ,
                       int UT ) ;
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
static struct ide_timing ide_timing[24U]  = 
#line 35 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
  {      {70U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 15U}, 
        {69U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 20U}, 
        {68U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 30U}, 
        {67U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 45U}, 
        {66U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 60U}, 
        {65U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 80U}, 
        {64U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 120U}, 
        {36U, 25U, 0U, 0U, 0U, 55U, 20U, 80U, 0U}, 
        {35U, 25U, 0U, 0U, 0U, 65U, 25U, 100U, 0U}, 
        {34U, 25U, 0U, 0U, 0U, 70U, 25U, 120U, 0U}, 
        {33U, 45U, 0U, 0U, 0U, 80U, 50U, 150U, 0U}, 
        {32U, 60U, 0U, 0U, 0U, 215U, 215U, 480U, 0U}, 
        {18U, 60U, 0U, 0U, 0U, 120U, 120U, 240U, 0U}, 
        {17U, 90U, 0U, 0U, 0U, 240U, 240U, 480U, 0U}, 
        {16U, 120U, 0U, 0U, 0U, 480U, 480U, 960U, 0U}, 
        {14U, 10U, 55U, 20U, 80U, 55U, 20U, 80U, 0U}, 
        {13U, 15U, 65U, 25U, 100U, 65U, 25U, 100U, 0U}, 
        {12U, 25U, 70U, 25U, 120U, 70U, 25U, 120U, 0U}, 
        {11U, 30U, 80U, 70U, 180U, 80U, 70U, 180U, 0U}, 
        {10U, 30U, 290U, 40U, 330U, 100U, 90U, 240U, 0U}, 
        {9U, 50U, 290U, 93U, 383U, 125U, 100U, 383U, 0U}, 
        {8U, 70U, 290U, 240U, 600U, 165U, 150U, 600U, 0U}, 
        {0U, 120U, 290U, 240U, 960U, 290U, 240U, 960U, 0U}, 
        {255U, (unsigned char)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0}};
#line 70 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
struct ide_timing *ide_timing_find_mode(u8 speed ) 
{ 
  struct ide_timing *t ;

  {
#line 74
  t = (struct ide_timing *)(& ide_timing);
#line 74
  goto ldv_38969;
  ldv_38968: ;
#line 75
  if ((unsigned int )t->mode == 255U) {
#line 76
    return ((struct ide_timing *)0);
  } else {

  }
#line 74
  t = t + 1;
  ldv_38969: ;
#line 74
  if ((int )t->mode != (int )speed) {
#line 76
    goto ldv_38968;
  } else {

  }

#line 77
  return (t);
}
}
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
static char const   __kstrtab_ide_timing_find_mode[21U]  = 
#line 79
  {      'i',      'd',      'e',      '_', 
        't',      'i',      'm',      'i', 
        'n',      'g',      '_',      'f', 
        'i',      'n',      'd',      '_', 
        'm',      'o',      'd',      'e', 
        '\000'};
#line 79
struct kernel_symbol  const  __ksymtab_ide_timing_find_mode ;
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
struct kernel_symbol  const  __ksymtab_ide_timing_find_mode  =    {(unsigned long )(& ide_timing_find_mode), (char const   *)(& __kstrtab_ide_timing_find_mode)};
#line 81 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
u16 ide_pio_cycle_time(ide_drive_t *drive , u8 pio ) 
{ 
  u16 *id ;
  struct ide_timing *t ;
  struct ide_timing *tmp ;
  u16 cycle ;
  bool tmp___0 ;

  {
  {
#line 83
  id = drive->id;
#line 84
  tmp = ide_timing_find_mode((int )((unsigned int )pio + 8U));
#line 84
  t = tmp;
#line 85
  cycle = 0U;
  }
#line 87
  if (((int )*(id + 53UL) & 2) != 0) {
#line 88
    if (((int )*(drive->id + 49UL) & 2048) != 0) {
#line 89
      cycle = *(id + 68UL);
    } else {
#line 91
      cycle = *(id + 67UL);
    }
#line 94
    if ((unsigned int )pio <= 2U && (int )cycle < (int )t->cycle) {
#line 95
      cycle = 0U;
    } else {

    }
#line 98
    if ((unsigned int )pio > 4U) {
      {
#line 98
      tmp___0 = ata_id_is_cfa((u16 const   *)id);
      }
#line 98
      if ((int )tmp___0) {
#line 99
        cycle = 0U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 102
  return ((unsigned int )cycle != 0U ? cycle : t->cycle);
}
}
#line 104 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
static char const   __kstrtab_ide_pio_cycle_time[19U]  = 
#line 104
  {      'i',      'd',      'e',      '_', 
        'p',      'i',      'o',      '_', 
        'c',      'y',      'c',      'l', 
        'e',      '_',      't',      'i', 
        'm',      'e',      '\000'};
#line 104
struct kernel_symbol  const  __ksymtab_ide_pio_cycle_time ;
#line 104 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
struct kernel_symbol  const  __ksymtab_ide_pio_cycle_time  =    {(unsigned long )(& ide_pio_cycle_time), (char const   *)(& __kstrtab_ide_pio_cycle_time)};
#line 109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
static void ide_timing_quantize(struct ide_timing *t , struct ide_timing *q , int T ,
                                int UT ) 
{ 


  {
#line 112
  q->setup = (int )t->setup * 1000 != 0 ? (unsigned int )((u8 )(((int )t->setup * 1000 + -1) / T)) + 1U : 0U;
#line 113
  q->act8b = (int )t->act8b * 1000 != 0 ? (unsigned int )((u16 )(((int )t->act8b * 1000 + -1) / T)) + 1U : 0U;
#line 114
  q->rec8b = (int )t->rec8b * 1000 != 0 ? (unsigned int )((u16 )(((int )t->rec8b * 1000 + -1) / T)) + 1U : 0U;
#line 115
  q->cyc8b = (int )t->cyc8b * 1000 != 0 ? (unsigned int )((u16 )(((int )t->cyc8b * 1000 + -1) / T)) + 1U : 0U;
#line 116
  q->active = (int )t->active * 1000 != 0 ? (unsigned int )((u16 )(((int )t->active * 1000 + -1) / T)) + 1U : 0U;
#line 117
  q->recover = (int )t->recover * 1000 != 0 ? (unsigned int )((u16 )(((int )t->recover * 1000 + -1) / T)) + 1U : 0U;
#line 118
  q->cycle = (int )t->cycle * 1000 != 0 ? (unsigned int )((u16 )(((int )t->cycle * 1000 + -1) / T)) + 1U : 0U;
#line 119
  q->udma = (int )t->udma * 1000 != 0 ? (unsigned int )((u16 )(((int )t->udma * 1000 + -1) / UT)) + 1U : 0U;
#line 120
  return;
}
}
#line 122 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
void ide_timing_merge(struct ide_timing *a , struct ide_timing *b , struct ide_timing *m ,
                      unsigned int what ) 
{ 
  u8 _max1 ;
  u8 _max2 ;
  u16 _max1___0 ;
  u16 _max2___0 ;
  u16 _max1___1 ;
  u16 _max2___1 ;
  u16 _max1___2 ;
  u16 _max2___2 ;
  u16 _max1___3 ;
  u16 _max2___3 ;
  u16 _max1___4 ;
  u16 _max2___4 ;
  u16 _max1___5 ;
  u16 _max2___5 ;
  u16 _max1___6 ;
  u16 _max2___6 ;

  {
#line 125
  if ((int )what & 1) {
#line 126
    _max1 = a->setup;
#line 126
    _max2 = b->setup;
#line 126
    m->setup = (u8 )((int )_max1 > (int )_max2 ? _max1 : _max2);
  } else {

  }
#line 127
  if ((what & 2U) != 0U) {
#line 128
    _max1___0 = a->act8b;
#line 128
    _max2___0 = b->act8b;
#line 128
    m->act8b = (u16 )((int )_max1___0 > (int )_max2___0 ? _max1___0 : _max2___0);
  } else {

  }
#line 129
  if ((what & 4U) != 0U) {
#line 130
    _max1___1 = a->rec8b;
#line 130
    _max2___1 = b->rec8b;
#line 130
    m->rec8b = (u16 )((int )_max1___1 > (int )_max2___1 ? _max1___1 : _max2___1);
  } else {

  }
#line 131
  if ((what & 8U) != 0U) {
#line 132
    _max1___2 = a->cyc8b;
#line 132
    _max2___2 = b->cyc8b;
#line 132
    m->cyc8b = (u16 )((int )_max1___2 > (int )_max2___2 ? _max1___2 : _max2___2);
  } else {

  }
#line 133
  if ((what & 16U) != 0U) {
#line 134
    _max1___3 = a->active;
#line 134
    _max2___3 = b->active;
#line 134
    m->active = (u16 )((int )_max1___3 > (int )_max2___3 ? _max1___3 : _max2___3);
  } else {

  }
#line 135
  if ((what & 32U) != 0U) {
#line 136
    _max1___4 = a->recover;
#line 136
    _max2___4 = b->recover;
#line 136
    m->recover = (u16 )((int )_max1___4 > (int )_max2___4 ? _max1___4 : _max2___4);
  } else {

  }
#line 137
  if ((what & 64U) != 0U) {
#line 138
    _max1___5 = a->cycle;
#line 138
    _max2___5 = b->cycle;
#line 138
    m->cycle = (u16 )((int )_max1___5 > (int )_max2___5 ? _max1___5 : _max2___5);
  } else {

  }
#line 139
  if ((what & 128U) != 0U) {
#line 140
    _max1___6 = a->udma;
#line 140
    _max2___6 = b->udma;
#line 140
    m->udma = (u16 )((int )_max1___6 > (int )_max2___6 ? _max1___6 : _max2___6);
  } else {

  }
#line 142
  return;
}
}
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
static char const   __kstrtab_ide_timing_merge[17U]  = 
#line 142
  {      'i',      'd',      'e',      '_', 
        't',      'i',      'm',      'i', 
        'n',      'g',      '_',      'm', 
        'e',      'r',      'g',      'e', 
        '\000'};
#line 142
struct kernel_symbol  const  __ksymtab_ide_timing_merge ;
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
struct kernel_symbol  const  __ksymtab_ide_timing_merge  =    {(unsigned long )(& ide_timing_merge), (char const   *)(& __kstrtab_ide_timing_merge)};
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
int ide_timing_compute(ide_drive_t *drive , u8 speed , struct ide_timing *t , int T ,
                       int UT ) 
{ 
  u16 *id ;
  struct ide_timing *s ;
  struct ide_timing p ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 147
  id = drive->id;
#line 153
  s = ide_timing_find_mode((int )speed);
  }
#line 154
  if ((unsigned long )s == (unsigned long )((struct ide_timing *)0)) {
#line 155
    return (-22);
  } else {

  }
#line 160
  *t = *s;
#line 166
  if (((int )*(id + 53UL) & 2) != 0) {
    {
#line 167
    __memset((void *)(& p), 0, 16UL);
    }
#line 169
    if ((unsigned int )speed - 8U <= 7U) {
#line 170
      if ((unsigned int )speed <= 10U) {
#line 171
        p.cyc8b = *(id + 67UL);
#line 171
        p.cycle = p.cyc8b;
      } else
#line 172
      if ((unsigned int )speed <= 12U) {
#line 174
        p.cyc8b = *(id + 68UL);
#line 174
        p.cycle = p.cyc8b;
      } else
#line 172
      if ((unsigned int )speed == 13U) {
        {
#line 172
        tmp = ata_id_is_cfa((u16 const   *)id);
        }
#line 172
        if (tmp) {
#line 172
          tmp___0 = 0;
        } else {
#line 172
          tmp___0 = 1;
        }
#line 172
        if (tmp___0) {
#line 174
          p.cyc8b = *(id + 68UL);
#line 174
          p.cycle = p.cyc8b;
        } else {

        }
      } else {

      }
    } else
#line 175
    if ((unsigned int )speed - 32U <= 2U) {
#line 176
      p.cycle = *(id + 65UL);
    } else {

    }
    {
#line 178
    ide_timing_merge(& p, t, t, 72U);
    }
  } else {

  }
  {
#line 184
  ide_timing_quantize(t, t, T, UT);
  }
#line 191
  if ((unsigned int )speed > 15U) {
    {
#line 192
    ide_timing_compute(drive, (int )drive->pio_mode, & p, T, UT);
#line 193
    ide_timing_merge(& p, t, t, 255U);
    }
  } else {

  }
#line 199
  if ((int )t->act8b + (int )t->rec8b < (int )t->cyc8b) {
#line 200
    t->act8b = (int )t->act8b + (int )((u16 )(((int )t->cyc8b - ((int )t->act8b + (int )t->rec8b)) / 2));
#line 201
    t->rec8b = (int )t->cyc8b - (int )t->act8b;
  } else {

  }
#line 204
  if ((int )t->active + (int )t->recover < (int )t->cycle) {
#line 205
    t->active = (int )t->active + (int )((u16 )(((int )t->cycle - ((int )t->active + (int )t->recover)) / 2));
#line 206
    t->recover = (int )t->cycle - (int )t->active;
  } else {

  }
#line 209
  return (0);
}
}
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
static char const   __kstrtab_ide_timing_compute[19U]  = 
#line 211
  {      'i',      'd',      'e',      '_', 
        't',      'i',      'm',      'i', 
        'n',      'g',      '_',      'c', 
        'o',      'm',      'p',      'u', 
        't',      'e',      '\000'};
#line 211
struct kernel_symbol  const  __ksymtab_ide_timing_compute ;
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-timings.c"
struct kernel_symbol  const  __ksymtab_ide_timing_compute  =    {(unsigned long )(& ide_timing_compute), (char const   *)(& __kstrtab_ide_timing_compute)};
#line 152 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/printk.h"
extern int __printk_ratelimit(char const   * ) ;
#line 795 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/blkdev.h"
extern void blk_rq_init(struct request_queue * , struct request * ) ;
#line 799
static void ldv_blk_put_request_97___1(struct request *ldv_func_arg1 ) ;
#line 805
static struct request *ldv_blk_get_request_96___1(struct request_queue *ldv_func_arg1 ,
                                                  int ldv_func_arg2 , gfp_t ldv_func_arg3 ) ;
#line 960
extern void blk_start_request(struct request * ) ;
#line 1097 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void ide_read_bcount_and_ireason(ide_drive_t *drive , u16 *bcount , u8 *ireason ) ;
#line 1099
int ide_check_ireason(ide_drive_t *drive , struct request *rq , int len , int ireason ,
                      int rw ) ;
#line 1101
int ide_check_atapi_device(ide_drive_t *drive , char const   *s ) ;
#line 1103
void ide_init_pc(struct ide_atapi_pc *pc ) ;
#line 1125
int ide_queue_pc_tail(ide_drive_t *drive , struct gendisk *disk , struct ide_atapi_pc *pc ,
                      void *buf , unsigned int bufflen ) ;
#line 1128
int ide_do_test_unit_ready(ide_drive_t *drive , struct gendisk *disk ) ;
#line 1129
int ide_do_start_stop(ide_drive_t *drive , struct gendisk *disk , int start ) ;
#line 1130
int ide_set_media_lock(ide_drive_t *drive , struct gendisk *disk , int on ) ;
#line 1131
void ide_create_request_sense_cmd(ide_drive_t *drive , struct ide_atapi_pc *pc ) ;
#line 1132
void ide_retry_pc(ide_drive_t *drive ) ;
#line 1134
void ide_prep_sense(ide_drive_t *drive , struct request *rq ) ;
#line 1135
int ide_queue_sense_rq(ide_drive_t *drive , void *special ) ;
#line 1137
int ide_cd_expiry(ide_drive_t *drive ) ;
#line 1139
int ide_cd_get_xferlen(struct request *rq ) ;
#line 1141
ide_startstop_t ide_issue_pc(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 1365
void ide_dma_unmap_sg(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/scsi/scsi.h"
extern unsigned char const   scsi_command_size_tbl[8U] ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
__inline static int dev_is_idecd(ide_drive_t *drive ) 
{ 


  {
#line 29
  return ((unsigned int )drive->media == 5U || (unsigned int )drive->media == 7U);
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_check_atapi_device(ide_drive_t *drive , char const   *s ) 
{ 
  u16 *id ;
  u8 gcw[2U] ;
  u8 protocol ;
  u8 device_type ;
  u8 removable ;
  u8 drq_type ;
  u8 packet_size ;

  {
#line 38
  id = drive->id;
#line 41
  *((u16 *)(& gcw)) = *id;
#line 43
  protocol = (int )gcw[1] >> 6;
#line 44
  device_type = (unsigned int )gcw[1] & 31U;
#line 45
  removable = (int )gcw[0] >> 7;
#line 46
  drq_type = (u8 )(((int )gcw[0] & 96) >> 5);
#line 47
  packet_size = (unsigned int )gcw[0] & 3U;
#line 57
  if ((unsigned int )protocol != 2U) {
    {
#line 58
    printk("\v%s: %s: protocol (0x%02x) is not ATAPI\n", s, (char *)(& drive->name),
           (int )protocol);
    }
  } else
#line 60
  if (((unsigned int )drive->media == 0U && (unsigned int )device_type != 0U) || ((unsigned int )drive->media == 1U && (unsigned int )device_type != 1U)) {
    {
#line 62
    printk("\v%s: %s: invalid device type (0x%02x)\n", s, (char *)(& drive->name),
           (int )device_type);
    }
  } else
#line 64
  if ((unsigned int )removable == 0U) {
    {
#line 65
    printk("\v%s: %s: the removable flag is not set\n", s, (char *)(& drive->name));
    }
  } else
#line 67
  if ((unsigned int )drive->media == 0U && (unsigned int )drq_type == 3U) {
    {
#line 68
    printk("\v%s: %s: sorry, DRQ type (0x%02x) not supported\n", s, (char *)(& drive->name),
           (int )drq_type);
    }
  } else
#line 70
  if ((unsigned int )packet_size != 0U) {
    {
#line 71
    printk("\v%s: %s: packet size (0x%02x) is not 12 bytes\n", s, (char *)(& drive->name),
           (int )packet_size);
    }
  } else {
#line 74
    return (1);
  }
#line 75
  return (0);
}
}
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_check_atapi_device[23U]  = 
#line 77
  {      'i',      'd',      'e',      '_', 
        'c',      'h',      'e',      'c', 
        'k',      '_',      'a',      't', 
        'a',      'p',      'i',      '_', 
        'd',      'e',      'v',      'i', 
        'c',      'e',      '\000'};
#line 77
struct kernel_symbol  const  __ksymtab_ide_check_atapi_device ;
#line 77 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_check_atapi_device  =    {(unsigned long )(& ide_check_atapi_device), (char const   *)(& __kstrtab_ide_check_atapi_device)};
#line 79 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
void ide_init_pc(struct ide_atapi_pc *pc ) 
{ 


  {
  {
#line 81
  __memset((void *)pc, 0, 48UL);
  }
#line 82
  return;
}
}
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_init_pc[12U]  = 
#line 83
  {      'i',      'd',      'e',      '_', 
        'i',      'n',      'i',      't', 
        '_',      'p',      'c',      '\000'};
#line 83
struct kernel_symbol  const  __ksymtab_ide_init_pc ;
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_init_pc  =    {(unsigned long )(& ide_init_pc), (char const   *)(& __kstrtab_ide_init_pc)};
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_queue_pc_tail(ide_drive_t *drive , struct gendisk *disk , struct ide_atapi_pc *pc ,
                      void *buf , unsigned int bufflen ) 
{ 
  struct request *rq ;
  int error ;

  {
  {
#line 95
  rq = ldv_blk_get_request_96___1(drive->queue, 0, 16U);
#line 96
  rq->cmd_type = 7;
#line 97
  rq->special = (void *)pc;
  }
#line 99
  if ((unsigned long )buf != (unsigned long )((void *)0) && bufflen != 0U) {
    {
#line 100
    error = blk_rq_map_kern(drive->queue, rq, buf, bufflen, 16U);
    }
#line 102
    if (error != 0) {
#line 103
      goto put_req;
    } else {

    }
  } else {

  }
  {
#line 106
  __memcpy((void *)rq->cmd, (void const   *)(& pc->c), 12UL);
  }
#line 107
  if ((unsigned int )drive->media == 1U) {
#line 108
    *(rq->cmd + 13UL) = 1U;
  } else {

  }
  {
#line 109
  error = blk_execute_rq(drive->queue, disk, rq, 0);
  }
  put_req: 
  {
#line 111
  ldv_blk_put_request_97___1(rq);
  }
#line 112
  return (error);
}
}
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_queue_pc_tail[18U]  = 
#line 114
  {      'i',      'd',      'e',      '_', 
        'q',      'u',      'e',      'u', 
        'e',      '_',      'p',      'c', 
        '_',      't',      'a',      'i', 
        'l',      '\000'};
#line 114
struct kernel_symbol  const  __ksymtab_ide_queue_pc_tail ;
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_queue_pc_tail  =    {(unsigned long )(& ide_queue_pc_tail), (char const   *)(& __kstrtab_ide_queue_pc_tail)};
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_do_test_unit_ready(ide_drive_t *drive , struct gendisk *disk ) 
{ 
  struct ide_atapi_pc pc ;
  int tmp ;

  {
  {
#line 120
  ide_init_pc(& pc);
#line 121
  pc.c[0] = 0U;
#line 123
  tmp = ide_queue_pc_tail(drive, disk, & pc, (void *)0, 0U);
  }
#line 123
  return (tmp);
}
}
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_do_test_unit_ready[23U]  = 
#line 125
  {      'i',      'd',      'e',      '_', 
        'd',      'o',      '_',      't', 
        'e',      's',      't',      '_', 
        'u',      'n',      'i',      't', 
        '_',      'r',      'e',      'a', 
        'd',      'y',      '\000'};
#line 125
struct kernel_symbol  const  __ksymtab_ide_do_test_unit_ready ;
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_do_test_unit_ready  =    {(unsigned long )(& ide_do_test_unit_ready), (char const   *)(& __kstrtab_ide_do_test_unit_ready)};
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_do_start_stop(ide_drive_t *drive , struct gendisk *disk , int start ) 
{ 
  struct ide_atapi_pc pc ;
  int tmp ;

  {
  {
#line 131
  ide_init_pc(& pc);
#line 132
  pc.c[0] = 27U;
#line 133
  pc.c[4] = (u8 )start;
  }
#line 135
  if ((unsigned int )drive->media == 1U) {
#line 136
    pc.flags = pc.flags | 4UL;
  } else {

  }
  {
#line 138
  tmp = ide_queue_pc_tail(drive, disk, & pc, (void *)0, 0U);
  }
#line 138
  return (tmp);
}
}
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_do_start_stop[18U]  = 
#line 140
  {      'i',      'd',      'e',      '_', 
        'd',      'o',      '_',      's', 
        't',      'a',      'r',      't', 
        '_',      's',      't',      'o', 
        'p',      '\000'};
#line 140
struct kernel_symbol  const  __ksymtab_ide_do_start_stop ;
#line 140 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_do_start_stop  =    {(unsigned long )(& ide_do_start_stop), (char const   *)(& __kstrtab_ide_do_start_stop)};
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_set_media_lock(ide_drive_t *drive , struct gendisk *disk , int on ) 
{ 
  struct ide_atapi_pc pc ;
  int tmp ;

  {
#line 146
  if ((drive->dev_flags & 32768UL) == 0UL) {
#line 147
    return (0);
  } else {

  }
  {
#line 149
  ide_init_pc(& pc);
#line 150
  pc.c[0] = 30U;
#line 151
  pc.c[4] = (u8 )on;
#line 153
  tmp = ide_queue_pc_tail(drive, disk, & pc, (void *)0, 0U);
  }
#line 153
  return (tmp);
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_set_media_lock[19U]  = 
#line 155
  {      'i',      'd',      'e',      '_', 
        's',      'e',      't',      '_', 
        'm',      'e',      'd',      'i', 
        'a',      '_',      'l',      'o', 
        'c',      'k',      '\000'};
#line 155
struct kernel_symbol  const  __ksymtab_ide_set_media_lock ;
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_set_media_lock  =    {(unsigned long )(& ide_set_media_lock), (char const   *)(& __kstrtab_ide_set_media_lock)};
#line 157 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
void ide_create_request_sense_cmd(ide_drive_t *drive , struct ide_atapi_pc *pc ) 
{ 


  {
  {
#line 159
  ide_init_pc(pc);
#line 160
  pc->c[0] = 3U;
  }
#line 161
  if ((unsigned int )drive->media == 0U) {
#line 162
    pc->c[4] = 255U;
#line 163
    pc->req_xfer = 18;
  } else {
#line 165
    pc->c[4] = 20U;
#line 166
    pc->req_xfer = 20;
  }
#line 168
  return;
}
}
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_create_request_sense_cmd[29U]  = 
#line 169
  {      'i',      'd',      'e',      '_', 
        'c',      'r',      'e',      'a', 
        't',      'e',      '_',      'r', 
        'e',      'q',      'u',      'e', 
        's',      't',      '_',      's', 
        'e',      'n',      's',      'e', 
        '_',      'c',      'm',      'd', 
        '\000'};
#line 169
struct kernel_symbol  const  __ksymtab_ide_create_request_sense_cmd ;
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_create_request_sense_cmd  =    {(unsigned long )(& ide_create_request_sense_cmd), (char const   *)(& __kstrtab_ide_create_request_sense_cmd)};
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
void ide_prep_sense(ide_drive_t *drive , struct request *rq ) 
{ 
  struct request_sense *sense ;
  struct request *sense_rq ;
  unsigned int cmd_len ;
  unsigned int sense_len ;
  int err ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 173
  sense = & drive->sense_data;
#line 174
  sense_rq = & drive->sense_rq;
  {
#line 179
  if ((int )drive->media == 0) {
#line 179
    goto case_0;
  } else {

  }
#line 183
  if ((int )drive->media == 1) {
#line 183
    goto case_1;
  } else {

  }
#line 187
  goto switch_default;
  case_0: /* CIL Label */ 
#line 180
  cmd_len = 255U;
#line 181
  sense_len = 18U;
#line 182
  goto ldv_38403;
  case_1: /* CIL Label */ 
#line 184
  cmd_len = 20U;
#line 185
  sense_len = 20U;
#line 186
  goto ldv_38403;
  switch_default: /* CIL Label */ 
#line 188
  cmd_len = 18U;
#line 189
  sense_len = 18U;
  switch_break: /* CIL Label */ ;
  }
  ldv_38403: 
  {
#line 192
  tmp = __builtin_expect(sense_len > 64U, 0L);
  }
#line 192
  if (tmp != 0L) {
    {
#line 192
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-atapi.c"),
                         "i" (192), "i" (12UL));
#line 192
    __builtin_unreachable();
    }
  } else {

  }
#line 194
  if ((unsigned int )rq->cmd_type == 3U || (int )drive->sense_rq_armed) {
#line 195
    return;
  } else {

  }
  {
#line 197
  __memset((void *)sense, 0, 64UL);
#line 199
  blk_rq_init(rq->q, sense_rq);
#line 201
  err = blk_rq_map_kern(drive->queue, sense_rq, (void *)sense, sense_len, 16U);
#line 203
  tmp___1 = __builtin_expect(err != 0, 0L);
  }
#line 203
  if (tmp___1 != 0L) {
    {
#line 204
    tmp___0 = __printk_ratelimit("ide_prep_sense");
    }
#line 204
    if (tmp___0 != 0) {
      {
#line 205
      printk("\fide-atapi: %s: failed to map sense buffer\n", (char *)(& drive->name));
      }
    } else {

    }
#line 207
    return;
  } else {

  }
#line 210
  sense_rq->rq_disk = rq->rq_disk;
#line 211
  *(sense_rq->cmd) = 3U;
#line 212
  *(sense_rq->cmd + 4UL) = (unsigned char )cmd_len;
#line 213
  sense_rq->cmd_type = 3;
#line 214
  sense_rq->cmd_flags = sense_rq->cmd_flags | 33554432ULL;
#line 216
  if ((unsigned int )drive->media == 1U) {
#line 217
    *(sense_rq->cmd + 13UL) = 1U;
  } else {

  }
#line 219
  drive->sense_rq_armed = 1;
#line 220
  return;
}
}
#line 221 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_prep_sense[15U]  = 
#line 221
  {      'i',      'd',      'e',      '_', 
        'p',      'r',      'e',      'p', 
        '_',      's',      'e',      'n', 
        's',      'e',      '\000'};
#line 221
struct kernel_symbol  const  __ksymtab_ide_prep_sense ;
#line 221 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_prep_sense  =    {(unsigned long )(& ide_prep_sense), (char const   *)(& __kstrtab_ide_prep_sense)};
#line 223 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_queue_sense_rq(ide_drive_t *drive , void *special ) 
{ 


  {
#line 226
  if (! drive->sense_rq_armed) {
    {
#line 227
    printk("\fide-atapi: %s: error queuing a sense request\n", (char *)(& drive->name));
    }
#line 229
    return (-12);
  } else {

  }
  {
#line 232
  drive->sense_rq.special = special;
#line 233
  drive->sense_rq_armed = 0;
#line 235
  (drive->hwif)->rq = (struct request *)0;
#line 237
  elv_add_request(drive->queue, & drive->sense_rq, 1);
  }
#line 238
  return (0);
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_queue_sense_rq[19U]  = 
#line 240
  {      'i',      'd',      'e',      '_', 
        'q',      'u',      'e',      'u', 
        'e',      '_',      's',      'e', 
        'n',      's',      'e',      '_', 
        'r',      'q',      '\000'};
#line 240
struct kernel_symbol  const  __ksymtab_ide_queue_sense_rq ;
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_queue_sense_rq  =    {(unsigned long )(& ide_queue_sense_rq), (char const   *)(& __kstrtab_ide_queue_sense_rq)};
#line 247 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
void ide_retry_pc(ide_drive_t *drive ) 
{ 
  struct request *failed_rq ;
  struct request *sense_rq ;
  struct ide_atapi_pc *pc ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 249
  failed_rq = (drive->hwif)->rq;
#line 250
  sense_rq = & drive->sense_rq;
#line 251
  pc = & drive->request_sense_pc;
#line 253
  ide_read_error(drive);
#line 256
  ide_init_pc(pc);
#line 257
  __memcpy((void *)(& pc->c), (void const   *)sense_rq->cmd, 12UL);
  }
#line 259
  if ((unsigned int )drive->media == 1U) {
#line 260
    drive->atapi_flags = drive->atapi_flags | 262144UL;
  } else {

  }
  {
#line 267
  (drive->hwif)->rq = (struct request *)0;
#line 268
  ide_requeue_and_plug(drive, failed_rq);
#line 269
  tmp___0 = ide_queue_sense_rq(drive, (void *)pc);
  }
#line 269
  if (tmp___0 != 0) {
    {
#line 270
    blk_start_request(failed_rq);
#line 271
    tmp = blk_rq_bytes((struct request  const  *)failed_rq);
#line 271
    ide_complete_rq(drive, -5, tmp);
    }
  } else {

  }
#line 273
  return;
}
}
#line 274 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_retry_pc[13U]  = 
#line 274
  {      'i',      'd',      'e',      '_', 
        'r',      'e',      't',      'r', 
        'y',      '_',      'p',      'c', 
        '\000'};
#line 274
struct kernel_symbol  const  __ksymtab_ide_retry_pc ;
#line 274 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_retry_pc  =    {(unsigned long )(& ide_retry_pc), (char const   *)(& __kstrtab_ide_retry_pc)};
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_cd_expiry(ide_drive_t *drive ) 
{ 
  struct request *rq ;
  unsigned long wait ;

  {
#line 278
  rq = (drive->hwif)->rq;
#line 279
  wait = 0UL;
  {
#line 290
  if ((int )*(rq->cmd) == 161) {
#line 290
    goto case_161;
  } else {

  }
#line 291
  if ((int )*(rq->cmd) == 4) {
#line 291
    goto case_4;
  } else {

  }
#line 292
  if ((int )*(rq->cmd) == 83) {
#line 292
    goto case_83;
  } else {

  }
#line 293
  if ((int )*(rq->cmd) == 91) {
#line 293
    goto case_91;
  } else {

  }
#line 294
  if ((int )*(rq->cmd) == 53) {
#line 294
    goto case_53;
  } else {

  }
#line 297
  goto switch_default;
  case_161: /* CIL Label */ ;
  case_4: /* CIL Label */ ;
  case_83: /* CIL Label */ ;
  case_91: /* CIL Label */ ;
  case_53: /* CIL Label */ 
#line 295
  wait = 15000UL;
#line 296
  goto ldv_38450;
  switch_default: /* CIL Label */ ;
#line 298
  if ((rq->cmd_flags & 16777216ULL) == 0ULL) {
    {
#line 299
    printk("\016ide-atapi: cmd 0x%x timed out\n", (int )*(rq->cmd));
    }
  } else {

  }
#line 301
  wait = 0UL;
#line 302
  goto ldv_38450;
  switch_break: /* CIL Label */ ;
  }
  ldv_38450: ;
#line 304
  return ((int )wait);
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_cd_expiry[14U]  = 
#line 306
  {      'i',      'd',      'e',      '_', 
        'c',      'd',      '_',      'e', 
        'x',      'p',      'i',      'r', 
        'y',      '\000'};
#line 306
struct kernel_symbol  const  __ksymtab_ide_cd_expiry ;
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_cd_expiry  =    {(unsigned long )(& ide_cd_expiry), (char const   *)(& __kstrtab_ide_cd_expiry)};
#line 308 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_cd_get_xferlen(struct request *rq ) 
{ 
  unsigned int tmp ;

  {
  {
#line 311
  if ((unsigned int )rq->cmd_type == 1U) {
#line 311
    goto case_1;
  } else {

  }
#line 313
  if ((unsigned int )rq->cmd_type == 3U) {
#line 313
    goto case_3;
  } else {

  }
#line 314
  if ((unsigned int )rq->cmd_type == 2U) {
#line 314
    goto case_2;
  } else {

  }
#line 315
  if ((unsigned int )rq->cmd_type == 9U) {
#line 315
    goto case_9;
  } else {

  }
#line 317
  goto switch_default;
  case_1: /* CIL Label */ ;
#line 312
  return (32768);
  case_3: /* CIL Label */ ;
  case_2: /* CIL Label */ ;
  case_9: /* CIL Label */ 
  {
#line 316
  tmp = blk_rq_bytes((struct request  const  *)rq);
  }
#line 316
  return ((int )tmp);
  switch_default: /* CIL Label */ ;
#line 318
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 321 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_cd_get_xferlen[19U]  = 
#line 321
  {      'i',      'd',      'e',      '_', 
        'c',      'd',      '_',      'g', 
        'e',      't',      '_',      'x', 
        'f',      'e',      'r',      'l', 
        'e',      'n',      '\000'};
#line 321
struct kernel_symbol  const  __ksymtab_ide_cd_get_xferlen ;
#line 321 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_cd_get_xferlen  =    {(unsigned long )(& ide_cd_get_xferlen), (char const   *)(& __kstrtab_ide_cd_get_xferlen)};
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
void ide_read_bcount_and_ireason(ide_drive_t *drive , u16 *bcount , u8 *ireason ) 
{ 
  struct ide_taskfile tf ;

  {
  {
#line 327
  (*(((drive->hwif)->tp_ops)->tf_read))(drive, & tf, 52);
#line 330
  *bcount = (u16 )((int )((short )((int )tf.lbah << 8)) | (int )((short )tf.lbam));
#line 331
  *ireason = (unsigned int )tf.nsect & 3U;
  }
#line 332
  return;
}
}
#line 333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_read_bcount_and_ireason[28U]  = 
#line 333
  {      'i',      'd',      'e',      '_', 
        'r',      'e',      'a',      'd', 
        '_',      'b',      'c',      'o', 
        'u',      'n',      't',      '_', 
        'a',      'n',      'd',      '_', 
        'i',      'r',      'e',      'a', 
        's',      'o',      'n',      '\000'};
#line 333
struct kernel_symbol  const  __ksymtab_ide_read_bcount_and_ireason ;
#line 333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_read_bcount_and_ireason  =    {(unsigned long )(& ide_read_bcount_and_ireason), (char const   *)(& __kstrtab_ide_read_bcount_and_ireason)};
#line 343 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
int ide_check_ireason(ide_drive_t *drive , struct request *rq , int len , int ireason ,
                      int rw ) 
{ 
  ide_hwif_t *hwif ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 346
  hwif = drive->hwif;
#line 350
  if (ireason == (rw == 0 ? 2 : 0)) {
#line 351
    return (0);
  } else
#line 352
  if (ireason == rw << 1) {
    {
#line 353
    printk("\vide-atapi: %s: %s: wrong transfer direction!\n", (char *)(& drive->name),
           "ide_check_ireason");
#line 356
    tmp = dev_is_idecd(drive);
    }
#line 356
    if (tmp != 0) {
      {
#line 357
      ide_pad_transfer(drive, rw, len);
      }
    } else {

    }
  } else
#line 358
  if (rw == 0 && ireason == 1) {
    {
#line 359
    tmp___0 = dev_is_idecd(drive);
    }
#line 359
    if (tmp___0 != 0) {
      {
#line 364
      (*((hwif->tp_ops)->read_status))(hwif);
      }
#line 365
      return (0);
    } else {

    }
  } else {
#line 368
    if (ireason & 1) {
      {
#line 369
      printk("\vide-atapi: %s: CoD != 0 in %s\n", (char *)(& drive->name), "ide_check_ireason");
      }
    } else {

    }
    {
#line 373
    printk("\vide-atapi: %s: %s: bad interrupt reason 0x%02x\n", (char *)(& drive->name),
           "ide_check_ireason", ireason);
    }
  }
  {
#line 377
  tmp___1 = dev_is_idecd(drive);
  }
#line 377
  if (tmp___1 != 0 && (unsigned int )rq->cmd_type == 9U) {
#line 378
    rq->cmd_flags = rq->cmd_flags | 8388608ULL;
  } else {

  }
#line 380
  return (1);
}
}
#line 382 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_check_ireason[18U]  = 
#line 382
  {      'i',      'd',      'e',      '_', 
        'c',      'h',      'e',      'c', 
        'k',      '_',      'i',      'r', 
        'e',      'a',      's',      'o', 
        'n',      '\000'};
#line 382
struct kernel_symbol  const  __ksymtab_ide_check_ireason ;
#line 382 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_check_ireason  =    {(unsigned long )(& ide_check_ireason), (char const   *)(& __kstrtab_ide_check_ireason)};
#line 389 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static ide_startstop_t ide_pc_intr(ide_drive_t *drive ) 
{ 
  struct ide_atapi_pc *pc ;
  ide_hwif_t *hwif ;
  struct ide_cmd *cmd ;
  struct request *rq ;
  struct ide_tp_ops  const  *tp_ops ;
  unsigned int timeout ;
  unsigned int done ;
  u16 bcount ;
  u8 stat ;
  u8 ireason ;
  u8 dsc ;
  u8 write ;
  int rc ;
  int uptodate ;
  int error ;
  ide_startstop_t tmp ;
  unsigned int tmp___0 ;
  ide_startstop_t tmp___1 ;
  ide_startstop_t tmp___2 ;
  int tmp___3 ;
  unsigned int __min1 ;
  unsigned int __min2 ;

  {
  {
#line 391
  pc = drive->pc;
#line 392
  hwif = drive->hwif;
#line 393
  cmd = & hwif->cmd;
#line 394
  rq = hwif->rq;
#line 395
  tp_ops = hwif->tp_ops;
#line 398
  dsc = 0U;
#line 399
  write = (pc->flags & 64UL) != 0UL;
#line 403
  timeout = (unsigned int )drive->media == 0U ? 12500U : 225000U;
#line 407
  stat = (*(tp_ops->read_status))(hwif);
  }
#line 409
  if ((pc->flags & 16UL) != 0UL) {
    {
#line 412
    drive->waiting_for_dma = 0U;
#line 413
    rc = (*((hwif->dma_ops)->dma_end))(drive);
#line 414
    ide_dma_unmap_sg(drive, cmd);
    }
#line 416
    if (rc != 0 || ((unsigned int )drive->media == 1U && (int )stat & 1)) {
#line 417
      if ((unsigned int )drive->media == 0U) {
        {
#line 418
        printk("\vide-atapi: %s: DMA %s error\n", (char *)(& drive->name), (int )(pc->rq)->cmd_flags & 1 ? (char *)"write" : (char *)"read");
        }
      } else {

      }
#line 421
      pc->flags = pc->flags | 32UL;
    } else {
#line 423
      rq->resid_len = 0U;
    }
  } else {

  }
#line 428
  if (((int )stat & 8) == 0) {
#line 434
    pc->flags = pc->flags & 0xffffffffffffffefUL;
#line 438
    if (((unsigned int )drive->media == 1U && (int )stat & 1) && (unsigned int )*(rq->cmd) == 3U) {
#line 440
      stat = (unsigned int )stat & 254U;
    } else {

    }
#line 442
    if ((int )stat & 1 || (pc->flags & 32UL) != 0UL) {
#line 446
      if ((unsigned int )drive->media != 1U) {
#line 447
        (pc->rq)->errors = (pc->rq)->errors + 1;
      } else {

      }
#line 449
      if ((unsigned int )*(rq->cmd) == 3U) {
        {
#line 450
        printk("\vide-atapi: %s: I/O error in request sense command\n", (char *)(& drive->name));
#line 452
        tmp = ide_do_reset(drive);
        }
#line 452
        return (tmp);
      } else {

      }
      {
#line 458
      ide_retry_pc(drive);
      }
#line 461
      return (0);
    } else {

    }
#line 463
    pc->error = 0;
#line 465
    if ((pc->flags & 4UL) != 0UL && ((int )stat & 16) == 0) {
#line 466
      dsc = 1U;
    } else {

    }
    {
#line 472
    done = blk_rq_bytes((struct request  const  *)rq);
#line 475
    uptodate = (*(drive->pc_callback))(drive, (int )dsc);
    }
#line 477
    if (uptodate == 0) {
#line 478
      drive->failed_pc = (struct ide_atapi_pc *)0;
    } else {

    }
#line 480
    if ((unsigned int )rq->cmd_type == 7U) {
#line 481
      rq->errors = 0;
#line 482
      error = 0;
    } else {
#line 485
      if ((unsigned int )rq->cmd_type != 1U && uptodate <= 0) {
#line 486
        if (rq->errors == 0) {
#line 487
          rq->errors = -5;
        } else {

        }
      } else {

      }
#line 490
      error = uptodate != 0 ? 0 : -5;
    }
    {
#line 493
    tmp___0 = blk_rq_bytes((struct request  const  *)rq);
#line 493
    ide_complete_rq(drive, error, tmp___0);
    }
#line 494
    return (0);
  } else {

  }
#line 497
  if ((pc->flags & 16UL) != 0UL) {
    {
#line 498
    pc->flags = pc->flags & 0xffffffffffffffefUL;
#line 499
    printk("\vide-atapi: %s: The device wants to issue more interrupts in DMA mode\n",
           (char *)(& drive->name));
#line 501
    ide_dma_off(drive);
#line 502
    tmp___1 = ide_do_reset(drive);
    }
#line 502
    return (tmp___1);
  } else {

  }
  {
#line 506
  ide_read_bcount_and_ireason(drive, & bcount, & ireason);
#line 508
  tmp___3 = ide_check_ireason(drive, rq, (int )bcount, (int )ireason, (int )write);
  }
#line 508
  if (tmp___3 != 0) {
    {
#line 509
    tmp___2 = ide_do_reset(drive);
    }
#line 509
    return (tmp___2);
  } else {

  }
  {
#line 511
  __min1 = (unsigned int )bcount;
#line 511
  __min2 = cmd->nleft;
#line 511
  done = __min1 < __min2 ? __min1 : __min2;
#line 512
  ide_pio_bytes(drive, cmd, (unsigned int )write, done);
#line 515
  rq->resid_len = rq->resid_len - done;
#line 517
  bcount = (int )bcount - (int )((u16 )done);
  }
#line 519
  if ((unsigned int )bcount != 0U) {
    {
#line 520
    ide_pad_transfer(drive, (int )write, (int )bcount);
    }
  } else {

  }
  {
#line 526
  ide_set_handler(drive, & ide_pc_intr, timeout);
  }
#line 527
  return (1);
}
}
#line 530 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static void ide_init_packet_cmd(struct ide_cmd *cmd , u8 valid_tf , u16 bcount , u8 dma ) 
{ 


  {
#line 533
  cmd->protocol = (unsigned int )dma != 0U ? 7 : 6;
#line 534
  cmd->valid.out.tf = (u8 )((unsigned int )valid_tf | 50U);
#line 536
  cmd->tf.__annonCompField84.command = 160U;
#line 537
  cmd->tf.__annonCompField83.feature = dma;
#line 538
  cmd->tf.lbam = (u8 )bcount;
#line 539
  cmd->tf.lbah = (u8 )((int )bcount >> 8);
#line 540
  return;
}
}
#line 542 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static u8 ide_read_ireason(ide_drive_t *drive ) 
{ 
  struct ide_taskfile tf ;

  {
  {
#line 546
  (*(((drive->hwif)->tp_ops)->tf_read))(drive, & tf, 4);
  }
#line 548
  return ((unsigned int )tf.nsect & 3U);
}
}
#line 551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static u8 ide_wait_ireason(ide_drive_t *drive , u8 ireason ) 
{ 
  int retries ;
  int tmp ;

  {
#line 553
  retries = 100;
#line 555
  goto ldv_38546;
  ldv_38545: 
  {
#line 557
  printk("\vide-atapi: %s: (IO,CoD != (0,1) while issuing a packet command, retrying\n",
         (char *)(& drive->name));
#line 559
  __const_udelay(429500UL);
#line 560
  ireason = ide_read_ireason(drive);
  }
#line 561
  if (retries == 0) {
    {
#line 562
    printk("\vide-atapi: %s: (IO,CoD != (0,1) while issuing a packet command, ignoring\n",
           (char *)(& drive->name));
#line 565
    ireason = (u8 )((unsigned int )ireason | 1U);
#line 566
    ireason = (unsigned int )ireason & 253U;
    }
  } else {

  }
  ldv_38546: 
#line 555
  tmp = retries;
#line 555
  retries = retries - 1;
#line 555
  if (tmp != 0 && ((unsigned int )ireason & 3U) != 1U) {
#line 557
    goto ldv_38545;
  } else {

  }

#line 570
  return (ireason);
}
}
#line 573 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static int ide_delayed_transfer_pc(ide_drive_t *drive ) 
{ 


  {
  {
#line 576
  (*(((drive->hwif)->tp_ops)->output_data))(drive, (struct ide_cmd *)0, (void *)(& (drive->pc)->c),
                                            12U);
  }
#line 579
  return (12500);
}
}
#line 582 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static ide_startstop_t ide_transfer_pc(ide_drive_t *drive ) 
{ 
  struct ide_atapi_pc *pc ;
  ide_hwif_t *hwif ;
  struct request *rq ;
  ide_expiry_t *expiry ;
  unsigned int timeout ;
  int cmd_len ;
  ide_startstop_t startstop ;
  u8 ireason ;
  int tmp ;
  ide_startstop_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 584
  pc = pc;
#line 585
  hwif = drive->hwif;
#line 586
  rq = hwif->rq;
#line 593
  tmp = ide_wait_stat(& startstop, drive, 8, 128, 1250UL);
  }
#line 593
  if (tmp != 0) {
    {
#line 594
    printk("\vide-atapi: %s: Strange, packet command initiated yet DRQ isn\'t asserted\n",
           (char *)(& drive->name));
    }
#line 596
    return (startstop);
  } else {

  }
#line 599
  if ((int )drive->atapi_flags & 1) {
#line 600
    if ((unsigned int )drive->dma != 0U) {
#line 601
      drive->waiting_for_dma = 1U;
    } else {

    }
  } else {

  }
  {
#line 604
  tmp___1 = dev_is_idecd(drive);
  }
#line 604
  if (tmp___1 != 0) {
#line 606
    cmd_len = (int )scsi_command_size_tbl[((int )*(rq->cmd) >> 5) & 7];
#line 607
    if (cmd_len <= 11) {
#line 608
      cmd_len = 12;
    } else {

    }
#line 610
    timeout = rq->timeout;
#line 611
    expiry = & ide_cd_expiry;
  } else {
#line 613
    pc = drive->pc;
#line 615
    cmd_len = 12;
#line 622
    if ((drive->atapi_flags & 65536UL) != 0UL) {
#line 623
      timeout = (unsigned int )drive->pc_delay;
#line 624
      expiry = & ide_delayed_transfer_pc;
    } else {
#line 626
      timeout = (unsigned int )drive->media == 0U ? 12500U : 225000U;
#line 628
      expiry = (ide_expiry_t *)0;
    }
    {
#line 631
    ireason = ide_read_ireason(drive);
    }
#line 632
    if ((unsigned int )drive->media == 1U) {
      {
#line 633
      ireason = ide_wait_ireason(drive, (int )ireason);
      }
    } else {

    }
#line 635
    if (((unsigned int )ireason & 3U) != 1U) {
      {
#line 636
      printk("\vide-atapi: %s: (IO,CoD) != (0,1) while issuing a packet command\n",
             (char *)(& drive->name));
#line 639
      tmp___0 = ide_do_reset(drive);
      }
#line 639
      return (tmp___0);
    } else {

    }
  }
  {
#line 643
  hwif->expiry = expiry;
#line 646
  tmp___2 = dev_is_idecd(drive);
#line 646
  ide_set_handler(drive, tmp___2 != 0 ? drive->irq_handler : & ide_pc_intr, timeout);
  }
#line 652
  if ((drive->atapi_flags & 65536UL) == 0UL) {
    {
#line 653
    (*((hwif->tp_ops)->output_data))(drive, (struct ide_cmd *)0, (void *)rq->cmd,
                                     (unsigned int )cmd_len);
    }
  } else {

  }
  {
#line 656
  tmp___3 = dev_is_idecd(drive);
  }
#line 656
  if (tmp___3 != 0) {
#line 657
    if ((unsigned int )drive->dma != 0U) {
      {
#line 658
      (*((hwif->dma_ops)->dma_start))(drive);
      }
    } else {

    }
  } else
#line 660
  if ((pc->flags & 8UL) != 0UL) {
    {
#line 661
    pc->flags = pc->flags | 16UL;
#line 662
    (*((hwif->dma_ops)->dma_start))(drive);
    }
  } else {

  }
#line 666
  return (1);
}
}
#line 669 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
ide_startstop_t ide_issue_pc(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  struct ide_atapi_pc *pc ;
  ide_hwif_t *hwif ;
  ide_expiry_t *expiry ;
  struct request *rq ;
  unsigned int timeout ;
  unsigned int bytes ;
  u16 bcount ;
  u8 valid_tf ;
  u8 drq_int ;
  int tmp ;
  int tmp___0 ;
  unsigned int __min1 ;
  unsigned int __min2 ;
  int tmp___1 ;
  int tmp___2 ;
  ide_startstop_t tmp___3 ;
  unsigned int tmp___4 ;

  {
  {
#line 672
  hwif = drive->hwif;
#line 673
  expiry = (ide_expiry_t *)0;
#line 674
  rq = hwif->rq;
#line 678
  drq_int = (unsigned int )((u8 )drive->atapi_flags) & 1U;
#line 680
  tmp___2 = dev_is_idecd(drive);
  }
#line 680
  if (tmp___2 != 0) {
    {
#line 681
    valid_tf = 12U;
#line 682
    tmp = ide_cd_get_xferlen(rq);
#line 682
    bcount = (u16 )tmp;
#line 683
    expiry = & ide_cd_expiry;
#line 684
    timeout = 15000U;
    }
#line 686
    if ((unsigned int )drive->dma != 0U) {
      {
#line 687
      tmp___0 = ide_dma_prepare(drive, cmd);
#line 687
      drive->dma = tmp___0 == 0;
      }
    } else {

    }
  } else {
    {
#line 689
    pc = drive->pc;
#line 691
    valid_tf = 64U;
#line 692
    bytes = blk_rq_bytes((struct request  const  *)rq);
    }
#line 694
    if ((unsigned int )drive->media == 1U) {
#line 694
      bcount = (u16 )bytes;
    } else {
#line 694
      __min1 = bytes;
#line 694
      __min2 = 64512U;
#line 694
      bcount = (u16 )(__min1 < __min2 ? __min1 : __min2);
    }
#line 698
    rq->resid_len = (unsigned int )bcount;
#line 700
    if ((pc->flags & 32UL) != 0UL) {
      {
#line 701
      pc->flags = pc->flags & 0xffffffffffffffdfUL;
#line 702
      ide_dma_off(drive);
      }
    } else {

    }
#line 705
    if ((pc->flags & 8UL) != 0UL) {
      {
#line 706
      tmp___1 = ide_dma_prepare(drive, cmd);
#line 706
      drive->dma = tmp___1 == 0;
      }
    } else {

    }
#line 708
    if ((unsigned int )drive->dma == 0U) {
#line 709
      pc->flags = pc->flags & 0xfffffffffffffff7UL;
    } else {

    }
#line 711
    timeout = (unsigned int )drive->media == 0U ? 12500U : 225000U;
  }
  {
#line 715
  ide_init_packet_cmd(cmd, (int )valid_tf, (int )bcount, (int )drive->dma);
#line 717
  do_rw_taskfile(drive, cmd);
  }
#line 719
  if ((unsigned int )drq_int != 0U) {
#line 720
    if ((unsigned int )drive->dma != 0U) {
#line 721
      drive->waiting_for_dma = 0U;
    } else {

    }
#line 722
    hwif->expiry = expiry;
  } else {

  }
  {
#line 725
  ide_execute_command(drive, cmd, & ide_transfer_pc, timeout);
  }
#line 727
  if ((unsigned int )drq_int == 0U) {
    {
#line 727
    tmp___3 = ide_transfer_pc(drive);
#line 727
    tmp___4 = tmp___3;
    }
  } else {
#line 727
    tmp___4 = 1;
  }
#line 727
  return (tmp___4);
}
}
#line 729 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
static char const   __kstrtab_ide_issue_pc[13U]  = 
#line 729
  {      'i',      'd',      'e',      '_', 
        'i',      's',      's',      'u', 
        'e',      '_',      'p',      'c', 
        '\000'};
#line 729
struct kernel_symbol  const  __ksymtab_ide_issue_pc ;
#line 729 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-atapi.c"
struct kernel_symbol  const  __ksymtab_ide_issue_pc  =    {(unsigned long )(& ide_issue_pc), (char const   *)(& __kstrtab_ide_issue_pc)};
#line 1327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-atapi.c.aux"
static struct request *ldv_blk_get_request_96___1(struct request_queue *ldv_func_arg1 ,
                                                  int ldv_func_arg2 , gfp_t ldv_func_arg3 ) 
{ 
  struct request *tmp ;

  {
  {
#line 1330
  tmp = ldv_linux_block_request_blk_get_request(ldv_func_arg3);
  }
#line 1330
  return (tmp);
}
}
#line 1333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-atapi.c.aux"
static void ldv_blk_put_request_97___1(struct request *ldv_func_arg1 ) 
{ 


  {
  {
#line 1336
  ldv_linux_block_request_put_blk_rq();
  }
#line 1337
  return;
}
}
#line 86 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kobject.h"
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
#line 88
  return ((char const   *)kobj->name);
}
}
#line 809 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
#line 812
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
#line 813
    return ((char const   *)dev->init_name);
  } else {

  }
  {
#line 815
  tmp = kobject_name(& dev->kobj);
  }
#line 815
  return (tmp);
}
}
#line 848 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
#line 850
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
#line 854
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
#line 856
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
#line 872 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
  {
#line 874
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  }
#line 874
  return (tmp);
}
}
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
  {
#line 878
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  }
#line 878
  return (tmp);
}
}
#line 885 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
  {
#line 887
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
  }
#line 887
  return (tmp);
}
}
#line 889 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
  {
#line 891
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
  }
#line 891
  return (tmp);
}
}
#line 940
extern int pci_enable_device(struct pci_dev * ) ;
#line 941
extern int pci_enable_device_io(struct pci_dev * ) ;
#line 957
extern void pci_disable_device(struct pci_dev * ) ;
#line 960
extern void pci_set_master(struct pci_dev * ) ;
#line 1015
extern int pci_save_state(struct pci_dev * ) ;
#line 1016
extern void pci_restore_state(struct pci_dev * ) ;
#line 1029
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
#line 1030
extern pci_power_t pci_choose_state(struct pci_dev * , pm_message_t  ) ;
#line 1094
extern int pci_request_selected_regions(struct pci_dev * , int  , char const   * ) ;
#line 1096
extern void pci_release_selected_regions(struct pci_dev * , int  ) ;
#line 61 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
extern int dma_set_mask(struct device * , u64  ) ;
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci-dma-compat.h"
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
  {
#line 115
  tmp = dma_set_mask(& dev->dev, mask);
  }
#line 115
  return (tmp);
}
}
#line 23 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/pci.h"
__inline static int pci_get_legacy_ide_irq(struct pci_dev *dev , int channel ) 
{ 


  {
#line 25
  return (channel != 0 ? 15 : 14);
}
}
#line 1474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  {
#line 1476
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  }
#line 1476
  return (tmp);
}
}
#line 1479 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
  {
#line 1481
  dev_set_drvdata(& pdev->dev, data);
  }
#line 1482
  return;
}
}
#line 1487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/pci.h"
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
  {
#line 1489
  tmp = dev_name(& pdev->dev);
  }
#line 1489
  return (tmp);
}
}
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
__inline static void ide_std_init_ports(struct ide_hw *hw , unsigned long io_addr ,
                                        unsigned long ctl_addr ) 
{ 
  unsigned int i ;
  unsigned long tmp ;

  {
#line 188
  i = 0U;
#line 188
  goto ldv_37089;
  ldv_37088: 
#line 189
  tmp = io_addr;
#line 189
  io_addr = io_addr + 1UL;
#line 189
  hw->__annonCompField82.io_ports_array[i] = tmp;
#line 188
  i = i + 1U;
  ldv_37089: ;
#line 188
  if (i <= 7U) {
#line 190
    goto ldv_37088;
  } else {

  }
#line 191
  hw->__annonCompField82.io_ports.ctl_addr = ctl_addr;
#line 192
  return;
}
}
#line 1179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
__inline static int ide_pci_is_in_compatibility_mode(struct pci_dev *dev ) 
{ 


  {
#line 1181
  if (dev->class >> 8 == 257U && (dev->class & 5U) != 5U) {
#line 1182
    return (1);
  } else {

  }
#line 1183
  return (0);
}
}
#line 1186
void ide_pci_setup_ports(struct pci_dev *dev , struct ide_port_info  const  *d , struct ide_hw *hw ,
                         struct ide_hw **hws ) ;
#line 1188
void ide_setup_pci_noise(struct pci_dev *dev , struct ide_port_info  const  *d ) ;
#line 1191
int ide_pci_set_master(struct pci_dev *dev , char const   *name ) ;
#line 1192
unsigned long ide_pci_dma_base(ide_hwif_t *hwif , struct ide_port_info  const  *d ) ;
#line 1193
int ide_pci_check_simplex(ide_hwif_t *hwif , struct ide_port_info  const  *d ) ;
#line 1317
int ide_pci_init_one(struct pci_dev *dev , struct ide_port_info  const  *d , void *priv ) ;
#line 1318
int ide_pci_init_two(struct pci_dev *dev1 , struct pci_dev *dev2 , struct ide_port_info  const  *d ,
                     void *priv ) ;
#line 1320
void ide_pci_remove(struct pci_dev *dev ) ;
#line 1323
int ide_pci_suspend(struct pci_dev *dev , pm_message_t state ) ;
#line 1324
int ide_pci_resume(struct pci_dev *dev ) ;
#line 1361
int ide_allocate_dma_engine(ide_hwif_t *hwif ) ;
#line 1377
struct ide_dma_ops  const  sff_dma_ops ;
#line 33 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static int ide_setup_pci_baseregs(struct pci_dev *dev , char const   *name ) 
{ 
  u8 progif ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 35
  progif = 0U;
#line 40
  tmp___3 = pci_read_config_byte((struct pci_dev  const  *)dev, 9, & progif);
  }
#line 40
  if (tmp___3 != 0 || ((int )progif & 5) != 5) {
#line 42
    if (((int )progif & 10) != 10) {
      {
#line 43
      tmp = pci_name((struct pci_dev  const  *)dev);
#line 43
      printk("\016%s %s: device not capable of full native PCI mode\n", name, tmp);
      }
#line 45
      return (-95);
    } else {

    }
    {
#line 47
    tmp___0 = pci_name((struct pci_dev  const  *)dev);
#line 47
    printk("\016%s %s: placing both ports into native PCI mode\n", name, tmp___0);
#line 49
    pci_write_config_byte((struct pci_dev  const  *)dev, 9, (int )((unsigned int )progif | 5U));
#line 50
    tmp___2 = pci_read_config_byte((struct pci_dev  const  *)dev, 9, & progif);
    }
#line 50
    if (tmp___2 != 0 || ((int )progif & 5) != 5) {
      {
#line 52
      tmp___1 = pci_name((struct pci_dev  const  *)dev);
#line 52
      printk("\v%s %s: rewrite of PROGIF failed, wanted 0x%04x, got 0x%04x\n", name,
             tmp___1, (int )((unsigned int )progif | 5U), (int )progif);
      }
#line 55
      return (-95);
    } else {

    }
  } else {

  }
#line 58
  return (0);
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static int ide_pci_clear_simplex(unsigned long dma_base , char const   *name ) 
{ 
  u8 dma_stat ;
  unsigned char tmp ;

  {
  {
#line 64
  tmp = inb((int )((unsigned int )dma_base + 2U));
#line 64
  dma_stat = tmp;
#line 66
  outb((int )dma_stat & 96, (int )((unsigned int )dma_base + 2U));
#line 67
  dma_stat = inb((int )((unsigned int )dma_base + 2U));
  }
#line 69
  return ((int )((signed char )dma_stat) < 0);
}
}
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
unsigned long ide_pci_dma_base(ide_hwif_t *hwif , struct ide_port_info  const  *d ) 
{ 
  struct pci_dev *dev ;
  struct device  const  *__mptr ;
  unsigned long dma_base ;
  u8 baridx ;
  char const   *tmp ;

  {
#line 82
  __mptr = (struct device  const  *)hwif->dev;
#line 82
  dev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 83
  dma_base = 0UL;
#line 85
  if ((hwif->host_flags & 65536U) != 0U) {
#line 86
    return (hwif->dma_base);
  } else {

  }
#line 88
  if ((unsigned long )hwif->mate != (unsigned long )((struct hwif_s *)0) && (hwif->mate)->dma_base != 0UL) {
#line 89
    dma_base = (hwif->mate)->dma_base - ((unsigned int )hwif->channel != 0U ? 0UL : 8UL);
  } else {
#line 91
    baridx = ((unsigned int )d->host_flags & 2048U) != 0U ? 2U : 4U;
#line 93
    dma_base = (unsigned long )dev->resource[(int )baridx].start;
#line 95
    if (dma_base == 0UL) {
      {
#line 96
      tmp = pci_name((struct pci_dev  const  *)dev);
#line 96
      printk("\v%s %s: DMA base is invalid\n", d->name, tmp);
      }
#line 98
      return (0UL);
    } else {

    }
  }
#line 102
  if ((unsigned int )hwif->channel != 0U) {
#line 103
    dma_base = dma_base + 8UL;
  } else {

  }
#line 105
  return (dma_base);
}
}
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_dma_base[17U]  = 
#line 107
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        'd',      'm',      'a',      '_', 
        'b',      'a',      's',      'e', 
        '\000'};
#line 107
struct kernel_symbol  const  __ksymtab_ide_pci_dma_base ;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_dma_base  =    {(unsigned long )(& ide_pci_dma_base), (char const   *)(& __kstrtab_ide_pci_dma_base)};
#line 109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
int ide_pci_check_simplex(ide_hwif_t *hwif , struct ide_port_info  const  *d ) 
{ 
  struct pci_dev *dev ;
  struct device  const  *__mptr ;
  u8 dma_stat ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 111
  __mptr = (struct device  const  *)hwif->dev;
#line 111
  dev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 114
  if (((unsigned int )d->host_flags & 67584U) != 0U) {
#line 115
    goto out;
  } else {

  }
#line 117
  if (((unsigned int )d->host_flags & 268435456U) != 0U) {
    {
#line 118
    tmp___0 = ide_pci_clear_simplex(hwif->dma_base, (char const   *)d->name);
    }
#line 118
    if (tmp___0 != 0) {
      {
#line 119
      tmp = pci_name((struct pci_dev  const  *)dev);
#line 119
      printk("\016%s %s: simplex device: DMA forced\n", d->name, tmp);
      }
    } else {

    }
#line 121
    goto out;
  } else {

  }
  {
#line 134
  dma_stat = (*((hwif->dma_ops)->dma_sff_read_status))(hwif);
  }
#line 135
  if (((int )((signed char )dma_stat) < 0 && (unsigned long )hwif->mate != (unsigned long )((struct hwif_s *)0)) && (hwif->mate)->dma_base != 0UL) {
    {
#line 136
    tmp___1 = pci_name((struct pci_dev  const  *)dev);
#line 136
    printk("\016%s %s: simplex device: DMA disabled\n", d->name, tmp___1);
    }
#line 138
    return (-1);
  } else {

  }
  out: ;
#line 141
  return (0);
}
}
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_check_simplex[22U]  = 
#line 143
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        'c',      'h',      'e',      'c', 
        'k',      '_',      's',      'i', 
        'm',      'p',      'l',      'e', 
        'x',      '\000'};
#line 143
struct kernel_symbol  const  __ksymtab_ide_pci_check_simplex ;
#line 143 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_check_simplex  =    {(unsigned long )(& ide_pci_check_simplex), (char const   *)(& __kstrtab_ide_pci_check_simplex)};
#line 148 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
int ide_pci_set_master(struct pci_dev *dev , char const   *name ) 
{ 
  u16 pcicmd ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 152
  pci_read_config_word((struct pci_dev  const  *)dev, 4, & pcicmd);
  }
#line 154
  if (((int )pcicmd & 4) == 0) {
    {
#line 155
    pci_set_master(dev);
#line 157
    tmp___0 = pci_read_config_word((struct pci_dev  const  *)dev, 4, & pcicmd);
    }
#line 157
    if (tmp___0 != 0 || ((int )pcicmd & 4) == 0) {
      {
#line 159
      tmp = pci_name((struct pci_dev  const  *)dev);
#line 159
      printk("\v%s %s: error updating PCICMD\n", name, tmp);
      }
#line 161
      return (-5);
    } else {

    }
  } else {

  }
#line 165
  return (0);
}
}
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_set_master[19U]  = 
#line 167
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        's',      'e',      't',      '_', 
        'm',      'a',      's',      't', 
        'e',      'r',      '\000'};
#line 167
struct kernel_symbol  const  __ksymtab_ide_pci_set_master ;
#line 167 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_set_master  =    {(unsigned long )(& ide_pci_set_master), (char const   *)(& __kstrtab_ide_pci_set_master)};
#line 170 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
void ide_setup_pci_noise(struct pci_dev *dev , struct ide_port_info  const  *d ) 
{ 
  char const   *tmp ;

  {
  {
#line 172
  tmp = pci_name((struct pci_dev  const  *)dev);
#line 172
  printk("\016%s %s: IDE controller (0x%04x:0x%04x rev 0x%02x)\n", d->name, tmp, (int )dev->vendor,
         (int )dev->device, (int )dev->revision);
  }
#line 175
  return;
}
}
#line 176 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_setup_pci_noise[20U]  = 
#line 176
  {      'i',      'd',      'e',      '_', 
        's',      'e',      't',      'u', 
        'p',      '_',      'p',      'c', 
        'i',      '_',      'n',      'o', 
        'i',      's',      'e',      '\000'};
#line 176
struct kernel_symbol  const  __ksymtab_ide_setup_pci_noise ;
#line 176 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_setup_pci_noise  =    {(unsigned long )(& ide_setup_pci_noise), (char const   *)(& __kstrtab_ide_setup_pci_noise)};
#line 192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static int ide_pci_enable(struct pci_dev *dev , struct ide_port_info  const  *d ) 
{ 
  int ret ;
  int bars ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 196
  tmp___1 = pci_enable_device(dev);
  }
#line 196
  if (tmp___1 != 0) {
    {
#line 197
    ret = pci_enable_device_io(dev);
    }
#line 198
    if (ret < 0) {
      {
#line 199
      tmp = pci_name((struct pci_dev  const  *)dev);
#line 199
      printk("\f%s %s: couldn\'t enable device\n", d->name, tmp);
      }
#line 201
      goto out;
    } else {

    }
    {
#line 203
    tmp___0 = pci_name((struct pci_dev  const  *)dev);
#line 203
    printk("\f%s %s: BIOS configuration fixed\n", d->name, tmp___0);
    }
  } else {

  }
  {
#line 212
  ret = pci_set_dma_mask(dev, 4294967295ULL);
  }
#line 213
  if (ret < 0) {
    {
#line 214
    tmp___2 = pci_name((struct pci_dev  const  *)dev);
#line 214
    printk("\v%s %s: can\'t set DMA mask\n", d->name, tmp___2);
    }
#line 216
    goto out;
  } else {

  }
#line 219
  if (((unsigned int )d->host_flags & 2U) != 0U) {
#line 220
    bars = 3;
  } else {
#line 222
    bars = 15;
  }
#line 224
  if (((unsigned int )d->host_flags & 16384U) == 0U) {
#line 225
    if (((unsigned int )d->host_flags & 2048U) != 0U) {
#line 226
      bars = bars | 4;
    } else {
#line 228
      bars = bars | 16;
    }
  } else {

  }
  {
#line 231
  ret = pci_request_selected_regions(dev, bars, (char const   *)d->name);
  }
#line 232
  if (ret < 0) {
    {
#line 233
    tmp___3 = pci_name((struct pci_dev  const  *)dev);
#line 233
    printk("\v%s %s: can\'t reserve resources\n", d->name, tmp___3);
    }
  } else {

  }
  out: ;
#line 236
  return (ret);
}
}
#line 248 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static int ide_pci_configure(struct pci_dev *dev , struct ide_port_info  const  *d ) 
{ 
  u16 pcicmd ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 250
  pcicmd = 0U;
#line 258
  tmp___0 = ide_setup_pci_baseregs(dev, (char const   *)d->name);
  }
#line 258
  if (tmp___0 != 0) {
    {
#line 260
    tmp = pci_name((struct pci_dev  const  *)dev);
#line 260
    printk("\016%s %s: device disabled (BIOS)\n", d->name, tmp);
    }
#line 262
    return (-19);
  } else {
    {
#line 258
    tmp___1 = pci_write_config_word((struct pci_dev  const  *)dev, 4, (int )((unsigned int )pcicmd | 1U));
    }
#line 258
    if (tmp___1 != 0) {
      {
#line 260
      tmp = pci_name((struct pci_dev  const  *)dev);
#line 260
      printk("\016%s %s: device disabled (BIOS)\n", d->name, tmp);
      }
#line 262
      return (-19);
    } else {

    }
  }
  {
#line 264
  tmp___3 = pci_read_config_word((struct pci_dev  const  *)dev, 4, & pcicmd);
  }
#line 264
  if (tmp___3 != 0) {
    {
#line 265
    tmp___2 = pci_name((struct pci_dev  const  *)dev);
#line 265
    printk("\v%s %s: error accessing PCI regs\n", d->name, tmp___2);
    }
#line 267
    return (-5);
  } else {

  }
#line 269
  if (((int )pcicmd & 1) == 0) {
    {
#line 270
    tmp___4 = pci_name((struct pci_dev  const  *)dev);
#line 270
    printk("\v%s %s: unable to enable IDE controller\n", d->name, tmp___4);
    }
#line 272
    return (-6);
  } else {

  }
#line 274
  return (0);
}
}
#line 287 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static int ide_pci_check_iomem(struct pci_dev *dev , struct ide_port_info  const  *d ,
                               int bar ) 
{ 
  ulong flags ;

  {
#line 290
  flags = dev->resource[bar].flags;
#line 293
  if (flags == 0UL || ((dev->resource[bar].start == 0ULL && dev->resource[bar].end == dev->resource[bar].start) || dev->resource[bar].end - dev->resource[bar].start == 0xffffffffffffffffULL)) {
#line 294
    return (0);
  } else {

  }
#line 297
  if ((flags & 256UL) != 0UL) {
#line 298
    return (0);
  } else {

  }
#line 301
  return (-22);
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static int ide_hw_configure(struct pci_dev *dev , struct ide_port_info  const  *d ,
                            unsigned int port , struct ide_hw *hw ) 
{ 
  unsigned long ctl ;
  unsigned long base ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 321
  ctl = 0UL;
#line 321
  base = 0UL;
#line 323
  if (((unsigned int )d->host_flags & 1U) == 0U) {
    {
#line 324
    tmp___0 = ide_pci_check_iomem(dev, d, (int )(port * 2U));
    }
#line 324
    if (tmp___0 != 0) {
      {
#line 326
      tmp = pci_name((struct pci_dev  const  *)dev);
#line 326
      printk("\v%s %s: I/O baseregs (BIOS) are reported as MEM for port %d!\n", d->name,
             tmp, port);
      }
#line 329
      return (-22);
    } else {
      {
#line 324
      tmp___1 = ide_pci_check_iomem(dev, d, (int )(port * 2U + 1U));
      }
#line 324
      if (tmp___1 != 0) {
        {
#line 326
        tmp = pci_name((struct pci_dev  const  *)dev);
#line 326
        printk("\v%s %s: I/O baseregs (BIOS) are reported as MEM for port %d!\n",
               d->name, tmp, port);
        }
#line 329
        return (-22);
      } else {

      }
    }
#line 332
    ctl = (unsigned long )dev->resource[port * 2U + 1U].start;
#line 333
    base = (unsigned long )dev->resource[port * 2U].start;
  } else {
#line 336
    ctl = port != 0U ? 884UL : 1012UL;
#line 337
    base = port != 0U ? 368UL : 496UL;
  }
#line 340
  if (base == 0UL || ctl == 0UL) {
    {
#line 341
    tmp___2 = pci_name((struct pci_dev  const  *)dev);
#line 341
    printk("\v%s %s: bad PCI BARs for port %d, skipping\n", d->name, tmp___2, port);
    }
#line 343
    return (-22);
  } else {

  }
  {
#line 346
  __memset((void *)hw, 0, 112UL);
#line 347
  hw->dev = & dev->dev;
#line 348
  ide_std_init_ports(hw, base, ctl | 2UL);
  }
#line 350
  return (0);
}
}
#line 364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
int ide_hwif_setup_dma(ide_hwif_t *hwif , struct ide_port_info  const  *d ) 
{ 
  struct pci_dev *dev ;
  struct device  const  *__mptr ;
  unsigned long base ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 366
  __mptr = (struct device  const  *)hwif->dev;
#line 366
  dev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 368
  if (((unsigned int )d->host_flags & 32768U) == 0U || (dev->class >> 8 == 257U && (dev->class & 128U) != 0U)) {
    {
#line 371
    tmp = ide_pci_dma_base(hwif, d);
#line 371
    base = tmp;
    }
#line 373
    if (base == 0UL) {
#line 374
      return (-1);
    } else {

    }
#line 376
    hwif->dma_base = base;
#line 378
    if ((unsigned long )hwif->dma_ops == (unsigned long )((struct ide_dma_ops  const  *)0)) {
#line 379
      hwif->dma_ops = & sff_dma_ops;
    } else {

    }
    {
#line 381
    tmp___0 = ide_pci_check_simplex(hwif, d);
    }
#line 381
    if (tmp___0 < 0) {
#line 382
      return (-1);
    } else {

    }
    {
#line 384
    tmp___1 = ide_pci_set_master(dev, (char const   *)d->name);
    }
#line 384
    if (tmp___1 < 0) {
#line 385
      return (-1);
    } else {

    }
#line 387
    if ((hwif->host_flags & 65536U) != 0U) {
      {
#line 388
      printk("\016    %s: MMIO-DMA\n", (char *)(& hwif->name));
      }
    } else {
      {
#line 390
      printk("\016    %s: BM-DMA at 0x%04lx-0x%04lx\n", (char *)(& hwif->name), base,
             base + 7UL);
      }
    }
    {
#line 393
    hwif->extra_base = base + ((unsigned int )hwif->channel != 0U ? 8UL : 16UL);
#line 395
    tmp___2 = ide_allocate_dma_engine(hwif);
    }
#line 395
    if (tmp___2 != 0) {
#line 396
      return (-1);
    } else {

    }
  } else {

  }
#line 399
  return (0);
}
}
#line 414 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static int ide_setup_pci_controller(struct pci_dev *dev , struct ide_port_info  const  *d ,
                                    int noisy ) 
{ 
  int ret ;
  u16 pcicmd ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 420
  if (noisy != 0) {
    {
#line 421
    ide_setup_pci_noise(dev, d);
    }
  } else {

  }
  {
#line 423
  ret = ide_pci_enable(dev, d);
  }
#line 424
  if (ret < 0) {
#line 425
    goto out;
  } else {

  }
  {
#line 427
  ret = pci_read_config_word((struct pci_dev  const  *)dev, 4, & pcicmd);
  }
#line 428
  if (ret < 0) {
    {
#line 429
    tmp = pci_name((struct pci_dev  const  *)dev);
#line 429
    printk("\v%s %s: error accessing PCI regs\n", d->name, tmp);
    }
#line 431
    goto out;
  } else {

  }
#line 433
  if (((int )pcicmd & 1) == 0) {
    {
#line 434
    ret = ide_pci_configure(dev, d);
    }
#line 435
    if (ret < 0) {
#line 436
      goto out;
    } else {

    }
    {
#line 437
    tmp___0 = pci_name((struct pci_dev  const  *)dev);
#line 437
    printk("\016%s %s: device enabled (Linux)\n", d->name, tmp___0);
    }
  } else {

  }
  out: ;
#line 442
  return (ret);
}
}
#line 461 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
void ide_pci_setup_ports(struct pci_dev *dev , struct ide_port_info  const  *d , struct ide_hw *hw ,
                         struct ide_hw **hws ) 
{ 
  int channels ;
  int port ;
  u8 tmp ;
  struct ide_pci_enablebit  const  *e ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 464
  channels = ((unsigned int )d->host_flags & 2U) != 0U ? 1 : 2;
#line 471
  port = 0;
#line 471
  goto ldv_38310;
  ldv_38309: 
#line 472
  e = (struct ide_pci_enablebit  const  *)(& d->enablebits) + (unsigned long )port;
#line 474
  if ((unsigned int )((unsigned char )e->reg) != 0U) {
    {
#line 474
    tmp___1 = pci_read_config_byte((struct pci_dev  const  *)dev, (int )e->reg, & tmp);
    }
#line 474
    if (tmp___1 != 0 || ((int )tmp & (int )((unsigned char )e->mask)) != (int )((unsigned char )e->val)) {
      {
#line 476
      tmp___0 = pci_name((struct pci_dev  const  *)dev);
#line 476
      printk("\016%s %s: IDE port disabled\n", d->name, tmp___0);
      }
#line 478
      goto ldv_38308;
    } else {

    }
  } else {

  }
  {
#line 481
  tmp___2 = ide_hw_configure(dev, d, (unsigned int )port, hw + (unsigned long )port);
  }
#line 481
  if (tmp___2 != 0) {
#line 482
    goto ldv_38308;
  } else {

  }
#line 484
  *(hws + (unsigned long )port) = hw + (unsigned long )port;
  ldv_38308: 
#line 471
  port = port + 1;
  ldv_38310: ;
#line 471
  if (port < channels) {
#line 473
    goto ldv_38309;
  } else {

  }

#line 478
  return;
}
}
#line 487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_setup_ports[20U]  = 
#line 487
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        's',      'e',      't',      'u', 
        'p',      '_',      'p',      'o', 
        'r',      't',      's',      '\000'};
#line 487
struct kernel_symbol  const  __ksymtab_ide_pci_setup_ports ;
#line 487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_setup_ports  =    {(unsigned long )(& ide_pci_setup_ports), (char const   *)(& __kstrtab_ide_pci_setup_ports)};
#line 499 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static int do_ide_setup_pci_device(struct pci_dev *dev , struct ide_port_info  const  *d ,
                                   u8 noisy ) 
{ 
  int pciirq ;
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
#line 508
  pciirq = (int )dev->irq;
#line 516
  if ((unsigned long )d->init_chipset != (unsigned long )((int (*/* const  */)(struct pci_dev * ))0)) {
    {
#line 516
    tmp = (*(d->init_chipset))(dev);
#line 516
    ret = tmp;
    }
  } else {
#line 516
    ret = 0;
  }
#line 517
  if (ret < 0) {
#line 518
    goto out;
  } else {

  }
  {
#line 520
  tmp___3 = ide_pci_is_in_compatibility_mode(dev);
  }
#line 520
  if (tmp___3 != 0) {
#line 521
    if ((unsigned int )noisy != 0U) {
      {
#line 522
      tmp___0 = pci_name((struct pci_dev  const  *)dev);
#line 522
      printk("\016%s %s: not 100%% native mode: will probe irqs later\n", d->name,
             tmp___0);
      }
    } else {

    }
#line 524
    pciirq = 0;
  } else
#line 525
  if (pciirq == 0 && (unsigned int )noisy != 0U) {
    {
#line 526
    tmp___1 = pci_name((struct pci_dev  const  *)dev);
#line 526
    printk("\f%s %s: bad irq (%d): will probe later\n", d->name, tmp___1, pciirq);
    }
  } else
#line 528
  if ((unsigned int )noisy != 0U) {
    {
#line 529
    tmp___2 = pci_name((struct pci_dev  const  *)dev);
#line 529
    printk("\016%s %s: 100%% native mode on irq %d\n", d->name, tmp___2, pciirq);
    }
  } else {

  }
#line 533
  ret = pciirq;
  out: ;
#line 535
  return (ret);
}
}
#line 538 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
int ide_pci_init_two(struct pci_dev *dev1 , struct pci_dev *dev2 , struct ide_port_info  const  *d ,
                     void *priv ) 
{ 
  struct pci_dev *pdev[2U] ;
  struct ide_host *host ;
  int ret ;
  int i ;
  int n_ports ;
  struct ide_hw hw[4U] ;
  struct ide_hw *hws[4U] ;
  int tmp ;
  int tmp___0 ;

  {
#line 541
  pdev[0] = dev1;
#line 541
  pdev[1] = dev2;
#line 543
  n_ports = (unsigned long )dev2 != (unsigned long )((struct pci_dev *)0) ? 4 : 2;
#line 544
  hws[0] = (struct ide_hw *)0;
#line 544
  hws[1] = (struct ide_hw *)0;
#line 544
  hws[2] = (struct ide_hw *)0;
#line 544
  hws[3] = (struct ide_hw *)0;
#line 546
  i = 0;
#line 546
  goto ldv_38345;
  ldv_38344: 
  {
#line 547
  ret = ide_setup_pci_controller(pdev[i], d, i == 0);
  }
#line 548
  if (ret < 0) {
#line 549
    goto out;
  } else {

  }
  {
#line 551
  ide_pci_setup_ports(pdev[i], d, (struct ide_hw *)(& hw) + (unsigned long )(i * 2),
                      (struct ide_hw **)(& hws) + (unsigned long )(i * 2));
#line 546
  i = i + 1;
  }
  ldv_38345: ;
#line 546
  if (i < n_ports / 2) {
#line 548
    goto ldv_38344;
  } else {

  }
  {
#line 554
  host = ide_host_alloc(d, (struct ide_hw **)(& hws), (unsigned int )n_ports);
  }
#line 555
  if ((unsigned long )host == (unsigned long )((struct ide_host *)0)) {
#line 556
    ret = -12;
#line 557
    goto out;
  } else {

  }
#line 560
  host->dev[0] = & dev1->dev;
#line 561
  if ((unsigned long )dev2 != (unsigned long )((struct pci_dev *)0)) {
#line 562
    host->dev[1] = & dev2->dev;
  } else {

  }
  {
#line 564
  host->host_priv = priv;
#line 565
  host->irq_flags = 128;
#line 567
  pci_set_drvdata(pdev[0], (void *)host);
  }
#line 568
  if ((unsigned long )dev2 != (unsigned long )((struct pci_dev *)0)) {
    {
#line 569
    pci_set_drvdata(pdev[1], (void *)host);
    }
  } else {

  }
#line 571
  i = 0;
#line 571
  goto ldv_38348;
  ldv_38347: 
  {
#line 572
  ret = do_ide_setup_pci_device(pdev[i], d, i == 0);
  }
#line 578
  if (ret < 0) {
#line 579
    goto out;
  } else {

  }
  {
#line 582
  tmp___0 = ide_pci_is_in_compatibility_mode(pdev[i]);
  }
#line 582
  if (tmp___0 != 0) {
    {
#line 583
    hw[i * 2].irq = pci_get_legacy_ide_irq(pdev[i], 0);
#line 584
    hw[i * 2 + 1].irq = pci_get_legacy_ide_irq(pdev[i], 1);
    }
  } else {
#line 586
    tmp = ret;
#line 586
    hw[i * 2].irq = tmp;
#line 586
    hw[i * 2 + 1].irq = tmp;
  }
#line 571
  i = i + 1;
  ldv_38348: ;
#line 571
  if (i < n_ports / 2) {
#line 573
    goto ldv_38347;
  } else {

  }
  {
#line 589
  ret = ide_host_register(host, d, (struct ide_hw **)(& hws));
  }
#line 590
  if (ret != 0) {
    {
#line 591
    ide_host_free(host);
    }
  } else {

  }
  out: ;
#line 593
  return (ret);
}
}
#line 595 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_init_two[17U]  = 
#line 595
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        'i',      'n',      'i',      't', 
        '_',      't',      'w',      'o', 
        '\000'};
#line 595
struct kernel_symbol  const  __ksymtab_ide_pci_init_two ;
#line 595 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_init_two  =    {(unsigned long )(& ide_pci_init_two), (char const   *)(& __kstrtab_ide_pci_init_two)};
#line 597 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
int ide_pci_init_one(struct pci_dev *dev , struct ide_port_info  const  *d , void *priv ) 
{ 
  int tmp ;

  {
  {
#line 600
  tmp = ide_pci_init_two(dev, (struct pci_dev *)0, d, priv);
  }
#line 600
  return (tmp);
}
}
#line 602 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_init_one[17U]  = 
#line 602
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        'i',      'n',      'i',      't', 
        '_',      'o',      'n',      'e', 
        '\000'};
#line 602
struct kernel_symbol  const  __ksymtab_ide_pci_init_one ;
#line 602 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_init_one  =    {(unsigned long )(& ide_pci_init_one), (char const   *)(& __kstrtab_ide_pci_init_one)};
#line 604 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
void ide_pci_remove(struct pci_dev *dev ) 
{ 
  struct ide_host *host ;
  void *tmp ;
  struct pci_dev *dev2 ;
  struct device  const  *__mptr ;
  struct pci_dev *tmp___0 ;
  int bars ;

  {
  {
#line 606
  tmp = pci_get_drvdata(dev);
#line 606
  host = (struct ide_host *)tmp;
  }
#line 607
  if ((unsigned long )host->dev[1] != (unsigned long )((struct device *)0)) {
#line 607
    __mptr = (struct device  const  *)host->dev[1];
#line 607
    tmp___0 = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
  } else {
#line 607
    tmp___0 = (struct pci_dev *)0;
  }
#line 607
  dev2 = tmp___0;
#line 610
  if ((host->host_flags & 2UL) != 0UL) {
#line 611
    bars = 3;
  } else {
#line 613
    bars = 15;
  }
#line 615
  if ((host->host_flags & 16384UL) == 0UL) {
#line 616
    if ((host->host_flags & 2048UL) != 0UL) {
#line 617
      bars = bars | 4;
    } else {
#line 619
      bars = bars | 16;
    }
  } else {

  }
  {
#line 622
  ide_host_remove(host);
  }
#line 624
  if ((unsigned long )dev2 != (unsigned long )((struct pci_dev *)0)) {
    {
#line 625
    pci_release_selected_regions(dev2, bars);
    }
  } else {

  }
  {
#line 626
  pci_release_selected_regions(dev, bars);
  }
#line 628
  if ((unsigned long )dev2 != (unsigned long )((struct pci_dev *)0)) {
    {
#line 629
    pci_disable_device(dev2);
    }
  } else {

  }
  {
#line 630
  pci_disable_device(dev);
  }
#line 631
  return;
}
}
#line 632 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_remove[15U]  = 
#line 632
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        'r',      'e',      'm',      'o', 
        'v',      'e',      '\000'};
#line 632
struct kernel_symbol  const  __ksymtab_ide_pci_remove ;
#line 632 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_remove  =    {(unsigned long )(& ide_pci_remove), (char const   *)(& __kstrtab_ide_pci_remove)};
#line 635 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
int ide_pci_suspend(struct pci_dev *dev , pm_message_t state ) 
{ 
  pci_power_t tmp ;

  {
  {
#line 637
  pci_save_state(dev);
#line 638
  pci_disable_device(dev);
#line 639
  tmp = pci_choose_state(dev, state);
#line 639
  pci_set_power_state(dev, tmp);
  }
#line 641
  return (0);
}
}
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_suspend[16U]  = 
#line 643
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        's',      'u',      's',      'p', 
        'e',      'n',      'd',      '\000'};
#line 643
struct kernel_symbol  const  __ksymtab_ide_pci_suspend ;
#line 643 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_suspend  =    {(unsigned long )(& ide_pci_suspend), (char const   *)(& __kstrtab_ide_pci_suspend)};
#line 645 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
int ide_pci_resume(struct pci_dev *dev ) 
{ 
  struct ide_host *host ;
  void *tmp ;
  int rc ;

  {
  {
#line 647
  tmp = pci_get_drvdata(dev);
#line 647
  host = (struct ide_host *)tmp;
#line 650
  pci_set_power_state(dev, 0);
#line 652
  rc = pci_enable_device(dev);
  }
#line 653
  if (rc != 0) {
#line 654
    return (rc);
  } else {

  }
  {
#line 656
  pci_restore_state(dev);
#line 657
  pci_set_master(dev);
  }
#line 659
  if ((unsigned long )host->init_chipset != (unsigned long )((int (*)(struct pci_dev * ))0)) {
    {
#line 660
    (*(host->init_chipset))(dev);
    }
  } else {

  }
#line 662
  return (0);
}
}
#line 664 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
static char const   __kstrtab_ide_pci_resume[15U]  = 
#line 664
  {      'i',      'd',      'e',      '_', 
        'p',      'c',      'i',      '_', 
        'r',      'e',      's',      'u', 
        'm',      'e',      '\000'};
#line 664
struct kernel_symbol  const  __ksymtab_ide_pci_resume ;
#line 664 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/setup-pci.c"
struct kernel_symbol  const  __ksymtab_ide_pci_resume  =    {(unsigned long )(& ide_pci_resume), (char const   *)(& __kstrtab_ide_pci_resume)};
#line 218 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/scatterlist.h"
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
  {
#line 220
  tmp = sg_page(sg);
#line 220
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
  }
#line 220
  return (tmp___0 + (unsigned long )sg->offset);
}
}
#line 69 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-mapping.h"
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
#line 71
  return ((unsigned int )dma_direction <= 2U);
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-mapping.h"
__inline static int is_device_dma_capable(struct device *dev ) 
{ 


  {
#line 78
  return ((unsigned long )dev->dma_mask != (unsigned long )((u64 *)0ULL) && *(dev->dma_mask) != 0ULL);
}
}
#line 131 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kmemcheck.h"
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
#line 133
  return;
}
}
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dma-debug.h"
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
#line 50
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
#line 53
extern void debug_dma_alloc_coherent(struct device * , size_t  , dma_addr_t  , void * ) ;
#line 56
extern void debug_dma_free_coherent(struct device * , size_t  , void * , dma_addr_t  ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
extern struct device x86_dma_fallback_dev ;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
  {
#line 37
  tmp = __builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
  }
#line 37
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
#line 38
    return (dma_ops);
  } else {
#line 40
    return (dev->archdata.dma_ops);
  }
}
}
#line 42 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 46
  tmp = get_dma_ops(dev);
#line 46
  ops = tmp;
#line 50
  i = 0;
#line 50
  s = sg;
  }
#line 50
  goto ldv_26081;
  ldv_26080: 
  {
#line 51
  tmp___0 = sg_virt(s);
#line 51
  kmemcheck_mark_initialized(tmp___0, s->length);
#line 50
  i = i + 1;
#line 50
  s = sg_next(s);
  }
  ldv_26081: ;
#line 50
  if (i < nents) {
#line 52
    goto ldv_26080;
  } else {

  }
  {
#line 52
  tmp___1 = valid_dma_direction((int )dir);
#line 52
  tmp___2 = __builtin_expect(tmp___1 == 0, 0L);
  }
#line 52
  if (tmp___2 != 0L) {
    {
#line 52
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (52), "i" (12UL));
#line 52
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 53
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
#line 54
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
  }
#line 56
  return (ents);
}
}
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/asm-generic/dma-mapping-common.h"
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 63
  tmp = get_dma_ops(dev);
#line 63
  ops = tmp;
#line 65
  tmp___0 = valid_dma_direction((int )dir);
#line 65
  tmp___1 = __builtin_expect(tmp___0 == 0, 0L);
  }
#line 65
  if (tmp___1 != 0L) {
    {
#line 65
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (65), "i" (12UL));
#line 65
    __builtin_unreachable();
    }
  } else {

  }
  {
#line 66
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
  }
#line 67
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
    {
#line 68
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
    }
  } else {

  }
#line 69
  return;
}
}
#line 103 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static unsigned long dma_alloc_coherent_mask(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;

  {
#line 106
  dma_mask = 0UL;
#line 108
  dma_mask = (unsigned long )dev->coherent_dma_mask;
#line 109
  if (dma_mask == 0UL) {
#line 110
    dma_mask = (int )gfp & 1 ? 16777215UL : 4294967295UL;
  } else {

  }
#line 112
  return (dma_mask);
}
}
#line 115 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static gfp_t dma_alloc_coherent_gfp_flags(struct device *dev , gfp_t gfp ) 
{ 
  unsigned long dma_mask ;
  unsigned long tmp ;

  {
  {
#line 117
  tmp = dma_alloc_coherent_mask(dev, gfp);
#line 117
  dma_mask = tmp;
  }
#line 119
  if ((unsigned long long )dma_mask <= 16777215ULL) {
#line 120
    gfp = gfp | 1U;
  } else {

  }
#line 122
  if ((unsigned long long )dma_mask <= 4294967295ULL && (gfp & 1U) == 0U) {
#line 123
    gfp = gfp | 4U;
  } else {

  }
#line 125
  return (gfp);
}
}
#line 131 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static void *dma_alloc_attrs(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                      gfp_t gfp , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  void *memory ;
  int tmp___0 ;
  gfp_t tmp___1 ;

  {
  {
#line 134
  tmp = get_dma_ops(dev);
#line 134
  ops = tmp;
#line 137
  gfp = gfp & 4294967288U;
  }
#line 142
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 143
    dev = & x86_dma_fallback_dev;
  } else {

  }
  {
#line 145
  tmp___0 = is_device_dma_capable(dev);
  }
#line 145
  if (tmp___0 == 0) {
#line 146
    return ((void *)0);
  } else {

  }
#line 148
  if ((unsigned long )ops->alloc == (unsigned long )((void *(*)(struct device * ,
                                                                size_t  , dma_addr_t * ,
                                                                gfp_t  , struct dma_attrs * ))0)) {
#line 149
    return ((void *)0);
  } else {

  }
  {
#line 151
  tmp___1 = dma_alloc_coherent_gfp_flags(dev, gfp);
#line 151
  memory = (*(ops->alloc))(dev, size, dma_handle, tmp___1, attrs);
#line 153
  debug_dma_alloc_coherent(dev, size, *dma_handle, memory);
  }
#line 155
  return (memory);
}
}
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/dma-mapping.h"
__inline static void dma_free_attrs(struct device *dev , size_t size , void *vaddr ,
                                    dma_addr_t bus , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int __ret_warn_on ;
  unsigned long _flags ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 164
  tmp = get_dma_ops(dev);
#line 164
  ops = tmp;
#line 166
  _flags = arch_local_save_flags();
#line 166
  tmp___0 = arch_irqs_disabled_flags(_flags);
#line 166
  __ret_warn_on = tmp___0 != 0;
#line 166
  tmp___1 = __builtin_expect(__ret_warn_on != 0, 0L);
  }
#line 166
  if (tmp___1 != 0L) {
    {
#line 166
    warn_slowpath_null("./arch/x86/include/asm/dma-mapping.h", 166);
    }
  } else {

  }
  {
#line 166
  __builtin_expect(__ret_warn_on != 0, 0L);
#line 171
  debug_dma_free_coherent(dev, size, vaddr, bus);
  }
#line 172
  if ((unsigned long )ops->free != (unsigned long )((void (*)(struct device * , size_t  ,
                                                              void * , dma_addr_t  ,
                                                              struct dma_attrs * ))0)) {
    {
#line 173
    (*(ops->free))(dev, size, vaddr, bus, attrs);
    }
  } else {

  }
#line 174
  return;
}
}
#line 1344 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
int ide_dma_good_drive(ide_drive_t *drive ) ;
#line 1345
int __ide_dma_bad_drive(ide_drive_t *drive ) ;
#line 1349 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
__inline static u8 ide_max_dma_mode(ide_drive_t *drive ) 
{ 
  u8 tmp ;

  {
  {
#line 1351
  tmp = ide_find_dma_mode(drive, 70);
  }
#line 1351
  return (tmp);
}
}
#line 1368
int config_drive_for_dma(ide_drive_t *drive ) ;
#line 1382
void ide_dma_lost_irq(ide_drive_t *drive ) ;
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static struct drive_list_entry  const  drive_whitelist[5U]  = {      {"Micropolis 2112A", (char const   *)0}, 
        {"CONNER CTMA 4000", (char const   *)0}, 
        {"CONNER CTT8000-A", (char const   *)0}, 
        {"ST34342A", (char const   *)0}, 
        {(char const   *)0, (char const   *)0}};
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static struct drive_list_entry  const  drive_blacklist[32U]  = 
#line 47
  {      {"WDC AC11000H", (char const   *)0}, 
        {"WDC AC22100H", (char const   *)0}, 
        {"WDC AC32500H", (char const   *)0}, 
        {"WDC AC33100H", (char const   *)0}, 
        {"WDC AC31600H", (char const   *)0}, 
        {"WDC AC32100H", "24.09P07"}, 
        {"WDC AC23200L", "21.10N21"}, 
        {"Compaq CRD-8241B", (char const   *)0}, 
        {"CRD-8400B", (char const   *)0}, 
        {"CRD-8480B", (char const   *)0}, 
        {"CRD-8482B", (char const   *)0}, 
        {"CRD-84", (char const   *)0}, 
        {"SanDisk SDP3B", (char const   *)0}, 
        {"SanDisk SDP3B-64", (char const   *)0}, 
        {"SANYO CD-ROM CRD", (char const   *)0}, 
        {"HITACHI CDR-8", (char const   *)0}, 
        {"HITACHI CDR-8335", (char const   *)0}, 
        {"HITACHI CDR-8435", (char const   *)0}, 
        {"Toshiba CD-ROM XM-6202B", (char const   *)0}, 
        {"TOSHIBA CD-ROM XM-1702BC", (char const   *)0}, 
        {"CD-532E-A", (char const   *)0}, 
        {"E-IDE CD-ROM CR-840", (char const   *)0}, 
        {"CD-ROM Drive/F5A", (char const   *)0}, 
        {"WPI CDD-820", (char const   *)0}, 
        {"SAMSUNG CD-ROM SC-148C", (char const   *)0}, 
        {"SAMSUNG CD-ROM SC", (char const   *)0}, 
        {"ATAPI CD-ROM DRIVE 40X MAXIMUM", (char const   *)0}, 
        {"_NEC DV5800A", (char const   *)0}, 
        {"SAMSUNG CD-ROM SN-124", "N001"}, 
        {"Seagate STT20000A", (char const   *)0}, 
        {"CD-ROM CDR_U200", "1.09"}, 
        {(char const   *)0, (char const   *)0}};
#line 91 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
ide_startstop_t ide_dma_intr(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_cmd *cmd ;
  u8 stat ;
  u8 dma_stat ;
  int tmp ;
  unsigned int tmp___0 ;
  ide_startstop_t tmp___1 ;

  {
  {
#line 93
  hwif = drive->hwif;
#line 94
  cmd = & hwif->cmd;
#line 95
  stat = 0U;
#line 95
  dma_stat = 0U;
#line 97
  drive->waiting_for_dma = 0U;
#line 98
  tmp = (*((hwif->dma_ops)->dma_end))(drive);
#line 98
  dma_stat = (u8 )tmp;
#line 99
  ide_dma_unmap_sg(drive, cmd);
#line 100
  stat = (*((hwif->tp_ops)->read_status))(hwif);
  }
#line 102
  if (((unsigned int )stat & ((unsigned int )drive->bad_wstat | 88U)) == 80U) {
#line 103
    if ((unsigned int )dma_stat == 0U) {
#line 104
      if (((int )cmd->tf_flags & 64) == 0) {
        {
#line 105
        ide_finish_cmd(drive, cmd, (int )stat);
        }
      } else {
        {
#line 107
        tmp___0 = blk_rq_sectors((struct request  const  *)cmd->rq);
#line 107
        ide_complete_rq(drive, 0, tmp___0 << 9);
        }
      }
#line 109
      return (0);
    } else {

    }
    {
#line 111
    printk("\v%s: %s: bad DMA status (0x%02x)\n", (char *)(& drive->name), "ide_dma_intr",
           (int )dma_stat);
    }
  } else {

  }
  {
#line 114
  tmp___1 = ide_error(drive, "dma_intr", (int )stat);
  }
#line 114
  return (tmp___1);
}
}
#line 117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
int ide_dma_good_drive(ide_drive_t *drive ) 
{ 
  int tmp ;

  {
  {
#line 119
  tmp = ide_in_drive_list(drive->id, (struct drive_list_entry  const  *)(& drive_whitelist));
  }
#line 119
  return (tmp);
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static int ide_dma_map_sg(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  ide_hwif_t *hwif ;
  struct scatterlist *sg ;
  int i ;

  {
#line 135
  hwif = drive->hwif;
#line 136
  sg = hwif->sg_table;
#line 139
  if (((int )cmd->tf_flags & 2) != 0) {
#line 140
    cmd->sg_dma_direction = 1;
  } else {
#line 142
    cmd->sg_dma_direction = 2;
  }
  {
#line 144
  i = dma_map_sg_attrs(hwif->dev, sg, cmd->sg_nents, (enum dma_data_direction )cmd->sg_dma_direction,
                       (struct dma_attrs *)0);
  }
#line 145
  if (i != 0) {
#line 146
    cmd->orig_sg_nents = cmd->sg_nents;
#line 147
    cmd->sg_nents = i;
  } else {

  }
#line 150
  return (i);
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
void ide_dma_unmap_sg(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  ide_hwif_t *hwif ;

  {
  {
#line 166
  hwif = drive->hwif;
#line 168
  dma_unmap_sg_attrs(hwif->dev, hwif->sg_table, cmd->orig_sg_nents, (enum dma_data_direction )cmd->sg_dma_direction,
                     (struct dma_attrs *)0);
  }
#line 169
  return;
}
}
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static char const   __kstrtab_ide_dma_unmap_sg[17U]  = 
#line 171
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        'u',      'n',      'm',      'a', 
        'p',      '_',      's',      'g', 
        '\000'};
#line 171
struct kernel_symbol  const  __ksymtab_ide_dma_unmap_sg ;
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
struct kernel_symbol  const  __ksymtab_ide_dma_unmap_sg  =    {(unsigned long )(& ide_dma_unmap_sg), (char const   *)(& __kstrtab_ide_dma_unmap_sg)};
#line 180 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
void ide_dma_off_quietly(ide_drive_t *drive ) 
{ 


  {
  {
#line 182
  drive->dev_flags = drive->dev_flags & 0xfffffffffffffffdUL;
#line 183
  ide_toggle_bounce(drive, 0);
#line 185
  (*(((drive->hwif)->dma_ops)->dma_host_set))(drive, 0);
  }
#line 186
  return;
}
}
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static char const   __kstrtab_ide_dma_off_quietly[20U]  = 
#line 187
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        'o',      'f',      'f',      '_', 
        'q',      'u',      'i',      'e', 
        't',      'l',      'y',      '\000'};
#line 187
struct kernel_symbol  const  __ksymtab_ide_dma_off_quietly ;
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
struct kernel_symbol  const  __ksymtab_ide_dma_off_quietly  =    {(unsigned long )(& ide_dma_off_quietly), (char const   *)(& __kstrtab_ide_dma_off_quietly)};
#line 197 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
void ide_dma_off(ide_drive_t *drive ) 
{ 


  {
  {
#line 199
  printk("\016%s: DMA disabled\n", (char *)(& drive->name));
#line 200
  ide_dma_off_quietly(drive);
  }
#line 201
  return;
}
}
#line 202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static char const   __kstrtab_ide_dma_off[12U]  = 
#line 202
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        'o',      'f',      'f',      '\000'};
#line 202
struct kernel_symbol  const  __ksymtab_ide_dma_off ;
#line 202 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
struct kernel_symbol  const  __ksymtab_ide_dma_off  =    {(unsigned long )(& ide_dma_off), (char const   *)(& __kstrtab_ide_dma_off)};
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
void ide_dma_on(ide_drive_t *drive ) 
{ 


  {
  {
#line 213
  drive->dev_flags = drive->dev_flags | 2UL;
#line 214
  ide_toggle_bounce(drive, 1);
#line 216
  (*(((drive->hwif)->dma_ops)->dma_host_set))(drive, 1);
  }
#line 217
  return;
}
}
#line 219 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
int __ide_dma_bad_drive(ide_drive_t *drive ) 
{ 
  u16 *id ;
  int blacklist ;
  int tmp ;

  {
  {
#line 221
  id = drive->id;
#line 223
  tmp = ide_in_drive_list(id, (struct drive_list_entry  const  *)(& drive_blacklist));
#line 223
  blacklist = tmp;
  }
#line 224
  if (blacklist != 0) {
    {
#line 225
    printk("\f%s: Disabling (U)DMA for %s (blacklisted)\n", (char *)(& drive->name),
           (char *)id + 27U);
    }
#line 227
    return (blacklist);
  } else {

  }
#line 229
  return (0);
}
}
#line 231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static char const   __kstrtab___ide_dma_bad_drive[20U]  = 
#line 231
  {      '_',      '_',      'i',      'd', 
        'e',      '_',      'd',      'm', 
        'a',      '_',      'b',      'a', 
        'd',      '_',      'd',      'r', 
        'i',      'v',      'e',      '\000'};
#line 231
struct kernel_symbol  const  __ksymtab___ide_dma_bad_drive ;
#line 231 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
struct kernel_symbol  const  __ksymtab___ide_dma_bad_drive  =    {(unsigned long )(& __ide_dma_bad_drive), (char const   *)(& __kstrtab___ide_dma_bad_drive)};
#line 233 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static u8 const   xfer_mode_bases[3U]  = {      64U,      32U,      16U};
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static unsigned int ide_get_mode_mask(ide_drive_t *drive , u8 base , u8 req_mode ) 
{ 
  u16 *id ;
  ide_hwif_t *hwif ;
  struct ide_port_ops  const  *port_ops ;
  unsigned int mask ;
  u8 tmp ;
  u8 tmp___0 ;
  u8 mode ;
  bool tmp___1 ;
  u8 tmp___2 ;
  u8 mode___0 ;

  {
#line 241
  id = drive->id;
#line 242
  hwif = drive->hwif;
#line 243
  port_ops = hwif->port_ops;
#line 244
  mask = 0U;
  {
#line 247
  if ((int )base == 64) {
#line 247
    goto case_64;
  } else {

  }
#line 264
  if ((int )base == 32) {
#line 264
    goto case_32;
  } else {

  }
#line 279
  if ((int )base == 16) {
#line 279
    goto case_16;
  } else {

  }
#line 293
  goto switch_default;
  case_64: /* CIL Label */ ;
#line 248
  if (((int )*(id + 53UL) & 4) == 0) {
#line 249
    goto ldv_38266;
  } else {

  }
#line 250
  mask = (unsigned int )*(id + 88UL);
#line 251
  if ((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->udma_filter != (unsigned long )((u8 (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 252
    tmp = (*(port_ops->udma_filter))(drive);
#line 252
    mask = mask & (unsigned int )tmp;
    }
  } else {
#line 254
    mask = mask & (unsigned int )hwif->ultra_mask;
  }
#line 259
  if ((unsigned int )req_mode > 66U) {
#line 260
    if ((mask & 120U) != 0U) {
      {
#line 260
      tmp___0 = eighty_ninty_three(drive);
      }
#line 260
      if ((unsigned int )tmp___0 == 0U) {
#line 261
        mask = mask & 7U;
      } else {

      }
    } else {

    }
  } else {

  }
#line 263
  goto ldv_38266;
  case_32: /* CIL Label */ 
  {
#line 265
  mask = (unsigned int )*(id + 63UL);
#line 268
  tmp___1 = ata_id_is_cfa((u16 const   *)id);
  }
#line 268
  if ((int )tmp___1 && ((int )*(id + 163UL) & 56) != 0) {
#line 269
    mode = (unsigned int )((u8 )(((int )*(id + 163UL) & 56) >> 3)) + 255U;
#line 271
    mask = mask | (unsigned int )(((2 << (int )mode) + -1) << 3);
  } else {

  }
#line 274
  if ((unsigned long )port_ops != (unsigned long )((struct ide_port_ops  const  *)0) && (unsigned long )port_ops->mdma_filter != (unsigned long )((u8 (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 275
    tmp___2 = (*(port_ops->mdma_filter))(drive);
#line 275
    mask = mask & (unsigned int )tmp___2;
    }
  } else {
#line 277
    mask = mask & (unsigned int )hwif->mwdma_mask;
  }
#line 278
  goto ldv_38266;
  case_16: /* CIL Label */ 
#line 280
  mask = (unsigned int )*(id + 62UL);
#line 281
  if ((mask & 7U) == 0U && (unsigned int )((int )*(id + 52UL) >> 8) != 0U) {
#line 282
    mode___0 = (u8 )((int )*(id + 52UL) >> 8);
#line 288
    if ((unsigned int )mode___0 <= 2U) {
#line 289
      mask = (unsigned int )((2 << (int )mode___0) + -1);
    } else {

    }
  } else {

  }
#line 291
  mask = mask & (unsigned int )hwif->swdma_mask;
#line 292
  goto ldv_38266;
  switch_default: /* CIL Label */ 
  {
#line 294
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"drivers/ide/ide-dma.c"),
                       "i" (294), "i" (12UL));
#line 294
  __builtin_unreachable();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_38266: ;
#line 298
  return (mask);
}
}
#line 313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
u8 ide_find_dma_mode(ide_drive_t *drive , u8 req_mode ) 
{ 
  ide_hwif_t *hwif ;
  unsigned int mask ;
  int x ;
  int i ;
  u8 mode ;
  int tmp ;
  int tmp___0 ;
  u8 _min1 ;
  u8 _min2 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 315
  hwif = drive->hwif;
#line 318
  mode = 0U;
#line 320
  if ((unsigned int )drive->media != 32U) {
#line 321
    if ((hwif->host_flags & 4096U) != 0U) {
#line 322
      return (0U);
    } else {

    }
  } else {

  }
#line 325
  i = 0;
#line 325
  goto ldv_38286;
  ldv_38285: ;
#line 326
  if ((int )req_mode < (int )((unsigned char )xfer_mode_bases[i])) {
#line 327
    goto ldv_38283;
  } else {

  }
  {
#line 328
  mask = ide_get_mode_mask(drive, (int )xfer_mode_bases[i], (int )req_mode);
#line 329
  tmp = fls((int )mask);
#line 329
  x = tmp + -1;
  }
#line 330
  if (x >= 0) {
#line 331
    mode = (int )((u8 )xfer_mode_bases[i]) + (int )((u8 )x);
#line 332
    goto ldv_38284;
  } else {

  }
  ldv_38283: 
#line 325
  i = i + 1;
  ldv_38286: ;
#line 325
  if ((unsigned int )i <= 2U) {
#line 327
    goto ldv_38285;
  } else {

  }
  ldv_38284: ;
#line 336
  if ((unsigned int )hwif->chipset == 11U && (unsigned int )mode == 0U) {
    {
#line 340
    tmp___0 = ide_dma_good_drive(drive);
    }
#line 340
    if (tmp___0 != 0 && (unsigned int )*(drive->id + 66UL) <= 149U) {
#line 342
      mode = 33U;
    } else {

    }
  } else {

  }
#line 345
  _min1 = mode;
#line 345
  _min2 = req_mode;
#line 345
  mode = (u8 )((int )_min1 < (int )_min2 ? _min1 : _min2);
#line 347
  if ((unsigned int )mode != 0U) {
    {
#line 347
    tmp___1 = ide_xfer_verbose((int )mode);
#line 347
    tmp___2 = tmp___1;
    }
  } else {
#line 347
    tmp___2 = "no DMA";
  }
  {
#line 347
  printk("\016%s: %s mode selected\n", (char *)(& drive->name), tmp___2);
  }
#line 350
  return (mode);
}
}
#line 353 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static int ide_tune_dma(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u8 speed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 355
  hwif = drive->hwif;
#line 358
  if (((int )*(drive->id + 49UL) & 256) == 0 || (drive->dev_flags & 65536UL) != 0UL) {
#line 360
    return (0);
  } else {

  }
  {
#line 363
  tmp = __ide_dma_bad_drive(drive);
  }
#line 363
  if (tmp != 0) {
#line 364
    return (0);
  } else {

  }
#line 366
  if ((hwif->host_flags & 1024U) != 0U) {
    {
#line 367
    tmp___0 = config_drive_for_dma(drive);
    }
#line 367
    return (tmp___0);
  } else {

  }
  {
#line 369
  speed = ide_max_dma_mode(drive);
  }
#line 371
  if ((unsigned int )speed == 0U) {
#line 372
    return (0);
  } else {

  }
  {
#line 374
  tmp___1 = ide_set_dma_mode(drive, (int )speed);
  }
#line 374
  if (tmp___1 != 0) {
#line 375
    return (0);
  } else {

  }
#line 377
  return (1);
}
}
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static int ide_dma_check(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  int tmp ;

  {
  {
#line 382
  hwif = drive->hwif;
#line 384
  tmp = ide_tune_dma(drive);
  }
#line 384
  if (tmp != 0) {
#line 385
    return (0);
  } else {

  }
#line 388
  if ((hwif->host_flags & 1024U) != 0U) {
#line 389
    return (-1);
  } else {

  }
  {
#line 391
  ide_set_max_pio(drive);
  }
#line 393
  return (-1);
}
}
#line 396 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
int ide_set_dma(ide_drive_t *drive ) 
{ 
  int rc ;

  {
  {
#line 406
  ide_dma_off_quietly(drive);
#line 408
  rc = ide_dma_check(drive);
  }
#line 409
  if (rc != 0) {
#line 410
    return (rc);
  } else {

  }
  {
#line 412
  ide_dma_on(drive);
  }
#line 414
  return (0);
}
}
#line 417 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
void ide_check_dma_crc(ide_drive_t *drive ) 
{ 
  u8 mode ;

  {
  {
#line 421
  ide_dma_off_quietly(drive);
#line 422
  drive->crc_count = 0;
#line 423
  mode = drive->current_speed;
  }
#line 428
  if ((unsigned int )mode - 65U <= 6U) {
#line 429
    mode = (u8 )((int )mode - 1);
  } else {
#line 431
    mode = 12U;
  }
  {
#line 432
  ide_set_xfer_rate(drive, (int )mode);
  }
#line 433
  if ((unsigned int )drive->current_speed > 15U) {
    {
#line 434
    ide_dma_on(drive);
    }
  } else {

  }
#line 435
  return;
}
}
#line 437 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
void ide_dma_lost_irq(ide_drive_t *drive ) 
{ 


  {
  {
#line 439
  printk("\v%s: DMA interrupt recovery\n", (char *)(& drive->name));
  }
#line 440
  return;
}
}
#line 441 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static char const   __kstrtab_ide_dma_lost_irq[17U]  = 
#line 441
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        'l',      'o',      's',      't', 
        '_',      'i',      'r',      'q', 
        '\000'};
#line 441
struct kernel_symbol  const  __ksymtab_ide_dma_lost_irq ;
#line 441 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
struct kernel_symbol  const  __ksymtab_ide_dma_lost_irq  =    {(unsigned long )(& ide_dma_lost_irq), (char const   *)(& __kstrtab_ide_dma_lost_irq)};
#line 448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
ide_startstop_t ide_dma_timeout_retry(ide_drive_t *drive , int error ) 
{ 
  ide_hwif_t *hwif ;
  struct ide_dma_ops  const  *dma_ops___0 ;
  struct ide_cmd *cmd ;
  ide_startstop_t ret ;
  u8 tmp ;
  u8 tmp___0 ;
  int tmp___1 ;

  {
#line 450
  hwif = drive->hwif;
#line 451
  dma_ops___0 = hwif->dma_ops;
#line 452
  cmd = & hwif->cmd;
#line 453
  ret = 0;
#line 459
  if (error < 0) {
    {
#line 460
    printk("\f%s: DMA timeout error\n", (char *)(& drive->name));
#line 461
    drive->waiting_for_dma = 0U;
#line 462
    (*(dma_ops___0->dma_end))(drive);
#line 463
    ide_dma_unmap_sg(drive, cmd);
#line 464
    tmp = (*((hwif->tp_ops)->read_status))(hwif);
#line 464
    ret = ide_error(drive, "dma timeout error", (int )tmp);
    }
  } else {
    {
#line 467
    printk("\f%s: DMA timeout retry\n", (char *)(& drive->name));
    }
#line 468
    if ((unsigned long )dma_ops___0->dma_clear != (unsigned long )((void (*/* const  */)(struct ide_drive_s * ))0)) {
      {
#line 469
      (*(dma_ops___0->dma_clear))(drive);
      }
    } else {

    }
    {
#line 470
    printk("\v%s: timeout waiting for DMA\n", (char *)(& drive->name));
#line 471
    tmp___1 = (*(dma_ops___0->dma_test_irq))(drive);
    }
#line 471
    if (tmp___1 == 0) {
      {
#line 472
      tmp___0 = (*((hwif->tp_ops)->read_status))(hwif);
#line 472
      ide_dump_status(drive, "DMA timeout", (int )tmp___0);
#line 474
      drive->waiting_for_dma = 0U;
#line 475
      (*(dma_ops___0->dma_end))(drive);
#line 476
      ide_dma_unmap_sg(drive, cmd);
      }
    } else {

    }
  }
  {
#line 485
  drive->dev_flags = drive->dev_flags | 16777216UL;
#line 486
  drive->retry_pio = (u8 )((int )drive->retry_pio + 1);
#line 487
  ide_dma_off_quietly(drive);
  }
#line 492
  if ((unsigned long )hwif->rq != (unsigned long )((struct request *)0)) {
#line 493
    (hwif->rq)->errors = 0;
  } else {

  }
#line 494
  return (ret);
}
}
#line 497 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
void ide_release_dma_engine(ide_hwif_t *hwif ) 
{ 
  int prd_size ;

  {
#line 499
  if ((unsigned long )hwif->dmatable_cpu != (unsigned long )((unsigned int *)0U)) {
    {
#line 500
    prd_size = hwif->prd_max_nents * hwif->prd_ent_size;
#line 502
    dma_free_attrs(hwif->dev, (size_t )prd_size, (void *)hwif->dmatable_cpu, hwif->dmatable_dma,
                   (struct dma_attrs *)0);
#line 504
    hwif->dmatable_cpu = (unsigned int *)0U;
    }
  } else {

  }
#line 506
  return;
}
}
#line 507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static char const   __kstrtab_ide_release_dma_engine[23U]  = 
#line 507
  {      'i',      'd',      'e',      '_', 
        'r',      'e',      'l',      'e', 
        'a',      's',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        'e',      'n',      'g',      'i', 
        'n',      'e',      '\000'};
#line 507
struct kernel_symbol  const  __ksymtab_ide_release_dma_engine ;
#line 507 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
struct kernel_symbol  const  __ksymtab_ide_release_dma_engine  =    {(unsigned long )(& ide_release_dma_engine), (char const   *)(& __kstrtab_ide_release_dma_engine)};
#line 509 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
int ide_allocate_dma_engine(ide_hwif_t *hwif ) 
{ 
  int prd_size ;
  void *tmp ;

  {
#line 513
  if (hwif->prd_max_nents == 0) {
#line 514
    hwif->prd_max_nents = 256;
  } else {

  }
#line 515
  if (hwif->prd_ent_size == 0) {
#line 516
    hwif->prd_ent_size = 8;
  } else {

  }
  {
#line 518
  prd_size = hwif->prd_max_nents * hwif->prd_ent_size;
#line 520
  tmp = dma_alloc_attrs(hwif->dev, (size_t )prd_size, & hwif->dmatable_dma, 32U, (struct dma_attrs *)0);
#line 520
  hwif->dmatable_cpu = (unsigned int *)tmp;
  }
#line 523
  if ((unsigned long )hwif->dmatable_cpu == (unsigned long )((unsigned int *)0U)) {
    {
#line 524
    printk("\v%s: unable to allocate PRD table\n", (char *)(& hwif->name));
    }
#line 526
    return (-12);
  } else {

  }
#line 529
  return (0);
}
}
#line 531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
static char const   __kstrtab_ide_allocate_dma_engine[24U]  = 
#line 531
  {      'i',      'd',      'e',      '_', 
        'a',      'l',      'l',      'o', 
        'c',      'a',      't',      'e', 
        '_',      'd',      'm',      'a', 
        '_',      'e',      'n',      'g', 
        'i',      'n',      'e',      '\000'};
#line 531
struct kernel_symbol  const  __ksymtab_ide_allocate_dma_engine ;
#line 531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
struct kernel_symbol  const  __ksymtab_ide_allocate_dma_engine  =    {(unsigned long )(& ide_allocate_dma_engine), (char const   *)(& __kstrtab_ide_allocate_dma_engine)};
#line 533 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma.c"
int ide_dma_prepare(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  struct ide_dma_ops  const  *dma_ops___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 535
  dma_ops___0 = (drive->hwif)->dma_ops;
#line 537
  if ((drive->dev_flags & 2UL) == 0UL) {
#line 539
    goto out;
  } else
#line 537
  if ((unsigned long )dma_ops___0->dma_check != (unsigned long )((int (*/* const  */)(struct ide_drive_s * ,
                                                                                      struct ide_cmd * ))0)) {
    {
#line 537
    tmp = (*(dma_ops___0->dma_check))(drive, cmd);
    }
#line 537
    if (tmp != 0) {
#line 539
      goto out;
    } else {

    }
  } else {

  }
  {
#line 540
  ide_map_sg(drive, cmd);
#line 541
  tmp___0 = ide_dma_map_sg(drive, cmd);
  }
#line 541
  if (tmp___0 == 0) {
#line 542
    goto out_map;
  } else {

  }
  {
#line 543
  tmp___1 = (*(dma_ops___0->dma_setup))(drive, cmd);
  }
#line 543
  if (tmp___1 != 0) {
#line 544
    goto out_dma_unmap;
  } else {

  }
#line 545
  drive->waiting_for_dma = 1U;
#line 546
  return (0);
  out_dma_unmap: 
  {
#line 548
  ide_dma_unmap_sg(drive, cmd);
  }
  out_map: 
  {
#line 550
  ide_map_sg(drive, cmd);
  }
  out: ;
#line 552
  return (1);
}
}
#line 315 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/arch/x86/include/asm/io.h"
__inline static void outl(unsigned int value , int port ) 
{ 


  {
#line 315
  __asm__  volatile   ("outl %0, %w1": : "a" (value), "Nd" (port));
#line 316
  return;
}
}
#line 1369 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
int ide_build_dmatable(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 1370
void ide_dma_host_set(ide_drive_t *drive , int on ) ;
#line 1371
int ide_dma_setup(ide_drive_t *drive , struct ide_cmd *cmd ) ;
#line 1372
void ide_dma_start(ide_drive_t *drive ) ;
#line 1373
int ide_dma_end(ide_drive_t *drive ) ;
#line 1374
int ide_dma_test_irq(ide_drive_t *drive ) ;
#line 1375
int ide_dma_sff_timer_expiry(ide_drive_t *drive ) ;
#line 1376
u8 ide_dma_sff_read_status(ide_hwif_t *hwif ) ;
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
int config_drive_for_dma(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u16 *id ;
  int tmp ;

  {
#line 22
  hwif = drive->hwif;
#line 23
  id = drive->id;
#line 25
  if ((unsigned int )drive->media != 32U) {
#line 26
    if ((hwif->host_flags & 4096U) != 0U) {
#line 27
      return (0);
    } else {

    }
  } else {

  }
#line 34
  if (((int )*(id + 53UL) & 4) != 0 && (((int )*(id + 88UL) >> 8) & 127) != 0) {
#line 36
    return (1);
  } else {

  }
#line 42
  if (((int )*(id + 63UL) & 1028) == 1028 || ((int )*(id + 62UL) & 1028) == 1028) {
#line 44
    return (1);
  } else {

  }
  {
#line 47
  tmp = ide_dma_good_drive(drive);
  }
#line 47
  if (tmp != 0) {
#line 48
    return (1);
  } else {

  }
#line 50
  return (0);
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
u8 ide_dma_sff_read_status(ide_hwif_t *hwif ) 
{ 
  unsigned long addr ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
#line 55
  addr = hwif->dma_base + 2UL;
#line 57
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 58
    tmp = readb((void const volatile   *)addr);
    }
#line 58
    return (tmp);
  } else {
    {
#line 60
    tmp___0 = inb((int )addr);
    }
#line 60
    return (tmp___0);
  }
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_ide_dma_sff_read_status[24U]  = 
#line 62
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        's',      'f',      'f',      '_', 
        'r',      'e',      'a',      'd', 
        '_',      's',      't',      'a', 
        't',      'u',      's',      '\000'};
#line 62
struct kernel_symbol  const  __ksymtab_ide_dma_sff_read_status ;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_ide_dma_sff_read_status  =    {(unsigned long )(& ide_dma_sff_read_status), (char const   *)(& __kstrtab_ide_dma_sff_read_status)};
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static void ide_dma_sff_write_status(ide_hwif_t *hwif , u8 val ) 
{ 
  unsigned long addr ;

  {
#line 66
  addr = hwif->dma_base + 2UL;
#line 68
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 69
    writeb((int )val, (void volatile   *)addr);
    }
  } else {
    {
#line 71
    outb((int )val, (int )addr);
    }
  }
#line 72
  return;
}
}
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
void ide_dma_host_set(ide_drive_t *drive , int on ) 
{ 
  ide_hwif_t *hwif ;
  u8 unit ;
  u8 dma_stat ;
  u8 tmp ;

  {
  {
#line 84
  hwif = drive->hwif;
#line 85
  unit = (unsigned int )drive->dn & 1U;
#line 86
  tmp = (*((hwif->dma_ops)->dma_sff_read_status))(hwif);
#line 86
  dma_stat = tmp;
  }
#line 88
  if (on != 0) {
#line 89
    dma_stat = (u8 )((int )((signed char )dma_stat) | (int )((signed char )(1 << ((int )unit + 5))));
  } else {
#line 91
    dma_stat = (u8 )((int )((signed char )dma_stat) & ~ ((int )((signed char )(1 << ((int )unit + 5)))));
  }
  {
#line 93
  ide_dma_sff_write_status(hwif, (int )dma_stat);
  }
#line 94
  return;
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_ide_dma_host_set[17U]  = 
#line 95
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        'h',      'o',      's',      't', 
        '_',      's',      'e',      't', 
        '\000'};
#line 95
struct kernel_symbol  const  __ksymtab_ide_dma_host_set ;
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_ide_dma_host_set  =    {(unsigned long )(& ide_dma_host_set), (char const   *)(& __kstrtab_ide_dma_host_set)};
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
int ide_build_dmatable(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  ide_hwif_t *hwif ;
  __le32 *table ;
  unsigned int count ;
  int i ;
  struct scatterlist *sg ;
  u8 is_trm290 ;
  u32 cur_addr ;
  u32 cur_len ;
  u32 xcount ;
  u32 bcount ;
  unsigned int tmp ;
  __le32 *tmp___0 ;
  unsigned int tmp___1 ;
  __le32 *tmp___2 ;
  __le32 *tmp___3 ;
  __le32 *tmp___4 ;

  {
#line 116
  hwif = drive->hwif;
#line 117
  table = hwif->dmatable_cpu;
#line 118
  count = 0U;
#line 121
  is_trm290 = (hwif->host_flags & 8388608U) != 0U;
#line 123
  i = 0;
#line 123
  sg = hwif->sg_table;
#line 123
  goto ldv_38242;
  ldv_38241: 
#line 126
  cur_addr = (u32 )sg->dma_address;
#line 127
  cur_len = sg->dma_length;
#line 135
  goto ldv_38239;
  ldv_38238: 
#line 136
  tmp = count;
#line 136
  count = count + 1U;
#line 136
  if (tmp > 255U) {
#line 137
    goto use_pio_instead;
  } else {

  }
#line 139
  bcount = 65536U - (cur_addr & 65535U);
#line 140
  if (bcount > cur_len) {
#line 141
    bcount = cur_len;
  } else {

  }
#line 142
  tmp___0 = table;
#line 142
  table = table + 1;
#line 142
  *tmp___0 = cur_addr;
#line 143
  xcount = bcount & 65535U;
#line 144
  if ((unsigned int )is_trm290 != 0U) {
#line 145
    xcount = ((xcount >> 2) - 1U) << 16;
  } else
#line 146
  if (xcount == 0U) {
#line 147
    tmp___1 = count;
#line 147
    count = count + 1U;
#line 147
    if (tmp___1 > 255U) {
#line 148
      goto use_pio_instead;
    } else {

    }
#line 149
    tmp___2 = table;
#line 149
    table = table + 1;
#line 149
    *tmp___2 = 32768U;
#line 150
    tmp___3 = table;
#line 150
    table = table + 1;
#line 150
    *tmp___3 = cur_addr + 32768U;
#line 151
    xcount = 32768U;
  } else {

  }
#line 153
  tmp___4 = table;
#line 153
  table = table + 1;
#line 153
  *tmp___4 = xcount;
#line 154
  cur_addr = cur_addr + bcount;
#line 155
  cur_len = cur_len - bcount;
  ldv_38239: ;
#line 135
  if (cur_len != 0U) {
#line 137
    goto ldv_38238;
  } else {

  }
  {
#line 123
  i = i + 1;
#line 123
  sg = sg_next(sg);
  }
  ldv_38242: ;
#line 123
  if (i < cmd->sg_nents) {
#line 125
    goto ldv_38241;
  } else {

  }

#line 159
  if (count != 0U) {
#line 160
    if ((unsigned int )is_trm290 == 0U) {
#line 161
      table = table - 1;
#line 161
      *table = *table | 2147483648U;
    } else {

    }
#line 162
    return ((int )count);
  } else {

  }
  use_pio_instead: 
  {
#line 166
  printk("\v%s: %s\n", (char *)(& drive->name), count != 0U ? (char *)"DMA table too small" : (char *)"empty DMA table?");
  }
#line 169
  return (0);
}
}
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_ide_build_dmatable[19U]  = 
#line 171
  {      'i',      'd',      'e',      '_', 
        'b',      'u',      'i',      'l', 
        'd',      '_',      'd',      'm', 
        'a',      't',      'a',      'b', 
        'l',      'e',      '\000'};
#line 171
struct kernel_symbol  const  __ksymtab_ide_build_dmatable ;
#line 171 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_ide_build_dmatable  =    {(unsigned long )(& ide_build_dmatable), (char const   *)(& __kstrtab_ide_build_dmatable)};
#line 187 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
int ide_dma_setup(ide_drive_t *drive , struct ide_cmd *cmd ) 
{ 
  ide_hwif_t *hwif ;
  u8 mmio ;
  u8 rw ;
  u8 dma_stat ;
  int tmp ;

  {
  {
#line 189
  hwif = drive->hwif;
#line 190
  mmio = (hwif->host_flags & 65536U) != 0U;
#line 191
  rw = ((int )cmd->tf_flags & 2) != 0 ? 0U : 8U;
#line 195
  tmp = ide_build_dmatable(drive, cmd);
  }
#line 195
  if (tmp == 0) {
    {
#line 196
    ide_map_sg(drive, cmd);
    }
#line 197
    return (1);
  } else {

  }
#line 201
  if ((unsigned int )mmio != 0U) {
    {
#line 202
    writel((unsigned int )hwif->dmatable_dma, (void volatile   *)(hwif->dma_base + 4UL));
    }
  } else {
    {
#line 205
    outl((unsigned int )hwif->dmatable_dma, (int )((unsigned int )hwif->dma_base + 4U));
    }
  }
#line 208
  if ((unsigned int )mmio != 0U) {
    {
#line 209
    writeb((int )rw, (void volatile   *)hwif->dma_base);
    }
  } else {
    {
#line 211
    outb((int )rw, (int )hwif->dma_base);
    }
  }
  {
#line 214
  dma_stat = (*((hwif->dma_ops)->dma_sff_read_status))(hwif);
#line 217
  ide_dma_sff_write_status(hwif, (int )((unsigned int )dma_stat | 6U));
  }
#line 219
  return (0);
}
}
#line 221 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_ide_dma_setup[14U]  = 
#line 221
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        's',      'e',      't',      'u', 
        'p',      '\000'};
#line 221
struct kernel_symbol  const  __ksymtab_ide_dma_setup ;
#line 221 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_ide_dma_setup  =    {(unsigned long )(& ide_dma_setup), (char const   *)(& __kstrtab_ide_dma_setup)};
#line 237 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
int ide_dma_sff_timer_expiry(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u8 dma_stat ;
  u8 tmp ;

  {
  {
#line 239
  hwif = drive->hwif;
#line 240
  tmp = (*((hwif->dma_ops)->dma_sff_read_status))(hwif);
#line 240
  dma_stat = tmp;
#line 242
  printk("\f%s: %s: DMA status (0x%02x)\n", (char *)(& drive->name), "ide_dma_sff_timer_expiry",
         (int )dma_stat);
  }
#line 245
  if (((int )dma_stat & 24) == 24) {
#line 246
    return (2500);
  } else {

  }
#line 248
  hwif->expiry = (int (*)(ide_drive_t * ))0;
#line 250
  if (((int )dma_stat & 2) != 0) {
#line 251
    return (-1);
  } else {

  }
#line 253
  if ((int )dma_stat & 1) {
#line 254
    return (2500);
  } else {

  }
#line 256
  if (((int )dma_stat & 4) != 0) {
#line 257
    return (2500);
  } else {

  }
#line 259
  return (0);
}
}
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_ide_dma_sff_timer_expiry[25U]  = 
#line 261
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        's',      'f',      'f',      '_', 
        't',      'i',      'm',      'e', 
        'r',      '_',      'e',      'x', 
        'p',      'i',      'r',      'y', 
        '\000'};
#line 261
struct kernel_symbol  const  __ksymtab_ide_dma_sff_timer_expiry ;
#line 261 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_ide_dma_sff_timer_expiry  =    {(unsigned long )(& ide_dma_sff_timer_expiry), (char const   *)(& __kstrtab_ide_dma_sff_timer_expiry)};
#line 263 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
void ide_dma_start(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u8 dma_cmd ;

  {
#line 265
  hwif = drive->hwif;
#line 273
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 274
    dma_cmd = readb((void const volatile   *)hwif->dma_base);
#line 275
    writeb((int )((unsigned int )dma_cmd | 1U), (void volatile   *)hwif->dma_base);
    }
  } else {
    {
#line 278
    dma_cmd = inb((int )hwif->dma_base);
#line 279
    outb((int )((unsigned int )dma_cmd | 1U), (int )hwif->dma_base);
    }
  }
#line 281
  return;
}
}
#line 282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_ide_dma_start[14U]  = 
#line 282
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        's',      't',      'a',      'r', 
        't',      '\000'};
#line 282
struct kernel_symbol  const  __ksymtab_ide_dma_start ;
#line 282 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_ide_dma_start  =    {(unsigned long )(& ide_dma_start), (char const   *)(& __kstrtab_ide_dma_start)};
#line 285 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
int ide_dma_end(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u8 dma_stat ;
  u8 dma_cmd ;

  {
#line 287
  hwif = drive->hwif;
#line 288
  dma_stat = 0U;
#line 288
  dma_cmd = 0U;
#line 291
  if ((hwif->host_flags & 65536U) != 0U) {
    {
#line 292
    dma_cmd = readb((void const volatile   *)hwif->dma_base);
#line 293
    writeb((int )dma_cmd & 254, (void volatile   *)hwif->dma_base);
    }
  } else {
    {
#line 296
    dma_cmd = inb((int )hwif->dma_base);
#line 297
    outb((int )dma_cmd & 254, (int )hwif->dma_base);
    }
  }
  {
#line 301
  dma_stat = (*((hwif->dma_ops)->dma_sff_read_status))(hwif);
#line 304
  ide_dma_sff_write_status(hwif, (int )((unsigned int )dma_stat | 6U));
  }
#line 309
  if (((int )dma_stat & 7) != 4) {
#line 310
    return ((int )((unsigned int )dma_stat | 16U));
  } else {

  }
#line 311
  return (0);
}
}
#line 313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_ide_dma_end[12U]  = 
#line 313
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        'e',      'n',      'd',      '\000'};
#line 313
struct kernel_symbol  const  __ksymtab_ide_dma_end ;
#line 313 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_ide_dma_end  =    {(unsigned long )(& ide_dma_end), (char const   *)(& __kstrtab_ide_dma_end)};
#line 316 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
int ide_dma_test_irq(ide_drive_t *drive ) 
{ 
  ide_hwif_t *hwif ;
  u8 dma_stat ;
  u8 tmp ;

  {
  {
#line 318
  hwif = drive->hwif;
#line 319
  tmp = (*((hwif->dma_ops)->dma_sff_read_status))(hwif);
#line 319
  dma_stat = tmp;
  }
#line 321
  return (((int )dma_stat & 4) != 0);
}
}
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_ide_dma_test_irq[17U]  = 
#line 323
  {      'i',      'd',      'e',      '_', 
        'd',      'm',      'a',      '_', 
        't',      'e',      's',      't', 
        '_',      'i',      'r',      'q', 
        '\000'};
#line 323
struct kernel_symbol  const  __ksymtab_ide_dma_test_irq ;
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_ide_dma_test_irq  =    {(unsigned long )(& ide_dma_test_irq), (char const   *)(& __kstrtab_ide_dma_test_irq)};
#line 325 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct ide_dma_ops  const  sff_dma_ops  = 
#line 325
     {& ide_dma_host_set, & ide_dma_setup, & ide_dma_start, & ide_dma_end, & ide_dma_test_irq,
    & ide_dma_lost_irq, 0, & ide_dma_sff_timer_expiry, 0, & ide_dma_sff_read_status};
#line 335 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
static char const   __kstrtab_sff_dma_ops[12U]  = 
#line 335
  {      's',      'f',      'f',      '_', 
        'd',      'm',      'a',      '_', 
        'o',      'p',      's',      '\000'};
#line 335
struct kernel_symbol  const  __ksymtab_sff_dma_ops ;
#line 335 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-dma-sff.c"
struct kernel_symbol  const  __ksymtab_sff_dma_ops  =    {(unsigned long )(& sff_dma_ops), (char const   *)(& __kstrtab_sff_dma_ops)};
#line 702 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_24_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 703
  ide_dma_lost_irq(arg1);
  }
#line 704
  return;
}
}
#line 707 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_24_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) 
{ 


  {
  {
#line 708
  ide_dma_setup(arg1, arg2);
  }
#line 709
  return;
}
}
#line 712 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_24_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 713
  ide_dma_sff_read_status(arg1);
  }
#line 714
  return;
}
}
#line 717 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_24_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 718
  ide_dma_start(arg1);
  }
#line 719
  return;
}
}
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_24_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 723
  ide_dma_test_irq(arg1);
  }
#line 724
  return;
}
}
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_24_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 728
  ide_dma_sff_timer_expiry(arg1);
  }
#line 729
  return;
}
}
#line 732 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_24_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 733
  ide_dma_end(arg1);
  }
#line 734
  return;
}
}
#line 737 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_24_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 738
  ide_dma_host_set(arg1, arg2);
  }
#line 739
  return;
}
}
#line 742 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_25_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 743
  ide_dma_lost_irq(arg1);
  }
#line 744
  return;
}
}
#line 747 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_25_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) 
{ 


  {
  {
#line 748
  ide_dma_setup(arg1, arg2);
  }
#line 749
  return;
}
}
#line 752 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_25_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 753
  ide_dma_sff_read_status(arg1);
  }
#line 754
  return;
}
}
#line 757 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_25_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 758
  ide_dma_start(arg1);
  }
#line 759
  return;
}
}
#line 762 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_25_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 763
  ide_dma_test_irq(arg1);
  }
#line 764
  return;
}
}
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_25_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 768
  ide_dma_sff_timer_expiry(arg1);
  }
#line 769
  return;
}
}
#line 772 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_25_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 773
  ide_dma_end(arg1);
  }
#line 774
  return;
}
}
#line 777 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_25_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 778
  ide_dma_host_set(arg1, arg2);
  }
#line 779
  return;
}
}
#line 782 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_26_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 783
  ide_dma_lost_irq(arg1);
  }
#line 784
  return;
}
}
#line 787 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_26_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) 
{ 


  {
  {
#line 788
  ide_dma_setup(arg1, arg2);
  }
#line 789
  return;
}
}
#line 792 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_26_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 793
  ide_dma_sff_read_status(arg1);
  }
#line 794
  return;
}
}
#line 797 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_26_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 798
  ide_dma_start(arg1);
  }
#line 799
  return;
}
}
#line 802 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_26_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 803
  ide_dma_test_irq(arg1);
  }
#line 804
  return;
}
}
#line 807 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_26_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 808
  ide_dma_sff_timer_expiry(arg1);
  }
#line 809
  return;
}
}
#line 812 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_26_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 813
  ide_dma_end(arg1);
  }
#line 814
  return;
}
}
#line 817 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_26_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 818
  ide_dma_host_set(arg1, arg2);
  }
#line 819
  return;
}
}
#line 822 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_27_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 823
  ide_dma_lost_irq(arg1);
  }
#line 824
  return;
}
}
#line 827 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_27_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) 
{ 


  {
  {
#line 828
  ide_dma_setup(arg1, arg2);
  }
#line 829
  return;
}
}
#line 832 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_27_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 833
  ide_dma_sff_read_status(arg1);
  }
#line 834
  return;
}
}
#line 837 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_27_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 838
  ide_dma_start(arg1);
  }
#line 839
  return;
}
}
#line 842 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_27_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 843
  ide_dma_test_irq(arg1);
  }
#line 844
  return;
}
}
#line 847 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_27_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 848
  ide_dma_sff_timer_expiry(arg1);
  }
#line 849
  return;
}
}
#line 852 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_27_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 853
  ide_dma_end(arg1);
  }
#line 854
  return;
}
}
#line 857 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_27_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 858
  ide_dma_host_set(arg1, arg2);
  }
#line 859
  return;
}
}
#line 862 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_28_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 863
  ide_dma_lost_irq(arg1);
  }
#line 864
  return;
}
}
#line 867 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_28_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) 
{ 


  {
  {
#line 868
  ide_dma_setup(arg1, arg2);
  }
#line 869
  return;
}
}
#line 872 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_28_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 873
  ide_dma_sff_read_status(arg1);
  }
#line 874
  return;
}
}
#line 877 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_28_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 878
  ide_dma_start(arg1);
  }
#line 879
  return;
}
}
#line 882 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_28_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 883
  ide_dma_test_irq(arg1);
  }
#line 884
  return;
}
}
#line 887 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_28_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 888
  ide_dma_sff_timer_expiry(arg1);
  }
#line 889
  return;
}
}
#line 892 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_28_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 893
  ide_dma_end(arg1);
  }
#line 894
  return;
}
}
#line 897 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_28_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 898
  ide_dma_host_set(arg1, arg2);
  }
#line 899
  return;
}
}
#line 902 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_29_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 903
  ide_dma_lost_irq(arg1);
  }
#line 904
  return;
}
}
#line 907 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_29_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) 
{ 


  {
  {
#line 908
  ide_dma_setup(arg1, arg2);
  }
#line 909
  return;
}
}
#line 912 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_29_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 913
  ide_dma_sff_read_status(arg1);
  }
#line 914
  return;
}
}
#line 917 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_29_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 918
  ide_dma_start(arg1);
  }
#line 919
  return;
}
}
#line 922 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_29_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 923
  ide_dma_test_irq(arg1);
  }
#line 924
  return;
}
}
#line 927 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_29_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 928
  ide_dma_sff_timer_expiry(arg1);
  }
#line 929
  return;
}
}
#line 932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_29_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 933
  ide_dma_end(arg1);
  }
#line 934
  return;
}
}
#line 937 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_29_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 938
  ide_dma_host_set(arg1, arg2);
  }
#line 939
  return;
}
}
#line 942 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_30_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 943
  ide_dma_lost_irq(arg1);
  }
#line 944
  return;
}
}
#line 947 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_30_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) 
{ 


  {
  {
#line 948
  ide_dma_setup(arg1, arg2);
  }
#line 949
  return;
}
}
#line 952 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_30_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 953
  ide_dma_sff_read_status(arg1);
  }
#line 954
  return;
}
}
#line 957 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_30_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 958
  ide_dma_start(arg1);
  }
#line 959
  return;
}
}
#line 962 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_30_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 963
  ide_dma_test_irq(arg1);
  }
#line 964
  return;
}
}
#line 967 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_30_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 968
  ide_dma_sff_timer_expiry(arg1);
  }
#line 969
  return;
}
}
#line 972 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_30_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 973
  ide_dma_end(arg1);
  }
#line 974
  return;
}
}
#line 977 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_30_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 978
  ide_dma_host_set(arg1, arg2);
  }
#line 979
  return;
}
}
#line 982 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_31_10(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 983
  ide_dma_lost_irq(arg1);
  }
#line 984
  return;
}
}
#line 987 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_31_11(int (*arg0)(struct ide_drive_s * ,
                                                                struct ide_cmd * ) ,
                                                    struct ide_drive_s *arg1 , struct ide_cmd *arg2 ) 
{ 


  {
  {
#line 988
  ide_dma_setup(arg1, arg2);
  }
#line 989
  return;
}
}
#line 992 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_31_12(unsigned char (*arg0)(struct hwif_s * ) ,
                                                    struct hwif_s *arg1 ) 
{ 


  {
  {
#line 993
  ide_dma_sff_read_status(arg1);
  }
#line 994
  return;
}
}
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_31_13(void (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 998
  ide_dma_start(arg1);
  }
#line 999
  return;
}
}
#line 1002 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_31_14(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 1003
  ide_dma_test_irq(arg1);
  }
#line 1004
  return;
}
}
#line 1007 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_31_15(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 1008
  ide_dma_sff_timer_expiry(arg1);
  }
#line 1009
  return;
}
}
#line 1012 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_31_3(int (*arg0)(struct ide_drive_s * ) ,
                                                   struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 1013
  ide_dma_end(arg1);
  }
#line 1014
  return;
}
}
#line 1017 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-dma-sff.c.aux"
void ldv_dummy_resourceless_instance_callback_31_7(void (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                   int arg2 ) 
{ 


  {
  {
#line 1018
  ide_dma_host_set(arg1, arg2);
  }
#line 1019
  return;
}
}
#line 75 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_filter_err_code(int ret_val ) ;
#line 369 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_lock_96___1(struct mutex *ldv_func_arg1 ) ;
#line 373
static void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) ;
#line 377
static void ldv_mutex_lock_102___0(struct mutex *ldv_func_arg1 ) ;
#line 381
static void ldv_mutex_lock_104___0(struct mutex *ldv_func_arg1 ) ;
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/kernel.h"
extern unsigned long simple_strtoul(char const   * , char ** , unsigned int  ) ;
#line 26 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
#line 193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/mutex.h"
static void ldv_mutex_unlock_97___1(struct mutex *ldv_func_arg1 ) ;
#line 197
static void ldv_mutex_unlock_100(struct mutex *ldv_func_arg1 ) ;
#line 201
static void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) ;
#line 205
static void ldv_mutex_unlock_103___0(struct mutex *ldv_func_arg1 ) ;
#line 209
static void ldv_mutex_unlock_105___0(struct mutex *ldv_func_arg1 ) ;
#line 114 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/seq_file.h"
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
#line 115
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
#line 118
extern int seq_putc(struct seq_file * , char  ) ;
#line 119
extern int seq_puts(struct seq_file * , char const   * ) ;
#line 122
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
#line 130
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
#line 132
extern int single_release(struct inode * , struct file * ) ;
#line 361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/gfp.h"
static unsigned long ldv___get_free_pages_98(gfp_t flags , unsigned int ldv_func_arg2 ) ;
#line 377
extern void free_pages(unsigned long  , unsigned int  ) ;
#line 161 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/device.h"
extern int bus_for_each_drv(struct bus_type * , struct device_driver * , void * ,
                            int (*)(struct device_driver * , void * ) ) ;
#line 972
extern void device_release_driver(struct device * ) ;
#line 973
extern int device_attach(struct device * ) ;
#line 418 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kmalloc(size_t size , gfp_t flags ) ;
#line 1960 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/fs.h"
__inline static struct inode *file_inode(struct file  const  *f ) 
{ 


  {
#line 1962
  return ((struct inode *)f->f_inode);
}
}
#line 17 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/proc_fs.h"
extern struct proc_dir_entry *proc_symlink(char const   * , struct proc_dir_entry * ,
                                           char const   * ) ;
#line 19
extern struct proc_dir_entry *proc_mkdir(char const   * , struct proc_dir_entry * ) ;
#line 25
extern struct proc_dir_entry *proc_create_data(char const   * , umode_t  , struct proc_dir_entry * ,
                                               struct file_operations  const  * ,
                                               void * ) ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/proc_fs.h"
__inline static struct proc_dir_entry *proc_create(char const   *name , umode_t mode ,
                                                   struct proc_dir_entry *parent ,
                                                   struct file_operations  const  *proc_fops ) 
{ 
  struct proc_dir_entry *tmp ;

  {
  {
#line 34
  tmp = proc_create_data(name, (int )mode, parent, proc_fops, (void *)0);
  }
#line 34
  return (tmp);
}
}
#line 39
extern void *PDE_DATA(struct inode  const  * ) ;
#line 42
extern void remove_proc_entry(char const   * , struct proc_dir_entry * ) ;
#line 18 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ctype.h"
extern unsigned char const   _ctype[] ;
#line 929 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/ide.h"
void ide_proc_register_driver(ide_drive_t *drive , struct ide_driver *driver ) ;
#line 930
void ide_proc_unregister_driver(ide_drive_t *drive , struct ide_driver *driver ) ;
#line 932
struct file_operations  const  ide_capacity_proc_fops ;
#line 933
struct file_operations  const  ide_geometry_proc_fops ;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct proc_dir_entry *proc_ide_root  ;
#line 34 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_imodel_proc_show(struct seq_file *m , void *v ) 
{ 
  ide_hwif_t *hwif ;
  char const   *name ;

  {
#line 36
  hwif = (ide_hwif_t *)m->private;
  {
#line 40
  if ((int )hwif->chipset == 1) {
#line 40
    goto case_1;
  } else {

  }
#line 41
  if ((int )hwif->chipset == 2) {
#line 41
    goto case_2;
  } else {

  }
#line 42
  if ((int )hwif->chipset == 3) {
#line 42
    goto case_3;
  } else {

  }
#line 43
  if ((int )hwif->chipset == 4) {
#line 43
    goto case_4;
  } else {

  }
#line 44
  if ((int )hwif->chipset == 5) {
#line 44
    goto case_5;
  } else {

  }
#line 45
  if ((int )hwif->chipset == 6) {
#line 45
    goto case_6;
  } else {

  }
#line 46
  if ((int )hwif->chipset == 7) {
#line 46
    goto case_7;
  } else {

  }
#line 47
  if ((int )hwif->chipset == 8) {
#line 47
    goto case_8;
  } else {

  }
#line 48
  if ((int )hwif->chipset == 9) {
#line 48
    goto case_9;
  } else {

  }
#line 49
  if ((int )hwif->chipset == 10) {
#line 49
    goto case_10;
  } else {

  }
#line 50
  if ((int )hwif->chipset == 12) {
#line 50
    goto case_12;
  } else {

  }
#line 51
  if ((int )hwif->chipset == 13) {
#line 51
    goto case_13;
  } else {

  }
#line 52
  if ((int )hwif->chipset == 11) {
#line 52
    goto case_11;
  } else {

  }
#line 53
  goto switch_default;
  case_1: /* CIL Label */ 
#line 40
  name = "generic";
#line 40
  goto ldv_39026;
  case_2: /* CIL Label */ 
#line 41
  name = "pci";
#line 41
  goto ldv_39026;
  case_3: /* CIL Label */ 
#line 42
  name = "cmd640";
#line 42
  goto ldv_39026;
  case_4: /* CIL Label */ 
#line 43
  name = "dtc2278";
#line 43
  goto ldv_39026;
  case_5: /* CIL Label */ 
#line 44
  name = "ali14xx";
#line 44
  goto ldv_39026;
  case_6: /* CIL Label */ 
#line 45
  name = "qd65xx";
#line 45
  goto ldv_39026;
  case_7: /* CIL Label */ 
#line 46
  name = "umc8672";
#line 46
  goto ldv_39026;
  case_8: /* CIL Label */ 
#line 47
  name = "ht6560b";
#line 47
  goto ldv_39026;
  case_9: /* CIL Label */ 
#line 48
  name = "4drives";
#line 48
  goto ldv_39026;
  case_10: /* CIL Label */ 
#line 49
  name = "mac-io";
#line 49
  goto ldv_39026;
  case_12: /* CIL Label */ 
#line 50
  name = "au1xxx";
#line 50
  goto ldv_39026;
  case_13: /* CIL Label */ 
#line 51
  name = "palm3710";
#line 51
  goto ldv_39026;
  case_11: /* CIL Label */ 
#line 52
  name = "acorn";
#line 52
  goto ldv_39026;
  switch_default: /* CIL Label */ 
#line 53
  name = "(unknown)";
#line 53
  goto ldv_39026;
  switch_break: /* CIL Label */ ;
  }
  ldv_39026: 
  {
#line 55
  seq_printf(m, "%s\n", name);
  }
#line 56
  return (0);
}
}
#line 59 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_imodel_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 61
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 61
  tmp___0 = single_open(file, & ide_imodel_proc_show, tmp);
  }
#line 61
  return (tmp___0);
}
}
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_imodel_proc_fops  = 
#line 64
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_imodel_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_mate_proc_show(struct seq_file *m , void *v ) 
{ 
  ide_hwif_t *hwif ;

  {
#line 74
  hwif = (ide_hwif_t *)m->private;
#line 76
  if ((unsigned long )hwif != (unsigned long )((ide_hwif_t *)0) && (unsigned long )hwif->mate != (unsigned long )((struct hwif_s *)0)) {
    {
#line 77
    seq_printf(m, "%s\n", (char *)(& (hwif->mate)->name));
    }
  } else {
    {
#line 79
    seq_printf(m, "(none)\n");
    }
  }
#line 80
  return (0);
}
}
#line 83 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_mate_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 85
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 85
  tmp___0 = single_open(file, & ide_mate_proc_show, tmp);
  }
#line 85
  return (tmp___0);
}
}
#line 88 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_mate_proc_fops  = 
#line 88
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_mate_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 96 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_channel_proc_show(struct seq_file *m , void *v ) 
{ 
  ide_hwif_t *hwif ;

  {
  {
#line 98
  hwif = (ide_hwif_t *)m->private;
#line 100
  seq_printf(m, "%c\n", (unsigned int )hwif->channel != 0U ? 49 : 48);
  }
#line 101
  return (0);
}
}
#line 104 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_channel_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 106
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 106
  tmp___0 = single_open(file, & ide_channel_proc_show, tmp);
  }
#line 106
  return (tmp___0);
}
}
#line 109 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_channel_proc_fops  = 
#line 109
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_channel_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_identify_proc_show(struct seq_file *m , void *v ) 
{ 
  ide_drive_t *drive ;
  u8 *buf ;
  void *tmp ;
  __le16 *val ;
  int i ;
  int tmp___0 ;

  {
#line 119
  drive = (ide_drive_t *)m->private;
#line 122
  if ((unsigned long )drive == (unsigned long )((ide_drive_t *)0)) {
    {
#line 123
    seq_putc(m, 10);
    }
#line 124
    return (0);
  } else {

  }
  {
#line 127
  tmp = kmalloc(512UL, 208U);
#line 127
  buf = (u8 *)tmp;
  }
#line 128
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
#line 129
    return (-12);
  } else {

  }
  {
#line 130
  tmp___0 = taskfile_lib_get_identify(drive, buf);
  }
#line 130
  if (tmp___0 == 0) {
#line 131
    val = (__le16 *)buf;
#line 134
    i = 0;
#line 134
    goto ldv_39074;
    ldv_39073: 
    {
#line 135
    seq_printf(m, "%04x%c", (int )*(val + (unsigned long )i), i % 8 == 7 ? 10 : 32);
#line 134
    i = i + 1;
    }
    ldv_39074: ;
#line 134
    if (i <= 255) {
#line 136
      goto ldv_39073;
    } else {

    }

  } else {
    {
#line 139
    seq_putc(m, (int )((char )*buf));
    }
  }
  {
#line 140
  kfree((void const   *)buf);
  }
#line 141
  return (0);
}
}
#line 144 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_identify_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 146
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 146
  tmp___0 = single_open(file, & ide_identify_proc_show, tmp);
  }
#line 146
  return (tmp___0);
}
}
#line 149 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_identify_proc_fops  = 
#line 149
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_identify_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 168 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct ide_proc_devset  const  *ide_find_setting(struct ide_proc_devset  const  *st ,
                                                        char *name ) 
{ 
  int tmp ;

  {
#line 171
  goto ldv_39087;
  ldv_39086: 
  {
#line 172
  tmp = strcmp(st->name, (char const   *)name);
  }
#line 172
  if (tmp == 0) {
#line 173
    goto ldv_39085;
  } else {

  }
#line 174
  st = st + 1;
  ldv_39087: ;
#line 171
  if ((unsigned long )st->name != (unsigned long )((char const   */* const  */)0)) {
#line 173
    goto ldv_39086;
  } else {

  }
  ldv_39085: ;
#line 176
  return ((unsigned long )st->name != (unsigned long )((char const   */* const  */)0) ? st : (struct ide_proc_devset  const  *)0);
}
}
#line 192 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_read_setting(ide_drive_t *drive , struct ide_proc_devset  const  *setting ) 
{ 
  struct ide_devset  const  *ds ;
  int val ;

  {
#line 195
  ds = setting->setting;
#line 196
  val = -22;
#line 198
  if ((unsigned long )ds->get != (unsigned long )((int (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 199
    val = (*(ds->get))(drive);
    }
  } else {

  }
#line 201
  return (val);
}
}
#line 222 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_write_setting(ide_drive_t *drive , struct ide_proc_devset  const  *setting ,
                             int val ) 
{ 
  struct ide_devset  const  *ds ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 225
  ds = setting->setting;
#line 227
  tmp = capable(21);
  }
#line 227
  if (tmp) {
#line 227
    tmp___0 = 0;
  } else {
#line 227
    tmp___0 = 1;
  }
#line 227
  if (tmp___0) {
#line 228
    return (-13);
  } else {

  }
#line 229
  if ((unsigned long )ds->set == (unsigned long )((int (*/* const  */)(ide_drive_t * ,
                                                                       int  ))0)) {
#line 230
    return (-1);
  } else {

  }
#line 231
  if ((int )ds->flags & 1 && (val < (int )setting->min || val > (int )setting->max)) {
#line 233
    return (-22);
  } else {

  }
  {
#line 234
  tmp___1 = ide_devset_execute(drive, ds, val);
  }
#line 234
  return (tmp___1);
}
}
#line 237 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int get_xfer_rate(ide_drive_t *drive ) 
{ 


  {
#line 237
  return ((int )drive->current_speed);
}
}
#line 239 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int set_xfer_rate(ide_drive_t *drive , int arg ) 
{ 
  struct ide_cmd cmd ;
  int tmp ;

  {
#line 243
  if ((unsigned int )arg - 8U > 62U) {
#line 244
    return (-22);
  } else {

  }
  {
#line 246
  __memset((void *)(& cmd), 0, 80UL);
#line 247
  cmd.tf.__annonCompField84.command = 239U;
#line 248
  cmd.tf.__annonCompField83.feature = 3U;
#line 249
  cmd.tf.nsect = (unsigned char )arg;
#line 250
  cmd.valid.out.tf = 6U;
#line 251
  cmd.valid.in.tf = 4U;
#line 252
  cmd.tf_flags = 256U;
#line 254
  tmp = ide_no_data_taskfile(drive, & cmd);
  }
#line 254
  return (tmp);
}
}
#line 257 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct ide_devset  const  ide_devset_current_speed  =    {& get_xfer_rate, & set_xfer_rate, 0U};
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int get_init_speed(ide_drive_t *drive ) 
{ 


  {
#line 258
  return ((int )drive->init_speed);
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int set_init_speed(ide_drive_t *drive , int arg ) 
{ 


  {
#line 258
  drive->init_speed = (u8 )arg;
#line 258
  return (0);
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct ide_devset  const  ide_devset_init_speed  =    {& get_init_speed, & set_init_speed, 1U};
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int get_nice1(ide_drive_t *drive ) 
{ 


  {
#line 259
  return ((drive->dev_flags & 32UL) != 0UL);
}
}
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int set_nice1(ide_drive_t *drive , int arg ) 
{ 


  {
#line 259
  if (arg != 0) {
#line 259
    drive->dev_flags = drive->dev_flags | 32UL;
  } else {
#line 259
    drive->dev_flags = drive->dev_flags & 0xffffffffffffffdfUL;
  }
#line 259
  return (0);
}
}
#line 259 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct ide_devset  const  ide_devset_nice1  =    {& get_nice1, & set_nice1, 1U};
#line 260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int get_number(ide_drive_t *drive ) 
{ 


  {
#line 260
  return ((int )drive->dn);
}
}
#line 260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int set_number(ide_drive_t *drive , int arg ) 
{ 


  {
#line 260
  drive->dn = (u8 )arg;
#line 260
  return (0);
}
}
#line 260 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct ide_devset  const  ide_devset_number  =    {& get_number, & set_number, 1U};
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct ide_proc_devset  const  ide_generic_settings[10U]  = 
#line 262
  {      {"current_speed", & ide_devset_current_speed, 0, 70, (int (*)(ide_drive_t * ))0,
      (int (*)(ide_drive_t * ))0}, 
        {"init_speed", & ide_devset_init_speed, 0, 70, (int (*)(ide_drive_t * ))0, (int (*)(ide_drive_t * ))0}, 
        {"io_32bit",
      & ide_devset_io_32bit, 0, 3, (int (*)(ide_drive_t * ))0, (int (*)(ide_drive_t * ))0}, 
        {"keepsettings",
      & ide_devset_keepsettings, 0, 1, (int (*)(ide_drive_t * ))0, (int (*)(ide_drive_t * ))0}, 
        {"nice1",
      & ide_devset_nice1, 0, 1, (int (*)(ide_drive_t * ))0, (int (*)(ide_drive_t * ))0}, 
        {"number",
      & ide_devset_number, 0, 3, (int (*)(ide_drive_t * ))0, (int (*)(ide_drive_t * ))0}, 
        {"pio_mode",
      & ide_devset_pio_mode, 0, 255, (int (*)(ide_drive_t * ))0, (int (*)(ide_drive_t * ))0}, 
        {"unmaskirq",
      & ide_devset_unmaskirq, 0, 1, (int (*)(ide_drive_t * ))0, (int (*)(ide_drive_t * ))0}, 
        {"using_dma",
      & ide_devset_using_dma, 0, 1, (int (*)(ide_drive_t * ))0, (int (*)(ide_drive_t * ))0}, 
        {(char const   *)0,
      0, 0, 0, 0, 0}};
#line 275 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static void proc_ide_settings_warn(void) 
{ 
  bool __print_once ;

  {
#line 277
  if (! __print_once) {
    {
#line 277
    __print_once = 1;
#line 277
    printk("\fWarning: /proc/ide/hd?/settings interface is obsolete, and will be removed soon!\n");
    }
  } else {

  }
#line 281
  return;
}
}
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_settings_proc_show(struct seq_file *m , void *v ) 
{ 
  struct ide_proc_devset  const  *setting ;
  struct ide_proc_devset  const  *g ;
  struct ide_proc_devset  const  *d ;
  struct ide_devset  const  *ds ;
  ide_drive_t *drive ;
  int rc ;
  int mul_factor ;
  int div_factor ;
  struct ide_proc_devset  const  *tmp ;
  struct ide_proc_devset  const  *tmp___0 ;
  int tmp___1 ;
  struct ide_proc_devset  const  *tmp___2 ;
  struct ide_proc_devset  const  *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 285
  drive = (ide_drive_t *)m->private;
#line 288
  proc_ide_settings_warn();
#line 290
  ldv_mutex_lock_96___1(& ide_setting_mtx);
#line 291
  g = (struct ide_proc_devset  const  *)(& ide_generic_settings);
#line 292
  d = drive->settings;
#line 293
  seq_printf(m, "name\t\t\tvalue\t\tmin\t\tmax\t\tmode\n");
#line 294
  seq_printf(m, "----\t\t\t-----\t\t---\t\t---\t\t----\n");
  }
#line 295
  goto ldv_39151;
  ldv_39150: ;
#line 297
  if (((unsigned long )g->name != (unsigned long )((char const   */* const  */)0) && (unsigned long )d != (unsigned long )((struct ide_proc_devset  const  *)0)) && (unsigned long )d->name != (unsigned long )((char const   */* const  */)0)) {
    {
#line 298
    tmp___1 = strcmp(d->name, g->name);
    }
#line 298
    if (tmp___1 < 0) {
#line 299
      tmp = d;
#line 299
      d = d + 1;
#line 299
      setting = tmp;
    } else {
#line 301
      tmp___0 = g;
#line 301
      g = g + 1;
#line 301
      setting = tmp___0;
    }
  } else
#line 302
  if ((unsigned long )d != (unsigned long )((struct ide_proc_devset  const  *)0) && (unsigned long )d->name != (unsigned long )((char const   */* const  */)0)) {
#line 303
    tmp___2 = d;
#line 303
    d = d + 1;
#line 303
    setting = tmp___2;
  } else {
#line 305
    tmp___3 = g;
#line 305
    g = g + 1;
#line 305
    setting = tmp___3;
  }
#line 306
  if ((unsigned long )setting->mulf != (unsigned long )((int (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 306
    tmp___4 = (*(setting->mulf))(drive);
#line 306
    mul_factor = tmp___4;
    }
  } else {
#line 306
    mul_factor = 1;
  }
#line 307
  if ((unsigned long )setting->divf != (unsigned long )((int (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 307
    tmp___5 = (*(setting->divf))(drive);
#line 307
    div_factor = tmp___5;
    }
  } else {
#line 307
    div_factor = 1;
  }
  {
#line 308
  seq_printf(m, "%-24s", setting->name);
#line 309
  rc = ide_read_setting(drive, setting);
  }
#line 310
  if (rc >= 0) {
    {
#line 311
    seq_printf(m, "%-16d", (rc * mul_factor) / div_factor);
    }
  } else {
    {
#line 313
    seq_printf(m, "%-16s", (char *)"write-only");
    }
  }
  {
#line 314
  seq_printf(m, "%-16d%-16d", (((int )setting->min * mul_factor + div_factor) + -1) / div_factor,
             ((int )setting->max * mul_factor) / div_factor);
#line 315
  ds = setting->setting;
  }
#line 316
  if ((unsigned long )ds->get != (unsigned long )((int (*/* const  */)(ide_drive_t * ))0)) {
    {
#line 317
    seq_printf(m, "r");
    }
  } else {

  }
#line 318
  if ((unsigned long )ds->set != (unsigned long )((int (*/* const  */)(ide_drive_t * ,
                                                                       int  ))0)) {
    {
#line 319
    seq_printf(m, "w");
    }
  } else {

  }
  {
#line 320
  seq_printf(m, "\n");
  }
  ldv_39151: ;
#line 295
  if ((unsigned long )g->name != (unsigned long )((char const   */* const  */)0) || ((unsigned long )d != (unsigned long )((struct ide_proc_devset  const  *)0) && (unsigned long )d->name != (unsigned long )((char const   */* const  */)0))) {
#line 297
    goto ldv_39150;
  } else {

  }
  {
#line 322
  ldv_mutex_unlock_97___1(& ide_setting_mtx);
  }
#line 323
  return (0);
}
}
#line 326 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_settings_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 328
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 328
  tmp___0 = single_open(file, & ide_settings_proc_show, tmp);
  }
#line 328
  return (tmp___0);
}
}
#line 333 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static ssize_t ide_settings_proc_write(struct file *file , char const   *buffer ,
                                       size_t count , loff_t *pos ) 
{ 
  ide_drive_t *drive ;
  struct inode *tmp ;
  void *tmp___0 ;
  char name[31U] ;
  int for_real ;
  int mul_factor ;
  int div_factor ;
  unsigned long n ;
  struct ide_proc_devset  const  *setting ;
  char *buf ;
  char *s ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *p ;
  unsigned int val ;
  char *q ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 336
  tmp = file_inode((struct file  const  *)file);
#line 336
  tmp___0 = PDE_DATA((struct inode  const  *)tmp);
#line 336
  drive = (ide_drive_t *)tmp___0;
#line 338
  for_real = 0;
#line 344
  tmp___1 = capable(21);
  }
#line 344
  if (tmp___1) {
#line 344
    tmp___2 = 0;
  } else {
#line 344
    tmp___2 = 1;
  }
#line 344
  if (tmp___2) {
#line 345
    return (-13L);
  } else {

  }
  {
#line 347
  proc_ide_settings_warn();
  }
#line 349
  if (count > 4095UL) {
#line 350
    return (-22L);
  } else {

  }
  {
#line 352
  tmp___3 = ldv___get_free_pages_98(131280U, 0U);
#line 352
  buf = (char *)tmp___3;
#line 352
  s = buf;
  }
#line 353
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
#line 354
    return (-12L);
  } else {

  }
  {
#line 356
  tmp___4 = copy_from_user((void *)buf, (void const   *)buffer, count);
  }
#line 356
  if (tmp___4 != 0UL) {
    {
#line 357
    free_pages((unsigned long )buf, 0U);
    }
#line 358
    return (-14L);
  } else {

  }
#line 361
  *(buf + count) = 0;
#line 366
  goto ldv_39173;
  ldv_39172: 
#line 367
  count = count - 1UL;
#line 368
  s = s + 1;
  ldv_39173: ;
#line 366
  if (count != 0UL && ((int )_ctype[(int )((unsigned char )*s)] & 32) != 0) {
#line 368
    goto ldv_39172;
  } else {

  }

  ldv_39188: 
#line 375
  p = s;
#line 376
  n = count;
#line 377
  goto ldv_39186;
  ldv_39185: 
#line 379
  q = p;
#line 381
  goto ldv_39179;
  ldv_39178: 
#line 382
  n = n - 1UL;
#line 383
  p = p + 1;
  ldv_39179: ;
#line 381
  if (n != 0UL && (int )((signed char )*p) != 58) {
#line 383
    goto ldv_39178;
  } else {

  }

#line 385
  if ((int )((signed char )*p) != 58) {
#line 386
    goto parse_error;
  } else {

  }
#line 387
  if ((long )p - (long )q > 30L) {
#line 388
    goto parse_error;
  } else {

  }
  {
#line 389
  __memcpy((void *)(& name), (void const   *)q, (size_t )((long )p - (long )q));
#line 390
  name[(long )p - (long )q] = 0;
  }
#line 392
  if (n != 0UL) {
#line 393
    n = n - 1UL;
#line 394
    p = p + 1;
  } else {
#line 396
    goto parse_error;
  }
  {
#line 398
  tmp___5 = simple_strtoul((char const   *)p, & q, 10U);
#line 398
  val = (unsigned int )tmp___5;
#line 399
  n = n + (unsigned long )((long )p - (long )q);
#line 400
  p = q;
  }
#line 401
  if (n != 0UL && ((int )_ctype[(int )((unsigned char )*p)] & 32) == 0) {
#line 402
    goto parse_error;
  } else {

  }
#line 403
  goto ldv_39183;
  ldv_39182: 
#line 404
  n = n - 1UL;
#line 405
  p = p + 1;
  ldv_39183: ;
#line 403
  if (n != 0UL && ((int )_ctype[(int )((unsigned char )*p)] & 32) != 0) {
#line 405
    goto ldv_39182;
  } else {

  }
  {
#line 408
  ldv_mutex_lock_99(& ide_setting_mtx);
#line 410
  setting = ide_find_setting((struct ide_proc_devset  const  *)(& ide_generic_settings),
                             (char *)(& name));
  }
#line 411
  if ((unsigned long )setting == (unsigned long )((struct ide_proc_devset  const  *)0)) {
#line 412
    if ((unsigned long )drive->settings != (unsigned long )((struct ide_proc_devset  const  *)0)) {
      {
#line 413
      setting = ide_find_setting(drive->settings, (char *)(& name));
      }
    } else {

    }
#line 414
    if ((unsigned long )setting == (unsigned long )((struct ide_proc_devset  const  *)0)) {
      {
#line 415
      ldv_mutex_unlock_100(& ide_setting_mtx);
      }
#line 416
      goto parse_error;
    } else {

    }
  } else {

  }
#line 419
  if (for_real != 0) {
#line 420
    if ((unsigned long )setting->mulf != (unsigned long )((int (*/* const  */)(ide_drive_t * ))0)) {
      {
#line 420
      tmp___6 = (*(setting->mulf))(drive);
#line 420
      mul_factor = tmp___6;
      }
    } else {
#line 420
      mul_factor = 1;
    }
#line 421
    if ((unsigned long )setting->divf != (unsigned long )((int (*/* const  */)(ide_drive_t * ))0)) {
      {
#line 421
      tmp___7 = (*(setting->divf))(drive);
#line 421
      div_factor = tmp___7;
      }
    } else {
#line 421
      div_factor = 1;
    }
    {
#line 422
    ide_write_setting(drive, setting, (int )((val * (unsigned int )div_factor) / (unsigned int )mul_factor));
    }
  } else {

  }
  {
#line 424
  ldv_mutex_unlock_101(& ide_setting_mtx);
  }
  ldv_39186: ;
#line 377
  if (n != 0UL) {
#line 379
    goto ldv_39185;
  } else {

  }
#line 426
  tmp___8 = for_real;
#line 426
  for_real = for_real + 1;
#line 426
  if (tmp___8 == 0) {
#line 428
    goto ldv_39188;
  } else {

  }
  {
#line 427
  free_pages((unsigned long )buf, 0U);
  }
#line 428
  return ((ssize_t )count);
  parse_error: 
  {
#line 430
  free_pages((unsigned long )buf, 0U);
#line 431
  printk("%s(): parse error\n", "ide_settings_proc_write");
  }
#line 432
  return (-22L);
}
}
#line 435 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_settings_proc_fops  = 
#line 435
     {& __this_module, & seq_lseek, & seq_read, & ide_settings_proc_write, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, & ide_settings_proc_open, 0, & single_release, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 444 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_capacity_proc_show(struct seq_file *m , void *v ) 
{ 


  {
  {
#line 446
  seq_printf(m, "%llu\n", 2147483647LL);
  }
#line 447
  return (0);
}
}
#line 450 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_capacity_proc_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  {
#line 452
  tmp = single_open(file, & ide_capacity_proc_show, (void *)0);
  }
#line 452
  return (tmp);
}
}
#line 455 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
struct file_operations  const  ide_capacity_proc_fops  = 
#line 455
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_capacity_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 462 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static char const   __kstrtab_ide_capacity_proc_fops[23U]  = 
#line 462
  {      'i',      'd',      'e',      '_', 
        'c',      'a',      'p',      'a', 
        'c',      'i',      't',      'y', 
        '_',      'p',      'r',      'o', 
        'c',      '_',      'f',      'o', 
        'p',      's',      '\000'};
#line 462
struct kernel_symbol  const  __ksymtab_ide_capacity_proc_fops ;
#line 462 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
struct kernel_symbol  const  __ksymtab_ide_capacity_proc_fops  =    {(unsigned long )(& ide_capacity_proc_fops), (char const   *)(& __kstrtab_ide_capacity_proc_fops)};
#line 464 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_geometry_proc_show(struct seq_file *m , void *v ) 
{ 
  ide_drive_t *drive ;

  {
  {
#line 466
  drive = (ide_drive_t *)m->private;
#line 468
  seq_printf(m, "physical     %d/%d/%d\n", drive->cyl, (int )drive->head, (int )drive->sect);
#line 470
  seq_printf(m, "logical      %d/%d/%d\n", drive->bios_cyl, (int )drive->bios_head,
             (int )drive->bios_sect);
  }
#line 472
  return (0);
}
}
#line 475 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_geometry_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 477
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 477
  tmp___0 = single_open(file, & ide_geometry_proc_show, tmp);
  }
#line 477
  return (tmp___0);
}
}
#line 480 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
struct file_operations  const  ide_geometry_proc_fops  = 
#line 480
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_geometry_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static char const   __kstrtab_ide_geometry_proc_fops[23U]  = 
#line 487
  {      'i',      'd',      'e',      '_', 
        'g',      'e',      'o',      'm', 
        'e',      't',      'r',      'y', 
        '_',      'p',      'r',      'o', 
        'c',      '_',      'f',      'o', 
        'p',      's',      '\000'};
#line 487
struct kernel_symbol  const  __ksymtab_ide_geometry_proc_fops ;
#line 487 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
struct kernel_symbol  const  __ksymtab_ide_geometry_proc_fops  =    {(unsigned long )(& ide_geometry_proc_fops), (char const   *)(& __kstrtab_ide_geometry_proc_fops)};
#line 489 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_dmodel_proc_show(struct seq_file *seq , void *v ) 
{ 
  ide_drive_t *drive ;
  char *m ;

  {
  {
#line 491
  drive = (ide_drive_t *)seq->private;
#line 492
  m = (char *)drive->id + 27U;
#line 494
  seq_printf(seq, "%.40s\n", (int )((signed char )*m) != 0 ? m : (char *)"(none)");
  }
#line 495
  return (0);
}
}
#line 498 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_dmodel_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 500
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 500
  tmp___0 = single_open(file, & ide_dmodel_proc_show, tmp);
  }
#line 500
  return (tmp___0);
}
}
#line 503 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_dmodel_proc_fops  = 
#line 503
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_dmodel_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_driver_proc_show(struct seq_file *m , void *v ) 
{ 
  ide_drive_t *drive ;
  struct device *dev ;
  struct ide_driver *ide_drv ;
  struct device_driver  const  *__mptr ;

  {
#line 513
  drive = (ide_drive_t *)m->private;
#line 514
  dev = & drive->gendev;
#line 517
  if ((unsigned long )dev->driver != (unsigned long )((struct device_driver *)0)) {
    {
#line 518
    __mptr = (struct device_driver  const  *)dev->driver;
#line 518
    ide_drv = (struct ide_driver *)__mptr + 0xfffffffffffffff0UL;
#line 519
    seq_printf(m, "%s version %s\n", (dev->driver)->name, ide_drv->version);
    }
  } else {
    {
#line 522
    seq_printf(m, "ide-default version 0.9.newide\n");
    }
  }
#line 523
  return (0);
}
}
#line 526 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_driver_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 528
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 528
  tmp___0 = single_open(file, & ide_driver_proc_show, tmp);
  }
#line 528
  return (tmp___0);
}
}
#line 531 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_replace_subdriver(ide_drive_t *drive , char const   *driver ) 
{ 
  struct device *dev ;
  int ret ;
  int err ;
  int tmp ;

  {
  {
#line 533
  dev = & drive->gendev;
#line 534
  ret = 1;
#line 537
  device_release_driver(dev);
#line 539
  strlcpy((char *)(& drive->driver_req), driver, 10UL);
#line 540
  err = device_attach(dev);
  }
#line 541
  if (err < 0) {
    {
#line 542
    printk("\fIDE: %s: device_attach error: %d\n", "ide_replace_subdriver", err);
    }
  } else {

  }
#line 544
  drive->driver_req[0] = 0;
#line 545
  if ((unsigned long )dev->driver == (unsigned long )((struct device_driver *)0)) {
    {
#line 546
    err = device_attach(dev);
    }
#line 547
    if (err < 0) {
      {
#line 548
      printk("\fIDE: %s: device_attach(2) error: %d\n", "ide_replace_subdriver", err);
      }
    } else {

    }
  } else {

  }
#line 552
  if ((unsigned long )dev->driver != (unsigned long )((struct device_driver *)0)) {
    {
#line 552
    tmp = strcmp((dev->driver)->name, driver);
    }
#line 552
    if (tmp == 0) {
#line 553
      ret = 0;
    } else {

    }
  } else {

  }
#line 555
  return (ret);
}
}
#line 558 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static ssize_t ide_driver_proc_write(struct file *file , char const   *buffer , size_t count ,
                                     loff_t *pos ) 
{ 
  ide_drive_t *drive ;
  struct inode *tmp ;
  void *tmp___0 ;
  char name[32U] ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;

  {
  {
#line 561
  tmp = file_inode((struct file  const  *)file);
#line 561
  tmp___0 = PDE_DATA((struct inode  const  *)tmp);
#line 561
  drive = (ide_drive_t *)tmp___0;
#line 564
  tmp___1 = capable(21);
  }
#line 564
  if (tmp___1) {
#line 564
    tmp___2 = 0;
  } else {
#line 564
    tmp___2 = 1;
  }
#line 564
  if (tmp___2) {
#line 565
    return (-13L);
  } else {

  }
#line 566
  if (count > 31UL) {
#line 567
    count = 31UL;
  } else {

  }
  {
#line 568
  tmp___3 = copy_from_user((void *)(& name), (void const   *)buffer, count);
  }
#line 568
  if (tmp___3 != 0UL) {
#line 569
    return (-14L);
  } else {

  }
  {
#line 570
  name[count] = 0;
#line 571
  tmp___4 = ide_replace_subdriver(drive, (char const   *)(& name));
  }
#line 571
  if (tmp___4 != 0) {
#line 572
    return (-22L);
  } else {

  }
#line 573
  return ((ssize_t )count);
}
}
#line 576 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_driver_proc_fops  = 
#line 576
     {& __this_module, & seq_lseek, & seq_read, & ide_driver_proc_write, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, & ide_driver_proc_open, 0, & single_release, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0};
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_media_proc_show(struct seq_file *m , void *v ) 
{ 
  ide_drive_t *drive ;
  char const   *media ;

  {
#line 587
  drive = (ide_drive_t *)m->private;
  {
#line 591
  if ((int )drive->media == 32) {
#line 591
    goto case_32;
  } else {

  }
#line 592
  if ((int )drive->media == 5) {
#line 592
    goto case_5;
  } else {

  }
#line 593
  if ((int )drive->media == 1) {
#line 593
    goto case_1;
  } else {

  }
#line 594
  if ((int )drive->media == 0) {
#line 594
    goto case_0;
  } else {

  }
#line 595
  if ((int )drive->media == 7) {
#line 595
    goto case_7;
  } else {

  }
#line 596
  goto switch_default;
  case_32: /* CIL Label */ 
#line 591
  media = "disk\n";
#line 591
  goto ldv_39271;
  case_5: /* CIL Label */ 
#line 592
  media = "cdrom\n";
#line 592
  goto ldv_39271;
  case_1: /* CIL Label */ 
#line 593
  media = "tape\n";
#line 593
  goto ldv_39271;
  case_0: /* CIL Label */ 
#line 594
  media = "floppy\n";
#line 594
  goto ldv_39271;
  case_7: /* CIL Label */ 
#line 595
  media = "optical\n";
#line 595
  goto ldv_39271;
  switch_default: /* CIL Label */ 
#line 596
  media = "UNKNOWN\n";
#line 596
  goto ldv_39271;
  switch_break: /* CIL Label */ ;
  }
  ldv_39271: 
  {
#line 598
  seq_puts(m, media);
  }
#line 599
  return (0);
}
}
#line 602 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_media_proc_open(struct inode *inode , struct file *file ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 604
  tmp = PDE_DATA((struct inode  const  *)inode);
#line 604
  tmp___0 = single_open(file, & ide_media_proc_show, tmp);
  }
#line 604
  return (tmp___0);
}
}
#line 607 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_media_proc_fops  = 
#line 607
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_media_proc_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 615 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static ide_proc_entry_t generic_drive_entries[6U]  = {      {"driver", 33060U, & ide_driver_proc_fops}, 
        {"identify", 33024U, & ide_identify_proc_fops}, 
        {"media", 33060U, & ide_media_proc_fops}, 
        {"model", 33060U, & ide_dmodel_proc_fops}, 
        {"settings", 33152U, & ide_settings_proc_fops}};
#line 624 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static void ide_add_proc_entries(struct proc_dir_entry *dir , ide_proc_entry_t *p ,
                                 void *data ) 
{ 
  struct proc_dir_entry *ent ;

  {
#line 628
  if ((unsigned long )dir == (unsigned long )((struct proc_dir_entry *)0) || (unsigned long )p == (unsigned long )((ide_proc_entry_t *)0)) {
#line 629
    return;
  } else {

  }
#line 630
  goto ldv_39290;
  ldv_39289: 
  {
#line 631
  ent = proc_create_data(p->name, (int )p->mode, dir, p->proc_fops, data);
  }
#line 632
  if ((unsigned long )ent == (unsigned long )((struct proc_dir_entry *)0)) {
#line 632
    return;
  } else {

  }
#line 633
  p = p + 1;
  ldv_39290: ;
#line 630
  if ((unsigned long )p->name != (unsigned long )((char const   *)0)) {
#line 632
    goto ldv_39289;
  } else {

  }

#line 637
  return;
}
}
#line 637 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static void ide_remove_proc_entries(struct proc_dir_entry *dir , ide_proc_entry_t *p ) 
{ 


  {
#line 639
  if ((unsigned long )dir == (unsigned long )((struct proc_dir_entry *)0) || (unsigned long )p == (unsigned long )((ide_proc_entry_t *)0)) {
#line 640
    return;
  } else {

  }
#line 641
  goto ldv_39297;
  ldv_39296: 
  {
#line 642
  remove_proc_entry(p->name, dir);
#line 643
  p = p + 1;
  }
  ldv_39297: ;
#line 641
  if ((unsigned long )p->name != (unsigned long )((char const   *)0)) {
#line 643
    goto ldv_39296;
  } else {

  }

#line 648
  return;
}
}
#line 647 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
void ide_proc_register_driver(ide_drive_t *drive , struct ide_driver *driver ) 
{ 
  ide_proc_entry_t *tmp ;

  {
  {
#line 649
  ldv_mutex_lock_102___0(& ide_setting_mtx);
#line 650
  drive->settings = (*(driver->proc_devsets))(drive);
#line 651
  ldv_mutex_unlock_103___0(& ide_setting_mtx);
#line 653
  tmp = (*(driver->proc_entries))(drive);
#line 653
  ide_add_proc_entries(drive->proc, tmp, (void *)drive);
  }
#line 654
  return;
}
}
#line 656 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static char const   __kstrtab_ide_proc_register_driver[25U]  = 
#line 656
  {      'i',      'd',      'e',      '_', 
        'p',      'r',      'o',      'c', 
        '_',      'r',      'e',      'g', 
        'i',      's',      't',      'e', 
        'r',      '_',      'd',      'r', 
        'i',      'v',      'e',      'r', 
        '\000'};
#line 656
struct kernel_symbol  const  __ksymtab_ide_proc_register_driver ;
#line 656 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
struct kernel_symbol  const  __ksymtab_ide_proc_register_driver  =    {(unsigned long )(& ide_proc_register_driver), (char const   *)(& __kstrtab_ide_proc_register_driver)};
#line 669 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
void ide_proc_unregister_driver(ide_drive_t *drive , struct ide_driver *driver ) 
{ 
  ide_proc_entry_t *tmp ;

  {
  {
#line 671
  tmp = (*(driver->proc_entries))(drive);
#line 671
  ide_remove_proc_entries(drive->proc, tmp);
#line 673
  ldv_mutex_lock_104___0(& ide_setting_mtx);
#line 678
  drive->settings = (struct ide_proc_devset  const  *)0;
#line 679
  ldv_mutex_unlock_105___0(& ide_setting_mtx);
  }
#line 680
  return;
}
}
#line 681 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static char const   __kstrtab_ide_proc_unregister_driver[27U]  = 
#line 681
  {      'i',      'd',      'e',      '_', 
        'p',      'r',      'o',      'c', 
        '_',      'u',      'n',      'r', 
        'e',      'g',      'i',      's', 
        't',      'e',      'r',      '_', 
        'd',      'r',      'i',      'v', 
        'e',      'r',      '\000'};
#line 681
struct kernel_symbol  const  __ksymtab_ide_proc_unregister_driver ;
#line 681 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
struct kernel_symbol  const  __ksymtab_ide_proc_unregister_driver  =    {(unsigned long )(& ide_proc_unregister_driver), (char const   *)(& __kstrtab_ide_proc_unregister_driver)};
#line 683 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
void ide_proc_port_register_devices(ide_hwif_t *hwif ) 
{ 
  struct proc_dir_entry *ent ;
  struct proc_dir_entry *parent ;
  ide_drive_t *drive ;
  char name[64U] ;
  int i ;

  {
#line 686
  parent = hwif->proc;
#line 691
  i = 0;
#line 691
  goto ldv_39333;
  ldv_39332: ;
#line 692
  if ((drive->dev_flags & 64UL) == 0UL) {
#line 693
    goto ldv_39331;
  } else {

  }
  {
#line 695
  drive->proc = proc_mkdir((char const   *)(& drive->name), parent);
  }
#line 696
  if ((unsigned long )drive->proc != (unsigned long )((struct proc_dir_entry *)0)) {
    {
#line 697
    ide_add_proc_entries(drive->proc, (ide_proc_entry_t *)(& generic_drive_entries),
                         (void *)drive);
    }
  } else {

  }
  {
#line 698
  sprintf((char *)(& name), "ide%d/%s", ((int )drive->name[2] + -97) / 2, (char *)(& drive->name));
#line 699
  ent = proc_symlink((char const   *)(& drive->name), proc_ide_root, (char const   *)(& name));
  }
#line 700
  if ((unsigned long )ent == (unsigned long )((struct proc_dir_entry *)0)) {
#line 700
    return;
  } else {

  }
  ldv_39331: 
#line 691
  i = i + 1;
  ldv_39333: 
#line 691
  drive = hwif->devices[i];
#line 691
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 693
    goto ldv_39332;
  } else {

  }

#line 698
  return;
}
}
#line 704 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
void ide_proc_unregister_device(ide_drive_t *drive ) 
{ 


  {
#line 706
  if ((unsigned long )drive->proc != (unsigned long )((struct proc_dir_entry *)0)) {
    {
#line 707
    ide_remove_proc_entries(drive->proc, (ide_proc_entry_t *)(& generic_drive_entries));
#line 708
    remove_proc_entry((char const   *)(& drive->name), proc_ide_root);
#line 709
    remove_proc_entry((char const   *)(& drive->name), (drive->hwif)->proc);
#line 710
    drive->proc = (struct proc_dir_entry *)0;
    }
  } else {

  }
#line 712
  return;
}
}
#line 714 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static ide_proc_entry_t hwif_entries[4U]  = {      {"channel", 33060U, & ide_channel_proc_fops}, 
        {"mate", 33060U, & ide_mate_proc_fops}, 
        {"model", 33060U, & ide_imodel_proc_fops}};
#line 721 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
void ide_proc_register_port(ide_hwif_t *hwif ) 
{ 


  {
#line 723
  if ((unsigned long )hwif->proc == (unsigned long )((struct proc_dir_entry *)0)) {
    {
#line 724
    hwif->proc = proc_mkdir((char const   *)(& hwif->name), proc_ide_root);
    }
#line 726
    if ((unsigned long )hwif->proc == (unsigned long )((struct proc_dir_entry *)0)) {
#line 727
      return;
    } else {

    }
    {
#line 729
    ide_add_proc_entries(hwif->proc, (ide_proc_entry_t *)(& hwif_entries), (void *)hwif);
    }
  } else {

  }
#line 731
  return;
}
}
#line 733 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
void ide_proc_unregister_port(ide_hwif_t *hwif ) 
{ 


  {
#line 735
  if ((unsigned long )hwif->proc != (unsigned long )((struct proc_dir_entry *)0)) {
    {
#line 736
    ide_remove_proc_entries(hwif->proc, (ide_proc_entry_t *)(& hwif_entries));
#line 737
    remove_proc_entry((char const   *)(& hwif->name), proc_ide_root);
#line 738
    hwif->proc = (struct proc_dir_entry *)0;
    }
  } else {

  }
#line 740
  return;
}
}
#line 742 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int proc_print_driver(struct device_driver *drv , void *data ) 
{ 
  struct ide_driver *ide_drv ;
  struct device_driver  const  *__mptr ;
  struct seq_file *s ;

  {
  {
#line 744
  __mptr = (struct device_driver  const  *)drv;
#line 744
  ide_drv = (struct ide_driver *)__mptr + 0xfffffffffffffff0UL;
#line 745
  s = (struct seq_file *)data;
#line 747
  seq_printf(s, "%s version %s\n", drv->name, ide_drv->version);
  }
#line 749
  return (0);
}
}
#line 752 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_drivers_show(struct seq_file *s , void *p ) 
{ 
  int err ;

  {
  {
#line 756
  err = bus_for_each_drv(& ide_bus_type, (struct device_driver *)0, (void *)s, & proc_print_driver);
  }
#line 757
  if (err < 0) {
    {
#line 758
    printk("\fIDE: %s: bus_for_each_drv error: %d\n", "ide_drivers_show", err);
    }
  } else {

  }
#line 760
  return (0);
}
}
#line 763 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static int ide_drivers_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  {
#line 765
  tmp = single_open(file, & ide_drivers_show, (void *)0);
  }
#line 765
  return (tmp);
}
}
#line 768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
static struct file_operations  const  ide_drivers_operations  = 
#line 768
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ide_drivers_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
#line 776 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
void proc_ide_create(void) 
{ 


  {
  {
#line 778
  proc_ide_root = proc_mkdir("ide", (struct proc_dir_entry *)0);
  }
#line 780
  if ((unsigned long )proc_ide_root == (unsigned long )((struct proc_dir_entry *)0)) {
#line 781
    return;
  } else {

  }
  {
#line 783
  proc_create("drivers", 0, proc_ide_root, & ide_drivers_operations);
  }
#line 784
  return;
}
}
#line 786 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-proc.c"
void proc_ide_destroy(void) 
{ 


  {
  {
#line 788
  remove_proc_entry("drivers", proc_ide_root);
#line 789
  remove_proc_entry("ide", (struct proc_dir_entry *)0);
  }
#line 790
  return;
}
}
#line 649 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_0_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 650
void ldv_file_operations_instance_callback_0_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 651
void ldv_file_operations_instance_callback_10_22(long (*arg0)(struct file * , char * ,
                                                              unsigned long  , long long * ) ,
                                                 struct file *arg1 , char *arg2 ,
                                                 unsigned long arg3 , long long *arg4 ) ;
#line 652
void ldv_file_operations_instance_callback_10_5(long long (*arg0)(struct file * ,
                                                                  long long  , int  ) ,
                                                struct file *arg1 , long long arg2 ,
                                                int arg3 ) ;
#line 653
void ldv_file_operations_instance_callback_1_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 654
void ldv_file_operations_instance_callback_1_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 655
void ldv_file_operations_instance_callback_2_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 656
void ldv_file_operations_instance_callback_2_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 657
void ldv_file_operations_instance_callback_3_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 658
void ldv_file_operations_instance_callback_3_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 659
void ldv_file_operations_instance_callback_4_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 660
void ldv_file_operations_instance_callback_4_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 661
void ldv_file_operations_instance_callback_5_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 662
void ldv_file_operations_instance_callback_5_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 663
void ldv_file_operations_instance_callback_6_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 664
void ldv_file_operations_instance_callback_6_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 665
void ldv_file_operations_instance_callback_7_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 666
void ldv_file_operations_instance_callback_7_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 667
void ldv_file_operations_instance_callback_8_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 668
void ldv_file_operations_instance_callback_8_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 669
void ldv_file_operations_instance_callback_9_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) ;
#line 670
void ldv_file_operations_instance_callback_9_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) ;
#line 671
int ldv_file_operations_instance_probe_0_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 672
int ldv_file_operations_instance_probe_10_12(int (*arg0)(struct inode * , struct file * ) ,
                                             struct inode *arg1 , struct file *arg2 ) ;
#line 673
int ldv_file_operations_instance_probe_1_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 674
int ldv_file_operations_instance_probe_2_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 675
int ldv_file_operations_instance_probe_3_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 676
int ldv_file_operations_instance_probe_4_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 677
int ldv_file_operations_instance_probe_5_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 678
int ldv_file_operations_instance_probe_6_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 679
int ldv_file_operations_instance_probe_7_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 680
int ldv_file_operations_instance_probe_8_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 681
int ldv_file_operations_instance_probe_9_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) ;
#line 682
void ldv_file_operations_instance_release_0_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 683
void ldv_file_operations_instance_release_10_2(int (*arg0)(struct inode * , struct file * ) ,
                                               struct inode *arg1 , struct file *arg2 ) ;
#line 684
void ldv_file_operations_instance_release_1_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 685
void ldv_file_operations_instance_release_2_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 686
void ldv_file_operations_instance_release_3_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 687
void ldv_file_operations_instance_release_4_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 688
void ldv_file_operations_instance_release_5_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 689
void ldv_file_operations_instance_release_6_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 690
void ldv_file_operations_instance_release_7_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 691
void ldv_file_operations_instance_release_8_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 692
void ldv_file_operations_instance_release_9_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) ;
#line 694
void ldv_file_operations_instance_write_10_4(long (*arg0)(struct file * , char * ,
                                                          unsigned long  , long long * ) ,
                                             struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                             long long *arg4 ) ;
#line 697
void ldv_file_operations_instance_write_3_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) ;
#line 706 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_0  ;
#line 707 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_1  ;
#line 708 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_10  ;
#line 709 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_2  ;
#line 710 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_3  ;
#line 711 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_4  ;
#line 712 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_5  ;
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_6  ;
#line 714 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_7  ;
#line 715 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_8  ;
#line 716 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
struct ldv_thread ldv_thread_9  ;
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_dummy_resourceless_instance_callback_24_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 723
  get_init_speed(arg1);
  }
#line 724
  return;
}
}
#line 727 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_dummy_resourceless_instance_callback_27_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 728
  get_nice1(arg1);
  }
#line 729
  return;
}
}
#line 732 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_dummy_resourceless_instance_callback_27_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) 
{ 


  {
  {
#line 733
  set_nice1(arg1, arg2);
  }
#line 734
  return;
}
}
#line 737 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_dummy_resourceless_instance_callback_28_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 738
  get_number(arg1);
  }
#line 739
  return;
}
}
#line 742 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_dummy_resourceless_instance_callback_28_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) 
{ 


  {
  {
#line 743
  set_number(arg1, arg2);
  }
#line 744
  return;
}
}
#line 747 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_dummy_resourceless_instance_callback_31_16(int (*arg0)(struct ide_drive_s * ) ,
                                                    struct ide_drive_s *arg1 ) 
{ 


  {
  {
#line 748
  get_xfer_rate(arg1);
  }
#line 749
  return;
}
}
#line 752 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_dummy_resourceless_instance_callback_31_17(int (*arg0)(struct ide_drive_s * ,
                                                                int  ) , struct ide_drive_s *arg1 ,
                                                    int arg2 ) 
{ 


  {
  {
#line 753
  set_xfer_rate(arg1, arg2);
  }
#line 754
  return;
}
}
#line 757 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_0(void *arg0 ) 
{ 
  long long (*ldv_0_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_0_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_0_container_file_operations ;
  char *ldv_0_ldv_param_22_1_default ;
  long long *ldv_0_ldv_param_22_3_default ;
  char *ldv_0_ldv_param_4_1_default ;
  long long *ldv_0_ldv_param_4_3_default ;
  long long ldv_0_ldv_param_5_1_default ;
  int ldv_0_ldv_param_5_2_default ;
  struct file *ldv_0_resource_file ;
  struct inode *ldv_0_resource_inode ;
  int ldv_0_ret_default ;
  unsigned long ldv_0_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 775
  ldv_0_ret_default = 1;
#line 780
  tmp = ldv_xmalloc(504UL);
#line 780
  ldv_0_resource_file = (struct file *)tmp;
#line 781
  tmp___0 = ldv_xmalloc(976UL);
#line 781
  ldv_0_resource_inode = (struct inode *)tmp___0;
#line 782
  tmp___1 = ldv_undef_int();
#line 782
  ldv_0_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 789
  goto ldv_main_0;
#line 791
  return;
  ldv_main_0: 
  {
#line 797
  tmp___3 = ldv_undef_int();
  }
#line 797
  if (tmp___3 != 0) {
    {
#line 800
    ldv_0_ret_default = ldv_file_operations_instance_probe_0_12(ldv_0_container_file_operations->open,
                                                                ldv_0_resource_inode,
                                                                ldv_0_resource_file);
#line 802
    ldv_0_ret_default = ldv_filter_err_code(ldv_0_ret_default);
#line 805
    tmp___2 = ldv_undef_int();
    }
#line 805
    if (tmp___2 != 0) {
      {
#line 807
      ldv_assume(ldv_0_ret_default == 0);
      }
#line 814
      goto ldv_call_0;
    } else {
      {
#line 818
      ldv_assume(ldv_0_ret_default != 0);
      }
#line 825
      goto ldv_main_0;
    }
  } else {
    {
#line 830
    ldv_free((void *)ldv_0_resource_file);
#line 831
    ldv_free((void *)ldv_0_resource_inode);
    }
#line 839
    return;
  }
#line 842
  return;
  ldv_call_0: 
  {
#line 848
  tmp___4 = ldv_undef_int();
  }
  {
#line 849
  if (tmp___4 == 1) {
#line 849
    goto case_1;
  } else {

  }
#line 876
  if (tmp___4 == 2) {
#line 876
    goto case_2;
  } else {

  }
#line 889
  if (tmp___4 == 3) {
#line 889
    goto case_3;
  } else {

  }
#line 919
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 851
  tmp___5 = ldv_xmalloc(1UL);
#line 851
  ldv_0_ldv_param_4_1_default = (char *)tmp___5;
#line 852
  tmp___6 = ldv_xmalloc(8UL);
#line 852
  ldv_0_ldv_param_4_3_default = (long long *)tmp___6;
#line 857
  ldv_assume(ldv_0_size_cnt_write_size <= 2147479552UL);
  }
#line 858
  if ((unsigned long )ldv_0_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 860
    ldv_file_operations_instance_write_0_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_0_container_file_operations->write,
                                           ldv_0_resource_file, ldv_0_ldv_param_4_1_default,
                                           ldv_0_size_cnt_write_size, ldv_0_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 865
  ldv_free((void *)ldv_0_ldv_param_4_1_default);
#line 866
  ldv_free((void *)ldv_0_ldv_param_4_3_default);
  }
#line 873
  goto ldv_call_0;
  case_2: /* CIL Label */ 
  {
#line 879
  ldv_file_operations_instance_release_0_2(ldv_0_container_file_operations->release,
                                           ldv_0_resource_inode, ldv_0_resource_file);
  }
#line 886
  goto ldv_main_0;
  case_3: /* CIL Label */ 
  {
#line 893
  tmp___9 = ldv_undef_int();
  }
#line 893
  if (tmp___9 != 0) {
    {
#line 895
    tmp___7 = ldv_xmalloc(1UL);
#line 895
    ldv_0_ldv_param_22_1_default = (char *)tmp___7;
#line 896
    tmp___8 = ldv_xmalloc(8UL);
#line 896
    ldv_0_ldv_param_22_3_default = (long long *)tmp___8;
#line 901
    ldv_file_operations_instance_callback_0_22(ldv_0_callback_read, ldv_0_resource_file,
                                               ldv_0_ldv_param_22_1_default, ldv_0_size_cnt_write_size,
                                               ldv_0_ldv_param_22_3_default);
#line 905
    ldv_free((void *)ldv_0_ldv_param_22_1_default);
#line 906
    ldv_free((void *)ldv_0_ldv_param_22_3_default);
    }
  } else {
    {
#line 913
    ldv_file_operations_instance_callback_0_5(ldv_0_callback_llseek, ldv_0_resource_file,
                                              ldv_0_ldv_param_5_1_default, ldv_0_ldv_param_5_2_default);
    }
  }
#line 917
  goto ldv_39964;
  switch_default: /* CIL Label */ 
  {
#line 919
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_39964: ;
#line 928
  goto ldv_call_0;
#line 930
  goto ldv_call_0;
#line 932
  return;
}
}
#line 937 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_1(void *arg0 ) 
{ 
  long long (*ldv_1_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_1_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_1_container_file_operations ;
  char *ldv_1_ldv_param_22_1_default ;
  long long *ldv_1_ldv_param_22_3_default ;
  char *ldv_1_ldv_param_4_1_default ;
  long long *ldv_1_ldv_param_4_3_default ;
  long long ldv_1_ldv_param_5_1_default ;
  int ldv_1_ldv_param_5_2_default ;
  struct file *ldv_1_resource_file ;
  struct inode *ldv_1_resource_inode ;
  int ldv_1_ret_default ;
  unsigned long ldv_1_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 955
  ldv_1_ret_default = 1;
#line 960
  tmp = ldv_xmalloc(504UL);
#line 960
  ldv_1_resource_file = (struct file *)tmp;
#line 961
  tmp___0 = ldv_xmalloc(976UL);
#line 961
  ldv_1_resource_inode = (struct inode *)tmp___0;
#line 962
  tmp___1 = ldv_undef_int();
#line 962
  ldv_1_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 969
  goto ldv_main_1;
#line 971
  return;
  ldv_main_1: 
  {
#line 977
  tmp___3 = ldv_undef_int();
  }
#line 977
  if (tmp___3 != 0) {
    {
#line 980
    ldv_1_ret_default = ldv_file_operations_instance_probe_1_12(ldv_1_container_file_operations->open,
                                                                ldv_1_resource_inode,
                                                                ldv_1_resource_file);
#line 982
    ldv_1_ret_default = ldv_filter_err_code(ldv_1_ret_default);
#line 985
    tmp___2 = ldv_undef_int();
    }
#line 985
    if (tmp___2 != 0) {
      {
#line 987
      ldv_assume(ldv_1_ret_default == 0);
      }
#line 994
      goto ldv_call_1;
    } else {
      {
#line 998
      ldv_assume(ldv_1_ret_default != 0);
      }
#line 1005
      goto ldv_main_1;
    }
  } else {
    {
#line 1010
    ldv_free((void *)ldv_1_resource_file);
#line 1011
    ldv_free((void *)ldv_1_resource_inode);
    }
#line 1019
    return;
  }
#line 1022
  return;
  ldv_call_1: 
  {
#line 1028
  tmp___4 = ldv_undef_int();
  }
  {
#line 1029
  if (tmp___4 == 1) {
#line 1029
    goto case_1;
  } else {

  }
#line 1056
  if (tmp___4 == 2) {
#line 1056
    goto case_2;
  } else {

  }
#line 1069
  if (tmp___4 == 3) {
#line 1069
    goto case_3;
  } else {

  }
#line 1099
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1031
  tmp___5 = ldv_xmalloc(1UL);
#line 1031
  ldv_1_ldv_param_4_1_default = (char *)tmp___5;
#line 1032
  tmp___6 = ldv_xmalloc(8UL);
#line 1032
  ldv_1_ldv_param_4_3_default = (long long *)tmp___6;
#line 1037
  ldv_assume(ldv_1_size_cnt_write_size <= 2147479552UL);
  }
#line 1038
  if ((unsigned long )ldv_1_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 1040
    ldv_file_operations_instance_write_1_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_1_container_file_operations->write,
                                           ldv_1_resource_file, ldv_1_ldv_param_4_1_default,
                                           ldv_1_size_cnt_write_size, ldv_1_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 1045
  ldv_free((void *)ldv_1_ldv_param_4_1_default);
#line 1046
  ldv_free((void *)ldv_1_ldv_param_4_3_default);
  }
#line 1053
  goto ldv_call_1;
  case_2: /* CIL Label */ 
  {
#line 1059
  ldv_file_operations_instance_release_1_2(ldv_1_container_file_operations->release,
                                           ldv_1_resource_inode, ldv_1_resource_file);
  }
#line 1066
  goto ldv_main_1;
  case_3: /* CIL Label */ 
  {
#line 1073
  tmp___9 = ldv_undef_int();
  }
#line 1073
  if (tmp___9 != 0) {
    {
#line 1075
    tmp___7 = ldv_xmalloc(1UL);
#line 1075
    ldv_1_ldv_param_22_1_default = (char *)tmp___7;
#line 1076
    tmp___8 = ldv_xmalloc(8UL);
#line 1076
    ldv_1_ldv_param_22_3_default = (long long *)tmp___8;
#line 1081
    ldv_file_operations_instance_callback_1_22(ldv_1_callback_read, ldv_1_resource_file,
                                               ldv_1_ldv_param_22_1_default, ldv_1_size_cnt_write_size,
                                               ldv_1_ldv_param_22_3_default);
#line 1085
    ldv_free((void *)ldv_1_ldv_param_22_1_default);
#line 1086
    ldv_free((void *)ldv_1_ldv_param_22_3_default);
    }
  } else {
    {
#line 1093
    ldv_file_operations_instance_callback_1_5(ldv_1_callback_llseek, ldv_1_resource_file,
                                              ldv_1_ldv_param_5_1_default, ldv_1_ldv_param_5_2_default);
    }
  }
#line 1097
  goto ldv_39994;
  switch_default: /* CIL Label */ 
  {
#line 1099
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_39994: ;
#line 1108
  goto ldv_call_1;
#line 1110
  goto ldv_call_1;
#line 1112
  return;
}
}
#line 1117 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_10(void *arg0 ) 
{ 
  long long (*ldv_10_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_10_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_10_container_file_operations ;
  char *ldv_10_ldv_param_22_1_default ;
  long long *ldv_10_ldv_param_22_3_default ;
  char *ldv_10_ldv_param_4_1_default ;
  long long *ldv_10_ldv_param_4_3_default ;
  long long ldv_10_ldv_param_5_1_default ;
  int ldv_10_ldv_param_5_2_default ;
  struct file *ldv_10_resource_file ;
  struct inode *ldv_10_resource_inode ;
  int ldv_10_ret_default ;
  unsigned long ldv_10_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1135
  ldv_10_ret_default = 1;
#line 1140
  tmp = ldv_xmalloc(504UL);
#line 1140
  ldv_10_resource_file = (struct file *)tmp;
#line 1141
  tmp___0 = ldv_xmalloc(976UL);
#line 1141
  ldv_10_resource_inode = (struct inode *)tmp___0;
#line 1142
  tmp___1 = ldv_undef_int();
#line 1142
  ldv_10_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 1149
  goto ldv_main_10;
#line 1151
  return;
  ldv_main_10: 
  {
#line 1157
  tmp___3 = ldv_undef_int();
  }
#line 1157
  if (tmp___3 != 0) {
    {
#line 1160
    ldv_10_ret_default = ldv_file_operations_instance_probe_10_12(ldv_10_container_file_operations->open,
                                                                  ldv_10_resource_inode,
                                                                  ldv_10_resource_file);
#line 1162
    ldv_10_ret_default = ldv_filter_err_code(ldv_10_ret_default);
#line 1165
    tmp___2 = ldv_undef_int();
    }
#line 1165
    if (tmp___2 != 0) {
      {
#line 1167
      ldv_assume(ldv_10_ret_default == 0);
      }
#line 1174
      goto ldv_call_10;
    } else {
      {
#line 1178
      ldv_assume(ldv_10_ret_default != 0);
      }
#line 1185
      goto ldv_main_10;
    }
  } else {
    {
#line 1190
    ldv_free((void *)ldv_10_resource_file);
#line 1191
    ldv_free((void *)ldv_10_resource_inode);
    }
#line 1199
    return;
  }
#line 1202
  return;
  ldv_call_10: 
  {
#line 1208
  tmp___4 = ldv_undef_int();
  }
  {
#line 1209
  if (tmp___4 == 1) {
#line 1209
    goto case_1;
  } else {

  }
#line 1234
  if (tmp___4 == 2) {
#line 1234
    goto case_2;
  } else {

  }
#line 1247
  if (tmp___4 == 3) {
#line 1247
    goto case_3;
  } else {

  }
#line 1277
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1211
  tmp___5 = ldv_xmalloc(1UL);
#line 1211
  ldv_10_ldv_param_4_1_default = (char *)tmp___5;
#line 1212
  tmp___6 = ldv_xmalloc(8UL);
#line 1212
  ldv_10_ldv_param_4_3_default = (long long *)tmp___6;
#line 1217
  ldv_assume(ldv_10_size_cnt_write_size <= 2147479552UL);
#line 1219
  ldv_file_operations_instance_write_10_4((long (*)(struct file * , char * , unsigned long  ,
                                                    long long * ))ldv_10_container_file_operations->write,
                                          ldv_10_resource_file, ldv_10_ldv_param_4_1_default,
                                          ldv_10_size_cnt_write_size, ldv_10_ldv_param_4_3_default);
#line 1223
  ldv_free((void *)ldv_10_ldv_param_4_1_default);
#line 1224
  ldv_free((void *)ldv_10_ldv_param_4_3_default);
  }
#line 1231
  goto ldv_call_10;
  case_2: /* CIL Label */ 
  {
#line 1237
  ldv_file_operations_instance_release_10_2(ldv_10_container_file_operations->release,
                                            ldv_10_resource_inode, ldv_10_resource_file);
  }
#line 1244
  goto ldv_main_10;
  case_3: /* CIL Label */ 
  {
#line 1251
  tmp___9 = ldv_undef_int();
  }
#line 1251
  if (tmp___9 != 0) {
    {
#line 1253
    tmp___7 = ldv_xmalloc(1UL);
#line 1253
    ldv_10_ldv_param_22_1_default = (char *)tmp___7;
#line 1254
    tmp___8 = ldv_xmalloc(8UL);
#line 1254
    ldv_10_ldv_param_22_3_default = (long long *)tmp___8;
#line 1259
    ldv_file_operations_instance_callback_10_22(ldv_10_callback_read, ldv_10_resource_file,
                                                ldv_10_ldv_param_22_1_default, ldv_10_size_cnt_write_size,
                                                ldv_10_ldv_param_22_3_default);
#line 1263
    ldv_free((void *)ldv_10_ldv_param_22_1_default);
#line 1264
    ldv_free((void *)ldv_10_ldv_param_22_3_default);
    }
  } else {
    {
#line 1271
    ldv_file_operations_instance_callback_10_5(ldv_10_callback_llseek, ldv_10_resource_file,
                                               ldv_10_ldv_param_5_1_default, ldv_10_ldv_param_5_2_default);
    }
  }
#line 1275
  goto ldv_40024;
  switch_default: /* CIL Label */ 
  {
#line 1277
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40024: ;
#line 1286
  goto ldv_call_10;
#line 1288
  goto ldv_call_10;
#line 1290
  return;
}
}
#line 1295 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_2(void *arg0 ) 
{ 
  long long (*ldv_2_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_2_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_2_container_file_operations ;
  char *ldv_2_ldv_param_22_1_default ;
  long long *ldv_2_ldv_param_22_3_default ;
  char *ldv_2_ldv_param_4_1_default ;
  long long *ldv_2_ldv_param_4_3_default ;
  long long ldv_2_ldv_param_5_1_default ;
  int ldv_2_ldv_param_5_2_default ;
  struct file *ldv_2_resource_file ;
  struct inode *ldv_2_resource_inode ;
  int ldv_2_ret_default ;
  unsigned long ldv_2_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1313
  ldv_2_ret_default = 1;
#line 1318
  tmp = ldv_xmalloc(504UL);
#line 1318
  ldv_2_resource_file = (struct file *)tmp;
#line 1319
  tmp___0 = ldv_xmalloc(976UL);
#line 1319
  ldv_2_resource_inode = (struct inode *)tmp___0;
#line 1320
  tmp___1 = ldv_undef_int();
#line 1320
  ldv_2_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 1327
  goto ldv_main_2;
#line 1329
  return;
  ldv_main_2: 
  {
#line 1335
  tmp___3 = ldv_undef_int();
  }
#line 1335
  if (tmp___3 != 0) {
    {
#line 1338
    ldv_2_ret_default = ldv_file_operations_instance_probe_2_12(ldv_2_container_file_operations->open,
                                                                ldv_2_resource_inode,
                                                                ldv_2_resource_file);
#line 1340
    ldv_2_ret_default = ldv_filter_err_code(ldv_2_ret_default);
#line 1343
    tmp___2 = ldv_undef_int();
    }
#line 1343
    if (tmp___2 != 0) {
      {
#line 1345
      ldv_assume(ldv_2_ret_default == 0);
      }
#line 1352
      goto ldv_call_2;
    } else {
      {
#line 1356
      ldv_assume(ldv_2_ret_default != 0);
      }
#line 1363
      goto ldv_main_2;
    }
  } else {
    {
#line 1368
    ldv_free((void *)ldv_2_resource_file);
#line 1369
    ldv_free((void *)ldv_2_resource_inode);
    }
#line 1377
    return;
  }
#line 1380
  return;
  ldv_call_2: 
  {
#line 1386
  tmp___4 = ldv_undef_int();
  }
  {
#line 1387
  if (tmp___4 == 1) {
#line 1387
    goto case_1;
  } else {

  }
#line 1414
  if (tmp___4 == 2) {
#line 1414
    goto case_2;
  } else {

  }
#line 1427
  if (tmp___4 == 3) {
#line 1427
    goto case_3;
  } else {

  }
#line 1457
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1389
  tmp___5 = ldv_xmalloc(1UL);
#line 1389
  ldv_2_ldv_param_4_1_default = (char *)tmp___5;
#line 1390
  tmp___6 = ldv_xmalloc(8UL);
#line 1390
  ldv_2_ldv_param_4_3_default = (long long *)tmp___6;
#line 1395
  ldv_assume(ldv_2_size_cnt_write_size <= 2147479552UL);
  }
#line 1396
  if ((unsigned long )ldv_2_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 1398
    ldv_file_operations_instance_write_2_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_2_container_file_operations->write,
                                           ldv_2_resource_file, ldv_2_ldv_param_4_1_default,
                                           ldv_2_size_cnt_write_size, ldv_2_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 1403
  ldv_free((void *)ldv_2_ldv_param_4_1_default);
#line 1404
  ldv_free((void *)ldv_2_ldv_param_4_3_default);
  }
#line 1411
  goto ldv_call_2;
  case_2: /* CIL Label */ 
  {
#line 1417
  ldv_file_operations_instance_release_2_2(ldv_2_container_file_operations->release,
                                           ldv_2_resource_inode, ldv_2_resource_file);
  }
#line 1424
  goto ldv_main_2;
  case_3: /* CIL Label */ 
  {
#line 1431
  tmp___9 = ldv_undef_int();
  }
#line 1431
  if (tmp___9 != 0) {
    {
#line 1433
    tmp___7 = ldv_xmalloc(1UL);
#line 1433
    ldv_2_ldv_param_22_1_default = (char *)tmp___7;
#line 1434
    tmp___8 = ldv_xmalloc(8UL);
#line 1434
    ldv_2_ldv_param_22_3_default = (long long *)tmp___8;
#line 1439
    ldv_file_operations_instance_callback_2_22(ldv_2_callback_read, ldv_2_resource_file,
                                               ldv_2_ldv_param_22_1_default, ldv_2_size_cnt_write_size,
                                               ldv_2_ldv_param_22_3_default);
#line 1443
    ldv_free((void *)ldv_2_ldv_param_22_1_default);
#line 1444
    ldv_free((void *)ldv_2_ldv_param_22_3_default);
    }
  } else {
    {
#line 1451
    ldv_file_operations_instance_callback_2_5(ldv_2_callback_llseek, ldv_2_resource_file,
                                              ldv_2_ldv_param_5_1_default, ldv_2_ldv_param_5_2_default);
    }
  }
#line 1455
  goto ldv_40054;
  switch_default: /* CIL Label */ 
  {
#line 1457
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40054: ;
#line 1466
  goto ldv_call_2;
#line 1468
  goto ldv_call_2;
#line 1470
  return;
}
}
#line 1475 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_3(void *arg0 ) 
{ 
  long long (*ldv_3_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_3_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_3_container_file_operations ;
  char *ldv_3_ldv_param_22_1_default ;
  long long *ldv_3_ldv_param_22_3_default ;
  char *ldv_3_ldv_param_4_1_default ;
  long long *ldv_3_ldv_param_4_3_default ;
  long long ldv_3_ldv_param_5_1_default ;
  int ldv_3_ldv_param_5_2_default ;
  struct file *ldv_3_resource_file ;
  struct inode *ldv_3_resource_inode ;
  int ldv_3_ret_default ;
  unsigned long ldv_3_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1493
  ldv_3_ret_default = 1;
#line 1498
  tmp = ldv_xmalloc(504UL);
#line 1498
  ldv_3_resource_file = (struct file *)tmp;
#line 1499
  tmp___0 = ldv_xmalloc(976UL);
#line 1499
  ldv_3_resource_inode = (struct inode *)tmp___0;
#line 1500
  tmp___1 = ldv_undef_int();
#line 1500
  ldv_3_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 1507
  goto ldv_main_3;
#line 1509
  return;
  ldv_main_3: 
  {
#line 1515
  tmp___3 = ldv_undef_int();
  }
#line 1515
  if (tmp___3 != 0) {
    {
#line 1518
    ldv_3_ret_default = ldv_file_operations_instance_probe_3_12(ldv_3_container_file_operations->open,
                                                                ldv_3_resource_inode,
                                                                ldv_3_resource_file);
#line 1520
    ldv_3_ret_default = ldv_filter_err_code(ldv_3_ret_default);
#line 1523
    tmp___2 = ldv_undef_int();
    }
#line 1523
    if (tmp___2 != 0) {
      {
#line 1525
      ldv_assume(ldv_3_ret_default == 0);
      }
#line 1532
      goto ldv_call_3;
    } else {
      {
#line 1536
      ldv_assume(ldv_3_ret_default != 0);
      }
#line 1543
      goto ldv_main_3;
    }
  } else {
    {
#line 1548
    ldv_free((void *)ldv_3_resource_file);
#line 1549
    ldv_free((void *)ldv_3_resource_inode);
    }
#line 1557
    return;
  }
#line 1560
  return;
  ldv_call_3: 
  {
#line 1566
  tmp___4 = ldv_undef_int();
  }
  {
#line 1567
  if (tmp___4 == 1) {
#line 1567
    goto case_1;
  } else {

  }
#line 1592
  if (tmp___4 == 2) {
#line 1592
    goto case_2;
  } else {

  }
#line 1605
  if (tmp___4 == 3) {
#line 1605
    goto case_3;
  } else {

  }
#line 1635
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1569
  tmp___5 = ldv_xmalloc(1UL);
#line 1569
  ldv_3_ldv_param_4_1_default = (char *)tmp___5;
#line 1570
  tmp___6 = ldv_xmalloc(8UL);
#line 1570
  ldv_3_ldv_param_4_3_default = (long long *)tmp___6;
#line 1575
  ldv_assume(ldv_3_size_cnt_write_size <= 2147479552UL);
#line 1577
  ldv_file_operations_instance_write_3_4((long (*)(struct file * , char * , unsigned long  ,
                                                   long long * ))ldv_3_container_file_operations->write,
                                         ldv_3_resource_file, ldv_3_ldv_param_4_1_default,
                                         ldv_3_size_cnt_write_size, ldv_3_ldv_param_4_3_default);
#line 1581
  ldv_free((void *)ldv_3_ldv_param_4_1_default);
#line 1582
  ldv_free((void *)ldv_3_ldv_param_4_3_default);
  }
#line 1589
  goto ldv_call_3;
  case_2: /* CIL Label */ 
  {
#line 1595
  ldv_file_operations_instance_release_3_2(ldv_3_container_file_operations->release,
                                           ldv_3_resource_inode, ldv_3_resource_file);
  }
#line 1602
  goto ldv_main_3;
  case_3: /* CIL Label */ 
  {
#line 1609
  tmp___9 = ldv_undef_int();
  }
#line 1609
  if (tmp___9 != 0) {
    {
#line 1611
    tmp___7 = ldv_xmalloc(1UL);
#line 1611
    ldv_3_ldv_param_22_1_default = (char *)tmp___7;
#line 1612
    tmp___8 = ldv_xmalloc(8UL);
#line 1612
    ldv_3_ldv_param_22_3_default = (long long *)tmp___8;
#line 1617
    ldv_file_operations_instance_callback_3_22(ldv_3_callback_read, ldv_3_resource_file,
                                               ldv_3_ldv_param_22_1_default, ldv_3_size_cnt_write_size,
                                               ldv_3_ldv_param_22_3_default);
#line 1621
    ldv_free((void *)ldv_3_ldv_param_22_1_default);
#line 1622
    ldv_free((void *)ldv_3_ldv_param_22_3_default);
    }
  } else {
    {
#line 1629
    ldv_file_operations_instance_callback_3_5(ldv_3_callback_llseek, ldv_3_resource_file,
                                              ldv_3_ldv_param_5_1_default, ldv_3_ldv_param_5_2_default);
    }
  }
#line 1633
  goto ldv_40084;
  switch_default: /* CIL Label */ 
  {
#line 1635
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40084: ;
#line 1644
  goto ldv_call_3;
#line 1646
  goto ldv_call_3;
#line 1648
  return;
}
}
#line 1653 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_4(void *arg0 ) 
{ 
  long long (*ldv_4_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_4_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_4_container_file_operations ;
  char *ldv_4_ldv_param_22_1_default ;
  long long *ldv_4_ldv_param_22_3_default ;
  char *ldv_4_ldv_param_4_1_default ;
  long long *ldv_4_ldv_param_4_3_default ;
  long long ldv_4_ldv_param_5_1_default ;
  int ldv_4_ldv_param_5_2_default ;
  struct file *ldv_4_resource_file ;
  struct inode *ldv_4_resource_inode ;
  int ldv_4_ret_default ;
  unsigned long ldv_4_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1671
  ldv_4_ret_default = 1;
#line 1676
  tmp = ldv_xmalloc(504UL);
#line 1676
  ldv_4_resource_file = (struct file *)tmp;
#line 1677
  tmp___0 = ldv_xmalloc(976UL);
#line 1677
  ldv_4_resource_inode = (struct inode *)tmp___0;
#line 1678
  tmp___1 = ldv_undef_int();
#line 1678
  ldv_4_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 1685
  goto ldv_main_4;
#line 1687
  return;
  ldv_main_4: 
  {
#line 1693
  tmp___3 = ldv_undef_int();
  }
#line 1693
  if (tmp___3 != 0) {
    {
#line 1696
    ldv_4_ret_default = ldv_file_operations_instance_probe_4_12(ldv_4_container_file_operations->open,
                                                                ldv_4_resource_inode,
                                                                ldv_4_resource_file);
#line 1698
    ldv_4_ret_default = ldv_filter_err_code(ldv_4_ret_default);
#line 1701
    tmp___2 = ldv_undef_int();
    }
#line 1701
    if (tmp___2 != 0) {
      {
#line 1703
      ldv_assume(ldv_4_ret_default == 0);
      }
#line 1710
      goto ldv_call_4;
    } else {
      {
#line 1714
      ldv_assume(ldv_4_ret_default != 0);
      }
#line 1721
      goto ldv_main_4;
    }
  } else {
    {
#line 1726
    ldv_free((void *)ldv_4_resource_file);
#line 1727
    ldv_free((void *)ldv_4_resource_inode);
    }
#line 1735
    return;
  }
#line 1738
  return;
  ldv_call_4: 
  {
#line 1744
  tmp___4 = ldv_undef_int();
  }
  {
#line 1745
  if (tmp___4 == 1) {
#line 1745
    goto case_1;
  } else {

  }
#line 1772
  if (tmp___4 == 2) {
#line 1772
    goto case_2;
  } else {

  }
#line 1785
  if (tmp___4 == 3) {
#line 1785
    goto case_3;
  } else {

  }
#line 1815
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1747
  tmp___5 = ldv_xmalloc(1UL);
#line 1747
  ldv_4_ldv_param_4_1_default = (char *)tmp___5;
#line 1748
  tmp___6 = ldv_xmalloc(8UL);
#line 1748
  ldv_4_ldv_param_4_3_default = (long long *)tmp___6;
#line 1753
  ldv_assume(ldv_4_size_cnt_write_size <= 2147479552UL);
  }
#line 1754
  if ((unsigned long )ldv_4_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 1756
    ldv_file_operations_instance_write_4_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_4_container_file_operations->write,
                                           ldv_4_resource_file, ldv_4_ldv_param_4_1_default,
                                           ldv_4_size_cnt_write_size, ldv_4_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 1761
  ldv_free((void *)ldv_4_ldv_param_4_1_default);
#line 1762
  ldv_free((void *)ldv_4_ldv_param_4_3_default);
  }
#line 1769
  goto ldv_call_4;
  case_2: /* CIL Label */ 
  {
#line 1775
  ldv_file_operations_instance_release_4_2(ldv_4_container_file_operations->release,
                                           ldv_4_resource_inode, ldv_4_resource_file);
  }
#line 1782
  goto ldv_main_4;
  case_3: /* CIL Label */ 
  {
#line 1789
  tmp___9 = ldv_undef_int();
  }
#line 1789
  if (tmp___9 != 0) {
    {
#line 1791
    tmp___7 = ldv_xmalloc(1UL);
#line 1791
    ldv_4_ldv_param_22_1_default = (char *)tmp___7;
#line 1792
    tmp___8 = ldv_xmalloc(8UL);
#line 1792
    ldv_4_ldv_param_22_3_default = (long long *)tmp___8;
#line 1797
    ldv_file_operations_instance_callback_4_22(ldv_4_callback_read, ldv_4_resource_file,
                                               ldv_4_ldv_param_22_1_default, ldv_4_size_cnt_write_size,
                                               ldv_4_ldv_param_22_3_default);
#line 1801
    ldv_free((void *)ldv_4_ldv_param_22_1_default);
#line 1802
    ldv_free((void *)ldv_4_ldv_param_22_3_default);
    }
  } else {
    {
#line 1809
    ldv_file_operations_instance_callback_4_5(ldv_4_callback_llseek, ldv_4_resource_file,
                                              ldv_4_ldv_param_5_1_default, ldv_4_ldv_param_5_2_default);
    }
  }
#line 1813
  goto ldv_40114;
  switch_default: /* CIL Label */ 
  {
#line 1815
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40114: ;
#line 1824
  goto ldv_call_4;
#line 1826
  goto ldv_call_4;
#line 1828
  return;
}
}
#line 1833 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_5(void *arg0 ) 
{ 
  long long (*ldv_5_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_5_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_5_container_file_operations ;
  char *ldv_5_ldv_param_22_1_default ;
  long long *ldv_5_ldv_param_22_3_default ;
  char *ldv_5_ldv_param_4_1_default ;
  long long *ldv_5_ldv_param_4_3_default ;
  long long ldv_5_ldv_param_5_1_default ;
  int ldv_5_ldv_param_5_2_default ;
  struct file *ldv_5_resource_file ;
  struct inode *ldv_5_resource_inode ;
  int ldv_5_ret_default ;
  unsigned long ldv_5_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1851
  ldv_5_ret_default = 1;
#line 1856
  tmp = ldv_xmalloc(504UL);
#line 1856
  ldv_5_resource_file = (struct file *)tmp;
#line 1857
  tmp___0 = ldv_xmalloc(976UL);
#line 1857
  ldv_5_resource_inode = (struct inode *)tmp___0;
#line 1858
  tmp___1 = ldv_undef_int();
#line 1858
  ldv_5_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 1865
  goto ldv_main_5;
#line 1867
  return;
  ldv_main_5: 
  {
#line 1873
  tmp___3 = ldv_undef_int();
  }
#line 1873
  if (tmp___3 != 0) {
    {
#line 1876
    ldv_5_ret_default = ldv_file_operations_instance_probe_5_12(ldv_5_container_file_operations->open,
                                                                ldv_5_resource_inode,
                                                                ldv_5_resource_file);
#line 1878
    ldv_5_ret_default = ldv_filter_err_code(ldv_5_ret_default);
#line 1881
    tmp___2 = ldv_undef_int();
    }
#line 1881
    if (tmp___2 != 0) {
      {
#line 1883
      ldv_assume(ldv_5_ret_default == 0);
      }
#line 1890
      goto ldv_call_5;
    } else {
      {
#line 1894
      ldv_assume(ldv_5_ret_default != 0);
      }
#line 1901
      goto ldv_main_5;
    }
  } else {
    {
#line 1906
    ldv_free((void *)ldv_5_resource_file);
#line 1907
    ldv_free((void *)ldv_5_resource_inode);
    }
#line 1915
    return;
  }
#line 1918
  return;
  ldv_call_5: 
  {
#line 1924
  tmp___4 = ldv_undef_int();
  }
  {
#line 1925
  if (tmp___4 == 1) {
#line 1925
    goto case_1;
  } else {

  }
#line 1952
  if (tmp___4 == 2) {
#line 1952
    goto case_2;
  } else {

  }
#line 1965
  if (tmp___4 == 3) {
#line 1965
    goto case_3;
  } else {

  }
#line 1995
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1927
  tmp___5 = ldv_xmalloc(1UL);
#line 1927
  ldv_5_ldv_param_4_1_default = (char *)tmp___5;
#line 1928
  tmp___6 = ldv_xmalloc(8UL);
#line 1928
  ldv_5_ldv_param_4_3_default = (long long *)tmp___6;
#line 1933
  ldv_assume(ldv_5_size_cnt_write_size <= 2147479552UL);
  }
#line 1934
  if ((unsigned long )ldv_5_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 1936
    ldv_file_operations_instance_write_5_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_5_container_file_operations->write,
                                           ldv_5_resource_file, ldv_5_ldv_param_4_1_default,
                                           ldv_5_size_cnt_write_size, ldv_5_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 1941
  ldv_free((void *)ldv_5_ldv_param_4_1_default);
#line 1942
  ldv_free((void *)ldv_5_ldv_param_4_3_default);
  }
#line 1949
  goto ldv_call_5;
  case_2: /* CIL Label */ 
  {
#line 1955
  ldv_file_operations_instance_release_5_2(ldv_5_container_file_operations->release,
                                           ldv_5_resource_inode, ldv_5_resource_file);
  }
#line 1962
  goto ldv_main_5;
  case_3: /* CIL Label */ 
  {
#line 1969
  tmp___9 = ldv_undef_int();
  }
#line 1969
  if (tmp___9 != 0) {
    {
#line 1971
    tmp___7 = ldv_xmalloc(1UL);
#line 1971
    ldv_5_ldv_param_22_1_default = (char *)tmp___7;
#line 1972
    tmp___8 = ldv_xmalloc(8UL);
#line 1972
    ldv_5_ldv_param_22_3_default = (long long *)tmp___8;
#line 1977
    ldv_file_operations_instance_callback_5_22(ldv_5_callback_read, ldv_5_resource_file,
                                               ldv_5_ldv_param_22_1_default, ldv_5_size_cnt_write_size,
                                               ldv_5_ldv_param_22_3_default);
#line 1981
    ldv_free((void *)ldv_5_ldv_param_22_1_default);
#line 1982
    ldv_free((void *)ldv_5_ldv_param_22_3_default);
    }
  } else {
    {
#line 1989
    ldv_file_operations_instance_callback_5_5(ldv_5_callback_llseek, ldv_5_resource_file,
                                              ldv_5_ldv_param_5_1_default, ldv_5_ldv_param_5_2_default);
    }
  }
#line 1993
  goto ldv_40144;
  switch_default: /* CIL Label */ 
  {
#line 1995
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40144: ;
#line 2004
  goto ldv_call_5;
#line 2006
  goto ldv_call_5;
#line 2008
  return;
}
}
#line 2013 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_6(void *arg0 ) 
{ 
  long long (*ldv_6_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_6_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_6_container_file_operations ;
  char *ldv_6_ldv_param_22_1_default ;
  long long *ldv_6_ldv_param_22_3_default ;
  char *ldv_6_ldv_param_4_1_default ;
  long long *ldv_6_ldv_param_4_3_default ;
  long long ldv_6_ldv_param_5_1_default ;
  int ldv_6_ldv_param_5_2_default ;
  struct file *ldv_6_resource_file ;
  struct inode *ldv_6_resource_inode ;
  int ldv_6_ret_default ;
  unsigned long ldv_6_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 2031
  ldv_6_ret_default = 1;
#line 2036
  tmp = ldv_xmalloc(504UL);
#line 2036
  ldv_6_resource_file = (struct file *)tmp;
#line 2037
  tmp___0 = ldv_xmalloc(976UL);
#line 2037
  ldv_6_resource_inode = (struct inode *)tmp___0;
#line 2038
  tmp___1 = ldv_undef_int();
#line 2038
  ldv_6_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 2045
  goto ldv_main_6;
#line 2047
  return;
  ldv_main_6: 
  {
#line 2053
  tmp___3 = ldv_undef_int();
  }
#line 2053
  if (tmp___3 != 0) {
    {
#line 2056
    ldv_6_ret_default = ldv_file_operations_instance_probe_6_12(ldv_6_container_file_operations->open,
                                                                ldv_6_resource_inode,
                                                                ldv_6_resource_file);
#line 2058
    ldv_6_ret_default = ldv_filter_err_code(ldv_6_ret_default);
#line 2061
    tmp___2 = ldv_undef_int();
    }
#line 2061
    if (tmp___2 != 0) {
      {
#line 2063
      ldv_assume(ldv_6_ret_default == 0);
      }
#line 2070
      goto ldv_call_6;
    } else {
      {
#line 2074
      ldv_assume(ldv_6_ret_default != 0);
      }
#line 2081
      goto ldv_main_6;
    }
  } else {
    {
#line 2086
    ldv_free((void *)ldv_6_resource_file);
#line 2087
    ldv_free((void *)ldv_6_resource_inode);
    }
#line 2095
    return;
  }
#line 2098
  return;
  ldv_call_6: 
  {
#line 2104
  tmp___4 = ldv_undef_int();
  }
  {
#line 2105
  if (tmp___4 == 1) {
#line 2105
    goto case_1;
  } else {

  }
#line 2132
  if (tmp___4 == 2) {
#line 2132
    goto case_2;
  } else {

  }
#line 2145
  if (tmp___4 == 3) {
#line 2145
    goto case_3;
  } else {

  }
#line 2175
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2107
  tmp___5 = ldv_xmalloc(1UL);
#line 2107
  ldv_6_ldv_param_4_1_default = (char *)tmp___5;
#line 2108
  tmp___6 = ldv_xmalloc(8UL);
#line 2108
  ldv_6_ldv_param_4_3_default = (long long *)tmp___6;
#line 2113
  ldv_assume(ldv_6_size_cnt_write_size <= 2147479552UL);
  }
#line 2114
  if ((unsigned long )ldv_6_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 2116
    ldv_file_operations_instance_write_6_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_6_container_file_operations->write,
                                           ldv_6_resource_file, ldv_6_ldv_param_4_1_default,
                                           ldv_6_size_cnt_write_size, ldv_6_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 2121
  ldv_free((void *)ldv_6_ldv_param_4_1_default);
#line 2122
  ldv_free((void *)ldv_6_ldv_param_4_3_default);
  }
#line 2129
  goto ldv_call_6;
  case_2: /* CIL Label */ 
  {
#line 2135
  ldv_file_operations_instance_release_6_2(ldv_6_container_file_operations->release,
                                           ldv_6_resource_inode, ldv_6_resource_file);
  }
#line 2142
  goto ldv_main_6;
  case_3: /* CIL Label */ 
  {
#line 2149
  tmp___9 = ldv_undef_int();
  }
#line 2149
  if (tmp___9 != 0) {
    {
#line 2151
    tmp___7 = ldv_xmalloc(1UL);
#line 2151
    ldv_6_ldv_param_22_1_default = (char *)tmp___7;
#line 2152
    tmp___8 = ldv_xmalloc(8UL);
#line 2152
    ldv_6_ldv_param_22_3_default = (long long *)tmp___8;
#line 2157
    ldv_file_operations_instance_callback_6_22(ldv_6_callback_read, ldv_6_resource_file,
                                               ldv_6_ldv_param_22_1_default, ldv_6_size_cnt_write_size,
                                               ldv_6_ldv_param_22_3_default);
#line 2161
    ldv_free((void *)ldv_6_ldv_param_22_1_default);
#line 2162
    ldv_free((void *)ldv_6_ldv_param_22_3_default);
    }
  } else {
    {
#line 2169
    ldv_file_operations_instance_callback_6_5(ldv_6_callback_llseek, ldv_6_resource_file,
                                              ldv_6_ldv_param_5_1_default, ldv_6_ldv_param_5_2_default);
    }
  }
#line 2173
  goto ldv_40174;
  switch_default: /* CIL Label */ 
  {
#line 2175
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40174: ;
#line 2184
  goto ldv_call_6;
#line 2186
  goto ldv_call_6;
#line 2188
  return;
}
}
#line 2193 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_7(void *arg0 ) 
{ 
  long long (*ldv_7_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_7_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_7_container_file_operations ;
  char *ldv_7_ldv_param_22_1_default ;
  long long *ldv_7_ldv_param_22_3_default ;
  char *ldv_7_ldv_param_4_1_default ;
  long long *ldv_7_ldv_param_4_3_default ;
  long long ldv_7_ldv_param_5_1_default ;
  int ldv_7_ldv_param_5_2_default ;
  struct file *ldv_7_resource_file ;
  struct inode *ldv_7_resource_inode ;
  int ldv_7_ret_default ;
  unsigned long ldv_7_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 2211
  ldv_7_ret_default = 1;
#line 2216
  tmp = ldv_xmalloc(504UL);
#line 2216
  ldv_7_resource_file = (struct file *)tmp;
#line 2217
  tmp___0 = ldv_xmalloc(976UL);
#line 2217
  ldv_7_resource_inode = (struct inode *)tmp___0;
#line 2218
  tmp___1 = ldv_undef_int();
#line 2218
  ldv_7_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 2225
  goto ldv_main_7;
#line 2227
  return;
  ldv_main_7: 
  {
#line 2233
  tmp___3 = ldv_undef_int();
  }
#line 2233
  if (tmp___3 != 0) {
    {
#line 2236
    ldv_7_ret_default = ldv_file_operations_instance_probe_7_12(ldv_7_container_file_operations->open,
                                                                ldv_7_resource_inode,
                                                                ldv_7_resource_file);
#line 2238
    ldv_7_ret_default = ldv_filter_err_code(ldv_7_ret_default);
#line 2241
    tmp___2 = ldv_undef_int();
    }
#line 2241
    if (tmp___2 != 0) {
      {
#line 2243
      ldv_assume(ldv_7_ret_default == 0);
      }
#line 2250
      goto ldv_call_7;
    } else {
      {
#line 2254
      ldv_assume(ldv_7_ret_default != 0);
      }
#line 2261
      goto ldv_main_7;
    }
  } else {
    {
#line 2266
    ldv_free((void *)ldv_7_resource_file);
#line 2267
    ldv_free((void *)ldv_7_resource_inode);
    }
#line 2275
    return;
  }
#line 2278
  return;
  ldv_call_7: 
  {
#line 2284
  tmp___4 = ldv_undef_int();
  }
  {
#line 2285
  if (tmp___4 == 1) {
#line 2285
    goto case_1;
  } else {

  }
#line 2312
  if (tmp___4 == 2) {
#line 2312
    goto case_2;
  } else {

  }
#line 2325
  if (tmp___4 == 3) {
#line 2325
    goto case_3;
  } else {

  }
#line 2355
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2287
  tmp___5 = ldv_xmalloc(1UL);
#line 2287
  ldv_7_ldv_param_4_1_default = (char *)tmp___5;
#line 2288
  tmp___6 = ldv_xmalloc(8UL);
#line 2288
  ldv_7_ldv_param_4_3_default = (long long *)tmp___6;
#line 2293
  ldv_assume(ldv_7_size_cnt_write_size <= 2147479552UL);
  }
#line 2294
  if ((unsigned long )ldv_7_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 2296
    ldv_file_operations_instance_write_7_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_7_container_file_operations->write,
                                           ldv_7_resource_file, ldv_7_ldv_param_4_1_default,
                                           ldv_7_size_cnt_write_size, ldv_7_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 2301
  ldv_free((void *)ldv_7_ldv_param_4_1_default);
#line 2302
  ldv_free((void *)ldv_7_ldv_param_4_3_default);
  }
#line 2309
  goto ldv_call_7;
  case_2: /* CIL Label */ 
  {
#line 2315
  ldv_file_operations_instance_release_7_2(ldv_7_container_file_operations->release,
                                           ldv_7_resource_inode, ldv_7_resource_file);
  }
#line 2322
  goto ldv_main_7;
  case_3: /* CIL Label */ 
  {
#line 2329
  tmp___9 = ldv_undef_int();
  }
#line 2329
  if (tmp___9 != 0) {
    {
#line 2331
    tmp___7 = ldv_xmalloc(1UL);
#line 2331
    ldv_7_ldv_param_22_1_default = (char *)tmp___7;
#line 2332
    tmp___8 = ldv_xmalloc(8UL);
#line 2332
    ldv_7_ldv_param_22_3_default = (long long *)tmp___8;
#line 2337
    ldv_file_operations_instance_callback_7_22(ldv_7_callback_read, ldv_7_resource_file,
                                               ldv_7_ldv_param_22_1_default, ldv_7_size_cnt_write_size,
                                               ldv_7_ldv_param_22_3_default);
#line 2341
    ldv_free((void *)ldv_7_ldv_param_22_1_default);
#line 2342
    ldv_free((void *)ldv_7_ldv_param_22_3_default);
    }
  } else {
    {
#line 2349
    ldv_file_operations_instance_callback_7_5(ldv_7_callback_llseek, ldv_7_resource_file,
                                              ldv_7_ldv_param_5_1_default, ldv_7_ldv_param_5_2_default);
    }
  }
#line 2353
  goto ldv_40204;
  switch_default: /* CIL Label */ 
  {
#line 2355
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40204: ;
#line 2364
  goto ldv_call_7;
#line 2366
  goto ldv_call_7;
#line 2368
  return;
}
}
#line 2373 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_8(void *arg0 ) 
{ 
  long long (*ldv_8_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_8_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_8_container_file_operations ;
  char *ldv_8_ldv_param_22_1_default ;
  long long *ldv_8_ldv_param_22_3_default ;
  char *ldv_8_ldv_param_4_1_default ;
  long long *ldv_8_ldv_param_4_3_default ;
  long long ldv_8_ldv_param_5_1_default ;
  int ldv_8_ldv_param_5_2_default ;
  struct file *ldv_8_resource_file ;
  struct inode *ldv_8_resource_inode ;
  int ldv_8_ret_default ;
  unsigned long ldv_8_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 2391
  ldv_8_ret_default = 1;
#line 2396
  tmp = ldv_xmalloc(504UL);
#line 2396
  ldv_8_resource_file = (struct file *)tmp;
#line 2397
  tmp___0 = ldv_xmalloc(976UL);
#line 2397
  ldv_8_resource_inode = (struct inode *)tmp___0;
#line 2398
  tmp___1 = ldv_undef_int();
#line 2398
  ldv_8_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 2405
  goto ldv_main_8;
#line 2407
  return;
  ldv_main_8: 
  {
#line 2413
  tmp___3 = ldv_undef_int();
  }
#line 2413
  if (tmp___3 != 0) {
    {
#line 2416
    ldv_8_ret_default = ldv_file_operations_instance_probe_8_12(ldv_8_container_file_operations->open,
                                                                ldv_8_resource_inode,
                                                                ldv_8_resource_file);
#line 2418
    ldv_8_ret_default = ldv_filter_err_code(ldv_8_ret_default);
#line 2421
    tmp___2 = ldv_undef_int();
    }
#line 2421
    if (tmp___2 != 0) {
      {
#line 2423
      ldv_assume(ldv_8_ret_default == 0);
      }
#line 2430
      goto ldv_call_8;
    } else {
      {
#line 2434
      ldv_assume(ldv_8_ret_default != 0);
      }
#line 2441
      goto ldv_main_8;
    }
  } else {
    {
#line 2446
    ldv_free((void *)ldv_8_resource_file);
#line 2447
    ldv_free((void *)ldv_8_resource_inode);
    }
#line 2455
    return;
  }
#line 2458
  return;
  ldv_call_8: 
  {
#line 2464
  tmp___4 = ldv_undef_int();
  }
  {
#line 2465
  if (tmp___4 == 1) {
#line 2465
    goto case_1;
  } else {

  }
#line 2492
  if (tmp___4 == 2) {
#line 2492
    goto case_2;
  } else {

  }
#line 2505
  if (tmp___4 == 3) {
#line 2505
    goto case_3;
  } else {

  }
#line 2535
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2467
  tmp___5 = ldv_xmalloc(1UL);
#line 2467
  ldv_8_ldv_param_4_1_default = (char *)tmp___5;
#line 2468
  tmp___6 = ldv_xmalloc(8UL);
#line 2468
  ldv_8_ldv_param_4_3_default = (long long *)tmp___6;
#line 2473
  ldv_assume(ldv_8_size_cnt_write_size <= 2147479552UL);
  }
#line 2474
  if ((unsigned long )ldv_8_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 2476
    ldv_file_operations_instance_write_8_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_8_container_file_operations->write,
                                           ldv_8_resource_file, ldv_8_ldv_param_4_1_default,
                                           ldv_8_size_cnt_write_size, ldv_8_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 2481
  ldv_free((void *)ldv_8_ldv_param_4_1_default);
#line 2482
  ldv_free((void *)ldv_8_ldv_param_4_3_default);
  }
#line 2489
  goto ldv_call_8;
  case_2: /* CIL Label */ 
  {
#line 2495
  ldv_file_operations_instance_release_8_2(ldv_8_container_file_operations->release,
                                           ldv_8_resource_inode, ldv_8_resource_file);
  }
#line 2502
  goto ldv_main_8;
  case_3: /* CIL Label */ 
  {
#line 2509
  tmp___9 = ldv_undef_int();
  }
#line 2509
  if (tmp___9 != 0) {
    {
#line 2511
    tmp___7 = ldv_xmalloc(1UL);
#line 2511
    ldv_8_ldv_param_22_1_default = (char *)tmp___7;
#line 2512
    tmp___8 = ldv_xmalloc(8UL);
#line 2512
    ldv_8_ldv_param_22_3_default = (long long *)tmp___8;
#line 2517
    ldv_file_operations_instance_callback_8_22(ldv_8_callback_read, ldv_8_resource_file,
                                               ldv_8_ldv_param_22_1_default, ldv_8_size_cnt_write_size,
                                               ldv_8_ldv_param_22_3_default);
#line 2521
    ldv_free((void *)ldv_8_ldv_param_22_1_default);
#line 2522
    ldv_free((void *)ldv_8_ldv_param_22_3_default);
    }
  } else {
    {
#line 2529
    ldv_file_operations_instance_callback_8_5(ldv_8_callback_llseek, ldv_8_resource_file,
                                              ldv_8_ldv_param_5_1_default, ldv_8_ldv_param_5_2_default);
    }
  }
#line 2533
  goto ldv_40234;
  switch_default: /* CIL Label */ 
  {
#line 2535
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40234: ;
#line 2544
  goto ldv_call_8;
#line 2546
  goto ldv_call_8;
#line 2548
  return;
}
}
#line 2553 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_file_operations_instance_9(void *arg0 ) 
{ 
  long long (*ldv_9_callback_llseek)(struct file * , long long  , int  ) ;
  long (*ldv_9_callback_read)(struct file * , char * , unsigned long  , long long * ) ;
  struct file_operations *ldv_9_container_file_operations ;
  char *ldv_9_ldv_param_22_1_default ;
  long long *ldv_9_ldv_param_22_3_default ;
  char *ldv_9_ldv_param_4_1_default ;
  long long *ldv_9_ldv_param_4_3_default ;
  long long ldv_9_ldv_param_5_1_default ;
  int ldv_9_ldv_param_5_2_default ;
  struct file *ldv_9_resource_file ;
  struct inode *ldv_9_resource_inode ;
  int ldv_9_ret_default ;
  unsigned long ldv_9_size_cnt_write_size ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 2571
  ldv_9_ret_default = 1;
#line 2576
  tmp = ldv_xmalloc(504UL);
#line 2576
  ldv_9_resource_file = (struct file *)tmp;
#line 2577
  tmp___0 = ldv_xmalloc(976UL);
#line 2577
  ldv_9_resource_inode = (struct inode *)tmp___0;
#line 2578
  tmp___1 = ldv_undef_int();
#line 2578
  ldv_9_size_cnt_write_size = (unsigned long )tmp___1;
  }
#line 2585
  goto ldv_main_9;
#line 2587
  return;
  ldv_main_9: 
  {
#line 2593
  tmp___3 = ldv_undef_int();
  }
#line 2593
  if (tmp___3 != 0) {
    {
#line 2596
    ldv_9_ret_default = ldv_file_operations_instance_probe_9_12(ldv_9_container_file_operations->open,
                                                                ldv_9_resource_inode,
                                                                ldv_9_resource_file);
#line 2598
    ldv_9_ret_default = ldv_filter_err_code(ldv_9_ret_default);
#line 2601
    tmp___2 = ldv_undef_int();
    }
#line 2601
    if (tmp___2 != 0) {
      {
#line 2603
      ldv_assume(ldv_9_ret_default == 0);
      }
#line 2610
      goto ldv_call_9;
    } else {
      {
#line 2614
      ldv_assume(ldv_9_ret_default != 0);
      }
#line 2621
      goto ldv_main_9;
    }
  } else {
    {
#line 2626
    ldv_free((void *)ldv_9_resource_file);
#line 2627
    ldv_free((void *)ldv_9_resource_inode);
    }
#line 2635
    return;
  }
#line 2638
  return;
  ldv_call_9: 
  {
#line 2644
  tmp___4 = ldv_undef_int();
  }
  {
#line 2645
  if (tmp___4 == 1) {
#line 2645
    goto case_1;
  } else {

  }
#line 2672
  if (tmp___4 == 2) {
#line 2672
    goto case_2;
  } else {

  }
#line 2685
  if (tmp___4 == 3) {
#line 2685
    goto case_3;
  } else {

  }
#line 2715
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2647
  tmp___5 = ldv_xmalloc(1UL);
#line 2647
  ldv_9_ldv_param_4_1_default = (char *)tmp___5;
#line 2648
  tmp___6 = ldv_xmalloc(8UL);
#line 2648
  ldv_9_ldv_param_4_3_default = (long long *)tmp___6;
#line 2653
  ldv_assume(ldv_9_size_cnt_write_size <= 2147479552UL);
  }
#line 2654
  if ((unsigned long )ldv_9_container_file_operations->write != (unsigned long )((ssize_t (*)(struct file * ,
                                                                                              char const   * ,
                                                                                              size_t  ,
                                                                                              loff_t * ))0)) {
    {
#line 2656
    ldv_file_operations_instance_write_9_4((long (*)(struct file * , char * , unsigned long  ,
                                                     long long * ))ldv_9_container_file_operations->write,
                                           ldv_9_resource_file, ldv_9_ldv_param_4_1_default,
                                           ldv_9_size_cnt_write_size, ldv_9_ldv_param_4_3_default);
    }
  } else {

  }
  {
#line 2661
  ldv_free((void *)ldv_9_ldv_param_4_1_default);
#line 2662
  ldv_free((void *)ldv_9_ldv_param_4_3_default);
  }
#line 2669
  goto ldv_call_9;
  case_2: /* CIL Label */ 
  {
#line 2675
  ldv_file_operations_instance_release_9_2(ldv_9_container_file_operations->release,
                                           ldv_9_resource_inode, ldv_9_resource_file);
  }
#line 2682
  goto ldv_main_9;
  case_3: /* CIL Label */ 
  {
#line 2689
  tmp___9 = ldv_undef_int();
  }
#line 2689
  if (tmp___9 != 0) {
    {
#line 2691
    tmp___7 = ldv_xmalloc(1UL);
#line 2691
    ldv_9_ldv_param_22_1_default = (char *)tmp___7;
#line 2692
    tmp___8 = ldv_xmalloc(8UL);
#line 2692
    ldv_9_ldv_param_22_3_default = (long long *)tmp___8;
#line 2697
    ldv_file_operations_instance_callback_9_22(ldv_9_callback_read, ldv_9_resource_file,
                                               ldv_9_ldv_param_22_1_default, ldv_9_size_cnt_write_size,
                                               ldv_9_ldv_param_22_3_default);
#line 2701
    ldv_free((void *)ldv_9_ldv_param_22_1_default);
#line 2702
    ldv_free((void *)ldv_9_ldv_param_22_3_default);
    }
  } else {
    {
#line 2709
    ldv_file_operations_instance_callback_9_5(ldv_9_callback_llseek, ldv_9_resource_file,
                                              ldv_9_ldv_param_5_1_default, ldv_9_ldv_param_5_2_default);
    }
  }
#line 2713
  goto ldv_40264;
  switch_default: /* CIL Label */ 
  {
#line 2715
  ldv_stop();
  }
  switch_break: /* CIL Label */ ;
  }
  ldv_40264: ;
#line 2724
  goto ldv_call_9;
#line 2726
  goto ldv_call_9;
#line 2728
  return;
}
}
#line 2733 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_0_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2734
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2735
  return;
}
}
#line 2738 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_0_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2739
  seq_lseek(arg1, arg2, arg3);
  }
#line 2740
  return;
}
}
#line 2743 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_10_22(long (*arg0)(struct file * , char * ,
                                                              unsigned long  , long long * ) ,
                                                 struct file *arg1 , char *arg2 ,
                                                 unsigned long arg3 , long long *arg4 ) 
{ 


  {
  {
#line 2744
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2745
  return;
}
}
#line 2748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_10_5(long long (*arg0)(struct file * ,
                                                                  long long  , int  ) ,
                                                struct file *arg1 , long long arg2 ,
                                                int arg3 ) 
{ 


  {
  {
#line 2749
  seq_lseek(arg1, arg2, arg3);
  }
#line 2750
  return;
}
}
#line 2753 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_1_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2754
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2755
  return;
}
}
#line 2758 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_1_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2759
  seq_lseek(arg1, arg2, arg3);
  }
#line 2760
  return;
}
}
#line 2763 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_2_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2764
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2765
  return;
}
}
#line 2768 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_2_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2769
  seq_lseek(arg1, arg2, arg3);
  }
#line 2770
  return;
}
}
#line 2773 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_3_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2774
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2775
  return;
}
}
#line 2778 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_3_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2779
  seq_lseek(arg1, arg2, arg3);
  }
#line 2780
  return;
}
}
#line 2783 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_4_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2784
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2785
  return;
}
}
#line 2788 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_4_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2789
  seq_lseek(arg1, arg2, arg3);
  }
#line 2790
  return;
}
}
#line 2793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_5_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2794
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2795
  return;
}
}
#line 2798 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_5_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2799
  seq_lseek(arg1, arg2, arg3);
  }
#line 2800
  return;
}
}
#line 2803 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_6_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2804
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2805
  return;
}
}
#line 2808 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_6_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2809
  seq_lseek(arg1, arg2, arg3);
  }
#line 2810
  return;
}
}
#line 2813 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_7_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2814
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2815
  return;
}
}
#line 2818 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_7_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2819
  seq_lseek(arg1, arg2, arg3);
  }
#line 2820
  return;
}
}
#line 2823 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_8_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2824
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2825
  return;
}
}
#line 2828 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_8_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2829
  seq_lseek(arg1, arg2, arg3);
  }
#line 2830
  return;
}
}
#line 2833 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_9_22(long (*arg0)(struct file * , char * ,
                                                             unsigned long  , long long * ) ,
                                                struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                                long long *arg4 ) 
{ 


  {
  {
#line 2834
  seq_read(arg1, arg2, arg3, arg4);
  }
#line 2835
  return;
}
}
#line 2838 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_callback_9_5(long long (*arg0)(struct file * , long long  ,
                                                                 int  ) , struct file *arg1 ,
                                               long long arg2 , int arg3 ) 
{ 


  {
  {
#line 2839
  seq_lseek(arg1, arg2, arg3);
  }
#line 2840
  return;
}
}
#line 2843 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_0_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2844
  tmp = ide_capacity_proc_open(arg1, arg2);
  }
#line 2844
  return (tmp);
}
}
#line 2848 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_10_12(int (*arg0)(struct inode * , struct file * ) ,
                                             struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2849
  tmp = ide_settings_proc_open(arg1, arg2);
  }
#line 2849
  return (tmp);
}
}
#line 2853 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_1_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2854
  tmp = ide_channel_proc_open(arg1, arg2);
  }
#line 2854
  return (tmp);
}
}
#line 2858 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_2_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2859
  tmp = ide_dmodel_proc_open(arg1, arg2);
  }
#line 2859
  return (tmp);
}
}
#line 2863 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_3_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2864
  tmp = ide_driver_proc_open(arg1, arg2);
  }
#line 2864
  return (tmp);
}
}
#line 2868 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_4_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2869
  tmp = ide_drivers_open(arg1, arg2);
  }
#line 2869
  return (tmp);
}
}
#line 2873 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_5_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2874
  tmp = ide_geometry_proc_open(arg1, arg2);
  }
#line 2874
  return (tmp);
}
}
#line 2878 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_6_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2879
  tmp = ide_identify_proc_open(arg1, arg2);
  }
#line 2879
  return (tmp);
}
}
#line 2883 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_7_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2884
  tmp = ide_imodel_proc_open(arg1, arg2);
  }
#line 2884
  return (tmp);
}
}
#line 2888 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_8_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2889
  tmp = ide_mate_proc_open(arg1, arg2);
  }
#line 2889
  return (tmp);
}
}
#line 2893 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
int ldv_file_operations_instance_probe_9_12(int (*arg0)(struct inode * , struct file * ) ,
                                            struct inode *arg1 , struct file *arg2 ) 
{ 
  int tmp ;

  {
  {
#line 2894
  tmp = ide_media_proc_open(arg1, arg2);
  }
#line 2894
  return (tmp);
}
}
#line 2898 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_0_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2899
  single_release(arg1, arg2);
  }
#line 2900
  return;
}
}
#line 2903 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_10_2(int (*arg0)(struct inode * , struct file * ) ,
                                               struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2904
  single_release(arg1, arg2);
  }
#line 2905
  return;
}
}
#line 2908 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_1_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2909
  single_release(arg1, arg2);
  }
#line 2910
  return;
}
}
#line 2913 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_2_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2914
  single_release(arg1, arg2);
  }
#line 2915
  return;
}
}
#line 2918 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_3_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2919
  single_release(arg1, arg2);
  }
#line 2920
  return;
}
}
#line 2923 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_4_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2924
  single_release(arg1, arg2);
  }
#line 2925
  return;
}
}
#line 2928 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_5_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2929
  single_release(arg1, arg2);
  }
#line 2930
  return;
}
}
#line 2933 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_6_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2934
  single_release(arg1, arg2);
  }
#line 2935
  return;
}
}
#line 2938 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_7_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2939
  single_release(arg1, arg2);
  }
#line 2940
  return;
}
}
#line 2943 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_8_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2944
  single_release(arg1, arg2);
  }
#line 2945
  return;
}
}
#line 2948 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_release_9_2(int (*arg0)(struct inode * , struct file * ) ,
                                              struct inode *arg1 , struct file *arg2 ) 
{ 


  {
  {
#line 2949
  single_release(arg1, arg2);
  }
#line 2950
  return;
}
}
#line 2953 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_write_10_4(long (*arg0)(struct file * , char * ,
                                                          unsigned long  , long long * ) ,
                                             struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                             long long *arg4 ) 
{ 


  {
  {
#line 2954
  ide_settings_proc_write(arg1, (char const   *)arg2, arg3, arg4);
  }
#line 2955
  return;
}
}
#line 2958 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
void ldv_file_operations_instance_write_3_4(long (*arg0)(struct file * , char * ,
                                                         unsigned long  , long long * ) ,
                                            struct file *arg1 , char *arg2 , unsigned long arg3 ,
                                            long long *arg4 ) 
{ 


  {
  {
#line 2959
  ide_driver_proc_write(arg1, (char const   *)arg2, arg3, arg4);
  }
#line 2960
  return;
}
}
#line 3652 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_lock_96___1(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3656
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3657
  return;
}
}
#line 3659 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_unlock_97___1(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3663
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3664
  return;
}
}
#line 3666 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static unsigned long ldv___get_free_pages_98(gfp_t flags , unsigned int ldv_func_arg2 ) 
{ 
  void *tmp ;

  {
  {
#line 3669
  ldv_check_alloc_flags(flags);
#line 3670
  tmp = ldv_malloc_unknown_size();
  }
#line 3670
  return ((unsigned long )((unsigned int )((long )tmp)));
}
}
#line 3673 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3677
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3678
  return;
}
}
#line 3680 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_unlock_100(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3684
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3685
  return;
}
}
#line 3687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3691
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3692
  return;
}
}
#line 3694 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_lock_102___0(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3698
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3699
  return;
}
}
#line 3701 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_unlock_103___0(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3705
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3706
  return;
}
}
#line 3708 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_lock_104___0(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3712
  ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3713
  return;
}
}
#line 3715 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-proc.c.aux"
static void ldv_mutex_unlock_105___0(struct mutex *ldv_func_arg1 ) 
{ 


  {
  {
#line 3719
  ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(ldv_func_arg1);
  }
#line 3720
  return;
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/slab.h"
__inline static void *kzalloc(size_t size , gfp_t flags ) ;
#line 499 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpixf.h"
extern acpi_status acpi_evaluate_object(acpi_handle  , acpi_string  , struct acpi_object_list * ,
                                        struct acpi_buffer * ) ;
#line 515
extern acpi_status acpi_get_object_info(acpi_handle  , struct acpi_device_info ** ) ;
#line 452 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/acpi/acpi_bus.h"
extern int acpi_bus_get_device(acpi_handle  , struct acpi_device ** ) ;
#line 459
extern int acpi_bus_set_power(acpi_handle  , int  ) ;
#line 536
extern struct acpi_device *acpi_find_child_device(struct acpi_device * , u64  , bool  ) ;
#line 51 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/acpi.h"
__inline static acpi_handle acpi_device_handle(struct acpi_device *adev ) 
{ 


  {
#line 53
  return ((unsigned long )adev != (unsigned long )((struct acpi_device *)0) ? adev->handle : (acpi_handle )0);
}
}
#line 96 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/dmi.h"
extern int dmi_check_system(struct dmi_system_id  const  * ) ;
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static bool ide_noacpi  ;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static bool ide_acpigtf  ;
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static bool ide_acpionboot  ;
#line 66 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static bool ide_noacpi_psx  ;
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static int no_acpi_psx(struct dmi_system_id  const  *id ) 
{ 


  {
  {
#line 69
  ide_noacpi_psx = 1;
#line 70
  printk("\r%s detected - disable ACPI _PSx.\n", id->ident);
  }
#line 71
  return (0);
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static struct dmi_system_id  const  ide_acpi_dmi_table[2U]  = {      {& no_acpi_psx, "HP nx9005", {{1U, (unsigned char)0, {'P', 'h', 'o', 'e', 'n',
                                                           'i', 'x', ' ', 'T', 'e',
                                                           'c', 'h', 'n', 'o', 'l',
                                                           'o', 'g', 'i', 'e', 's',
                                                           ' ', 'L', 't', 'd', '.',
                                                           '\000'}}, {2U, (unsigned char)0,
                                                                      {'K', 'A', 'M',
                                                                       '1', '.', '6',
                                                                       '0', '\000'}}},
      0}};
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
int ide_acpi_init(void) 
{ 


  {
  {
#line 91
  dmi_check_system((struct dmi_system_id  const  *)(& ide_acpi_dmi_table));
  }
#line 92
  return (0);
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
bool ide_port_acpi(ide_hwif_t *hwif ) 
{ 


  {
#line 97
  return ((bool )(! ide_noacpi && (unsigned long )hwif->acpidata != (unsigned long )((struct ide_acpi_hwif_link *)0)));
}
}
#line 100 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static acpi_handle acpi_get_child(acpi_handle handle , u64 addr ) 
{ 
  struct acpi_device *adev ;
  int tmp ;

  {
#line 104
  if ((unsigned long )handle == (unsigned long )((acpi_handle )0)) {
#line 105
    return ((acpi_handle )0);
  } else {
    {
#line 104
    tmp = acpi_bus_get_device(handle, & adev);
    }
#line 104
    if (tmp != 0) {
#line 105
      return ((acpi_handle )0);
    } else {

    }
  }
  {
#line 107
  adev = acpi_find_child_device(adev, addr, 0);
  }
#line 108
  return ((unsigned long )adev != (unsigned long )((struct acpi_device *)0) ? adev->handle : (acpi_handle )0);
}
}
#line 121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static int ide_get_dev_handle(struct device *dev , acpi_handle **handle , u64 *pcidevfn ) 
{ 
  struct pci_dev *pdev ;
  struct device  const  *__mptr ;
  unsigned int bus ;
  unsigned int devnum ;
  unsigned int func ;
  u64 addr ;
  acpi_handle dev_handle ;
  acpi_status status ;
  struct acpi_device_info *dinfo ;
  int ret ;

  {
  {
#line 124
  __mptr = (struct device  const  *)dev;
#line 124
  pdev = (struct pci_dev *)__mptr + 0xffffffffffffff68UL;
#line 129
  dinfo = (struct acpi_device_info *)0;
#line 130
  ret = -19;
#line 132
  bus = (unsigned int )(pdev->bus)->number;
#line 133
  devnum = (pdev->devfn >> 3) & 31U;
#line 134
  func = pdev->devfn & 7U;
#line 136
  addr = (unsigned long long )((devnum << 16) | func);
#line 140
  dev_handle = acpi_device_handle(dev->acpi_node.companion);
  }
#line 141
  if ((unsigned long )dev_handle == (unsigned long )((acpi_handle )0)) {
#line 143
    goto err;
  } else {

  }
  {
#line 146
  status = acpi_get_object_info(dev_handle, & dinfo);
  }
#line 147
  if (status != 0U) {
#line 149
    goto err;
  } else {

  }
#line 151
  if (((unsigned long )dinfo != (unsigned long )((struct acpi_device_info *)0) && ((int )dinfo->valid & 2) != 0) && dinfo->address == addr) {
#line 153
    *pcidevfn = addr;
#line 154
    *handle = dev_handle;
  } else {
#line 160
    goto err;
  }
#line 165
  ret = 0;
  err: 
  {
#line 167
  kfree((void const   *)dinfo);
  }
#line 168
  return (ret);
}
}
#line 179 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static acpi_handle ide_acpi_hwif_get_handle(ide_hwif_t *hwif ) 
{ 
  struct device *dev ;
  acpi_handle dev_handle ;
  u64 pcidevfn ;
  acpi_handle chan_handle ;
  int err ;

  {
#line 181
  dev = hwif->gendev.parent;
#line 182
  dev_handle = dev_handle;
#line 189
  if ((unsigned long )dev == (unsigned long )((struct device *)0)) {
#line 191
    return ((acpi_handle )0);
  } else {

  }
  {
#line 194
  err = ide_get_dev_handle(dev, & dev_handle, & pcidevfn);
  }
#line 195
  if (err < 0) {
#line 197
    return ((acpi_handle )0);
  } else {

  }
  {
#line 203
  chan_handle = acpi_get_child(dev_handle, (u64 )hwif->channel);
  }
#line 207
  return (chan_handle);
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static int do_drive_get_GTF(ide_drive_t *drive , unsigned int *gtf_length , unsigned long *gtf_address ,
                            unsigned long *obj_loc ) 
{ 
  acpi_status status ;
  struct acpi_buffer output ;
  union acpi_object *out_obj ;
  int err ;

  {
#line 232
  err = -19;
#line 234
  *gtf_length = 0U;
#line 235
  *gtf_address = 0UL;
#line 236
  *obj_loc = 0UL;
#line 238
  if ((unsigned long )(drive->acpidata)->obj_handle == (unsigned long )((acpi_handle )0)) {
#line 240
    goto out;
  } else {

  }
  {
#line 244
  output.length = 0xffffffffffffffffULL;
#line 245
  output.pointer = (void *)0;
#line 248
  err = -5;
#line 249
  status = acpi_evaluate_object((drive->acpidata)->obj_handle, (char *)"_GTF", (struct acpi_object_list *)0,
                                & output);
  }
#line 251
  if (status != 0U) {
    {
#line 252
    printk("\017%s: Run _GTF error: status = 0x%x\n", "do_drive_get_GTF", status);
    }
#line 255
    goto out;
  } else {

  }
#line 258
  if (output.length == 0ULL || (unsigned long )output.pointer == (unsigned long )((void *)0)) {
#line 263
    goto out;
  } else {

  }
#line 266
  out_obj = (union acpi_object *)output.pointer;
#line 267
  if (out_obj->type != 3U) {
    {
#line 271
    err = -2;
#line 272
    kfree((void const   *)output.pointer);
    }
#line 273
    goto out;
  } else {

  }
#line 276
  if ((out_obj->buffer.length == 0U || (unsigned long )out_obj->buffer.pointer == (unsigned long )((u8 *)0U)) || out_obj->buffer.length % 7U != 0U) {
    {
#line 278
    printk("\v%s: unexpected GTF length (%d) or addr (0x%p)\n", "do_drive_get_GTF",
           out_obj->buffer.length, out_obj->buffer.pointer);
#line 282
    err = -2;
#line 283
    kfree((void const   *)output.pointer);
    }
#line 284
    goto out;
  } else {

  }
#line 287
  *gtf_length = out_obj->buffer.length;
#line 288
  *gtf_address = (unsigned long )out_obj->buffer.pointer;
#line 289
  *obj_loc = (unsigned long )out_obj;
#line 292
  err = 0;
  out: ;
#line 294
  return (err);
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
static int do_drive_set_taskfiles(ide_drive_t *drive , unsigned int gtf_length , unsigned long gtf_address ) 
{ 
  int rc ;
  int err ;
  int gtf_count ;
  int ix ;
  u8 *gtf ;
  struct ide_cmd cmd ;

  {
#line 310
  rc = 0;
#line 311
  gtf_count = (int )(gtf_length / 7U);
#line 318
  ix = 0;
#line 318
  goto ldv_42854;
  ldv_42853: 
#line 319
  gtf = (u8 *)(gtf_address + (unsigned long )(ix * 7));
#line 327
  if (! ide_acpigtf) {
#line 329
    goto ldv_42851;
  } else {

  }
  {
#line 333
  __memset((void *)(& cmd), 0, 80UL);
#line 334
  __memcpy((void *)(& cmd.tf.__annonCompField83.feature), (void const   *)gtf, 7UL);
#line 335
  cmd.valid.out.tf = 126U;
#line 336
  cmd.valid.in.tf = 124U;
#line 338
  err = ide_no_data_taskfile(drive, & cmd);
  }
#line 339
  if (err != 0) {
    {
#line 340
    printk("\v%s: ide_no_data_taskfile failed: %u\n", "do_drive_set_taskfiles", err);
#line 342
    rc = err;
    }
  } else {

  }
  ldv_42851: 
#line 318
  ix = ix + 1;
  ldv_42854: ;
#line 318
  if (ix < gtf_count) {
#line 320
    goto ldv_42853;
  } else {

  }

#line 346
  return (rc);
}
}
#line 361 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
int ide_acpi_exec_tfs(ide_drive_t *drive ) 
{ 
  int ret ;
  unsigned int gtf_length ;
  unsigned long gtf_address ;
  unsigned long obj_loc ;

  {
  {
#line 370
  ret = do_drive_get_GTF(drive, & gtf_length, & gtf_address, & obj_loc);
  }
#line 371
  if (ret < 0) {
#line 373
    return (ret);
  } else {

  }
  {
#line 378
  ret = do_drive_set_taskfiles(drive, gtf_length, gtf_address);
#line 379
  kfree((void const   *)obj_loc);
  }
#line 386
  return (ret);
}
}
#line 396 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
void ide_acpi_get_timing(ide_hwif_t *hwif ) 
{ 
  acpi_status status ;
  struct acpi_buffer output ;
  union acpi_object *out_obj ;

  {
  {
#line 403
  output.length = 0xffffffffffffffffULL;
#line 404
  output.pointer = (void *)0;
#line 407
  status = acpi_evaluate_object((hwif->acpidata)->obj_handle, (char *)"_GTM", (struct acpi_object_list *)0,
                                & output);
  }
#line 414
  if (status != 0U) {
#line 416
    return;
  } else {

  }
#line 419
  if (output.length == 0ULL || (unsigned long )output.pointer == (unsigned long )((void *)0)) {
    {
#line 423
    kfree((void const   *)output.pointer);
    }
#line 424
    return;
  } else {

  }
#line 427
  out_obj = (union acpi_object *)output.pointer;
#line 428
  if (out_obj->type != 3U) {
    {
#line 432
    kfree((void const   *)output.pointer);
    }
#line 433
    return;
  } else {

  }
#line 436
  if ((out_obj->buffer.length == 0U || (unsigned long )out_obj->buffer.pointer == (unsigned long )((u8 *)0U)) || out_obj->buffer.length != 20U) {
    {
#line 438
    printk("\v%s: unexpected _GTM length (0x%x)[should be 0x%zx] or addr (0x%p)\n",
           "ide_acpi_get_timing", out_obj->buffer.length, 20UL, out_obj->buffer.pointer);
#line 443
    kfree((void const   *)output.pointer);
    }
#line 444
    return;
  } else {

  }
  {
#line 447
  __memcpy((void *)(& (hwif->acpidata)->gtm), (void const   *)out_obj->buffer.pointer,
           20UL);
#line 461
  kfree((void const   *)output.pointer);
  }
#line 462
  return;
}
}
#line 474 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
void ide_acpi_push_timing(ide_hwif_t *hwif ) 
{ 
  acpi_status status ;
  struct acpi_object_list input ;
  union acpi_object in_params[3U] ;
  struct ide_acpi_drive_link *master ;
  struct ide_acpi_drive_link *slave ;

  {
  {
#line 479
  master = & (hwif->acpidata)->master;
#line 480
  slave = & (hwif->acpidata)->slave;
#line 485
  input.count = 3U;
#line 486
  input.pointer = (union acpi_object *)(& in_params);
#line 487
  in_params[0].type = 3U;
#line 488
  in_params[0].buffer.length = 20U;
#line 489
  in_params[0].buffer.pointer = (u8 *)(& (hwif->acpidata)->gtm);
#line 490
  in_params[1].type = 3U;
#line 491
  in_params[1].buffer.length = 512U;
#line 492
  in_params[1].buffer.pointer = (u8 *)(& master->idbuff);
#line 493
  in_params[2].type = 3U;
#line 494
  in_params[2].buffer.length = 512U;
#line 495
  in_params[2].buffer.pointer = (u8 *)(& slave->idbuff);
#line 498
  status = acpi_evaluate_object((hwif->acpidata)->obj_handle, (char *)"_STM", & input,
                                (struct acpi_buffer *)0);
  }
#line 504
  return;
}
}
#line 515 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
void ide_acpi_set_state(ide_hwif_t *hwif , int on ) 
{ 
  ide_drive_t *drive ;
  int i ;

  {
#line 520
  if ((int )ide_noacpi_psx) {
#line 521
    return;
  } else {

  }
#line 526
  if (on != 0) {
    {
#line 527
    acpi_bus_set_power((hwif->acpidata)->obj_handle, 0);
    }
  } else {

  }
#line 529
  i = 0;
#line 529
  goto ldv_42885;
  ldv_42884: ;
#line 529
  if ((drive->dev_flags & 64UL) != 0UL) {
#line 530
    if ((unsigned long )(drive->acpidata)->obj_handle != (unsigned long )((acpi_handle )0)) {
      {
#line 531
      acpi_bus_set_power((drive->acpidata)->obj_handle, on != 0 ? 0 : 4);
      }
    } else {

    }
  } else {

  }
#line 529
  i = i + 1;
  ldv_42885: 
#line 529
  drive = hwif->devices[i];
#line 529
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 531
    goto ldv_42884;
  } else {

  }

#line 535
  if (on == 0) {
    {
#line 536
    acpi_bus_set_power((hwif->acpidata)->obj_handle, 4);
    }
  } else {

  }
#line 537
  return;
}
}
#line 551 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
void ide_acpi_init_port(ide_hwif_t *hwif ) 
{ 
  void *tmp ;

  {
  {
#line 553
  tmp = kzalloc(1080UL, 208U);
#line 553
  hwif->acpidata = (struct ide_acpi_hwif_link *)tmp;
  }
#line 554
  if ((unsigned long )hwif->acpidata == (unsigned long )((struct ide_acpi_hwif_link *)0)) {
#line 555
    return;
  } else {

  }
  {
#line 557
  (hwif->acpidata)->obj_handle = ide_acpi_hwif_get_handle(hwif);
  }
#line 558
  if ((unsigned long )(hwif->acpidata)->obj_handle == (unsigned long )((acpi_handle )0)) {
    {
#line 560
    kfree((void const   *)hwif->acpidata);
#line 561
    hwif->acpidata = (struct ide_acpi_hwif_link *)0;
    }
  } else {

  }
#line 563
  return;
}
}
#line 565 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/drivers/ide/ide-acpi.c"
void ide_acpi_port_init_devices(ide_hwif_t *hwif ) 
{ 
  ide_drive_t *drive ;
  int i ;
  int err ;
  acpi_handle dev_handle ;

  {
#line 570
  if ((unsigned long )hwif->acpidata == (unsigned long )((struct ide_acpi_hwif_link *)0)) {
#line 571
    return;
  } else {

  }
#line 578
  (hwif->devices[0])->acpidata = & (hwif->acpidata)->master;
#line 579
  (hwif->devices[1])->acpidata = & (hwif->acpidata)->slave;
#line 582
  i = 0;
#line 582
  goto ldv_42898;
  ldv_42897: ;
#line 582
  if ((drive->dev_flags & 64UL) != 0UL) {
    {
#line 589
    dev_handle = acpi_get_child((hwif->acpidata)->obj_handle, (u64 )drive->dn & 1ULL);
#line 594
    (drive->acpidata)->obj_handle = dev_handle;
    }
  } else {

  }
#line 582
  i = i + 1;
  ldv_42898: 
#line 582
  drive = hwif->devices[i];
#line 582
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 584
    goto ldv_42897;
  } else {

  }
#line 598
  i = 0;
#line 598
  goto ldv_42901;
  ldv_42900: ;
#line 598
  if ((drive->dev_flags & 64UL) != 0UL) {
    {
#line 599
    err = taskfile_lib_get_identify(drive, (u8 *)(& (drive->acpidata)->idbuff));
    }
  } else {

  }
#line 598
  i = i + 1;
  ldv_42901: 
#line 598
  drive = hwif->devices[i];
#line 598
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 600
    goto ldv_42900;
  } else {

  }

#line 605
  if ((int )ide_noacpi || ! ide_acpionboot) {
#line 607
    return;
  } else {

  }
  {
#line 611
  ide_acpi_set_state(hwif, 1);
#line 615
  ide_acpi_get_timing(hwif);
#line 616
  ide_acpi_push_timing(hwif);
#line 618
  i = 0;
  }
#line 618
  goto ldv_42904;
  ldv_42903: ;
#line 618
  if ((drive->dev_flags & 64UL) != 0UL) {
    {
#line 619
    ide_acpi_exec_tfs(drive);
    }
  } else {

  }
#line 618
  i = i + 1;
  ldv_42904: 
#line 618
  drive = hwif->devices[i];
#line 618
  if ((unsigned long )drive != (unsigned long )((ide_drive_t *)0) || i <= 1) {
#line 620
    goto ldv_42903;
  } else {

  }

#line 625
  return;
}
}
#line 639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/weaver/.tmp_ide-acpi.c.aux"
void ldv_dummy_resourceless_instance_callback_23_3(int (*arg0)(struct dmi_system_id * ) ,
                                                   struct dmi_system_id *arg1 ) 
{ 


  {
  {
#line 640
  no_acpi_psx((struct dmi_system_id  const  *)arg1);
  }
#line 641
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/irq.linux_alloc_irq.bk.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) ;
#line 50 "/home/ubuntu/klever-work/linux/ldv/irq.h"
bool ldv_in_interrupt_context(void) ;
#line 24 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_flags(gfp_t flags ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 27
  tmp = ldv_in_interrupt_context();
  }
#line 27
  if (tmp) {
#line 27
    tmp___0 = 0;
  } else {
#line 27
    tmp___0 = 1;
  }
  {
#line 27
  ldv_assert_linux_alloc_irq__wrong_flags(tmp___0 || flags == 32U);
  }
#line 28
  return;
}
}
#line 31 "/home/ubuntu/klever-work/linux/alloc/irq.c"
void ldv_linux_alloc_irq_check_alloc_nonatomic(void) 
{ 
  bool tmp ;

  {
  {
#line 33
  tmp = ldv_in_interrupt_context();
  }
#line 33
  if ((int )tmp) {
    {
#line 36
    ldv_assert_linux_alloc_irq__nonatomic(0);
    }
  } else {

  }
#line 37
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/spinlock.linux_alloc_spinlock.bk.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
int ldv_exclusive_spin_is_locked(void) ;
#line 25 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_flags(gfp_t flags ) 
{ 
  int tmp ;

  {
#line 27
  if (flags != 32U && flags != 0U) {
    {
#line 29
    tmp = ldv_exclusive_spin_is_locked();
#line 29
    ldv_assert_linux_alloc_spinlock__wrong_flags(tmp == 0);
    }
  } else {

  }
#line 30
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/alloc/spinlock.c"
void ldv_linux_alloc_spinlock_check_alloc_nonatomic(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_exclusive_spin_is_locked();
#line 37
  ldv_assert_linux_alloc_spinlock__nonatomic(tmp == 0);
  }
#line 38
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/usb lock.linux_alloc_usb_lock.bk.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) ;
#line 2
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_lock  =    1;
#line 26 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_flags(gfp_t flags ) 
{ 


  {
#line 28
  if (ldv_linux_alloc_usb_lock_lock == 2) {
    {
#line 31
    ldv_assert_linux_alloc_usb_lock__wrong_flags(flags == 16U || flags == 32U);
    }
  } else {

  }
#line 32
  return;
}
}
#line 36 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_check_alloc_nonatomic(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_alloc_usb_lock__nonatomic(ldv_linux_alloc_usb_lock_lock == 1);
  }
#line 40
  return;
}
}
#line 43 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_lock_device(void) 
{ 


  {
#line 46
  ldv_linux_alloc_usb_lock_lock = 2;
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_trylock_device(void) 
{ 
  int tmp ;

  {
#line 52
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 52
    tmp = ldv_undef_int();
    }
#line 52
    if (tmp != 0) {
#line 55
      ldv_linux_alloc_usb_lock_lock = 2;
#line 57
      return (1);
    } else {
#line 62
      return (0);
    }
  } else {
#line 62
    return (0);
  }
}
}
#line 67 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
int ldv_linux_alloc_usb_lock_usb_lock_device_for_reset(void) 
{ 
  int tmp ;

  {
#line 69
  if (ldv_linux_alloc_usb_lock_lock == 1) {
    {
#line 69
    tmp = ldv_undef_int();
    }
#line 69
    if (tmp != 0) {
#line 72
      ldv_linux_alloc_usb_lock_lock = 2;
#line 74
      return (0);
    } else {
#line 79
      return (-1);
    }
  } else {
#line 79
    return (-1);
  }
}
}
#line 84 "/home/ubuntu/klever-work/linux/alloc/usb lock.c"
void ldv_linux_alloc_usb_lock_usb_unlock_device(void) 
{ 


  {
#line 87
  ldv_linux_alloc_usb_lock_lock = 1;
#line 88
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_add(int i , atomic_t *v ) 
{ 


  {
#line 23
  v->counter = v->counter + i;
#line 24
  return;
}
}
#line 27 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_sub(int i , atomic_t *v ) 
{ 


  {
#line 29
  v->counter = v->counter - i;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_sub_and_test(int i , atomic_t *v ) 
{ 


  {
#line 35
  v->counter = v->counter - i;
#line 36
  if (v->counter != 0) {
#line 37
    return (0);
  } else {

  }
#line 39
  return (1);
}
}
#line 43 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_inc(atomic_t *v ) 
{ 


  {
#line 45
  v->counter = v->counter + 1;
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/atomic.c"
void ldv_linux_usb_dev_atomic_dec(atomic_t *v ) 
{ 


  {
#line 51
  v->counter = v->counter - 1;
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_dec_and_test(atomic_t *v ) 
{ 


  {
#line 57
  v->counter = v->counter - 1;
#line 58
  if (v->counter != 0) {
#line 59
    return (0);
  } else {

  }
#line 61
  return (1);
}
}
#line 65 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_and_test(atomic_t *v ) 
{ 


  {
#line 67
  v->counter = v->counter + 1;
#line 68
  if (v->counter != 0) {
#line 69
    return (0);
  } else {

  }
#line 71
  return (1);
}
}
#line 75 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_return(int i , atomic_t *v ) 
{ 


  {
#line 77
  v->counter = v->counter + i;
#line 78
  return (v->counter);
}
}
#line 82 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_add_negative(int i , atomic_t *v ) 
{ 


  {
#line 84
  v->counter = v->counter + i;
#line 85
  return (v->counter < 0);
}
}
#line 89 "/home/ubuntu/klever-work/linux/arch/atomic.c"
int ldv_linux_usb_dev_atomic_inc_short(short *v ) 
{ 


  {
#line 91
  *v = (short )((unsigned int )((unsigned short )*v) + 1U);
#line 92
  return ((int )*v);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/io.linux_arch_io.bk.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/verifier/nondet.h"
void *ldv_undef_ptr(void) ;
#line 22 "/home/ubuntu/klever-work/linux/arch/io.c"
int ldv_linux_arch_io_iomem  =    0;
#line 25 "/home/ubuntu/klever-work/linux/arch/io.c"
void *ldv_linux_arch_io_io_mem_remap(void) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_undef_ptr();
#line 27
  ptr = tmp;
  }
#line 29
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 31
    ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem + 1;
#line 33
    return (ptr);
  } else {

  }
#line 36
  return (ptr);
}
}
#line 40 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_io_mem_unmap(void) 
{ 


  {
  {
#line 43
  ldv_assert_linux_arch_io__less_initial_decrement(ldv_linux_arch_io_iomem > 0);
#line 45
  ldv_linux_arch_io_iomem = ldv_linux_arch_io_iomem - 1;
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/arch/io.c"
void ldv_linux_arch_io_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_arch_io__more_initial_at_exit(ldv_linux_arch_io_iomem == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/genhd.linux_block_genhd.bk.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) ;
#line 2
void ldv_assert_linux_block_genhd__double_allocation(int expr ) ;
#line 3
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) ;
#line 4
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) ;
#line 31 "/home/ubuntu/klever-work/linux/block/genhd.c"
static int ldv_linux_block_genhd_disk_state  =    0;
#line 34 "/home/ubuntu/klever-work/linux/block/genhd.c"
struct gendisk *ldv_linux_block_genhd_alloc_disk(void) 
{ 
  struct gendisk *res ;
  void *tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ptr();
#line 39
  res = (struct gendisk *)tmp;
#line 37
  ldv_assert_linux_block_genhd__double_allocation(ldv_linux_block_genhd_disk_state == 0);
  }
#line 41
  if ((unsigned long )res != (unsigned long )((struct gendisk *)0)) {
#line 43
    ldv_linux_block_genhd_disk_state = 1;
#line 45
    return (res);
  } else {

  }
#line 48
  return (res);
}
}
#line 52 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_add_disk(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_block_genhd__use_before_allocation(ldv_linux_block_genhd_disk_state == 1);
#line 57
  ldv_linux_block_genhd_disk_state = 2;
  }
#line 58
  return;
}
}
#line 61 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_del_gendisk(void) 
{ 


  {
  {
#line 64
  ldv_assert_linux_block_genhd__delete_before_add(ldv_linux_block_genhd_disk_state == 2);
#line 66
  ldv_linux_block_genhd_disk_state = 1;
  }
#line 67
  return;
}
}
#line 70 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_put_disk(struct gendisk *disk ) 
{ 


  {
#line 72
  if ((unsigned long )disk != (unsigned long )((struct gendisk *)0)) {
    {
#line 74
    ldv_assert_linux_block_genhd__free_before_allocation(ldv_linux_block_genhd_disk_state > 0);
#line 76
    ldv_linux_block_genhd_disk_state = 0;
    }
  } else {

  }
#line 78
  return;
}
}
#line 81 "/home/ubuntu/klever-work/linux/block/genhd.c"
void ldv_linux_block_genhd_check_final_state(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_block_genhd__more_initial_at_exit(ldv_linux_block_genhd_disk_state == 0);
  }
#line 85
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/queue.linux_block_queue.bk.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) ;
#line 2
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/block/queue.c"
static int ldv_linux_block_queue_queue_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/block/queue.c"
struct request_queue *ldv_linux_block_queue_request_queue(void) 
{ 
  struct request_queue *res ;
  void *tmp ;

  {
  {
#line 38
  tmp = ldv_undef_ptr();
#line 38
  res = (struct request_queue *)tmp;
#line 36
  ldv_assert_linux_block_queue__double_allocation(ldv_linux_block_queue_queue_state == 0);
  }
#line 40
  if ((unsigned long )res != (unsigned long )((struct request_queue *)0)) {
#line 42
    ldv_linux_block_queue_queue_state = 1;
#line 44
    return (res);
  } else {

  }
#line 47
  return (res);
}
}
#line 51 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_blk_cleanup_queue(void) 
{ 


  {
  {
#line 54
  ldv_assert_linux_block_queue__use_before_allocation(ldv_linux_block_queue_queue_state == 1);
#line 56
  ldv_linux_block_queue_queue_state = 0;
  }
#line 57
  return;
}
}
#line 60 "/home/ubuntu/klever-work/linux/block/queue.c"
void ldv_linux_block_queue_check_final_state(void) 
{ 


  {
  {
#line 63
  ldv_assert_linux_block_queue__more_initial_at_exit(ldv_linux_block_queue_queue_state == 0);
  }
#line 64
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/request.linux_block_request.bk.c"
void ldv_assert_linux_block_request__double_get(int expr ) ;
#line 2
void ldv_assert_linux_block_request__double_put(int expr ) ;
#line 3
void ldv_assert_linux_block_request__get_at_exit(int expr ) ;
#line 21 "/home/ubuntu/klever-work/linux/ldv/err.h"
long ldv_is_err(void const   *ptr ) ;
#line 32 "/home/ubuntu/klever-work/linux/block/request.c"
int ldv_linux_block_request_blk_rq  =    0;
#line 35 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_get_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;

  {
  {
#line 40
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 43
  tmp = ldv_undef_ptr();
#line 43
  res = (struct request *)tmp;
  }
#line 46
  if ((mask == 16U || mask == 208U) || mask == 16U) {
    {
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
    }
  } else {

  }
#line 49
  if ((unsigned long )res != (unsigned long )((struct request *)0)) {
#line 51
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 54
  return (res);
}
}
#line 58 "/home/ubuntu/klever-work/linux/block/request.c"
struct request *ldv_linux_block_request_blk_make_request(gfp_t mask ) 
{ 
  struct request *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 63
  ldv_assert_linux_block_request__double_get(ldv_linux_block_request_blk_rq == 0);
#line 66
  tmp = ldv_undef_ptr();
#line 66
  res = (struct request *)tmp;
#line 67
  ldv_assume((unsigned long )res != (unsigned long )((struct request *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
  }
#line 70
  if (tmp___0 == 0L) {
#line 72
    ldv_linux_block_request_blk_rq = 1;
  } else {

  }
#line 75
  return (res);
}
}
#line 79 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_put_blk_rq(void) 
{ 


  {
  {
#line 82
  ldv_assert_linux_block_request__double_put(ldv_linux_block_request_blk_rq == 1);
#line 84
  ldv_linux_block_request_blk_rq = 0;
  }
#line 85
  return;
}
}
#line 88 "/home/ubuntu/klever-work/linux/block/request.c"
void ldv_linux_block_request_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_block_request__get_at_exit(ldv_linux_block_request_blk_rq == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/class.linux_drivers_base_class.bk.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_nonpositive(void) ;
#line 33 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_usb_gadget_class  =    0;
#line 36 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void *ldv_linux_drivers_base_class_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 41
  is_got = ldv_undef_ptr();
#line 44
  ldv_assume((int )((long )is_got));
#line 47
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 47
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 52
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 56
  return (is_got);
}
}
#line 60 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
int ldv_linux_drivers_base_class_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 65
  is_reg = ldv_undef_int_nonpositive();
  }
#line 68
  if (is_reg == 0) {
    {
#line 71
    ldv_assert_linux_drivers_base_class__double_registration(ldv_linux_drivers_base_class_usb_gadget_class == 0);
#line 73
    ldv_linux_drivers_base_class_usb_gadget_class = 1;
    }
  } else {

  }
#line 77
  return (is_reg);
}
}
#line 81 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_unregister_class(void) 
{ 


  {
  {
#line 84
  ldv_assert_linux_drivers_base_class__double_deregistration(ldv_linux_drivers_base_class_usb_gadget_class == 1);
#line 86
  ldv_linux_drivers_base_class_usb_gadget_class = 0;
  }
#line 87
  return;
}
}
#line 89 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 91
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 92
    return;
  } else {
    {
#line 91
    tmp = ldv_is_err((void const   *)cls);
    }
#line 91
    if (tmp != 0L) {
#line 92
      return;
    } else {

    }
  }
  {
#line 93
  ldv_linux_drivers_base_class_unregister_class();
  }
#line 94
  return;
}
}
#line 97 "/home/ubuntu/klever-work/linux/drivers/base/class.c"
void ldv_linux_drivers_base_class_check_final_state(void) 
{ 


  {
  {
#line 100
  ldv_assert_linux_drivers_base_class__registered_at_exit(ldv_linux_drivers_base_class_usb_gadget_class == 0);
  }
#line 101
  return;
}
}
#line 35 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_xzalloc(size_t size ) ;
#line 26 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
void *ldv_dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
#line 28
  if ((unsigned long )dev != (unsigned long )((struct device  const  *)0) && (unsigned long )dev->p != (unsigned long )((struct device_private */* const  */)0)) {
#line 29
    return ((dev->p)->driver_data);
  } else {

  }
#line 30
  return ((void *)0);
}
}
#line 39 "/home/ubuntu/klever-work/linux/drivers/base/dd.c"
int ldv_dev_set_drvdata(struct device *dev , void *data ) 
{ 
  void *tmp ;

  {
  {
#line 41
  tmp = ldv_xzalloc(8UL);
#line 41
  dev->p = (struct device_private *)tmp;
#line 42
  (dev->p)->driver_data = data;
  }
#line 43
  return (0);
}
}
#line 31 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_zalloc(size_t size ) ;
#line 23 "/home/ubuntu/klever-work/linux/drivers/spi.c"
struct spi_master *ldv_spi_alloc_master(struct device *host , unsigned int size ) 
{ 
  struct spi_master *master ;
  void *tmp ;

  {
  {
#line 27
  tmp = ldv_zalloc((unsigned long )size + 2176UL);
#line 27
  master = (struct spi_master *)tmp;
  }
#line 29
  if ((unsigned long )master == (unsigned long )((struct spi_master *)0)) {
#line 30
    return ((struct spi_master *)0);
  } else {

  }
  {
#line 32
  ldv_dev_set_drvdata(& master->dev, (void *)master + 1U);
  }
#line 34
  return (master);
}
}
#line 20 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err(void const   *ptr ) 
{ 


  {
#line 22
  return ((unsigned long )ptr > 4294967295UL);
}
}
#line 25 "/home/ubuntu/klever-work/linux/err.c"
void *ldv_err_ptr(long error ) 
{ 


  {
#line 27
  return ((void *)(4294967295L - error));
}
}
#line 30 "/home/ubuntu/klever-work/linux/err.c"
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
#line 32
  return ((long )(4294967295UL - (unsigned long )ptr));
}
}
#line 35 "/home/ubuntu/klever-work/linux/err.c"
long ldv_is_err_or_null(void const   *ptr ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 37
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
#line 37
    tmp___0 = 1;
  } else {
    {
#line 37
    tmp = ldv_is_err(ptr);
    }
#line 37
    if (tmp != 0L) {
#line 37
      tmp___0 = 1;
    } else {
#line 37
      tmp___0 = 0;
    }
  }
#line 37
  return ((long )tmp___0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/char_dev.linux_fs_char_dev.bk.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) ;
#line 2
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) ;
#line 3
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) ;
#line 30 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_usb_gadget_chrdev  =    0;
#line 33 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 38
  is_reg = ldv_undef_int_nonpositive();
  }
#line 41
  if (is_reg == 0) {
    {
#line 43
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 45
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
#line 46
    if (major == 0) {
      {
#line 48
      is_reg = ldv_undef_int();
#line 49
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 54
  return (is_reg);
}
}
#line 58 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
int ldv_linux_fs_char_dev_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_fs_char_dev__double_registration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
#line 70
    ldv_linux_fs_char_dev_usb_gadget_chrdev = 1;
    }
  } else {

  }
#line 74
  return (is_reg);
}
}
#line 78 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_unregister_chrdev_region(void) 
{ 


  {
  {
#line 81
  ldv_assert_linux_fs_char_dev__double_deregistration(ldv_linux_fs_char_dev_usb_gadget_chrdev == 1);
#line 83
  ldv_linux_fs_char_dev_usb_gadget_chrdev = 0;
  }
#line 84
  return;
}
}
#line 87 "/home/ubuntu/klever-work/linux/fs/char_dev.c"
void ldv_linux_fs_char_dev_check_final_state(void) 
{ 


  {
  {
#line 90
  ldv_assert_linux_fs_char_dev__registered_at_exit(ldv_linux_fs_char_dev_usb_gadget_chrdev == 0);
  }
#line 91
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/sysfs.linux_fs_sysfs.bk.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs  =    0;
#line 25 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
int ldv_linux_fs_sysfs_sysfs_create_group(void) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 28
  tmp = ldv_undef_int_nonpositive();
#line 28
  res = tmp;
  }
#line 30
  if (res == 0) {
#line 32
    ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs + 1;
#line 34
    return (0);
  } else {

  }
#line 37
  return (res);
}
}
#line 41 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_sysfs_remove_group(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_fs_sysfs__less_initial_decrement(ldv_linux_fs_sysfs_sysfs > 0);
#line 46
  ldv_linux_fs_sysfs_sysfs = ldv_linux_fs_sysfs_sysfs - 1;
  }
#line 47
  return;
}
}
#line 50 "/home/ubuntu/klever-work/linux/fs/sysfs.c"
void ldv_linux_fs_sysfs_check_final_state(void) 
{ 


  {
  {
#line 53
  ldv_assert_linux_fs_sysfs__more_initial_at_exit(ldv_linux_fs_sysfs_sysfs == 0);
  }
#line 54
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/rwlock.linux_kernel_locking_rwlock.bk.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) ;
#line 5
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) ;
#line 6
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_rlock  =    1;
#line 25 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_wlock  =    1;
#line 28 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_lock(void) 
{ 


  {
  {
#line 31
  ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 33
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
  }
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_read_unlock(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(ldv_linux_kernel_locking_rwlock_rlock > 1);
#line 42
  ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + -1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_lock(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_locking_rwlock__double_write_lock(ldv_linux_kernel_locking_rwlock_wlock == 1);
#line 51
  ldv_linux_kernel_locking_rwlock_wlock = 2;
  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_write_unlock(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(ldv_linux_kernel_locking_rwlock_wlock != 1);
#line 60
  ldv_linux_kernel_locking_rwlock_wlock = 1;
  }
#line 61
  return;
}
}
#line 64 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_read_trylock(void) 
{ 
  int tmp ;

  {
#line 67
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 67
    tmp = ldv_undef_int();
    }
#line 67
    if (tmp != 0) {
#line 69
      ldv_linux_kernel_locking_rwlock_rlock = ldv_linux_kernel_locking_rwlock_rlock + 1;
#line 71
      return (1);
    } else {
#line 75
      return (0);
    }
  } else {
#line 75
    return (0);
  }
}
}
#line 80 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
int ldv_linux_kernel_locking_rwlock_write_trylock(void) 
{ 
  int tmp ;

  {
#line 83
  if (ldv_linux_kernel_locking_rwlock_wlock == 1) {
    {
#line 83
    tmp = ldv_undef_int();
    }
#line 83
    if (tmp != 0) {
#line 85
      ldv_linux_kernel_locking_rwlock_wlock = 2;
#line 87
      return (1);
    } else {
#line 91
      return (0);
    }
  } else {
#line 91
    return (0);
  }
}
}
#line 96 "/home/ubuntu/klever-work/linux/kernel/locking/rwlock.c"
void ldv_linux_kernel_locking_rwlock_check_final_state(void) 
{ 


  {
  {
#line 99
  ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(ldv_linux_kernel_locking_rwlock_rlock == 1);
#line 101
  ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(ldv_linux_kernel_locking_rwlock_wlock == 1);
  }
#line 102
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/module.linux_kernel_module.bk.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_module_refcounter  =    1;
#line 27 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_get(struct module *module ) 
{ 


  {
#line 30
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
#line 32
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
  } else {

  }
#line 33
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/kernel/module.c"
int ldv_linux_kernel_module_try_module_get(struct module *module ) 
{ 
  int tmp ;

  {
#line 40
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 42
    tmp = ldv_undef_int();
    }
#line 42
    if (tmp == 1) {
#line 44
      ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter + 1;
#line 46
      return (1);
    } else {
#line 50
      return (0);
    }
  } else {

  }
#line 51
  return (0);
}
}
#line 56 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put(struct module *module ) 
{ 


  {
#line 59
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    {
#line 61
    ldv_assert_linux_kernel_module__less_initial_decrement(ldv_linux_kernel_module_module_refcounter > 1);
#line 63
    ldv_linux_kernel_module_module_refcounter = ldv_linux_kernel_module_module_refcounter - 1;
    }
  } else {

  }
#line 65
  return;
}
}
#line 68 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_module_put_and_exit(void) 
{ 


  {
  {
#line 71
  ldv_linux_kernel_module_module_put((struct module *)1);
  }
  LDV_LINUX_KERNEL_MODULE_STOP: ;
#line 73
  goto LDV_LINUX_KERNEL_MODULE_STOP;
}
}
#line 77 "/home/ubuntu/klever-work/linux/kernel/module.c"
unsigned int ldv_linux_kernel_module_module_refcount(void) 
{ 


  {
#line 80
  return ((unsigned int )(ldv_linux_kernel_module_module_refcounter + -1));
}
}
#line 84 "/home/ubuntu/klever-work/linux/kernel/module.c"
void ldv_linux_kernel_module_check_final_state(void) 
{ 


  {
  {
#line 87
  ldv_assert_linux_kernel_module__more_initial_at_exit(ldv_linux_kernel_module_module_refcounter == 1);
  }
#line 88
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/srcu.linux_kernel_rcu_srcu.bk.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
int ldv_linux_kernel_rcu_srcu_srcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_srcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_srcu__more_unlocks(ldv_linux_kernel_rcu_srcu_srcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_srcu_srcu_nested = ldv_linux_kernel_rcu_srcu_srcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/srcu.c"
void ldv_linux_kernel_rcu_srcu_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(ldv_linux_kernel_rcu_srcu_srcu_nested == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/lock bh.linux_kernel_rcu_update_lock_bh.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
int ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_lock_bh(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_rcu_read_unlock_bh(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh = ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock bh.c"
void ldv_linux_kernel_rcu_update_lock_bh_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(ldv_linux_kernel_rcu_update_lock_bh_rcu_nested_bh == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/lock sched.linux_kernel_rcu_update_lock_sched.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
int ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_lock_sched(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_rcu_read_unlock_sched(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched = ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock sched.c"
void ldv_linux_kernel_rcu_update_lock_sched_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(ldv_linux_kernel_rcu_update_lock_sched_rcu_nested_sched == 0);
  }
#line 53
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/lock.linux_kernel_rcu_update_lock.bk.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) ;
#line 2
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) ;
#line 3
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) ;
#line 23 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
int ldv_linux_kernel_rcu_update_lock_rcu_nested  =    0;
#line 26 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_lock(void) 
{ 


  {
#line 29
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested + 1;
#line 30
  return;
}
}
#line 33 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_rcu_read_unlock(void) 
{ 


  {
  {
#line 36
  ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(ldv_linux_kernel_rcu_update_lock_rcu_nested > 0);
#line 38
  ldv_linux_kernel_rcu_update_lock_rcu_nested = ldv_linux_kernel_rcu_update_lock_rcu_nested - 1;
  }
#line 39
  return;
}
}
#line 42 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_for_read_section(void) 
{ 


  {
  {
#line 45
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 46
  return;
}
}
#line 49 "/home/ubuntu/klever-work/linux/kernel/rcu/update/lock.c"
void ldv_linux_kernel_rcu_update_lock_check_final_state(void) 
{ 


  {
  {
#line 52
  ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(ldv_linux_kernel_rcu_update_lock_rcu_nested == 0);
  }
#line 53
  return;
}
}
#line 21 "/home/ubuntu/klever-work/linux/ldv/common.c"
static int ldv_filter_positive_int(int val ) 
{ 


  {
  {
#line 23
  ldv_assume(val <= 0);
  }
#line 24
  return (val);
}
}
#line 31 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_init(int init_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = ldv_filter_positive_int(init_ret_val);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_post_probe(int probe_ret_val ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = ldv_filter_positive_int(probe_ret_val);
  }
#line 39
  return (tmp);
}
}
#line 43 "/home/ubuntu/klever-work/linux/ldv/common.c"
int ldv_filter_err_code(int ret_val ) 
{ 
  int tmp ;

  {
  {
#line 45
  tmp = ldv_filter_positive_int(ret_val);
  }
#line 45
  return (tmp);
}
}
#line 25 "/home/ubuntu/klever-work/linux/ldv/irq.c"
static bool __ldv_in_interrupt_context  =    0;
#line 27 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_interrupt_context(void) 
{ 


  {
#line 29
  __ldv_in_interrupt_context = 1;
#line 30
  return;
}
}
#line 32 "/home/ubuntu/klever-work/linux/ldv/irq.c"
void ldv_switch_to_process_context(void) 
{ 


  {
#line 34
  __ldv_in_interrupt_context = 0;
#line 35
  return;
}
}
#line 37 "/home/ubuntu/klever-work/linux/ldv/irq.c"
bool ldv_in_interrupt_context(void) 
{ 


  {
#line 39
  return (__ldv_in_interrupt_context);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/find_bit.linux_lib_find_bit.bk.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) ;
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/lkbce/include/linux/cpumask.h"
extern int nr_cpu_ids ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.h"
unsigned long ldv_undef_ulong(void) ;
#line 24 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_next_bit(unsigned long size , unsigned long offset ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 29
  tmp = ldv_undef_ulong();
#line 29
  nondet = tmp;
#line 27
  ldv_assert_linux_lib_find_bit__offset_out_of_range(offset <= size);
#line 30
  ldv_assume(nondet <= size);
#line 31
  ldv_assume(1);
  }
#line 32
  return (nondet);
}
}
#line 36 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
unsigned long ldv_linux_lib_find_bit_find_first_bit(unsigned long size ) 
{ 
  unsigned long nondet ;
  unsigned long tmp ;

  {
  {
#line 39
  tmp = ldv_undef_ulong();
#line 39
  nondet = tmp;
#line 40
  ldv_assume(nondet <= size);
#line 41
  ldv_assume(1);
  }
#line 42
  return (nondet);
}
}
#line 46 "/home/ubuntu/klever-work/linux/lib/find_bit.c"
void ldv_linux_lib_find_bit_initialize(void) 
{ 


  {
  {
#line 48
  ldv_assume(nr_cpu_ids > 0);
  }
#line 49
  return;
}
}
#line 24 "/home/ubuntu/klever-work/linux/mm/kzalloc.c"
void *ldv_kzalloc(size_t size , gfp_t flags ) 
{ 
  void *res ;

  {
  {
#line 28
  ldv_check_alloc_flags(flags);
#line 29
  res = ldv_zalloc(size);
#line 30
  ldv_after_alloc(res);
  }
#line 32
  return (res);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/sdio_func.linux_mmc_sdio_func.bk.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) ;
#line 2
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) ;
#line 3
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) ;
#line 25 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
unsigned short ldv_linux_mmc_sdio_func_sdio_element  =    0U;
#line 28 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_context(struct sdio_func *func ) 
{ 


  {
  {
#line 31
  ldv_assert_linux_mmc_sdio_func__wrong_params((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
  }
#line 32
  return;
}
}
#line 35 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_claim_host(struct sdio_func *func ) 
{ 


  {
  {
#line 38
  ldv_assert_linux_mmc_sdio_func__double_claim((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
#line 41
  ldv_linux_mmc_sdio_func_sdio_element = (unsigned short )((func->card)->host)->index;
  }
#line 42
  return;
}
}
#line 45 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_sdio_release_host(struct sdio_func *func ) 
{ 


  {
  {
#line 48
  ldv_assert_linux_mmc_sdio_func__release_without_claim((int )ldv_linux_mmc_sdio_func_sdio_element == ((func->card)->host)->index);
#line 51
  ldv_linux_mmc_sdio_func_sdio_element = 0U;
  }
#line 52
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/mmc/sdio_func.c"
void ldv_linux_mmc_sdio_func_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_mmc_sdio_func__unreleased_at_exit((unsigned int )ldv_linux_mmc_sdio_func_sdio_element == 0U);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/register.linux_net_register.bk.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) ;
#line 105 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_register_netdev(void) ;
#line 30 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_linux_net_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/net/register.c"
int ldv_pre_register_netdev(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_net_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_net_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/net/register.c"
void ldv_linux_net_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_net_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_net_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_net_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/rtnetlink.linux_net_rtnetlink.bk.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) ;
#line 2
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) ;
#line 3
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int rtnllocknumber  =    0;
#line 29 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_unlock(void) 
{ 


  {
  {
#line 32
  ldv_assert_linux_net_rtnetlink__double_unlock(rtnllocknumber == 1);
#line 34
  rtnllocknumber = 0;
  }
#line 35
  return;
}
}
#line 38 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_past_rtnl_lock(void) 
{ 


  {
  {
#line 41
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 43
  rtnllocknumber = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_before_ieee80211_unregister_hw(void) 
{ 


  {
  {
#line 50
  ldv_linux_net_rtnetlink_past_rtnl_lock();
#line 52
  ldv_linux_net_rtnetlink_past_rtnl_unlock();
  }
#line 53
  return;
}
}
#line 56 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_is_locked(void) 
{ 
  int tmp ;

  {
#line 59
  if (rtnllocknumber != 0) {
#line 61
    return (rtnllocknumber);
  } else {
    {
#line 63
    tmp = ldv_undef_int();
    }
#line 63
    if (tmp != 0) {
#line 65
      return (1);
    } else {
#line 68
      return (0);
    }
  }
}
}
#line 72 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
int ldv_linux_net_rtnetlink_rtnl_trylock(void) 
{ 
  int tmp ;

  {
  {
#line 75
  ldv_assert_linux_net_rtnetlink__double_lock(rtnllocknumber == 0);
#line 77
  tmp = ldv_linux_net_rtnetlink_rtnl_is_locked();
  }
#line 77
  if (tmp == 0) {
#line 79
    rtnllocknumber = 1;
#line 81
    return (1);
  } else {
#line 84
    return (0);
  }
}
}
#line 88 "/home/ubuntu/klever-work/linux/net/rtnetlink.c"
void ldv_linux_net_rtnetlink_check_final_state(void) 
{ 


  {
  {
#line 91
  ldv_assert_linux_net_rtnetlink__lock_on_exit(rtnllocknumber == 0);
  }
#line 92
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/sock.linux_net_sock.bk.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) ;
#line 2
void ldv_assert_linux_net_sock__double_release(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/net/sock.c"
int locksocknumber  =    0;
#line 27 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_past_lock_sock_nested(void) 
{ 


  {
#line 30
  locksocknumber = locksocknumber + 1;
#line 31
  return;
}
}
#line 34 "/home/ubuntu/klever-work/linux/net/sock.c"
bool ldv_linux_net_sock_lock_sock_fast(void) 
{ 
  int tmp ;

  {
  {
#line 37
  tmp = ldv_undef_int();
  }
#line 37
  if (tmp != 0) {
#line 39
    locksocknumber = locksocknumber + 1;
#line 41
    return (1);
  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_unlock_sock_fast(void) 
{ 


  {
  {
#line 51
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 53
  locksocknumber = locksocknumber - 1;
  }
#line 54
  return;
}
}
#line 57 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_before_release_sock(void) 
{ 


  {
  {
#line 60
  ldv_assert_linux_net_sock__double_release(locksocknumber > 0);
#line 62
  locksocknumber = locksocknumber - 1;
  }
#line 63
  return;
}
}
#line 66 "/home/ubuntu/klever-work/linux/net/sock.c"
void ldv_linux_net_sock_check_final_state(void) 
{ 


  {
  {
#line 69
  ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(locksocknumber == 0);
  }
#line 70
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/coherent.linux_usb_coherent.bk.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/coherent.c"
int ldv_linux_usb_coherent_coherent_state  =    0;
#line 27 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void *ldv_linux_usb_coherent_usb_alloc_coherent(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 30
  tmp = ldv_undef_ptr();
#line 30
  arbitrary_memory = tmp;
  }
#line 32
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 34
    return (arbitrary_memory);
  } else {

  }
#line 37
  ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + 1;
#line 39
  return (arbitrary_memory);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_usb_free_coherent(void *addr ) 
{ 


  {
#line 45
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    {
#line 47
    ldv_assert_linux_usb_coherent__less_initial_decrement(ldv_linux_usb_coherent_coherent_state > 0);
#line 49
    ldv_linux_usb_coherent_coherent_state = ldv_linux_usb_coherent_coherent_state + -1;
    }
  } else {

  }
#line 51
  return;
}
}
#line 54 "/home/ubuntu/klever-work/linux/usb/coherent.c"
void ldv_linux_usb_coherent_check_final_state(void) 
{ 


  {
  {
#line 57
  ldv_assert_linux_usb_coherent__more_initial_at_exit(ldv_linux_usb_coherent_coherent_state == 0);
  }
#line 58
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/dev.linux_usb_dev.bk.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) ;
#line 3
void ldv_assert_linux_usb_dev__probe_failed(int expr ) ;
#line 4
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) ;
#line 24 "/home/ubuntu/klever-work/linux/usb/dev.c"
ldv_map LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS  ;
#line 27 "/home/ubuntu/klever-work/linux/usb/dev.c"
struct usb_device *ldv_linux_usb_dev_usb_get_dev(struct usb_device *dev ) 
{ 


  {
#line 30
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
#line 32
    LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0 ? LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + 1 : 1;
  } else {

  }
#line 39
  return (dev);
}
}
#line 43 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_usb_put_dev(struct usb_device *dev ) 
{ 


  {
#line 46
  if ((unsigned long )dev != (unsigned long )((struct usb_device *)0)) {
    {
#line 48
    ldv_assert_linux_usb_dev__unincremented_counter_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS != 0);
#line 50
    ldv_assert_linux_usb_dev__less_initial_decrement(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 0);
    }
#line 54
    if (LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS > 1) {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS + -1;
    } else {
#line 54
      LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
    }
  } else {

  }
#line 56
  return;
}
}
#line 59 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_return_value_probe(int retval ) 
{ 


  {
#line 62
  if (retval != 0) {
    {
#line 64
    ldv_assert_linux_usb_dev__probe_failed(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
    }
  } else {

  }
#line 65
  return;
}
}
#line 69 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_initialize(void) 
{ 


  {
#line 72
  LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS = 0;
#line 73
  return;
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/dev.c"
void ldv_linux_usb_dev_check_final_state(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_dev__more_initial_at_exit(LDV_LINUX_USB_DEV_USB_DEV_REF_COUNTS == 0);
  }
#line 80
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/gadget.linux_usb_gadget.bk.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) ;
#line 2
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) ;
#line 3
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) ;
#line 4
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) ;
#line 5
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) ;
#line 6
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) ;
#line 7
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) ;
#line 33 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_usb_gadget  =    0;
#line 37 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void *ldv_linux_usb_gadget_create_class(void) 
{ 
  void *is_got ;
  long tmp ;

  {
  {
#line 42
  is_got = ldv_undef_ptr();
#line 45
  ldv_assume((int )((long )is_got));
#line 48
  tmp = ldv_is_err((void const   *)is_got);
  }
#line 48
  if (tmp == 0L) {
    {
#line 50
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 54
  return (is_got);
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_class(void) 
{ 
  int is_reg ;

  {
  {
#line 63
  is_reg = ldv_undef_int_nonpositive();
  }
#line 66
  if (is_reg == 0) {
    {
#line 68
    ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 72
  return (is_reg);
}
}
#line 76 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_class(void) 
{ 


  {
  {
#line 79
  ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 80
  return;
}
}
#line 82 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_destroy_class(struct class *cls ) 
{ 
  long tmp ;

  {
#line 84
  if ((unsigned long )cls == (unsigned long )((struct class *)0)) {
#line 85
    return;
  } else {
    {
#line 84
    tmp = ldv_is_err((void const   *)cls);
    }
#line 84
    if (tmp != 0L) {
#line 85
      return;
    } else {

    }
  }
  {
#line 86
  ldv_linux_usb_gadget_unregister_class();
  }
#line 87
  return;
}
}
#line 90 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev(int major ) 
{ 
  int is_reg ;

  {
  {
#line 95
  is_reg = ldv_undef_int_nonpositive();
  }
#line 98
  if (is_reg == 0) {
    {
#line 100
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
#line 101
    if (major == 0) {
      {
#line 103
      is_reg = ldv_undef_int();
#line 104
      ldv_assume(is_reg > 0);
      }
    } else {

    }
  } else {

  }
#line 109
  return (is_reg);
}
}
#line 113 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_chrdev_region(void) 
{ 
  int is_reg ;

  {
  {
#line 118
  is_reg = ldv_undef_int_nonpositive();
  }
#line 121
  if (is_reg == 0) {
    {
#line 123
    ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
    }
  } else {

  }
#line 127
  return (is_reg);
}
}
#line 131 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_chrdev_region(void) 
{ 


  {
  {
#line 134
  ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 135
  return;
}
}
#line 138 "/home/ubuntu/klever-work/linux/usb/gadget.c"
int ldv_linux_usb_gadget_register_usb_gadget(void) 
{ 
  int is_reg ;

  {
  {
#line 143
  is_reg = ldv_undef_int_nonpositive();
  }
#line 146
  if (is_reg == 0) {
    {
#line 148
    ldv_assert_linux_usb_gadget__double_usb_gadget_registration(ldv_linux_usb_gadget_usb_gadget == 0);
#line 150
    ldv_linux_usb_gadget_usb_gadget = 1;
    }
  } else {

  }
#line 154
  return (is_reg);
}
}
#line 158 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_unregister_usb_gadget(void) 
{ 


  {
  {
#line 161
  ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(ldv_linux_usb_gadget_usb_gadget == 1);
#line 163
  ldv_linux_usb_gadget_usb_gadget = 0;
  }
#line 164
  return;
}
}
#line 167 "/home/ubuntu/klever-work/linux/usb/gadget.c"
void ldv_linux_usb_gadget_check_final_state(void) 
{ 


  {
  {
#line 170
  ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(ldv_linux_usb_gadget_usb_gadget == 0);
  }
#line 171
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/register.linux_usb_register.bk.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) ;
#line 90 "/home/ubuntu/klever-work/linux/ldv/common.h"
int ldv_pre_usb_register_driver(void) ;
#line 30 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_linux_usb_register_probe_state  =    0;
#line 33 "/home/ubuntu/klever-work/linux/usb/register.c"
int ldv_pre_usb_register_driver(void) 
{ 
  int nondet ;
  int tmp ;

  {
  {
#line 35
  tmp = ldv_undef_int();
#line 35
  nondet = tmp;
  }
#line 38
  if (nondet < 0) {
#line 40
    ldv_linux_usb_register_probe_state = 1;
#line 42
    return (nondet);
  } else {
#line 46
    return (0);
  }
}
}
#line 51 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_reset_error_counter(void) 
{ 


  {
#line 54
  ldv_linux_usb_register_probe_state = 0;
#line 55
  return;
}
}
#line 58 "/home/ubuntu/klever-work/linux/usb/register.c"
void ldv_linux_usb_register_check_return_value_probe(int retval ) 
{ 


  {
#line 60
  if (ldv_linux_usb_register_probe_state == 1) {
    {
#line 62
    ldv_assert_linux_usb_register__wrong_return_value(retval != 0);
    }
  } else {

  }
  {
#line 65
  ldv_linux_usb_register_reset_error_counter();
  }
#line 66
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/urb.linux_usb_urb.bk.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) ;
#line 2
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) ;
#line 26 "/home/ubuntu/klever-work/linux/usb/urb.c"
int ldv_linux_usb_urb_urb_state  =    0;
#line 29 "/home/ubuntu/klever-work/linux/usb/urb.c"
struct urb *ldv_linux_usb_urb_usb_alloc_urb(void) 
{ 
  void *arbitrary_memory ;
  void *tmp ;

  {
  {
#line 32
  tmp = ldv_undef_ptr();
#line 32
  arbitrary_memory = tmp;
  }
#line 34
  if ((unsigned long )arbitrary_memory == (unsigned long )((void *)0)) {
#line 36
    return ((struct urb *)arbitrary_memory);
  } else {

  }
#line 39
  ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + 1;
#line 41
  return ((struct urb *)arbitrary_memory);
}
}
#line 45 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_usb_free_urb(struct urb *urb ) 
{ 


  {
#line 46
  if ((unsigned long )urb != (unsigned long )((struct urb *)0)) {
    {
#line 48
    ldv_assert_linux_usb_urb__less_initial_decrement(ldv_linux_usb_urb_urb_state > 0);
#line 50
    ldv_linux_usb_urb_urb_state = ldv_linux_usb_urb_urb_state + -1;
    }
  } else {

  }
#line 52
  return;
}
}
#line 55 "/home/ubuntu/klever-work/linux/usb/urb.c"
void ldv_linux_usb_urb_check_final_state(void) 
{ 


  {
  {
#line 58
  ldv_assert_linux_usb_urb__more_initial_at_exit(ldv_linux_usb_urb_urb_state == 0);
  }
#line 59
  return;
}
}
#line 24 "/home/ubuntu/klever-work/verifier/common.h"
extern void ldv_assert(char const   * , int  ) ;
#line 45
void __builtin_trap(void) ;
#line 23 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_assume(int expression ) 
{ 


  {
#line 25
  if (expression == 0) {
    ldv_assume_label: ;
#line 29
    goto ldv_assume_label;
  } else {

  }
#line 31
  return;
}
}
#line 33 "/home/ubuntu/klever-work/verifier/common.c"
void ldv_stop(void) 
{ 


  {
  ldv_stop_label: ;
#line 36
  goto ldv_stop_label;
}
}
#line 43 "/home/ubuntu/klever-work/verifier/common.c"
long __builtin_expect(long exp , long c ) 
{ 


  {
#line 45
  return (exp);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/common.c"
void __builtin_trap(void) 
{ 


  {
  {
#line 56
  ldv_assert("", 0);
  }
#line 57
  return;
}
}
#line 29 "/home/ubuntu/klever-work/verifier/memory.h"
void *ldv_malloc(size_t size ) ;
#line 30
void *ldv_calloc(size_t nmemb , size_t size ) ;
#line 37
extern void *external_allocated_data(void) ;
#line 40
void *ldv_calloc_unknown_size(void) ;
#line 47
void *ldv_xmalloc_unknown_size(size_t size ) ;
#line 25 "/home/ubuntu/klever-work/verifier/memory.c"
extern void *malloc(size_t  ) ;
#line 26
extern void *calloc(size_t  , size_t  ) ;
#line 27
extern void free(void * ) ;
#line 28
extern void *memset(void * , int  , size_t  ) ;
#line 30 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 32
  tmp___1 = ldv_undef_int();
  }
#line 32
  if (tmp___1 != 0) {
    {
#line 33
    tmp = malloc(size);
#line 33
    res = tmp;
#line 34
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 35
    tmp___0 = ldv_is_err((void const   *)res);
#line 35
    ldv_assume(tmp___0 == 0L);
    }
#line 36
    return (res);
  } else {
#line 39
    return ((void *)0);
  }
}
}
#line 43 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc(size_t nmemb , size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 45
  tmp___1 = ldv_undef_int();
  }
#line 45
  if (tmp___1 != 0) {
    {
#line 46
    tmp = calloc(nmemb, size);
#line 46
    res = tmp;
#line 47
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 48
    tmp___0 = ldv_is_err((void const   *)res);
#line 48
    ldv_assume(tmp___0 == 0L);
    }
#line 49
    return (res);
  } else {
#line 52
    return ((void *)0);
  }
}
}
#line 56 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 58
  tmp = ldv_calloc(1UL, size);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/ubuntu/klever-work/verifier/memory.c"
void ldv_free(void *s ) 
{ 


  {
  {
#line 63
  free(s);
  }
#line 64
  return;
}
}
#line 66 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 68
  tmp = malloc(size);
#line 68
  res = tmp;
#line 69
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 70
  tmp___0 = ldv_is_err((void const   *)res);
#line 70
  ldv_assume(tmp___0 == 0L);
  }
#line 71
  return (res);
}
}
#line 74 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xzalloc(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 76
  tmp = calloc(1UL, size);
#line 76
  res = tmp;
#line 77
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 78
  tmp___0 = ldv_is_err((void const   *)res);
#line 78
  ldv_assume(tmp___0 == 0L);
  }
#line 79
  return (res);
}
}
#line 82 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_malloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 84
  tmp___1 = ldv_undef_int();
  }
#line 84
  if (tmp___1 != 0) {
    {
#line 85
    tmp = external_allocated_data();
#line 85
    res = tmp;
#line 86
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 87
    tmp___0 = ldv_is_err((void const   *)res);
#line 87
    ldv_assume(tmp___0 == 0L);
    }
#line 88
    return (res);
  } else {
#line 91
    return ((void *)0);
  }
}
}
#line 95 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_calloc_unknown_size(void) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 97
  tmp___1 = ldv_undef_int();
  }
#line 97
  if (tmp___1 != 0) {
    {
#line 98
    tmp = external_allocated_data();
#line 98
    res = tmp;
#line 99
    memset(res, 0, 8UL);
#line 100
    ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 101
    tmp___0 = ldv_is_err((void const   *)res);
#line 101
    ldv_assume(tmp___0 == 0L);
    }
#line 102
    return (res);
  } else {
#line 105
    return ((void *)0);
  }
}
}
#line 109 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_zalloc_unknown_size(void) 
{ 
  void *tmp ;

  {
  {
#line 111
  tmp = ldv_calloc_unknown_size();
  }
#line 111
  return (tmp);
}
}
#line 114 "/home/ubuntu/klever-work/verifier/memory.c"
void *ldv_xmalloc_unknown_size(size_t size ) 
{ 
  void *res ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 116
  tmp = external_allocated_data();
#line 116
  res = tmp;
#line 117
  ldv_assume((unsigned long )res != (unsigned long )((void *)0));
#line 118
  tmp___0 = ldv_is_err((void const   *)res);
#line 118
  ldv_assume(tmp___0 == 0L);
  }
#line 119
  return (res);
}
}
#line 27 "/home/ubuntu/klever-work/verifier/nondet.h"
int ldv_undef_int_negative(void) ;
#line 24 "/home/ubuntu/klever-work/verifier/nondet.c"
extern int __VERIFIER_nondet_int(void) ;
#line 36
extern unsigned long __VERIFIER_nondet_ulong(void) ;
#line 37
extern void *__VERIFIER_nondet_pointer(void) ;
#line 40 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  {
#line 41
  tmp = __VERIFIER_nondet_int();
  }
#line 41
  return (tmp);
}
}
#line 44 "/home/ubuntu/klever-work/verifier/nondet.c"
void *ldv_undef_ptr(void) 
{ 
  void *tmp ;

  {
  {
#line 45
  tmp = __VERIFIER_nondet_pointer();
  }
#line 45
  return (tmp);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/nondet.c"
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  {
#line 49
  tmp = __VERIFIER_nondet_ulong();
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 54
  tmp = ldv_undef_int();
#line 54
  ret = tmp;
#line 55
  ldv_assume(ret < 0);
  }
#line 56
  return (ret);
}
}
#line 59 "/home/ubuntu/klever-work/verifier/nondet.c"
int ldv_undef_int_nonpositive(void) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 61
  tmp = ldv_undef_int();
#line 61
  ret = tmp;
#line 62
  ldv_assume(ret <= 0);
  }
#line 63
  return (ret);
}
}
#line 32 "/home/ubuntu/klever-work/verifier/thread.h"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) ;
#line 35
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) ;
#line 38
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) ;
#line 41
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) ;
#line 27 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create(struct ldv_thread *ldv_thread , void (*function)(void * ) ,
                      void *data ) 
{ 


  {
#line 29
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
    {
#line 30
    (*function)(data);
    }
  } else {

  }
#line 31
  return (0);
}
}
#line 35 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_create_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ,
                        void *data ) 
{ 
  int i ;

  {
#line 39
  if ((unsigned long )function != (unsigned long )((void (*)(void * ))0)) {
#line 40
    i = 0;
#line 40
    goto ldv_1179;
    ldv_1178: 
    {
#line 41
    (*function)(data);
#line 40
    i = i + 1;
    }
    ldv_1179: ;
#line 40
    if (i < ldv_thread_set->number) {
#line 42
      goto ldv_1178;
    } else {

    }

  } else {

  }
#line 44
  return (0);
}
}
#line 48 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join(struct ldv_thread *ldv_thread , void (*function)(void * ) ) 
{ 


  {
#line 50
  return (0);
}
}
#line 54 "/home/ubuntu/klever-work/verifier/thread.c"
int ldv_thread_join_N(struct ldv_thread_set *ldv_thread_set , void (*function)(void * ) ) 
{ 


  {
#line 56
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/mutex.linux_kernel_locking_mutex.bk.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode  ;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 33
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 35
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
  }
#line 36
  return;
}
}
#line 39 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 42
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 44
  tmp = ldv_undef_int();
  }
#line 44
  if (tmp != 0) {
#line 46
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 48
    return (0);
  } else {
#line 52
    return (-4);
  }
}
}
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 60
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode) {
#line 62
    return (1);
  } else {
    {
#line 65
    tmp = ldv_undef_int();
    }
#line 65
    if (tmp != 0) {
#line 67
      return (1);
    } else {
#line 71
      return (0);
    }
  }
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 79
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 82
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_i_mutex_of_inode(lock);
  }
#line 82
  if (tmp != 0) {
#line 84
    return (0);
  } else {
#line 88
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 1;
#line 90
    return (1);
  }
}
}
#line 95 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt ,
                                                                              struct mutex *lock ) 
{ 


  {
#line 98
  cnt->counter = cnt->counter - 1;
#line 101
  if (cnt->counter != 0) {
#line 103
    return (0);
  } else {
    {
#line 106
    ldv_linux_kernel_locking_mutex_mutex_lock_i_mutex_of_inode(lock);
    }
#line 108
    return (1);
  }
}
}
#line 113 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  {
#line 116
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 118
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
  }
#line 119
  return;
}
}
#line 120 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx  ;
#line 123 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_ide_cfg_mtx(struct mutex *lock ) 
{ 


  {
  {
#line 126
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx);
#line 128
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx = 1;
  }
#line 129
  return;
}
}
#line 132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_ide_cfg_mtx(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 135
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx);
#line 137
  tmp = ldv_undef_int();
  }
#line 137
  if (tmp != 0) {
#line 139
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx = 1;
#line 141
    return (0);
  } else {
#line 145
    return (-4);
  }
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_ide_cfg_mtx(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 153
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx) {
#line 155
    return (1);
  } else {
    {
#line 158
    tmp = ldv_undef_int();
    }
#line 158
    if (tmp != 0) {
#line 160
      return (1);
    } else {
#line 164
      return (0);
    }
  }
}
}
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_ide_cfg_mtx(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 172
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx);
#line 175
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_ide_cfg_mtx(lock);
  }
#line 175
  if (tmp != 0) {
#line 177
    return (0);
  } else {
#line 181
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx = 1;
#line 183
    return (1);
  }
}
}
#line 188 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_ide_cfg_mtx(atomic_t *cnt ,
                                                                         struct mutex *lock ) 
{ 


  {
#line 191
  cnt->counter = cnt->counter - 1;
#line 194
  if (cnt->counter != 0) {
#line 196
    return (0);
  } else {
    {
#line 199
    ldv_linux_kernel_locking_mutex_mutex_lock_ide_cfg_mtx(lock);
    }
#line 201
    return (1);
  }
}
}
#line 206 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_ide_cfg_mtx(struct mutex *lock ) 
{ 


  {
  {
#line 209
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx);
#line 211
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx = 0;
  }
#line 212
  return;
}
}
#line 213 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx  ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(struct mutex *lock ) 
{ 


  {
  {
#line 219
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx);
#line 221
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx = 1;
  }
#line 222
  return;
}
}
#line 225 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_ide_setting_mtx(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 228
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx);
#line 230
  tmp = ldv_undef_int();
  }
#line 230
  if (tmp != 0) {
#line 232
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx = 1;
#line 234
    return (0);
  } else {
#line 238
    return (-4);
  }
}
}
#line 243 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_ide_setting_mtx(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 246
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx) {
#line 248
    return (1);
  } else {
    {
#line 251
    tmp = ldv_undef_int();
    }
#line 251
    if (tmp != 0) {
#line 253
      return (1);
    } else {
#line 257
      return (0);
    }
  }
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_ide_setting_mtx(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 265
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx);
#line 268
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_ide_setting_mtx(lock);
  }
#line 268
  if (tmp != 0) {
#line 270
    return (0);
  } else {
#line 274
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx = 1;
#line 276
    return (1);
  }
}
}
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_ide_setting_mtx(atomic_t *cnt ,
                                                                             struct mutex *lock ) 
{ 


  {
#line 284
  cnt->counter = cnt->counter - 1;
#line 287
  if (cnt->counter != 0) {
#line 289
    return (0);
  } else {
    {
#line 292
    ldv_linux_kernel_locking_mutex_mutex_lock_ide_setting_mtx(lock);
    }
#line 294
    return (1);
  }
}
}
#line 299 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_ide_setting_mtx(struct mutex *lock ) 
{ 


  {
  {
#line 302
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx);
#line 304
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx = 0;
  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock  ;
#line 309 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 312
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 314
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
  }
#line 315
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 321
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 323
  tmp = ldv_undef_int();
  }
#line 323
  if (tmp != 0) {
#line 325
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 327
    return (0);
  } else {
#line 331
    return (-4);
  }
}
}
#line 336 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 339
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock) {
#line 341
    return (1);
  } else {
    {
#line 344
    tmp = ldv_undef_int();
    }
#line 344
    if (tmp != 0) {
#line 346
      return (1);
    } else {
#line 350
      return (0);
    }
  }
}
}
#line 355 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 358
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 361
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_lock(lock);
  }
#line 361
  if (tmp != 0) {
#line 363
    return (0);
  } else {
#line 367
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 1;
#line 369
    return (1);
  }
}
}
#line 374 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_lock(atomic_t *cnt ,
                                                                  struct mutex *lock ) 
{ 


  {
#line 377
  cnt->counter = cnt->counter - 1;
#line 380
  if (cnt->counter != 0) {
#line 382
    return (0);
  } else {
    {
#line 385
    ldv_linux_kernel_locking_mutex_mutex_lock_lock(lock);
    }
#line 387
    return (1);
  }
}
}
#line 392 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
  {
#line 395
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 397
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
  }
#line 398
  return;
}
}
#line 399 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
ldv_set LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device  ;
#line 402 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 405
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 407
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
  }
#line 408
  return;
}
}
#line 411 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_lock_interruptible_or_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 414
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 416
  tmp = ldv_undef_int();
  }
#line 416
  if (tmp != 0) {
#line 418
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 420
    return (0);
  } else {
#line 424
    return (-4);
  }
}
}
#line 429 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
#line 432
  if ((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device) {
#line 434
    return (1);
  } else {
    {
#line 437
    tmp = ldv_undef_int();
    }
#line 437
    if (tmp != 0) {
#line 439
      return (1);
    } else {
#line 443
      return (0);
    }
  }
}
}
#line 448 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int tmp ;

  {
  {
#line 451
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 454
  tmp = ldv_linux_kernel_locking_mutex_mutex_is_locked_mutex_of_device(lock);
  }
#line 454
  if (tmp != 0) {
#line 456
    return (0);
  } else {
#line 460
    LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 1;
#line 462
    return (1);
  }
}
}
#line 467 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
int ldv_linux_kernel_locking_mutex_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt ,
                                                                             struct mutex *lock ) 
{ 


  {
#line 470
  cnt->counter = cnt->counter - 1;
#line 473
  if (cnt->counter != 0) {
#line 475
    return (0);
  } else {
    {
#line 478
    ldv_linux_kernel_locking_mutex_mutex_lock_mutex_of_device(lock);
    }
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  {
#line 488
  ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock((int )LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
#line 490
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
  }
#line 491
  return;
}
}
#line 493 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_initialize(void) 
{ 


  {
#line 496
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode = 0;
#line 498
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx = 0;
#line 500
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx = 0;
#line 502
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock = 0;
#line 504
  LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device = 0;
#line 505
  return;
}
}
#line 508 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/mutex.c"
void ldv_linux_kernel_locking_mutex_check_final_state(void) 
{ 


  {
  {
#line 511
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_i_mutex_of_inode);
#line 513
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_cfg_mtx);
#line 515
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_ide_setting_mtx);
#line 517
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_lock);
#line 519
  ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(! LDV_LINUX_KERNEL_LOCKING_MUTEX_MUTEXES_mutex_of_device);
  }
#line 520
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/spinlock.linux_kernel_locking_spinlock.bk.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) ;
#line 2
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) ;
#line 3
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) ;
#line 4
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) ;
#line 22 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct  =    1;
#line 25 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 28
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 30
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 32
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
  }
#line 33
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 39
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 41
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2);
#line 43
  ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 1;
  }
#line 44
  return;
}
}
#line 47 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 52
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 54
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 57
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 60
  if (is_spin_held_by_another_thread != 0) {
#line 62
    return (0);
  } else {
#line 66
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 68
    return (1);
  }
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_alloc_lock_of_task_struct(void) 
{ 


  {
  {
#line 76
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 78
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
  }
#line 79
  return;
}
}
#line 82 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 87
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 90
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 92
    return (0);
  } else {
#line 96
    return (1);
  }
}
}
#line 101 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_alloc_lock_of_task_struct(void) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_alloc_lock_of_task_struct();
  }
#line 104
  return (tmp == 0);
}
}
#line 108 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_alloc_lock_of_task_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 113
  is_spin_contended = ldv_undef_int();
  }
#line 116
  if (is_spin_contended != 0) {
#line 118
    return (0);
  } else {
#line 122
    return (1);
  }
}
}
#line 127 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_alloc_lock_of_task_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 132
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 134
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 137
  atomic_value_after_dec = ldv_undef_int();
  }
#line 140
  if (atomic_value_after_dec == 0) {
#line 142
    ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct = 2;
#line 144
    return (1);
  } else {

  }
#line 148
  return (0);
}
}
#line 150 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode  =    1;
#line 153 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_i_lock_of_inode(void) 
{ 


  {
  {
#line 156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 160
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
  }
#line 161
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_i_lock_of_inode(void) 
{ 


  {
  {
#line 167
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 169
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2);
#line 171
  ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 1;
  }
#line 172
  return;
}
}
#line 175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 182
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 185
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 188
  if (is_spin_held_by_another_thread != 0) {
#line 190
    return (0);
  } else {
#line 194
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 196
    return (1);
  }
}
}
#line 201 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_i_lock_of_inode(void) 
{ 


  {
  {
#line 204
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 206
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
  }
#line 207
  return;
}
}
#line 210 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 215
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 218
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1 && is_spin_held_by_another_thread == 0) {
#line 220
    return (0);
  } else {
#line 224
    return (1);
  }
}
}
#line 229 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_i_lock_of_inode(void) 
{ 
  int tmp ;

  {
  {
#line 232
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_i_lock_of_inode();
  }
#line 232
  return (tmp == 0);
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_i_lock_of_inode(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 241
  is_spin_contended = ldv_undef_int();
  }
#line 244
  if (is_spin_contended != 0) {
#line 246
    return (0);
  } else {
#line 250
    return (1);
  }
}
}
#line 255 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_i_lock_of_inode(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 260
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 262
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 265
  atomic_value_after_dec = ldv_undef_int();
  }
#line 268
  if (atomic_value_after_dec == 0) {
#line 270
    ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode = 2;
#line 272
    return (1);
  } else {

  }
#line 276
  return (0);
}
}
#line 278 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock  =    1;
#line 281 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock(void) 
{ 


  {
  {
#line 284
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 286
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 288
  ldv_linux_kernel_locking_spinlock_spin_lock = 2;
  }
#line 289
  return;
}
}
#line 292 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock(void) 
{ 


  {
  {
#line 295
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 297
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 2);
#line 299
  ldv_linux_kernel_locking_spinlock_spin_lock = 1;
  }
#line 300
  return;
}
}
#line 303 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 308
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 310
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 313
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 316
  if (is_spin_held_by_another_thread != 0) {
#line 318
    return (0);
  } else {
#line 322
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 324
    return (1);
  }
}
}
#line 329 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock(void) 
{ 


  {
  {
#line 332
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 334
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
  }
#line 335
  return;
}
}
#line 338 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 343
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 346
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 1 && is_spin_held_by_another_thread == 0) {
#line 348
    return (0);
  } else {
#line 352
    return (1);
  }
}
}
#line 357 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock(void) 
{ 
  int tmp ;

  {
  {
#line 360
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock();
  }
#line 360
  return (tmp == 0);
}
}
#line 364 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 369
  is_spin_contended = ldv_undef_int();
  }
#line 372
  if (is_spin_contended != 0) {
#line 374
    return (0);
  } else {
#line 378
    return (1);
  }
}
}
#line 383 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 388
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 390
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 393
  atomic_value_after_dec = ldv_undef_int();
  }
#line 396
  if (atomic_value_after_dec == 0) {
#line 398
    ldv_linux_kernel_locking_spinlock_spin_lock = 2;
#line 400
    return (1);
  } else {

  }
#line 404
  return (0);
}
}
#line 406 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN  =    1;
#line 409 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 412
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 414
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 416
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
  }
#line 417
  return;
}
}
#line 420 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 423
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 425
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2);
#line 427
  ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 1;
  }
#line 428
  return;
}
}
#line 431 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 436
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 438
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 441
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 444
  if (is_spin_held_by_another_thread != 0) {
#line 446
    return (0);
  } else {
#line 450
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 452
    return (1);
  }
}
}
#line 457 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock_of_NOT_ARG_SIGN(void) 
{ 


  {
  {
#line 460
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 462
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
  }
#line 463
  return;
}
}
#line 466 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 471
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 474
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1 && is_spin_held_by_another_thread == 0) {
#line 476
    return (0);
  } else {
#line 480
    return (1);
  }
}
}
#line 485 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int tmp ;

  {
  {
#line 488
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_NOT_ARG_SIGN();
  }
#line 488
  return (tmp == 0);
}
}
#line 492 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock_of_NOT_ARG_SIGN(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 497
  is_spin_contended = ldv_undef_int();
  }
#line 500
  if (is_spin_contended != 0) {
#line 502
    return (0);
  } else {
#line 506
    return (1);
  }
}
}
#line 511 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock_of_NOT_ARG_SIGN(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 516
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 518
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 521
  atomic_value_after_dec = ldv_undef_int();
  }
#line 524
  if (atomic_value_after_dec == 0) {
#line 526
    ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN = 2;
#line 528
    return (1);
  } else {

  }
#line 532
  return (0);
}
}
#line 534 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s  =    1;
#line 537 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_lock_of_hwif_s(void) 
{ 


  {
  {
#line 540
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
#line 542
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
#line 544
  ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s = 2;
  }
#line 545
  return;
}
}
#line 548 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_lock_of_hwif_s(void) 
{ 


  {
  {
#line 551
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 2);
#line 553
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 2);
#line 555
  ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s = 1;
  }
#line 556
  return;
}
}
#line 559 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_lock_of_hwif_s(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 564
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
#line 566
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
#line 569
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 572
  if (is_spin_held_by_another_thread != 0) {
#line 574
    return (0);
  } else {
#line 578
    ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s = 2;
#line 580
    return (1);
  }
}
}
#line 585 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_lock_of_hwif_s(void) 
{ 


  {
  {
#line 588
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
#line 590
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
  }
#line 591
  return;
}
}
#line 594 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_hwif_s(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 599
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 602
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1 && is_spin_held_by_another_thread == 0) {
#line 604
    return (0);
  } else {
#line 608
    return (1);
  }
}
}
#line 613 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_lock_of_hwif_s(void) 
{ 
  int tmp ;

  {
  {
#line 616
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_lock_of_hwif_s();
  }
#line 616
  return (tmp == 0);
}
}
#line 620 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_lock_of_hwif_s(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 625
  is_spin_contended = ldv_undef_int();
  }
#line 628
  if (is_spin_contended != 0) {
#line 630
    return (0);
  } else {
#line 634
    return (1);
  }
}
}
#line 639 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_lock_of_hwif_s(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 644
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
#line 646
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
#line 649
  atomic_value_after_dec = ldv_undef_int();
  }
#line 652
  if (atomic_value_after_dec == 0) {
#line 654
    ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s = 2;
#line 656
    return (1);
  } else {

  }
#line 660
  return (0);
}
}
#line 662 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data  =    1;
#line 665 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 668
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 670
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 672
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
  }
#line 673
  return;
}
}
#line 676 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 679
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 681
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2);
#line 683
  ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 1;
  }
#line 684
  return;
}
}
#line 687 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 692
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 694
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 697
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 700
  if (is_spin_held_by_another_thread != 0) {
#line 702
    return (0);
  } else {
#line 706
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 708
    return (1);
  }
}
}
#line 713 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_node_size_lock_of_pglist_data(void) 
{ 


  {
  {
#line 716
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 718
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
  }
#line 719
  return;
}
}
#line 722 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 727
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 730
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1 && is_spin_held_by_another_thread == 0) {
#line 732
    return (0);
  } else {
#line 736
    return (1);
  }
}
}
#line 741 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_node_size_lock_of_pglist_data(void) 
{ 
  int tmp ;

  {
  {
#line 744
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_node_size_lock_of_pglist_data();
  }
#line 744
  return (tmp == 0);
}
}
#line 748 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_node_size_lock_of_pglist_data(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 753
  is_spin_contended = ldv_undef_int();
  }
#line 756
  if (is_spin_contended != 0) {
#line 758
    return (0);
  } else {
#line 762
    return (1);
  }
}
}
#line 767 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_node_size_lock_of_pglist_data(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 772
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 774
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 777
  atomic_value_after_dec = ldv_undef_int();
  }
#line 780
  if (atomic_value_after_dec == 0) {
#line 782
    ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data = 2;
#line 784
    return (1);
  } else {

  }
#line 788
  return (0);
}
}
#line 790 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_ptl  =    1;
#line 793 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_ptl(void) 
{ 


  {
  {
#line 796
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 798
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 800
  ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
  }
#line 801
  return;
}
}
#line 804 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_ptl(void) 
{ 


  {
  {
#line 807
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 809
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 2);
#line 811
  ldv_linux_kernel_locking_spinlock_spin_ptl = 1;
  }
#line 812
  return;
}
}
#line 815 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 820
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 822
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 825
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 828
  if (is_spin_held_by_another_thread != 0) {
#line 830
    return (0);
  } else {
#line 834
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 836
    return (1);
  }
}
}
#line 841 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_ptl(void) 
{ 


  {
  {
#line 844
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 846
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
  }
#line 847
  return;
}
}
#line 850 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 855
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 858
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 1 && is_spin_held_by_another_thread == 0) {
#line 860
    return (0);
  } else {
#line 864
    return (1);
  }
}
}
#line 869 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_ptl(void) 
{ 
  int tmp ;

  {
  {
#line 872
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_ptl();
  }
#line 872
  return (tmp == 0);
}
}
#line 876 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_ptl(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 881
  is_spin_contended = ldv_undef_int();
  }
#line 884
  if (is_spin_contended != 0) {
#line 886
    return (0);
  } else {
#line 890
    return (1);
  }
}
}
#line 895 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_ptl(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 900
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 902
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 905
  atomic_value_after_dec = ldv_undef_int();
  }
#line 908
  if (atomic_value_after_dec == 0) {
#line 910
    ldv_linux_kernel_locking_spinlock_spin_ptl = 2;
#line 912
    return (1);
  } else {

  }
#line 916
  return (0);
}
}
#line 918 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue  =    1;
#line 921 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_queue_lock_of_request_queue(void) 
{ 


  {
  {
#line 924
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
#line 926
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
#line 928
  ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue = 2;
  }
#line 929
  return;
}
}
#line 932 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_queue_lock_of_request_queue(void) 
{ 


  {
  {
#line 935
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 2);
#line 937
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 2);
#line 939
  ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue = 1;
  }
#line 940
  return;
}
}
#line 943 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_queue_lock_of_request_queue(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 948
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
#line 950
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
#line 953
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 956
  if (is_spin_held_by_another_thread != 0) {
#line 958
    return (0);
  } else {
#line 962
    ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue = 2;
#line 964
    return (1);
  }
}
}
#line 969 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_queue_lock_of_request_queue(void) 
{ 


  {
  {
#line 972
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
#line 974
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
  }
#line 975
  return;
}
}
#line 978 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_queue_lock_of_request_queue(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 983
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 986
  if (ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1 && is_spin_held_by_another_thread == 0) {
#line 988
    return (0);
  } else {
#line 992
    return (1);
  }
}
}
#line 997 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_queue_lock_of_request_queue(void) 
{ 
  int tmp ;

  {
  {
#line 1000
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_queue_lock_of_request_queue();
  }
#line 1000
  return (tmp == 0);
}
}
#line 1004 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_queue_lock_of_request_queue(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1009
  is_spin_contended = ldv_undef_int();
  }
#line 1012
  if (is_spin_contended != 0) {
#line 1014
    return (0);
  } else {
#line 1018
    return (1);
  }
}
}
#line 1023 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_queue_lock_of_request_queue(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1028
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
#line 1030
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
#line 1033
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1036
  if (atomic_value_after_dec == 0) {
#line 1038
    ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue = 2;
#line 1040
    return (1);
  } else {

  }
#line 1044
  return (0);
}
}
#line 1046 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
static int ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct  =    1;
#line 1049 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_lock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1052
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1054
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1056
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
  }
#line 1057
  return;
}
}
#line 1060 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1063
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 1065
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2);
#line 1067
  ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 1;
  }
#line 1068
  return;
}
}
#line 1071 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_trylock_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1076
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1078
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1081
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1084
  if (is_spin_held_by_another_thread != 0) {
#line 1086
    return (0);
  } else {
#line 1090
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 1092
    return (1);
  }
}
}
#line 1097 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_spin_unlock_wait_siglock_of_sighand_struct(void) 
{ 


  {
  {
#line 1100
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1102
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
  }
#line 1103
  return;
}
}
#line 1106 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct(void) 
{ 
  int is_spin_held_by_another_thread ;

  {
  {
#line 1111
  is_spin_held_by_another_thread = ldv_undef_int();
  }
#line 1114
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1 && is_spin_held_by_another_thread == 0) {
#line 1116
    return (0);
  } else {
#line 1120
    return (1);
  }
}
}
#line 1125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_can_lock_siglock_of_sighand_struct(void) 
{ 
  int tmp ;

  {
  {
#line 1128
  tmp = ldv_linux_kernel_locking_spinlock_spin_is_locked_siglock_of_sighand_struct();
  }
#line 1128
  return (tmp == 0);
}
}
#line 1132 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_spin_is_contended_siglock_of_sighand_struct(void) 
{ 
  int is_spin_contended ;

  {
  {
#line 1137
  is_spin_contended = ldv_undef_int();
  }
#line 1140
  if (is_spin_contended != 0) {
#line 1142
    return (0);
  } else {
#line 1146
    return (1);
  }
}
}
#line 1151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_linux_kernel_locking_spinlock_atomic_dec_and_lock_siglock_of_sighand_struct(void) 
{ 
  int atomic_value_after_dec ;

  {
  {
#line 1156
  ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1158
  ldv_assume(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
#line 1161
  atomic_value_after_dec = ldv_undef_int();
  }
#line 1164
  if (atomic_value_after_dec == 0) {
#line 1166
    ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct = 2;
#line 1168
    return (1);
  } else {

  }
#line 1172
  return (0);
}
}
#line 1175 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
void ldv_linux_kernel_locking_spinlock_check_final_state(void) 
{ 


  {
  {
#line 1178
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 1);
#line 1180
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 1);
#line 1182
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock == 1);
#line 1184
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 1);
#line 1186
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 1);
#line 1188
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 1);
#line 1190
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_ptl == 1);
#line 1192
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 1);
#line 1194
  ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 1);
  }
#line 1195
  return;
}
}
#line 1198 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/locking/spinlock.c"
int ldv_exclusive_spin_is_locked(void) 
{ 


  {
#line 1201
  if (ldv_linux_kernel_locking_spinlock_spin_alloc_lock_of_task_struct == 2) {
#line 1203
    return (1);
  } else {

  }
#line 1206
  if (ldv_linux_kernel_locking_spinlock_spin_i_lock_of_inode == 2) {
#line 1208
    return (1);
  } else {

  }
#line 1211
  if (ldv_linux_kernel_locking_spinlock_spin_lock == 2) {
#line 1213
    return (1);
  } else {

  }
#line 1216
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_NOT_ARG_SIGN == 2) {
#line 1218
    return (1);
  } else {

  }
#line 1221
  if (ldv_linux_kernel_locking_spinlock_spin_lock_of_hwif_s == 2) {
#line 1223
    return (1);
  } else {

  }
#line 1226
  if (ldv_linux_kernel_locking_spinlock_spin_node_size_lock_of_pglist_data == 2) {
#line 1228
    return (1);
  } else {

  }
#line 1231
  if (ldv_linux_kernel_locking_spinlock_spin_ptl == 2) {
#line 1233
    return (1);
  } else {

  }
#line 1236
  if (ldv_linux_kernel_locking_spinlock_spin_queue_lock_of_request_queue == 2) {
#line 1238
    return (1);
  } else {

  }
#line 1241
  if (ldv_linux_kernel_locking_spinlock_spin_siglock_of_sighand_struct == 2) {
#line 1243
    return (1);
  } else {

  }
#line 1246
  return (0);
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/completion.linux_kernel_sched_completion.bk.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) ;
#line 2
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) ;
#line 27 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/sched/completion.c"
static int ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_hwif_s  =    0;
#line 30 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_gendev_rel_comp_of_hwif_s(void) 
{ 


  {
#line 33
  ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_hwif_s = 1;
#line 34
  return;
}
}
#line 37 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_macro_gendev_rel_comp_of_hwif_s(void) 
{ 


  {
  {
#line 40
  ldv_assert_linux_kernel_sched_completion__double_init(ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_hwif_s != 0);
#line 42
  ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_hwif_s = 1;
  }
#line 43
  return;
}
}
#line 46 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_wait_for_completion_gendev_rel_comp_of_hwif_s(void) 
{ 


  {
  {
#line 49
  ldv_assert_linux_kernel_sched_completion__wait_without_init(ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_hwif_s != 0);
#line 51
  ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_hwif_s = 2;
  }
#line 52
  return;
}
}
#line 54 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/sched/completion.c"
static int ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_ide_drive_s  =    0;
#line 57 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_gendev_rel_comp_of_ide_drive_s(void) 
{ 


  {
#line 60
  ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_ide_drive_s = 1;
#line 61
  return;
}
}
#line 64 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_init_completion_macro_gendev_rel_comp_of_ide_drive_s(void) 
{ 


  {
  {
#line 67
  ldv_assert_linux_kernel_sched_completion__double_init(ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_ide_drive_s != 0);
#line 69
  ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_ide_drive_s = 1;
  }
#line 70
  return;
}
}
#line 73 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/kernel/sched/completion.c"
void ldv_linux_kernel_sched_completion_wait_for_completion_gendev_rel_comp_of_ide_drive_s(void) 
{ 


  {
  {
#line 76
  ldv_assert_linux_kernel_sched_completion__wait_without_init(ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_ide_drive_s != 0);
#line 78
  ldv_linux_kernel_sched_completion_completion_gendev_rel_comp_of_ide_drive_s = 2;
  }
#line 79
  return;
}
}
#line 1 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/rsg/models/idr.linux_lib_idr.bk.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) ;
#line 2
void ldv_assert_linux_lib_idr__double_init(int expr ) ;
#line 3
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) ;
#line 4
void ldv_assert_linux_lib_idr__not_initialized(int expr ) ;
#line 29 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/lib/idr.c"
static int ldv_linux_lib_idr_idr  =    0;
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_init(void) 
{ 


  {
  {
#line 35
  ldv_assert_linux_lib_idr__double_init(ldv_linux_lib_idr_idr == 0);
#line 37
  ldv_linux_lib_idr_idr = 1;
  }
#line 38
  return;
}
}
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_alloc(void) 
{ 


  {
  {
#line 44
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 46
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 48
  ldv_linux_lib_idr_idr = 2;
  }
#line 49
  return;
}
}
#line 52 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_find(void) 
{ 


  {
  {
#line 55
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 57
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 59
  ldv_linux_lib_idr_idr = 2;
  }
#line 60
  return;
}
}
#line 63 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_remove(void) 
{ 


  {
  {
#line 66
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 68
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 70
  ldv_linux_lib_idr_idr = 2;
  }
#line 71
  return;
}
}
#line 74 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_idr_destroy(void) 
{ 


  {
  {
#line 77
  ldv_assert_linux_lib_idr__not_initialized(ldv_linux_lib_idr_idr != 0);
#line 79
  ldv_assert_linux_lib_idr__destroyed_before_usage(ldv_linux_lib_idr_idr != 3);
#line 81
  ldv_linux_lib_idr_idr = 3;
  }
#line 82
  return;
}
}
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/avtg/drivers/ide/ide-core.ko/linux::united/tr/linux/lib/idr.c"
void ldv_linux_lib_idr_check_final_state(void) 
{ 


  {
  {
#line 88
  ldv_assert_linux_lib_idr__more_at_exit(ldv_linux_lib_idr_idr == 0 || ldv_linux_lib_idr_idr == 3);
  }
#line 89
  return;
}
}
#line 2 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
extern void __VERIFIER_error_linux_net_rtnetlink(void) ;
#line 3 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_lock(int expr ) 
{ 


  {
#line 4
  if (! expr) {
    {
#line 5
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 6
  return;
}
}
#line 7 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__lock_on_exit(int expr ) 
{ 


  {
#line 8
  if (! expr) {
    {
#line 9
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 10
  return;
}
}
#line 11 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_rtnetlink__double_unlock(int expr ) 
{ 


  {
#line 12
  if (! expr) {
    {
#line 13
    __VERIFIER_error_linux_net_rtnetlink();
    }
  } else {

  }
#line 14
  return;
}
}
#line 15
extern void __VERIFIER_error_linux_kernel_locking_rwlock(void) ;
#line 16 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_on_write_lock(int expr ) 
{ 


  {
#line 17
  if (! expr) {
    {
#line 18
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 19
  return;
}
}
#line 20 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__more_read_unlocks(int expr ) 
{ 


  {
#line 21
  if (! expr) {
    {
#line 22
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 23
  return;
}
}
#line 24 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__read_lock_at_exit(int expr ) 
{ 


  {
#line 25
  if (! expr) {
    {
#line 26
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 27
  return;
}
}
#line 28 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_lock(int expr ) 
{ 


  {
#line 29
  if (! expr) {
    {
#line 30
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 31
  return;
}
}
#line 32 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__double_write_unlock(int expr ) 
{ 


  {
#line 33
  if (! expr) {
    {
#line 34
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 35
  return;
}
}
#line 36 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_rwlock__write_lock_at_exit(int expr ) 
{ 


  {
#line 37
  if (! expr) {
    {
#line 38
    __VERIFIER_error_linux_kernel_locking_rwlock();
    }
  } else {

  }
#line 39
  return;
}
}
#line 40
extern void __VERIFIER_error_linux_lib_idr(void) ;
#line 41 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__double_init(int expr ) 
{ 


  {
#line 42
  if (! expr) {
    {
#line 43
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 44
  return;
}
}
#line 45 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__not_initialized(int expr ) 
{ 


  {
#line 46
  if (! expr) {
    {
#line 47
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 48
  return;
}
}
#line 49 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__destroyed_before_usage(int expr ) 
{ 


  {
#line 50
  if (! expr) {
    {
#line 51
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 52
  return;
}
}
#line 53 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_idr__more_at_exit(int expr ) 
{ 


  {
#line 54
  if (! expr) {
    {
#line 55
    __VERIFIER_error_linux_lib_idr();
    }
  } else {

  }
#line 56
  return;
}
}
#line 57
extern void __VERIFIER_error_linux_kernel_sched_completion(void) ;
#line 58 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__double_init(int expr ) 
{ 


  {
#line 59
  if (! expr) {
    {
#line 60
    __VERIFIER_error_linux_kernel_sched_completion();
    }
  } else {

  }
#line 61
  return;
}
}
#line 62 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_sched_completion__wait_without_init(int expr ) 
{ 


  {
#line 63
  if (! expr) {
    {
#line 64
    __VERIFIER_error_linux_kernel_sched_completion();
    }
  } else {

  }
#line 65
  return;
}
}
#line 66
extern void __VERIFIER_error_linux_net_register(void) ;
#line 67 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_register__wrong_return_value(int expr ) 
{ 


  {
#line 68
  if (! expr) {
    {
#line 69
    __VERIFIER_error_linux_net_register();
    }
  } else {

  }
#line 70
  return;
}
}
#line 71
extern void __VERIFIER_error_linux_fs_char_dev(void) ;
#line 72 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_registration(int expr ) 
{ 


  {
#line 73
  if (! expr) {
    {
#line 74
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 75
  return;
}
}
#line 76 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__double_deregistration(int expr ) 
{ 


  {
#line 77
  if (! expr) {
    {
#line 78
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 79
  return;
}
}
#line 80 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_char_dev__registered_at_exit(int expr ) 
{ 


  {
#line 81
  if (! expr) {
    {
#line 82
    __VERIFIER_error_linux_fs_char_dev();
    }
  } else {

  }
#line 83
  return;
}
}
#line 84
extern void __VERIFIER_error_linux_kernel_rcu_srcu(void) ;
#line 85 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__more_unlocks(int expr ) 
{ 


  {
#line 86
  if (! expr) {
    {
#line 87
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 88
  return;
}
}
#line 89 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_read_section(int expr ) 
{ 


  {
#line 90
  if (! expr) {
    {
#line 91
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 92
  return;
}
}
#line 93 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_srcu__locked_at_exit(int expr ) 
{ 


  {
#line 94
  if (! expr) {
    {
#line 95
    __VERIFIER_error_linux_kernel_rcu_srcu();
    }
  } else {

  }
#line 96
  return;
}
}
#line 97
extern void __VERIFIER_error_linux_kernel_module(void) ;
#line 98 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__less_initial_decrement(int expr ) 
{ 


  {
#line 99
  if (! expr) {
    {
#line 100
    __VERIFIER_error_linux_kernel_module();
    }
  } else {

  }
#line 101
  return;
}
}
#line 102 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_module__more_initial_at_exit(int expr ) 
{ 


  {
#line 103
  if (! expr) {
    {
#line 104
    __VERIFIER_error_linux_kernel_module();
    }
  } else {

  }
#line 105
  return;
}
}
#line 106
extern void __VERIFIER_error_linux_alloc_spinlock(void) ;
#line 107 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__wrong_flags(int expr ) 
{ 


  {
#line 108
  if (! expr) {
    {
#line 109
    __VERIFIER_error_linux_alloc_spinlock();
    }
  } else {

  }
#line 110
  return;
}
}
#line 111 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_spinlock__nonatomic(int expr ) 
{ 


  {
#line 112
  if (! expr) {
    {
#line 113
    __VERIFIER_error_linux_alloc_spinlock();
    }
  } else {

  }
#line 114
  return;
}
}
#line 115
extern void __VERIFIER_error_linux_lib_find_bit(void) ;
#line 116 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_lib_find_bit__offset_out_of_range(int expr ) 
{ 


  {
#line 117
  if (! expr) {
    {
#line 118
    __VERIFIER_error_linux_lib_find_bit();
    }
  } else {

  }
#line 119
  return;
}
}
#line 120
extern void __VERIFIER_error_linux_mmc_sdio_func(void) ;
#line 121 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__wrong_params(int expr ) 
{ 


  {
#line 122
  if (! expr) {
    {
#line 123
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 124
  return;
}
}
#line 125 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__double_claim(int expr ) 
{ 


  {
#line 126
  if (! expr) {
    {
#line 127
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 128
  return;
}
}
#line 129 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__release_without_claim(int expr ) 
{ 


  {
#line 130
  if (! expr) {
    {
#line 131
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 132
  return;
}
}
#line 133 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_mmc_sdio_func__unreleased_at_exit(int expr ) 
{ 


  {
#line 134
  if (! expr) {
    {
#line 135
    __VERIFIER_error_linux_mmc_sdio_func();
    }
  } else {

  }
#line 136
  return;
}
}
#line 137
extern void __VERIFIER_error_linux_usb_coherent(void) ;
#line 138 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__less_initial_decrement(int expr ) 
{ 


  {
#line 139
  if (! expr) {
    {
#line 140
    __VERIFIER_error_linux_usb_coherent();
    }
  } else {

  }
#line 141
  return;
}
}
#line 142 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_coherent__more_initial_at_exit(int expr ) 
{ 


  {
#line 143
  if (! expr) {
    {
#line 144
    __VERIFIER_error_linux_usb_coherent();
    }
  } else {

  }
#line 145
  return;
}
}
#line 146
extern void __VERIFIER_error_linux_kernel_rcu_update_lock(void) ;
#line 147 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__more_unlocks(int expr ) 
{ 


  {
#line 148
  if (! expr) {
    {
#line 149
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 150
  return;
}
}
#line 151 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_read_section(int expr ) 
{ 


  {
#line 152
  if (! expr) {
    {
#line 153
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 154
  return;
}
}
#line 155 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock__locked_at_exit(int expr ) 
{ 


  {
#line 156
  if (! expr) {
    {
#line 157
    __VERIFIER_error_linux_kernel_rcu_update_lock();
    }
  } else {

  }
#line 158
  return;
}
}
#line 159
extern void __VERIFIER_error_linux_net_sock(void) ;
#line 160 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__all_locked_sockets_must_be_released(int expr ) 
{ 


  {
#line 161
  if (! expr) {
    {
#line 162
    __VERIFIER_error_linux_net_sock();
    }
  } else {

  }
#line 163
  return;
}
}
#line 164 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_net_sock__double_release(int expr ) 
{ 


  {
#line 165
  if (! expr) {
    {
#line 166
    __VERIFIER_error_linux_net_sock();
    }
  } else {

  }
#line 167
  return;
}
}
#line 168
extern void __VERIFIER_error_linux_kernel_rcu_update_lock_bh(void) ;
#line 169 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__more_unlocks(int expr ) 
{ 


  {
#line 170
  if (! expr) {
    {
#line 171
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 172
  return;
}
}
#line 173 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_read_section(int expr ) 
{ 


  {
#line 174
  if (! expr) {
    {
#line 175
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 176
  return;
}
}
#line 177 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_bh__locked_at_exit(int expr ) 
{ 


  {
#line 178
  if (! expr) {
    {
#line 179
    __VERIFIER_error_linux_kernel_rcu_update_lock_bh();
    }
  } else {

  }
#line 180
  return;
}
}
#line 181
extern void __VERIFIER_error_linux_usb_dev(void) ;
#line 182 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__unincremented_counter_decrement(int expr ) 
{ 


  {
#line 183
  if (! expr) {
    {
#line 184
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 185
  return;
}
}
#line 186 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__less_initial_decrement(int expr ) 
{ 


  {
#line 187
  if (! expr) {
    {
#line 188
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 189
  return;
}
}
#line 190 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__more_initial_at_exit(int expr ) 
{ 


  {
#line 191
  if (! expr) {
    {
#line 192
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 193
  return;
}
}
#line 194 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_dev__probe_failed(int expr ) 
{ 


  {
#line 195
  if (! expr) {
    {
#line 196
    __VERIFIER_error_linux_usb_dev();
    }
  } else {

  }
#line 197
  return;
}
}
#line 198
extern void __VERIFIER_error_linux_kernel_locking_mutex(void) ;
#line 199 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock(int expr ) 
{ 


  {
#line 200
  if (! expr) {
    {
#line 201
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 202
  return;
}
}
#line 203 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 204
  if (! expr) {
    {
#line 205
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 206
  return;
}
}
#line 207 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_double_unlock(int expr ) 
{ 


  {
#line 208
  if (! expr) {
    {
#line 209
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 210
  return;
}
}
#line 211 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_mutex__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 212
  if (! expr) {
    {
#line 213
    __VERIFIER_error_linux_kernel_locking_mutex();
    }
  } else {

  }
#line 214
  return;
}
}
#line 215
extern void __VERIFIER_error_linux_usb_gadget(void) ;
#line 216 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 217
  if (! expr) {
    {
#line 218
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 219
  return;
}
}
#line 220 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__class_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 221
  if (! expr) {
    {
#line 222
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 223
  return;
}
}
#line 224 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_registration_with_usb_gadget(int expr ) 
{ 


  {
#line 225
  if (! expr) {
    {
#line 226
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 227
  return;
}
}
#line 228 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__chrdev_deregistration_with_usb_gadget(int expr ) 
{ 


  {
#line 229
  if (! expr) {
    {
#line 230
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 231
  return;
}
}
#line 232 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_registration(int expr ) 
{ 


  {
#line 233
  if (! expr) {
    {
#line 234
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 235
  return;
}
}
#line 236 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__double_usb_gadget_deregistration(int expr ) 
{ 


  {
#line 237
  if (! expr) {
    {
#line 238
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 239
  return;
}
}
#line 240 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_gadget__usb_gadget_registered_at_exit(int expr ) 
{ 


  {
#line 241
  if (! expr) {
    {
#line 242
    __VERIFIER_error_linux_usb_gadget();
    }
  } else {

  }
#line 243
  return;
}
}
#line 244
extern void __VERIFIER_error_linux_alloc_usb_lock(void) ;
#line 245 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__wrong_flags(int expr ) 
{ 


  {
#line 246
  if (! expr) {
    {
#line 247
    __VERIFIER_error_linux_alloc_usb_lock();
    }
  } else {

  }
#line 248
  return;
}
}
#line 249 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_usb_lock__nonatomic(int expr ) 
{ 


  {
#line 250
  if (! expr) {
    {
#line 251
    __VERIFIER_error_linux_alloc_usb_lock();
    }
  } else {

  }
#line 252
  return;
}
}
#line 253
extern void __VERIFIER_error_linux_block_request(void) ;
#line 254 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_get(int expr ) 
{ 


  {
#line 255
  if (! expr) {
    {
#line 256
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 257
  return;
}
}
#line 258 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__double_put(int expr ) 
{ 


  {
#line 259
  if (! expr) {
    {
#line 260
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 261
  return;
}
}
#line 262 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_request__get_at_exit(int expr ) 
{ 


  {
#line 263
  if (! expr) {
    {
#line 264
    __VERIFIER_error_linux_block_request();
    }
  } else {

  }
#line 265
  return;
}
}
#line 266
extern void __VERIFIER_error_linux_alloc_irq(void) ;
#line 267 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__wrong_flags(int expr ) 
{ 


  {
#line 268
  if (! expr) {
    {
#line 269
    __VERIFIER_error_linux_alloc_irq();
    }
  } else {

  }
#line 270
  return;
}
}
#line 271 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_alloc_irq__nonatomic(int expr ) 
{ 


  {
#line 272
  if (! expr) {
    {
#line 273
    __VERIFIER_error_linux_alloc_irq();
    }
  } else {

  }
#line 274
  return;
}
}
#line 275
extern void __VERIFIER_error_linux_drivers_base_class(void) ;
#line 276 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_registration(int expr ) 
{ 


  {
#line 277
  if (! expr) {
    {
#line 278
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 279
  return;
}
}
#line 280 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__double_deregistration(int expr ) 
{ 


  {
#line 281
  if (! expr) {
    {
#line 282
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 283
  return;
}
}
#line 284 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_drivers_base_class__registered_at_exit(int expr ) 
{ 


  {
#line 285
  if (! expr) {
    {
#line 286
    __VERIFIER_error_linux_drivers_base_class();
    }
  } else {

  }
#line 287
  return;
}
}
#line 288
extern void __VERIFIER_error_linux_block_queue(void) ;
#line 289 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__double_allocation(int expr ) 
{ 


  {
#line 290
  if (! expr) {
    {
#line 291
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 292
  return;
}
}
#line 293 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__use_before_allocation(int expr ) 
{ 


  {
#line 294
  if (! expr) {
    {
#line 295
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 296
  return;
}
}
#line 297 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_queue__more_initial_at_exit(int expr ) 
{ 


  {
#line 298
  if (! expr) {
    {
#line 299
    __VERIFIER_error_linux_block_queue();
    }
  } else {

  }
#line 300
  return;
}
}
#line 301
extern void __VERIFIER_error_linux_block_genhd(void) ;
#line 302 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__double_allocation(int expr ) 
{ 


  {
#line 303
  if (! expr) {
    {
#line 304
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 305
  return;
}
}
#line 306 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__use_before_allocation(int expr ) 
{ 


  {
#line 307
  if (! expr) {
    {
#line 308
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 309
  return;
}
}
#line 310 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__delete_before_add(int expr ) 
{ 


  {
#line 311
  if (! expr) {
    {
#line 312
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 313
  return;
}
}
#line 314 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__free_before_allocation(int expr ) 
{ 


  {
#line 315
  if (! expr) {
    {
#line 316
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 317
  return;
}
}
#line 318 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_block_genhd__more_initial_at_exit(int expr ) 
{ 


  {
#line 319
  if (! expr) {
    {
#line 320
    __VERIFIER_error_linux_block_genhd();
    }
  } else {

  }
#line 321
  return;
}
}
#line 322
extern void __VERIFIER_error_linux_arch_io(void) ;
#line 323 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__less_initial_decrement(int expr ) 
{ 


  {
#line 324
  if (! expr) {
    {
#line 325
    __VERIFIER_error_linux_arch_io();
    }
  } else {

  }
#line 326
  return;
}
}
#line 327 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_arch_io__more_initial_at_exit(int expr ) 
{ 


  {
#line 328
  if (! expr) {
    {
#line 329
    __VERIFIER_error_linux_arch_io();
    }
  } else {

  }
#line 330
  return;
}
}
#line 331
extern void __VERIFIER_error_linux_usb_register(void) ;
#line 332 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_register__wrong_return_value(int expr ) 
{ 


  {
#line 333
  if (! expr) {
    {
#line 334
    __VERIFIER_error_linux_usb_register();
    }
  } else {

  }
#line 335
  return;
}
}
#line 336
extern void __VERIFIER_error_linux_fs_sysfs(void) ;
#line 337 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__less_initial_decrement(int expr ) 
{ 


  {
#line 338
  if (! expr) {
    {
#line 339
    __VERIFIER_error_linux_fs_sysfs();
    }
  } else {

  }
#line 340
  return;
}
}
#line 341 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_fs_sysfs__more_initial_at_exit(int expr ) 
{ 


  {
#line 342
  if (! expr) {
    {
#line 343
    __VERIFIER_error_linux_fs_sysfs();
    }
  } else {

  }
#line 344
  return;
}
}
#line 345
extern void __VERIFIER_error_linux_kernel_locking_spinlock(void) ;
#line 346 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock(int expr ) 
{ 


  {
#line 347
  if (! expr) {
    {
#line 348
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 349
  return;
}
}
#line 350 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_lock_try(int expr ) 
{ 


  {
#line 351
  if (! expr) {
    {
#line 352
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 353
  return;
}
}
#line 354 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_double_unlock(int expr ) 
{ 


  {
#line 355
  if (! expr) {
    {
#line 356
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 357
  return;
}
}
#line 358 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_locking_spinlock__one_thread_locked_at_exit(int expr ) 
{ 


  {
#line 359
  if (! expr) {
    {
#line 360
    __VERIFIER_error_linux_kernel_locking_spinlock();
    }
  } else {

  }
#line 361
  return;
}
}
#line 362
extern void __VERIFIER_error_linux_usb_urb(void) ;
#line 363 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__less_initial_decrement(int expr ) 
{ 


  {
#line 364
  if (! expr) {
    {
#line 365
    __VERIFIER_error_linux_usb_urb();
    }
  } else {

  }
#line 366
  return;
}
}
#line 367 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_usb_urb__more_initial_at_exit(int expr ) 
{ 


  {
#line 368
  if (! expr) {
    {
#line 369
    __VERIFIER_error_linux_usb_urb();
    }
  } else {

  }
#line 370
  return;
}
}
#line 371
extern void __VERIFIER_error_linux_kernel_rcu_update_lock_sched(void) ;
#line 372 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__more_unlocks(int expr ) 
{ 


  {
#line 373
  if (! expr) {
    {
#line 374
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 375
  return;
}
}
#line 376 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_read_section(int expr ) 
{ 


  {
#line 377
  if (! expr) {
    {
#line 378
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 379
  return;
}
}
#line 380 "/home/ubuntu/klever-work/native-scheduler-work-dir/scheduler/jobs/52932560210082014fc0d2c97903306e/klever-core-work-dir/vtg/drivers/ide/ide-core.ko/linux::united/mbt/bug kind funcs.c"
void ldv_assert_linux_kernel_rcu_update_lock_sched__locked_at_exit(int expr ) 
{ 


  {
#line 381
  if (! expr) {
    {
#line 382
    __VERIFIER_error_linux_kernel_rcu_update_lock_sched();
    }
  } else {

  }
#line 383
  return;
}
}
